rollerAddress.DriveControl,
                                fdoExtension->DriveControlImage );

                            if ( fdoExtension->LastMotorSettleTime.QuadPart > 0) {

                                KeDelayExecutionThread( KernelMode,
                                                        FALSE,
                                                        &fdoExtension->LastMotorSettleTime );
                            }
                        }

                        fdoExtension->CurrentPowerState = newState.DeviceState;

                        //
                        //  Set a flag to simulate a disk change event so that
                        //  we will be sure to touch the floppy drive hardware
                        //  the next time it is accessed in case it was removed.
                        //
                        fdoExtension->WakeUp = TRUE;

                        PoStartNextPowerIrp( Irp );
                        IoCompleteRequest( Irp, IO_NO_INCREMENT );


                        //
                        // Process any requests that were queued in PowerQueue
                        // when the device was in D3 state.
                        //
                        FdcFdoInternalDeviceControl(fdoExtension->Self,
                                                    NULL);

                    }
                }


                //
                //  Page out the driver if it is not busy elsewhere.
                //
                //  FDC_PAGE_ENTIRE_DRIVER_WITH_MUTEX;

                break;
            }

            case IRP_MN_WAIT_WAKE:
            case IRP_MN_POWER_SEQUENCE:
            case IRP_MN_QUERY_POWER: {
                // 
                // Fall through
                //
            }

            default: {
                FdcDump( FDCPOWER, ("FdcPower: non-IRP_MN_SET_POWER %x\n",
                                    irpSp->MinorFunction));

                //
                //  Just forward this irp to the underlying device.
                //
                IoMarkIrpPending(Irp);
                PoStartNextPowerIrp( Irp );
                IoSkipCurrentIrpStackLocation( Irp );
                PoCallDriver(fdoExtension->TargetObject, Irp );

                ntStatus = STATUS_PENDING;

                break;

            }

            }  // switch ( irpSp->MinorFunction ) 
        }

    } else {

        FdcDump( FDCPOWER, ("FdcPower: In PDO - complete request\n"));

        //
        //  We are not yet doing any power management on the floppy controller.
        //
        switch (irpSp->MinorFunction) {
            case IRP_MN_SET_POWER:
            case IRP_MN_QUERY_POWER: {
                Irp->IoStatus.Status = STATUS_SUCCESS;
                break;
            }

            case IRP_MN_WAIT_WAKE:
            case IRP_MN_POWER_SEQUENCE:
            default: {
                break;
            }
        }

        PoStartNextPowerIrp( Irp );
        ntStatus = Irp->IoStatus.Status;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return ntStatus;
}

VOID
FdcSystemPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PFDC_FDO_EXTENSION fdoExtension;
    PIRP irp = (PIRP) Context;
    NTSTATUS status = IoStatus->Status;
    
    FdcDump( FDCPOWER, ("FdcSystemPowerCompletionRoutine - Irp 0x%x\n",
                        irp));

    fdoExtension = DeviceObject->DeviceExtension;

    irp->IoStatus.Status = status;

    PoStartNextPowerIrp(irp);

    if (NT_SUCCESS(status)) {
        IoSkipCurrentIrpStackLocation(irp);
        PoCallDriver( fdoExtension->TargetObject, irp );
    } else {
        FdcDump( FDCPOWER, ("Device power irp failed. Status 0x%x\n",
                            status));
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }
}

NTSTATUS
FdcStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine attempts to start the floppy controller device.  Starting
    the floppy controller consists primarily of resetting it and configuring
    it, mostly just to make sure that it is there.

Arguments:

    DeviceObject - a pointer to the device object being started.
    Irp - a pointer to the start device Irp.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFDC_FDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpSp;

    BOOLEAN foundPortA = FALSE;
    BOOLEAN foundPortB = FALSE;
    BOOLEAN foundDma = FALSE;
    BOOLEAN foundInterrupt = FALSE;
    ULONG currentBase = 0xFFFFFFFF;

    PCM_RESOURCE_LIST translatedResources;
    PCM_FULL_RESOURCE_DESCRIPTOR fullList;
    PCM_PARTIAL_RESOURCE_LIST partialList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    ULONG i;
    ULONG startOffset;
    ULONG currentOffset;

    UCHAR ioPortMap;

    fdoExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Ask the PDO if it is a tape enabler device and, if so, what
    //  is the enabler device object.
    //
    FdcGetEnablerDevice( fdoExtension );

    if ( fdoExtension->FdcEnablerSupported ) {
#if defined(NO_LEGACY_DRIVERS)
        ntStatus = STATUS_OBJECT_NAME_NOT_FOUND;
#else


        INTERFACE_TYPE InterfaceType;

        //
        //  This is a tape enabler card so we need to get the resources
        //  'the old-fashinoed way'.
        //
        for ( InterfaceType = 0;
              InterfaceType < MaximumInterfaceType;
              InterfaceType++ ) {

            CONFIGURATION_TYPE Dc = DiskController;

            ntStatus = IoQueryDeviceDescription( &InterfaceType,
                                                 NULL,
                                                 &Dc,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 FdcFdoConfigCallBack,
                                                 fdoExtension );

            if (!NT_SUCCESS(ntStatus) && (ntStatus != STATUS_OBJECT_NAME_NOT_FOUND)) {

                return ntStatus;
            }
        }

        if ( fdoExtension->FdcEnablerDeviceObject == NULL ) {

            ntStatus = STATUS_OBJECT_NAME_NOT_FOUND;

        } else {

            ntStatus = STATUS_SUCCESS;
        }
#endif // NO_LEGACY_DRIVERS
    } else {

        //
        //  Now that the PDO is done with the Irp we can have our way with
        //  it.
        //
        FdcDump( FDCPNP, ("AllocatedResources = %p\n", irpSp->Parameters.StartDevice.AllocatedResources) );
        FdcDump( FDCPNP, ("AllocatedResourcesTranslated = %p\n", irpSp->Parameters.StartDevice.AllocatedResourcesTranslated) );

        if ( irpSp->Parameters.StartDevice.AllocatedResources == NULL ||
             irpSp->Parameters.StartDevice.AllocatedResourcesTranslated == NULL ) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Set up the resource information that we will use to access the
        //  controller hardware.  We always expect only 1 full set of resources.
        //  In that list we expect a DMA channel, an Interrupt vector, and 2 I/O Port
        //  ranges.  If we don't see all the required resources we will woof.
        //
        translatedResources = irpSp->Parameters.StartDevice.AllocatedResourcesTranslated;

        ASSERT( translatedResources->Count == 1 );

        fullList = &translatedResources->List[0];
        partialList = &translatedResources->List[0].PartialResourceList;

        //
        //  Enumerate the list of resources, adding them into our context as we go.
        //
        RtlZeroMemory( &fdoExtension->ControllerAddress, sizeof(CONTROLLER) );

        for ( i = 0; i < partialList->Count; i++ ) {

            partial = &partialList->PartialDescriptors[i];

            switch ( partial->Type ) {

            case CmResourceTypePort: {
                //
                //  If we get a base address that is lower than anything we have seen
                //  before, we assume that we have been working with aliased addresses
                //  and start over with the new base address.
                //
                if ( (partial->u.Port.Start.LowPart & 0xFFFFFFF8) < currentBase ) {

                    RtlZeroMemory( &fdoExtension->ControllerAddress, sizeof(CONTROLLER) );
                    currentBase = partial->u.Port.Start.LowPart & 0xFFFFFFF8;
                }

                //
                //  We only use resources that are associated with the current (lowest)
                //  base addressed.  All others are assumed to be aliased and are not
                //  used.
                //
                if ( (partial->u.Port.Start.LowPart & 0xFFFFFFF8) == currentBase ) {

                    FdcDump( FDCPNP,
                             ("FdcStartDevice: Adding - %04x, Length - %04x\n",
                             partial->u.Port.Start.LowPart,
                             partial->u.Port.Length) );

                    startOffset = partial->u.Port.Start.LowPart & 0x07;

                    if ( (partial->Flags & CM_RESOURCE_PORT_IO) == CM_RESOURCE_PORT_MEMORY ) {

                        fdoExtension->ControllerAddress.Address[startOffset] =
                            MmMapIoSpace( partial->u.Port.Start,
                                          partial->u.Port.Length,
                                          FALSE );

                        FdcDump( FDCPNP, ("FdcStartDevice: Mapped IoPort\n") );

                    } else {

                        fdoExtension->ControllerAddress.Address[startOffset] = (PUCHAR)(ULONG_PTR)partial->u.Port.Start.QuadPart;
                    }

                    currentOffset = 1;
                    while ( currentOffset < partial->u.Port.Length ) {

                        fdoExtension->ControllerAddress.Address[startOffset + currentOffset] =
                            fdoExtension->ControllerAddress.Address[startOffset] + currentOffset;
                        ++currentOffset;
                    }
                }

                break;
            }

            //
            // Handle memory mapped Port I/O
            //
            case CmResourceTypeMemory: {
                //
                //  If we get a base address that is lower than anything we have seen
                //  before, we assume that we have been working with aliased addresses
                //  and start over with the new base address.
                //
                if ( (partial->u.Memory.Start.LowPart & 0xFFFFFFF8) < currentBase ) {

                    RtlZeroMemory( &fdoExtension->ControllerAddress, sizeof(CONTROLLER) );
                    currentBase = partial->u.Memory.Start.LowPart & 0xFFFFFFF8;
                }

                //
                //  We only use resources that are associated with the current (lowest)
                //  base addressed.  All others are assumed to be aliased and are not
                //  used.
                //
                if ( (partial->u.Memory.Start.LowPart & 0xFFFFFFF8) == currentBase ) {

                    FdcDump( FDCPNP,
                             ("FdcStartDevice: Adding - %04x, Length - %04x\n",
                             partial->u.Memory.Start.LowPart,
                             partial->u.Memory.Length) );

                    startOffset = partial->u.Memory.Start.LowPart & 0x07;

                    fdoExtension->ControllerAddress.Address[startOffset] =
                            MmMapIoSpace( partial->u.Memory.Start,
                                          partial->u.Memory.Length,
                                          FALSE );

                    FdcDump( FDCPNP, ("FdcStartDevice: Mapped IoPort\n") );

                    currentOffset = 1;
                    while ( currentOffset < partial->u.Memory.Length ) {

                        fdoExtension->ControllerAddress.Address[startOffset + currentOffset] =
                            fdoExtension->ControllerAddress.Address[startOffset] + currentOffset;
                        ++currentOffset;
                    }
                }

                break;
            }
            
            case CmResourceTypeDma: {

                DEVICE_DESCRIPTION deviceDesc = {0};

                FdcDump( FDCPNP, ("FdcStartDevice: DMA - %04x\n", partial->u.Dma.Channel) );

                foundDma = TRUE;

                deviceDesc.Version = DEVICE_DESCRIPTION_VERSION1;

                if ( partial->u.Dma.Channel > 3 ) {
                    deviceDesc.DmaWidth = Width16Bits;
                } else {
                    deviceDesc.DmaWidth = Width8Bits;
                }

                deviceDesc.DemandMode    = TRUE;
                deviceDesc.MaximumLength = MAX_BYTES_PER_SECTOR * MAX_SECTORS_PER_TRACK;
                deviceDesc.IgnoreCount   = TRUE;

                //
                // Always ask for one more page than maximum transfer size.
                //
                deviceDesc.MaximumLength += PAGE_SIZE;

                deviceDesc.DmaChannel = partial->u.Dma.Channel;
                deviceDesc.InterfaceType = fullList->InterfaceType;
                deviceDesc.DmaSpeed = DEFAULT_DMA_SPEED;
                deviceDesc.AutoInitialize = FALSE;

                ASSERT(fdoExtension->UnderlyingPDO);

                fdoExtension->AdapterObject =
                    (PADAPTER_OBJECT)IoGetDmaAdapter(fdoExtension->UnderlyingPDO,
                                                     &deviceDesc,
                                                     &fdoExtension->NumberOfMapRegisters );

                if (!fdoExtension->AdapterObject) {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }

                //
                //  Here we can get another adapter object for formatting.  It
                //  should look the same as the previous one except AutoInitialize
                //  will be true.
                //
                break;
            }

            case CmResourceTypeInterrupt: {

                FdcDump( FDCPNP, ("FdcStartDevice: IRQ - %04x\n", partial->u.Interrupt.Vector) );

                foundInterrupt = TRUE;

                if ( partial->Flags & CM_RESOURCE_INTERRUPT_LATCHED) {

                    fdoExtension->InterruptMode = Latched;

                } else {

                    fdoExtension->InterruptMode = LevelSensitive;
                }

                fdoExtension->ControllerVector = partial->u.Interrupt.Vector;
                fdoExtension->ProcessorMask = partial->u.Interrupt.Affinity;
                fdoExtension->ControllerIrql = (KIRQL)partial->u.Interrupt.Level;               
                fdoExtension->SharableVector = TRUE;
                fdoExtension->SaveFloatState = FALSE;

                break;
            }

            default:

                break;
            }
        }

        FdcDump( FDCPNP, ("FdcStartDevice: ControllerAddress.StatusA      = %08x\n"
                          "FdcStartDevice: ControllerAddress.StatusB      = %08x\n"
                          "FdcStartDevice: ControllerAddress.DriveControl = %08x\n"
                          "FdcStartDevice: ControllerAddress.Tape         = %08x\n"
                          "FdcStartDevice: ControllerAddress.Status       = %08x\n"
                          "FdcStartDevice: ControllerAddress.Fifo         = %08x\n"
                          "FdcStartDevice: ControllerAddress.DRDC         = %08x\n",
                          fdoExtension->ControllerAddress.StatusA,
                          fdoExtension->ControllerAddress.StatusB,
                          fdoExtension->ControllerAddress.DriveControl,
                          fdoExtension->ControllerAddress.Tape,
                          fdoExtension->ControllerAddress.Status,
                          fdoExtension->ControllerAddress.Fifo,
                          fdoExtension->ControllerAddress.DRDC) );

        if ( !foundDma ||
             !foundInterrupt ||
             fdoExtension->ControllerAddress.DriveControl == NULL ||
             fdoExtension->ControllerAddress.Status == NULL ||
             fdoExtension->ControllerAddress.Fifo == NULL ||
             fdoExtension->ControllerAddress.DRDC.DataRate == NULL) {

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        if ( NT_SUCCESS(ntStatus) ) {
            //
            //  Set up the bus information since we know it now.
            //
            fdoExtension->BusType = fullList->InterfaceType;
            fdoExtension->BusNumber = fullList->BusNumber;
            fdoExtension->ProbeFloppyDevices = ProbeFloppyDevices;
        }
    }

    if ( NT_SUCCESS(ntStatus) ) {

        ntStatus = FdcInitializeDeviceObject( DeviceObject );

        //
        //  Connect the interrupt for the reset operation.
        //
        ntStatus = IoConnectInterrupt( &fdoExtension->InterruptObject,
                                       FdcInterruptService,
                                       fdoExtension,
                                       NULL,
                                       fdoExtension->ControllerVector,
                                       fdoExtension->ControllerIrql,
                                       fdoExtension->ControllerIrql,
                                       fdoExtension->InterruptMode,
                                       fdoExtension->SharableVector,
                                       fdoExtension->ProcessorMask,
                                       fdoExtension->SaveFloatState );

        FdcDump( FDCPNP, ("FdcStartDevice: IoConnectInterrupt - %08x\n", ntStatus) );

        fdoExtension->CurrentInterrupt = FALSE;

        if ( NT_SUCCESS(ntStatus) ) {

            //
            // Initialize (Reset) the controller hardware.  This will make
            // sure that the controller is really there and leave it in an
            // appropriate state for the rest of the system startup.
            //
            fdoExtension->AllowInterruptProcessing =
                    fdoExtension->CurrentInterrupt = TRUE;

            //
            // Acquire the Fdc Enabler card if there is one
            //
            if (fdoExtension->FdcEnablerSupported) {

                LARGE_INTEGER acquireTimeOut;

                acquireTimeOut.QuadPart = -(ONE_SECOND * 15);

                ntStatus = FcFdcEnabler( fdoExtension->FdcEnablerDeviceObject,
                                         IOCTL_ACQUIRE_FDC,
                                         &acquireTimeOut);
            }

            if ( NT_SUCCESS(ntStatus) ) {

                ntStatus = FcInitializeControllerHardware( fdoExtension,
                                                           DeviceObject );

                FdcDump( FDCPNP, ("FdcStartDevice: FcInitializeControllerHardware - %08x\n", ntStatus) );

                //
                // Free the tape accelerator card if it was used.
                //
                if (fdoExtension->FdcEnablerSupported) {

                    FcFdcEnabler( fdoExtension->FdcEnablerDeviceObject,
                                  IOCTL_RELEASE_FDC,
                                  NULL);
                }

                fdoExtension->CurrentInterrupt = FALSE;
            }

            if ( NT_SUCCESS( ntStatus ) ) {

                fdoExtension->HardwareFailed = FALSE;
                ntStatus = FcGetFdcInformation ( fdoExtension );

            } else {

                fdoExtension->HardwareFailed = TRUE;
            }

            IoDisconnectInterrupt(fdoExtension->InterruptObject);
        }

        if ( NT_SUCCESS(ntStatus) ) {

            //
            //  Preinit our ACPI data. We start out not knowing
            //      1 - is this an ACPI machine.
            //      2 - is the _FDE method supported by this BIOS.
            //      3 - what did _FDE enumerate.
            //
            // We pre-init ACPI data only on the first start irp.
            // We should not reset these fields if they've been set
            // already in FdcQueryDeviceRelations. This is to prevent loss
            // of information during rebalance.
            //
            if (!(fdoExtension->ACPI_BIOS)) {
               FdcDump(FDCSHOW,
                       ("Probably not an ACPI machine.\n"));
            }

            if (!(fdoExtension->ACPI_FDE_Valid)) {
               RtlZeroMemory(&fdoExtension->ACPI_FDE_Data, sizeof(ACPI_FDE_ENUM_TABLE));
            }

            fdoExtension->ACPI_FDE_Data.ACPI_Tape = TapeDontKnow;
        }

/*
        if( NT_SUCCESS( ntStatus ) &&
            (fdoExtension->ACPI_FDE_Data.ACPI_Tape == TapePresent ||
             fdoExtension->ACPI_FDE_Data.ACPI_Tape == TapeDontKnow) ) {

            //
            //  We will only attempt to allocate memory for and enumerate tape
            //  drives if we are not in setup mode and we have the tape mode
            //  register (0x3f3).
            //
#ifdef NOT_NOW
            if ( !FdcInSetupMode &&
                 fdoExtension->ControllerAddress.Tape != NULL ) {

                FcAllocateCommonBuffers( fdoExtension );
            }
#endif
        }
*/
    }

    Irp->IoStatus.Information = 0;

    return ntStatus;
}
NTSTATUS
FdcInitializeDeviceObject(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine initializes the DeviceObject resources.  DeviceObject resources
    only need to be initialized once, regardless of how many times this device
    is started.

Arguments:

    DeviceObject - a pointer to the device object being started.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFDC_FDO_EXTENSION fdoExtension;
    USHORT      motorControlData;

    FdcDump( FDCSHOW, ("FdcInitializeDeviceObject:\n") );
    fdoExtension = DeviceObject->DeviceExtension;

    if ( !fdoExtension->DeviceObjectInitialized ) {

        //
        // Set the time to wait for an interrupt before timing out to a
        // few seconds.
        //
        fdoExtension->InterruptDelay.QuadPart = -(ONE_SECOND * 4);

        //
        // Set the minimum time that we can delay (10ms according to system
        // rules).  This will be used when we have to delay to, say, wait
        // for the FIFO - the FIFO should become ready is well under 10ms.
        //
        fdoExtension->Minimum10msDelay.QuadPart = -(10 * 1000 * 10);

        //
        // Initialize the DPC structure in the device object, so that
        // the ISR can queue DPCs.
        //
        IoInitializeDpcRequest( fdoExtension->Self, FdcDeferredProcedure );

        //
        // Occasionally during stress we've seen the device lock up.
        // We create a dpc so that we can log that the device lock up
        // occured and that we reset the device.
        //
        KeInitializeDpc( &fdoExtension->LogErrorDpc,
                         FcLogErrorDpc,
                         fdoExtension );

        //
        // Assume there is a CONFIGURE command until found otherwise.
        // Other Booleans were zero-initialized to FALSE.
        //
        fdoExtension->ControllerConfigurable = NotConfigurable ? FALSE : TRUE;
        fdoExtension->Model30 = Model30 ? TRUE : FALSE;

        fdoExtension->AllowInterruptProcessing = TRUE;
        fdoExtension->CurrentInterrupt         = TRUE;
        fdoExtension->ControllerInUse          = FALSE;
        fdoExtension->CurrentIrp               = NULL;

        //
        // Start the timer
        //
        fdoExtension->InterruptTimer = CANCEL_TIMER;

        IoInitializeTimer( DeviceObject, FdcCheckTimer, fdoExtension );

        //
        // Initialize events to signal interrupts and adapter object
        // allocation
        //
        KeInitializeEvent( &fdoExtension->InterruptEvent,
                           SynchronizationEvent,
                           FALSE);

        KeInitializeEvent( &fdoExtension->AllocateAdapterChannelEvent,
                           NotificationEvent,
                           FALSE );

        fdoExtension->AdapterChannelRefCount = 0;

        KeInitializeEvent( &fdoExtension->AcquireEvent,
                           SynchronizationEvent,
                           TRUE );
    }

    fdoExtension->DeviceObjectInitialized = TRUE;

    return ntStatus;
}

#if !defined(NO_LEGACY_DRIVERS)

NTSTATUS
FdcFdoConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )
/*++

Routine Description:

    This routine is used to acquire all of the configuration
    information for a tape enabler if we ever find one.

Arguments:

    Context - Pointer to our FDO extension

    PathName - unicode registry path.  Not Used.

    BusType - Internal, Isa, ...

    BusNumber - Which bus if we are on a multibus system.

    BusInformation - Configuration information about the bus. Not Used.

    ControllerType - Should always be DiskController.

    ControllerNumber - Which controller if there is more than one
                       controller in the system.

    ControllerInformation - Array of pointers to the three pieces of
                            registry information.

    PeripheralType - Should always be FloppyDiskPeripheral.

    PeripheralNumber - Which floppy if this controller is maintaining
                       more than one.

    PeripheralInformation - Arrya of pointers to the three pieces of
                            registry information.

Return Value:

    STATUS_SUCCESS if everything went ok, or STATUS_INSUFFICIENT_RESOURCES
    if it couldn't map the base csr or acquire the adapter object, or
    all of the resource information couldn't be acquired.

--*/
{

    PFDC_FDO_EXTENSION fdoExtension = (PFDC_FDO_EXTENSION)Context;
    NTSTATUS ntStatus;
    UNICODE_STRING pdoName;
    PDEVICE_OBJECT newPdo;
    PFDC_PDO_EXTENSION pdoExtension;
    RTL_QUERY_REGISTRY_TABLE paramTable[2] = {0};
    ULONG apiSupported;
    WCHAR idstr[200] = {0};
    UNICODE_STRING str;
    USHORT i;
    BOOLEAN foundPort = FALSE;
    BOOLEAN foundInterrupt = FALSE;
    BOOLEAN foundDma = FALSE;

    FdcDump( FDCSHOW, ("FdcFdoConfigCallBack:\n") );

    //
    //  The first thing to do is to go out and look for an enabler.  We
    //  know we are dealing with one if there is a registry value called
    //  APISupported.
    //
    str.Length = 0;
    str.MaximumLength = 200;
    str.Buffer = idstr;

    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = L"APISupported";
    paramTable[0].EntryContext = &str;
    paramTable[0].DefaultType = REG_SZ;
    paramTable[0].DefaultData = L"";
    paramTable[0].DefaultLength = sizeof(WCHAR);

    ntStatus = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                       PathName->Buffer,
                                       &paramTable[0],
                                       NULL,
                                       NULL);
    if ( !NT_SUCCESS( ntStatus ) ) {
        str.Buffer[0] = 0;
    }

    if ( str.Buffer[0] != 0 ) {

        FdcDump( FDCINFO,
                 ("FdcFdoConfigCallBack: Got registry setting for EnablerAPI = %s\n",
                 str.Buffer) );

        ntStatus = IoGetDeviceObjectPointer( &str,
                                             FILE_READ_ACCESS,
                                             &fdoExtension->FdcEnablerFileObject,
                                             &fdoExtension->FdcEnablerDeviceObject);
    }

    if ( fdoExtension->FdcEnablerDeviceObject != NULL ) {

        PCM_FULL_RESOURCE_DESCRIPTOR controllerData =
            (PCM_FULL_RESOURCE_DESCRIPTOR)
            (((PUCHAR)ControllerInformation[IoQueryDeviceConfigurationData]) +
            ControllerInformation[IoQueryDeviceConfigurationData]->DataOffset);

        //
        // We have the pointer.  Save off the interface type and
        // the busnumber for use when we call the Hal and the
        // Io System.
        //
        fdoExtension->BusType = BusType;
        fdoExtension->BusNumber = BusNumber;
        fdoExtension->SharableVector = TRUE;
        fdoExtension->SaveFloatState = FALSE;

        //
        // We need to get the following information out of the partial
        // resource descriptors.
        //
        // The irql and vector.
        //
        // The dma channel.
        //
        // The base address and span covered by the floppy controllers
        // registers.
        //
        // It is not defined how these appear in the partial resource
        // lists, so we will just loop over all of them.  If we find
        // something we don't recognize, we drop that information on
        // the floor.  When we have finished going through all the
        // partial information, we validate that we got the above
        // three.
        //
        for ( i = 0;
              i < controllerData->PartialResourceList.Count;
              i++ ) {

            PCM_PARTIAL_RESOURCE_DESCRIPTOR partial =
                &controllerData->PartialResourceList.PartialDescriptors[i];

            switch ( partial->Type ) {

            case CmResourceTypePort: {

                foundPort = TRUE;

                //
                // Save of the pointer to the partial so
                // that we can later use it to report resources
                // and we can also use this later in the routine
                // to make sure that we got all of our resources.
                //
                fdoExtension->SpanOfControllerAddress = partial->u.Port.Length;
                fdoExtension->ControllerAddress.StatusA =
                    FdcGetControllerBase(
                        BusType,
                        BusNumber,
                        partial->u.Port.Start,
                        fdoExtension->SpanOfControllerAddress,
                        (BOOLEAN)!!partial->Flags );

                if ( fdoExtension->ControllerAddress.StatusA == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    fdoExtension->ControllerAddress.StatusB       = fdoExtension->ControllerAddress.StatusA + 1;
                    fdoExtension->ControllerAddress.DriveControl  = fdoExtension->ControllerAddress.StatusA + 2;
                    fdoExtension->ControllerAddress.Tape          = fdoExtension->ControllerAddress.StatusA + 3;
                    fdoExtension->ControllerAddress.Status        = fdoExtension->ControllerAddress.StatusA + 4;
                    fdoExtension->ControllerAddress.Fifo          = fdoExtension->ControllerAddress.StatusA + 5;
                    fdoExtension->ControllerAddress.DRDC.DataRate = fdoExtension->ControllerAddress.StatusA + 7;
                }

                break;
            }
            case CmResourceTypeInterrupt: {

                foundInterrupt = TRUE;

                if ( partial->Flags & CM_RESOURCE_INTERRUPT_LATCHED ) {

                    fdoExtension->InterruptMode = Latched;

                } else {

                    fdoExtension->InterruptMode = LevelSensitive;

                }

                fdoExtension->ControllerVector =
                    HalGetInterruptVector(
                        BusType,
                        BusNumber,
                        partial->u.Interrupt.Level,
                        partial->u.Interrupt.Vector,
                        &fdoExtension->ControllerIrql,
                        &fdoExtension->ProcessorMask
                        );

                break;
            }
            case CmResourceTypeDma: {

                DEVICE_DESCRIPTION deviceDesc = {0};

                //
                // Use IgnoreCount equal to TRUE to fix PS/1000.
                //
                foundDma = TRUE;

                deviceDesc.Version = DEVICE_DESCRIPTION_VERSION1;

                if ( partial->u.Dma.Channel > 3 ) {
                    deviceDesc.DmaWidth = Width16Bits;
                } else {
                    deviceDesc.DmaWidth = Width8Bits;
                }

                deviceDesc.DemandMode    = TRUE;
                deviceDesc.MaximumLength = MAX_BYTES_PER_SECTOR * MAX_SECTORS_PER_TRACK;
                deviceDesc.IgnoreCount   = TRUE;

                deviceDesc.DmaChannel = partial->u.Dma.Channel;
                deviceDesc.InterfaceType = BusType;
                deviceDesc.DmaSpeed = DEFAULT_DMA_SPEED;
                fdoExtension->AdapterObject =
                    (PADAPTER_OBJECT)IoGetDmaAdapter(fdoExtension->UnderlyingPDO,
                                                     &deviceDesc,
                                                     &fdoExtension->NumberOfMapRegisters
                                                     );

                if ( fdoExtension->AdapterObject == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
                break;
            }
            default:

                break;
            }
        }
        //
        // If we didn't get all the information then we return
        // insufficient resources.
        //
        if ( !foundPort || !foundInterrupt || !foundDma ) {

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    return ntStatus;
}

#endif // NO_LEGACY_DRIVERS

PVOID
FdcGetControllerBase(
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfBytes,
    BOOLEAN InIoSpace
    )
/*++

Routine Description:

    This routine maps an IO address to system address space.

Arguments:

    BusType - what type of bus - eisa, mca, isa
    IoBusNumber - which IO bus (for machines with multiple buses).
    IoAddress - base device address to be mapped.
    NumberOfBytes - number of bytes for which address is valid.
    InIoSpace - indicates an IO address.

Return Value:

    Mapped address

--*/
{
    PHYSICAL_ADDRESS cardAddress;
    ULONG addressSpace = InIoSpace;
    PVOID Address;

    if ( !HalTranslateBusAddress( BusType,
                                  BusNumber,
                                  IoAddress,
                                  &addressSpace,
                                  &cardAddress ) ){
        return NULL;
    }

    //
    // Map the device base address into the virtual address space
    // if the address is in memory space.
    //

    if ( !addressSpace ) {

        Address = MmMapIoSpace( cardAddress,
                                NumberOfBytes,
                                FALSE );

    } else {

        Address = (PCONTROLLER)(ULONG_PTR)cardAddress.QuadPart;
    }
    return Address;
}


NTSTATUS
FcInitializeControllerHardware(
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is called at initialization time by FcInitializeDevice()
    - once for each controller that we have to support.

    When this routine is called, the controller data structures have all
    been allocated.

Arguments:

    ControllerData - the completed data structure associated with the
    controller hardware being initialized.

    DeviceObject - a pointer to a device object; this routine will cause
    an interrupt, and the ISR requires CurrentDeviceObject to be filled
    in.

Return Value:

    STATUS_SUCCESS if this controller appears to have been reset properly,
    error otherwise.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    UCHAR statusRegister0;
    UCHAR cylinder;
    UCHAR driveNumber;
    UCHAR retrycnt;

    FdcDump( FDCSHOW, ("Fdc: FcInitializeControllerHardware...\n") );

    for (retrycnt = 0; ; retrycnt++) {

        //
        // Reset the controller.  This will cause an interrupt.  Reset
        // CurrentDeviceObject until after the 10ms wait, in case any
        // stray interrupts come in.
        //
        DISABLE_CONTROLLER_IMAGE (FdoExtension);

        WRITE_CONTROLLER(
            FdoExtension->ControllerAddress.DriveControl,
            FdoExtension->DriveControlImage );

        KeStallExecutionProcessor( 10 );

        FdoExtension->CurrentDeviceObject = DeviceObject;
        FdoExtension->AllowInterruptProcessing = TRUE;
        FdoExtension->CommandHasResultPhase = FALSE;
        KeResetEvent( &FdoExtension->InterruptEvent );

        ENABLE_CONTROLLER_IMAGE (FdoExtension);

        WRITE_CONTROLLER(
            FdoExtension->ControllerAddress.DriveControl,
            FdoExtension->DriveControlImage );

        //
        // Wait for an interrupt.  Note that STATUS_TIMEOUT and
        // STATUS_SUCCESS are the only possible return codes, since we
        // aren't alertable and won't get APCs.
        //
        ntStatus = KeWaitForSingleObject( &FdoExtension->InterruptEvent,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          &FdoExtension->InterruptDelay );

        if (ntStatus == STATUS_TIMEOUT) {

            if (retrycnt >= 1) {
                break;
            }

            // Retry reset after configure command to enable polling
            // interrupt.

            FdoExtension->FifoBuffer[0] = COMMND_CONFIGURE;

            if (FdoExtension->Clock48MHz) {
                FdoExtension->FifoBuffer[0] |= COMMND_OPTION_CLK48;
            }

            FdoExtension->FifoBuffer[1] = 0;
            FdoExtension->FifoBuffer[2] = COMMND_CONFIGURE_FIFO_THRESHOLD;
            FdoExtension->FifoBuffer[3] = 0;

            ntStatus = FcIssueCommand( FdoExtension,
                                       FdoExtension->FifoBuffer,
                                       FdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            if (!NT_SUCCESS(ntStatus)) {
                ntStatus = STATUS_TIMEOUT;
                break;
            }

            KeStallExecutionProcessor( 500 );

        } else {

            break;

        }
    }

    if ( ntStatus == STATUS_TIMEOUT ) {

        //
        // Change info to an error.
        //

        ntStatus = STATUS_IO_TIMEOUT;

        FdoExtension->HardwareFailed = TRUE;
    }

    if ( !NT_SUCCESS( ntStatus ) ) {

        FdcDump(FDCDBGP,("Fdc: controller didn't interrupt after reset\n"));

        return ntStatus;
    } 

    ntStatus = FcFinishReset( FdoExtension );

    return ntStatus;
}

NTSTATUS
FcGetFdcInformation(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine will attempt to identify the type of Floppy Controller

Arguments:

    FdoExtension - a pointer to our data area for the drive being
    accessed (any drive if a controller command is being given).

Return Value:

--*/
{
    NTSTATUS ntStatus;
    FDC_INFORMATION fdcInfo = {0};

    if (FdoExtension->FdcEnablerSupported) {

        fdcInfo.structSize = sizeof(fdcInfo);

        ntStatus = FcFdcEnabler( FdoExtension->FdcEnablerDeviceObject,
                                 IOCTL_GET_FDC_INFO,
                                 &fdcInfo);

        if ( NT_SUCCESS( ntStatus ) ) {

            FdoExtension->FdcType = (UCHAR)fdcInfo.FloppyControllerType;
            FdoExtension->Clock48MHz =
                            (fdcInfo.ClockRatesSupported == FDC_CLOCK_48MHZ);
            FdoExtension->FdcSpeeds = (UCHAR)fdcInfo.SpeedsAvailable;

        }

    } else {

        //
        // First, assume that we don't know what kind of FDC is attached.
        //

        FdoExtension->FdcType = FDC_TYPE_UNKNOWN;


        // Check for an enhanced type controller by issuing the version command.

        FdoExtension->FifoBuffer[0] = COMMND_VERSION;

        ntStatus = FcIssueCommand( FdoExtension,
                                FdoExtension->FifoBuffer,
                                FdoExtension->FifoBuffer,
                                NULL,
                                0,
                                0 );

        if ( NT_SUCCESS( ntStatus ) ) {

            if (FdoExtension->FifoBuffer[0] == VALID_NEC_FDC) {

                FdoExtension->FdcType = FDC_TYPE_ENHANCED;

            } else {

                FdoExtension->FdcType = FDC_TYPE_NORMAL;

            }
        }

        // Determine if the controller is a National 8477 by issuing the NSC
        // command which is specific to National parts and returns 0x71. (This
        // command happens to be the same as the Intel Part ID command so we
        // will use it instead.) The lower four bits are subject to change by
        // National and will reflect the version of the part in question.  At
        // this point we will only test the high four bits.

        if ( FdoExtension->FdcType == FDC_TYPE_ENHANCED &&
             NT_SUCCESS( ntStatus ) ) {

            FdoExtension->FifoBuffer[0] = COMMND_PART_ID;

            ntStatus = FcIssueCommand( FdoExtension,
                                       FdoExtension->FifoBuffer,
                                       FdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            if ( NT_SUCCESS( ntStatus ) ) {

                if ( (FdoExtension->FifoBuffer[0] & NSC_MASK) ==
                     NSC_PRIMARY_VERSION) {

                    FdoExtension->FdcType = FDC_TYPE_NATIONAL;

                }
            }
        }

        // Determine if the controller is an 82077 by issuing the perpendicular
        // mode command which at this time is only valid on 82077's.

        if ( FdoExtension->FdcType == FDC_TYPE_ENHANCED &&
             NT_SUCCESS( ntStatus ) ) {

            FdoExtension->FifoBuffer[0] = COMMND_PERPENDICULAR_MODE;
            FdoExtension->FifoBuffer[1] = COMMND_PERPENDICULAR_MODE_OW;

            ntStatus = FcIssueCommand( FdoExtension,
                                       FdoExtension->FifoBuffer,
                                       FdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            if (ntStatus != STATUS_DEVICE_NOT_READY) {

                FdoExtension->FdcType = FDC_TYPE_82077;

            } else {

                ntStatus = STATUS_SUCCESS;
            }
        }

        // Determine if the controller is an Intel 82078 by issuing the part id
        // command which is specific to Intel 82078 parts.

        if ( FdoExtension->FdcType == FDC_TYPE_82077 &&
             NT_SUCCESS( ntStatus ) ) {

            FdoExtension->FifoBuffer[0] = COMMND_PART_ID;

            ntStatus = FcIssueCommand( FdoExtension,
                                       FdoExtension->FifoBuffer,
                                       FdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            if ( NT_SUCCESS( ntStatus ) ) {

                if ((FdoExtension->FifoBuffer[0] & INTEL_MASK) ==
                    INTEL_64_PIN_VERSION) {

                    FdoExtension->FdcType = FDC_TYPE_82078_64;
                } else {
                    if ((FdoExtension->FifoBuffer[0] & INTEL_MASK) ==
                        INTEL_44_PIN_VERSION) {

                        FdoExtension->FdcType = FDC_TYPE_82078_44;
                    }
                }
            }
        }

        switch (FdoExtension->FdcType) {

        case FDC_TYPE_UNKNOWN   :
        case FDC_TYPE_NORMAL    :
        case FDC_TYPE_ENHANCED  :
        default:

            FdoExtension->FdcSpeeds = FDC_SPEED_250KB |
                                      FDC_SPEED_300KB |
                                      FDC_SPEED_500KB;
            break;

        case FDC_TYPE_82077     :
        case FDC_TYPE_82077AA   :
        case FDC_TYPE_82078_44  :
        case FDC_TYPE_NATIONAL  :

            FdoExtension->FdcSpeeds = FDC_SPEED_250KB |
                                      FDC_SPEED_300KB |
                                      FDC_SPEED_500KB |
                                      FDC_SPEED_1MB;
            break;

        case FDC_TYPE_82078_64  :

            FdoExtension->FdcSpeeds = FDC_SPEED_250KB |
                                      FDC_SPEED_300KB |
                                      FDC_SPEED_500KB |
                                      FDC_SPEED_1MB;

            if ( FdoExtension->Clock48MHz ) {

                FdoExtension->FdcSpeeds |= FDC_SPEED_2MB;
            }

            break;
        }
    }

    FdcDump( FDCINFO, ("Fdc: FdcType - %x\n", FdoExtension->FdcType));

    return ntStatus;
}
#define IO_PORT_REQ_MASK 0xbc

NTSTATUS
FdcFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine examines the supplied resource list and adds resources if
    necessary.  The only resources that it is concerned with adding are io port
    resources.  Adding io port resources is necessary because of different bios
    configurations and specifications.

    The PC97(98) hardware specification defines only 3f2, 3f4, and 3f5 as
    io port resources for standard floppy controllers (based on IBM PC floppy
    controller configurations).  In addition to these resources, fdc.sys
    requires 3f7 for disk change detection and data rate programming and
    optionally 3f3 for floppy tape support.  In addition, some bioses define
    aliased resources (e.g. 3f2 & 7f2, etc.)

    This routine first forwards the irp to the underlying PDO.  Upon return,
    it examines the io resource list to determine if any additional resources
    will be required.  It maintains a linked list of all io port base addresses
    that it encounters, assuming that they define aliased resources.  N.B. - if
    alternative lists are present in the io resource requirements list, only the
    first list is examined.  If additional resources are required a new io
    resource list is created.  The first io resource list in the new resource
    requirements list will contain the original resources as well as the
    additional resources required.  If it was necessary to request the tape mode
    register (3f3), i.e. 3f3 was not in the original list, a second list is
    generated that is identical to the first new list except that 3f3 is excluded.
    This list is for the case where the tape mode register is not available.
    Finally, the original list(s) is(are) copied to the end of the new list and
    are treated as alternative io resource lists.

Arguments:

    DeviceObject - a pointer to the device object being started.
    Irp - a pointer to the start device Irp.

Return Value:

--*/
{
    NTSTATUS ntStatus;
    PFDC_FDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpSp;
    KEVENT doneEvent;
    PIO_RESOURCE_REQUIREMENTS_LIST resourceRequirementsIn;
    PIO_RESOURCE_REQUIREMENTS_LIST resourceRequirementsOut;
    ULONG listSize;
    ULONG i,j;
    PIO_RESOURCE_LIST ioResourceListIn;
    PIO_RESOURCE_LIST ioResourceListOut;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptorIn;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptorOut;
    LIST_ENTRY ioPortList;
    PLIST_ENTRY links;
    PIO_PORT_INFO ioPortInfo;
    BOOLEAN foundBase;
    ULONG newDescriptors;
    BOOLEAN interruptResource = FALSE;
    BOOLEAN dmaResource = FALSE;
    UCHAR newPortMask;
    BOOLEAN requestTapeModeRegister = FALSE;
    USHORT in,out;

    fdoExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ntStatus = STATUS_SUCCESS;
    InitializeListHead( &ioPortList );

    FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_FILTER_RESOURCE_REQUIREMENTS - Irp: %p\n", Irp) );

    //
    // Pass this irp down to the PDO before proceeding.
    //
    KeInitializeEvent( &doneEvent, NotificationEvent, FALSE );

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine( Irp,
                            FdcPnpComplete,
                            &doneEvent,
                            TRUE,
                            TRUE,
                            TRUE );

    ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

    if ( ntStatus == STATUS_PENDING ) {

        KeWaitForSingleObject( &doneEvent, Executive, KernelMode, FALSE, NULL );
    }

    //
    //  Modified resources are returned in Irp-IoStatus.Information, otherwise
    //  just use what's in the parameter list.
    //
    if ( Irp->IoStatus.Information == 0 ) {

        Irp->IoStatus.Information = (UINT_PTR)irpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList;

        if ( Irp->IoStatus.Information == (UINT_PTR)NULL ) {
            //
            //  NULL List, the PDO freed the incoming resource list but did not
            //  provide a new list.  Complete the IRP with the PDO's status.
            //
            ntStatus = Irp->IoStatus.Status;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return( ntStatus );
        }

    }

    resourceRequirementsIn = (PIO_RESOURCE_REQUIREMENTS_LIST)Irp->IoStatus.Information;

    FdcDump( FDCSHOW, ("Resource Requirements List = %08X\n", resourceRequirementsIn) );

    //
    //  Make a pass through the resource list and determine what resources are
    //  already there as well as the base address for the io port and any
    //  alias ioports.
    //
    ioResourceListIn  = resourceRequirementsIn->List;
    ioResourceDescriptorIn  = ioResourceListIn->Descriptors;

    ntStatus = STATUS_SUCCESS;

    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: examining %d resources\n", ioResourceListIn->Count));

    for ( i = 0; i < ioResourceListIn->Count && NT_SUCCESS(ntStatus); i++ ) {

        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: IoResourceDescritporIn = %p\n",ioResourceDescriptorIn));

        switch ( ioResourceDescriptorIn->Type ) {

        case CmResourceTypeInterrupt:

            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found Interrupt Resource\n"));
            interruptResource = TRUE;
            break;

        case CmResourceTypeDma:

            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found Dma Resource \n"));
            dmaResource = TRUE;
            break;

        case CmResourceTypePort:

            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found Port Resource\n"));
            //
            //  For the ioPorts we will make a list containing each detected
            //  'base' address as well as the currently allocated addresses
            //  on that base.  Later we will use this to request additional
            //  resources if necessary.
            //
            //  First, if this base isn't already in the list, create a new
            //  list entry for it.
            //

            foundBase = FALSE;

            for ( links = ioPortList.Flink;
                  links != &ioPortList;
                  links = links->Flink) {

                ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);

                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Examining %p for match\n",ioPortInfo));
                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements:   Base Address = %08x\n",ioPortInfo->BaseAddress.LowPart));
                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements:   Desc Address = %08x\n",ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart & 0xfffffff8));

                if ( ioPortInfo->BaseAddress.LowPart ==
                     (ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart & 0xfffffff8) ) {

                    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found %08x in the ioPortList\n",ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart));

                    foundBase = TRUE;
                    //
                    //  Add these resources into the resource map for this base
                    //  address.
                    //
                    for ( j = 0; j < ioResourceDescriptorIn->u.Port.Length; j++ ) {

                        ioPortInfo->Map |= 0x01 << ((ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart & 0x07) + j);
                    }
                    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: New IoPortInfo->Map = %x\n",ioPortInfo->Map));
                    break;
                }
            }

            if ( !foundBase ) {

                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Creating new ioPortList entry for %08x\n",ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart));
                ioPortInfo = ExAllocatePool( PagedPool | POOL_COLD_ALLOCATION, sizeof(IO_PORT_INFO) );
                if ( ioPortInfo == NULL ) {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    RtlZeroMemory( ioPortInfo, sizeof(IO_PORT_INFO) );
                    ioPortInfo->BaseAddress = ioResourceDescriptorIn->u.Port.MinimumAddress;
                    ioPortInfo->BaseAddress.LowPart &= 0xfffffff8;
                    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements:   Base Address = %08x\n",ioPortInfo->BaseAddress.LowPart));
                    for ( j = 0; j < ioResourceDescriptorIn->u.Port.Length; j++ ) {
                        ioPortInfo->Map |= 0x01 << ((ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart & 0x07) + j);
                    }
                    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements:   New IoPortInfo->Map = %x\n",ioPortInfo->Map));
                    InsertTailList( &ioPortList, &ioPortInfo->ListEntry );
                }
            }
            break;

        default:

            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found unknown resource\n"));
            break;
        }
        ioResourceDescriptorIn++;
    }

    //
    //  If we didn't see any io port resources, we will just return now
    //  since we can't be sure of what to ask for.  The subsequent start
    //  device will surely fail.  This also goes for the interrupt and
    //  dma resource.
    //
    if ( !NT_SUCCESS(ntStatus) ||
         IsListEmpty( &ioPortList ) ||
         !interruptResource ||
         !dmaResource ) {
        //
        //  Clean up the ioPortInfo list
        //
        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Bad Resources, Go directly to jail\n"));
        while ( !IsListEmpty( &ioPortList ) ) {
            links = RemoveHeadList( &ioPortList );
            ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);
            ExFreePool( ioPortInfo );
        }

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return ntStatus;
    }

    //
    //  At this point, we know what resources we are currently assigned so
    //  we can determine what additional resources we need to request.  We
    //  need to know the size of the list we need to create so first count
    //  the number of resource descriptors we will have to add to the current
    //  list.
    //
    newDescriptors = 0;

    for ( links = ioPortList.Flink;
          links != &ioPortList;
          links = links->Flink) {

        ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);

        newPortMask = ~ioPortInfo->Map & IO_PORT_REQ_MASK;

        if ( newPortMask & 0x08 ) {
            requestTapeModeRegister = TRUE;
        }

        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Counting bits in %x\n",newPortMask));

        while ( newPortMask > 0 ) {
            if ( newPortMask & 0x01 ) {
                newDescriptors++;
            }
            newPortMask >>= 1;
        }
    }

    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Create %d new descriptors\n", newDescriptors) );

    //
    //  If we need resources that were not in the list, we will need to
    //  allocate a new resource requirements list that includes these
    //  new resources.
    //
    if ( newDescriptors > 0 ) {

        //
        //  Allocate and initialize a resource requirements list.  Make it big
        //  enough to hold whatever was in the list to start with along with
        //  the new resource list.
        //
        listSize = resourceRequirementsIn->ListSize +
                   resourceRequirementsIn->ListSize +
                   newDescriptors * sizeof(IO_RESOURCE_DESCRIPTOR);

        //
        //  If we will be requesting the tape mode register we will need to
        //  make an alternate list without it in case we cannot get it.
        //
        if ( requestTapeModeRegister ) {

            listSize = listSize +
                       resourceRequirementsIn->ListSize +
                       newDescriptors * sizeof(IO_RESOURCE_DESCRIPTOR);
        }

        resourceRequirementsOut = ExAllocatePool( NonPagedPool, listSize );

        if ( resourceRequirementsOut == NULL ) {

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            RtlZeroMemory( resourceRequirementsOut, listSize);

            //
            //  Initialize the IO_RESOURCE_REQUIREMENTS_LIST header.
            //
            resourceRequirementsOut->ListSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) -
                                                 sizeof(IO_RESOURCE_LIST);
            resourceRequirementsOut->InterfaceType = resourceRequirementsIn->InterfaceType;
            resourceRequirementsOut->BusNumber = resourceRequirementsIn->BusNumber;
            resourceRequirementsOut->SlotNumber = resourceRequirementsIn->SlotNumber;
            resourceRequirementsOut->Reserved[0] = resourceRequirementsIn->Reserved[0];
            resourceRequirementsOut->Reserved[1] = resourceRequirementsIn->Reserved[1];
            resourceRequirementsOut->Reserved[2] = resourceRequirementsIn->Reserved[2];
            resourceRequirementsOut->AlternativeLists = resourceRequirementsIn->AlternativeLists + 1;
            if ( requestTapeModeRegister ) {
                ++resourceRequirementsOut->AlternativeLists;
            }

            //
            //  Copy the primary list from the incoming IO_RESOURCE_REQUIREMENTS_LIST
            //  to the new list.
            //
            ioResourceListIn  = resourceRequirementsIn->List;
            ioResourceListOut = resourceRequirementsOut->List;

            listSize = sizeof(IO_RESOURCE_LIST) +
                      (ioResourceListIn->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR);
            RtlCopyMemory( ioResourceListOut, ioResourceListIn, listSize );

            resourceRequirementsOut->ListSize += listSize;

            //
            //  Add any additional resources that we are requesting.
            //
            ioResourceDescriptorOut = (PIO_RESOURCE_DESCRIPTOR)((ULONG_PTR)resourceRequirementsOut +
                                                                           resourceRequirementsOut->ListSize);
            for ( links = ioPortList.Flink;
                  links != &ioPortList;
                  links = links->Flink) {

                ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);

                newPortMask = ~ioPortInfo->Map & IO_PORT_REQ_MASK;
                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Add resource desc for each bit in %x\n",newPortMask));

                i = 0;
                while ( newPortMask != 0 ) {

                    if ( newPortMask & 0x01 ) {

                        ioResourceDescriptorOut->Option = IO_RESOURCE_PREFERRED;
                        ioResourceDescriptorOut->Type = CmResourceTypePort;
                        ioResourceDescriptorOut->ShareDisposition = CmResourceShareDeviceExclusive;
                        ioResourceDescriptorOut->Flags = CM_RESOURCE_PORT_IO;

                        ioResourceDescriptorOut->u.Port.Length = 1;
                        ioResourceDescriptorOut->u.Port.Alignment = 1;
                        ioResourceDescriptorOut->u.Port.MinimumAddress.QuadPart =
                        ioResourceDescriptorOut->u.Port.MaximumAddress.QuadPart =
                        ioPortInfo->BaseAddress.QuadPart + (ULONGLONG)i;

                        ++ioResourceListOut->Count;
                        resourceRequirementsOut->ListSize += sizeof(IO_RESOURCE_DESCRIPTOR);

                        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Add resource descriptor: %p\n",ioResourceDescriptorOut));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->Option           = %x\n",ioResourceDescriptorOut->Option          ));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->Type             = %x\n",ioResourceDescriptorOut->Type            ));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->ShareDisposition = %x\n",ioResourceDescriptorOut->ShareDisposition));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->Flags            = %x\n",ioResourceDescriptorOut->Flags           ));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->u.Port.Length    = %x\n",ioResourceDescriptorOut->u.Port.Length   ));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->u.Port.Alignment = %x\n",ioResourceDescriptorOut->u.Port.Alignment));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->u.Port.MinimumAddress.LowPart = %08x\n",ioResourceDescriptorOut->u.Port.MinimumAddress.LowPart));

                        ioResourceDescriptorOut++;
                    }
                    newPortMask >>= 1;
                    i++;
                }
            }

            if ( requestTapeModeRegister ) {

                ioResourceListIn = ioResourceListOut;
                ioResourceListOut = (PIO_RESOURCE_LIST)ioResourceDescriptorOut;

                ioResourceListOut->Version  = ioResourceListIn->Version;
                ioResourceListOut->Revision = ioResourceListIn->Revision;
                ioResourceListOut->Count    = 0;

                resourceRequirementsOut->ListSize += sizeof(IO_RESOURCE_LIST) -
                                                      sizeof(IO_RESOURCE_DESCRIPTOR);

                in = out = 0;

                do {

                    if ( (ioResourceListIn->Descriptors[in].Type != CmResourceTypePort) ||
                         ((ioResourceListIn->Descriptors[in].u.Port.MinimumAddress.LowPart & 0x07) != 0x03) ) {

                        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Add %08x to alternate list\n", resourceRequirementsOut->List[0].Descriptors[out]));
                        ioResourceListOut->Descriptors[out++] = ioResourceListIn->Descriptors[in++];
                        ++ioResourceListOut->Count;
                        resourceRequirementsOut->ListSize += sizeof(IO_RESOURCE_DESCRIPTOR);
                    } else {
                        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Don't add %08x to alternate list\n", resourceRequirementsOut->List[0].Descriptors[out]));
                        in++;
                    }
                } while ( in < ioResourceListIn->Count );
            }

            //
            //  Copy the original list(s) to the end of our new list.
            //
            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Copy %d existing resource list(s)\n",resourceRequirementsIn->AlternativeLists));
            ioResourceListIn = resourceRequirementsIn->List;
            ioResourceListOut = (PIO_RESOURCE_LIST)((ULONG_PTR)resourceRequirementsOut +
                                                           resourceRequirementsOut->ListSize);

            for ( in = 0; in < resourceRequirementsIn->AlternativeLists; in++ ) {

                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Copy list %p\n",ioResourceListIn));

                listSize = sizeof(IO_RESOURCE_LIST) +
                          (ioResourceListIn->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR);
                RtlCopyMemory( ioResourceListOut, ioResourceListIn, listSize );

                ioResourceListOut = (PIO_RESOURCE_LIST)((ULONG_PTR)ioResourceListOut + listSize);
                ioResourceListIn = (PIO_RESOURCE_LIST)((ULONG_PTR)ioResourceListIn + listSize);
                resourceRequirementsOut->ListSize += listSize;
            }

            FdcDump( FDCSHOW, ("Resource Requirements List = %p\n", resourceRequirementsOut) );

            Irp->IoStatus.Information = (UINT_PTR)resourceRequirementsOut;

            //
            // Free the caller's list
            //
            ExFreePool( resourceRequirementsIn );
            ntStatus = STATUS_SUCCESS;
        }
    }
    //
    //  Clean up the ioPortInfo list
    //
    while ( !IsListEmpty( &ioPortList ) ) {
        links = RemoveHeadList( &ioPortList );
        ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);
        ExFreePool( ioPortInfo );
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return ntStatus;
}

NTSTATUS
FdcQueryDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine will report any devices that have been enumerated on the
    floppy controller.  If we don't know of any devices yet we will
    enumerate the registry hardware tree.

Arguments:

    DeviceObject - a pointer to the device object being started.
    Irp - a pointer to the start device Irp.

Return Value:

--*/
{
    PFDC_FDO_EXTENSION fdoExtension;
    PFDC_PDO_EXTENSION pdoExtension;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpSp;
    ULONG relationCount;
    ULONG relationLength;
    PDEVICE_RELATIONS relations;
    PLIST_ENTRY entry;
    ULONG returnSize;
    PACPI_FDE_ENUM_TABLE returnBuffer;

    fdoExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ntStatus = STATUS_SUCCESS;

    FdcDump( FDCSHOW, ("FdcQueryDeviceRelations:\n"));

    if ( irpSp->Parameters.QueryDeviceRelations.Type != BusRelations ) {
        //
        // We don't support this
        //
        FdcDump( FDCSHOW, ("FdcQueryDeviceRelations: Type = %d\n", irpSp->Parameters.QueryDeviceRelations.Type));

        IoSkipCurrentIrpStackLocation( Irp );
        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        return ntStatus;
    }

    //
    // Tell the plug and play system about all the PDOs.
    //
    // There might also be device relations below and above this FDO,
    // so, be sure to propagate the relations from the upper drivers.
    //

    //
    //  The current number of PDOs
    //
    relationCount = ( Irp->IoStatus.Information == 0 ) ? 0 :
        ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Count;

    //
    //  *ACPI*  Determine if we are no an ACPI machine and, if so, whether it
    //  supports the _FDE method (Floppy Device Enumerate).
    //
    ntStatus = DeviceQueryACPI_SyncExecMethod( fdoExtension->TargetObject,
                                               'EDF_',
                                               0,
                                               NULL,
                                               NULL,
                                               NULL,
                                               ACPI_METHOD_ARGUMENT_BUFFER,
                                               sizeof(ACPI_FDE_ENUM_TABLE),
                                               NULL,
                                               &returnSize,
                                               &returnBuffer );

    FdcDump( FDCSHOW, ("FDC-ACPI _EDF return size = %d\n", returnSize));

    fdoExtension->ACPI_FDE_Valid = FALSE;

    if (NT_SUCCESS(ntStatus)) {

        if (returnSize == sizeof(ACPI_FDE_ENUM_TABLE)) {

            //
            // It's good!
            //
            RtlCopyMemory(&fdoExtension->ACPI_FDE_Data, returnBuffer, returnSize);
            fdoExtension->ACPI_BIOS = TRUE;
            fdoExtension->ProbeFloppyDevices = FALSE;
            fdoExtension->ACPI_FDE_Valid = TRUE;
        }

        //
        // Free the buffer.
        //
        ExFreePool(returnBuffer);

    } else if (ntStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

        //
        // ACPI is out there, the BIOS just didn't implement _FDE.
        //
        fdoExtension->ACPI_BIOS = TRUE;
        fdoExtension->ProbeFloppyDevices = FALSE;

    } else {

        fdoExtension->ACPI_BIOS = FALSE;
    }

    //
    //  If we are on an ACPI machine and either we are probing devices or we
    //  have valid _FDE data enumerate via ACPI methods.  If we are not probing
    //  devices and there is no _FDE method available, we will just rely on Bios
    //  data collected by ntdetect.
    //
    if ( fdoExtension->ACPI_BIOS &&
         (fdoExtension->ACPI_FDE_Valid || fdoExtension->ProbeFloppyDevices) ) {

        ntStatus = FdcEnumerateAcpiBios( DeviceObject );

        if ( !NT_SUCCESS(ntStatus) ) {

            return ntStatus;
        }

    } else {

        INTERFACE_TYPE InterfaceType;
        //
        //  Query the registry hardware tree to find out how many floppy
        //  drives were reported by the firmware.
        //
        //  Notice that we are enumerating ALL floppy devices in the BIOS.  We
        //  will filter out any devices not connected to this controller in the
        //  callback routine.
        //
        for ( InterfaceType = 0;
              InterfaceType < MaximumInterfaceType;
              InterfaceType++ ) {

            CONFIGURATION_TYPE Dc = DiskController;
            CONFIGURATION_TYPE Fp = FloppyDiskPeripheral;

            ntStatus = IoQueryDeviceDescription( &InterfaceType,
                                                 NULL,
                                                 &Dc,
                                                 NULL,
                                                 &Fp,
                                                 NULL,
                                                 FdcConfigCallBack,
                                                 fdoExtension );

            if (!NT_SUCCESS(ntStatus) && (ntStatus != STATUS_OBJECT_NAME_NOT_FOUND)) {

                Irp->IoStatus.Status = ntStatus;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);
                return ntStatus;
            }
        }
    }

    //
    //  Reset the probe flag so we don't do it again on the next query.
    //
    fdoExtension->ProbeFloppyDevices = FALSE;

    FdcDump( FDCSHOW, ("FdcQueryDeviceRelations: My relations count - %d\n", fdoExtension->NumPDOs));

    if (!fdoExtension->NumPDOs) {

        //
        // Nothing to add.
        //
        IoSkipCurrentIrpStackLocation( Irp );
        return IoCallDriver( fdoExtension->TargetObject, Irp );
    }

    relationLength = sizeof(DEVICE_RELATIONS) +
        (relationCount + fdoExtension->NumPDOs) * sizeof (PDEVICE_OBJECT);

    ASSERT(relationLength);

    relations = (PDEVICE_RELATIONS) ExAllocatePool (NonPagedPool, relationLength);

    if ( relations == NULL ) {

        if (relationCount) {

            //
            // Don't hide existing children
            //
            IoSkipCurrentIrpStackLocation( Irp );
            return IoCallDriver( fdoExtension->TargetObject, Irp );

        } else {

            Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            return STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    //
    // Copy in the device objects so far
    //
    if ( relationCount ) {
        RtlCopyMemory( relations->Objects,
                       ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Objects,
                       relationCount * sizeof (PDEVICE_OBJECT));
                relations->Count = relationCount;
    } else {
           relations->Count = 0;
        }

    //
    // For each PDO on this bus add a pointer to the device relations
    // buffer, being sure to take out a reference to that object.
    // The PlugPlay system will dereference the object when it is done with
    // it and free the device relations buffer.
    //
    for (entry = fdoExtension->PDOs.Flink;
         entry != &fdoExtension->PDOs;
         entry = entry->Flink) {

        pdoExtension = CONTAINING_RECORD( entry, FDC_PDO_EXTENSION, PdoLink );
        if (!(pdoExtension->ReportedMissing)) {

            relations->Objects[relationCount++] = pdoExtension->Self;
            ObReferenceObject( pdoExtension->Self );

            //
            // If this fires, we somehow added more children than NumPDOs, and
            // we haven't enough memory!!!
            //
            ASSERT(relationCount <= relations->Count+fdoExtension->NumPDOs);
        }
    }
    relations->Count = relationCount;

    //
    // Set up and pass the IRP further down the stack
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    if ( Irp->IoStatus.Information != 0) {

        ExFreePool ((PVOID) Irp->IoStatus.Information);
    }

    Irp->IoStatus.Information = (UINT_PTR) relations;

    IoSkipCurrentIrpStackLocation( Irp );
    ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

    return ntStatus;
}

NTSTATUS
FdcEnumerateAcpiBios(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    Enumerate floppy devices on an ACPI machine.  If ACPI has provided a _FDE
    method we will use that information to enumerate devices.  We may or not
    verify the _FDE data with a device probe.  If no _FDE method is available
    we will just assume a floppy drive at each address (4) and probe those
    devices.
    NOTE - if we are not probing devices and there is no _FDE method we shouldn't
    get here.  Rather, we will rely on the BIOS data collected by ntdetect to
    enumerate floppy devices.

Arguments:

    DeviceObject - a pointer to the device object being started.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFDC_FDO_EXTENSION fdoExtension = (PFDC_FDO_EXTENSION)DeviceObject->DeviceExtension;
    UCHAR peripheralNumber;
    PLIST_ENTRY entry ;
    PFDC_PDO_EXTENSION pdoExtension;
    BOOLEAN alreadyEnumerated;
    BOOLEAN newlyMissing;
    BOOLEAN newlyPresent;

    //
    //  If we got floppy enumeration information from ACPI (via _FDE method)
    //  then probe and create devices as necessary.
    //
    fdoExtension->BusNumber = 0;

    //
    //  For each device, check the ACPI state if we have one.  If ACPI
    //  indicates that a device is present then probe if we should and
    //  create a PDO if we verify that a device is present.
    //
    for ( peripheralNumber = 0; peripheralNumber <= 3; peripheralNumber++ ) {

        //
        //  if we already have a pdo for this device don't create a new device
        //
        alreadyEnumerated = FALSE;
        newlyMissing = FALSE;
        newlyPresent = FALSE;
        entry = fdoExtension->PDOs.Flink;
        while ( entry != &fdoExtension->PDOs && NT_SUCCESS(ntStatus) ) {

            pdoExtension = CONTAINING_RECORD( entry, FDC_PDO_EXTENSION, PdoLink );

            //
            // If we found someone already listed as missing, keep going.
            //
            if (( pdoExtension->PeripheralNumber == peripheralNumber )&&
                (!pdoExtension->ReportedMissing)) {

                alreadyEnumerated = TRUE;
                break;
            }
            entry = entry->Flink ;
        }

        if (alreadyEnumerated) {

            if ( fdoExtension->ACPI_FDE_Valid ) {

                if ( !fdoExtension->ACPI_FDE_Data.DrivePresent[peripheralNumber] ) {

                    newlyMissing = TRUE;
                }

            } else if ( fdoExtension->ProbeFloppyDevices ) {

                ntStatus = FdcProbeFloppyDevice( DeviceObject, peripheralNumber );

                if (!NT_SUCCESS(ntStatus)) {

                    newlyMissing = TRUE;
                }
            }

        } else {

            if ( fdoExtension->ACPI_FDE_Valid ) {

                if ( fdoExtension->ACPI_FDE_Data.DrivePresent[peripheralNumber] ) {
                    newlyPresent = TRUE;
                }

            } else if ( fdoExtension->ProbeFloppyDevices ) {

                ntStatus = FdcProbeFloppyDevice( DeviceObject, peripheralNumber );
                if (NT_SUCCESS(ntStatus)) {

                    newlyPresent = TRUE;
                }

            }
        }

        //
        //  If we have a floppy device, create a PDO for it.
        //
        if (newlyPresent) {

            FdcCreateFloppyPdo( fdoExtension, peripheralNumber );

        } else if (newlyMissing) {

            pdoExtension->ReportedMissing = TRUE;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
FdcConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )
/*++

Routine Description:

Arguments:

    Context - Pointer to our FDO extension

    PathName - unicode registry path.  Not Used.

    BusType - Internal, Isa, ...

    BusNumber - Which bus if we are on a multibus system.

    BusInformation - Configuration information about the bus. Not Used.

    ControllerType - Should always be DiskController.

    ControllerNumber - Which controller if there is more than one
                       controller in the system.

    ControllerInformation - Array of pointers to the three pieces of
                            registry information.

    PeripheralType - Should always be FloppyDiskPeripheral.

    PeripheralNumber - Which floppy if this controller is maintaining
                       more than one.

    PeripheralInformation - Arrya of pointers to the three pieces of
                            registry information.

Return Value:

    STATUS_SUCCESS if everything went ok, or STATUS_INSUFFICIENT_RESOURCES
    if it couldn't map the base csr or acquire the adapter object, or
    all of the resource information couldn't be acquired.

--*/
{

    PFDC_FDO_EXTENSION fdoExtension = (PFDC_FDO_EXTENSION)Context;
    NTSTATUS ntStatus;
    USHORT resourceCount;
    BOOLEAN thisController;
    PCM_FULL_RESOURCE_DESCRIPTOR controllerData;
    PLIST_ENTRY entry ;
    PFDC_PDO_EXTENSION pdoExtension;
    PCM_FULL_RESOURCE_DESCRIPTOR peripheralData;
    USHORT resCount;

    FdcDump( FDCSHOW, ("FdcConfigCallBack:\n") );

    //
    //  Verify that this floppy disk drive is on the current
    //  floppy disk controller.
    //
    thisController = FALSE;
    controllerData = (PCM_FULL_RESOURCE_DESCRIPTOR)
        (((PUCHAR)ControllerInformation[IoQueryDeviceConfigurationData]) +
        ControllerInformation[IoQueryDeviceConfigurationData]->DataOffset);

    //
    // Check if the information from the registry for this device
    // is valid.
    //

    if (!(((PUCHAR)PeripheralInformation[IoQueryDeviceConfigurationData]) +
        PeripheralInformation[IoQueryDeviceConfigurationData]->DataLength)) {

        ASSERT(FALSE);
        return STATUS_INVALID_PARAMETER;

    }

    peripheralData = (PCM_FULL_RESOURCE_DESCRIPTOR)
        (((PUCHAR)PeripheralInformation[IoQueryDeviceConfigurationData]) +
        PeripheralInformation[IoQueryDeviceConfigurationData]->DataOffset);

    for ( resourceCount = 0;
          resourceCount < controllerData->PartialResourceList.Count;
          resourceCount++ ) {

        PCM_PARTIAL_RESOURCE_DESCRIPTOR partial =
            &controllerData->PartialResourceList.PartialDescriptors[resourceCount];

        FdcDump( FDCSHOW, ("FdcConfigCallBack: resource type = %x\n",partial->Type) );

        switch (partial->Type) {

        case CmResourceTypePort: {

            PUCHAR address;

            address = FdcGetControllerBase( BusType,
                                            BusNumber,
                                            partial->u.Port.Start,
                                            partial->u.Port.Length,
                                            (BOOLEAN)!!partial->Flags );

            FdcDump( FDCSHOW, ("FdcConfigCallBack: DriveControl = %04x %04x\n",fdoExtension->ControllerAddress.DriveControl,address + 2));
            if ( fdoExtension->ControllerAddress.DriveControl == address + 2) {
                thisController = TRUE;
            }
            break;
        }

        default:

            break;
        }
    }

    //
    //  If this floppy device is not on the current controller (based on the
    //  io resources, we will not enumerate it at this time.
    //
    if ( !thisController ) {

        return STATUS_SUCCESS;
    }

    //
    // Verify if this is a super floppy. If so we skip it.
    //
    for (resCount = 0;
         resCount < peripheralData->PartialResourceList.Count;
         resCount++) {

       PCM_PARTIAL_RESOURCE_DESCRIPTOR peripartial =
           &peripheralData->PartialResourceList.PartialDescriptors[resCount];

       PCM_FLOPPY_DEVICE_DATA fDeviceData;

       if (peripartial == NULL) {
          continue;
       } else if ((peripartial->Type) != CmResourceTypeDeviceSpecific) {
          continue;
       }

       fDeviceData = (PCM_FLOPPY_DEVICE_DATA)(peripartial + 1);
       if ((fDeviceData != NULL) && 
           (fDeviceData->MaxDensity & 0x80000000)) {
          return STATUS_SUCCESS;
       }
    }

    //
    //  if we already have a pdo for this device don't enumerate it again.
    //
    entry = fdoExtension->PDOs.Flink;
    while ( entry != &fdoExtension->PDOs ) {

        pdoExtension = CONTAINING_RECORD( entry, FDC_PDO_EXTENSION, PdoLink );

        if (( pdoExtension->PeripheralNumber == PeripheralNumber ) &&
            (!pdoExtension->ReportedMissing)) {

            return STATUS_SUCCESS;
        }
        entry = entry->Flink ;
    }

    fdoExtension->BusType = BusType;
    fdoExtension->BusNumber = BusNumber;
    fdoExtension->ControllerNumber = ControllerNumber;

    if ( fdoExtension->ProbeFloppyDevices ) {

        ntStatus = FdcProbeFloppyDevice( fdoExtension->Self, (UCHAR)PeripheralNumber );

    } else {

        ntStatus = STATUS_SUCCESS;
    }

    if ( NT_SUCCESS(ntStatus) ) {

        FdcCreateFloppyPdo( fdoExtension, (UCHAR)PeripheralNumber );
    }

    return STATUS_SUCCESS;
}

VOID
FdcCreateFloppyPdo(
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN UCHAR PeripheralNumber
    )
{
    NTSTATUS ntStatus;
    UNICODE_STRING pdoName;
    WCHAR pdoNameBuffer[64] = {0};
    PDEVICE_OBJECT newPdo;
    PFDC_PDO_EXTENSION pdoExtension;
    USHORT nameIndex = 0;

    do {

        swprintf( pdoNameBuffer, L"\\Device\\FloppyPDO%x", nameIndex++ );
        RtlInitUnicodeString( &pdoName, pdoNameBuffer );

        ntStatus = IoCreateDevice( FdoExtension->Self->DriverObject,
                                   sizeof(FDC_PDO_EXTENSION),
                                   &pdoName,
                                   FILE_DEVICE_MASS_STORAGE,
                                   FILE_DEVICE_SECURE_OPEN,
                                   FALSE,
                                   &newPdo);

    } while ( ntStatus == STATUS_OBJECT_NAME_COLLISION );

    if ( !NT_SUCCESS(ntStatus) ) {

        FdcDump( FDCSHOW | FDCPNP,
                 ("Fdc: FdcCreateFloppyPdo: Error - %08x\n", ntStatus) );
        return;
    }

    FdcDump( FDCSHOW | FDCPNP,
             ("FdcCreateFloppyPdo: DeviceObject Name - %S\n", pdoNameBuffer) );

    pdoExtension = (PFDC_PDO_EXTENSION)newPdo->DeviceExtension;

    pdoExtension->TargetObject = FdoExtension->Self;

    pdoExtension->IsFDO = FALSE;
    pdoExtension->Self = newPdo;
    pdoExtension->DeviceType = FloppyDiskDevice;

    pdoExtension->ParentFdo = FdoExtension->Self;

    pdoExtension->Removed = FALSE; // no irp_mn_remove as of yet
    pdoExtension->ReportedMissing = FALSE;

    pdoExtension->PeripheralNumber = PeripheralNumber;

    newPdo->Flags |= DO_DIRECT_IO;
    newPdo->Flags |= DO_POWER_PAGABLE;
    newPdo->StackSize += FdoExtension->Self->StackSize;
    newPdo->Flags &= ~DO_DEVICE_INITIALIZING;

    // IoGetConfigurationInformation()->FloppyCount++;

    InsertTailList(&FdoExtension->PDOs, &pdoExtension->PdoLink);
    FdoExtension->NumPDOs++;
}

NTSTATUS
FdcCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called only rarely by the I/O system; it's mainly
    for layered drivers to call.  All it does is complete the IRP
    successfully.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    Always returns STATUS_SUCCESS, since this is a null operation.

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );

    FdcDump(
        FDCSHOW,
        ("FdcCreateClose...\n")
        );

    //
    // Null operation.  Do not give an I/O boost since
    // no I/O was actually done.  IoStatus.Information should be
    // FILE_OPENED for an open; it's undefined for a close.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = FILE_OPENED;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return STATUS_SUCCESS;
}


NTSTATUS
FdcSystemControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )

/*++

Routine Description:

    IRP_MJ_SYSTEM_CONTROL dispatch routine. Currently, we don't handle
    this. So, if this is FDO just pass it to the lower driver. If this
    is PDO complete the irp with changing the irp status.
    
Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/
{

    PFDC_EXTENSION_HEADER  extensionHeader;
    PFDC_FDO_EXTENSION     fdoExtension;
    NTSTATUS status;

    extensionHeader = (PFDC_EXTENSION_HEADER)DeviceObject->DeviceExtension;

    if ( extensionHeader->IsFDO ) {

        fdoExtension = (PFDC_FDO_EXTENSION) DeviceObject->DeviceExtension;
        IoSkipCurrentIrpStackLocation( Irp );
        return IoCallDriver( fdoExtension->TargetObject, Irp );
    }

    status = Irp->IoStatus.Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}


NTSTATUS
FdcDeviceControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Determine if this device IOCTL request is directed towards an FDO or a PDO and
    pass the Irp on the the appropriate routine.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/

{
    PFDC_EXTENSION_HEADER  extensionHeader;
    PFDC_FDO_EXTENSION     fdoExtension;

    extensionHeader = (PFDC_EXTENSION_HEADER)DeviceObject->DeviceExtension;

    if ( extensionHeader->IsFDO ) {

        fdoExtension = (PFDC_FDO_EXTENSION) DeviceObject->DeviceExtension;
        IoSkipCurrentIrpStackLocation( Irp );
        return IoCallDriver( fdoExtension->TargetObject, Irp );
    }

    Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return STATUS_INVALID_DEVICE_REQUEST;
}

NTSTATUS
FdcInternalDeviceControl(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Determine if this Pnp request is directed towards an FDO or a PDO and
    pass the Irp on the the appropriate routine.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFDC_EXTENSION_HEADER extensionHeader;
    KIRQL oldIrq;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    extensionHeader = (PFDC_EXTENSION_HEADER)DeviceObject->DeviceExtension;

    if ( extensionHeader->IsFDO ) {

        ntStatus = FdcFdoInternalDeviceControl( DeviceObject, Irp );

    } else {

        ntStatus = FdcPdoInternalDeviceControl( DeviceObject, Irp );
    }

    return ntStatus;
}

NTSTATUS
FdcPdoInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to perform a device I/O
    control function.

    Most irps are put onto the driver queue (IoStartPacket).  Some irps do not
    require touching the hardware and are handled right here.

    In some cases the irp cannot be put on the queue because it cannot be
    completed at IRQL_DISPATCH_LEVEL.  However, the driver queue must be empty
    before the irp can be completed.  In these cases, the queue is
    'synchronized' before completing the irp.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    STATUS_SUCCESS or STATUS_PENDING if recognized I/O control code,
    STATUS_INVALID_DEVICE_REQUEST otherwise.

--*/

{
    PFDC_PDO_EXTENSION pdoExtension;
    PFDC_FDO_EXTENSION fdoExtension;
    BOOLEAN isFDO;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpSp;
    PIO_STACK_LOCATION nextIrpSp;
    PISSUE_FDC_ADAPTER_BUFFER_PARMS adapterBufferParms;

    pdoExtension = (PFDC_PDO_EXTENSION)DeviceObject->DeviceExtension;
    fdoExtension = (PFDC_FDO_EXTENSION)pdoExtension->ParentFdo->DeviceExtension;

    if ( pdoExtension->Removed) {
        //
        // This bus has received the PlugPlay remove IRP.  It will no longer
        // respond to external requests.
        //
        ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest( Irp, IO_DISK_INCREMENT );
        return ntStatus;
    }

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    FdcDump( FDCSHOW,
             ("FdcPdoInternalDeviceControl: %x\n",
             irpSp->Parameters.DeviceIoControl.IoControlCode) );

    switch ( irpSp->Parameters.DeviceIoControl.IoControlCode ) {

    case IOCTL_DISK_INTERNAL_GET_ENABLER: {

        if ( pdoExtension->DeviceType == FloppyControllerDevice ) {

            *(PBOOLEAN)irpSp->Parameters.DeviceIoControl.Type3InputBuffer = TRUE;

        } else {

            *(PBOOLEAN)irpSp->Parameters.DeviceIoControl.Type3InputBuffer = FALSE;
        }

        ntStatus = STATUS_SUCCESS;

        break;
        }

    case IOCTL_DISK_INTERNAL_GET_FDC_INFO:

        FcReportFdcInformation( pdoExtension, fdoExtension, irpSp );

        ntStatus = STATUS_SUCCESS;

        break;

    default:

        IoSkipCurrentIrpStackLocation( Irp );

        //
        // Call the driver and request the operation
        //
        return IoCallDriver( pdoExtension->TargetObject, Irp );
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest( Irp, IO_DISK_INCREMENT );

    return ntStatus;
}

NTSTATUS
FdcFdoInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to perform a device I/O
    control function.

    Most irps are put onto the driver queue (IoStartPacket).  Some irps do not
    require touching the hardware and are handled right here.

    In some cases the irp cannot be put on the queue because it cannot be
    completed at IRQL_DISPATCH_LEVEL.  However, the driver queue must be empty
    before the irp can be completed.  In these cases, the queue is
    'synchronized' before completing the irp.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    STATUS_SUCCESS or STATUS_PENDING if recognized I/O control code,
    STATUS_INVALID_DEVICE_REQUEST otherwise.

--*/

{
    PFDC_FDO_EXTENSION fdoExtension;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpSp;
    PIO_STACK_LOCATION nextIrpSp;
    PISSUE_FDC_ADAPTER_BUFFER_PARMS adapterBufferParms;
    BOOLEAN powerQueueClear = FALSE;
    PLIST_ENTRY deferredRequest;
    PIRP currentIrp;
    ULONG ioControlCode;
    PFDC_DISK_CHANGE_PARMS fdcDiskChangeParms;
    PUCHAR dataRate;
    UCHAR tapeMode;
    PUCHAR precomp;
    PISSUE_FDC_COMMAND_PARMS issueCommandParms;
    PSET_HD_BIT_PARMS setHdBitParams;

    fdoExtension = (PFDC_FDO_EXTENSION)DeviceObject->DeviceExtension;

    #if DBG
      if (Irp == NULL) {
         FdcDump(FDCSHOW, ("Coming out of sleep state. "));
         FdcDump(FDCSHOW, ("Going to process queued requests.\n"));
      }
    #endif
    
    if (FdcInSetupMode) {
       //
       // We should not stop retries when we are in
       // setup mode. Retries are not attempted too
       // often only during normal boot (non-setup boot).
       //
       fdoExtension->HardwareFailed = FALSE;
    }

    if ( fdoExtension->HardwareFailed ) {
        LARGE_INTEGER currentTime;

        KeQuerySystemTime( &currentTime );
        if ( fdoExtension->FdcFailedTime.QuadPart ) {
            if ( currentTime.QuadPart > (fdoExtension->FdcFailedTime.QuadPart + (10000 * 60)) ) {
                fdoExtension->HardwareFailed = FALSE;
                fdoExtension->FdcFailedTime.QuadPart = 0;
            }
        } else {
            fdoExtension->FdcFailedTime.QuadPart = currentTime.QuadPart;
        }
    }

    if (Irp != NULL) {
       InterlockedIncrement( &fdoExtension->OutstandingRequests );

       if ( fdoExtension->Removed ) {
         //
         // This device has received the PlugPlay remove IRP.  It will no longer
         // respond to external requests.
         //
          if ( InterlockedDecrement(&fdoExtension->OutstandingRequests ) == 0 ) {
             KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
          }
          ntStatus = STATUS_DELETE_PENDING;
          Irp->IoStatus.Status = ntStatus;
          IoCompleteRequest( Irp, IO_NO_INCREMENT );
          return ntStatus;
       }

      //
      //  If we are in a non-working power state then just queue the irp
      //  for later execution.
      //
       if ( fdoExtension->Paused ||
            (fdoExtension->CurrentPowerState == PowerDeviceD3) ) {

          IoMarkIrpPending( Irp );
          ExInterlockedInsertTailList( &fdoExtension->PowerQueue,
                                       &Irp->Tail.Overlay.ListEntry,
                                       &fdoExtension->PowerQueueSpinLock );

          ntStatus = STATUS_PENDING;
          return ntStatus;
       }
    }

    do {

        deferredRequest = ExInterlockedRemoveHeadList( &fdoExtension->PowerQueue,
                                                       &fdoExtension->PowerQueueSpinLock );

        if ( deferredRequest == NULL ) {

            if (Irp == NULL) {
               ntStatus = STATUS_SUCCESS;
               break;
            }
            currentIrp = Irp;
            powerQueueClear = TRUE;

        } else {

            currentIrp = CONTAINING_RECORD( deferredRequest, IRP, Tail.Overlay.ListEntry );
        }

        irpSp = IoGetCurrentIrpStackLocation( currentIrp );

        FdcDump( FDCSHOW,
                 ("FdcFdoInternalDeviceControl: %x\n",
                 irpSp->Parameters.DeviceIoControl.IoControlCode) );

        ioControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;

        //
        //  GET_ENABLER and GET_FDC_INFO are handled in the PDO, not the FDO.
        //
        if ( ioControlCode == IOCTL_DISK_INTERNAL_GET_ENABLER ||
             ioControlCode == IOCTL_DISK_INTERNAL_GET_FDC_INFO ) {

            ntStatus = STATUS_INVALID_DEVICE_REQUEST;

        //
        //  If the controller is not acquired (in use) then then only
        //  operation that is allowed is to acquire the fdc.
        //
        } else if ( !fdoExtension->ControllerInUse &&
                    ioControlCode != IOCTL_DISK_INTERNAL_ACQUIRE_FDC ) {

            ntStatus = STATUS_INVALID_DEVICE_REQUEST;

        } else {

            switch ( ioControlCode ) {

            case IOCTL_DISK_INTERNAL_ACQUIRE_FDC:

                //
                // Try to Acquire the Fdc.  If the Fdc is busy, this call will
                // time out.
                //
                ntStatus = FcAcquireFdc(
                                    fdoExtension,
                                    (PLARGE_INTEGER)irpSp->
                                    Parameters.DeviceIoControl.Type3InputBuffer );
                //
                // Return the device object of the last device that called this
                // driver.  This can be used to determine if any other drivers
                // have messed with the fdc since it was last acquired.
                //
                if ( NT_SUCCESS(ntStatus) ) {

                    irpSp->Parameters.DeviceIoControl.Type3InputBuffer =
                                                    fdoExtension->LastDeviceObject;

                    //
                    // FDC has been acquired. Set TapeEnumerationPending to
                    // TRUE to indicate FDC is in use.
                    //
                    fdoExtension->TapeEnumerationPending = TRUE;
                }
                break;

            case IOCTL_DISK_INTERNAL_ENABLE_FDC_DEVICE:

                //
                // Turn the motor on and select a floppy channel
                //
                ntStatus = FcTurnOnMotor( fdoExtension, (PFDC_ENABLE_PARMS)irpSp->Parameters.DeviceIoControl.Type3InputBuffer );

                break;

            case IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND:

                issueCommandParms =
                    (PISSUE_FDC_COMMAND_PARMS)
                    irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                ntStatus = FcIssueCommand( fdoExtension,
                                           issueCommandParms->FifoInBuffer,
                                           issueCommandParms->FifoOutBuffer,
                                           issueCommandParms->IoHandle,
                                           issueCommandParms->IoOffset,
                                           issueCommandParms->TransferBytes );


                break;

            case IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND_QUEUED:

                IoMarkIrpPending( currentIrp );

                IoStartPacket( DeviceObject,
                               currentIrp,
                               NULL,
                               NULL );

                ntStatus = STATUS_PENDING;

                break;

            case IOCTL_DISK_INTERNAL_RESET_FDC:

                ntStatus = FcInitializeControllerHardware( fdoExtension,
                                                           DeviceObject );
                break;

            case IOCTL_DISK_INTERNAL_RELEASE_FDC:

                ntStatus = FcReleaseFdc( fdoExtension );
                //
                // Save the DeviceObject of the releasing device.  This is
                // returned with the subsequent acquire fdc request and
                // can be used to determine whether the floppy controller
                // has been messed with between release and acquisition
                //
                if ( NT_SUCCESS(ntStatus) ) {

                    fdoExtension->LastDeviceObject =
                        irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                    //
                    // FDC is no longer in use. Set TapeEnumerationPending
                    // to FALSE.
                    //
                    fdoExtension->TapeEnumerationPending = FALSE;
                }

                break;

            case IOCTL_DISK_INTERNAL_GET_ADAPTER_BUFFER:
                //
                // Allocate an MDL for the passed in buffer.
                //
                adapterBufferParms = (PISSUE_FDC_ADAPTER_BUFFER_PARMS)
                            irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                adapterBufferParms->Handle =
                             IoAllocateMdl( adapterBufferParms->IoBuffer,
                                            adapterBufferParms->TransferBytes,
                                            FALSE,
                                            FALSE,
                                            NULL );

                if ( adapterBufferParms->Handle == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    MmBuildMdlForNonPagedPool( adapterBufferParms->Handle );

                    ntStatus = STATUS_SUCCESS;
                }

                break;

            case IOCTL_DISK_INTERNAL_FLUSH_ADAPTER_BUFFER:
                //
                // Free the MDL
                //
                adapterBufferParms = (PISSUE_FDC_ADAPTER_BUFFER_PARMS)
                            irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                if ( adapterBufferParms->Handle != NULL ) {

                    IoFreeMdl( adapterBufferParms->Handle );
                }

                ntStatus = STATUS_SUCCESS;

                break;

            case IOCTL_DISK_INTERNAL_FDC_START_READ:
            case IOCTL_DISK_INTERNAL_FDC_START_WRITE:

                ntStatus = STATUS_SUCCESS;

                if ( fdoExtension->FdcEnablerSupported ) {

                    FDC_MODE_SELECT fdcModeSelect = {0};

                    fdcModeSelect.structSize = sizeof(fdcModeSelect);
                    //
                    // Reading from the media means writing to DMA memory and
                    // visa-versa for writing to the media.
                    //
                    if ( irpSp->Parameters.DeviceIoControl.IoControlCode ==
                         IOCTL_DISK_INTERNAL_FDC_START_READ ) {

                        fdcModeSelect.DmaDirection = FDC_WRITE_TO_MEMORY;

                    } else {

                        fdcModeSelect.DmaDirection = FDC_READ_FROM_MEMORY;
                    }

                    ntStatus = FcFdcEnabler(
                                    fdoExtension->FdcEnablerDeviceObject,
                                    IOCTL_SET_FDC_MODE,
                                    &fdcModeSelect);
                }
                break;

            case IOCTL_DISK_INTERNAL_DISABLE_FDC_DEVICE:

                ntStatus = FcTurnOffMotor( fdoExtension );

                break;

            case IOCTL_DISK_INTERNAL_GET_FDC_DISK_CHANGE:

                FdcDump(FDCINFO, ("Fdc: Read Disk Change\n") );

                fdcDiskChangeParms =
                    (PFDC_DISK_CHANGE_PARMS)irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                fdcDiskChangeParms->DriveStatus = READ_CONTROLLER(
                    fdoExtension->ControllerAddress.DRDC.DiskChange );
                //
                //  If we just waked up from hibernation, simulate a disk
                //  change event so the upper levels will be sure to check
                //  this disk.
                //
                if ( fdoExtension->WakeUp ) {

                    fdcDiskChangeParms->DriveStatus |= DSKCHG_DISKETTE_REMOVED;
                    fdoExtension->WakeUp = FALSE;
                }

                ntStatus = STATUS_SUCCESS;

                break;

            case IOCTL_DISK_INTERNAL_SET_FDC_DATA_RATE:

                dataRate = (PUCHAR)irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                FdcDump(FDCINFO, ("Fdc: Write Data Rate: %x\n", *dataRate) );

                WRITE_CONTROLLER( fdoExtension->ControllerAddress.DRDC.DataRate,
                                  *dataRate );

                ntStatus = STATUS_SUCCESS;

                break;

            case IOCTL_DISK_INTERNAL_SET_FDC_TAPE_MODE:

                tapeMode = READ_CONTROLLER( fdoExtension->ControllerAddress.Tape );
                tapeMode &= 0xfc;
                tapeMode |= *((PUCHAR)irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

                FdcDump(FDCINFO, ("Fdc: Write Tape Mode Register: %x\n", tapeMode));

                WRITE_CONTROLLER(fdoExtension->ControllerAddress.Tape, tapeMode);

                ntStatus = STATUS_SUCCESS;

                break;

            case IOCTL_DISK_INTERNAL_SET_FDC_PRECOMP:

                precomp = (PUCHAR)irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                FdcDump(FDCINFO, ("Fdc: Write Precomp: %x\n", *precomp));

                WRITE_CONTROLLER(fdoExtension->ControllerAddress.Status, *precomp );

                ntStatus = STATUS_SUCCESS;

                break;

            default:
                //
                // Mark the Irp pending and queue it.
                //
                ntStatus = STATUS_INVALID_DEVICE_REQUEST;

                break;
            }
        }

        if ( ntStatus != STATUS_PENDING ) {

            if ( InterlockedDecrement(&fdoExtension->OutstandingRequests ) == 0 ) {
                KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
            }
            currentIrp->IoStatus.Status = ntStatus;
            IoCompleteRequest( currentIrp, IO_DISK_INCREMENT );
        }

    } while ( !powerQueueClear );

    return ntStatus;
}

VOID
FcReportFdcInformation(
    IN      PFDC_PDO_EXTENSION PdoExtension,
    IN      PFDC_FDO_EXTENSION FdoExtension,
    IN OUT  PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine reports information about the Floppy Disk Controller
    that a higher level driver might need; primarily information
    regarding the DMA Adapter.

Arguments:

    fdoExtension    - Pointer to this device's extension data.

    IrpSp           - Pointer to the current Irp

Return Value:

    STATUS_SUCCESS

--*/

{
    PFDC_INFO fdcInfo;
    PACPI_FDI_DATA fdiData;
    ULONG bufferCount;
    ULONG bufferSize;
    ULONG i;
    NTSTATUS ntStatus;
    USHORT argumentType[16] = {0};
    USHORT argumentSize[16] = {0};

    FDC_PAGE_RESET_DRIVER_WITH_MUTEX;

    FdcDump( FDCINFO, ("Fdc: Report FDC Information\n") );

    fdcInfo = (PFDC_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    //
    // save the requested buffer count and buffer size.
    //
    bufferCount = fdcInfo->BufferCount;
    bufferSize =  fdcInfo->BufferSize;

    //
    // fill in the floppy controller hardware information
    //
    fdcInfo->BusType = FdoExtension->BusType;
    fdcInfo->BusNumber = FdoExtension->BusNumber;
    fdcInfo->ControllerNumber = FdoExtension->ControllerNumber;
    fdcInfo->PeripheralNumber = PdoExtension->PeripheralNumber;

    fdcInfo->FloppyControllerType = FdoExtension->FdcType;
    fdcInfo->SpeedsAvailable = FdoExtension->FdcSpeeds;

    fdcInfo->MaxTransferSize = FdoExtension->NumberOfMapRegisters * PAGE_SIZE;

    fdcInfo->BufferSize = 0;
    fdcInfo->BufferCount = 0;

    if ( bufferSize <= FdoExtension->BufferSize ) {

        fdcInfo->BufferSize = bufferSize;
        fdcInfo->BufferCount = MIN( bufferCount,
                                    FdoExtension->BufferCount );
        FdoExtension->BuffersRequested = MAX( fdcInfo->BufferCount,
                                              FdoExtension->BuffersRequested );
    }

    for ( i = 0 ; i < fdcInfo->BufferCount ; i++ ) {

        fdcInfo->BufferAddress[i].Logical =
                                    FdoExtension->TransferBuffers[i].Logical;
        fdcInfo->BufferAddress[i].Virtual =
                                    FdoExtension->TransferBuffers[i].Virtual;
    }

    //
    // *ACPI* call _FDI method to get data on this drive. Note that section
    // 6.2.5 says _FDI is a package, and lists BYTE and WORD as size fields for
    // the package. Of course 32bit integer, buffer, and string are the only
    // legal values, so we treat this is a package of 16 integers.
    //
    fdcInfo->AcpiBios = FdoExtension->ACPI_BIOS;

    if ( fdcInfo->AcpiBios ) {

        for(i=0; i<16; i++) {

            argumentType[i] = ACPI_METHOD_ARGUMENT_INTEGER;
            argumentSize[i] = sizeof(ULONG);
        }

        ntStatus = DeviceQueryACPI_SyncExecMethodForPackage( PdoExtension->Self,
                                                             'IDF_',
                                                             0,
                                                             NULL,
                                                             NULL,
                                                             NULL,
                                                             16,
                                                             sizeof(ACPI_FDI_DATA),
                                                             argumentType,
                                                             argumentSize,
                                                             &fdiData );

        if (NT_SUCCESS(ntStatus)) {

            //
            // Got valid data from acpi.
            //
                fdcInfo->AcpiFdiSupported = TRUE;
            fdcInfo->AcpiFdiData = *fdiData;

            //
            // Free the buffer.
            //
            ExFreePool(fdiData);

        } else if (ntStatus == STATUS_OBJECT_NAME_NOT_FOUND) {

            //
            // ACPI is out there, the BIOS just didn't implement _FDI for this
            // device (perhaps an add-on controller).
            //
                fdcInfo->AcpiFdiSupported = FALSE;

        } else {

            //
            // No ACPI.
            //
            fdcInfo->AcpiBios = FdoExtension->ACPI_BIOS;
            fdcInfo->AcpiFdiSupported = FALSE;
        }
    }

    FDC_PAGE_ENTIRE_DRIVER_WITH_MUTEX;
}

VOID
FdcStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS ntStatus;
    ULONG formatExParametersSize;
    PUCHAR diskChange;
    PUCHAR dataRate;
    PUCHAR tapeMode;
    PUCHAR precomp;
    PFDC_FDO_EXTENSION fdoExtension;
    PISSUE_FDC_COMMAND_PARMS issueCommandParms;
    PKDEVICE_QUEUE_ENTRY request;

    FdcDump( FDCSHOW, ("FdcStartIo...\n") );

    fdoExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ntStatus = STATUS_SUCCESS;

    switch( irpSp->Parameters.DeviceIoControl.IoControlCode ) {

        case IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND_QUEUED:

            issueCommandParms =
                (PISSUE_FDC_COMMAND_PARMS)
                irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

            if ( CommandTable[issueCommandParms->FifoInBuffer[0] &
                                            COMMAND_MASK].InterruptExpected ) {

                fdoExtension->CurrentDeviceObject = DeviceObject;
                fdoExtension->AllowInterruptProcessing = TRUE;
                fdoExtension->CommandHasResultPhase = FALSE;
                fdoExtension->InterruptTimer =
                    issueCommandParms->TimeOut ?
                    issueCommandParms->TimeOut + 1 : START_TIMER;
                fdoExtension->CurrentIrp = Irp;

            }

            ntStatus = FcStartCommand( fdoExtension,
                                       issueCommandParms->FifoInBuffer,
                                       issueCommandParms->FifoOutBuffer,
                                       issueCommandParms->IoHandle,
                                       issueCommandParms->IoOffset,
                                       issueCommandParms->TransferBytes,
                                       FALSE );

            if ( NT_SUCCESS( ntStatus )) {

                if ( CommandTable[issueCommandParms->FifoInBuffer[0] &
                                            COMMAND_MASK].InterruptExpected ) {

                    ntStatus = STATUS_PENDING;

                } else {

                    ntStatus = FcFinishCommand(
                                    fdoExtension,
                                    issueCommandParms->FifoInBuffer,
                                    issueCommandParms->FifoOutBuffer,
                                    issueCommandParms->IoHandle,
                                    issueCommandParms->IoOffset,
                                    issueCommandParms->TransferBytes,
                                    FALSE );

                }

            }

            break;

        default: {

            FdcDump(
                FDCDBGP,
                ("Fdc: invalid device request %x\n",
                irpSp->Parameters.DeviceIoControl.IoControlCode)
                );

            ntStatus = STATUS_INVALID_DEVICE_REQUEST;

            break;
        }
    }

    if ( ntStatus != STATUS_PENDING ) {
        Irp->IoStatus.Status = ntStatus;
        if (!NT_SUCCESS( ntStatus ) &&
            IoIsErrorUserInduced( ntStatus )) {

            IoSetHardErrorOrVerifyDevice( Irp, DeviceObject );
        }

        IoStartNextPacket( DeviceObject, FALSE );
    }
}

NTSTATUS
FcAcquireFdc(
    IN      PFDC_FDO_EXTENSION  FdoExtension,
    IN      PLARGE_INTEGER  TimeOut
    )

/*++

Routine Description:

    This routine acquires the floppy disk controller.  This includes
    allocating the adapter channel and connecting the interrupt.

    NOTE - This is where the sharing mechanism will be put into
    this driver.  That is, higher level drivers will 'reserve' the
    floppy controller with this ioctl.  Subsequent calls to this driver
    that are not from the 'reserving' drive will be rejected with a
    BUSY status.

Arguments:

    DeviceObject    - Device object for the current device

Return Value:

    STATUS_DEVICE_BUSY if we don't have the controller, otherwise
    STATUS_SUCCESS

--*/

{
    NTSTATUS ntStatus;

    FdcDump(FDCINFO,
           ("Fdc: Acquire the Floppy Controller\n")
           );

    //
    // Wait for the Fdc, either from the enabler or directly here.  Semaphores
    // are used to synchronize usage of the Fdc hardware.  If somebody else is
    // using the floppy controller now we must wait for them to finish.  If
    // this takes too long we will just let the caller know that the device is
    // busy.
    //
    if (FdoExtension->FdcEnablerSupported) {

        ntStatus = FcFdcEnabler( FdoExtension->FdcEnablerDeviceObject,
                                 IOCTL_ACQUIRE_FDC,
                                 TimeOut);
    } else {

        ntStatus = KeWaitForSingleObject( &FdoExtension->AcquireEvent,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          TimeOut );

        if ( ntStatus == STATUS_TIMEOUT ) {

            ntStatus = STATUS_DEVICE_BUSY;
        }
    }

    if ( NT_SUCCESS(ntStatus) ) {
        //
        // Lock down the driver code in memory.
        //

        FDC_PAGE_RESET_DRIVER_WITH_MUTEX;

        //
        // Allocate the adapter channel
        //
        FcAllocateAdapterChannel( FdoExtension );

        IoStartTimer(FdoExtension->Self);

        //
        // Connect the Interrupt
        //
        ntStatus = IoConnectInterrupt(&FdoExtension->InterruptObject,
                                      FdcInterruptService,
                                      FdoExtension,
                                      NULL,
                                      FdoExtension->ControllerVector,
                                      FdoExtension->ControllerIrql,
                                      FdoExtension->ControllerIrql,
                                      FdoExtension->InterruptMode,
                                      FdoExtension->SharableVector,
                                      FdoExtension->ProcessorMask,
                                      FdoExtension->SaveFloatState);

        if ( NT_SUCCESS( ntStatus ) ) {
            FdoExtension->ControllerInUse = TRUE;
        } else {
            FcFreeAdapterChannel( FdoExtension );
            IoStopTimer(FdoExtension->Self);
        }
    } else {

        ntStatus = STATUS_DEVICE_BUSY;
    }

    return ntStatus;
}

NTSTATUS
FcReleaseFdc(
    IN      PFDC_FDO_EXTENSION  FdoExtension
    )

/*++

Routine Description:

    This routine releaese the floppy disk controller.  This includes
    freeing the adapter channel and disconnecting the interrupt.

    NOTE - This is where the sharing mechanism will be put into
    this driver.  That is, higher level drivers will 'reserve' the
    floppy controller with this ioctl.  Subsequent calls to this driver
    that are not from the 'reserving' drive will be rejected with a
    BUSY status.

Arguments:

    fdoExtension    - Pointer to this device's extension data.

Return Value:

    STATUS_DEVICE_BUSY if we don't have the controller, otherwise
    STATUS_SUCCESS

--*/

{
    FdcDump(FDCINFO, ("Fdc: Release the Floppy Controller\n") );

    //
    // Free the Adapter Channel
    //
    FcFreeAdapterChannel( FdoExtension );

    FdoExtension->AllowInterruptProcessing = FALSE;
    FdoExtension->ControllerInUse = FALSE;

    //
    // Disconnect the Interrupt
    //
    IoDisconnectInterrupt(FdoExtension->InterruptObject);

    IoStopTimer(FdoExtension->Self);

    FDC_PAGE_ENTIRE_DRIVER_WITH_MUTEX;

    //
    // Release the Fdc Enabler card if there is one.  Otherwise, set the
    // floppy synchronization event.
    //
    if (FdoExtension->FdcEnablerSupported) {

        FcFdcEnabler( FdoExtension->FdcEnablerDeviceObject,
                      IOCTL_RELEASE_FDC,
                      NULL);
    } else {

        KeSetEvent( &FdoExtension->AcquireEvent,
                    (KPRIORITY) 0,
                    FALSE );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FcTurnOnMotor(
    IN      PFDC_FDO_EXTENSION  FdoExtension,
    IN OUT  PFDC_ENABLE_PARMS   FdcEnableParms
    )

/*++

Routine Description:

    This routine turns on the motor if it not already running.

Arguments:

    fdoExtension    - Pointer to this device's extension data.

    IrpSp           - Pointer to the current Irp

Return Value:

    STATUS_DEVICE_BUSY if we don't have the controller, otherwise
    STATUS_SUCCESS

--*/

{
    UCHAR driveStatus;
    UCHAR newStatus;
    LARGE_INTEGER motorOnDelay;
    USHORT      lpc;

    FdcDump(FDCINFO,
           ("Fdc: Turn Motor On: %x\n", FdcEnableParms->DriveOnValue) );

    driveStatus = FdoExtension->DriveControlImage;

    newStatus = FdcEnableParms->DriveOnValue |
                                DRVCTL_ENABLE_CONTROLLER |
                                DRVCTL_ENABLE_DMA_AND_INTERRUPTS;

    if ( driveStatus != newStatus ) {

        // If the drive is not on then check to see if we have
        // the controller.  Otherwise we assume that we have
        // the controller since we give it up only when we
        // turn off the motor.

        if (!FdoExtension->CurrentInterrupt) {

            FdoExtension->CurrentInterrupt = TRUE;

            driveStatus = FdoExtension->DriveControlImage;
        }

        FdoExtension->AllowInterruptProcessing = TRUE;

        FdoExtension->DriveControlImage = newStatus;

        WRITE_CONTROLLER(FdoExtension->ControllerAddress.DriveControl,
                         FdoExtension->DriveControlImage );

        if (FdcEnableParms->TimeToWait > 0) {

            motorOnDelay.LowPart =
                - ( 10 * 1000 * FdcEnableParms->TimeToWait );
            motorOnDelay.HighPart = -1;

            FdoExtension->LastMotorSettleTime = motorOnDelay;

            KeDelayExecutionThread( KernelMode, FALSE, &motorOnDelay );
        }

        FdcEnableParms->MotorStarted = TRUE;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FcTurnOffMotor(
    IN      PFDC_FDO_EXTENSION  FdoExtension
    )

/*++

Routine Description:

    This routine turns off all motors.  By default, Drive A is left selected
    by this routine since it is not possible to deselect all drives.  On a
    Power PC, drive D is left selected.

Arguments:

    fdoExtension   - Supplies the fdc extension.

Return Value:

    None.

--*/

{

    FdcDump(FDCINFO, ("Fdc: Turn Motor Off\n"));

    FdoExtension->DriveControlImage =
            DRVCTL_ENABLE_DMA_AND_INTERRUPTS +
#ifdef _PPC_
        DRVCTL_DRIVE_MASK +
#endif
        DRVCTL_ENABLE_CONTROLLER;

    WRITE_CONTROLLER(FdoExtension->ControllerAddress.DriveControl,
                     FdoExtension->DriveControlImage );

    return STATUS_SUCCESS;
}

VOID
FcAllocateAdapterChannel(
    IN OUT  PFDC_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine allocates an adapter channel.  The caller of
    IoAllocateAdapterChannel routine must wait for the
    'AllocateAdapterChannelEvent' to be signalled before trying to use the
    adapter channel.

Arguments:

    fdoExtension   - Supplies the fdc extension.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    if ( (FdoExtension->AdapterChannelRefCount)++ ) {
        return;
    }

    KeResetEvent( &FdoExtension->AllocateAdapterChannelEvent );

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    IoAllocateAdapterChannel( FdoExtension->AdapterObject,
                              FdoExtension->Self,
                              FdoExtension->NumberOfMapRegisters,
                              FdcAllocateAdapterChannel,
                              FdoExtension );

    KeLowerIrql( oldIrql );

    KeWaitForSingleObject( &FdoExtension->AllocateAdapterChannelEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL);
}

VOID
FcFreeAdapterChannel(
    IN OUT  PFDC_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine frees the previously allocated adapter channel.

Arguments:

    fdoExtension   - Supplies the fdc extension.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    if ( --(FdoExtension->AdapterChannelRefCount) ) {
        return;
    }

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    IoFreeAdapterChannel( FdoExtension->AdapterObject );

    KeLowerIrql( oldIrql );
}

IO_ALLOCATION_ACTION
FdcAllocateAdapterChannel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )

/*++

Routine Description:

    This DPC is called whenever the fdc.sys driver is trying to allocate
    the adapter channel.  It saves the MapRegisterBase in the controller data
    area, and sets the AllocateAdapterChannelEvent to awaken the thread.

Arguments:

    DeviceObject - unused.

    Irp - unused.

    MapRegisterBase - the base of the map registers that can be used
    for this transfer.

    Context - a pointer to our controller data area.

Return Value:

    Returns Allocation Action 'KeepObject' which means that the adapter
    object will be held for now (to be released explicitly later).

--*/
{
    PFDC_FDO_EXTENSION fdoExtension = Context;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    fdoExtension->MapRegisterBase = MapRegisterBase;

    KeSetEvent( &fdoExtension->AllocateAdapterChannelEvent,
                0L,
                FALSE );

    return KeepObject;
}

VOID
FcLogErrorDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to log an error that we had to reset the device.

Arguments:

    Dpc - The dpc object.

    DeferredContext - A pointer to the controller data.

    SystemContext1 - Unused.

    SystemContext2 - Unused.

Return Value:

    Mapped address

--*/

{

    PIO_ERROR_LOG_PACKET errorLogEntry;
    PFDC_FDO_EXTENSION fdoExtension = DeferredContext;

    errorLogEntry = IoAllocateErrorLogEntry(
                        fdoExtension->DriverObject,
                        (UCHAR)(sizeof(IO_ERROR_LOG_PACKET))
                        );

    if ( errorLogEntry != NULL) {

        errorLogEntry->ErrorCode = IO_ERR_RESET;
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->UniqueErrorValue = 0;
        errorLogEntry->FinalStatus = STATUS_SUCCESS;
        errorLogEntry->DumpDataSize = 0;

        IoWriteErrorLogEntry(errorLogEntry);

    }

}

NTSTATUS
FcIssueCommand(
    IN OUT  PFDC_FDO_EXTENSION  FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes
    )

/*++

Routine Description:

    This routine sends the command and all parameters to the controller,
    waits for the command to interrupt if necessary, and reads the result
    bytes from the controller, if any.

    Before calling this routine, the caller should put the parameters for
    the command in ControllerData->FifoBuffer[].  The result bytes will
    be returned in the same place.

    This routine runs off the CommandTable.  For each command, this says
    how many parameters there are, whether or not there is an interrupt
    to wait for, and how many result bytes there are.  Note that commands
    without result bytes actually have two, since the ISR will issue a
    SENSE INTERRUPT STATUS command on their behalf.

Arguments:

    Command - a byte specifying the command to be sent to the controller.

    fdoExtension - a pointer to our data area for this controller.

Return Value:

    STATUS_SUCCESS if the command was sent and bytes received properly;
    appropriate error propogated otherwise.

--*/

{
    NTSTATUS ntStatus;
    NTSTATUS ntStatus2;
    UCHAR i;
    PUCHAR fifoBuffer;
    UCHAR Command;
    BOOLEAN NeedToFlush = FALSE;

    if ( FdoExtension->HardwareFailed ) {
        return STATUS_DEVICE_NOT_READY;
    }

    #if DBG
    if (TransferBytes) {
       FdcDump(FDCDBGP,
               ("Bytes to transfer is %d\n", TransferBytes));
    }
    #endif // DBG
    
    //
    // If this command causes an interrupt, set CurrentDeviceObject and
    // reset the interrupt event.
    //

    Command = FifoInBuffer[0];

    FdcDump( FDCINFO,
             ("FcIssueCommand: Issue Command : %x\n",
             CommandTable[Command & COMMAND_MASK].OpCode)
             );


    if ( CommandTable[Command & COMMAND_MASK].InterruptExpected ) {

        FdoExtension->CurrentDeviceObject = FdoExtension->Self;
        FdoExtension->AllowInterruptProcessing = TRUE;
        FdoExtension->CommandHasResultPhase =
            !!CommandTable[Command & COMMAND_MASK].FirstResultByte;

        KeResetEvent( &FdoExtension->InterruptEvent );
    }

    //
    // Start up the command
    //

    ntStatus = FcStartCommand( FdoExtension,
                               FifoInBuffer,
                               FifoOutBuffer,
                               IoHandle,
                               IoOffset,
                               TransferBytes,
                               TRUE );

    if ( NT_SUCCESS( ntStatus ) ) {

        //
        // If there is an interrupt, wait for it.
        //

        if ( CommandTable[Command & COMMAND_MASK].InterruptExpected ) {
            ntStatus = KeWaitForSingleObject(
                &FdoExtension->InterruptEvent,
                Executive,
                KernelMode,
                FALSE,
                &FdoExtension->InterruptDelay );

            if ( ntStatus == STATUS_TIMEOUT ) {

                //
                // Change info to an error.  We'll just say
                // that the device isn't ready.
                //
                FdcDump(FDCWARN,
                        ("TIME_OUT waiting for interrupt in FcIssueCommand\n")
                        );
                ntStatus = STATUS_DEVICE_NOT_READY;

                FdoExtension->HardwareFailed = TRUE;
            }

        }

        //
        // If successful so far, get the result bytes.
        //

        if ( NT_SUCCESS( ntStatus ) ||
             (ntStatus == STATUS_DEVICE_NOT_READY)) {
            ntStatus = FcFinishCommand( FdoExtension,
                                        FifoInBuffer,
                                        FifoOutBuffer,
                                        IoHandle,
                                        IoOffset,
                                        TransferBytes,
                                        TRUE );

        } 
    }

    return ntStatus;
}

NTSTATUS
FcStartCommand(
    IN OUT  PFDC_FDO_EXTENSION  FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes,
    IN      BOOLEAN         AllowLongDelay
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS ntStatus;
    NTSTATUS ntStatus2;
    UCHAR i = 0;
    PUCHAR fifoBuffer;
    UCHAR Command;
    BOOLEAN NeedToFlush = FALSE;
    PIO_STACK_LOCATION irpSp;
    UCHAR status0;

    //
    // If this command causes an interrupt, set CurrentDeviceObject and
    // reset the interrupt event.
    //

    Command = FifoInBuffer[0];

    FdcDump( FDCINFO,
             ("FcStartCommand: Issue Command : %x\n",
             CommandTable[Command & COMMAND_MASK].OpCode)
             );

    FdoExtension->CommandHasResultPhase =
        !!CommandTable[Command & COMMAND_MASK].FirstResultByte;

    // First we will need to set up the data transfer if there is one associated
    // with this request.
    //
    if (CommandTable[Command & COMMAND_MASK].DataTransfer == FDC_READ_DATA ) {
        //
        // Setup Adapter Channel for Read
        //
        IoMapTransfer(FdoExtension->AdapterObject,
                      IoHandle,
                      FdoExtension->MapRegisterBase,
                      (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle ) + IoOffset ),
                      &TransferBytes,
                      FALSE);

    } else if (CommandTable[Command & COMMAND_MASK].DataTransfer ==
               FDC_WRITE_DATA ) {
       
        //
        // Setup Adapter Channel for Write
        //
        IoMapTransfer(FdoExtension->AdapterObject,
                      IoHandle,
                      FdoExtension->MapRegisterBase,
                      (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle ) + IoOffset ),
                      &TransferBytes,
                      TRUE);

    }

    //
    // Send the command to the controller.
    //
    if ( Command == COMMND_CONFIGURE ) {
        if ( FdoExtension->Clock48MHz ) {
            Command |= COMMND_OPTION_CLK48;
        }
    }
    ntStatus = FcSendByte( (UCHAR)(CommandTable[Command & COMMAND_MASK].OpCode |
                                  (Command & ~COMMAND_MASK)),
                           FdoExtension,
                           AllowLongDelay );

    //
    // If the command was successfully sent, we can proceed.
    //

    if ( NT_SUCCESS( ntStatus ) ) {

        //
        // Send the parameters as long as we succeed.
        //

        for ( i = 1;
            ( i <= CommandTable[Command & COMMAND_MASK].NumberOfParameters ) &&
                ( NT_SUCCESS( ntStatus ) );
            i++ ) {

            ntStatus = FcSendByte( FifoInBuffer[i],
                                   FdoExtension,
                                   AllowLongDelay );
            //
            // The Drive Specification is a special case since we don't really know
            // how many bytes to send until we encounter the DONE bit (or we have sent
            // the maximum allowable bytes).
            //
            if ((Command == COMMND_DRIVE_SPECIFICATION) &&
                (FifoInBuffer[i] & COMMND_DRIVE_SPECIFICATION_DONE) ) {
                break;
            }
        }

    }

    //
    // If there was a problem, check to see if it was caused by an
    // unimplemented command.
    //

    if ( !NT_SUCCESS( ntStatus ) ) {

        if ( ( i == 2 ) &&
            ( !CommandTable[Command & COMMAND_MASK].AlwaysImplemented ) ) {

            //
            // This error is probably caused by a command that's not
            // implemented on this controller.  Read the error from the
            // controller, and we should be in a stable state.
            //

            ntStatus2 = FcGetByte( &status0,
                                   FdoExtension,
                                   AllowLongDelay );

            //
            // If GetByte went as planned, we'll return the original error.
            //

            if ( NT_SUCCESS( ntStatus2 ) ) {

                if ( status0 != STREG0_END_INVALID_COMMAND ) {

                    //
                    // Status isn't as we expect, so return generic error.
                    //

                    ntStatus = STATUS_FLOPPY_BAD_REGISTERS;

                    FdoExtension->HardwareFailed = TRUE;
                    FdcDump( FDCINFO,
                             ("FcStartCommand: unexpected error value %2x\n",
                             status0) );
                } else {
                    FdoExtension->HardwareFailed = FALSE;
                    FdcDump( FDCINFO,
                             ("FcStartCommand: Invalid command error returned\n") );
                }

            } else {

                //
                // GetByte returned an error, so propogate THAT.
                //

                FdcDump( FDCINFO,
                         ("FcStartCommand: FcGetByte returned error %x\n",
                         ntStatus2) );
                ntStatus = ntStatus2;
            }
        }

        //
        // Flush the Adapter Channel if we allocated it.
        //

        if (CommandTable[Command & COMMAND_MASK].DataTransfer ==
            FDC_READ_DATA) {


   
            IoFlushAdapterBuffers( FdoExtension->AdapterObject,
                                   (PMDL)IoHandle,
                                   FdoExtension->MapRegisterBase,
                                   (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle) + IoOffset ),
                                   TransferBytes,
                                   FALSE);

        } else if (CommandTable[Command & COMMAND_MASK].DataTransfer ==
                   FDC_WRITE_DATA) {

            IoFlushAdapterBuffers( FdoExtension->AdapterObject,
                                   (PMDL)IoHandle,
                                   FdoExtension->MapRegisterBase,
                                   (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle) + IoOffset ),
                                   TransferBytes,
                                   TRUE);
        }
    }

    if ( !NT_SUCCESS( ntStatus ) ) {

        //
        // Print an error message unless the command isn't always
        // implemented, ie CONFIGURE.
        //

        if ( !( ( ntStatus == STATUS_DEVICE_NOT_READY ) &&
            ( !CommandTable[Command & COMMAND_MASK].AlwaysImplemented ) ) ) {

            FdcDump( FDCDBGP,
                     ("Fdc: err %x ------  while giving command %x\n",
                     ntStatus, Command) );
        }
    }

    return ntStatus;
}

NTSTATUS
FcFinishCommand(
    IN OUT  PFDC_FDO_EXTENSION  FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes,
    IN      BOOLEAN         AllowLongDelay
    )

/*++

Routine Description:

    This function is called to complete a command to the floppy controller.
    At this point the floppy controller has successfully been sent a command
    and has either generated an interrupt or is ready with its result phase.
    This routine will also flush the DMA Adapter Buffers if they have been
    allocated.

Arguments:

    FdoExtension - a pointer to our data area for this controller.

    IssueCommandParms - Floppy controller command parameters.

Return Value:

    STATUS_SUCCESS if the command is successfully completed.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    NTSTATUS ntStatus2;
    UCHAR i;
    UCHAR Command;

    Command = FifoInBuffer[0];

    FdcDump(FDCSHOW, ("Fdc: FcFinishCommand...\n"));


    if (CommandTable[Command & COMMAND_MASK].FirstResultByte > 0) {

        FifoOutBuffer[0] = FdoExtension->FifoBuffer[0];

        FdcDump( FDCSHOW, ("FcFinishCommand - Result: %02x", FifoOutBuffer[0]) );
    }

    for ( i = CommandTable[Command & COMMAND_MASK].FirstResultByte;
         ( i < CommandTable[Command & COMMAND_MASK].NumberOfResultBytes ) &&
         ( NT_SUCCESS( ntStatus ) );
         i++ ) {

        ntStatus = FcGetByte(
            &FifoOutBuffer[i],
            FdoExtension,
            AllowLongDelay );

        FdcDump( FDCSHOW, (" %02x", FifoOutBuffer[i]) );
    }
    FdcDump( FDCSHOW, ("\n") );

    //
    // Flush the Adapter Channel
    //

    if (CommandTable[Command & COMMAND_MASK].DataTransfer == FDC_READ_DATA) {

       IoFlushAdapterBuffers(FdoExtension->AdapterObject,
                             (PMDL)IoHandle,
                             FdoExtension->MapRegisterBase,
                             (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle ) + IoOffset ),
                             TransferBytes,
                             FALSE);

    } else if (CommandTable[Command & COMMAND_MASK].DataTransfer ==
               FDC_WRITE_DATA) {

        //
        // Setup Adapter Channel for Write
        //
       IoFlushAdapterBuffers(FdoExtension->AdapterObject,
                             (PMDL)IoHandle,
                             FdoExtension->MapRegisterBase,
                             (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle ) + IoOffset ),
                             TransferBytes,
                             TRUE);

    }

    return ntStatus;
}

NTSTATUS
FcSendByte(
    IN UCHAR ByteToSend,
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN BOOLEAN AllowLongDelay
    )

/*++

Routine Description:

    This routine is called to send a byte to the controller.  It won't
    send the byte unless the controller is ready to receive a byte; if
    it's not ready after checking FIFO_TIGHTLOOP_RETRY_COUNT times, we
    delay for the minimum possible time (10ms) and then try again.  It
    should always be ready after waiting 10ms.

Arguments:

    ByteToSend - the byte to send to the controller.

    ControllerData - a pointer to our data area for this controller.

Return Value:

    STATUS_SUCCESS if the byte was sent to the controller;
    STATUS_DEVICE_NOT_READY otherwise.

--*/

{
    ULONG i = 0;
    BOOLEAN byteWritten = FALSE;

    if ( FdoExtension->HardwareFailed ) {
        return STATUS_DEVICE_NOT_READY;
    }

    //
    // Sit in a tight loop for a while.  If the controller becomes ready,
    // send the byte.
    //

    do {

        if ( ( READ_CONTROLLER( FdoExtension->ControllerAddress.Status )
            & STATUS_IO_READY_MASK ) == STATUS_WRITE_READY ) {

            WRITE_CONTROLLER(
                FdoExtension->ControllerAddress.Fifo,
                ByteToSend );

            byteWritten = TRUE;

        } else {
            KeStallExecutionProcessor(1);
        }

        i++;

    } while ( (!byteWritten) && ( i < FIFO_TIGHTLOOP_RETRY_COUNT ) );

    //
    // We hope that in most cases the FIFO will become ready very quickly
    // and the above loop will have written the byte.  But if the FIFO
    // is not yet ready, we'll loop a few times delaying for 10ms and then
    // try it again.
    //

    if ( AllowLongDelay ) {

        i = 0;

        while ( ( !byteWritten ) && ( i < FIFO_DELAY_RETRY_COUNT ) ) {

            FdcDump(
                FDCINFO,
                ("Fdc: waiting for 10ms for controller write\n")
                );

            KeDelayExecutionThread(
                KernelMode,
                FALSE,
                &FdoExtension->Minimum10msDelay );

            i++;

            if ( (READ_CONTROLLER( FdoExtension->ControllerAddress.Status )
                & STATUS_IO_READY_MASK) == STATUS_WRITE_READY ) {

                WRITE_CONTROLLER(
                    FdoExtension->ControllerAddress.Fifo,
                    ByteToSend );

                byteWritten = TRUE;
            }
        }
    }

    if ( byteWritten ) {

        return STATUS_SUCCESS;

    } else {

        //
        // We've waited over 30ms, and the FIFO *still* isn't ready.
        // Return an error.
        //

        FdcDump(
            FDCWARN,
            ("Fdc: FIFO not ready to write after 30ms\n")
            );

        FdoExtension->HardwareFailed = TRUE;

        return STATUS_DEVICE_NOT_READY;
    }
}

NTSTATUS
FcGetByte(
    OUT PUCHAR ByteToGet,
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN BOOLEAN AllowLongDelay
    )

/*++

Routine Description:

    This routine is called to get a byte from the controller.  It won't
    read the byte unless the controller is ready to send a byte; if
    it's not ready after checking FIFO_RETRY_COUNT times, we delay for
    the minimum possible time (10ms) and then try again.  It should
    always be ready after waiting 10ms.

Arguments:

    ByteToGet - the address in which the byte read from the controller
    is stored.

    ControllerData - a pointer to our data area for this controller.

Return Value:

    STATUS_SUCCESS if a byte was read from the controller;
    STATUS_DEVICE_NOT_READY otherwise.

--*/

{
    ULONG i = 0;
    BOOLEAN byteRead = FALSE;

    //
    // Sit in a tight loop for a while.  If the controller becomes ready,
    // read the byte.
    //

    do {

        if ( ( READ_CONTROLLER( FdoExtension->ControllerAddress.Status )
            & STATUS_IO_READY_MASK ) == STATUS_READ_READY ) {

            *ByteToGet = READ_CONTROLLER(
                FdoExtension->ControllerAddress.Fifo );

            byteRead = TRUE;

        } else {
            KeStallExecutionProcessor(1);
        }

        i++;

    } while ( ( !byteRead ) && ( i < FIFO_TIGHTLOOP_RETRY_COUNT ) );

    //
    // We hope that in most cases the FIFO will become ready very quickly
    // and the above loop will have read the byte.  But if the FIFO
    // is not yet ready, we'll loop a few times delaying for 10ms and then
    // trying it again.
    //

    if ( AllowLongDelay ) {

        i = 0;

        while ( ( !byteRead ) && ( i < FIFO_DELAY_RETRY_COUNT ) ) {

            FdcDump(
                FDCINFO,
                ("Fdc: waiting for 10ms for controller read\n")
                );

            KeDelayExecutionThread(
                KernelMode,
                FALSE,
                &FdoExtension->Minimum10msDelay );

            i++;

            if ( (READ_CONTROLLER( FdoExtension->ControllerAddress.Status )
                & STATUS_IO_READY_MASK) == STATUS_READ_READY ) {

                *ByteToGet = READ_CONTROLLER(
                    FdoExtension->ControllerAddress.Fifo );

                byteRead = TRUE;

            }
        }
    }

    if ( byteRead ) {

        return STATUS_SUCCESS;

    } else {

        //
        // We've waited over 30ms, and the FIFO *still* isn't ready.
        // Return an error.
        //

        FdcDump(
            FDCWARN,
            ("Fdc: FIFO not ready to read after 30ms\n")
            );

        FdoExtension->HardwareFailed = TRUE;

        return STATUS_DEVICE_NOT_READY;
    }

}

VOID
FdcCheckTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine is called at DISPATCH_LEVEL once every second by the
    I/O system.

    If the timer is "set" (greater than 0) this routine will KeSync a
    routine to decrement it.  If it ever reaches 0, the hardware is
    assumed to be in an unknown state, and so we log an error and
    initiate a reset.

    If a timeout occurs while resetting the controller, the KeSync'd
    routine will return an error, and this routine will fail any IRPs
    currently being processed.  Future IRPs will try the hardware again.

    When this routine is called, the driver state is impossible to
    predict.  However, when it is called and the timer is running, we
    know that one of the disks on the controller is expecting an
    interrupt.  So no new packets are starting on the current disk due
    to device queues, and no code should be processing this packet since
    the packet is waiting for an interrupt.

Arguments:

    DeviceObject - a pointer to the device object associated with this
    timer.

    Fdcxtension - a pointer to the fdc extension data.

Return Value:

    None.

--*/

{
    PFDC_FDO_EXTENSION fdoExtension;
    PIRP irp;

    fdoExtension = (PFDC_FDO_EXTENSION)Context;
    irp = DeviceObject->CurrentIrp;

    //
    // When the counter is -1, the timer is "off" so we don't want to do
    // anything.  If it's on, we'll have to synchronize execution with
    // other routines while we mess with the variables (and, potentially,
    // the hardware).
    //

    if ( fdoExtension->InterruptTimer == CANCEL_TIMER ) {

        return;
    }

    //
    // In the unlikely event that we attempt to reset the controller due
    // to a timeout AND that reset times out, we will need to fail the
    // IRP that was in progress at the first timeout occurred.
    //

    if ( !KeSynchronizeExecution( fdoExtension->InterruptObject,
                                  FdcTimerSync,
                                  fdoExtension ) ) {

        //
        // We're done with the reset.  Return the IRP that was being
        // processed with an error, and release the controller object.
        //

        fdoExtension->ResettingController = RESET_NOT_RESETTING;

        irp->IoStatus.Status = STATUS_DEVICE_NOT_READY;

        IoSetHardErrorOrVerifyDevice( irp, DeviceObject );

        if ( InterlockedDecrement(&fdoExtension->OutstandingRequests ) == 0 ) {
            KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
        }
        IoCompleteRequest( irp, IO_DISK_INCREMENT );

        IoStartNextPacket( DeviceObject, FALSE );

    }
}

BOOLEAN
FdcTimerSync(
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine is called at DIRQL by FdcCheckTimer() when
    InterruptTimer is greater than 0.

    If the timer is "set" (greater than 0) this routine will decrement
    it.  If it ever reaches 0, the hardware is assumed to be in an
    unknown state, and so we log an error and initiate a reset.

    When this routine is called, the driver state is impossible to
    predict.  However, when it is called and the timer is running, we
    know that one of the disks on the controller is expecting an
    interrupt.  So, no new packets are starting on the current disk due
    to device queues, and no code should be processing this packet since
    the packet is waiting for an interrupt.  The controller object must
    be held.

Arguments:

    Context - a pointer to the controller extension.

Return Value:

    Generally TRUE.

    FALSE is only returned if the controller timed out while resetting
    the drive, so this means that the hardware state is unknown.

--*/

{
    PFDC_FDO_EXTENSION fdoExtension;

    fdoExtension = (PFDC_FDO_EXTENSION)Context;

    //
    // When the counter is -1, the timer is "off" so we don't want to do
    // anything.  It may have changed since we last checked it in
    // FdcCheckTimer().
    //

    if ( fdoExtension->InterruptTimer == CANCEL_TIMER ) {

        return TRUE;
    }

    //
    // The timer is "on", so decrement it.
    //

    fdoExtension->InterruptTimer--;

    //
    // If we hit zero, the timer has expired and we'll reset the
    // controller.
    //

    if ( fdoExtension->InterruptTimer == EXPIRED_TIMER ) {

        //
        // If we were ALREADY resetting the controller when it timed out,
        // there's something seriously wrong.
        //

        FdcDump( FDCDBGP, ("Fdc: Operation Timed Out.\n") );

        if ( fdoExtension->ResettingController != RESET_NOT_RESETTING ) {

            //
            // Returning FALSE will cause the current IRP to be completed
            // with an error.  Future IRPs will probably get a timeout and
            // attempt to reset the controller again.  This will probably
            // never happen.
            //

            FdcDump( FDCDBGP, ("Fdc: Timeout Reset timed out.\n") );

            fdoExtension->InterruptTimer = CANCEL_TIMER;
            return FALSE;
        }

        //
        // Reset the controller.  This will cause an interrupt.  Reset
        // CurrentDeviceObject until after the 10ms wait, in case any
        // stray interrupts come in.
        //

        fdoExtension->ResettingController = RESET_DRIVE_RESETTING;

        DISABLE_CONTROLLER_IMAGE (fdoExtension);

#ifdef _PPC_
        fdoExtension->DriveControlImage |= DRVCTL_DRIVE_MASK;
#endif

        WRITE_CONTROLLER(
            fdoExtension->ControllerAddress.DriveControl,
            fdoExtension->DriveControlImage );

        KeStallExecutionProcessor( 10 );

        fdoExtension->CommandHasResultPhase = FALSE;
        fdoExtension->InterruptTimer = START_TIMER;

        ENABLE_CONTROLLER_IMAGE (fdoExtension);

        WRITE_CONTROLLER(
            fdoExtension->ControllerAddress.DriveControl,
            fdoExtension->DriveControlImage );

    }

    return TRUE;
}

BOOLEAN
FdcInterruptService(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called at DIRQL by the system when the controller
    interrupts.

Arguments:

    Interrupt - a pointer to the interrupt object.

    Context - a pointer to our controller data area for the controller
    that interrupted.  (This was set up by the call to
    IoConnectInterrupt).

Return Value:

    Normally returns TRUE, but will return FALSE if this interrupt was
    not expected.

--*/

{
    PFDC_FDO_EXTENSION fdoExtension;
    PDEVICE_OBJECT currentDeviceObject;
    ULONG i;
    UCHAR statusByte;
    BOOLEAN controllerStateError;

    UCHAR resultStatus0;
    UCHAR aiStatus=0;
    UCHAR aiInterrupt=0;
    ULONG rqmReadyRetryCount;
    BOOLEAN Response;

    UNREFERENCED_PARAMETER( Interrupt );

#ifdef KEEP_COUNTERS
    FloppyIntrTime = KeQueryPerformanceCounter((PVOID)NULL);
    FloppyInterrupts++;
#endif

    FdcDump( FDCSHOW, ("FdcInterruptService: ") );

    fdoExtension = (PFDC_FDO_EXTENSION) Context;

    if (!fdoExtension->AllowInterruptProcessing) {
        FdcDump( FDCSHOW, ("processing not allowed\n") );
        return FALSE;
    }

    //
    // CurrentDeviceObject is set to the device object that is
    // expecting an interrupt.
    //

    currentDeviceObject = fdoExtension->CurrentDeviceObject;
    fdoExtension->CurrentDeviceObject = NULL;
    controllerStateError = FALSE;
    fdoExtension->InterruptTimer = CANCEL_TIMER;

    KeStallExecutionProcessor(10);

    if ( fdoExtension->CommandHasResultPhase ) {

        //
        // Result phase of previous command.  (Note that we can't trust
        // the CMD_BUSY bit in the status register to tell us whether
        // there's result bytes or not; it's sometimes wrong).
        // By reading the first result byte, we reset the interrupt.
        // The other result bytes will be read by a thread.
        // Note that we want to do this even if the interrupt is
        // unexpected, to make sure the interrupt is dismissed.
        //

        FdcDump(
            FDCSHOW,
            ("have result phase\n")
            );

        if ( ( READ_CONTROLLER( fdoExtension->ControllerAddress.Status )
            & STATUS_IO_READY_MASK ) == STATUS_READ_READY ) {

            fdoExtension->FifoBuffer[0] =
                READ_CONTROLLER( fdoExtension->ControllerAddress.Fifo );

            FdcDump(FDCSHOW,("FdcInterruptService: 1st fifo byte %2x\n",
                    fdoExtension->FifoBuffer[0]));

        } else {

            //
            // Should never get here.  If we do, DON'T wake up the thread;
            // let it time out and reset the controller, or let another
            // interrupt handle this.
            //

            FdcDump(FDCDBGP,
                    ("FdcInterruptService: controller not ready to be read in ISR\n"));

            controllerStateError = TRUE;
        }

    } else {

        //
        // Previous command doesn't have a result phase. To read how it
        // completed, issue a sense interrupt command.  Don't read
        // the result bytes from the sense interrupt; that is the
        // responsibility of the calling thread.
        // Note that we want to do this even if the interrupt is
        // unexpected, to make sure the interrupt is dismissed.
        //

        FdcDump(
            FDCSHOW,
            ("no result phase\n")
            );
        i = 0;

        do {

            KeStallExecutionProcessor( 1 );
            statusByte =
                READ_CONTROLLER(fdoExtension->ControllerAddress.Status);
            i++;

        } while ( ( i < FIFO_ISR_TIGHTLOOP_RETRY_COUNT ) &&
            ( ( statusByte & STATUS_CONTROLLER_BUSY ) ||
            ( ( statusByte & STATUS_IO_READY_MASK ) != STATUS_WRITE_READY ) ) );

        if ( !( statusByte & STATUS_CONTROLLER_BUSY ) &&
            ( ( statusByte & STATUS_IO_READY_MASK ) == STATUS_WRITE_READY ) ) {

            WRITE_CONTROLLER(
                fdoExtension->ControllerAddress.Fifo,
                0x08 );
//                COMMND_SENSE_INTERRUPT_STATUS );

            //
            // Wait for the controller to ACK the SenseInterrupt command, by
            // showing busy.  On very fast machines we can end up running
            // driver's system-thread before the controller has had time to
            // set the busy bit.
            //

            for (i = ISR_SENSE_RETRY_COUNT; i; i--) {

                statusByte =
                    READ_CONTROLLER( fdoExtension->ControllerAddress.Status );
                if (statusByte & STATUS_CONTROLLER_BUSY) {
                    break;
                }

                KeStallExecutionProcessor( 1 );
            }

            if (!i) {
                FdcDump(
                    FDCSHOW,
                    ("FdcInterruptService: spin loop complete and controller NOT busy\n")
                    );
            }

            if ( currentDeviceObject == NULL ) {

                //
                // This is an unexpected interrupt, so nobody's going to
                // read the result bytes.  Read them now.
                //

                FdcDump(FDCSHOW, ("FdcInterruptService: Dumping fifo bytes!\n"));
                READ_CONTROLLER( fdoExtension->ControllerAddress.Fifo );
                READ_CONTROLLER( fdoExtension->ControllerAddress.Fifo );
            }
        } else {
            //
            // Shouldn't get here.  If we do, DON'T wake up the thread;
            // let it time out and reset the controller, or let another
            // interrupt take care of it.
            //

            FdcDump(FDCDBGP, ("Fdc: no result, but can't write SenseIntr\n"));

            controllerStateError = TRUE;
        }
    }

    //
    // We've written to the controller, and we're about to leave.  On
    // machines with levelsensitive interrupts, we'll get another interrupt
    // if we RETURN before the port is flushed.  To make sure that doesn't
    // happen, we'll do a read here.
    //

    statusByte = READ_CONTROLLER( fdoExtension->ControllerAddress.Status );

    //
    // Let the interrupt settle.
    //

    KeStallExecutionProcessor(10);

#ifdef KEEP_COUNTERS
    FloppyEndIntrTime = KeQueryPerformanceCounter((PVOID)NULL);
    FloppyIntrDelay.QuadPart = FloppyIntrDelay.QuadPart +
                               (FloppyEndIntrTime.QuadPart -
                                FloppyIntrTime.QuadPart);
#endif

    if ( currentDeviceObject == NULL ) {

        //
        // We didn't expect this interrupt.  We've dismissed it just
        // in case, but now return FALSE withOUT waking up the thread.
        //

        FdcDump(FDCDBGP,
                   ("Fdc: unexpected interrupt\n"));

        return FALSE;
    }

    if ( !controllerStateError ) {

        //
        // Request a DPC for execution later to get the remainder of the
        // floppy state.
        //

        fdoExtension->IsrReentered = 0;
        fdoExtension->AllowInterruptProcessing = FALSE;

        IoRequestDpc(currentDeviceObject,
                     currentDeviceObject->CurrentIrp,
                     (PVOID) NULL);

    } else {

        //
        // Running the floppy (at least on R4000 boxes) we've seen
        // examples where the device interrupts, yet it never says
        // it *ISN'T* busy.  If this ever happens on non-MCA x86 boxes
        // it would be ok since we use latched interrupts.  Even if
        // the device isn't touched so that the line would be pulled
        // down, on the latched machine, this ISR wouldn't be called
        // again.  The normal timeout code for a request would eventually
        // reset the controller and retry the request.
        //
        // On the R4000 boxes and on MCA machines, the floppy is using
        // level sensitive interrupts.  Therefore if we don't do something
        // to lower the interrupt line, we will be called over and over,
        // *forever*.  This makes it look as though the machine is hung.
        // Unless we were lucky enough to be on a multiprocessor, the
        // normal timeout code would NEVER get a chance to run because
        // the timeout code runs at dispatch level, and we will never
        // leave device level.
        //
        // What we will do is keep a counter that is incremented every
        // time we reach this section of code.  When the counter goes
        // over the threshold we will do a hard reset of the device
        // and reset the counter down to zero.  The counter will be
        // initialized when the device is first initialized.  It will
        // be set to zero in the other arm of this if, and it will be
        // reset to zero by the normal timeout logic.
        //

        fdoExtension->CurrentDeviceObject = currentDeviceObject;
        if (fdoExtension->IsrReentered > FLOPPY_RESET_ISR_THRESHOLD) {

            //
            // Reset the controller.  This could cause an interrupt
            //

            fdoExtension->IsrReentered = 0;

            DISABLE_CONTROLLER_IMAGE (fdoExtension);

#ifdef _PPC_
            fdoExtension->DriveControlImage |= DRVCTL_DRIVE_MASK;
#endif

            WRITE_CONTROLLER(fdoExtension->ControllerAddress.DriveControl,
                             fdoExtension->DriveControlImage);

            KeStallExecutionProcessor( 10 );

            ENABLE_CONTROLLER_IMAGE (fdoExtension);

            WRITE_CONTROLLER(fdoExtension->ControllerAddress.DriveControl,
                             fdoExtension->DriveControlImage);

            //
            // Give the device plenty of time to be reset and
            // interrupt again.  Then just do the sense interrupt.
            // this should quiet the device.  We will then let
            // the normal timeout code do its work.
            //

            KeStallExecutionProcessor(500);
            WRITE_CONTROLLER(fdoExtension->ControllerAddress.Fifo,
                             0x08 );
//                           COMMND_SENSE_INTERRUPT_STATUS );
            KeStallExecutionProcessor(500);

            KeInsertQueueDpc(&fdoExtension->LogErrorDpc,
                             NULL,
                             NULL);
        } else {

            fdoExtension->IsrReentered++;
        }

    }
    return TRUE;
}

VOID
FdcDeferredProcedure(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is called at DISPATCH_LEVEL by the system at the
    request of FdcInterruptService().  It simply sets the interrupt
    event, which wakes up the floppy thread.

Arguments:

    Dpc - a pointer to the DPC object used to invoke this routine.

    DeferredContext - a pointer to the device object associated with this
    DPC.

    SystemArgument1 - unused.

    SystemArgument2 - unused.

Return Value:

    None.

--*/

{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
//    PFDC_PDO_EXTENSION pdoExtension;
    PFDC_FDO_EXTENSION fdoExtension;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PLIST_ENTRY request;
    PISSUE_FDC_COMMAND_PARMS issueCommandParms;

    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

#ifdef KEEP_COUNTERS
    FloppyDPCs++;
    FloppyDPCTime = KeQueryPerformanceCounter((PVOID)NULL);

    FloppyDPCDelay.QuadPart = FloppyDPCDelay.QuadPart +
                              (FloppyDPCTime.QuadPart -
                               FloppyIntrTime.QuadPart);
#endif

    deviceObject = (PDEVICE_OBJECT) DeferredContext;
    fdoExtension = deviceObject->DeviceExtension;

    irp = deviceObject->CurrentIrp;

    if ( irp != NULL ) {

        irpSp = IoGetCurrentIrpStackLocation( irp );
    }

    if ( irp != NULL &&
         irpSp->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND_QUEUED ) {

        issueCommandParms =
            (PISSUE_FDC_COMMAND_PARMS)
            irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

        ntStatus = FcFinishCommand(
                        fdoExtension,
                        issueCommandParms->FifoInBuffer,
                        issueCommandParms->FifoOutBuffer,
                        issueCommandParms->IoHandle,
                        issueCommandParms->IoOffset,
                        issueCommandParms->TransferBytes,
                        FALSE );

        irp->IoStatus.Status = ntStatus;

        if ( !NT_SUCCESS( ntStatus ) &&
            IoIsErrorUserInduced( ntStatus ) ) {

            IoSetHardErrorOrVerifyDevice( irp, deviceObject );
        }

        if ( InterlockedDecrement(&fdoExtension->OutstandingRequests ) == 0 ) {
            KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
        }
        IoCompleteRequest( irp, IO_NO_INCREMENT );

        IoStartNextPacket( deviceObject, FALSE );

    } else {
        FdcDump( FDCSHOW, ("FdcDeferredProcedure: Set Event\n") );
        
        KeSetEvent( &fdoExtension->InterruptEvent, (KPRIORITY) 0, FALSE );
    }
}

NTSTATUS
FcFinishReset(
    IN OUT  PFDC_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine is called to complete a reset operation which entails
    reading the interrupt status from each active channel on the floppy
    controller.

Arguments:

    FdoExtension - a pointer to our data area for this controller.

Return Value:

    STATUS_SUCCESS if this controller appears to have been reset properly,
    error otherwise.

--*/

{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    UCHAR       statusRegister0;
    UCHAR       cylinder;
    UCHAR       driveNumber;

    FdcDump(
        FDCSHOW,
        ("Fdc: FcFinishReset\n")
        );

    //
    // Sense interrupt status for all drives.
    //
    for ( driveNumber = 0;
        ( driveNumber < MAXIMUM_DISKETTES_PER_CONTROLLER ) &&
            ( NT_SUCCESS( ntStatus ) );
        driveNumber++ ) {

        if ( driveNumber != 0 ) {

            //
            // Note that the ISR issued first SENSE INTERRUPT for us.
            //

            ntStatus = FcSendByte(
                          CommandTable[COMMND_SENSE_INTERRUPT_STATUS].OpCode,
                          FdoExtension,
                          TRUE );
        }

        if ( NT_SUCCESS( ntStatus ) ) {

            ntStatus = FcGetByte( &statusRegister0, FdoExtension, TRUE );

            if ( NT_SUCCESS( ntStatus ) ) {

                ntStatus = FcGetByte( &cylinder, FdoExtension, TRUE );
            }
        }
    }

    return ntStatus;
}

NTSTATUS
FcFdcEnabler(
    IN      PDEVICE_OBJECT DeviceObject,
    IN      ULONG Ioctl,
    IN OUT  PVOID Data
    )
/*++

Routine Description:

    Call the floppy enabler driver to execute a command.  This is always a
    synchronous call and, since it includes waiting for an event, should only
    be done at IRQL_PASSIVE_LEVEL.

    All communication with the Floppy Enabler driver is carried out through
    device i/o control requests.  Any data that is to be sent to or received
    from the floppy enabler driver is included in the Type3InputBuffer section
    of the irp.

Arguments:

    DeviceObject - a pointer to the current device object.

    Ioctl - the IoControl code that will be sent to the Floppy Enabler.

    Data - a pointer to data that will be sent to or received from the Floppy
           Enabler.

Return Value:

    STATUS_TIMEOUT if the Floppy Enabler does not respond in a timely manner.
    otherwise IoStatus.Status from the Floppy Enabler is returned.

--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    KEVENT doneEvent;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS ntStatus;

    FdcDump(FDCINFO,("FcFdcEnabler: Calling fdc enabler with %x\n", Ioctl));

    KeInitializeEvent( &doneEvent,
                       NotificationEvent,
                       FALSE);

    //
    // Create an IRP for enabler
    //
    irp = IoBuildDeviceIoControlRequest( Ioctl,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,
                                         &doneEvent,
                                         &ioStatus );

    if (irp == NULL) {

        FdcDump(FDCDBGP,("FcFdcEnabler: Can't allocate Irp\n"));
        //
        // If an Irp can't be allocated, then this call will
        // simply return. This will leave the queue frozen for
        // this device, which means it can no longer be accessed.
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation(irp);
    irpStack->Parameters.DeviceIoControl.Type3InputBuffer = Data;

    //
    // Call the driver and request the operation
    //
    ntStatus = IoCallDriver(DeviceObject, irp);

    if ( ntStatus == STATUS_PENDING ) {

        //
        // Now wait for operation to complete (should already be done,  but
        // maybe not)
        //
        KeWaitForSingleObject( &doneEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        ntStatus = ioStatus.Status;
    }

    return ntStatus;
}
VOID
FdcGetEnablerDevice(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    )
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT doneEvent;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS ntStatus;

    FdcDump(FDCINFO,("FdcGetEnablerDevice:\n"));

    KeInitializeEvent( &doneEvent,
                       NotificationEvent,
                       FALSE);

    //
    // Create an IRP for enabler
    //
    irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_INTERNAL_GET_ENABLER,
                                         FdoExtension->TargetObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,
                                         &doneEvent,
                                         &ioStatus );

    if (irp == NULL) {

        FdcDump(FDCDBGP,("FdcGetEnablerDevice: Can't allocate Irp\n"));
        //
        // If an Irp can't be allocated, then this call will
        // simply return. This will leave the queue frozen for
        // this device, which means it can no longer be accessed.
        //
        return;
    }

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = &FdoExtension->FdcEnablerSupported;

    //
    // Call the driver and request the operation
    //
    ntStatus = IoCallDriver( FdoExtension->TargetObject, irp );

    //
    // Now wait for operation to complete (should already be done,  but
    // maybe not)
    //
    if ( ntStatus == STATUS_PENDING ) {

        ntStatus = KeWaitForSingleObject( &doneEvent,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL);
    }
    return;
}


NTSTATUS
FdcTerminateBufferThread(
    IN PFDC_FDO_EXTENSION  FdoExtension
    )
{
    PVOID bufferThread;
    LARGE_INTEGER timeout;

    NTSTATUS status;

    ASSERT(FdoExtension->BufferThreadHandle != NULL);

    //
    // First check to see if the buffer thread has already terminated.  If
    // so we can just close the handle and be done with it.
    //

    status = ObReferenceObjectByHandle(FdoExtension->BufferThreadHandle,
                                       SYNCHRONIZE,
                                       NULL,
                                       KernelMode,
                                       &bufferThread,
                                       NULL);
    if (!NT_SUCCESS(status)) {
       FdcDump(FDCWARN,
               ("FDC: ObReferenceObjectByHandle failed. Status - %x",
                status));
       return status;
    }

    timeout.QuadPart = 0;

    status = KeWaitForSingleObject(bufferThread,
                                   KernelMode,
                                   Executive,
                                   FALSE,
                                   &timeout);

    if(status == STATUS_TIMEOUT) {

        KIRQL oldIrql;

        //
        // The thread has not yet terminated itself.  Go ahead and give it a
        // helping hand.
        //

        KeAcquireSpinLock(&(FdoExtension->BufferThreadSpinLock), &oldIrql);

        FdoExtension->TerminateBufferThread = TRUE;

        timeout.QuadPart = 0;

        KeSetTimer(&(FdoExtension->BufferTimer),
                   timeout,
                   NULL);

        //
        // Drop the spinlock and wait for the thread to kill itself.
        //

        KeReleaseSpinLock(&(FdoExtension->BufferThreadSpinLock), oldIrql);

        status = KeWaitForSingleObject(bufferThread,
                                       KernelMode,
                                       Executive,
                                       FALSE,
                                       NULL);
    }

    ASSERT(NT_SUCCESS(status));

    //
    // Dereference the thread and close the handle so it can go away.
    //

    ObDereferenceObject(bufferThread);
    ZwClose(FdoExtension->BufferThreadHandle);

    FdoExtension->BufferThreadHandle = NULL;
    FdoExtension->TerminateBufferThread = FALSE;

    return status;
}

NTSTATUS
FdcProbeFloppyDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR DeviceSelect
    )
/*++

Routine Description:

    Probe for a floppy device.  This routine will issue a RECALIBRATE command(s)
    to the specified floppy device which will attempt to move the head to track 0.
    The floppy drive should respond by setting the track 0 line when it gets there.
    No response indicates that there is probably no device out there.
    NOTE - some older 360k, 5.25" floppy devices did not implement the track 0 line
    so this probe will not accurately indicate their presence.

Arguments:

    DeviceObject - a pointer to the device object being started.
    DeviceSelect - the floppy device to probe (0 - 3).

Return Value:

    Returns the status of the probe.

--*/
{
    NTSTATUS ntStatus;
    PFDC_FDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;

    FdcDump( FDCSHOW, ("Fdc: FdcProbeFloppyDevice\n") );

    ntStatus = FcAcquireFdc( fdoExtension, NULL );

    if ( NT_SUCCESS(ntStatus) ) {

        //
        //  Reset the floppy controller for good measure.
        //
        ntStatus = FcInitializeControllerHardware( fdoExtension, DeviceObject );

        if ( NT_SUCCESS(ntStatus) ) {

            FDC_ENABLE_PARMS fdcEnable;

            fdcEnable.DriveOnValue = DeviceSelect | ( DRVCTL_DRIVE_0 << DeviceSelect );
            fdcEnable.TimeToWait   = 1000;  //Max motor settle time.
            fdcEnable.MotorStarted = FALSE;

            ntStatus = FcTurnOnMotor( fdoExtension, &fdcEnable );
        }

        if ( NT_SUCCESS(ntStatus) ) {

            //
            //  Issue a recalibrate command.
            //
            FdcDump( FDCSHOW, ("Fdc: FdcProbeFloppyDevice - issue 1st recalibrate\n") );

            fdoExtension->FifoBuffer[0] = COMMND_RECALIBRATE;
            fdoExtension->FifoBuffer[1] = DeviceSelect;

            ntStatus = FcIssueCommand( fdoExtension,
                                       fdoExtension->FifoBuffer,
                                       fdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            //
            //  If the floppy controller reports a drive fault (Equipment Check) then
            //  we must issue another recalibrate command since we don't know if there is
            //  no drive present or if the drive has more than 80 tracks.
            //
            if ( NT_SUCCESS(ntStatus) &&
                 fdoExtension->FifoBuffer[0] & STREG0_DRIVE_FAULT ) {

                FdcDump( FDCSHOW, ("Fdc: FdcProbeFloppyDevice - issue 2nd recalibrate\n") );

                fdoExtension->FifoBuffer[0] = COMMND_RECALIBRATE;
                fdoExtension->FifoBuffer[1] = DeviceSelect;

                ntStatus = FcIssueCommand( fdoExtension,
                                           fdoExtension->FifoBuffer,
                                           fdoExtension->FifoBuffer,
                                           NULL,
                                           0,
                                           0 );

                if ( NT_SUCCESS(ntStatus) &&
                     fdoExtension->FifoBuffer[0] & STREG0_DRIVE_FAULT ) {

                    FdcDump( FDCSHOW, ("Fdc: FdcProbeFloppyDevice - failed device probe.\n") );
                    ntStatus = STATUS_NO_SUCH_DEVICE;
                }
            }
        }

        FcTurnOffMotor( fdoExtension );

        FcReleaseFdc( fdoExtension );
    }

    return ntStatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\fdc\inc\ntddfdc.h ===
/*++

Copyright (c) 1990-1998  Microsoft Corporation

Module Name:

    ntddfdc.h

Abstract:

    This is the include file that defines all constants and types for
    accessing the fdc.sys port adapter.

Revision History:

--*/

//
// Floppy Drive Motor Enable
//
#define FDC_MOTOR_A         0x10
#define FDC_MOTOR_B         0x20
#define FDC_MOTOR_C         0x40
#define FDC_MOTOR_D         0x80

//
// Floppy Drive Select
//
#define FDC_SELECT_A        0x00
#define FDC_SELECT_B        0x01
#define FDC_SELECT_C        0x02
#define FDC_SELECT_D        0x03

//
// Floppy commands.
//

#define COMMND_READ_DATA                   0x00
#define COMMND_READ_DELETED_DATA           0x01
#define COMMND_WRITE_DATA                  0x02
#define COMMND_WRITE_DELETED_DATA          0x03
#define COMMND_READ_TRACK                  0x04
#define COMMND_VERIFY                      0x05
#define COMMND_VERSION                     0x06
#define COMMND_FORMAT_TRACK                0x07
#define COMMND_SCAN_EQUAL                  0x08
#define COMMND_SCAN_LOW_OR_EQUAL           0x09
#define COMMND_SCAN_HIGH_OR_EQUAL          0x0A
#define COMMND_RECALIBRATE                 0x0B
#define COMMND_SENSE_INTERRUPT_STATUS      0x0C
#define COMMND_SPECIFY                     0x0D
#define COMMND_SENSE_DRIVE_STATUS          0x0E
#define COMMND_DRIVE_SPECIFICATION         0x0F
#define COMMND_SEEK                        0x10
#define COMMND_CONFIGURE                   0x11
#define COMMND_RELATIVE_SEEK               0x12
#define COMMND_DUMPREG                     0x13
#define COMMND_READ_ID                     0x14
#define COMMND_PERPENDICULAR_MODE          0x15
#define COMMND_LOCK                        0x16
#define COMMND_PART_ID                     0x17
#define COMMND_POWERDOWN_MODE              0x18
#define COMMND_OPTION                      0x19
#define COMMND_SAVE                        0x1A
#define COMMND_RESTORE                     0x1B
#define COMMND_FORMAT_AND_WRITE            0x1C

#ifdef TOSHIBA
#define TOSHIBA_COMMND_MODE     0x1D
#endif

//
// Optional bits used with the commands.
//

#define COMMND_OPTION_MULTI_TRACK          0x80     //
#define COMMND_OPTION_MFM                  0x40     /// Used in read and write commands
#define COMMND_OPTION_SKIP                 0x20     //

#define COMMND_OPTION_CLK48                0x80     // Used in configure command

#define COMMND_OPTION_DIRECTION            0x40     // Used in relative seek command

#define COMMND_OPTION_LOCK                 0x80     // Used in lock command

#define COMMND_DRIVE_SPECIFICATION_DONE    0x80     // Done bit in the Drive Specification argument string



//
// Floppy controler data rates (to be OR'd together)
//
#define FDC_SPEED_250KB     0x0001
#define FDC_SPEED_300KB     0x0002
#define FDC_SPEED_500KB     0x0004
#define FDC_SPEED_1MB       0x0008
#define FDC_SPEED_2MB       0x0010

//
// Dma Width supported
//
#define FDC_8_BIT_DMA       0x0001
#define FDC_16_BIT_DMA      0x0002

//
// Clock Rate to the FDC (FDC_82078 only)
//
#define FDC_CLOCK_NORMAL      0x0000    // Use this for non 82078 parts
#define FDC_CLOCK_48MHZ       0x0001    // 82078 with a 48MHz clock
#define FDC_CLOCK_24MHZ       0x0002    // 82078 with a 24MHz clock

//
// Floppy controler types
//
#define FDC_TYPE_UNKNOWN         0
#define FDC_TYPE_NORMAL          2
#define FDC_TYPE_ENHANCED        3
#define FDC_TYPE_82077           4
#define FDC_TYPE_82077AA         5
#define FDC_TYPE_82078_44        6
#define FDC_TYPE_82078_64        7
#define FDC_TYPE_NATIONAL        8

//
// Internal floppy disk driver device controls.
//

#define IOCTL_DISK_INTERNAL_ACQUIRE_FDC              CTL_CODE(IOCTL_DISK_BASE, 0x300, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_RELEASE_FDC              CTL_CODE(IOCTL_DISK_BASE, 0x301, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_GET_FDC_INFO             CTL_CODE(IOCTL_DISK_BASE, 0x302, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND        CTL_CODE(IOCTL_DISK_BASE, 0x303, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND_QUEUED CTL_CODE(IOCTL_DISK_BASE, 0x304, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_RESET_FDC                CTL_CODE(IOCTL_DISK_BASE, 0x305, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_ENABLE_FDC_DEVICE        CTL_CODE(IOCTL_DISK_BASE, 0x306, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_DISABLE_FDC_DEVICE       CTL_CODE(IOCTL_DISK_BASE, 0x307, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_GET_FDC_DISK_CHANGE      CTL_CODE(IOCTL_DISK_BASE, 0x308, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_SET_FDC_DATA_RATE        CTL_CODE(IOCTL_DISK_BASE, 0x309, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_SET_FDC_TAPE_MODE        CTL_CODE(IOCTL_DISK_BASE, 0x30a, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_SET_FDC_PRECOMP          CTL_CODE(IOCTL_DISK_BASE, 0x30b, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_GET_ADAPTER_BUFFER       CTL_CODE(IOCTL_DISK_BASE, 0x30c, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_FLUSH_ADAPTER_BUFFER     CTL_CODE(IOCTL_DISK_BASE, 0x30d, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_FDC_START_READ           CTL_CODE(IOCTL_DISK_BASE, 0x30e, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_FDC_START_WRITE          CTL_CODE(IOCTL_DISK_BASE, 0x30f, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_GET_ENABLER              CTL_CODE(IOCTL_DISK_BASE, 0x310, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_SET_HD_BIT               CTL_CODE(IOCTL_DISK_BASE, 0x311, METHOD_NEITHER, FILE_ANY_ACCESS)

#ifdef TOSHIBA
/* 3 mode support */
#define IOCTL_DISK_INTERNAL_ENABLE_3_MODE       CTL_CODE(IOCTL_DISK_BASE, 0xb01, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_DISK_INTERNAL_AVAILABLE_3_MODE       CTL_CODE(IOCTL_DISK_BASE, 0xb02, METHOD_NEITHER, FILE_ANY_ACCESS)

typedef struct _enable_3_mode
{   UCHAR   DeviceUnit;
    BOOLEAN Enable3Mode;
} ENABLE_3_MODE, *PENABLE_3_MODE;

#endif


//
// Transfer Buffer Array.  Contains the number of buffers allocated and a
// virtual address for each of the allocated buffers.
//
typedef struct _TRANSFER_BUFFER {
    PHYSICAL_ADDRESS Logical;
    PVOID             Virtual;
} TRANSFER_BUFFER, *PTRANSFER_BUFFER;

//
// Parameters for communicating with fdc.sys
//
//
//	Floppy Device Data returned from the ACPI _FDI method.  This data is
//	very nearly identical to the CM_FLOPPY_DEVICE_DATA retured via
//	IoQueryDeviceDescription.
//	
//	Refer to x86 BIOS documentation for Int13, function 8 for definitions of
//	these fields.
//
typedef struct _ACPI_FDI_DATA {

    ULONG   DriveNumber;
    ULONG   DeviceType;
    ULONG   MaxCylinderNumber;
    ULONG   MaxSectorNumber;
    ULONG   MaxHeadNumber;
    ULONG   StepRateHeadUnloadTime;
    ULONG   HeadLoadTime;
    ULONG   MotorOffTime;
    ULONG   SectorLengthCode;
    ULONG   SectorPerTrack;
    ULONG   ReadWriteGapLength;
    ULONG   DataTransferLength;
    ULONG   FormatGapLength;
    ULONG   FormatFillCharacter;
    ULONG   HeadSettleTime; // in 1ms units, typically 15ms
    ULONG   MotorSettleTime; // in 1/8ms units, typically 8=1ms

} ACPI_FDI_DATA, *PACPI_FDI_DATA;

typedef enum _ACPI_FDI_DEVICE_TYPE {

    CmosProblem = 0,
    Form525Capacity360,
    Form525Capacity1200,
    Form35Capacity720,
    Form35Capacity1440,
    Form35Capacity2880

} ACPI_FDI_DEVICE_TYPE ;

typedef struct _FDC_INFO {
    UCHAR FloppyControllerType;     // Should be any ONE of type FDC_TYPE_XXXX
    UCHAR SpeedsAvailable;          // Any combination of FDC_SPEED_xxxx or'd together
    ULONG AdapterBufferSize;        // number of bytes available in the adapters buffer
                                    // If zero,  then no limit on amount of data pending
                                    // in get/flush adapter buffer
    INTERFACE_TYPE BusType;
    ULONG BusNumber;                // These are used by floppy.sys to query
    ULONG ControllerNumber;         // its device description.
    ULONG PeripheralNumber;
    ULONG UnitNumber;               // NEC98: Indicate device unit number.

    ULONG MaxTransferSize;

	BOOLEAN	AcpiBios;
	BOOLEAN AcpiFdiSupported;
	ACPI_FDI_DATA AcpiFdiData;

    ULONG BufferCount;
    ULONG BufferSize;
    TRANSFER_BUFFER BufferAddress[];

} FDC_INFO, *PFDC_INFO;

//
// TurnOnMotor
//

typedef struct _FDC_ENABLE_PARMS {
    UCHAR DriveOnValue;             // FDC_MOTOR_X + FDC_SELECT_X
    USHORT TimeToWait;
    BOOLEAN MotorStarted;
} FDC_ENABLE_PARMS;

typedef FDC_ENABLE_PARMS *PFDC_ENABLE_PARMS;

//
// DiskChange
//

typedef struct _FDC_DISK_CHANGE_PARMS {
    UCHAR  DriveStatus;
    UCHAR  DriveOnValue;
} FDC_DISK_CHANGE_PARMS, *PFDC_DISK_CHANGE_PARMS;

//
// IssueCommand
//

typedef struct _ISSUE_FDC_COMMAND_PARMS {
    PUCHAR  FifoInBuffer;
    PUCHAR  FifoOutBuffer;
    PVOID   IoHandle;           // Must be "Handle" from ISSUE_FDC_ADAPTER_BUFFER_PARMS or Mdl
    ULONG   IoOffset;
    ULONG   TransferBytes;      // Must be return value from ISSUE_FDC_ADAPTER_BUFFER_PARMS "TransferBytes"
    ULONG   TimeOut;
} ISSUE_FDC_COMMAND_PARMS, *PISSUE_FDC_COMMAND_PARMS;

//
// Fill/Flush Adapter Buffer
//

typedef struct _ISSUE_FDC_ADAPTER_BUFFER_PARMS {
    PVOID   IoBuffer;           // Pointer to caller's data buffer (if NULL, no data is copied
                                // to (GET) /from (FLUSH) the adapter buffer)

    USHORT  TransferBytes;      // amount of data to transfer (could be less on return
                                // if insufficient space to copy buffer). Could be Zero
                                // if no buffers are available

    PVOID   Handle;             // used to pass in the IoBuffer field of the ISSUE_FDC_COMMAND_PARMS
                                // structure.

} ISSUE_FDC_ADAPTER_BUFFER_PARMS, *PISSUE_FDC_ADAPTER_BUFFER_PARMS;

//
// NEC98: Set a HD bit or a FDD EXC bit.
//

typedef struct _SET_HD_BIT_PARMS {

    BOOLEAN DriveType144MB;     // Indicate drive Type is 1.44MB.
    BOOLEAN Media144MB;         // Indicate media is 1.44MB
    BOOLEAN More120MB;          // Indicate capacity of media is 1.2MB or more
    UCHAR   DeviceUnit;         // Indicate device unit number
    BOOLEAN ChangedHdBit;       // Indicate HD Bit have been changed

} SET_HD_BIT_PARMS, *PSET_HD_BIT_PARMS;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\fdc\inc\flpyenbl.h ===
/*++

Copyright (c) 1996  Hewlett-Packard Corporation

Module Name:

    cmsfcxx.h

Abstract:

    This file includes data declarations for Floppy Controller Enabling

Author:

    Kurt Godwin (v-kurtg) 26-Mar-1996.

Environment:

    Kernel mode only.

Notes:

Revision History:

--*/

#define FDC_VALUE_API_SUPPORTED L"APISupported"
#define FDC_VALUE_CLOCK_48MHZ   L"Clock48MHz"

//
// Floppy controler data rates (to be OR'd together)
//
#define FDC_SPEED_250KB     0x0001
#define FDC_SPEED_300KB     0x0002
#define FDC_SPEED_500KB     0x0004
#define FDC_SPEED_1MB       0x0008
#define FDC_SPEED_2MB       0x0010

//
// Dma Width supported
//
#define FDC_8_BIT_DMA       0x0001
#define FDC_16_BIT_DMA      0x0002

//
// Dma direction
//
#define FDC_READ_FROM_MEMORY 0x0000
#define FDC_WRITE_TO_MEMORY  0x0001

//
// Clock Rate to the FDC (FDC_82078 only)
//
#define FDC_CLOCK_NORMAL      0x0000    // Use this for non 82078 parts
#define FDC_CLOCK_48MHZ       0x0001    // 82078 with a 48MHz clock
#define FDC_CLOCK_24MHZ       0x0002    // 82078 with a 24MHz clock

//
// Floppy controler types
//
#define FDC_TYPE_NORMAL          2  // Any NEC 768 compatible, 250Kb/sec 500Kb/sec
#define FDC_TYPE_ENHANCED        3  // Any NEC 768 compatible that supports the version command, 250Kb/sec 500Kb/sec
#define FDC_TYPE_82077           4  // National 8477, 250Kb/sec 500Kb/sec 1Mb/sec
#define FDC_TYPE_82077AA         5  // Intel 82077, 250Kb/sec 500Kb/sec 1Mb/sec
#define FDC_TYPE_82078_44        6  // Intel 82077AA, 250Kb/sec 500Kb/sec 1Mb/sec
#define FDC_TYPE_82078_64        7  // Intel 82078 44 Pin Version, 250Kb/sec 500Kb/sec 1Mb/sec(2Mb/sec capable)
#define FDC_TYPE_NATIONAL        8  // Intel 82078 64 Pin Version, 250Kb/sec 500Kb/sec 1Mb/sec(2Mb/sec capable)


typedef struct _FDC_MODE_SELECT {
    ULONG structSize;       // Size of this structure (inclusive)

    ULONG Speed;            // Should be only ONE of the data rates (i.e. FDC_SPEED_XXX)
                            // ONLY select speeds that were available from FDC_INFORMATION

    ULONG DmaWidth;         // Should be only ONE of the dma widths (i.e. FDC_16_BIT_DMA)
                            // ONLY select DMA Widths that were available from FDC_INFORMATION
    ULONG DmaDirection;     // Should be FDC_READ_FROM_MEMORY or FDC_WRITE_TO_MEMORY

    ULONG ClockRate;        // Should be FDC_48MHZ, FDC_24MHZ or zero

} FDC_MODE_SELECT, *PFDC_MODE_SELECT;

typedef struct _FDC_INFORMATION {
    ULONG structSize;       // Size of this structure (inclusive)

    ULONG SpeedsAvailable;      // Any combination of FDC_SPEED_xxxx or'd together

    ULONG DmaWidthsSupported;   // Any combination of FDC_xx_BIT_DMA

    ULONG ClockRatesSupported;  // Should be FDC_48MHZ, FDC_24MHZ or zero
                                // If the part is capable of both speeds
                                // return both OR'd together.  It is then
                                // the caller's responsiblity to set the
                                // proper data rate with FDC_MODE_SELECT

    ULONG FloppyControllerType; // Should be any ONE of type FDC_TYPE_XXXX

} FDC_INFORMATION, *PFDC_INFORMATION;

#define IOCTL_FLPENBL_BASE                 FILE_DEVICE_TAPE

//
// IOCTL Codes set to the enabler driver's IRP_MJ_INTERNAL_DEVICE_CONTROL
//
//
//


//
// ACQUIRE_FDC:
//
// input: Type3InputBuffer = PLARGE_INTEGER timeout;
// output:
//
// status:
//      Completion status will be STATUS_SUCCESS or STATUS_IN_USE
//
#define IOCTL_AQUIRE_FDC     CTL_CODE(IOCTL_FLPENBL_BASE, 0x0001, METHOD_NEITHER, FILE_ANY_ACCESS)
#define IOCTL_ACQUIRE_FDC    CTL_CODE(IOCTL_FLPENBL_BASE, 0x0001, METHOD_NEITHER, FILE_ANY_ACCESS)


//
// RELEASE_FDC
//
// input:
// output:
//
// status:
//      Completion status will be STATUS_SUCCESS or STATUS_INVALID_PARAMETER
//
#define IOCTL_RELEASE_FDC   CTL_CODE(IOCTL_FLPENBL_BASE, 0x0002, METHOD_NEITHER, FILE_ANY_ACCESS)


//
// GET_FDC_INFO
//
//
// input:
//      For this function,
//      (irp stack)->Parameters.DeviceIoControl.Type3InputBuffer
//      will point to a FDC_INFORMATION buffer (output only)
//
// output:
//
// status:
//      ioCompletion status will allways be STATUS_SUCCESS
//
#define IOCTL_GET_FDC_INFO  CTL_CODE(IOCTL_FLPENBL_BASE, 0x0003, METHOD_NEITHER, FILE_ANY_ACCESS)

//
// SET_FDC_MODE
//
// input:
//      For this function,
//      (irp stack)->Parameters.DeviceIoControl.Type3InputBuffer
//      will point to a FDC_MODE_SELECT buffer (input only)
//
//
// output:
//
// status:
//
// ioCompletion status will be STATUS_SUCCESS or STATUS_INVALID_PARAMETER
//
#define IOCTL_SET_FDC_MODE  CTL_CODE(IOCTL_FLPENBL_BASE, 0x0004, METHOD_NEITHER, FILE_ANY_ACCESS)

// ADD_CONTENDER
//
// input:
//      controller # (as in FloppyController#) of the controller that
//      wants to contend for resources used by this controller
//
// output:
//      NOTHING
//
#define IOCTL_ADD_CONTENDER  CTL_CODE(IOCTL_FLPENBL_BASE, 0x0005, METHOD_NEITHER, FILE_ANY_ACCESS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\acpiutil.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1999
//
//  File:       acpiutil.c
//
//--------------------------------------------------------------------------

#include "ideport.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(NONPAGE, DeviceQueryACPISettings)
#pragma alloc_text(NONPAGE, DeviceQueryACPISettingsCompletionRoutine)
#pragma alloc_text(NONPAGE, DeviceQueryFirmwareBootSettings)
#pragma alloc_text(NONPAGE, DeviceQueryChannelTimingSettings)

#pragma alloc_text(NONPAGE, ChannelSetACPITimingSettings)
#pragma alloc_text(NONPAGE, ChannelSyncSetACPITimingSettingsCompletionRoutine)
#pragma alloc_text(NONPAGE, ChannelSetACPITimingSettings)
#pragma alloc_text(NONPAGE, ChannelSetACPITimingSettingsCompletionRoutine)
#endif // ALLOC_PRAGMA


NTSTATUS
DeviceQueryACPISettings (
    IN PDEVICE_EXTENSION_HEADER DoExtension,
    IN ULONG ControlMethodName,
    OUT PACPI_EVAL_OUTPUT_BUFFER *QueryResult
    )
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK ioStatusBlock;
    ACPI_EVAL_INPUT_BUFFER cmInputData;
    PACPI_EVAL_OUTPUT_BUFFER cmOutputData;
    ULONG cmOutputDataSize;
    NTSTATUS status;
    KEVENT event;
    ULONG retry;
    ULONG systemBufferLength;
    PDEVICE_OBJECT targetDeviceObject;


    DebugPrint((DBG_ACPI,
                "ATAPI: ChannelQueryACPISettings for %c%c%c%c\n",
                ((PUCHAR)&ControlMethodName)[0],
                ((PUCHAR)&ControlMethodName)[1],
                ((PUCHAR)&ControlMethodName)[2],
                ((PUCHAR)&ControlMethodName)[3]
                ));

    RtlZeroMemory (
        &cmInputData,
        sizeof(cmInputData)
        );

    cmInputData.Signature = ACPI_EVAL_INPUT_BUFFER_SIGNATURE;
    cmInputData.MethodNameAsUlong = ControlMethodName;

    //
    // get the top of our device stack
    //
    targetDeviceObject = IoGetAttachedDeviceReference(
                             DoExtension->DeviceObject
                             );

    cmOutputDataSize = sizeof(ACPI_EVAL_OUTPUT_BUFFER);
    irp = NULL;

    for (retry=0; retry<2; retry++) {

        DebugPrint((DBG_ACPI, "ATAPI: _GTM try %x\n", retry));

        cmOutputData = ExAllocatePool (
                           NonPagedPool,
                           cmOutputDataSize
                           );
        if (cmOutputData == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        KeInitializeEvent(&event,
                          NotificationEvent,
                          FALSE);

        irp = IoAllocateIrp(targetDeviceObject->StackSize, FALSE);
        if (irp == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        if (sizeof(cmInputData) > cmOutputDataSize) {
            systemBufferLength = sizeof(cmInputData);
        } else {
            systemBufferLength = cmOutputDataSize;
        }

        irp->AssociatedIrp.SystemBuffer = ExAllocatePool(
                                              NonPagedPoolCacheAligned,
                                              systemBufferLength
                                              );
        if (irp->AssociatedIrp.SystemBuffer == NULL) {
            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        ASSERT ((IOCTL_ACPI_ASYNC_EVAL_METHOD & 0x3) == METHOD_BUFFERED);
        irp->Flags = IRP_BUFFERED_IO | IRP_INPUT_OPERATION;
        irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

        irpSp = IoGetNextIrpStackLocation( irp );

        irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
        irpSp->Parameters.DeviceIoControl.OutputBufferLength = cmOutputDataSize;
        irpSp->Parameters.DeviceIoControl.InputBufferLength = sizeof(cmInputData);
        irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_ACPI_ASYNC_EVAL_METHOD;

        RtlCopyMemory(
            irp->AssociatedIrp.SystemBuffer,
            &cmInputData,
            sizeof(cmInputData)
            );

        irp->UserBuffer = cmOutputData;

        IoSetCompletionRoutine(
            irp,
            DeviceQueryACPISettingsCompletionRoutine,
            &event,
            TRUE,
            TRUE,
            TRUE
            );

        status = IoCallDriver(targetDeviceObject, irp);

        if (status == STATUS_PENDING) {

            KeWaitForSingleObject(&event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
            status = irp->IoStatus.Status;
        }

        if (NT_SUCCESS(status)) {

            //
            // should get what we are expecting
            //
            ASSERT (
                cmOutputData->Signature ==
                ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE
            );
            if (cmOutputData->Signature !=
                ACPI_EVAL_OUTPUT_BUFFER_SIGNATURE) {

                status = STATUS_UNSUCCESSFUL;
            }
        }

        ExFreePool(irp->AssociatedIrp.SystemBuffer);
        IoFreeIrp(irp);
        irp = NULL;

        if (!NT_SUCCESS(status)) {

            //
            // grab the data length in case we need it
            //
            cmOutputDataSize = cmOutputData->Length;

            ExFreePool(cmOutputData);
            cmOutputData = NULL;

            if (status == STATUS_BUFFER_OVERFLOW) {

                //
                // output buffer too small, try again
                //

            } else {

                //
                // got some error, no need to retry
                //
                break;
            }
        }
    }

    //
    // Clean up
    //
    ObDereferenceObject (targetDeviceObject);

    if (irp) {

        if (irp->AssociatedIrp.SystemBuffer) {

            ExFreePool(irp->AssociatedIrp.SystemBuffer);
        }
        IoFreeIrp(irp);
    }

    //
    // returning
    //
    *QueryResult = cmOutputData;
    return status;
} // ChannelQueryACPISettings


NTSTATUS
DeviceQueryACPISettingsCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PKEVENT event = Context;

    if (!NT_ERROR(Irp->IoStatus.Status)) {

        //
        // Copy the information from the system
        // buffer to the caller's buffer.
        //
        RtlCopyMemory(
            Irp->UserBuffer,
            Irp->AssociatedIrp.SystemBuffer,
            Irp->IoStatus.Information
            );
    }


    KeSetEvent(
        event,
        EVENT_INCREMENT,
        FALSE
        );



    return STATUS_MORE_PROCESSING_REQUIRED;
} // DeviceQueryACPISettingsCompletionRoutine


NTSTATUS
DeviceQueryFirmwareBootSettings (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PDEVICE_SETTINGS *IdeBiosSettings
    )
{
    NTSTATUS status;
    PACPI_EVAL_OUTPUT_BUFFER queryResult;
    PDEVICE_SETTINGS ideBiosSettings;
    ULONG entryNumber;

    *IdeBiosSettings = NULL;

    status = DeviceQueryACPISettings (
                 (PDEVICE_EXTENSION_HEADER) PdoExtension,
                 ACPI_METHOD_GET_TASK_FILE,
                 &queryResult
                 );

    if (NT_SUCCESS(status)) {

        if (queryResult->Count != 1) {

            ASSERT (queryResult->Count == 1);
            status = STATUS_UNSUCCESSFUL;
        }
    }

    if (NT_SUCCESS(status)) {

        PACPI_METHOD_ARGUMENT argument;

        argument = queryResult->Argument;

        //
        // looking for buffer type
        //
        if (argument->Type == ACPI_METHOD_ARGUMENT_BUFFER) {

            ULONG numEntries;

            ASSERT (!(argument->DataLength % sizeof(ACPI_GTF_IDE_REGISTERS)));

            numEntries = argument->DataLength / sizeof(ACPI_GTF_IDE_REGISTERS);

            ideBiosSettings = ExAllocatePool (
                                  NonPagedPool,
                                  sizeof(DEVICE_SETTINGS) +
                                    numEntries * sizeof(IDEREGS)
                                  );
            if (!ideBiosSettings) {

                DebugPrint((DBG_ALWAYS, "ATAPI: ChannelQueryFirmwareBootSettings failed to allocate memory\n"));
                status = STATUS_INSUFFICIENT_RESOURCES;

            } else {


                for (entryNumber=0; entryNumber<numEntries; entryNumber++) {

                    RtlMoveMemory (
                        ideBiosSettings->FirmwareSettings + entryNumber,
                        argument->Data + entryNumber * sizeof(ACPI_GTF_IDE_REGISTERS),
                        sizeof(ACPI_GTF_IDE_REGISTERS)
                        );

                    ideBiosSettings->FirmwareSettings[entryNumber].bReserved = 0;
                }

                ideBiosSettings->NumEntries = numEntries;

                *IdeBiosSettings = ideBiosSettings;

#if DBG
                {
                    ULONG i;
                    DebugPrint((DBG_ACPI, "ATAPI: _GTF Data:\n"));
                    for (i=0; i<ideBiosSettings->NumEntries; i++) {
                        DebugPrint((DBG_ACPI, "\t"));
                        DebugPrint((DBG_ACPI, " 0x%02x", ideBiosSettings->FirmwareSettings[i].bFeaturesReg));
                        DebugPrint((DBG_ACPI, " 0x%02x", ideBiosSettings->FirmwareSettings[i].bSectorCountReg));
                        DebugPrint((DBG_ACPI, " 0x%02x", ideBiosSettings->FirmwareSettings[i].bSectorNumberReg));
                        DebugPrint((DBG_ACPI, " 0x%02x", ideBiosSettings->FirmwareSettings[i].bCylLowReg));
                        DebugPrint((DBG_ACPI, " 0x%02x", ideBiosSettings->FirmwareSettings[i].bCylHighReg));
                        DebugPrint((DBG_ACPI, " 0x%02x", ideBiosSettings->FirmwareSettings[i].bDriveHeadReg));
                        DebugPrint((DBG_ACPI, " 0x%02x", ideBiosSettings->FirmwareSettings[i].bCommandReg));
                        DebugPrint((DBG_ACPI, "\n"));
                    }
                }
#endif
            }
        }
    }

    //
    // clean up
    //
    if (queryResult) {

        ExFreePool (queryResult);
    }
    return status;
} // ChannelQueryFirmwareBootSettings


NTSTATUS
DeviceQueryChannelTimingSettings (
    IN PFDO_EXTENSION FdoExtension,
    IN OUT PACPI_IDE_TIMING TimimgSettings
    )
{
    NTSTATUS status;
    PACPI_EVAL_OUTPUT_BUFFER queryResult;
    PACPI_IDE_TIMING timimgSettings;
    ULONG i;

    status = DeviceQueryACPISettings (
                 (PDEVICE_EXTENSION_HEADER) FdoExtension,
                 ACPI_METHOD_GET_TIMING,
                 &queryResult
                 );

    if (NT_SUCCESS(status)) {

        if (queryResult->Count != 1) {

            ASSERT (queryResult->Count == 1);
            status = STATUS_UNSUCCESSFUL;
        }
    }

    if (NT_SUCCESS(status)) {

        PACPI_METHOD_ARGUMENT argument;

        //
        // PIO Speed
        //
        argument = queryResult->Argument;

        ASSERT (argument->Type == ACPI_METHOD_ARGUMENT_BUFFER);
        if ((argument->Type == ACPI_METHOD_ARGUMENT_BUFFER) &&
            (argument->DataLength >= sizeof (ACPI_IDE_TIMING))) {

            RtlCopyMemory (
                TimimgSettings,
                argument->Data,
                sizeof(ACPI_IDE_TIMING)
                );

            DebugPrint((DBG_ACPI, "ATAPI: _GTM Data:\n"));
            for (i=0; i<MAX_IDE_DEVICE; i++) {
                DebugPrint((DBG_ACPI, "\tPIO Speed %d: 0x%0x\n", i, TimimgSettings->Speed[i].Pio));
                DebugPrint((DBG_ACPI, "\tDMA Speed %d: 0x%0x\n", i, TimimgSettings->Speed[i].Dma));
            }
            DebugPrint((DBG_ACPI, "\tFlags:     0x%0x\n", TimimgSettings->Flags.AsULong));

			//
			// The following asserts are bogus. The ACPI spec doesn't say anything about the timing
			// information for the slave device in this case
			//
            //if (!TimimgSettings->Flags.b.IndependentTiming) {
             //   ASSERT (TimimgSettings->Speed[MAX_IDE_DEVICE - 1].Pio == ACPI_XFER_MODE_NOT_SUPPORT);
              //  ASSERT (TimimgSettings->Speed[MAX_IDE_DEVICE - 1].Dma == ACPI_XFER_MODE_NOT_SUPPORT);
            //}

        } else {

            status = STATUS_UNSUCCESSFUL;
        }

    }

    if (!NT_SUCCESS(status)) {

        for (i=0; i<MAX_IDE_DEVICE; i++) {

            TimimgSettings->Speed[i].Pio = ACPI_XFER_MODE_NOT_SUPPORT;
            TimimgSettings->Speed[i].Dma = ACPI_XFER_MODE_NOT_SUPPORT;
        }
    }

    //
    // clean up
    //
    if (queryResult) {

        ExFreePool (queryResult);
    }
    return status;
} // DeviceQueryChannelTimingSettings


NTSTATUS
ChannelSyncSetACPITimingSettings (
    IN PFDO_EXTENSION FdoExtension,
    IN PACPI_IDE_TIMING TimimgSettings,
    IN PIDENTIFY_DATA AtaIdentifyData[MAX_IDE_DEVICE]
    )
{
    SYNC_SET_ACPI_TIMING_CONTEXT context;
    NTSTATUS status;

    KeInitializeEvent(&context.Event,
                      NotificationEvent,
                      FALSE);

    context.IrpStatus = STATUS_UNSUCCESSFUL;

    status = ChannelSetACPITimingSettings (
                 FdoExtension,
                 TimimgSettings,
                 AtaIdentifyData,
                 ChannelSyncSetACPITimingSettingsCompletionRoutine,
                 &context
                 );

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&context.Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = context.IrpStatus;
    }

    return status;
}

NTSTATUS
ChannelSyncSetACPITimingSettingsCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PVOID Context
    )
{
    PSYNC_SET_ACPI_TIMING_CONTEXT context = Context;

    context->IrpStatus = Status;

    KeSetEvent(
        &context->Event,
        EVENT_INCREMENT,
        FALSE
        );

    return STATUS_MORE_PROCESSING_REQUIRED;
}


NTSTATUS
ChannelSetACPITimingSettings (
    IN PFDO_EXTENSION FdoExtension,
    IN PACPI_IDE_TIMING TimimgSettings,
    IN PIDENTIFY_DATA AtaIdentifyData[MAX_IDE_DEVICE],
    IN PSET_ACPI_TIMING_COMPLETION_ROUTINE CallerCompletionRoutine,
    IN PVOID CallerContext
    )
{
    ULONG i;
    PIRP irp;
    NTSTATUS status;
    PDEVICE_OBJECT targetDeviceObject;

    PACPI_EVAL_INPUT_BUFFER_COMPLEX cmInputData;
    ULONG cmInputDataSize;
    PACPI_METHOD_ARGUMENT argument;
    PASYNC_SET_ACPI_TIMING_CONTEXT context;

    PIO_STACK_LOCATION irpSp;

    DebugPrint((DBG_ACPI,
                "ATAPI: ChannelSetACPITimingSettings _STM data\n"
                ));
    for (i=0; i<MAX_IDE_DEVICE; i++) {
        DebugPrint((DBG_ACPI, "\tPIO Speed %d: 0x%0x\n", i, TimimgSettings->Speed[i].Pio));
        DebugPrint((DBG_ACPI, "\tDMA Speed %d: 0x%0x\n", i, TimimgSettings->Speed[i].Dma));
    }
    DebugPrint((DBG_ACPI, "\tFlags:     0x%0x\n", TimimgSettings->Flags.AsULong));


    cmInputData = NULL;
    irp = NULL;
    targetDeviceObject = NULL;
    context = NULL;

    //
    // get the memory we need
    //
    cmInputDataSize = sizeof (ACPI_EVAL_INPUT_BUFFER_COMPLEX) +
                      3 * sizeof (ACPI_METHOD_ARGUMENT) +
                      sizeof (ACPI_IDE_TIMING) +
                      2 * sizeof (IDENTIFY_DATA);

    cmInputData = ExAllocatePool (
                      NonPagedPool,
                      cmInputDataSize 
                      );

    if (cmInputData == NULL) {
        status=STATUS_INSUFFICIENT_RESOURCES;
        goto getout;
    }

    context = ExAllocatePool (NonPagedPool,
                              sizeof(ASYNC_SET_ACPI_TIMING_CONTEXT)
                              );


        
    if (context == NULL) {
        status=STATUS_INSUFFICIENT_RESOURCES;
        goto getout;
    }


    RtlZeroMemory (
        cmInputData,
        cmInputDataSize 
        );

    context->FdoExtension = FdoExtension;
    context->CallerCompletionRoutine = CallerCompletionRoutine;
    context->CallerContext = CallerContext;


    cmInputData->Signature = ACPI_EVAL_INPUT_BUFFER_COMPLEX_SIGNATURE;
    cmInputData->MethodNameAsUlong = ACPI_METHOD_SET_TIMING;
    cmInputData->Size = cmInputDataSize;
    cmInputData->ArgumentCount = 3;

    //
    // first argument
    //
    argument = cmInputData->Argument;

    argument->Type = ACPI_METHOD_ARGUMENT_BUFFER;
    argument->DataLength = sizeof(ACPI_IDE_TIMING);
    RtlCopyMemory (
        argument->Data,
        TimimgSettings,
        sizeof(ACPI_IDE_TIMING)
        );
    argument = ACPI_METHOD_NEXT_ARGUMENT(argument);

    //
    // second argument
    //
    argument->Type = ACPI_METHOD_ARGUMENT_BUFFER;

    if (AtaIdentifyData[0]) {

        argument->DataLength = sizeof(IDENTIFY_DATA);
        RtlCopyMemory (
            argument->Data,
            AtaIdentifyData[0],
            sizeof(IDENTIFY_DATA)
            );

        argument = ACPI_METHOD_NEXT_ARGUMENT(argument);

    } else {

        argument->DataLength = sizeof(IDENTIFY_DATA);
        RtlZeroMemory (
            argument->Data,
            sizeof(IDENTIFY_DATA)
            );

        argument = ACPI_METHOD_NEXT_ARGUMENT(argument);
    }

    //
    // third argument
    //
    argument->Type = ACPI_METHOD_ARGUMENT_BUFFER;
    if (AtaIdentifyData[1]) {

        argument->DataLength = sizeof(IDENTIFY_DATA);
        RtlCopyMemory (
            argument->Data,
            AtaIdentifyData[1],
            sizeof(IDENTIFY_DATA)
            );
    } else {

        argument->DataLength = sizeof(IDENTIFY_DATA);
        RtlZeroMemory (
            argument->Data,
            sizeof(IDENTIFY_DATA)
            );
    }

    //
    // get the top of our device stack
    //
    targetDeviceObject = IoGetAttachedDeviceReference(
                             FdoExtension->DeviceObject
                             );

    irp = IoAllocateIrp(targetDeviceObject->StackSize, FALSE);
    if (irp == NULL) {
        status = STATUS_INSUFFICIENT_RESOURCES;
        goto getout;
    }

    irp->AssociatedIrp.SystemBuffer = cmInputData;

    ASSERT ((IOCTL_ACPI_ASYNC_EVAL_METHOD & 0x3) == METHOD_BUFFERED);
    irp->Flags = IRP_BUFFERED_IO | IRP_INPUT_OPERATION;
    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    irpSp = IoGetNextIrpStackLocation( irp );

    irpSp->MajorFunction = IRP_MJ_DEVICE_CONTROL;
    irpSp->Parameters.DeviceIoControl.OutputBufferLength = 0;
    irpSp->Parameters.DeviceIoControl.InputBufferLength = cmInputDataSize;
    irpSp->Parameters.DeviceIoControl.IoControlCode = IOCTL_ACPI_ASYNC_EVAL_METHOD;

    irp->UserBuffer = NULL;

    IoSetCompletionRoutine(
        irp,
        ChannelSetACPITimingSettingsCompletionRoutine,
        context,
        TRUE,
        TRUE,
        TRUE
        );

    IoCallDriver(targetDeviceObject, irp);

    status = STATUS_PENDING;

getout:
    //
    // Clean up
    //
    if (targetDeviceObject) {

        ObDereferenceObject (targetDeviceObject);
    }

    if (!NT_SUCCESS(status) && (status != STATUS_PENDING)) {

        if (irp) {

            IoFreeIrp(irp);
        }

        if (cmInputData) {
            ExFreePool (cmInputData);
        }

        if (context) {
            ExFreePool(context);
        }
    }

    //
    // returning
    //
    return status;

} // ChannelSetACPITimingSettings

NTSTATUS
ChannelSetACPITimingSettingsCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PASYNC_SET_ACPI_TIMING_CONTEXT context = Context;

    if (!NT_SUCCESS(Irp->IoStatus.Status)) {

        DebugPrint ((DBG_ALWAYS,
                     "*********************************************\n"
                     "*********************************************\n"
                     "**                                          *\n"
                     "** ACPI Set Timing Failed with status %x    *\n"
                     "** Ignore it for now                        *\n"
                     "**                                          *\n"
                     "*********************************************\n"
                     "*********************************************\n",
                     Irp->IoStatus.Status
                     ));

        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    (*context->CallerCompletionRoutine) (
        DeviceObject,
        Irp->IoStatus.Status,
        context->CallerContext
        );

    ExFreePool (Irp->AssociatedIrp.SystemBuffer);
    ExFreePool(context);
    IoFreeIrp(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\atapi.c ===
/*++

Copyright (C) 1993-99  Microsoft Corporation

Module Name:

    atapi.c

Abstract:

    This is the miniport driver for IDE controllers.

Author:

    Mike Glass (MGlass)
    Chuck Park (ChuckP)
    Joe Dai (joedai)

Environment:

    kernel mode only

Notes:

Revision History:

    george C.(georgioc)     Merged wtih Compaq code to make miniport driver function
                            with the 120MB floppy drive
                            Added support for MEDIA STATUS NOTIFICATION
                            Added support for SCSIOP_START_STOP_UNIT (eject media)

    joedai                  PCI Bus Master IDE Support
                            ATA Passthrough (temporary solution)
                            LBA with ATA drive > 8G
                            PCMCIA IDE support
                            Native mode support

--*/

#include "ideport.h"

#if DBG
ULONG __DebugForceTimeout = 0;
static ULONG __DebugResetCounter = 0;
LOGICAL IdeDebugSimulateHardHang = FALSE;
#endif // DBG

#ifdef ALLOC_PRAGMA
    #pragma alloc_text(NONPAGE, InitHwExtWithIdentify)
#endif // ALLOC_PRAGMA

BOOLEAN
IssueIdentify(
             PIDE_REGISTERS_1    CmdBaseAddr,
             PIDE_REGISTERS_2    CtrlBaseAddr,
             IN ULONG            DeviceNumber,
             IN UCHAR            Command,
             IN BOOLEAN          InterruptOff,
             OUT PIDENTIFY_DATA  IdentifyData
             )

/*++

Routine Description:

    Issue IDENTIFY command to a device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    DeviceNumber - Indicates which device.
    Command - Either the standard (EC) or the ATAPI packet (A1) IDENTIFY.
    InterruptOff - should leave interrupt disabled

Return Value:

    TRUE if all goes well.

--*/

{
    ULONG                waitCount = 20000;
    ULONG                i,j;
    UCHAR                statusByte;
    UCHAR                signatureLow,
    signatureHigh;
    IDENTIFY_DATA        fullIdentifyData;

    RtlZeroMemory (IdentifyData, sizeof (IdentifyData));

    //
    // Select device 0 or 1.
    //
    SelectIdeDevice(CmdBaseAddr, DeviceNumber, 0);

    //
    // Check that the status register makes sense.
    //

    GetBaseStatus(CmdBaseAddr, statusByte);

    if (Command == IDE_COMMAND_IDENTIFY) {

        //
        // Mask status byte ERROR bits.
        //

        CLRMASK (statusByte, IDE_STATUS_ERROR | IDE_STATUS_INDEX);

        DebugPrint((1,
                    "IssueIdentify: Checking for IDE. Status (%x)\n",
                    statusByte));

        //
        // Check if register value is reasonable.
        //

        if (statusByte != IDE_STATUS_IDLE) {

            //
            // Reset the controller.
            //
            IdeHardReset (
                         CmdBaseAddr,
                         CtrlBaseAddr,
                         InterruptOff,
                         TRUE
                         );

            SelectIdeDevice(CmdBaseAddr, DeviceNumber, 0);

            //
            // Another check for signature, to deal with one model Atapi that doesn't assert signature after
            // a soft reset.
            //

            signatureLow = IdePortInPortByte(CmdBaseAddr->CylinderLow);
            signatureHigh = IdePortInPortByte(CmdBaseAddr->CylinderHigh);

            if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                //
                // Device is Atapi.
                //

                return FALSE;
            }

            if (Is98LegacyIde(CmdBaseAddr)) {

                AtapiSoftReset(CmdBaseAddr, CtrlBaseAddr, DeviceNumber, TRUE);

                WaitOnBusy(CmdBaseAddr, statusByte);

                if (!(statusByte & IDE_STATUS_ERROR)) {

                    //
                    // Device is WD-Mode cdrom.
                    //

                    return FALSE;
                }
            }

            GetBaseStatus(CmdBaseAddr, statusByte);
            CLRMASK (statusByte, IDE_STATUS_INDEX);

            if (statusByte != IDE_STATUS_IDLE) {

                //
                // Give up on this.
                //

                return FALSE;
            }

        }

    } else {

        DebugPrint((1,
                    "IssueIdentify: Checking for ATAPI. Status (%x)\n",
                    statusByte));

    }

    //
    // Load CylinderHigh and CylinderLow with number bytes to transfer.
    //

    IdePortOutPortByte(CmdBaseAddr->CylinderHigh, (0x200 >> 8));
    IdePortOutPortByte(CmdBaseAddr->CylinderLow,  (0x200 & 0xFF));

    for (j = 0; j < 2; j++) {

        //
        // Send IDENTIFY command.
        //

        WaitOnBusy(CmdBaseAddr,statusByte);

        IdePortOutPortByte(CmdBaseAddr->Command, Command);

        WaitOnBusy(CmdBaseAddr,statusByte);

        if (statusByte & IDE_STATUS_ERROR) {

            continue;
        }

        //
        // Wait for DRQ.
        //

        for (i = 0; i < 4; i++) {

            WaitForDrq(CmdBaseAddr, statusByte);

            if (statusByte & IDE_STATUS_DRQ) {

                //
                // Read status to acknowledge any interrupts generated.
                //

                GetBaseStatus(CmdBaseAddr, statusByte);

                //
                // One last check for Atapi.
                //


                signatureLow = IdePortInPortByte(CmdBaseAddr->CylinderLow);
                signatureHigh = IdePortInPortByte(CmdBaseAddr->CylinderHigh);

                if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                    //
                    // Device is Atapi.
                    //

                    return FALSE;
                }

                break;
            }

            if (Command == IDE_COMMAND_IDENTIFY) {

                //
                // Check the signature. If DRQ didn't come up it's likely Atapi.
                //

                signatureLow = IdePortInPortByte(CmdBaseAddr->CylinderLow);
                signatureHigh = IdePortInPortByte(CmdBaseAddr->CylinderHigh);

                if (signatureLow == 0x14 && signatureHigh == 0xEB) {

                    //
                    // Device is Atapi.
                    //

                    return FALSE;
                }

                if (Is98LegacyIde(CmdBaseAddr)) {

                    AtapiSoftReset(CmdBaseAddr, CtrlBaseAddr, DeviceNumber, TRUE);

                    WaitOnBusy(CmdBaseAddr, statusByte);

                    if (!(statusByte & IDE_STATUS_ERROR)) {

                        //
                        // Device is WD-Mode cdrom.
                        //

                        return FALSE;
                    }
                }
            }

            WaitOnBusy(CmdBaseAddr,statusByte);
        }

        if (i == 4 && j == 0) {

            //
            // Device didn't respond correctly. It will be given one more chances.
            //

            DebugPrint((1,
                        "IssueIdentify: DRQ never asserted (%x). Error reg (%x)\n",
                        statusByte,
                        IdePortInPortByte(CmdBaseAddr->Error)));

            AtapiSoftReset(CmdBaseAddr, CtrlBaseAddr, DeviceNumber, InterruptOff);

            GetStatus(CmdBaseAddr,statusByte);

            DebugPrint((1,
                        "IssueIdentify: Status after soft reset (%x)\n",
                        statusByte));

        } else {

            break;

        }
    }

    //
    // Check for error on really bad master devices that assert random
    // patterns of bits in the status register at the slave address.
    //
    if (statusByte & IDE_STATUS_ERROR) {
        return FALSE;
    }


    DebugPrint((1,
                "IssueIdentify: Status before read words %x\n",
                statusByte));

    //
    // pull out 256 words. After waiting for one model that asserts busy
    // after receiving the Packet Identify command.
    //

    WaitOnBusy(CmdBaseAddr,statusByte);

    if (!(statusByte & IDE_STATUS_DRQ)) {
        return FALSE;
    }

    if (Is98LegacyIde(CmdBaseAddr)) {
        //
        // Delay(10ms) for ATAPI CD-ROM device.
        //

        if (Command == IDE_COMMAND_ATAPI_IDENTIFY) {
            for (i = 0; i < 100; i++) {
                KeStallExecutionProcessor(100);
            }
        }
    }

    ReadBuffer(CmdBaseAddr,
               (PUSHORT)&fullIdentifyData,
               sizeof (fullIdentifyData) / 2);

    RtlMoveMemory(IdentifyData,&fullIdentifyData,sizeof(*IdentifyData));

    WaitOnBusy(CmdBaseAddr,statusByte);

    for (i = 0; i < 0x10000; i++) {

        GetStatus(CmdBaseAddr,statusByte);

        if (statusByte & IDE_STATUS_DRQ) {

            //
            // pull out any remaining bytes and throw away.
            //

            READ_PORT_USHORT(CmdBaseAddr->Data);

        } else {

            break;

        }
    }

    DebugPrint((3,
                "IssueIdentify: Status after read words (%x)\n",
                statusByte));

    return TRUE;

} // end IssueIdentify()

VOID
InitDeviceGeometry(
                  PHW_DEVICE_EXTENSION HwDeviceExtension,
                  ULONG                Device,
                  ULONG                NumberOfCylinders,
                  ULONG                NumberOfHeads,
                  ULONG                SectorsPerTrack
                  )
{

    ASSERT (HwDeviceExtension);
    ASSERT (Device < HwDeviceExtension->MaxIdeDevice);
    ASSERT (NumberOfCylinders);
    ASSERT (NumberOfHeads);
    ASSERT (SectorsPerTrack);

    HwDeviceExtension->NumberOfCylinders[Device] = NumberOfCylinders;
    HwDeviceExtension->NumberOfHeads[Device]     = NumberOfHeads;
    HwDeviceExtension->SectorsPerTrack[Device]   = SectorsPerTrack;

    return;
}

VOID
InitHwExtWithIdentify(
                     IN PVOID           HwDeviceExtension,
                     IN ULONG           DeviceNumber,
                     IN UCHAR           Command,
                     IN PIDENTIFY_DATA  IdentifyData,
                     IN BOOLEAN         RemovableMedia
                     )

/*++

Routine Description:

    Issue IDENTIFY command to a device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    DeviceNumber - Indicates which device.
    Command - Either the standard (EC) or the ATAPI packet (A1) IDENTIFY.
    InterruptOff - should leave interrupt disabled

Return Value:

    TRUE if all goes well.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG                i,j;

    //
    // Check out a few capabilities / limitations of the device.
    //

    if (IdentifyData->MediaStatusNotification == IDENTIFY_MEDIA_STATUS_NOTIFICATION_SUPPORTED) {

        //
        // Determine if this drive supports the MSN functions.
        //

        DebugPrint((2,"InitHwExtWithIdentify: Marking drive %d as removable. SFE = %d\n",
                    DeviceNumber,
                    IdentifyData->MediaStatusNotification));

        deviceExtension->DeviceFlags[DeviceNumber] |= DFLAGS_MSN_SUPPORT;
    }


    if (RemovableMedia) {

        //
        // This device has removable media
        //

        deviceExtension->DeviceFlags[DeviceNumber] |= DFLAGS_REMOVABLE_DRIVE;
        CLRMASK (deviceExtension->DeviceFlags[DeviceNumber], DFLAGS_IDENTIFY_VALID);

        DebugPrint((2,
                    "InitHwExtWithIdentify: Device media is removable\n"));

    } else {

        DebugPrint((2,
                    "InitHwExtWithIdentify: Device media is NOT removable\n"));
    }

    if (IdentifyData->GeneralConfiguration & 0x20 &&
        Command != IDE_COMMAND_IDENTIFY) {

        //
        // This device interrupts with the assertion of DRQ after receiving
        // Atapi Packet Command
        //

        deviceExtension->DeviceFlags[DeviceNumber] |= DFLAGS_INT_DRQ;

        DebugPrint((2,
                    "InitHwExtWithIdentify: Device interrupts on assertion of DRQ.\n"));

    } else {

        DebugPrint((2,
                    "InitHwExtWithIdentify: Device does not interrupt on assertion of DRQ.\n"));
    }

    if (((IdentifyData->GeneralConfiguration & 0xF00) == 0x100) &&
        Command != IDE_COMMAND_IDENTIFY) {

        //
        // This is a tape.
        //

        deviceExtension->DeviceFlags[DeviceNumber] |= DFLAGS_TAPE_DEVICE;

        DebugPrint((2,
                    "InitHwExtWithIdentify: Device is a tape drive.\n"));

    } else {

        DebugPrint((2,
                    "InitHwExtWithIdentify: Device is not a tape drive.\n"));
    }

    return;

} // InitHwExtWithIdentify


BOOLEAN
SetDriveParameters(
                  IN PVOID HwDeviceExtension,
                  IN ULONG DeviceNumber,
                  IN BOOLEAN Sync
                  )

/*++

Routine Description:

    Set drive parameters using the IDENTIFY data.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    DeviceNumber - Indicates which device.

Return Value:

    TRUE if all goes well.


--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1 = &deviceExtension->BaseIoAddress1;
    PIDE_REGISTERS_2     baseIoAddress2 = &deviceExtension->BaseIoAddress2;
    ULONG i;
    UCHAR statusByte;

    DebugPrint ((DBG_BUSSCAN, "SetDriveParameters: %s %d\n", __FILE__, __LINE__));

    DebugPrint((1,
                "SetDriveParameters: Number of heads %x\n",
                deviceExtension->NumberOfHeads[DeviceNumber]));

    DebugPrint((1,
                "SetDriveParameters: Sectors per track %x\n",
                deviceExtension->SectorsPerTrack[DeviceNumber]));
    if (deviceExtension->DeviceFlags[DeviceNumber] & DFLAGS_IDENTIFY_VALID) {

        ASSERT(!(deviceExtension->DeviceFlags[DeviceNumber] & DFLAGS_REMOVABLE_DRIVE));

        SETMASK(deviceExtension->DeviceFlags[DeviceNumber], DFLAGS_IDENTIFY_INVALID);
        CLRMASK(deviceExtension->DeviceFlags[DeviceNumber], DFLAGS_IDENTIFY_VALID);
    }

    //
    // Set up registers for SET PARAMETER command.
    //
    SelectIdeDevice(baseIoAddress1, DeviceNumber, (deviceExtension->NumberOfHeads[DeviceNumber] - 1));

    IdePortOutPortByte(baseIoAddress1->BlockCount,
                       (UCHAR)deviceExtension->SectorsPerTrack[DeviceNumber]);

    DebugPrint ((DBG_BUSSCAN, "SetDriveParameters: %s %d\n", __FILE__, __LINE__));

    //
    // Send SET PARAMETER command.
    //
    IdePortOutPortByte(baseIoAddress1->Command,
                       IDE_COMMAND_SET_DRIVE_PARAMETERS);

    DebugPrint ((DBG_BUSSCAN, "SetDriveParameters: %s %d\n", __FILE__, __LINE__));

    if (Sync) {

        DebugPrint ((DBG_BUSSCAN, "SetDriveParameters: %s %d\n", __FILE__, __LINE__));

        //
        // Wait for ERROR or command complete.
        //
        WaitOnBusy(baseIoAddress1,statusByte);

        DebugPrint ((DBG_BUSSCAN, "SetDriveParameters: %s %d\n", __FILE__, __LINE__));

        if (statusByte & IDE_STATUS_BUSY) {

            return FALSE;

        } else {

            if (statusByte & IDE_STATUS_ERROR) {

                UCHAR errorByte;

                errorByte = IdePortInPortByte(baseIoAddress1->Error);
                DebugPrint((1,
                            "SetDriveParameters: Error bit set. Status %x, error %x\n",
                            errorByte,
                            statusByte));

                return FALSE;

            } else {

                return TRUE;
            }
        }

    } else {

        return TRUE;
    }

} // end SetDriveParameters()

VOID
BuildResetStateTable (
    PHW_DEVICE_EXTENSION DeviceExtension
    )
{
    ULONG numStates;
    ULONG deviceNumber;

    //
    // build state table
    //
    numStates = 0;

    //
    // choose slave if master is not present
    //
    deviceNumber = (DeviceExtension->DeviceFlags[0] & DFLAGS_DEVICE_PRESENT) ? 0 : 1;

    DeviceExtension->ResetState.DeviceNumber[numStates] = deviceNumber;
    DeviceExtension->ResetState.State[numStates++] = IdeResetBegin;

    DeviceExtension->ResetState.DeviceNumber[numStates] = deviceNumber;
    DeviceExtension->ResetState.State[numStates++] = ideResetBusResetInProgress;

    for (deviceNumber = 0; deviceNumber < MAX_IDE_DEVICE; deviceNumber++) {

        if (DeviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {

            if (DeviceExtension->DeviceFlags[deviceNumber] & DFLAGS_ATAPI_DEVICE) {

                DeviceExtension->ResetState.DeviceNumber[numStates] = deviceNumber;
                DeviceExtension->ResetState.State[numStates++] = ideResetAtapiReset;

                DeviceExtension->ResetState.DeviceNumber[numStates] = deviceNumber;
                DeviceExtension->ResetState.State[numStates++] = ideResetAtapiResetInProgress;

                DeviceExtension->ResetState.DeviceNumber[numStates] = deviceNumber;
                DeviceExtension->ResetState.State[numStates++] = ideResetAtapiIdentifyData;

            } else {

                DeviceExtension->ResetState.DeviceNumber[numStates] = deviceNumber;
                DeviceExtension->ResetState.State[numStates++] = ideResetAtaIDP;

                DeviceExtension->ResetState.DeviceNumber[numStates] = deviceNumber;
                DeviceExtension->ResetState.State[numStates++] = ideResetAtaIDPInProgress;

                DeviceExtension->ResetState.DeviceNumber[numStates] = deviceNumber;
                DeviceExtension->ResetState.State[numStates++] = ideResetAtaMSN;
            }
        }
    }

    //
    // choose slave if master is not present
    //
    deviceNumber = (DeviceExtension->DeviceFlags[0] & DFLAGS_DEVICE_PRESENT) ? 0 : 1;

    DeviceExtension->ResetState.DeviceNumber[numStates] = deviceNumber;
    DeviceExtension->ResetState.State[numStates++] = ideResetFinal;

    ASSERT (numStates <= RESET_STATE_TABLE_LEN);

    return;
}

BOOLEAN
AtapiResetController(
                    IN PVOID  HwDeviceExtension,
                    IN ULONG  PathId,
                    IN PULONG CallAgain
                    )

/*++

Routine Description:

    Reset IDE controller and/or Atapi device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    Nothing.


--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1 baseIoAddress1;
    PIDE_REGISTERS_2 baseIoAddress2;
    BOOLEAN result = FALSE;
    ULONG i;
    UCHAR statusByte;
    ULONG numStates;
    BOOLEAN  enumProbing = FALSE;
    ULONG lineNumber, deviceNumber;
    BOOLEAN setResetFinalState; 

    baseIoAddress1 = &deviceExtension->BaseIoAddress1;
    baseIoAddress2 = &deviceExtension->BaseIoAddress2;

    if (*CallAgain == 0) {

        BuildResetStateTable(deviceExtension);
    }

    DebugPrint ((DBG_RESET,
                 "AtapiResetController CallAgain = 0x%x, device = 0x%x, busyCount = 0x%x\n",
                 *CallAgain,
                 deviceExtension->ResetState.DeviceNumber[*CallAgain],
                 deviceExtension->ResetState.WaitBusyCount
                ));

    switch (deviceExtension->ResetState.State[*CallAgain]) {
    
    case IdeResetBegin:

        DebugPrint((DBG_RESET,
                    "AtapiResetController: Reset 0x%x IDE...\n",
                    deviceExtension->BaseIoAddress1.RegistersBaseAddress));

        //
        // Check if request is in progress.
        //
        if (deviceExtension->CurrentSrb) {

            enumProbing = TestForEnumProbing (deviceExtension->CurrentSrb);

            if ((deviceExtension->CurrentSrb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH) ||
                (deviceExtension->CurrentSrb->Function == SRB_FUNCTION_ATA_PASS_THROUGH)) {

                PATA_PASS_THROUGH    ataPassThroughData;

                ataPassThroughData = deviceExtension->CurrentSrb->DataBuffer;

                AtapiTaskRegisterSnapshot (baseIoAddress1, &ataPassThroughData->IdeReg);

            } else if (deviceExtension->CurrentSrb->Function == SRB_FUNCTION_ATA_PASS_THROUGH_EX) {

                PIDEREGS pIdeReg = (PIDEREGS) deviceExtension->CurrentSrb->Cdb;

                AtapiTaskRegisterSnapshot(baseIoAddress1, pIdeReg);
            }

            //
            // Complete outstanding request with SRB_STATUS_BUS_RESET.
            //

            IdePortCompleteRequest(deviceExtension,
                                   deviceExtension->CurrentSrb,
                                   (ULONG)SRB_STATUS_BUS_RESET);

            //
            // Clear request tracking fields.
            //

            deviceExtension->CurrentSrb = NULL;
            deviceExtension->BytesLeft = 0;
            deviceExtension->DataBuffer = NULL;

            //
            // Indicate ready for next request.
            //

            IdePortNotification(IdeNextRequest,
                                deviceExtension,
                                NULL);

        }

        //
        // Clear DMA
        //
        if (deviceExtension->DMAInProgress) {
            deviceExtension->DMAInProgress = FALSE;
            deviceExtension->BusMasterInterface.BmDisarm (deviceExtension->BusMasterInterface.Context);
        }

        //
        // Clear expecting interrupt flag.
        //

        deviceExtension->ExpectingInterrupt = FALSE;
        deviceExtension->RDP = FALSE;

        if (!enumProbing) {

            //
            // ATA soft reset.  reset only ATA devices
            //
            IdeHardReset (
                         baseIoAddress1,
                         baseIoAddress2,
                         TRUE,
                         FALSE
                         );
            (*CallAgain)++;
            deviceExtension->ResetState.WaitBusyCount = 0;

            //
            // go to the next stage if a short wait satisfies the 
            // requirement
            //
            SelectIdeDevice(baseIoAddress1,
                            deviceExtension->ResetState.DeviceNumber[*CallAgain],
                            0
                            );

            GetStatus(baseIoAddress1,statusByte);

            WaitOnBusyUntil(baseIoAddress1, statusByte, 200);

            if (statusByte & IDE_STATUS_BUSY) {

                return TRUE;

            } else {

                return AtapiResetController(
                                           HwDeviceExtension,
                                           PathId,
                                           CallAgain
                                           );
            }

        } else {

            //
            // timeout is caused by a command sent to a non-existing device
            // no need to reset
            //
            *CallAgain = 0;
        }

        return TRUE;
        break;

        //
        // all these states waits for BUSY to go clear
        // then go to the next state
        //

    case ideResetBusResetInProgress:

        SelectIdeDevice(baseIoAddress1,
                        deviceExtension->ResetState.DeviceNumber[*CallAgain],
                        0
                        );

    case ideResetAtapiResetInProgress:
    case ideResetAtaIDPInProgress:

        GetStatus(baseIoAddress1,statusByte);

        if (statusByte & IDE_STATUS_BUSY) {

            deviceExtension->ResetState.WaitBusyCount++;

            if ((deviceExtension->ResetState.WaitBusyCount > 30) ||
                (statusByte == 0xff)) {

                //
                // reset fails
                //
                DebugPrint ((DBG_ALWAYS, "ATAPI ResetController: ATA soft reset fails\n"));

                if (IdePortChannelEmpty (baseIoAddress1, 
                                         baseIoAddress2, 
                                         deviceExtension->MaxIdeDevice)) {

                    IdePortNotification(IdeAllDeviceMissing,
                                        deviceExtension,
                                        NULL);
                    *CallAgain = 0;
                    IdePortOutPortByte (baseIoAddress2->DeviceControl, IDE_DC_REENABLE_CONTROLLER);
                    return TRUE;
                }

                //
                // no choice, but continue with the reset
                //
//                *CallAgain = 0;
//                IdePortOutPortByte (baseIoAddress2, IDE_DC_REENABLE_CONTROLLER);
//                return FALSE;

            } else {

                DebugPrint ((DBG_ALWAYS, "ATAPI: ResetController not ready (status = 0x%x) ...wait for 1 sec\n", statusByte));
                return TRUE;
            }
        }

        (*CallAgain)++;
        return AtapiResetController(
                                   HwDeviceExtension,
                                   PathId,
                                   CallAgain
                                   );
        break;

    case ideResetAtapiReset:
        SelectIdeDevice(baseIoAddress1, deviceExtension->ResetState.DeviceNumber[*CallAgain], 0);
        IdePortOutPortByte(baseIoAddress1->Command, IDE_COMMAND_ATAPI_RESET);
        deviceExtension->ResetState.WaitBusyCount = 0;
        (*CallAgain)++;

        //
        // go to the next stage if a short wait satisfies the 
        // requirement
        //
        GetStatus(baseIoAddress1,statusByte);

        WaitOnBusyUntil(baseIoAddress1, statusByte, 200);

        if (statusByte & IDE_STATUS_BUSY) {

            return TRUE;

        } else {

            return AtapiResetController(
                                       HwDeviceExtension,
                                       PathId,
                                       CallAgain
                                       );
        }

        return TRUE;
        break;

    case ideResetAtaIDP:
        if (!Is98LegacyIde(baseIoAddress1)) {
            SetDriveParameters(HwDeviceExtension,
                               deviceExtension->ResetState.DeviceNumber[*CallAgain],
                               FALSE);
        }
        deviceExtension->ResetState.WaitBusyCount = 0;
        (*CallAgain)++;

        //
        // go to the next stage if a short wait satisfies the 
        // requirement
        //
        GetStatus(baseIoAddress1,statusByte);

        WaitOnBusyUntil(baseIoAddress1, statusByte, 200);

        if (statusByte & IDE_STATUS_BUSY) {

            return TRUE;

        } else {

            return AtapiResetController(
                                       HwDeviceExtension,
                                       PathId,
                                       CallAgain
                                       );
        }

        return TRUE;
        break;

    case ideResetAtapiIdentifyData:

        //
        // the device shouldn't be busy at this point
        //
        SelectIdeDevice(&deviceExtension->BaseIoAddress1,
                        deviceExtension->ResetState.DeviceNumber[*CallAgain],
                        0
                        );

        WaitOnBusyUntil(&deviceExtension->BaseIoAddress1,
                        statusByte,
                        100
                       );

        //
        // issue identify command only if the device is not
        // already busy
        //
        if (!(statusByte & IDE_STATUS_BUSY)) {

            GetAtapiIdentifyQuick( &deviceExtension->BaseIoAddress1,
                                   &deviceExtension->BaseIoAddress2,
                                   deviceExtension->ResetState.DeviceNumber[*CallAgain],
                                   &deviceExtension->IdentifyData[deviceExtension->ResetState.DeviceNumber[*CallAgain]]
                                   );

            /*
            IssueIdentify(
                         &deviceExtension->BaseIoAddress1,
                         &deviceExtension->BaseIoAddress2,
                         deviceExtension->ResetState.DeviceNumber[*CallAgain],
                         IDE_COMMAND_ATAPI_IDENTIFY,
                         FALSE,
                         &deviceExtension->IdentifyData[deviceExtension->ResetState.DeviceNumber[*CallAgain]]
                         );
                         */

        }

//        InitHwExtWithIdentify(
//            HwDeviceExtension,
//            deviceExtension->ResetState.DeviceNumber[*CallAgain],
//            IDE_COMMAND_ATAPI_IDENTIFY,
//            &deviceExtension->IdentifyData[deviceExtension->ResetState.DeviceNumber[*CallAgain]]
//            );
        (*CallAgain)++;
        return AtapiResetController(
                                   HwDeviceExtension,
                                   PathId,
                                   CallAgain
                                   );
        break;

    case ideResetAtaMSN:
        IdeMediaStatus(
                      TRUE, 
                      HwDeviceExtension, 
                      deviceExtension->ResetState.DeviceNumber[*CallAgain]
                      );
        (*CallAgain)++;
        return AtapiResetController(
                                   HwDeviceExtension,
                                   PathId,
                                   CallAgain
                                   );
        break;

    case ideResetFinal:

        //
        // HACK: if any of the devices are busy at this point, then they should
        // be marked dead. This will anyway happen because of the timeout count.
        // However, the waitOnBusy macros in all the routines would consume upto
        // 30s leaving the sytem practically hung until the reset completes. Instead,
        // we just clear the device present flag before the routine is called and
        // restore it after that.
        //
        for (i = 0; i < (deviceExtension->MaxIdeDevice/MAX_IDE_DEVICE); i++) {

            if (deviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_PRESENT) {
                SelectIdeDevice(baseIoAddress1, i, 0);
                WaitOnBusyUntil(baseIoAddress1, statusByte, 100);

                if (statusByte & IDE_STATUS_BUSY) {
                    CLRMASK(deviceExtension->DeviceFlags[i], DFLAGS_DEVICE_PRESENT);
                    SETMASK(deviceExtension->DeviceFlags[i], DFLAGS_DEVICE_ERASED);
                }
            }
        }

        AtapiHwInitialize(HwDeviceExtension, NULL);

        //
        // Restore the device present flag
        //
        for (i = 0; i < (deviceExtension->MaxIdeDevice/MAX_IDE_DEVICE); i++) {

            if (deviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_ERASED) {
                SETMASK(deviceExtension->DeviceFlags[i], DFLAGS_DEVICE_PRESENT);
            }
        }

        if (IdePortChannelEmpty (baseIoAddress1, 
                                 baseIoAddress2, deviceExtension->MaxIdeDevice)) {

            IdePortNotification(IdeAllDeviceMissing,
                                deviceExtension,
                                NULL);
        }
        *CallAgain = 0;
        for (i = 0; i < (deviceExtension->MaxIdeDevice/MAX_IDE_DEVICE); i++) {
            SelectIdeLine(baseIoAddress1, i);
            IdePortOutPortByte (baseIoAddress2->DeviceControl, IDE_DC_REENABLE_CONTROLLER);
        }
        return TRUE;
        break;

    default:
        ASSERT(FALSE);
        *CallAgain = 0;
        for (i = 0; i < (deviceExtension->MaxIdeDevice/MAX_IDE_DEVICE); i++) {
            SelectIdeLine(baseIoAddress1, i);
            IdePortOutPortByte (baseIoAddress2->DeviceControl, IDE_DC_REENABLE_CONTROLLER);
        }
        return FALSE;
        break;
    }
} // end AtapiResetController()



ULONG
MapError(
        IN PVOID HwDeviceExtension,
        IN PSCSI_REQUEST_BLOCK Srb
        )

/*++

Routine Description:

    This routine maps ATAPI and IDE errors to specific SRB statuses.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    PIDE_REGISTERS_2     baseIoAddress2  = &deviceExtension->BaseIoAddress2;
    ULONG i;
    UCHAR errorByte;
    UCHAR srbStatus;
    UCHAR scsiStatus;
    SENSE_DATA  tempSenseBuffer;
    PSENSE_DATA  senseBuffer = (PSENSE_DATA)&tempSenseBuffer;

    //
    // Read the error register.
    //

    //errorByte = IdePortInPortByte(baseIoAddress1->Error);
    GetErrorByte(baseIoAddress1, errorByte);

    DebugPrint((DBG_IDE_DEVICE_ERROR,
                "MapError: cdb %x and Error register is %x\n",
                Srb->Cdb[0],
                errorByte));

    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

        switch (errorByte >> 4) {
        case SCSI_SENSE_NO_SENSE:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: No sense information\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_RECOVERED_ERROR:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: Recovered error\n"));
            scsiStatus = 0;
            srbStatus = SRB_STATUS_SUCCESS;
            break;

        case SCSI_SENSE_NOT_READY:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: Device not ready\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_MEDIUM_ERROR:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: Media error\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_HARDWARE_ERROR:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: Hardware error\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_ILLEGAL_REQUEST:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: Illegal request\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_UNIT_ATTENTION:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: Unit attention\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_DATA_PROTECT:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: Data protect\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_BLANK_CHECK:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: Blank check\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        case SCSI_SENSE_ABORTED_COMMAND:
            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "Atapi: Command Aborted\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;

        default:

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "ATAPI: Invalid sense information\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
            break;
        }

    } else {

        scsiStatus = 0;
        //
        // Save errorByte,to be used by SCSIOP_REQUEST_SENSE.
        //

        deviceExtension->ReturningMediaStatus = errorByte;

        RtlZeroMemory(senseBuffer, sizeof(SENSE_DATA));

        if (errorByte & IDE_ERROR_MEDIA_CHANGE_REQ) {
            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "IDE: Media change\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

            if (Srb->SenseInfoBuffer) {

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
                senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_OPERATOR_REQUEST;
                senseBuffer->AdditionalSenseCodeQualifier = SCSI_SENSEQ_MEDIUM_REMOVAL;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

        } else if (errorByte & IDE_ERROR_COMMAND_ABORTED) {

            DebugPrint((DBG_IDE_DEVICE_ERROR, "IDE: Command abort\n"));

            scsiStatus = SCSISTAT_CHECK_CONDITION;

            if ((errorByte & IDE_ERROR_CRC_ERROR) &&
                (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_USE_UDMA) &&
                SRB_USES_DMA(Srb)) {

                DebugPrint((1, "Srb 0x%x had a CRC error using UDMA\n", Srb));

                srbStatus = SRB_STATUS_PARITY_ERROR;

                if (Srb->SenseInfoBuffer) {

                    senseBuffer->ErrorCode = 0x70;
                    senseBuffer->Valid     = 1;
                    senseBuffer->AdditionalSenseLength = 0xb;
                    senseBuffer->SenseKey =  SCSI_SENSE_HARDWARE_ERROR;
                    senseBuffer->AdditionalSenseCode = 0x8;
                    senseBuffer->AdditionalSenseCodeQualifier = 0x3;

                    srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
                }

                deviceExtension->ErrorCount++;

            } else {

                srbStatus = SRB_STATUS_ABORTED;

                if (Srb->SenseInfoBuffer) {

                    senseBuffer->ErrorCode = 0x70;
                    senseBuffer->Valid     = 1;
                    senseBuffer->AdditionalSenseLength = 0xb;
                    senseBuffer->SenseKey =  SCSI_SENSE_ABORTED_COMMAND;
                    senseBuffer->AdditionalSenseCode = 0;
                    senseBuffer->AdditionalSenseCodeQualifier = 0;

                    srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
                }

                if (Srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) {

                    deviceExtension->ErrorCount++;
                }
            }

        } else if (errorByte & IDE_ERROR_END_OF_MEDIA) {

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "IDE: End of media\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

            if (Srb->SenseInfoBuffer) {

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_NOT_READY;
                senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_NO_MEDIA_IN_DEVICE;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }
            if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED)) {
                deviceExtension->ErrorCount++;
            }

        } else if (errorByte & IDE_ERROR_ILLEGAL_LENGTH) {

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "IDE: Illegal length\n"));
            srbStatus = SRB_STATUS_INVALID_REQUEST;

        } else if (errorByte & IDE_ERROR_BAD_BLOCK) {

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "IDE: Bad block\n"));
            srbStatus = SRB_STATUS_ERROR;
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            if (Srb->SenseInfoBuffer) {

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_HARDWARE_ERROR;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

        } else if (errorByte & IDE_ERROR_ID_NOT_FOUND) {

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "IDE: Id not found\n"));
            srbStatus = SRB_STATUS_ERROR;
            scsiStatus = SCSISTAT_CHECK_CONDITION;

            if (Srb->SenseInfoBuffer) {

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_ILLEGAL_REQUEST;
                senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_ILLEGAL_BLOCK;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

            deviceExtension->ErrorCount++;

        } else if (errorByte & IDE_ERROR_MEDIA_CHANGE) {

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "IDE: Media change\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

            if (Srb->SenseInfoBuffer) {

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
                senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }

        } else if (errorByte & IDE_ERROR_DATA_ERROR) {

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "IDE: Data error\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;

            if (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED)) {
                deviceExtension->ErrorCount++;
            }

            //
            // Build sense buffer
            //

            if (Srb->SenseInfoBuffer) {

                senseBuffer->ErrorCode = 0x70;
                senseBuffer->Valid     = 1;
                senseBuffer->AdditionalSenseLength = 0xb;
                senseBuffer->SenseKey = (deviceExtension->
                                         DeviceFlags[Srb->TargetId] & DFLAGS_REMOVABLE_DRIVE)? SCSI_SENSE_DATA_PROTECT : SCSI_SENSE_MEDIUM_ERROR;
                senseBuffer->AdditionalSenseCode = 0;
                senseBuffer->AdditionalSenseCodeQualifier = 0;

                srbStatus |= SRB_STATUS_AUTOSENSE_VALID;
            }
        } else { // no sense info

            DebugPrint((DBG_IDE_DEVICE_ERROR,
                        "IdePort: No sense information\n"));
            scsiStatus = SCSISTAT_CHECK_CONDITION;
            srbStatus = SRB_STATUS_ERROR;
        }

        if (senseBuffer->Valid == 1) {

            ULONG length = sizeof(SENSE_DATA);

            if (Srb->SenseInfoBufferLength < length ) {

               length = Srb->SenseInfoBufferLength;
            }

            ASSERT(length);
            ASSERT(Srb->SenseInfoBuffer);

            RtlCopyMemory(Srb->SenseInfoBuffer, (PVOID) senseBuffer, length);
        }

        if ((deviceExtension->ErrorCount >= MAX_ERRORS) &&
            (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_USE_DMA))) {

            deviceExtension->MaximumBlockXfer[Srb->TargetId] = 0;

            DebugPrint((DBG_ALWAYS,
                        "MapError: Disabling 32-bit PIO and Multi-sector IOs\n"));

            if (deviceExtension->ErrorCount == MAX_ERRORS) {

                //
                // Log the error.
                //

                IdePortLogError( HwDeviceExtension,
                                 Srb,
                                 Srb->PathId,
                                 Srb->TargetId,
                                 Srb->Lun,
                                 SP_BAD_FW_WARNING,
                                 4);
            }

            //
            // Reprogram to not use Multi-sector.
            //

            for (i = 0; i < deviceExtension->MaxIdeDevice; i++) {
                UCHAR statusByte;

                if (deviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_PRESENT &&
                    !(deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE)) {

                    //
                    // Select the device.
                    //
                    SelectIdeDevice(baseIoAddress1, i, 0);

                    //
                    // Setup sector count to reflect the # of blocks.
                    //

                    IdePortOutPortByte(baseIoAddress1->BlockCount,
                                       0);

                    //
                    // Issue the command.
                    //

                    IdePortOutPortByte(baseIoAddress1->Command,
                                       IDE_COMMAND_SET_MULTIPLE);

                    //
                    // Wait for busy to drop.
                    //

                    WaitOnBaseBusy(baseIoAddress1,statusByte);

                    //
                    // Check for errors. Reset the value to 0 (disable MultiBlock) if the
                    // command was aborted.
                    //

                    if (statusByte & IDE_STATUS_ERROR) {

                        //
                        // Read the error register.
                        //

                        errorByte = IdePortInPortByte(baseIoAddress1->Error);

                        DebugPrint((DBG_ALWAYS,
                                    "AtapiHwInitialize: Error setting multiple mode. Status %x, error byte %x\n",
                                    statusByte,
                                    errorByte));
                        //
                        // Adjust the devExt. value, if necessary.
                        //

                        deviceExtension->MaximumBlockXfer[i] = 0;

                    }
                    deviceExtension->DeviceParameters[i].IdePioReadCommand      = IDE_COMMAND_READ;
                    deviceExtension->DeviceParameters[i].IdePioWriteCommand     = IDE_COMMAND_WRITE;

#ifdef ENABLE_48BIT_LBA
                    if (deviceExtension->DeviceFlags[i] & DFLAGS_48BIT_LBA) {
                        deviceExtension->DeviceParameters[i].IdePioReadCommandExt = IDE_COMMAND_READ_EXT;
                        deviceExtension->DeviceParameters[i].IdePioWriteCommandExt = IDE_COMMAND_WRITE_EXT;
                    }
#endif
                    deviceExtension->DeviceParameters[i].MaxBytePerPioInterrupt = 512;
                    deviceExtension->MaximumBlockXfer[i] = 0;
                }
            }
        }
    }


    //
    // Set SCSI status to indicate a check condition.
    //

    Srb->ScsiStatus = scsiStatus;

    return srbStatus;

} // end MapError()

NTSTATUS
AtapiSetTransferMode (
                     PHW_DEVICE_EXTENSION DeviceExtension,
                     ULONG                DeviceNumber,
                     UCHAR                ModeValue
                     )
{

    PIDE_REGISTERS_1    baseIoAddress1 = &DeviceExtension->BaseIoAddress1;
    UCHAR               ideStatus; 

    if (DeviceExtension->CurrentSrb) {
        DebugPrint ((DBG_ALWAYS, "DeviceExtension->CurrentSrb = 0x%x\n", DeviceExtension->CurrentSrb));
        ASSERT(DeviceExtension->CurrentSrb == NULL);
    }
    ASSERT (DeviceExtension->ExpectingInterrupt == FALSE);

    if (Is98LegacyIde(baseIoAddress1)) {

        if ( !EnhancedIdeSupport() ) {

            DebugPrint((1,"atapi: AtapiSetTransferMode -  not enhanced-ide.\n"));
            return STATUS_INVALID_DEVICE_REQUEST;
        }

        if (DeviceExtension->DeviceFlags[DeviceNumber] & DFLAGS_WD_MODE) {
            //
            // WD-Mode cd-rom can not set transfer mode.
            //

            DebugPrint((1,"atapi: AtapiSetTransferMode -  not enhanced-ide.\n"));
            return STATUS_INVALID_DEVICE_REQUEST;
        }
    }

    SelectIdeDevice(baseIoAddress1, DeviceNumber, 0);

    WaitOnBusy(baseIoAddress1, ideStatus);

    IdePortOutPortByte(
                      baseIoAddress1->Error,
                      IDE_SET_FEATURE_SET_TRANSFER_MODE
                      );

    IdePortOutPortByte(
                      baseIoAddress1->BlockCount,
                      ModeValue
                      );

    IdePortOutPortByte(
                      baseIoAddress1->Command,
                      IDE_COMMAND_SET_FEATURE
                      );

    WaitOnBusy(baseIoAddress1, ideStatus);

    if (ideStatus & (IDE_STATUS_BUSY | IDE_STATUS_ERROR)) {

        return STATUS_INVALID_DEVICE_REQUEST;

    } else {

        return STATUS_SUCCESS;
    }
}



VOID
AtapiProgramTransferMode (
                         PHW_DEVICE_EXTENSION DeviceExtension
                         )
{
    ULONG                       i;

    for (i=0; i<DeviceExtension->MaxIdeDevice; i++) {

        UCHAR ideCommand;
        ULONG pioModeStatus;
        ULONG dmaModeStatus;
        ULONG xferMode;

        if (!(DeviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_PRESENT)) {

            continue;
        }

        DebugPrint((DBG_XFERMODE, "ATAPI: ProgramTransferMode device %x- TMSelected = 0x%x\n",
                    i,
                    DeviceExtension->DeviceParameters[i].TransferModeSelected));

        CLRMASK (DeviceExtension->DeviceFlags[i], DFLAGS_USE_DMA | DFLAGS_USE_UDMA);

        if (!DeviceExtension->NoPioSetTransferMode) {

            //
            // many old devices just don't support set transfer mode
            // they act unpredictably after receiving one
            // e.g. "SAMSUNG SCR-730 REV D-05" cdrom will start returning
            // no error on TEST_UNIT_READY even if it doesn't have a media
            // 
            // we are going to apply some magic code here!!
            // we would not set transfer mode if the device doesn't support
            // timing faster than mode2
            //
            GetHighestPIOTransferMode(DeviceExtension->DeviceParameters[i].TransferModeSelected, xferMode);

            if (xferMode > PIO2) {

                DebugPrint((DBG_XFERMODE, "ATAPI: device %x, setting PIOmode 0x%x\n",
                            i,
                            xferMode));

                ideCommand = IDE_SET_ADVANCE_PIO_MODE(xferMode-PIO0);

                pioModeStatus = AtapiSetTransferMode (
                                                     DeviceExtension,
                                                     i, 
                                                     ideCommand
                                                     );
                if (!NT_SUCCESS(pioModeStatus)) {

                    DebugPrint ((DBG_ALWAYS, 
                                 "ATAPI: Unable to set pio xfer mode %d for 0x%x device %d\n", 
                                 xferMode,
                                 DeviceExtension->BaseIoAddress1.RegistersBaseAddress,
                                 i));
                }
            }
        }

        //
        // Program DMA mode
        //
        GetHighestDMATransferMode(DeviceExtension->DeviceParameters[i].TransferModeSelected, xferMode);


        if (xferMode >= UDMA0) {

            ideCommand = IDE_SET_UDMA_MODE(xferMode-UDMA0);

        } else if (xferMode >= MWDMA0) {

            ideCommand = IDE_SET_MWDMA_MODE(xferMode-MWDMA0);

        } else if (xferMode >= SWDMA0) {

            ideCommand = IDE_SET_SWDMA_MODE(xferMode-SWDMA0);

        }

        //
        // Issue the set features command only if we support
        // any of the DMA modes
        //
        if (xferMode >= SWDMA0) {

            DebugPrint((DBG_XFERMODE, "ATAPI: device %x, setting DMAmode 0x%x\n",
                        i,
                        xferMode));

            dmaModeStatus = AtapiSetTransferMode (
                                                 DeviceExtension,
                                                 i, 
                                                 ideCommand
                                                 );
            if (NT_SUCCESS(dmaModeStatus)) {

                DeviceExtension->DeviceFlags[i] |= DFLAGS_USE_DMA;

                if (xferMode >= UDMA0) {
                    DeviceExtension->DeviceFlags[i] |= DFLAGS_USE_UDMA;
                }

            } else {

                DebugPrint ((DBG_ALWAYS, 
                             "ATAPI: Unable to set DMA mode %d for  0x%x device %d\n",
                             xferMode,
                             DeviceExtension->BaseIoAddress1.RegistersBaseAddress,
                             i));
            }
        }
    }
    return;
}



BOOLEAN
AtapiHwInitialize(
                 IN PVOID HwDeviceExtension,
                 IN UCHAR FlushCommand[MAX_IDE_DEVICE * MAX_IDE_LINE]
                 )

/*++

Routine Description:

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    TRUE - if initialization successful.
    FALSE - if initialization unsuccessful.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress;
    ULONG i;
    UCHAR statusByte, errorByte;

    baseIoAddress = &deviceExtension->BaseIoAddress1;

    for (i = 0; i < deviceExtension->MaxIdeDevice; i++) {
        if (deviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_PRESENT) {

            //
            // Select device
            //
            SelectIdeDevice(baseIoAddress, i, 0);

            //
            // Make sure device is ready for any command
            //
            if (!(deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE)) {

                WaitForDRDY(baseIoAddress, statusByte);
            }

            if (!(deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE)) {

                //
                // Enable media status notification
                //

                IdeMediaStatus(TRUE,HwDeviceExtension,i);

                //
                // If supported, setup Multi-block transfers.
                //
                if (deviceExtension->MaximumBlockXfer[i]) {

                    //
                    // Select the device.
                    //
                    SelectIdeDevice(baseIoAddress, i, 0);

                    //
                    // Setup sector count to reflect the # of blocks.
                    //

                    IdePortOutPortByte(baseIoAddress->BlockCount,
                                       deviceExtension->MaximumBlockXfer[i]);

                    //
                    // Issue the command.
                    //

                    IdePortOutPortByte(baseIoAddress->Command,
                                       IDE_COMMAND_SET_MULTIPLE);

                    //
                    // Wait for busy to drop.
                    //

                    WaitOnBaseBusy(baseIoAddress,statusByte);

                    //
                    // Check for errors. Reset the value to 0 (disable MultiBlock) if the
                    // command was aborted.
                    //

                    if (statusByte & IDE_STATUS_ERROR) {

                        //
                        // Read the error register.
                        //

                        errorByte = IdePortInPortByte(baseIoAddress->Error);

                        DebugPrint((1,
                                    "AtapiHwInitialize: Error setting multiple mode. Status %x, error byte %x\n",
                                    statusByte,
                                    errorByte));
                        //
                        // Adjust the devExt. value, if necessary.
                        //

                        deviceExtension->MaximumBlockXfer[i] = 0;

                    } else {
                        DebugPrint((2,
                                    "AtapiHwInitialize: Using Multiblock on Device %d. Blocks / int - %d\n",
                                    i,
                                    deviceExtension->MaximumBlockXfer[i]));
                    }
                }
            }

            // IdeMediaStatus(TRUE,HwDeviceExtension,i);

            //
            // We need to get our device ready for action before
            // returning from this function
            //
            // According to the atapi spec 2.5 or 2.6, an atapi device
            // clears its status BSY bit when it is ready for atapi commands.
            // However, some devices (Panasonic SQ-TC500N) are still
            // not ready even when the status BSY is clear.  They don't react
            // to atapi commands.
            //
            // Since there is really no other indication that tells us
            // the drive is really ready for action.  We are going to check BSY
            // is clear and then just wait for an arbitrary amount of time!  At
            // least for the older ATAPI changers.
            //
            if (deviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE) {
                PIDE_REGISTERS_1     baseIoAddress1 = &deviceExtension->BaseIoAddress1;
                PIDE_REGISTERS_2     baseIoAddress2 = &deviceExtension->BaseIoAddress2;
                ULONG waitCount;

                // have to get out of the loop sometime!
                // 10000 * 100us = 1000,000us = 1000ms = 1s
                waitCount = 10000;
                GetStatus(baseIoAddress1, statusByte);
                while ((statusByte & IDE_STATUS_BUSY) && waitCount) {
                    //
                    // Wait for Busy to drop.
                    //
                    KeStallExecutionProcessor(100);
                    GetStatus(baseIoAddress1, statusByte);
                    waitCount--;
                }
            }
        }
    }

    AtapiProgramTransferMode (deviceExtension);

    InitDeviceParameters (HwDeviceExtension, FlushCommand);

    return TRUE;

} // end AtapiHwInitialize()


VOID
AtapiHwInitializeMultiLun (
                          IN PVOID HwDeviceExtension,
                          IN ULONG TargetId,
                          IN ULONG numSlot
                          )
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;

    deviceExtension->DeviceFlags[TargetId] |= DFLAGS_MULTI_LUN_INITED;

    deviceExtension->LastLun[TargetId] = (numSlot == 0) ? 0 : (numSlot - 1);

    return;
}

#ifdef DRIVER_PARAMETER_REGISTRY_SUPPORT

ULONG
AtapiParseArgumentString(
                        IN PCHAR String,
                        IN PCHAR KeyWord
                        )

/*++

Routine Description:

    This routine will parse the string for a match on the keyword, then
    calculate the value for the keyword and return it to the caller.

Arguments:

    String - The ASCII string to parse.
    KeyWord - The keyword for the value desired.

Return Values:

    Zero if value not found
    Value converted from ASCII to binary.

--*/

{
    PCHAR cptr;
    PCHAR kptr;
    ULONG value;
    ULONG stringLength = 0;
    ULONG keyWordLength = 0;
    ULONG index;

    if (!String) {
        return 0;
    }
    if (!KeyWord) {
        return 0;
    }

    //
    // Calculate the string length and lower case all characters.
    //

    cptr = String;
    while (*cptr) {
        if (*cptr >= 'A' && *cptr <= 'Z') {
            *cptr = *cptr + ('a' - 'A');
        }
        cptr++;
        stringLength++;
    }

    //
    // Calculate the keyword length and lower case all characters.
    //

    cptr = KeyWord;
    while (*cptr) {

        if (*cptr >= 'A' && *cptr <= 'Z') {
            *cptr = *cptr + ('a' - 'A');
        }
        cptr++;
        keyWordLength++;
    }

    if (keyWordLength > stringLength) {

        //
        // Can't possibly have a match.
        //

        return 0;
    }

    //
    // Now setup and start the compare.
    //

    cptr = String;

    ContinueSearch:

    //
    // The input string may start with white space.  Skip it.
    //

    while (*cptr == ' ' || *cptr == '\t') {
        cptr++;
    }

    if (*cptr == '\0') {

        //
        // end of string.
        //

        return 0;
    }

    kptr = KeyWord;
    while (*cptr++ == *kptr++) {

        if (*(cptr - 1) == '\0') {

            //
            // end of string
            //

            return 0;
        }
    }

    if (*(kptr - 1) == '\0') {

        //
        // May have a match backup and check for blank or equals.
        //

        cptr--;
        while (*cptr == ' ' || *cptr == '\t') {
            cptr++;
        }

        //
        // Found a match.  Make sure there is an equals.
        //

        if (*cptr != '=') {

            //
            // Not a match so move to the next semicolon.
            //

            while (*cptr) {
                if (*cptr++ == ';') {
                    goto ContinueSearch;
                }
            }
            return 0;
        }

        //
        // Skip the equals sign.
        //

        cptr++;

        //
        // Skip white space.
        //

        while ((*cptr == ' ') || (*cptr == '\t')) {
            cptr++;
        }

        if (*cptr == '\0') {

            //
            // Early end of string, return not found
            //

            return 0;
        }

        if (*cptr == ';') {

            //
            // This isn't it either.
            //

            cptr++;
            goto ContinueSearch;
        }

        value = 0;
        if ((*cptr == '0') && (*(cptr + 1) == 'x')) {

            //
            // Value is in Hex.  Skip the "0x"
            //

            cptr += 2;
            for (index = 0; *(cptr + index); index++) {

                if (*(cptr + index) == ' ' ||
                    *(cptr + index) == '\t' ||
                    *(cptr + index) == ';') {
                    break;
                }

                if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                    value = (16 * value) + (*(cptr + index) - '0');
                } else {
                    if ((*(cptr + index) >= 'a') && (*(cptr + index) <= 'f')) {
                        value = (16 * value) + (*(cptr + index) - 'a' + 10);
                    } else {

                        //
                        // Syntax error, return not found.
                        //
                        return 0;
                    }
                }
            }
        } else {

            //
            // Value is in Decimal.
            //

            for (index = 0; *(cptr + index); index++) {

                if (*(cptr + index) == ' ' ||
                    *(cptr + index) == '\t' ||
                    *(cptr + index) == ';') {
                    break;
                }

                if ((*(cptr + index) >= '0') && (*(cptr + index) <= '9')) {
                    value = (10 * value) + (*(cptr + index) - '0');
                } else {

                    //
                    // Syntax error return not found.
                    //
                    return 0;
                }
            }
        }

        return value;
    } else {

        //
        // Not a match check for ';' to continue search.
        //

        while (*cptr) {
            if (*cptr++ == ';') {
                goto ContinueSearch;
            }
        }

        return 0;
    }
}
#endif

VOID
InitDeviceParameters (
                     IN PVOID HwDeviceExtension,
                     IN UCHAR FlushCommand[MAX_IDE_DEVICE * MAX_IDE_LINE]
                     )
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG deviceNumber;

    //
    // pick out the ATA or ATAPI r/w command we are going to use
    //
    for (deviceNumber = 0; deviceNumber < deviceExtension->MaxIdeDevice; deviceNumber++) {
        if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {

            DebugPrint ((DBG_BUSSCAN, "ATAPI: Base=0x%x Device %d is going to do ", deviceExtension->BaseIoAddress1.RegistersBaseAddress, deviceNumber));
            if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_USE_DMA) {
                DebugPrint ((DBG_BUSSCAN, "DMA\n"));
            } else {
                DebugPrint ((DBG_BUSSCAN, "PIO\n"));
            }


            if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_ATAPI_DEVICE) {

                deviceExtension->DeviceParameters[deviceNumber].MaxBytePerPioInterrupt = 512;

            } else {

                if (deviceExtension->MaximumBlockXfer[deviceNumber]) {

                    DebugPrint ((DBG_BUSSCAN, "ATAPI: ATA Device (%d) is going to do PIO Multiple\n", deviceNumber));

                    deviceExtension->DeviceParameters[deviceNumber].IdePioReadCommand = IDE_COMMAND_READ_MULTIPLE;
                    deviceExtension->DeviceParameters[deviceNumber].IdePioWriteCommand = IDE_COMMAND_WRITE_MULTIPLE;

#ifdef ENABLE_48BIT_LBA
                    if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_48BIT_LBA) {
                        deviceExtension->DeviceParameters[deviceNumber].IdePioReadCommandExt = IDE_COMMAND_READ_MULTIPLE_EXT;
                        deviceExtension->DeviceParameters[deviceNumber].IdePioWriteCommandExt = IDE_COMMAND_WRITE_MULTIPLE_EXT;
                    }
#endif

                    deviceExtension->DeviceParameters[deviceNumber].MaxBytePerPioInterrupt =
                    deviceExtension->MaximumBlockXfer[deviceNumber] * 512;
                } else {

                    DebugPrint ((DBG_BUSSCAN, "ATAPI: ATA Device (%d) is going to do PIO Single\n", deviceNumber));

                    deviceExtension->DeviceParameters[deviceNumber].IdePioReadCommand = IDE_COMMAND_READ;
                    deviceExtension->DeviceParameters[deviceNumber].IdePioWriteCommand = IDE_COMMAND_WRITE;

#ifdef ENABLE_48BIT_LBA
                    if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_48BIT_LBA) {
                        deviceExtension->DeviceParameters[deviceNumber].IdePioReadCommandExt = IDE_COMMAND_READ_EXT;
                        deviceExtension->DeviceParameters[deviceNumber].IdePioWriteCommandExt = IDE_COMMAND_WRITE_EXT;
                    }
#endif
                    deviceExtension->DeviceParameters[deviceNumber].MaxBytePerPioInterrupt = 512;
                }

                if (FlushCommand) {

                    deviceExtension->DeviceParameters[deviceNumber].IdeFlushCommand = FlushCommand[deviceNumber];

#ifdef ENABLE_48BIT_LBA
                    //
                    // if the flush command worked then we are going to assume that the flush command
                    // for the 48 bit LBA feature set is supported.
                    //
                    if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_48BIT_LBA) {
                        deviceExtension->DeviceParameters[deviceNumber].IdeFlushCommandExt = IDE_COMMAND_FLUSH_CACHE_EXT;
                        deviceExtension->DeviceParameters[deviceNumber].IdeFlushCommand = IDE_COMMAND_NO_FLUSH;
                    }
#endif
                }
            }
        }
    }
}


ULONG
Atapi2Scsi(
          IN PHW_DEVICE_EXTENSION DeviceExtension,
          IN PSCSI_REQUEST_BLOCK Srb,
          IN char *DataBuffer,
          IN ULONG ByteCount
          )
/*++

Routine Description:

    Convert atapi cdb and mode sense data to scsi format

Arguments:

    Srb         - SCSI request block
    DataBuffer  - mode sense data
    ByteCount   - mode sense data length

Return Value:

    byte adjust

--*/
{
    ULONG bytesAdjust = 0;

    if (DeviceExtension->scsi2atapi) {

        if (Srb->Cdb[0] == ATAPI_MODE_SENSE) {

            ASSERT(FALSE);

        } else if (Srb->Cdb[0] == ATAPI_LS120_FORMAT_UNIT) {

            Srb->Cdb[0] = SCSIOP_FORMAT_UNIT;
        }

        RESTORE_ORIGINAL_CDB(DeviceExtension, Srb);

        DeviceExtension->scsi2atapi = FALSE;
    }
    return bytesAdjust;
}


VOID
AtapiCallBack(
             IN PVOID HwDeviceExtension
             )
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK  srb = deviceExtension->CurrentSrb;
    PATAPI_REGISTERS_1   baseIoAddress1;
    UCHAR statusByte;

    //
    // If the last command was DSC restrictive, see if it's set. If so, the device is
    // ready for a new request. Otherwise, reset the timer and come back to here later.
    //

    if (srb && (!(deviceExtension->ExpectingInterrupt))) {
#if DBG
        if (!SRB_IS_RDP(srb)) {
            DebugPrint((1,
                        "AtapiCallBack: Invalid CDB marked as RDP - %x\n",
                        srb->Cdb[0]));
        }
#endif

        baseIoAddress1 = (PATAPI_REGISTERS_1)&deviceExtension->BaseIoAddress1;
        if (deviceExtension->RDP) {
            GetStatus(baseIoAddress1, statusByte);
            if (statusByte & IDE_STATUS_DSC) {

                IdePortNotification(IdeRequestComplete,
                                    deviceExtension,
                                    srb);

                //
                // Clear current SRB.
                //

                deviceExtension->CurrentSrb = NULL;
                deviceExtension->RDP = FALSE;

                //
                // Ask for next request.
                //

                IdePortNotification(IdeNextRequest,
                                    deviceExtension,
                                    NULL);


                return;

            } else {

                DebugPrint((3,
                            "AtapiCallBack: Requesting another timer for Op %x\n",
                            deviceExtension->CurrentSrb->Cdb[0]));

                IdePortNotification(IdeRequestTimerCall,
                                    HwDeviceExtension,
                                    AtapiCallBack,
                                    1000);
                return;
            }
        }
    }

    DebugPrint((2,
                "AtapiCallBack: Calling ISR directly due to BUSY\n"));
    AtapiInterrupt(HwDeviceExtension);

}

//#define IdeCrashDumpLogIsrStatus(hwExtension, isrStatus) hwExtension->CrashDumpIsrStatus[hwExtension->CrashDumpLogIndex]=isrStatus;

BOOLEAN
AtapiInterrupt(
              IN PVOID HwDeviceExtension
              )

/*++

Routine Description:

    This is the interrupt service routine for ATAPI IDE miniport driver.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage

Return Value:

    TRUE if expecting an interrupt.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PSCSI_REQUEST_BLOCK srb              = deviceExtension->CurrentSrb;
    PATAPI_REGISTERS_1 baseIoAddress1;
    PATAPI_REGISTERS_2 baseIoAddress2;
    ULONG byteCount = 0, bytesThisInterrupt = 512;
    ULONG status;
    ULONG i;
    UCHAR statusByte,interruptReason;
    BOOLEAN commandComplete = FALSE;
    BOOLEAN atapiDev = FALSE;
    UCHAR dmaStatus;
    BOOLEAN fakeStatus = FALSE;
    BOOLEAN packetBasedSrb;
    BOOLEAN wdModeCdRom;
    BMSTATUS bmStatus=0;
    BOOLEAN dmaInProgress = FALSE;
    BOOLEAN alwaysClearBusMasterInterrupt;
    UCHAR savedCmd;
    BOOLEAN interruptCleared = FALSE;

    alwaysClearBusMasterInterrupt = deviceExtension->BusMasterInterface.AlwaysClearBusMasterInterrupt;


    //
    // if this flag is set, we must try to clear the busmaster interrupt
    // this is to overcome a bug in the cpq controller
    // this is set for native mode contollers
    //                                     
    if (alwaysClearBusMasterInterrupt) {
        if (deviceExtension->BusMasterInterface.BmStatus) {
            bmStatus = deviceExtension->BusMasterInterface.BmStatus (deviceExtension->BusMasterInterface.Context);
            if (bmStatus & BMSTATUS_INTERRUPT) {
                deviceExtension->BusMasterInterface.BmDisarm (deviceExtension->BusMasterInterface.Context);

                interruptCleared = TRUE;
            }
        }
    }


    if (srb) {

        baseIoAddress1 =    (PATAPI_REGISTERS_1)&deviceExtension->BaseIoAddress1;
        baseIoAddress2 =    (PATAPI_REGISTERS_2)&deviceExtension->BaseIoAddress2;
    } else {
        DebugPrint((1,
                    "AtapiInterrupt: CurrentSrb is NULL.  Bogus Interrupt\n"));
        if (deviceExtension->InterruptMode == LevelSensitive) {
            if (deviceExtension->BaseIoAddress1.RegistersBaseAddress != NULL) {
                baseIoAddress1 = (PATAPI_REGISTERS_1)&deviceExtension->BaseIoAddress1;
                GetBaseStatus(baseIoAddress1, statusByte);
                /*
                GetSelectedIdeDevice(baseIoAddress1, savedCmd);
                SelectIdeDevice(baseIoAddress1, 0, 0);
                GetBaseStatus(baseIoAddress1, statusByte);
                SelectIdeDevice(baseIoAddress1, 1, 0);
                GetBaseStatus(baseIoAddress1, statusByte);
                ReSelectIdeDevice(baseIoAddress1, savedCmd);
                */
            }
        }

        return interruptCleared;
    }

    if (!(deviceExtension->ExpectingInterrupt)) {

        DebugPrint((1,
                    "AtapiInterrupt: Unexpected interrupt.\n"));

        return interruptCleared;
    }

    if (!alwaysClearBusMasterInterrupt) {
        if (deviceExtension->BusMasterInterface.BmStatus) {
            bmStatus = deviceExtension->BusMasterInterface.BmStatus (deviceExtension->BusMasterInterface.Context);
            if (bmStatus & BMSTATUS_INTERRUPT) {
                deviceExtension->BusMasterInterface.BmDisarm (deviceExtension->BusMasterInterface.Context);
            }
        }
    }

    //
    // For SiS IDE Controller, we have to read the bm status register first
    //
    if (deviceExtension->DMAInProgress) {

        // PCI Busmaster IDE Controller spec defines a bit in its status
        // register which indicates pending interrupt.  However,
        // CMD 646 (maybe some other one, too) doesn't always do that if
        // the interrupt is from a atapi device.  (strange, but true!)
        // Since we can look at this interrupt bit only if we are sharing
        // interrupt, we will do just that

        //
        // Doesn't look like it is our interrupt
        // If we are called from crashdmp (polling mode) then prociess the interrupt
        // even if the bit is not set. It is checked in the crashdmp routine.
        //
        if (!(bmStatus & BMSTATUS_INTERRUPT) && 
            !(deviceExtension->DriverMustPoll)) {
            DebugPrint((1, "No BusMaster Interrupt\n"));

            ASSERT(interruptCleared == FALSE);
            return FALSE;
        }

        dmaInProgress = deviceExtension->DMAInProgress;
        deviceExtension->DMAInProgress = FALSE;

        if (deviceExtension->BusMasterInterface.IgnoreActiveBitForAtaDevice) {
            if (!(deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE)) {
                CLRMASK (bmStatus, BMSTATUS_NOT_REACH_END_OF_TRANSFER);
            }
        }
    }

    //
    // should we check for the interrupt bit for PIO transfers?
    //

    //
    // Select IDE line(Primary or Secondary).
    //
    SelectIdeLine(baseIoAddress1, srb->TargetId >> 1);

    //
    // Clear interrupt by reading status.
    //
    GetBaseStatus(baseIoAddress1, statusByte);

#ifdef ENABLE_ATAPI_VERIFIER
    if (ViIdeGenerateDmaTimeout(deviceExtension, dmaInProgress)) {
        deviceExtension->ExpectingInterrupt = FALSE;
        return TRUE;
    }
#endif

    //
    // Log the bus master status
    //
    if (!deviceExtension->DriverMustPoll) {
        IdeLogBmStatus(srb, bmStatus);
    }

    //IdeCrashDumpLogIsrStatus(deviceExtension, bmStatus);
    //
    // check the type of srb we have
    //
    if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

        packetBasedSrb = TRUE;

    } else {

        packetBasedSrb = FALSE;
    }


    if ((srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH) ||
        (srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH) ||
        (srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH_EX)) {

        PIDEREGS             pIdeReg;

        packetBasedSrb = FALSE;

        if (srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH_EX) {

            pIdeReg = (PIDEREGS) srb->Cdb;

        } else {

            PATA_PASS_THROUGH    ataPassThroughData;

            ataPassThroughData = srb->DataBuffer;
            pIdeReg            = &ataPassThroughData->IdeReg;
        }

        //
        // if the last command we issued was a SLEEP command,
        // the device interface (task registers) is invalid.
        // In order to complete the interrupt, will fake the 
        // a good status
        //
        if (pIdeReg->bCommandReg == IDE_COMMAND_SLEEP) {

            fakeStatus = TRUE;
        }

    }

    if (fakeStatus) {

        statusByte = IDE_STATUS_IDLE;
    }

    DebugPrint((1,
                "AtapiInterrupt: Entered with status (%x)\n",
                statusByte));


    if (statusByte & IDE_STATUS_BUSY) {

        if (deviceExtension->DriverMustPoll) {

            //
            // Crashdump is polling and we got caught with busy asserted.
            // Just go away, and we will be polled again shortly.
            //

            DebugPrint((1,
                        "AtapiInterrupt: Hit status=0x%x while polling during crashdump.\n", 
                        statusByte
                       ));

            deviceExtension->DMAInProgress = TRUE;
            return TRUE;
        }

        if (dmaInProgress) {

            //
            // this is really bad since we already disabled
            // dma at this point, but the device is still busy
            // can't really recover. just return from now.  
            // the timeout code will kick in and save the world
            //

            DebugPrint((DBG_ALWAYS,
                        "AtapiInterrupt: End of DMA transfer but device is still BUSY.  status = 0x%x\n", 
                        statusByte));

            //
            // we are not expecting interrupt anymore. Clear the flag.
            //
            deviceExtension->ExpectingInterrupt = FALSE;
            return interruptCleared;
        }

        //
        // Ensure BUSY is non-asserted.
        //

        for (i = 0; i < 10; i++) {

            GetBaseStatus(baseIoAddress1, statusByte);
            if (!(statusByte & IDE_STATUS_BUSY)) {
                break;
            }

        }

        if (i == 10) {

            DebugPrint((2,
                        "AtapiInterrupt: BUSY on entry. Status %x, Base IO %x\n",
                        statusByte,
                        baseIoAddress1));

            IdePortNotification(IdeRequestTimerCall,
                                HwDeviceExtension,
                                AtapiCallBack,
                                500);

            return interruptCleared;
        }
    }

    //
    // Check for error conditions.
    //

    if (statusByte & IDE_STATUS_ERROR) {

        if (srb->Cdb[0] != SCSIOP_REQUEST_SENSE) {

            //
            // Fail this request.
            //

            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        }
    }

    wdModeCdRom = FALSE;

    if (Is98LegacyIde(baseIoAddress1)) {

        if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_WD_MODE) {
            if (deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE) {

                wdModeCdRom = TRUE;

            } else {

                status = SRB_STATUS_ERROR;
                goto CompleteRequest;
            }
        }
    }

    //
    // check reason for this interrupt.
    //
    if (packetBasedSrb && !wdModeCdRom) {

        interruptReason = (IdePortInPortByte(baseIoAddress1->InterruptReason) & 0x3);
        atapiDev = TRUE;
        bytesThisInterrupt = 512;

        if (dmaInProgress) {

            if (interruptReason != 0x3) {

                //
                // the device causes an interrupt in the middle of a
                // dma transfer!  bad bad bad device!
                // do nothing and just return.  this will get translated
                // to a timeout and we will retry.
                //
                DebugPrint((1, 
                            "Interrupt during DMA transfer, reason %x != 0x3\n", 
                            interruptReason
                           ));

                deviceExtension->ExpectingInterrupt = FALSE;

                return interruptCleared;
            }
        }

    } else {

        if (dmaInProgress) {

            interruptReason = 0x3;

        } else if (statusByte & IDE_STATUS_DRQ) {

            if (deviceExtension->MaximumBlockXfer[srb->TargetId]) {
                bytesThisInterrupt = 512 * deviceExtension->MaximumBlockXfer[srb->TargetId];

            }

            if (srb->SrbFlags & SRB_FLAGS_DATA_IN) {

                interruptReason =  0x2;

            } else if (srb->SrbFlags & SRB_FLAGS_DATA_OUT) {
                interruptReason = 0x0;

            } else {
                status = SRB_STATUS_ERROR;
                goto CompleteRequest;
            }

        } else if (statusByte & IDE_STATUS_BUSY) {

            ASSERT(interruptCleared == FALSE);
            return FALSE;

        } else {

            if (deviceExtension->BytesLeft && (!Is98LegacyIde(baseIoAddress1))) {

                //
                // We should return interruptCleared. But this is set based on
                // the bus master status bits. For non dma operations, we should not
                // rely on this. This code path should be revisited and the correct
                // return value should be determined. 
                //
                return interruptCleared;

            } else {

                //
                // Command complete - verify, write, or the SMART enable/disable.
                //
                // Also get_media_status

                interruptReason = 0x3;
            }
        }
    }

    if (interruptReason == 0x1 && (statusByte & IDE_STATUS_DRQ)) {

        //
        // Write the packet.
        //

        DebugPrint((2,
                    "AtapiInterrupt: Writing Atapi packet.\n"));

        //
        // Send CDB to device.
        //

        WriteBuffer(baseIoAddress1,
                    (PUSHORT)srb->Cdb,
                    6);

        if (SRB_USES_DMA(srb)) {
            deviceExtension->DMAInProgress = TRUE;
            deviceExtension->BusMasterInterface.BmArm (deviceExtension->BusMasterInterface.Context);
        }

        return interruptCleared;

    } else if (interruptReason == 0x0 && (statusByte & IDE_STATUS_DRQ)) {

        //
        // Write the data.
        //
        if (packetBasedSrb) {

            //
            // Pick up bytes to transfer and convert to words.
            //

            byteCount =
            IdePortInPortByte(baseIoAddress1->ByteCountLow);

            byteCount |=
            IdePortInPortByte(baseIoAddress1->ByteCountHigh) << 8;

            if (byteCount != deviceExtension->BytesLeft) {
                DebugPrint((3,
                            "AtapiInterrupt: %d bytes requested; %d bytes xferred\n",
                            deviceExtension->BytesLeft,
                            byteCount));
            }

            //
            // Verify this makes sense.
            //

            if (byteCount > deviceExtension->BytesLeft) {
                byteCount = deviceExtension->BytesLeft;
            }

        } else {

            //
            // IDE path. Check if words left is at least 256.
            //

            if (deviceExtension->BytesLeft < bytesThisInterrupt) {

                //
                // Transfer only words requested.
                //

                byteCount = deviceExtension->BytesLeft;

            } else {

                //
                // Transfer next block.
                //

                byteCount = bytesThisInterrupt;
            }
        }

        //
        // Ensure that this is a write command.
        //

        if (srb->SrbFlags & SRB_FLAGS_DATA_OUT) {

            DebugPrint((3,
                        "AtapiInterrupt: Write interrupt\n"));

            WaitOnBusy(baseIoAddress1,statusByte);

            WriteBuffer(baseIoAddress1,
                        (PUSHORT)deviceExtension->DataBuffer,
                        byteCount / sizeof(USHORT));

            if (byteCount & 1) {

                //
                // grab the last byte
                //
                IdePortOutPortByte(
                                  (PUCHAR)(baseIoAddress1->Data), 
                                  deviceExtension->DataBuffer[byteCount - 1]
                                  );
            }

        } else {

            DebugPrint((1,
                        "AtapiInterrupt: Int reason %x, but srb is for a write %x.\n",
                        interruptReason,
                        srb));

            //
            // Fail this request.
            //

            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        }


        //
        // Advance data buffer pointer and bytes left.
        //

        deviceExtension->DataBuffer += byteCount;
        deviceExtension->BytesLeft -= byteCount;

        return interruptCleared;

    } else if (interruptReason == 0x2 && (statusByte & IDE_STATUS_DRQ)) {

        if (packetBasedSrb) {

            //
            // Pick up bytes to transfer
            //

            byteCount =
            IdePortInPortByte(baseIoAddress1->ByteCountLow);

            byteCount |=
            IdePortInPortByte(baseIoAddress1->ByteCountHigh) << 8;

            if (byteCount != deviceExtension->BytesLeft) {
                DebugPrint((3,
                            "AtapiInterrupt: %d bytes requested; %d bytes xferred\n",
                            deviceExtension->BytesLeft,
                            byteCount));
            }

            //
            // Verify this makes sense.
            //

            if (byteCount > deviceExtension->BytesLeft) {
                byteCount = deviceExtension->BytesLeft;
            }

        } else {

            //
            // Check if words left is at least 256.
            //

            if (deviceExtension->BytesLeft < bytesThisInterrupt) {

                //
                // Transfer only words requested.
                //

                byteCount = deviceExtension->BytesLeft;

            } else {

                //
                // Transfer next block.
                //

                byteCount = bytesThisInterrupt;
            }
        }

        //
        // Ensure that this is a read command.
        //

        if (srb->SrbFlags & SRB_FLAGS_DATA_IN) {

            DebugPrint((3,
                        "AtapiInterrupt: Read interrupt\n"));

            WaitOnBusy(baseIoAddress1,statusByte);

            ReadBuffer(baseIoAddress1,
                       (PUSHORT)deviceExtension->DataBuffer,
                       byteCount / sizeof(USHORT));

            if (byteCount & 1) {

                //
                // grab the last byte
                //
                deviceExtension->DataBuffer[byteCount - 1] = IdePortInPortByte((PUCHAR)(baseIoAddress1->Data));
            }

        } else {

            DebugPrint((1,
                        "AtapiInterrupt: Int reason %x, but srb is for a read %x.\n",
                        interruptReason,
                        srb));

            //
            // Fail this request.
            //

            status = SRB_STATUS_ERROR;
            goto CompleteRequest;
        }

        //
        // Translate ATAPI data back to SCSI data if needed
        //
        if (deviceExtension->scsi2atapi) {

            //
            //convert and adjust the wordCount
            //
            byteCount -= Atapi2Scsi(
                                   deviceExtension, 
                                   srb, 
                                   deviceExtension->DataBuffer,
                                   byteCount 
                                   );
        }

        //
        // Advance data buffer pointer and bytes left.
        //

        deviceExtension->DataBuffer += byteCount;
        deviceExtension->BytesLeft -= byteCount;

        //
        // Check for read command complete.
        //

        if (deviceExtension->BytesLeft == 0) {

            if (packetBasedSrb) {

                //
                // Work around to make many atapi devices return correct sector size
                // of 2048. Also certain devices will have sector count == 0x00, check
                // for that also.
                //
                if (!(deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_MULTI_LUN_INITED)) {

                    if ((srb->Cdb[0] == 0x25) &&
                        ((deviceExtension->IdentifyData[srb->TargetId].GeneralConfiguration >> 8) & 0x1f) == 0x05) {

                        deviceExtension->DataBuffer -= byteCount;
                        if (deviceExtension->DataBuffer[0] == 0x00) {

                            *((ULONG *) &(deviceExtension->DataBuffer[0])) = 0xFFFFFF7F;

                        }

                        *((ULONG *) &(deviceExtension->DataBuffer[2])) = 0x00080000;
                        deviceExtension->DataBuffer += byteCount;
                    }
                }
            } else {

                //
                // Completion for IDE drives.
                //


                if (deviceExtension->BytesLeft) {

                    status = SRB_STATUS_DATA_OVERRUN;

                } else {

                    status = SRB_STATUS_SUCCESS;

                }

                goto CompleteRequest;

            }
        }

        return interruptCleared;

    } else if (interruptReason == 0x3) { // && !(statusByte & IDE_STATUS_DRQ)) {

        if (dmaInProgress) {

            deviceExtension->BytesLeft = 0;

            ASSERT (interruptReason == 3);

            //
            // bmStatus is initalized eariler.
            //
            if (!BMSTATUS_SUCCESS(bmStatus)) {

                if (bmStatus & BMSTATUS_ERROR_TRANSFER) {

                    status = SRB_STATUS_ERROR;
                }

                if (bmStatus & BMSTATUS_NOT_REACH_END_OF_TRANSFER) {

                    status = SRB_STATUS_DATA_OVERRUN;
                }

            } else {

                status = SRB_STATUS_SUCCESS;
            }

        } else {

            //
            // Command complete.
            //

            if (deviceExtension->BytesLeft) {

                status = SRB_STATUS_DATA_OVERRUN;

            } else {

                status = SRB_STATUS_SUCCESS;
            }
        }

        CompleteRequest:

        if (status == SRB_STATUS_ERROR) {

            DebugPrint ((1, 
                         "AtapiInterrupt: last command return status byte = 0x%x and error byte = 0x%x\n", 
                         statusByte, 
                         IdePortInPortByte(baseIoAddress1->Error)));

            if (deviceExtension->scsi2atapi) {

                RESTORE_ORIGINAL_CDB(deviceExtension, srb);

                deviceExtension->scsi2atapi = FALSE;

            }
            //
            // Map error to specific SRB status and handle request sense.
            //
            if ((srb->Function == SRB_FUNCTION_FLUSH) ||
                (srb->Function == SRB_FUNCTION_SHUTDOWN)) {

                //
                // return status success even if a flush fails
                //
                status = SRB_STATUS_SUCCESS;
            } else {

                //
                // log only the error that is caused by normal reuqest that
                // fails
                //
                if ((srb->Function != SRB_FUNCTION_ATA_PASS_THROUGH) &&
                    (srb->Function != SRB_FUNCTION_ATA_POWER_PASS_THROUGH) &&
                    (srb->Function != SRB_FUNCTION_ATA_PASS_THROUGH_EX)) {

                    status = MapError(deviceExtension,
                                      srb);
                }
            }


            deviceExtension->RDP = FALSE;

#if DBG
//#define ATAPI_RANDOM_RW_ERROR_FREQUENCY    50
    #if ATAPI_RANDOM_RW_ERROR_FREQUENCY

        } else if (status == SRB_STATUS_SUCCESS) {

            static ULONG _____RWCount = 0;

            if ((srb->Cdb[0] == SCSIOP_READ) || (srb->Cdb[0] == SCSIOP_WRITE)) {

                _____RWCount++;

//                if (baseIoAddress1 == (PATAPI_REGISTERS_1)0x170) {
                {

                    if ((_____RWCount % ATAPI_RANDOM_RW_ERROR_FREQUENCY) == 0) {

                        DebugPrint ((1, "ATAPI: Forcing R/W error\n"));

                        srb->SrbStatus = SRB_STATUS_ERROR;
                        srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
                        if (srb->SenseInfoBuffer) {

                            PSENSE_DATA  senseBuffer = (PSENSE_DATA)srb->SenseInfoBuffer;

                            senseBuffer->ErrorCode = 0x70;
                            senseBuffer->Valid     = 1;
                            senseBuffer->AdditionalSenseLength = 0xb;
                            senseBuffer->SenseKey =  SCSI_SENSE_HARDWARE_ERROR;
                            senseBuffer->AdditionalSenseCode = 0;
                            senseBuffer->AdditionalSenseCodeQualifier = 0;

                            srb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;
                        }
                        status = srb->SrbStatus;
                    }
                }
            }

    #endif // DBG
#endif // ATAPI_GENERATE_RANDOM_RW_ERROR

        } else {

            //
            // Wait for busy to drop.
            //

            for (i = 0; i < 60; i++) {

                if (fakeStatus) {

                    statusByte = IDE_STATUS_IDLE;
                } else {

                    GetStatus(baseIoAddress1,statusByte);
                }
                if (!(statusByte & IDE_STATUS_BUSY)) {
                    break;
                }
                KeStallExecutionProcessor(500);
            }

            if (i == 60) {

                //
                // reset the controller.
                //

                DebugPrint((0,
                            "AtapiInterrupt: Resetting due to BSY still up - %x. Base Io %x\n",
                            statusByte,
                            baseIoAddress1));

                if (deviceExtension->DriverMustPoll) {

                    //
                    // When we are polling, no dpc gets enqueued. 
                    // Try a quick reset...
                    //
                    //AtapiSyncResetController (HwDeviceExtension,srb->PathId);
                    status = SRB_STATUS_BUS_RESET;

                } else {

                    //
                    // Reset the controller in the completion DPC
                    //
                    IdePortNotification(IdeResetRequest,
                                        deviceExtension,
                                        NULL);

                    return interruptCleared;
                }

            }

            //
            // Check to see if DRQ is still up.
            //

            if (statusByte & IDE_STATUS_DRQ) {

                for (i = 0; i < 500; i++) {
                    GetStatus(baseIoAddress1,statusByte);
                    if (!(statusByte & IDE_STATUS_DRQ)) {
                        break;
                    }
                    KeStallExecutionProcessor(100);

                }

                if (i == 500) {

                    //
                    // reset the controller.
                    //
                    DebugPrint((0,
                                "AtapiInterrupt: Resetting due to DRQ still up - %x\n",
                                statusByte));

                    if (deviceExtension->DriverMustPoll) {

                        //
                        // When we are polling, no dpc gets enqueued. 
                        // Try a quick reset...
                        //
                        //AtapiSyncResetController (HwDeviceExtension,srb->PathId);
                        status = SRB_STATUS_BUS_RESET;

                    } else {

                        //
                        // Reset the controller in the completion DPC
                        //
                        IdePortNotification(IdeResetRequest,
                                            deviceExtension,
                                            NULL);
                        return interruptCleared;
                    }

                }

            }
        }


        //
        // Clear interrupt expecting and dmaInProgress flag.
        //

        deviceExtension->ExpectingInterrupt = FALSE;

        //
        // Sanity check that there is a current request.
        //

        if (srb != NULL) {

            //
            // Set status in SRB.
            //

            srb->SrbStatus = (UCHAR)status;

            //
            // Check for underflow.
            //

            if (deviceExtension->BytesLeft) {

                //
                // Subtract out residual words and update if filemark hit,
                // setmark hit , end of data, end of media...
                //

                if (!(deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_TAPE_DEVICE)) {

                    if (status == SRB_STATUS_DATA_OVERRUN) {
                        srb->DataTransferLength -= deviceExtension->BytesLeft;
                    } else {
                        srb->DataTransferLength = 0;
                    }
                } else {
                    srb->DataTransferLength -= deviceExtension->BytesLeft;
                }
            }

            if ((srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH) ||
                (srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH)) {

                PATA_PASS_THROUGH ataPassThroughData = srb->DataBuffer;

                AtapiTaskRegisterSnapshot ((PIDE_REGISTERS_1)baseIoAddress1, &ataPassThroughData->IdeReg);

            } else if (deviceExtension->CurrentSrb->Function == SRB_FUNCTION_ATA_PASS_THROUGH_EX) {

                PIDEREGS pIdeReg = (PIDEREGS) srb->Cdb;

                AtapiTaskRegisterSnapshot((PIDE_REGISTERS_1)baseIoAddress1, pIdeReg);
            }

            if (srb->Function != SRB_FUNCTION_IO_CONTROL) {

                //
                // Indicate command complete.
                //

                if (!(deviceExtension->RDP) &&
                    !(deviceExtension->DriverMustPoll)) {
                    IdePortNotification(IdeRequestComplete,
                                        deviceExtension,
                                        srb);

                }
            } else {

                PSENDCMDOUTPARAMS cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                UCHAR             error = 0;

                if (status != SRB_STATUS_SUCCESS) {
                    error = IdePortInPortByte(baseIoAddress1->Error);
                }

                //
                // Build the SMART status block depending upon the completion status.
                //

                cmdOutParameters->cBufferSize = byteCount;
                cmdOutParameters->DriverStatus.bDriverError = (error) ? SMART_IDE_ERROR : 0;
                cmdOutParameters->DriverStatus.bIDEError = error;

                //
                // If the sub-command is return smart status, jam the value from cylinder low and high, into the
                // data buffer.
                //

                if (deviceExtension->SmartCommand == RETURN_SMART_STATUS) {
                    cmdOutParameters->bBuffer[0] = RETURN_SMART_STATUS;
                    cmdOutParameters->bBuffer[1] = IdePortInPortByte(baseIoAddress1->InterruptReason);
                    cmdOutParameters->bBuffer[2] = IdePortInPortByte(baseIoAddress1->Unused1);
                    cmdOutParameters->bBuffer[3] = IdePortInPortByte(baseIoAddress1->ByteCountLow);
                    cmdOutParameters->bBuffer[4] = IdePortInPortByte(baseIoAddress1->ByteCountHigh);
                    cmdOutParameters->bBuffer[5] = IdePortInPortByte(baseIoAddress1->DriveSelect);
                    cmdOutParameters->bBuffer[6] = SMART_CMD;
                    cmdOutParameters->cBufferSize = 8;
                }

                //
                // Indicate command complete.
                //

                IdePortNotification(IdeRequestComplete,
                                    deviceExtension,
                                    srb);

            }

        } else {

            DebugPrint((1,
                        "AtapiInterrupt: No SRB!\n"));
        }

        //
        // Indicate ready for next request.
        //

        if (!(deviceExtension->RDP)) {

            //
            // Clear current SRB.
            //

            deviceExtension->CurrentSrb = NULL;

            if (!deviceExtension->DriverMustPoll) {
                IdePortNotification(IdeNextRequest,
                                    deviceExtension,
                                    NULL);
            }
        } else {

            ASSERT(!deviceExtension->DriverMustPoll);
            IdePortNotification(IdeRequestTimerCall,
                                HwDeviceExtension,
                                AtapiCallBack,
                                2000);
        }

        return interruptCleared;

    } else {

        //
        // Unexpected int.
        //

        DebugPrint((0,
                    "AtapiInterrupt: Unexpected interrupt. InterruptReason %x. Status %x.\n",
                    interruptReason,
                    statusByte));

        ASSERT(interruptCleared == FALSE);
        return interruptCleared;
    }

    return interruptCleared;

} // end AtapiInterrupt()


ULONG
IdeSendSmartCommand(
                   IN PVOID HwDeviceExtension,
                   IN PSCSI_REQUEST_BLOCK Srb
                   )

/*++

Routine Description:

    This routine handles SMART enable, disable, read attributes and threshold commands.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    PIDE_REGISTERS_2     baseIoAddress2  = &deviceExtension->BaseIoAddress2;
    PSENDCMDOUTPARAMS    cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
    PSENDCMDINPARAMS      pCmdInParameters = (PSENDCMDINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
    SENDCMDINPARAMS      cmdInParameters = *(PSENDCMDINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
    PIDEREGS             regs = &cmdInParameters.irDriveRegs;
    ULONG                i;
    UCHAR                statusByte,targetId;
    ULONG                byteCount;


    if (cmdInParameters.irDriveRegs.bCommandReg == SMART_CMD) {

        targetId = cmdInParameters.bDriveNumber;

        //TODO optimize this check

        if ((!(deviceExtension->DeviceFlags[targetId] & DFLAGS_DEVICE_PRESENT)) ||
            (deviceExtension->DeviceFlags[targetId] & DFLAGS_ATAPI_DEVICE)) {

            return SRB_STATUS_SELECTION_TIMEOUT;
        }

        deviceExtension->SmartCommand = cmdInParameters.irDriveRegs.bFeaturesReg;

        //
        // fudge the target Id field in the srb
        // atapi interrupt will use this field.
        //
        Srb->TargetId = targetId;

        //
        // Determine which of the commands to carry out.
        //

#ifdef ENABLE_SMARTLOG_SUPPORT
        if ((cmdInParameters.irDriveRegs.bFeaturesReg == READ_ATTRIBUTES) ||
            (cmdInParameters.irDriveRegs.bFeaturesReg == READ_THRESHOLDS) ||
            (cmdInParameters.irDriveRegs.bFeaturesReg == SMART_READ_LOG)) {
#else
        if ((cmdInParameters.irDriveRegs.bFeaturesReg == READ_ATTRIBUTES) ||
            (cmdInParameters.irDriveRegs.bFeaturesReg == READ_THRESHOLDS)) {
#endif

            ULONG dataLength = 0;

            SelectIdeLine(baseIoAddress1, targetId >> 1);

            WaitOnBusy(baseIoAddress1,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {
                DebugPrint((1,
                            "IdeSendSmartCommand: Returning BUSY status\n"));
                return SRB_STATUS_BUSY;
            }

#ifdef ENABLE_SMARTLOG_SUPPORT
            if (cmdInParameters.irDriveRegs.bFeaturesReg == SMART_READ_LOG) {

                dataLength = cmdInParameters.irDriveRegs.bSectorCountReg* SMART_LOG_SECTOR_SIZE;

            } else {

                dataLength = READ_ATTRIBUTE_BUFFER_SIZE;

            }
#else
            dataLength = READ_ATTRIBUTE_BUFFER_SIZE;
#endif

            //
            // Zero the ouput buffer as the input buffer info. has been saved off locally (the buffers are the same).
            //
            for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) + dataLength - 1); i++) {
                ((PUCHAR)cmdOutParameters)[i] = 0;
            }

            //
            // Set data buffer pointer and words left.
            //
            deviceExtension->DataBuffer = (PUCHAR)cmdOutParameters->bBuffer;
            deviceExtension->BytesLeft = dataLength;

            //
            // Indicate expecting an interrupt.
            //
            deviceExtension->ExpectingInterrupt = TRUE;

            SelectIdeDevice(baseIoAddress1, targetId, 0);
            IdePortOutPortByte(baseIoAddress1->Error,regs->bFeaturesReg);
            IdePortOutPortByte(baseIoAddress1->BlockCount,regs->bSectorCountReg);
            IdePortOutPortByte(baseIoAddress1->BlockNumber,regs->bSectorNumberReg);
            IdePortOutPortByte(baseIoAddress1->CylinderLow,regs->bCylLowReg);
            IdePortOutPortByte(baseIoAddress1->CylinderHigh,regs->bCylHighReg);
            IdePortOutPortByte(baseIoAddress1->Command,regs->bCommandReg);

            //
            // Wait for interrupt.
            //
            return SRB_STATUS_PENDING;

        } else if ((cmdInParameters.irDriveRegs.bFeaturesReg == ENABLE_SMART) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == DISABLE_SMART) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == RETURN_SMART_STATUS) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == ENABLE_DISABLE_AUTOSAVE) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == EXECUTE_OFFLINE_DIAGS) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == SAVE_ATTRIBUTE_VALUES) ||
                   (cmdInParameters.irDriveRegs.bFeaturesReg == ENABLE_DISABLE_AUTO_OFFLINE)) {
#ifdef ENABLE_SMARTLOG_SUPPORT
            //
            // Allow only the non-captive tests, for now.
            //
            if (cmdInParameters.irDriveRegs.bFeaturesReg == EXECUTE_OFFLINE_DIAGS) {

                UCHAR sectorNumber = regs->bSectorNumberReg;

                if ((sectorNumber == SMART_OFFLINE_ROUTINE_OFFLINE) ||
                    (sectorNumber == SMART_SHORT_SELFTEST_OFFLINE) ||
                    (sectorNumber == SMART_EXTENDED_SELFTEST_OFFLINE) ||
                    (sectorNumber == SMART_ABORT_OFFLINE_SELFTEST)) {

                    DebugPrint((1, 
                                "The SMART offline command %x is allowed\n",
                                sectorNumber));

                } else if ((sectorNumber == SMART_SHORT_SELFTEST_CAPTIVE) ||
                           (sectorNumber == SMART_EXTENDED_SELFTEST_CAPTIVE)) {

                    //
                    // Don't allow captive mode requests, if you have a slave(another)
                    // device
                    //
                    if (HasSlaveDevice(deviceExtension, targetId)) {
                        return SRB_STATUS_INVALID_REQUEST;
                    }

                }
            }
#endif

            SelectIdeLine(baseIoAddress1, targetId >> 1);

            WaitOnBusy(baseIoAddress1,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {
                DebugPrint((1,
                            "IdeSendSmartCommand: Returning BUSY status\n"));
                return SRB_STATUS_BUSY;
            }

            //
            // Zero the ouput buffer as the input buffer info. has been saved off locally (the buffers are the same).
            //
            for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) - 1); i++) {
                ((PUCHAR)cmdOutParameters)[i] = 0;
            }

            //
            // Set data buffer pointer and indicate no data transfer.
            //
            deviceExtension->DataBuffer = (PUCHAR)cmdOutParameters->bBuffer;
            deviceExtension->BytesLeft = 0;

            //
            // Indicate expecting an interrupt.
            //
            deviceExtension->ExpectingInterrupt = TRUE;

            SelectIdeDevice(baseIoAddress1, targetId, 0);
            IdePortOutPortByte(baseIoAddress1->Error,regs->bFeaturesReg);
            IdePortOutPortByte(baseIoAddress1->BlockCount,regs->bSectorCountReg);
            IdePortOutPortByte(baseIoAddress1->BlockNumber,regs->bSectorNumberReg);
            IdePortOutPortByte(baseIoAddress1->CylinderLow,regs->bCylLowReg);
            IdePortOutPortByte(baseIoAddress1->CylinderHigh,regs->bCylHighReg);
            IdePortOutPortByte(baseIoAddress1->Command,regs->bCommandReg);

            //
            // Wait for interrupt.
            //
            return SRB_STATUS_PENDING;

        }
#ifdef ENABLE_SMARTLOG_SUPPORT
        else if (cmdInParameters.irDriveRegs.bFeaturesReg == SMART_WRITE_LOG) {

            SelectIdeLine(baseIoAddress1, targetId >> 1);

            WaitOnBusy(baseIoAddress1,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {
                DebugPrint((1,
                            "IdeSendSmartCommand: Returning BUSY status\n"));
                return SRB_STATUS_BUSY;
            }

            //
            // we are assuming that the drive will return an error if we try to
            // write multiple sectors when it is not supported.
            //

            //
            // set the input buffer and the datalength fields.
            //
            deviceExtension->DataBuffer = (PUCHAR)pCmdInParameters->bBuffer;
            deviceExtension->BytesLeft = cmdInParameters.irDriveRegs.bSectorCountReg* SMART_LOG_SECTOR_SIZE;

            //
            // Indicate expecting an interrupt.
            //
            deviceExtension->ExpectingInterrupt = TRUE;

            SelectIdeDevice(baseIoAddress1, targetId, 0);
            IdePortOutPortByte(baseIoAddress1->Error,regs->bFeaturesReg);
            IdePortOutPortByte(baseIoAddress1->BlockCount,regs->bSectorCountReg);
            IdePortOutPortByte(baseIoAddress1->BlockNumber,regs->bSectorNumberReg);
            IdePortOutPortByte(baseIoAddress1->CylinderLow,regs->bCylLowReg);
            IdePortOutPortByte(baseIoAddress1->CylinderHigh,regs->bCylHighReg);
            IdePortOutPortByte(baseIoAddress1->Command,regs->bCommandReg);

            ASSERT(!SRB_USES_DMA(Srb));

            if (!SRB_USES_DMA(Srb)) {

                if (deviceExtension->BytesLeft < 
                    deviceExtension->DeviceParameters[Srb->TargetId].MaxBytePerPioInterrupt) {
                    byteCount = deviceExtension->BytesLeft;
                } else {
                    byteCount = deviceExtension->DeviceParameters[Srb->TargetId].MaxBytePerPioInterrupt;
                }
                //
                // Wait for BSY and DRQ.
                //

                WaitOnBaseBusy(baseIoAddress1,statusByte);

                if (statusByte & IDE_STATUS_BUSY) {

                    DebugPrint((1,
                                "IdeSendSmartCommand: Returning BUSY status %x\n",
                                statusByte));
                    return SRB_STATUS_BUSY;

                }

                if (statusByte & IDE_STATUS_ERROR) {

                    DebugPrint((1,
                                "IdeSendSmartCommand: Returning ERROR status %x\n",
                                statusByte));

                    deviceExtension->BytesLeft = 0;

                    //
                    // Clear interrupt expecting flag.
                    //
                    deviceExtension->ExpectingInterrupt = FALSE;
                    return MapError(deviceExtension, Srb);
                }

                for (i = 0; i < 1000; i++) {
                    GetBaseStatus(baseIoAddress1, statusByte);
                    if (statusByte & IDE_STATUS_DRQ) {
                        break;
                    }
                    KeStallExecutionProcessor(200);

                }

                if (!(statusByte & IDE_STATUS_DRQ)) {

                    DebugPrint((1,
                                "IdeSmartCommand: DRQ never asserted (%x)\n", 
                                statusByte));

                    deviceExtension->BytesLeft = 0;

                    //
                    // Clear interrupt expecting flag.
                    //

                    deviceExtension->ExpectingInterrupt = FALSE;

                    //
                    // Clear current SRB.
                    //

                    deviceExtension->CurrentSrb = NULL;

                    return SRB_STATUS_SELECTION_TIMEOUT;
                }

                //
                // Write next 256 words.
                //

                WriteBuffer(baseIoAddress1,
                            (PUSHORT)deviceExtension->DataBuffer,
                            byteCount / sizeof(USHORT));

                //
                // Adjust buffer address and words left count.
                //

                deviceExtension->BytesLeft -= byteCount;
                deviceExtension->DataBuffer += byteCount;

            }
            //
            // Wait for interrupt.
            //
            return SRB_STATUS_PENDING;

        }
#endif
    }

    return SRB_STATUS_INVALID_REQUEST;

} // end IdeSendSmartCommand()

#ifdef ENABLE_48BIT_LBA

ULONG
IdeReadWriteExt(
               IN PVOID HwDeviceExtension,
               IN PSCSI_REQUEST_BLOCK Srb
               )

/*++

Routine Description:

    This routine handles IDE read and writes.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    PIDE_REGISTERS_2     baseIoAddress2  = &deviceExtension->BaseIoAddress2;
    ULONG                i;
    ULONG                byteCount;
    UCHAR                statusByte,statusByte2;
    UCHAR                cylinderHigh,cylinderLow,drvSelect;
    ULONG                sectorCount;
    LARGE_INTEGER        startingSector;

    //
    // the device should support 48 bit LBA
    //
    ASSERT(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_48BIT_LBA);
    ASSERT(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_LBA);

    //
    // Select device 0 or 1.
    //
    SelectIdeDevice(baseIoAddress1, Srb->TargetId, 0);

    GetStatus(baseIoAddress1, statusByte2);

    if (statusByte2 & IDE_STATUS_BUSY) {
        DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                    "IdeReadWrite: Returning BUSY status\n"));
        return SRB_STATUS_BUSY;
    }

    if (!(statusByte2 & IDE_STATUS_DRDY)) {

        DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                    "IdeReadWrite: IDE_STATUS_DRDY not set\n"));
        return SRB_STATUS_BUSY;
    }

    //
    // Set data buffer pointer and words left.
    // BytesLeft should be 64-bit.
    //
    deviceExtension->DataBuffer = (PUCHAR)Srb->DataBuffer;
    deviceExtension->BytesLeft = Srb->DataTransferLength;

    //
    // Indicate expecting an interrupt.
    //
    deviceExtension->ExpectingInterrupt = TRUE;

    //                                                         
    // Set up sector count register. Round up to next block.
    //
    sectorCount = (Srb->DataTransferLength + 0x1FF) / 0x200;

    ASSERT(sectorCount != 0);


    //
    // Get starting sector number from CDB.
    //
    startingSector.QuadPart = 0;
    startingSector.LowPart = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
                              ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
                              ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
                              ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;

    DebugPrint((1,
                "startingSector = 0x%x, length = 0x%x\n",
                startingSector.LowPart,
                sectorCount
                ));


    //
    // the device shall support LBA. We will not use CHS
    //
    SelectIdeDevice(baseIoAddress1,
                    Srb->TargetId,
                    IDE_LBA_MODE);

    //
    // load the higher order bytes
    //
    IdePortOutPortByte (
                       baseIoAddress1->BlockCount,
                       (UCHAR)((sectorCount & 0x0000ff00) >> 8));

    IdePortOutPortByte (
                       baseIoAddress1->BlockNumber,
                       (UCHAR) (((startingSector.LowPart) & 0xff000000) >> 24));

    IdePortOutPortByte (
                       baseIoAddress1->CylinderLow,
                       (UCHAR) (((startingSector.HighPart) & 0x000000ff) >> 0));

    IdePortOutPortByte (
                       baseIoAddress1->CylinderHigh,
                       (UCHAR) (((startingSector.HighPart) & 0x0000ff00) >> 8));

    //
    // load the lower order bytes
    //
    IdePortOutPortByte (
                       baseIoAddress1->BlockCount,
                       (UCHAR)((sectorCount & 0x000000ff) >> 0));

    IdePortOutPortByte (
                       baseIoAddress1->BlockNumber,
                       (UCHAR) (((startingSector.LowPart) & 0x000000ff) >> 0));

    IdePortOutPortByte (
                       baseIoAddress1->CylinderLow,
                       (UCHAR) (((startingSector.LowPart) & 0x0000ff00) >> 8));

    IdePortOutPortByte (
                       baseIoAddress1->CylinderHigh,
                       (UCHAR) (((startingSector.LowPart) & 0x00ff0000) >> 16));

    //
    // Check if write request.
    //
    if (Srb->SrbFlags & SRB_FLAGS_DATA_IN) {

        //
        // Send read command.
        //
        if (SRB_USES_DMA(Srb)) {

            IdePortOutPortByte (
                               baseIoAddress1->Command, 
                               IDE_COMMAND_READ_DMA_EXT);

        } else {

            ASSERT (deviceExtension->DeviceParameters[Srb->TargetId].IdePioReadCommandExt);

            IdePortOutPortByte (
                               baseIoAddress1->Command,
                               deviceExtension->DeviceParameters[Srb->TargetId].IdePioReadCommandExt);
        }

    } else {


        //
        // Send write command.
        //
        if (SRB_USES_DMA(Srb)) {

            IdePortOutPortByte (
                               baseIoAddress1->Command, 
                               IDE_COMMAND_WRITE_DMA_EXT);

        } else {

            ASSERT(deviceExtension->DeviceParameters[Srb->TargetId].IdePioWriteCommandExt);

            IdePortOutPortByte (
                               baseIoAddress1->Command,
                               deviceExtension->DeviceParameters[Srb->TargetId].IdePioWriteCommandExt);
        }

        if (!SRB_USES_DMA(Srb)) {

            if (deviceExtension->BytesLeft < 
                deviceExtension->DeviceParameters[Srb->TargetId].MaxBytePerPioInterrupt) {
                byteCount = deviceExtension->BytesLeft;
            } else {
                byteCount = deviceExtension->DeviceParameters[Srb->TargetId].MaxBytePerPioInterrupt;
            }
            //
            // Wait for BSY and DRQ.
            //

            WaitOnBaseBusy(baseIoAddress1,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {

                DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                            "IdeReadWrite 2: Returning BUSY status %x\n",
                            statusByte));
                return SRB_STATUS_BUSY;
            }

            for (i = 0; i < 1000; i++) {
                GetBaseStatus(baseIoAddress1, statusByte);
                if (statusByte & IDE_STATUS_DRQ) {
                    break;
                }
                KeStallExecutionProcessor(200);

            }

            if (!(statusByte & IDE_STATUS_DRQ)) {

                DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                            "IdeReadWrite: DRQ never asserted (%x) original status (%x)\n",
                            statusByte,
                            statusByte2));

                deviceExtension->BytesLeft = 0;

                //
                // Clear interrupt expecting flag.
                //

                deviceExtension->ExpectingInterrupt = FALSE;

                //
                // Clear current SRB.
                //

                deviceExtension->CurrentSrb = NULL;

                return SRB_STATUS_TIMEOUT;
            }

            //
            // Write next 256 words.
            //

            WriteBuffer(baseIoAddress1,
                        (PUSHORT)deviceExtension->DataBuffer,
                        byteCount / sizeof(USHORT));

            //
            // Adjust buffer address and words left count.
            //

            deviceExtension->BytesLeft -= byteCount;
            deviceExtension->DataBuffer += byteCount;

        }
    }

    if (SRB_USES_DMA(Srb)) {
        deviceExtension->DMAInProgress = TRUE;
        deviceExtension->BusMasterInterface.BmArm (deviceExtension->BusMasterInterface.Context);
    }

    //
    // Wait for interrupt.
    //

    return SRB_STATUS_PENDING;

} // end IdeReadWriteExt()
#endif


ULONG
IdeReadWrite(
            IN PVOID HwDeviceExtension,
            IN PSCSI_REQUEST_BLOCK Srb
            )

/*++

Routine Description:

    This routine handles IDE read and writes.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    PIDE_REGISTERS_2     baseIoAddress2  = &deviceExtension->BaseIoAddress2;
    ULONG                startingSector,i;
    ULONG                byteCount;
    UCHAR                statusByte,statusByte2;
    UCHAR                cylinderHigh,cylinderLow,drvSelect,sectorNumber;


    //
    // Select device 0 or 1.
    //
    SelectIdeDevice(baseIoAddress1, Srb->TargetId, 0);

    GetStatus(baseIoAddress1, statusByte2);

    if (statusByte2 & IDE_STATUS_BUSY) {
        DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                    "IdeReadWrite: Returning BUSY status\n"));
        return SRB_STATUS_BUSY;
    }

    if (!(statusByte2 & IDE_STATUS_DRDY)) {

        if ((statusByte2 == 0) && 
            (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_SONY_MEMORYSTICK)) {
            statusByte2=IDE_STATUS_DRDY;
        } else {
            DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                        "IdeReadWrite: IDE_STATUS_DRDY not set\n"));
            return SRB_STATUS_BUSY;
        }
    }


    //
    // returns status busy when atapi verifier is enabled
    //
    //ViIdeFakeHungController(HwDeviceExtension);

    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = (PUCHAR)Srb->DataBuffer;
    deviceExtension->BytesLeft = Srb->DataTransferLength;

    //
    // Indicate expecting an interrupt.
    //

    deviceExtension->ExpectingInterrupt = TRUE;

    //                                                         
    // Set up sector count register. Round up to next block.
    //
    IdePortOutPortByte (
                       baseIoAddress1->BlockCount,
                       (UCHAR)((Srb->DataTransferLength + 0x1FF) / 0x200));

    //
    // Get starting sector number from CDB.
    //

    startingSector = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;

    DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                "IdeReadWrite: Starting sector is %x, Number of bytes %x\n",
                startingSector,
                Srb->DataTransferLength));

    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_LBA) {

        SelectIdeDevice(baseIoAddress1,
                        Srb->TargetId,
                        (IDE_LBA_MODE | ((startingSector & 0x0f000000) >> 24)));

        IdePortOutPortByte (
                           baseIoAddress1->BlockNumber,
                           (UCHAR) ((startingSector & 0x000000ff) >> 0));
        IdePortOutPortByte (
                           baseIoAddress1->CylinderLow,
                           (UCHAR) ((startingSector & 0x0000ff00) >> 8));

        IdePortOutPortByte (
                           baseIoAddress1->CylinderHigh,
                           (UCHAR) ((startingSector & 0x00ff0000) >> 16));


    } else {  //CHS

        //
        // Set up sector number register.
        //

        sectorNumber =  (UCHAR)((startingSector % deviceExtension->SectorsPerTrack[Srb->TargetId]) + 1);
        IdePortOutPortByte (
                           baseIoAddress1->BlockNumber,
                           sectorNumber);

        //
        // Set up cylinder low register.
        //

        cylinderLow =  (UCHAR)(startingSector / (deviceExtension->SectorsPerTrack[Srb->TargetId] *
                                                 deviceExtension->NumberOfHeads[Srb->TargetId]));
        IdePortOutPortByte (
                           baseIoAddress1->CylinderLow,
                           cylinderLow);

        //
        // Set up cylinder high register.
        //

        cylinderHigh = (UCHAR)((startingSector / (deviceExtension->SectorsPerTrack[Srb->TargetId] *
                                                  deviceExtension->NumberOfHeads[Srb->TargetId])) >> 8);
        IdePortOutPortByte (
                           baseIoAddress1->CylinderHigh,
                           cylinderHigh);

        //
        // Set up head and drive select register.
        //

        drvSelect = (UCHAR)(((startingSector / deviceExtension->SectorsPerTrack[Srb->TargetId]) %
                             deviceExtension->NumberOfHeads[Srb->TargetId]));
        SelectIdeDevice(baseIoAddress1, Srb->TargetId, drvSelect);

        DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                    "IdeReadWrite: Cylinder %x Head %x Sector %x\n",
                    startingSector /
                    (deviceExtension->SectorsPerTrack[Srb->TargetId] *
                     deviceExtension->NumberOfHeads[Srb->TargetId]),
                    (startingSector /
                     deviceExtension->SectorsPerTrack[Srb->TargetId]) %
                    deviceExtension->NumberOfHeads[Srb->TargetId],
                    startingSector %
                    deviceExtension->SectorsPerTrack[Srb->TargetId] + 1));
    }

    //
    // Check if write request.
    //

    if (Srb->SrbFlags & SRB_FLAGS_DATA_IN) {

        //
        // Send read command.
        //
        if (SRB_USES_DMA(Srb)) {

            IdePortOutPortByte (
                               baseIoAddress1->Command, 
                               IDE_COMMAND_READ_DMA);

        } else {

            IdePortOutPortByte (
                               baseIoAddress1->Command,
                               deviceExtension->DeviceParameters[Srb->TargetId].IdePioReadCommand);
        }

    } else {


        //
        // Send write command.
        //
        if (SRB_USES_DMA(Srb)) {

            IdePortOutPortByte (
                               baseIoAddress1->Command, 
                               IDE_COMMAND_WRITE_DMA);

        } else {

            IdePortOutPortByte (
                               baseIoAddress1->Command,
                               deviceExtension->DeviceParameters[Srb->TargetId].IdePioWriteCommand);
        }

        if (!SRB_USES_DMA(Srb)) {

            if (deviceExtension->BytesLeft < 
                deviceExtension->DeviceParameters[Srb->TargetId].MaxBytePerPioInterrupt) {
                byteCount = deviceExtension->BytesLeft;
            } else {
                byteCount = deviceExtension->DeviceParameters[Srb->TargetId].MaxBytePerPioInterrupt;
            }
            //
            // Wait for BSY and DRQ.
            //

            WaitOnBaseBusy(baseIoAddress1,statusByte);

            if (statusByte & IDE_STATUS_BUSY) {

                DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                            "IdeReadWrite 2: Returning BUSY status %x\n",
                            statusByte));
                return SRB_STATUS_BUSY;
            }

            for (i = 0; i < 1000; i++) {
                GetBaseStatus(baseIoAddress1, statusByte);
                if (statusByte & IDE_STATUS_DRQ) {
                    break;
                }
                KeStallExecutionProcessor(200);

            }

            if (!(statusByte & IDE_STATUS_DRQ)) {

                DebugPrint((DBG_CRASHDUMP | DBG_READ_WRITE,
                            "IdeReadWrite: DRQ never asserted (%x) original status (%x)\n",
                            statusByte,
                            statusByte2));

                deviceExtension->BytesLeft = 0;

                //
                // Clear interrupt expecting flag.
                //

                deviceExtension->ExpectingInterrupt = FALSE;

                //
                // Clear current SRB.
                //

                deviceExtension->CurrentSrb = NULL;

                return SRB_STATUS_TIMEOUT;
            }

            //
            // Write next 256 words.
            //

            WriteBuffer(baseIoAddress1,
                        (PUSHORT)deviceExtension->DataBuffer,
                        byteCount / sizeof(USHORT));

            //
            // Adjust buffer address and words left count.
            //

            deviceExtension->BytesLeft -= byteCount;
            deviceExtension->DataBuffer += byteCount;

        }
    }

    if (SRB_USES_DMA(Srb)) {
        deviceExtension->DMAInProgress = TRUE;
        deviceExtension->BusMasterInterface.BmArm (deviceExtension->BusMasterInterface.Context);
    }

    //
    // Wait for interrupt.
    //

    return SRB_STATUS_PENDING;

} // end IdeReadWrite()

#ifdef ENABLE_48BIT_LBA
ULONG
IdeVerifyExt(
            IN PVOID HwDeviceExtension,
            IN PSCSI_REQUEST_BLOCK Srb
            )

/*++

Routine Description:

    This routine handles IDE Verify.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    PIDE_REGISTERS_2     baseIoAddress2  = &deviceExtension->BaseIoAddress2;
    LARGE_INTEGER        startingSector;
    ULONG                sectors;
    ULONG                endSector;
    ULONG                sectorCount;

    //
    // the device should support 48 bit LBA
    //
    ASSERT(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_48BIT_LBA);
    ASSERT(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_LBA);

    //
    // Get starting sector number from CDB.
    //
    startingSector.QuadPart = 0;
    startingSector.QuadPart = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
                              ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
                              ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
                              ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;

    DebugPrint((3,
                "IdeVerify: Starting sector %x. Number of blocks %x\n",
                startingSector,
                ((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb));

    sectorCount = (USHORT)(((PCDB)Srb->Cdb)->CDB10.TransferBlocksMsb << 8 |
                           ((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb );

    if (sectorCount > 0x10000) {

        DebugPrint((DBG_ALWAYS,
                    "IdeVerify: verify too many sectors 0x%x\n",
                    sectorCount));

        return SRB_STATUS_INVALID_REQUEST;
    }


    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = Srb->DataBuffer;
    deviceExtension->BytesLeft = Srb->DataTransferLength;

    //
    // Indicate expecting an interrupt.
    //

    deviceExtension->ExpectingInterrupt = TRUE;


    SelectIdeDevice(baseIoAddress1,
                    Srb->TargetId,
                    IDE_LBA_MODE);

    //
    // Load the higer order bytes
    //
    IdePortOutPortByte(baseIoAddress1->BlockNumber,
                       (UCHAR) (((startingSector.LowPart) & 0xff000000) >> 24));

    IdePortOutPortByte(baseIoAddress1->CylinderLow,
                       (UCHAR) (((startingSector.HighPart) & 0x000000ff) >> 0));

    IdePortOutPortByte(baseIoAddress1->CylinderHigh,
                       (UCHAR) (((startingSector.HighPart) & 0x0000ff00) >> 8));

    IdePortOutPortByte(baseIoAddress1->BlockCount,
                       (UCHAR)((sectorCount & 0x0000ff00) >> 8));

    //
    // Load the lower order bytes
    //
    IdePortOutPortByte(baseIoAddress1->BlockNumber,
                       (UCHAR) (((startingSector.LowPart) & 0x000000ff) >> 0));

    IdePortOutPortByte(baseIoAddress1->CylinderLow,
                       (UCHAR) (((startingSector.LowPart) & 0x0000ff00) >> 8));

    IdePortOutPortByte(baseIoAddress1->CylinderHigh,
                       (UCHAR) (((startingSector.LowPart) & 0x00ff0000) >> 16));

    IdePortOutPortByte(baseIoAddress1->BlockCount,
                       (UCHAR)((sectorCount & 0x000000ff) >> 0));

    //
    // Send verify command.
    //

    IdePortOutPortByte(baseIoAddress1->Command,
                       IDE_COMMAND_VERIFY_EXT);

    //
    // Wait for interrupt.
    //

    return SRB_STATUS_PENDING;

} // end IdeVerifyExt()
#endif


ULONG
IdeVerify(
         IN PVOID HwDeviceExtension,
         IN PSCSI_REQUEST_BLOCK Srb
         )

/*++

Routine Description:

    This routine handles IDE Verify.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    SRB status

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    PIDE_REGISTERS_2     baseIoAddress2  = &deviceExtension->BaseIoAddress2;
    ULONG                startingSector;
    ULONG                sectors;
    ULONG                endSector;
    USHORT               sectorCount;

    //
    // Drive has these number sectors.
    //

#if DBG
    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_LBA) { // LBA
        sectors = deviceExtension->IdentifyData[Srb->TargetId].UserAddressableSectors;
    } else {
        sectors = deviceExtension->SectorsPerTrack[Srb->TargetId] *
                  deviceExtension->NumberOfHeads[Srb->TargetId] *
                  deviceExtension->NumberOfCylinders[Srb->TargetId];
    }
#endif

    DebugPrint((3,
                "IdeVerify: Total sectors %x\n",
                sectors));

    //
    // Get starting sector number from CDB.
    //

    startingSector = ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 8 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 16 |
                     ((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 << 24;

    DebugPrint((3,
                "IdeVerify: Starting sector %x. Number of blocks %x\n",
                startingSector,
                ((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb));

    sectorCount = (USHORT)(((PCDB)Srb->Cdb)->CDB10.TransferBlocksMsb << 8 |
                           ((PCDB)Srb->Cdb)->CDB10.TransferBlocksLsb );
    endSector = startingSector + sectorCount;

    DebugPrint((3,
                "IdeVerify: Ending sector %x\n",
                endSector));

    if (sectorCount > 0x100) {

        DebugPrint((DBG_ALWAYS,
                    "IdeVerify: verify too many sectors 0x%x\n",
                    sectorCount));

        return SRB_STATUS_INVALID_REQUEST;
    }


    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = Srb->DataBuffer;
    deviceExtension->BytesLeft = Srb->DataTransferLength;

    //
    // Indicate expecting an interrupt.
    //

    deviceExtension->ExpectingInterrupt = TRUE;


    if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_LBA) { // LBA

        SelectIdeDevice(baseIoAddress1,
                        Srb->TargetId,
                        (IDE_LBA_MODE |((startingSector & 0x0f000000) >> 24)));

        IdePortOutPortByte(baseIoAddress1->BlockNumber,
                           (UCHAR) ((startingSector & 0x000000ff) >> 0));

        IdePortOutPortByte(baseIoAddress1->CylinderLow,
                           (UCHAR) ((startingSector & 0x0000ff00) >> 8));

        IdePortOutPortByte(baseIoAddress1->CylinderHigh,
                           (UCHAR) ((startingSector & 0x00ff0000) >> 16));

        DebugPrint((2,
                    "IdeVerify: LBA: startingSector %x\n",
                    startingSector));

    } else {  //CHS

        //
        // Set up head and drive select register.
        //

        SelectIdeDevice(baseIoAddress1,
                        Srb->TargetId,
                        (UCHAR)((startingSector /
                                 deviceExtension->SectorsPerTrack[Srb->TargetId]) %
                                deviceExtension->NumberOfHeads[Srb->TargetId]));

        //
        // Set up sector number register.
        //

        IdePortOutPortByte(baseIoAddress1->BlockNumber,
                           (UCHAR)((startingSector %
                                    deviceExtension->SectorsPerTrack[Srb->TargetId]) + 1));

        //
        // Set up cylinder low register.
        //

        IdePortOutPortByte(baseIoAddress1->CylinderLow,
                           (UCHAR)(startingSector /
                                   (deviceExtension->SectorsPerTrack[Srb->TargetId] *
                                    deviceExtension->NumberOfHeads[Srb->TargetId])));

        //
        // Set up cylinder high register.
        //

        IdePortOutPortByte(baseIoAddress1->CylinderHigh,
                           (UCHAR)((startingSector /
                                    (deviceExtension->SectorsPerTrack[Srb->TargetId] *
                                     deviceExtension->NumberOfHeads[Srb->TargetId])) >> 8));

        DebugPrint((2,
                    "IdeVerify: CHS: Cylinder %x Head %x Sector %x\n",
                    startingSector /
                    (deviceExtension->SectorsPerTrack[Srb->TargetId] *
                     deviceExtension->NumberOfHeads[Srb->TargetId]),
                    (startingSector /
                     deviceExtension->SectorsPerTrack[Srb->TargetId]) %
                    deviceExtension->NumberOfHeads[Srb->TargetId],
                    startingSector %
                    deviceExtension->SectorsPerTrack[Srb->TargetId] + 1));
    }

/********
    if (endSector > sectors) {

        //
        // Too big, round down.
        //

        DebugPrint((1,
                    "IdeVerify: Truncating request to %x blocks\n",
                    sectors - startingSector - 1));

        IdePortOutPortByte(baseIoAddress1->BlockCount,
                               (UCHAR)(sectors - startingSector - 1));

    } else {

        IdePortOutPortByte(baseIoAddress1->BlockCount,(UCHAR)sectorCount);
    }
******/

    IdePortOutPortByte(baseIoAddress1->BlockCount,(UCHAR)sectorCount);

    //
    // Send verify command.
    //

    IdePortOutPortByte(baseIoAddress1->Command,
                       IDE_COMMAND_VERIFY);

    //
    // Wait for interrupt.
    //

    return SRB_STATUS_PENDING;

} // end IdeVerify()


VOID
Scsi2Atapi(
          IN PHW_DEVICE_EXTENSION DeviceExtension,
          IN PSCSI_REQUEST_BLOCK Srb
          )

/*++

Routine Description:

    Convert SCSI packet command to Atapi packet command.

Arguments:

    Srb - IO request packet

Return Value:

    None

--*/
{
    SAVE_ORIGINAL_CDB(DeviceExtension, Srb);

    DeviceExtension->scsi2atapi = FALSE;

    if (!(DeviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_TAPE_DEVICE)) {

        //
        // Change the cdb length
        //
        //Srb->CdbLength = 12;

        switch (Srb->Cdb[0]) {
        case SCSIOP_MODE_SENSE: {

            ASSERT(FALSE);

            break;
            }

        case SCSIOP_MODE_SELECT: {

            ASSERT (FALSE);

            break;
            }

        case SCSIOP_START_STOP_UNIT: {

                //
                // Bad Cd-roms
                // STOP command (1B) hangs during shutdown/hibernation on
                // some cd-rom drives. Setting the Immediate bit to 0 seems
                // to work
                //

                PCDB cdb = (PCDB)Srb->Cdb;
                if ((cdb->START_STOP.Immediate == 1) && 
                    (cdb->START_STOP.LoadEject == 0) &&
                    (cdb->START_STOP.Start == 0))

                    cdb->START_STOP.Immediate=0;
                DeviceExtension->scsi2atapi = TRUE;
                break;
            }

        case SCSIOP_FORMAT_UNIT:

            if (DeviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_LS120_FORMAT) {

                Srb->Cdb[0] = ATAPI_LS120_FORMAT_UNIT;
                DeviceExtension->scsi2atapi = TRUE;
            }
            break;

        }
    }

    return;
} // Scsi2Atapi



ULONG
AtapiSendCommand(
                IN PVOID HwDeviceExtension,
                IN PSCSI_REQUEST_BLOCK Srb
                )

/*++

Routine Description:

    Send ATAPI packet command to device.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:


--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PATAPI_REGISTERS_1   baseIoAddress1  = (PATAPI_REGISTERS_1)&deviceExtension->BaseIoAddress1;
    PATAPI_REGISTERS_2   baseIoAddress2 =  (PATAPI_REGISTERS_2)&deviceExtension->BaseIoAddress2;
    ULONG i;
    ULONG flags;
    UCHAR statusByte,byteCountLow,byteCountHigh;


#ifdef ENABLE_48BIT_LBA
    ASSERT(!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_48BIT_LBA));
#endif

    DebugPrint((DBG_ATAPI_DEVICES,
                "AtapiSendCommand: Command %x to TargetId %d lun %d\n",
                Srb->Cdb[0],
                Srb->TargetId,
                Srb->Lun));

    if (Srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) {
        DebugPrint((DBG_ATAPI_DEVICES,
                    "AtapiSendCommand: xferLength=%x, LBA=%x\n",
                    Srb->DataTransferLength,
                    (((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte0 |
                     (((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte1 << 8) | 
                     (((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte2 << 16) |
                     (((PCDB)Srb->Cdb)->CDB10.LogicalBlockByte3 << 24))
                   ));
    }

    //
    // Make sure command is to ATAPI device.
    //

    flags = deviceExtension->DeviceFlags[Srb->TargetId];

    if (Srb->Lun > deviceExtension->LastLun[Srb->TargetId]) {
        return SRB_STATUS_SELECTION_TIMEOUT;
    }

    if (!(flags & DFLAGS_ATAPI_DEVICE)) {
        return SRB_STATUS_SELECTION_TIMEOUT;
    }

    //
    // Select device 0 or 1.
    //
    SelectIdeDevice(baseIoAddress1, Srb->TargetId, 0);


    //
    // Verify that controller is ready for next command.
    //

    GetStatus(baseIoAddress1,statusByte);

    DebugPrint((2,
                "AtapiSendCommand: Entered with status %x\n",
                statusByte));

    if (statusByte & IDE_STATUS_BUSY) {
        DebugPrint((1,
                    "AtapiSendCommand: Device busy (%x)\n",
                    statusByte));
        return SRB_STATUS_BUSY;

    }

    //
    // If a tape drive has doesn't have DSC set and the last command is restrictive, don't send
    // the next command. See discussion of Restrictive Delayed Process commands in QIC-157.
    //

#if 0
    if ((!(statusByte & IDE_STATUS_DSC)) &&
        (flags & DFLAGS_TAPE_DEVICE) && deviceExtension->RDP) {
        KeStallExecutionProcessor(1000);
        DebugPrint((2,"AtapiSendCommand: DSC not set. %x\n",statusByte));
        return SRB_STATUS_BUSY;
    }
#endif

    //
    // Extended RDP to include SEEK commands for CD-ROMS.
    //
    if ((!(statusByte & IDE_STATUS_DSC)) && deviceExtension->RDP &&
        (flags & DFLAGS_RDP_SET)) {

        KeStallExecutionProcessor(1000);

        DebugPrint((DBG_ATAPI_DEVICES,
                    "AtapiSendCommand: DSC not set. %x\n",
                    statusByte
                   ));

        return SRB_STATUS_BUSY;
    }

    if (SRB_IS_RDP(Srb)) {

        deviceExtension->RDP = TRUE;
        SETMASK(deviceExtension->DeviceFlags[Srb->TargetId], DFLAGS_RDP_SET);

        DebugPrint((3,
                    "AtapiSendCommand: %x mapped as DSC restrictive\n",
                    Srb->Cdb[0]));

    } else {

        deviceExtension->RDP = FALSE;
        CLRMASK(deviceExtension->DeviceFlags[Srb->TargetId], DFLAGS_RDP_SET);
    }

    //
    // Convert SCSI to ATAPI commands if needed
    //
    Scsi2Atapi(deviceExtension, Srb);

    //
    // Set data buffer pointer and words left.
    //

    deviceExtension->DataBuffer = Srb->DataBuffer;
    deviceExtension->BytesLeft = Srb->DataTransferLength;

    WaitOnBusy(baseIoAddress1,statusByte);

    //
    // Write transfer byte count to registers.
    //

    byteCountLow = (UCHAR)(Srb->DataTransferLength & 0xFF);
    byteCountHigh = (UCHAR)(Srb->DataTransferLength >> 8);

    if (Srb->DataTransferLength >= 0x10000) {
        byteCountLow = byteCountHigh = 0xFF;
    }

    IdePortOutPortByte(baseIoAddress1->ByteCountLow,byteCountLow);
    IdePortOutPortByte(baseIoAddress1->ByteCountHigh, byteCountHigh);

    if (SRB_USES_DMA(Srb)) {
        IdePortOutPortByte(baseIoAddress1->Error, 0x1);
    } else {

        IdePortOutPortByte(baseIoAddress1->Error, 0x0);
    }

    if (flags & DFLAGS_INT_DRQ) {

        //
        // This device interrupts when ready to receive the packet.
        //
        // Write ATAPI packet command.
        //

        deviceExtension->ExpectingInterrupt = TRUE;

        IdePortOutPortByte(baseIoAddress1->Command,
                           IDE_COMMAND_ATAPI_PACKET);

        DebugPrint((3,
                    "AtapiSendCommand: Wait for int. to send packet. Status (%x)\n",
                    statusByte));

        return SRB_STATUS_PENDING;

    } else {

        //
        // Write ATAPI packet command.
        //

        IdePortOutPortByte(baseIoAddress1->Command,
                           IDE_COMMAND_ATAPI_PACKET);

        //
        // Wait for DRQ.
        //

        WaitOnBusy(baseIoAddress1, statusByte);
        WaitForDrq(baseIoAddress1, statusByte);

        if (!(statusByte & IDE_STATUS_DRQ)) {

            DebugPrint((1,
                        "AtapiSendCommand: DRQ never asserted (%x)\n",
                        statusByte));
            return SRB_STATUS_ERROR;
        }
    }

    //
    // Need to read status register.
    //

    GetBaseStatus(baseIoAddress1, statusByte);

    //
    // Indicate expecting an interrupt and wait for it.
    //

    deviceExtension->ExpectingInterrupt = TRUE;


    //
    // Send CDB to device.
    //

    WaitOnBusy(baseIoAddress1,statusByte);

    WriteBuffer(baseIoAddress1,
                (PUSHORT)Srb->Cdb,
                6);

    if (SRB_USES_DMA(Srb)) {
        deviceExtension->DMAInProgress = TRUE;
        deviceExtension->BusMasterInterface.BmArm (deviceExtension->BusMasterInterface.Context);
    }

    return SRB_STATUS_PENDING;

} // end AtapiSendCommand()

ULONG
IdeSendFlushCommand(
                   IN PVOID HwDeviceExtension,
                   IN PSCSI_REQUEST_BLOCK Srb
                   )
/*++

Routine Description:

    Program ATA registers for IDE flush command.

Arguments:

    HwDeviceExtension - ATAPI driver storage.
    Srb - System request block.

Return Value:

    SRB status (pending if all goes well).

--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    UCHAR                flushCommand;
    ULONG status;


    //
    // Get the flush command
    //
    flushCommand = deviceExtension->DeviceParameters[Srb->TargetId].IdeFlushCommand;

    //
    // We should check for the case where we have  already queued a 
    // flush cache command. 
    //
    if (flushCommand == IDE_COMMAND_NO_FLUSH) {
        return SRB_STATUS_SUCCESS;
    }

    //
    // if we reached this stage then the device should support flush command
    //
    ASSERT (flushCommand != IDE_COMMAND_NO_FLUSH);

    DebugPrint((1,
                "IdeSendFlushCommand: device %d, srb 0x%x\n",
                Srb->TargetId,
                Srb
               ));

    //
    // Select the right device
    //
    SelectIdeDevice(baseIoAddress1, Srb->TargetId, 0);

    //
    // Set data buffer pointer and words left.
    //
    deviceExtension->DataBuffer = (PUCHAR)Srb->DataBuffer;
    deviceExtension->BytesLeft = Srb->DataTransferLength;

    //
    // Indicate expecting an interrupt.
    //
    deviceExtension->ExpectingInterrupt = TRUE;
    status = SRB_STATUS_PENDING;


    //
    // Program the TaskFile registers
    //
    IdePortOutPortByte(baseIoAddress1->Error,        0);
    IdePortOutPortByte(baseIoAddress1->BlockCount,   0);
    IdePortOutPortByte(baseIoAddress1->BlockNumber,  0);
    IdePortOutPortByte(baseIoAddress1->CylinderLow,  0);
    IdePortOutPortByte(baseIoAddress1->CylinderHigh, 0);
    IdePortOutPortByte(baseIoAddress1->Command,      flushCommand);

    return status;
}

#ifdef ENABLE_48BIT_LBA

ULONG
IdeSendFlushCommandExt(
                      IN PVOID HwDeviceExtension,
                      IN PSCSI_REQUEST_BLOCK Srb
                      )
/*++

Routine Description:

    Program ATA registers for IDE flush ext command.

Arguments:

    HwDeviceExtension - ATAPI driver storage.
    Srb - System request block.

Return Value:

    SRB status (pending if all goes well).

--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    UCHAR                flushCommand;
    ULONG status;
    UCHAR statusByte;


    //
    // the device should support 48 bit LBA
    //
    ASSERT(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_48BIT_LBA);

    //
    // Get the flush command
    //
    flushCommand = deviceExtension->DeviceParameters[Srb->TargetId].IdeFlushCommandExt;

    //
    // We should check for the case where we have  already queued a 
    // flush cache command. 
    //
    if (flushCommand == IDE_COMMAND_NO_FLUSH) {
        return SRB_STATUS_SUCCESS;
    }

    //
    // if we reached this stage then the device should support flush command
    //
    ASSERT (flushCommand != IDE_COMMAND_NO_FLUSH);

    DebugPrint((1,
                "IdeSendFlushCommand: device %d, srb 0x%x\n",
                Srb->TargetId,
                Srb
               ));

    //
    // Select the right device
    //
    SelectIdeDevice(baseIoAddress1, Srb->TargetId, 0);

    //
    // Set data buffer pointer and words left.
    //
    deviceExtension->DataBuffer = (PUCHAR)Srb->DataBuffer;
    deviceExtension->BytesLeft = Srb->DataTransferLength;

    //
    // Indicate expecting an interrupt.
    //
    deviceExtension->ExpectingInterrupt = TRUE;
    status = SRB_STATUS_PENDING;


    //
    // Program the TaskFile registers (previous content)
    //
    IdePortOutPortByte(baseIoAddress1->Error,        0);
    IdePortOutPortByte(baseIoAddress1->BlockCount,   0);
    IdePortOutPortByte(baseIoAddress1->BlockNumber,  0);
    IdePortOutPortByte(baseIoAddress1->CylinderLow,  0);
    IdePortOutPortByte(baseIoAddress1->CylinderHigh, 0);

    //
    // Program the TaskFile registers (current content)
    //
    IdePortOutPortByte(baseIoAddress1->Error,        0);
    IdePortOutPortByte(baseIoAddress1->BlockCount,   0);
    IdePortOutPortByte(baseIoAddress1->BlockNumber,  0);
    IdePortOutPortByte(baseIoAddress1->CylinderLow,  0);
    IdePortOutPortByte(baseIoAddress1->CylinderHigh, 0);

    IdePortOutPortByte(baseIoAddress1->Command,      flushCommand);

    return status;
}
#endif

ULONG
IdeSendCommand(
              IN PVOID HwDeviceExtension,
              IN PSCSI_REQUEST_BLOCK Srb
              )

/*++

Routine Description:

    Program ATA registers for IDE disk transfer.

Arguments:

    HwDeviceExtension - ATAPI driver storage.
    Srb - System request block.

Return Value:

    SRB status (pending if all goes well).

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    PIDE_REGISTERS_2     baseIoAddress2  = &deviceExtension->BaseIoAddress2;
    PCDB cdb;

    UCHAR statusByte,errorByte;
    ULONG status;
    ULONG i;
    PMODE_PARAMETER_HEADER   modeData;

    DebugPrint((2,
                "IdeSendCommand: Command %x to device %d\n",
                Srb->Cdb[0],
                Srb->TargetId));



    switch (Srb->Cdb[0]) {
    case SCSIOP_INQUIRY:

        //
        // Filter out all TIDs but 0 and 1 since this is an IDE interface
        // which support up to two devices.
        //

        if ((Srb->Lun != 0) ||
            (!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT))) {

            //
            // Indicate no device found at this address.
            //

            status = SRB_STATUS_SELECTION_TIMEOUT;
            break;

        } else {

            INQUIRYDATA     inquiryData;
            PIDENTIFY_DATA  identifyData = &deviceExtension->IdentifyData[Srb->TargetId];

            //
            // Zero INQUIRY data structure.
            //
            RtlZeroMemory(Srb->DataBuffer, Srb->DataTransferLength);

            RtlZeroMemory((PUCHAR) &inquiryData, sizeof(INQUIRYDATA));

            inquiryData.DeviceType = DIRECT_ACCESS_DEVICE;

            //
            // Set the removable bit, if applicable.
            //

            if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_REMOVABLE_DRIVE) {
                inquiryData.RemovableMedia = 1;
            }

            //
            // Fill in vendor identification fields.
            //
            //for (i = 0; i < 20; i += 2) {
            //    inquiryData.VendorId[i] =
            //    ((PUCHAR)identifyData->ModelNumber)[i + 1];
            //    inquiryData.VendorId[i+1] =
            //    ((PUCHAR)identifyData->ModelNumber)[i];
            //}
            //
            // break it into two loops such that it 
            // explicitly indicates the fields to 
            // which the id is copied
            //

            //
            // copy the first 8 bytes to VendorId
            //
            for (i = 0; i < 8; i += 2) {
                inquiryData.VendorId[i] =
                ((PUCHAR)identifyData->ModelNumber)[i + 1];
                inquiryData.VendorId[i+1] =
                ((PUCHAR)identifyData->ModelNumber)[i];
            }

            //
            // copy the next 12 bytes to ProductId
            //
            for (i = 0; i < 12; i += 2) {
                inquiryData.ProductId[i] =
                ((PUCHAR)identifyData->ModelNumber)[i + 9];
                inquiryData.ProductId[i+1] =
                ((PUCHAR)identifyData->ModelNumber)[i + 8];
            }

            //
            // Initialize unused portion of product id.
            //
            for (i = 0; i < 4; i++) {
                inquiryData.ProductId[12+i] = ' ';
            }

            //
            // Move firmware revision from IDENTIFY data to
            // product revision in INQUIRY data.
            //
            for (i = 0; i < 4; i += 2) {
                inquiryData.ProductRevisionLevel[i] =
                ((PUCHAR)identifyData->FirmwareRevision)[i+1];
                inquiryData.ProductRevisionLevel[i+1] =
                ((PUCHAR)identifyData->FirmwareRevision)[i];
            }

            //
            // Copy as much the return data as possible
            //
            RtlMoveMemory (
                          Srb->DataBuffer,
                          &inquiryData,
                          Srb->DataTransferLength > sizeof (INQUIRYDATA) ? 
                          sizeof (INQUIRYDATA) : 
                          Srb->DataTransferLength
                          );

            status = SRB_STATUS_SUCCESS;
        }

        break;

    case SCSIOP_TEST_UNIT_READY:

        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED) {

            //
            // Select device 0 or 1.
            //

            SelectIdeDevice(baseIoAddress1, Srb->TargetId, 0);
            IdePortOutPortByte(baseIoAddress1->Command,IDE_COMMAND_GET_MEDIA_STATUS);

            //
            // Wait for busy. If media has not changed, return success
            //

            WaitOnBusy(baseIoAddress1,statusByte);

            if (!(statusByte & IDE_STATUS_ERROR)) {
                deviceExtension->ExpectingInterrupt = FALSE;
                status = SRB_STATUS_SUCCESS;
            } else {
                errorByte = IdePortInPortByte(baseIoAddress1->Error);
                if (errorByte == IDE_ERROR_DATA_ERROR) {

                    //
                    // Special case: If current media is write-protected,
                    // the 0xDA command will always fail since the write-protect bit
                    // is sticky,so we can ignore this error
                    //

                    GetBaseStatus(baseIoAddress1, statusByte);
                    status = SRB_STATUS_SUCCESS;

                } else {

                    deviceExtension->ReturningMediaStatus = errorByte;

                    //
                    // we need to set the scsi status here. Otherwise we 
                    // won't issue a request sense
                    //
                    Srb->ScsiStatus = SCSISTAT_CHECK_CONDITION;
                    Srb->SrbStatus = SRB_STATUS_ERROR;

                    status = SRB_STATUS_ERROR;
                }
            }
        } else {
            status = SRB_STATUS_SUCCESS;
        }

        break;

    case SCSIOP_VERIFY:
#ifdef ENABLE_48BIT_LBA

        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_48BIT_LBA) {

            status = IdeVerifyExt(HwDeviceExtension, Srb);
            break;
        }
#endif
        status = IdeVerify(HwDeviceExtension,Srb);

        break;
#ifdef  DIDE_CPQ_BM
    case SCSIOP_DVD_READ:
    case SCSIOP_REPORT_KEY:
    case SCSIOP_SEND_KEY:
    case SCSIOP_READ_DVD_STRUCTURE:
#endif
    case SCSIOP_READ:
    case SCSIOP_WRITE:

#ifdef ENABLE_48BIT_LBA

        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_48BIT_LBA) {

            status = IdeReadWriteExt(HwDeviceExtension,
                                     Srb);
            break;
        }
#endif
        status = IdeReadWrite(HwDeviceExtension,
                              Srb);
        break;

    case SCSIOP_START_STOP_UNIT:

        //
        //Determine what type of operation we should perform
        //
        cdb = (PCDB)Srb->Cdb;

        if (cdb->START_STOP.LoadEject == 1) {

            SelectIdeLine(baseIoAddress1, Srb->TargetId >> 1);

            //
            // Eject media,
            // first select device 0 or 1.
            //
            WaitOnBusy(baseIoAddress1,statusByte);

            SelectIdeDevice(baseIoAddress1, Srb->TargetId, 0);
            IdePortOutPortByte(baseIoAddress1->Command,IDE_COMMAND_MEDIA_EJECT);
        }
        status = SRB_STATUS_SUCCESS;
        break;

    case SCSIOP_MEDIUM_REMOVAL:

        cdb = (PCDB)Srb->Cdb;

        SelectIdeLine(baseIoAddress1, Srb->TargetId >> 1);

        WaitOnBusy(baseIoAddress1,statusByte);

        SelectIdeDevice(baseIoAddress1, Srb->TargetId, 0);
        if (cdb->MEDIA_REMOVAL.Prevent == TRUE) {
            IdePortOutPortByte(baseIoAddress1->Command,IDE_COMMAND_DOOR_LOCK);
        } else {
            IdePortOutPortByte(baseIoAddress1->Command,IDE_COMMAND_DOOR_UNLOCK);
        }

        status = SRB_STATUS_SUCCESS;

        WaitOnBusy(baseIoAddress1,statusByte);

        if (statusByte & IDE_STATUS_ERROR) {

            errorByte = IdePortInPortByte(baseIoAddress1->Error);

            status = MapError(HwDeviceExtension, Srb);

        }

        break;

    case SCSIOP_REQUEST_SENSE:
        // this function makes sense buffers to report the results
        // of the original GET_MEDIA_STATUS command

        if ((deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED) && 
            (Srb->DataTransferLength >= sizeof(SENSE_DATA))) {
            status = IdeBuildSenseBuffer(HwDeviceExtension, Srb);
        } else {
            status = SRB_STATUS_INVALID_REQUEST;
        }
        break;

    case SCSIOP_SYNCHRONIZE_CACHE:

        DebugPrint((1,
                    "Flush the cache for IDE device %d\n",
                    Srb->TargetId
                   ));

        status = SRB_STATUS_SUCCESS;

        //
        // Send the flush command if one exists
        //
#ifdef ENABLE_48BIT_LBA
            if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_48BIT_LBA) {

                if (deviceExtension->DeviceParameters[Srb->TargetId].IdeFlushCommandExt != 
                    IDE_COMMAND_NO_FLUSH) {

                    status = IdeSendFlushCommandExt(HwDeviceExtension, Srb);
                }

            } else {
#endif

                if (deviceExtension->DeviceParameters[Srb->TargetId].IdeFlushCommand != 
                    IDE_COMMAND_NO_FLUSH) {

                    status = IdeSendFlushCommand(deviceExtension, Srb);
                }
#ifdef ENABLE_48BIT_LBA
            }
#endif
        break;

    case SCSIOP_FORMAT_UNIT:
        if ( IsNEC_98 ) {
            // 
            // Support physical format of fixed disk.
            // It is meaningful for SCSI device.
            // So, we do not execute it on IDE device.
            // But we need to return the success in order to fit with SCSI
            // 
            status = SRB_STATUS_SUCCESS;
            break;
        }

    default:

        DebugPrint((1,
                    "IdeSendCommand: Unsupported command %x\n",
                    Srb->Cdb[0]));

        status = SRB_STATUS_INVALID_REQUEST;

    } // end switch

    return status;

} // end IdeSendCommand()

ULONG
IdeSendPassThroughCommand(
                         IN PVOID HwDeviceExtension,
                         IN PSCSI_REQUEST_BLOCK Srb
                         )

/*++

Routine Description:

    Program ATA registers for IDE disk transfer.

Arguments:

    HwDeviceExtension - ATAPI driver storage.
    Srb - System request block.

Return Value:

    SRB status (pending if all goes well).

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    PIDE_REGISTERS_2     baseIoAddress2  = &deviceExtension->BaseIoAddress2;
    PCDB cdb;
    UCHAR statusByte,errorByte;
    ULONG status;
    PATA_PASS_THROUGH       ataPassThroughData;
    PIDEREGS                pIdeReg;

    ataPassThroughData = Srb->DataBuffer;
    pIdeReg            = &ataPassThroughData->IdeReg;

    //
    // select the right device
    //
    CLRMASK (pIdeReg->bDriveHeadReg, 0xb0);
    pIdeReg->bDriveHeadReg |= (UCHAR) (((Srb->TargetId & 0x1) << 4) | 0xA0);

    SelectIdeDevice(baseIoAddress1, Srb->TargetId, pIdeReg->bDriveHeadReg);

    //
    // check to see if this is a "no-op" SRB 
    //
    if (pIdeReg->bReserved & ATA_PTFLAGS_NO_OP) {

        ULONG repeatCount = (ULONG)ataPassThroughData->IdeReg.bSectorCountReg;
        UCHAR busyWait = pIdeReg->bSectorNumberReg;

        //
        // wait for busy if this is set
        //
        if (busyWait != 0) {

            ULONG busyWaitTime;

            if (busyWait > 30) {

                busyWait = 30;
            }

            busyWaitTime = busyWait * 1000;

            GetStatus(baseIoAddress1, statusByte);

            WaitOnBusyUntil(baseIoAddress1, statusByte, busyWaitTime);
        }

        if (repeatCount <= 0) {
            repeatCount = 1;
        }

        while (repeatCount) {
            repeatCount--;

            KeStallExecutionProcessor(100);

            //
            // get a copy of the task file registers
            //
            AtapiTaskRegisterSnapshot (
                                      baseIoAddress1,
                                      pIdeReg
                                      );
        }

        return SRB_STATUS_SUCCESS;
    }

    if (pIdeReg->bReserved & ATA_PTFLAGS_EMPTY_CHANNEL_TEST) {

#ifdef DPC_FOR_EMPTY_CHANNEL
        if (status=IdePortChannelEmptyQuick(baseIoAddress1, baseIoAddress2, 
                                            deviceExtension->MaxIdeDevice, &deviceExtension->CurrentIdeDevice,
                                            &deviceExtension->MoreWait, &deviceExtension->NoRetry)) {
            if (status==STATUS_RETRY) {
                return SRB_STATUS_PENDING;
            }
            return SRB_STATUS_SUCCESS;
        } else {
            return SRB_STATUS_ERROR;
        }
#endif

        if (IdePortChannelEmpty(baseIoAddress1, baseIoAddress2, deviceExtension->MaxIdeDevice)) {

            return SRB_STATUS_SUCCESS;

        } else {

            return SRB_STATUS_ERROR;
        }
    }


    if (pIdeReg->bReserved & ATA_PTFLAGS_INLINE_HARD_RESET) {

        IdeHardReset (
                     baseIoAddress1,
                     baseIoAddress2,
                     FALSE,
                     TRUE
                     );

        //
        // re-select the right device
        //
        SelectIdeDevice(baseIoAddress1, Srb->TargetId, pIdeReg->bDriveHeadReg);
    }

    GetStatus(baseIoAddress1, statusByte);

    if (statusByte & IDE_STATUS_BUSY) {
        DebugPrint((1,
                    "IdeSendPassThroughCommand: Returning BUSY status\n"));
        return SRB_STATUS_BUSY;
    }
    if (pIdeReg->bReserved & ATA_PTFLAGS_STATUS_DRDY_REQUIRED) {

        if (!(statusByte & IDE_STATUS_DRDY)) {

            if ((statusByte == 0)  &&
                (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_SONY_MEMORYSTICK)) {
                statusByte = IDE_STATUS_DRDY;
            } else {
                DebugPrint((1,
                            "IdeSendPassThroughCommand: DRDY not ready\n"));
                return SRB_STATUS_BUSY;
            }
        }
    }
    if (pIdeReg->bCommandReg != IDE_COMMAND_ATAPI_RESET) {


#if 1
        //
        // if identifydata in device extension is valid, use it
        // send it to the device if enum probling flag is set
        //
        if ((deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_IDENTIFY_VALID) && 
            (pIdeReg->bCommandReg == IDE_COMMAND_IDENTIFY) &&
            (!(pIdeReg->bFeaturesReg & ATA_PTFLAGS_ENUM_PROBING))) {

            ASSERT(!(deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_REMOVABLE_DRIVE));

            DebugPrint((1, "Bypassing identify command\n"));

            RtlMoveMemory(ataPassThroughData->DataBuffer, &(deviceExtension->IdentifyData[Srb->TargetId]), 
                          ataPassThroughData->DataBufferSize);

            return SRB_STATUS_SUCCESS;

        }
#endif
        //
        // Set data buffer pointer and bytes left.
        //

        deviceExtension->DataBuffer = ataPassThroughData->DataBuffer;
        deviceExtension->BytesLeft = ataPassThroughData->DataBufferSize;

        //
        // Indicate expecting an interrupt.
        //

        deviceExtension->ExpectingInterrupt = TRUE;
        status = SRB_STATUS_PENDING;

        IdePortOutPortByte(baseIoAddress1->Error,        pIdeReg->bFeaturesReg);
        IdePortOutPortByte(baseIoAddress1->BlockCount,   pIdeReg->bSectorCountReg);
        IdePortOutPortByte(baseIoAddress1->BlockNumber,  pIdeReg->bSectorNumberReg);
        IdePortOutPortByte(baseIoAddress1->CylinderLow,  pIdeReg->bCylLowReg);
        IdePortOutPortByte(baseIoAddress1->CylinderHigh, pIdeReg->bCylHighReg);
        IdePortOutPortByte(baseIoAddress1->Command,      pIdeReg->bCommandReg);

    } else {

        //
        // perform sync. atapi soft reset because this command doesn't generate interrupts
        //
        AtapiSoftReset(baseIoAddress1, baseIoAddress2, Srb->TargetId & 0x1, FALSE);
        status = SRB_STATUS_SUCCESS;
    }

    DebugPrint ((1, "IdeSendPassThroughCommand: 0x%x 0x%x command = 0x%x\n", baseIoAddress1->RegistersBaseAddress, Srb->TargetId, pIdeReg->bCommandReg));

    return status;

} // end IdeSendPassThroughCommand()


VOID
IdeMediaStatus(
              BOOLEAN EnableMSN,
              IN PVOID HwDeviceExtension,
              ULONG DeviceNumber
              )
/*++

Routine Description:

    Enables disables media status notification

Arguments:

HwDeviceExtension - ATAPI driver storage.

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress = &deviceExtension->BaseIoAddress1;
    UCHAR statusByte,errorByte;


    if (EnableMSN == TRUE) {

        //
        // If supported enable Media Status Notification support
        //

        if ((deviceExtension->DeviceFlags[DeviceNumber] & DFLAGS_MSN_SUPPORT)) {

            //
            // enable
            //
            SelectIdeDevice(baseIoAddress, DeviceNumber, 0);
            IdePortOutPortByte(baseIoAddress->Error,(UCHAR) (0x95));
            IdePortOutPortByte(baseIoAddress->Command,
                               IDE_COMMAND_SET_FEATURE);

            WaitOnBaseBusy(baseIoAddress,statusByte);

            if (statusByte & IDE_STATUS_ERROR) {
                //
                // Read the error register.
                //
                errorByte = IdePortInPortByte(baseIoAddress->Error);

                DebugPrint((1,
                            "IdeMediaStatus: Error enabling media status. Status %x, error byte %x\n",
                            statusByte,
                            errorByte));
            } else {
                deviceExtension->DeviceFlags[DeviceNumber] |= DFLAGS_MEDIA_STATUS_ENABLED;
                DebugPrint((1,"IdeMediaStatus: Media Status Notification Supported\n"));
                deviceExtension->ReturningMediaStatus = 0;

            }

        }
    } else { // end if EnableMSN == TRUE

        //
        // disable if previously enabled
        //
        if ((deviceExtension->DeviceFlags[DeviceNumber] & DFLAGS_MEDIA_STATUS_ENABLED)) {

            SelectIdeDevice(baseIoAddress, DeviceNumber, 0);
            IdePortOutPortByte(baseIoAddress->Error,(UCHAR) (0x31));
            IdePortOutPortByte(baseIoAddress->Command,
                               IDE_COMMAND_SET_FEATURE);

            WaitOnBaseBusy(baseIoAddress,statusByte);
            CLRMASK (deviceExtension->DeviceFlags[DeviceNumber], DFLAGS_MEDIA_STATUS_ENABLED);
        }


    }

}

ULONG
IdeBuildSenseBuffer(
                   IN PVOID HwDeviceExtension,
                   IN PSCSI_REQUEST_BLOCK Srb
                   )

/*++

Routine Description:

    Builts an artificial sense buffer to report the results of a GET_MEDIA_STATUS
    command. This function is invoked to satisfy the SCSIOP_REQUEST_SENSE.
Arguments:

    HwDeviceExtension - ATAPI driver storage.
    Srb - System request block.

Return Value:

    SRB status (ALWAYS SUCCESS).

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG status;
    PSENSE_DATA  senseBuffer = (PSENSE_DATA)Srb->DataBuffer;

    if (senseBuffer) {

        if (deviceExtension->ReturningMediaStatus & IDE_ERROR_MEDIA_CHANGE) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_MEDIUM_CHANGED;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        } else if (deviceExtension->ReturningMediaStatus & IDE_ERROR_MEDIA_CHANGE_REQ) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_UNIT_ATTENTION;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_OPERATOR_REQUEST;
            senseBuffer->AdditionalSenseCodeQualifier = SCSI_SENSEQ_MEDIUM_REMOVAL;
        } else if (deviceExtension->ReturningMediaStatus & IDE_ERROR_END_OF_MEDIA) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_NOT_READY;
            senseBuffer->AdditionalSenseCode = SCSI_ADSENSE_NO_MEDIA_IN_DEVICE;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        } else if (deviceExtension->ReturningMediaStatus & IDE_ERROR_DATA_ERROR) {

            senseBuffer->ErrorCode = 0x70;
            senseBuffer->Valid     = 1;
            senseBuffer->AdditionalSenseLength = 0xb;
            senseBuffer->SenseKey =  SCSI_SENSE_DATA_PROTECT;
            senseBuffer->AdditionalSenseCode = 0;
            senseBuffer->AdditionalSenseCodeQualifier = 0;
        }

        return SRB_STATUS_SUCCESS;
    }
    return SRB_STATUS_ERROR;

}// End of IdeBuildSenseBuffer




BOOLEAN
AtapiStartIo(
            IN PVOID HwDeviceExtension,
            IN PSCSI_REQUEST_BLOCK Srb
            )

/*++

Routine Description:

    This routine is called from the port driver synchronized
    with the kernel to start an IO request.

Arguments:

    HwDeviceExtension - HBA miniport driver's adapter data storage
    Srb - IO request packet

Return Value:

    TRUE

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    ULONG status;


#if DBG

    //
    // Code to simulate a hard-hang of an IDE device.
    //

    if (IdeDebugSimulateHardHang) {
    
        Srb->SrbStatus = SRB_STATUS_BUSY;

        //
        // Indicate command complete.
        //

        IdePortNotification(IdeRequestComplete,
                            deviceExtension,
                            Srb);

        //
        // Indicate ready for next request.
        //

        IdePortNotification(IdeNextRequest,
                            deviceExtension,
                            NULL);

        //
        // Mark all the devices deadmeat
        //

        IdePortNotification(IdeAllDeviceMissing,
                            deviceExtension,
                            NULL);

        return TRUE;
    }
#endif // DBG

    //
    // Determine which function.
    //

    switch (Srb->Function) {
    
    case SRB_FUNCTION_ATA_POWER_PASS_THROUGH:
    case SRB_FUNCTION_FLUSH:
    case SRB_FUNCTION_SHUTDOWN:
    case SRB_FUNCTION_ATA_PASS_THROUGH:
    case SRB_FUNCTION_ATA_PASS_THROUGH_EX:
    case SRB_FUNCTION_EXECUTE_SCSI:

        //
        // Sanity check. Only one request can be outstanding on a
        // controller.
        //

        if (deviceExtension->CurrentSrb) {

            DebugPrint((1,
                        "AtapiStartIo: Already have a request!\n"));
            Srb->SrbStatus = SRB_STATUS_BUSY;
            IdePortNotification(IdeRequestComplete,
                                deviceExtension,
                                Srb);
            return FALSE;
        }

        //
        // Indicate that a request is active on the controller.
        //

        deviceExtension->CurrentSrb = Srb;

        //
        // Send command to device.
        //
        if (Srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH_EX) {

            //
            // ATA PASSTHROUGH EX
            status = IdeSendAtaPassThroughExCommand(HwDeviceExtension,
                                                    Srb
                                                    );

        } else if ((Srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH) ||
                   (Srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH)) {

            // ATA_PASSTHORUGH
            status = IdeSendPassThroughCommand(HwDeviceExtension,
                                               Srb);

        } else if ((deviceExtension->DeviceFlags[Srb->TargetId] & 
                    (DFLAGS_ATAPI_DEVICE | DFLAGS_DEVICE_PRESENT)) ==
                   (DFLAGS_ATAPI_DEVICE | DFLAGS_DEVICE_PRESENT)) {

            status = AtapiSendCommand(HwDeviceExtension,
                                      Srb);

        } else if ((Srb->Function == SRB_FUNCTION_FLUSH) ||
                   (Srb->Function == SRB_FUNCTION_SHUTDOWN)) {

#ifdef ENABLE_48BIT_LBA
            if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_48BIT_LBA) {

                status = IdeSendFlushCommandExt(HwDeviceExtension,
                                                Srb);
            } else {
#endif

                status = IdeSendFlushCommand(HwDeviceExtension,
                                             Srb);

#ifdef ENABLE_48BIT_LBA
            }
#endif

        } else if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_DEVICE_PRESENT) {

            status = IdeSendCommand(HwDeviceExtension,
                                    Srb);

        } else {

            status = SRB_STATUS_SELECTION_TIMEOUT;
        }

        break;

    case SRB_FUNCTION_ABORT_COMMAND:

        //
        // Verify that SRB to abort is still outstanding.
        //

        if (!deviceExtension->CurrentSrb) {

            DebugPrint((1, "AtapiStartIo: SRB to abort already completed\n"));

            //
            // Complete abort SRB.
            //

            status = SRB_STATUS_ABORT_FAILED;

            break;
        }

        //
        // Abort function indicates that a request timed out.
        // Call reset routine. Card will only be reset if
        // status indicates something is wrong.
        // Fall through to reset code.
        //

    case SRB_FUNCTION_RESET_BUS:

        //
        // Reset Atapi and SCSI bus.
        //

        DebugPrint((1, "AtapiStartIo: Reset bus request received\n"));

        SelectIdeLine(&deviceExtension->BaseIoAddress1, Srb->TargetId >> 1);

        if (!AtapiSyncResetController(deviceExtension,
                                      Srb->PathId)) {

            DebugPrint((1,"AtapiStartIo: Reset bus failed\n"));

            //
            // Log reset failure.
            //

            IdePortLogError(
                           HwDeviceExtension,
                           NULL,
                           0,
                           0,
                           0,
                           SP_INTERNAL_ADAPTER_ERROR,
                           5 << 8
                           );

            status = SRB_STATUS_ERROR;

        } else {

            status = SRB_STATUS_SUCCESS;
        }

        break;

    case SRB_FUNCTION_IO_CONTROL:

        if (deviceExtension->CurrentSrb) {

            DebugPrint((1,
                        "AtapiStartIo: Already have a request!\n"));
            Srb->SrbStatus = SRB_STATUS_BUSY;
            IdePortNotification(IdeRequestComplete,
                                deviceExtension,
                                Srb);
            return FALSE;
        }

        //
        // Indicate that a request is active on the controller.
        //

        deviceExtension->CurrentSrb = Srb;

        if (strlen("SCSIDISK") != RtlCompareMemory(((PSRB_IO_CONTROL)(Srb->DataBuffer))->Signature,"SCSIDISK",strlen("SCSIDISK"))) {

            DebugPrint((1,
                        "AtapiStartIo: IoControl signature incorrect. Send %s, expected %s\n",
                        ((PSRB_IO_CONTROL)(Srb->DataBuffer))->Signature,
                        "SCSIDISK"));

            status = SRB_STATUS_INVALID_REQUEST;
            break;
        }

        switch (((PSRB_IO_CONTROL)(Srb->DataBuffer))->ControlCode) {
        
        case IOCTL_SCSI_MINIPORT_SMART_VERSION: {

                PGETVERSIONINPARAMS versionParameters = (PGETVERSIONINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                UCHAR deviceNumber;
                UCHAR channelNo;

                //
                // Version and revision per SMART 1.03
                //

                versionParameters->bVersion = 1;
                versionParameters->bRevision = 1;
                versionParameters->bReserved = 0;

                //
                // Indicate that support for IDE IDENTIFY, ATAPI IDENTIFY and SMART commands.
                //

                versionParameters->fCapabilities = (CAP_ATA_ID_CMD | CAP_ATAPI_ID_CMD | CAP_SMART_CMD);

                //
                // This is done because of how the IOCTL_SCSI_MINIPORT
                // determines 'targetid's'. Disk.sys places the real target id value
                // in the DeviceMap field. Once we do some parameter checking, the value passed
                // back to the application will be determined.
                //


                //
                // HACK: atapi doesn't have the channel number. So it uses the hack below.
                // this should work on non native mode IDE controllers
                //
                channelNo = (deviceExtension->PrimaryAddress)? 0:1;

                //
                // the bIDEDeviceMap is a bit map, with the bits defined as follows
                // bit 0 - IDE drive as master on Primary channel
                // bit 1 - IDE drive as slave on Primary channel
                // bit 2 - IDE drive as master on Secondary channel
                // bit 3 - IDE drive as slave on Secondary Channel
                // bit 4 - ATAPI drive as master on Primary Channle
                // bit 5 - ATAPI drive as slave on Primary Channle
                // bit 6 - ATAPI drive as master on secondary Channle
                // bit 7 - ATAPI drive as slave on secondary Channle
                //
                // since we have an FDO per channel, we can only fill in the fields
                // pertinent to this channel. 
                //

                versionParameters->bIDEDeviceMap = 0;

                //
                // Master device
                //
                deviceNumber = 0;
                if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {
                    if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_ATAPI_DEVICE) {

                        deviceNumber += channelNo*2 + 4;

                    } else {

                        deviceNumber += channelNo*2;

                    }

                    versionParameters->bIDEDeviceMap |= (1 << deviceNumber);
                }

                //
                // slave device
                //
                deviceNumber = 1;
                if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {
                    if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_ATAPI_DEVICE) {

                        deviceNumber += channelNo*2 + 4;

                    } else {

                        deviceNumber += channelNo*2;

                    }

                    versionParameters->bIDEDeviceMap |= (1 << deviceNumber);
                }


                //if (!(deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) ||
                 //   (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_ATAPI_DEVICE)) {
//
 //                   status = SRB_STATUS_SELECTION_TIMEOUT;
  //                  break;
   //             }

                status = SRB_STATUS_SUCCESS;
                break;
            }

        case IOCTL_SCSI_MINIPORT_IDENTIFY: {

                PSENDCMDOUTPARAMS cmdOutParameters = (PSENDCMDOUTPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                SENDCMDINPARAMS   cmdInParameters = *(PSENDCMDINPARAMS)(((PUCHAR)Srb->DataBuffer) + sizeof(SRB_IO_CONTROL));
                ULONG             i;
                UCHAR             targetId;


                if (cmdInParameters.irDriveRegs.bCommandReg == ID_CMD) {

                    //
                    // Extract the target.
                    //

                    targetId = cmdInParameters.bDriveNumber;

                    if (!(deviceExtension->DeviceFlags[targetId] & DFLAGS_DEVICE_PRESENT) ||
                        (deviceExtension->DeviceFlags[targetId] & DFLAGS_ATAPI_DEVICE)) {

                        status = SRB_STATUS_SELECTION_TIMEOUT;
                        break;
                    }

                    //
                    // Zero the output buffer
                    //

                    for (i = 0; i < (sizeof(SENDCMDOUTPARAMS) + IDENTIFY_BUFFER_SIZE - 1); i++) {
                        ((PUCHAR)cmdOutParameters)[i] = 0;
                    }

                    //
                    // Build status block.
                    //

                    cmdOutParameters->cBufferSize = IDENTIFY_BUFFER_SIZE;
                    cmdOutParameters->DriverStatus.bDriverError = 0;
                    cmdOutParameters->DriverStatus.bIDEError = 0;

                    //
                    // Extract the identify data from the device extension.
                    //

                    RtlMoveMemory (cmdOutParameters->bBuffer, &deviceExtension->IdentifyData[targetId], IDENTIFY_DATA_SIZE);

                    status = SRB_STATUS_SUCCESS;


                } else {
                    status = SRB_STATUS_INVALID_REQUEST;
                }
                break;
            }

        case  IOCTL_SCSI_MINIPORT_READ_SMART_ATTRIBS:
        case  IOCTL_SCSI_MINIPORT_READ_SMART_THRESHOLDS:
        case  IOCTL_SCSI_MINIPORT_ENABLE_SMART:
        case  IOCTL_SCSI_MINIPORT_DISABLE_SMART:
        case  IOCTL_SCSI_MINIPORT_RETURN_STATUS:
        case  IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTOSAVE:
        case  IOCTL_SCSI_MINIPORT_SAVE_ATTRIBUTE_VALUES:
        case  IOCTL_SCSI_MINIPORT_EXECUTE_OFFLINE_DIAGS:
        case  IOCTL_SCSI_MINIPORT_ENABLE_DISABLE_AUTO_OFFLINE:
#ifdef ENABLE_SMARTLOG_SUPPORT
        case  IOCTL_SCSI_MINIPORT_READ_SMART_LOG:
        case  IOCTL_SCSI_MINIPORT_WRITE_SMART_LOG:
#endif

            status = IdeSendSmartCommand(HwDeviceExtension,Srb);
            break;

        default :

            status = SRB_STATUS_INVALID_REQUEST;
            break;

        }

        break;

    default:

        //
        // Indicate unsupported command.
        //

        status = SRB_STATUS_INVALID_REQUEST;

        break;

    } // end switch

    //
    // Check if command complete.
    //

    if (status != SRB_STATUS_PENDING) {

        DebugPrint((2,
                    "AtapiStartIo: Srb %x complete with status %x\n",
                    Srb,
                    status));

        //
        // Clear current SRB.
        //

        deviceExtension->CurrentSrb = NULL;

        //
        // Set status in SRB.
        //

        Srb->SrbStatus = (UCHAR)status;

        //
        // Indicate command complete.
        //

        IdePortNotification(IdeRequestComplete,
                            deviceExtension,
                            Srb);

        //
        // Indicate ready for next request.
        //

        IdePortNotification(IdeNextRequest,
                            deviceExtension,
                            NULL);
    }

    return TRUE;

} // end AtapiStartIo()

BOOLEAN
AtapiSyncResetController(
                        IN PVOID  HwDeviceExtension,
                        IN ULONG  PathId
                        )
{
    ULONG   callAgain = 0;
    BOOLEAN result;

    do {

        result = AtapiResetController(
                                     HwDeviceExtension,
                                     PathId,
                                     &callAgain
                                     );

    } while (callAgain);

    return result;
}


NTSTATUS
IdeHardReset (
             PIDE_REGISTERS_1     BaseIoAddress1,
             PIDE_REGISTERS_2     BaseIoAddress2,
             BOOLEAN              InterruptOff,
             BOOLEAN              Sync
             )
{
    UCHAR resetByte;

    DebugPrint((1,
                "IdeHardReset: Resetting controller.\n"));

    //
    // Kingston DP-ATA/20 pcmcia flash card
    //
    // if we don't make sure we select master device,
    // later when we check for busy status, we will
    // get the non-existing slave status
    //
    IdePortOutPortByte (BaseIoAddress1->DriveSelect, 0xA0);

    IdePortOutPortByte (BaseIoAddress2->DeviceControl, IDE_DC_RESET_CONTROLLER | IDE_DC_DISABLE_INTERRUPTS);

    //
    // ATA-2 spec requires a minimum of 5 microsec stall here
    //
    KeStallExecutionProcessor (10);

    if (InterruptOff) {
        resetByte = IDE_DC_DISABLE_INTERRUPTS;

    } else {
        resetByte = IDE_DC_REENABLE_CONTROLLER;
    }

    IdePortOutPortByte (BaseIoAddress2->DeviceControl, resetByte);

    //
    // ATA-2 spec requires a minimum of 400 ns stall here
    //
    KeStallExecutionProcessor (1);

    if (Sync) {

        UCHAR deviceSelect;
        UCHAR status;
        ULONG sec;                                                      
        ULONG i;                                                        
        UCHAR statusByte;

        WaitOnBusyUntil(BaseIoAddress1, statusByte, 500);

        IdePortOutPortByte (BaseIoAddress1->DriveSelect, 0xa0);
        deviceSelect = IdePortInPortByte(BaseIoAddress1->DriveSelect);
        if (deviceSelect != 0xa0) {

            //
            // slave only channel
            //
            KeStallExecutionProcessor(1000);                     
            IdePortOutPortByte (BaseIoAddress1->DriveSelect, 0xb0);
        }

        //
        // ATA-2 spec allows a maximum of 31s for both master and slave device to come back from reset
        //
        for (sec=0; sec<31; sec++) {

            /**/                                                        
            /* one second loop */                                       
            /**/                                                        
            for (i=0; i<2500; i++) {
                GetStatus(BaseIoAddress1, status);                       
                if (status & IDE_STATUS_BUSY) {
                    KeStallExecutionProcessor(400);                     
                    continue;                                           
                } else {
                    break;                                              
                }                                                       
            }                                                           
            if (status == 0xff) {
                break;                                                  
            } else if (status & IDE_STATUS_BUSY) {
                DebugPrint ((0, "ATAPI: IdeHardReset WaitOnBusy failed. status = 0x%x\n", (ULONG) (status))); 
            } else {
                break;                                                  
            }                                                           
        }                                                               

        if (status & IDE_STATUS_BUSY) {

            DebugPrint ((0, "ATAPI: IdeHardReset WaitOnBusy failed. status = 0x%x\n", (ULONG) (status))); 

            return STATUS_UNSUCCESSFUL;

        } else {

            return STATUS_SUCCESS;
        }

    } else {

        return STATUS_SUCCESS;
    }
}


VOID
AtapiTaskRegisterSnapshot (
                          IN PIDE_REGISTERS_1 CmdRegBase,
                          IN OUT PIDEREGS     IdeReg
                          )
{
    ASSERT(IdeReg);

    IdeReg->bFeaturesReg     = IdePortInPortByte(CmdRegBase->Error);
    IdeReg->bSectorCountReg  = IdePortInPortByte(CmdRegBase->BlockCount);
    IdeReg->bSectorNumberReg = IdePortInPortByte(CmdRegBase->BlockNumber);
    IdeReg->bCylLowReg       = IdePortInPortByte(CmdRegBase->CylinderLow);
    IdeReg->bCylHighReg      = IdePortInPortByte(CmdRegBase->CylinderHigh);
    IdeReg->bDriveHeadReg    = IdePortInPortByte(CmdRegBase->DriveSelect);
    IdeReg->bCommandReg      = IdePortInPortByte(CmdRegBase->Command);

    return;
} // AtapiTaskFileSnapshot

BOOLEAN
GetAtapiIdentifyQuick (
    IN PIDE_REGISTERS_1 BaseIoAddress1,
    IN PIDE_REGISTERS_2 BaseIoAddress2,
    IN ULONG DeviceNumber,
    OUT PIDENTIFY_DATA IdentifyData
    )
{
    UCHAR statusByte;
    ULONG i;

    SelectIdeDevice(BaseIoAddress1, DeviceNumber, 0);

    GetStatus(BaseIoAddress1, statusByte);

    if (statusByte & IDE_STATUS_BUSY) {

        return FALSE;
    }

    IdePortOutPortByte(BaseIoAddress1->Command, IDE_COMMAND_ATAPI_IDENTIFY);

    WaitOnBusyUntil(BaseIoAddress1, statusByte, 500);

    if ((statusByte & IDE_STATUS_BUSY) ||
        (statusByte & IDE_STATUS_ERROR)) {

        return FALSE;
    }
    
    if (statusByte & IDE_STATUS_DRQ) {

        ReadBuffer(BaseIoAddress1,
                   (PUSHORT)IdentifyData,
                   sizeof (IDENTIFY_DATA) / 2);

    }

    GetStatus(BaseIoAddress1, statusByte);

    //
    // pull out any remaining bytes and throw away.
    //
    i=0;
    while ((statusByte & IDE_STATUS_DRQ) && (i < 100)) {

        READ_PORT_USHORT(BaseIoAddress1->Data);

        GetStatus(BaseIoAddress1, statusByte);

        KeStallExecutionProcessor(50);

        i++;
    }

    return TRUE;

}

ULONG
IdeSendAtaPassThroughExCommand(
    IN PVOID HwDeviceExtension, 
    IN PSCSI_REQUEST_BLOCK Srb 
    )

/*++

Routine Description:

    Programs ATA registers 

Arguments:

    HwDeviceExtension - ATAPI driver storage.
    Srb - System request block.

Return Value:

    SRB status (pending if all goes well).

--*/

{
    PHW_DEVICE_EXTENSION deviceExtension = HwDeviceExtension;
    PIDE_REGISTERS_1     baseIoAddress1  = &deviceExtension->BaseIoAddress1;
    PIDE_REGISTERS_2     baseIoAddress2  = &deviceExtension->BaseIoAddress2;
    UCHAR statusByte,errorByte;
    ULONG status;
    PIDEREGS                pIdeReg;

    pIdeReg             = (PIDEREGS) Srb->Cdb;

    ASSERT(!SRB_USES_DMA(Srb));

    //
    // select the right device
    //
    CLRMASK (pIdeReg->bDriveHeadReg, 0xb0);
    pIdeReg->bDriveHeadReg |= (UCHAR) (((Srb->TargetId & 0x1) << 4) | 0xA0);

    SelectIdeDevice(baseIoAddress1, Srb->TargetId, pIdeReg->bDriveHeadReg);

    GetStatus(baseIoAddress1, statusByte);

    WaitOnBusyUntil(baseIoAddress1, statusByte, 200);

    if (statusByte & IDE_STATUS_BUSY) {

        DebugPrint((0,
                    "ataPassThrough: Returning status 0x%x\n",
                    statusByte
                    ));

        return SRB_STATUS_BUSY;
    }

    if (pIdeReg->bReserved & ATA_PTFLAGS_STATUS_DRDY_REQUIRED) {

        if (!(statusByte & IDE_STATUS_DRDY)) {

            DebugPrint((0,
                        "ataPassThrough: DRDY not ready\n"
                        ));

            return SRB_STATUS_BUSY;
        }
    }

    //
    // Set data buffer pointer and bytes left.
    //

    deviceExtension->DataBuffer = Srb->DataBuffer;
    deviceExtension->BytesLeft = Srb->DataTransferLength;

    //
    // Indicate expecting an interrupt.
    //

    deviceExtension->ExpectingInterrupt = TRUE;
    status = SRB_STATUS_PENDING;

    if (pIdeReg->bReserved & ATA_FLAGS_48BIT_COMMAND) {
        
        if (deviceExtension->DeviceFlags[Srb->TargetId] & DFLAGS_48BIT_LBA) {

            PIDEREGS prevReg = (PIDEREGS)(&Srb->Cdb[8]);

            IdePortOutPortByte(baseIoAddress1->Error,        prevReg->bFeaturesReg);
            IdePortOutPortByte(baseIoAddress1->BlockCount,   prevReg->bSectorCountReg);
            IdePortOutPortByte(baseIoAddress1->BlockNumber,  prevReg->bSectorNumberReg);
            IdePortOutPortByte(baseIoAddress1->CylinderLow,  prevReg->bCylLowReg);
            IdePortOutPortByte(baseIoAddress1->CylinderHigh, prevReg->bCylHighReg);

        } else{

            DebugPrint((0,
                        "ataPassThrough: no 48bit support\n"
                        ));

            deviceExtension->BytesLeft = 0;

            //
            // Clear interrupt expecting flag.
            //

            deviceExtension->ExpectingInterrupt = FALSE;

            return SRB_STATUS_BUSY;
        }

    }

    IdePortOutPortByte(baseIoAddress1->Error,        pIdeReg->bFeaturesReg);
    IdePortOutPortByte(baseIoAddress1->BlockCount,   pIdeReg->bSectorCountReg);
    IdePortOutPortByte(baseIoAddress1->BlockNumber,  pIdeReg->bSectorNumberReg);
    IdePortOutPortByte(baseIoAddress1->CylinderLow,  pIdeReg->bCylLowReg);
    IdePortOutPortByte(baseIoAddress1->CylinderHigh, pIdeReg->bCylHighReg);
    IdePortOutPortByte(baseIoAddress1->Command,      pIdeReg->bCommandReg);

    if ((Srb->SrbFlags & SRB_FLAGS_DATA_OUT) &&
        !SRB_USES_DMA(Srb)) {

        ULONG byteCount;
        ULONG i;

        if (deviceExtension->BytesLeft < 
            deviceExtension->DeviceParameters[Srb->TargetId].MaxBytePerPioInterrupt) {

            byteCount = deviceExtension->BytesLeft;

        } else {

            byteCount = deviceExtension->DeviceParameters[Srb->TargetId].MaxBytePerPioInterrupt;

        }
        //
        // Wait for BSY and DRQ.
        //

        WaitOnBusyUntil(baseIoAddress1,statusByte, 500);

        if (statusByte & IDE_STATUS_BUSY) {

            DebugPrint((0,
                        "ataPassThrough: Returning BUSY status %x\n",
                        statusByte
                        ));

            deviceExtension->BytesLeft = 0;

            //
            // Clear interrupt expecting flag.
            //

            deviceExtension->ExpectingInterrupt = FALSE;

            return SRB_STATUS_BUSY;
        }

        for (i = 0; i < 1000; i++) {

            GetBaseStatus(baseIoAddress1, statusByte);

            if (statusByte & IDE_STATUS_DRQ) {
                break;
            }

            KeStallExecutionProcessor(200);
        }

        if (!(statusByte & IDE_STATUS_DRQ)) {

            DebugPrint((0,
                        "ataPassThrough: DRQ never asserted (%x)\n",
                        statusByte
                        ));

            deviceExtension->BytesLeft = 0;

            //
            // Clear interrupt expecting flag.
            //

            deviceExtension->ExpectingInterrupt = FALSE;

            return SRB_STATUS_BUSY;
        }

        //
        // Write next 256 words.
        //

        WriteBuffer(baseIoAddress1,
                    (PUSHORT)deviceExtension->DataBuffer,
                    byteCount / sizeof(USHORT));

        //
        // Adjust buffer address and words left count.
        //

        deviceExtension->BytesLeft -= byteCount;
        deviceExtension->DataBuffer += byteCount;
    }

    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\fdc\mode3fdc\desk2fdc\fdc.c ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999
Copyright (c) 1996  Colorado Software Architects

Module Name:

    fdc.c

Abstract:

    This is the NEC PD756 (aka AT, aka IS1A, aka ix86) and Intel 82077
    (aka MIPS) floppy diskette driver for NT.

Environment:

    Kernel mode only.

--*/

//
// Include files.
//

#include "stdio.h"
#include "ntddk.h"
#include "ntdddisk.h"                    // disk device driver I/O control codes
#include "ntddfdc.h"                     // fdc I/O control codes and parameters
#include <fdc_data.h>                    // this driver's data declarations
#include <flpyenbl.h>

#define MAX(a,b) ((a) > (b) ? (a) : (b))
#define MIN(a,b) ((a) > (b) ? (b) : (a))

COMMAND_TABLE CommandTable[] = {
    { 0x06, 8, 1, 7,  TRUE,  TRUE,  FDC_READ_DATA  },   // Read Data
    { 0x0C, 0, 0, 0,  FALSE, FALSE, FDC_NO_DATA    },   // Not Implemented (MIPS)
    { 0x05, 8, 1, 7,  TRUE,  TRUE,  FDC_WRITE_DATA },   // Write Data
    { 0x09, 0, 0, 0,  FALSE, FALSE, FDC_NO_DATA    },   // Not Implemented
    { 0x02, 8, 1, 7,  TRUE,  TRUE,  FDC_READ_DATA  },   // Read Track
    { 0x16, 8, 1, 7,  TRUE,  FALSE, FDC_NO_DATA    },   // Verify
    { 0x10, 0, 0, 1,  FALSE, FALSE, FDC_NO_DATA    },   // Version
    { 0x0D, 5, 1, 7,  TRUE,  TRUE,  FDC_WRITE_DATA },   // Format Track
    { 0x11, 8, 1, 7,  TRUE,  FALSE, FDC_READ_DATA  },   // Scan Equal
    { 0x19, 8, 1, 7,  TRUE,  FALSE, FDC_READ_DATA  },   // Scan Low Or Equal
    { 0x1D, 8, 1, 7,  TRUE,  FALSE, FDC_READ_DATA  },   // Scan High Or Equal
    { 0x07, 1, 0, 2,  TRUE,  TRUE,  FDC_NO_DATA    },   // Recalibrate
    { 0x08, 0, 0, 2,  FALSE, TRUE,  FDC_NO_DATA    },   // Sense Interrupt Status
    { 0x03, 2, 0, 0,  FALSE, TRUE,  FDC_NO_DATA    },   // Specify
    { 0x04, 1, 0, 1,  FALSE, TRUE,  FDC_NO_DATA    },   // Sense Drive Status
    { 0x8E, 6, 0, 0,  FALSE, FALSE, FDC_NO_DATA    },   // Drive Specification Command
    { 0x0F, 2, 0, 2,  TRUE,  TRUE,  FDC_NO_DATA    },   // Seek
    { 0x13, 3, 0, 0,  FALSE, FALSE, FDC_NO_DATA    },   // Configure
    { 0x8F, 2, 0, 2,  TRUE,  FALSE, FDC_NO_DATA    },   // Relative Seek
    { 0x0E, 0, 0, 10, FALSE, FALSE, FDC_NO_DATA    },   // Dumpreg
    { 0x0A, 1, 1, 7,  TRUE,  TRUE,  FDC_NO_DATA    },   // Read ID
    { 0x12, 1, 0, 0,  FALSE, FALSE, FDC_NO_DATA    },   // Perpendicular Mode
    { 0x14, 0, 0, 1,  FALSE, FALSE, FDC_NO_DATA    },   // Lock
    { 0x18, 0, 0, 1,  FALSE, FALSE, FDC_NO_DATA    },   // Part ID
    { 0x17, 1, 0, 1,  FALSE, FALSE, FDC_NO_DATA    },   // Powerdown Mode
    { 0x33, 1, 0, 0,  FALSE, FALSE, FDC_NO_DATA    },   // Option
    { 0x2E, 0, 0, 16, FALSE, FALSE, FDC_NO_DATA    },   // Save
    { 0x4E, 16, 0, 0, FALSE, FALSE, FDC_NO_DATA    },   // Restore
    { 0xAD, 5, 1, 7,  TRUE,  TRUE,  FDC_WRITE_DATA }    // Format And Write
};

//
// This is the actual definition of FdcDebugLevel.
// Note that it is only defined if this is a "debug"
// build.
//
#if DBG
extern ULONG FdcDebugLevel = 0;
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT,DriverEntry)
#endif

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'polF')
#endif

BOOLEAN FdcInSetupMode;

//
// Used for paging the driver.
//
ULONG PagingReferenceCount = 0;
PFAST_MUTEX PagingMutex = NULL;

ULONG NumberOfBuffers = 0;
ULONG BufferSize = 0;
ULONG Model30 = 0;
ULONG NotConfigurable = 0;

//  Feb.9.1998 KIADP011 Get base address of configuration ports
//  and device identifier
#ifdef TOSHIBAJ
ULONG   SmcConfigBase;
ULONG   SmcConfigID;
PUCHAR  TranslatedConfigBase = NULL;

#endif


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )

/*++

Routine Description:

    This routine is the driver's entry point, called by the I/O system
    to load the driver.  This routine can be called any number of times,
    as long as the IO system and the configuration manager conspire to
    give it an unmanaged controller to support at each call.  It could
    also be called a single time and given all of the controllers at
    once.

    It initializes the passed-in driver object, calls the configuration
    manager to learn about the devices that it is to support, and for
    each controller to be supported it calls a routine to initialize the
    controller (and all drives attached to it).

Arguments:

    DriverObject - a pointer to the object that represents this device
    driver.

Return Value:

    If we successfully initialize at least one drive, STATUS_SUCCESS is
    returned.

    If we don't (because the configuration manager returns an error, or
    the configuration manager says that there are no controllers or
    drives to support, or no controllers or drives can be successfully
    initialized), then the last error encountered is propogated.

--*/

{
    NTSTATUS ntStatus;

    //
    // We use this to query into the registry as to whether we
    // should break at driver entry.
    //

    RTL_QUERY_REGISTRY_TABLE paramTable[6];
    ULONG zero = 0;
    ULONG one = 1;
    ULONG debugLevel = 0;
    ULONG shouldBreak = 0;
    ULONG setupMode;
    PWCHAR path;
    UNICODE_STRING parameters;
    UNICODE_STRING systemPath;
    UNICODE_STRING identifier;
    UNICODE_STRING thinkpad, ps2e;
    ULONG pathLength;

    RtlInitUnicodeString(&parameters, L"\\Parameters");
    RtlInitUnicodeString(&systemPath,
        L"\\REGISTRY\\MACHINE\\HARDWARE\\DESCRIPTION\\System");
    RtlInitUnicodeString(&thinkpad, L"IBM THINKPAD 750");
    RtlInitUnicodeString(&ps2e, L"IBM PS2E");

    pathLength = RegistryPath->Length + parameters.Length + sizeof(WCHAR);
    if (pathLength < systemPath.Length + sizeof(WCHAR)) {
        pathLength = systemPath.Length + sizeof(WCHAR);
    }

    //
    // Since the registry path parameter is a "counted" UNICODE string, it
    // might not be zero terminated.  For a very short time allocate memory
    // to hold the registry path zero terminated so that we can use it to
    // delve into the registry.
    //
    // NOTE NOTE!!!! This is not an architected way of breaking into
    // a driver.  It happens to work for this driver because the author
    // likes to do things this way.
    //
    NumberOfBuffers = 3;
    BufferSize = 0x8000;

    if (path = ExAllocatePool(PagedPool, pathLength)) {

        RtlZeroMemory(&paramTable[0],
                      sizeof(paramTable));
        RtlZeroMemory(path, pathLength);
        RtlMoveMemory(path,
                      RegistryPath->Buffer,
                      RegistryPath->Length);

        paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name = L"BreakOnEntry";
        paramTable[0].EntryContext = &shouldBreak;
        paramTable[0].DefaultType = REG_DWORD;
        paramTable[0].DefaultData = &zero;
        paramTable[0].DefaultLength = sizeof(ULONG);
        paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name = L"DebugLevel";
        paramTable[1].EntryContext = &debugLevel;
        paramTable[1].DefaultType = REG_DWORD;
        paramTable[1].DefaultData = &zero;
        paramTable[1].DefaultLength = sizeof(ULONG);
        paramTable[2].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[2].Name = L"NumberOfBuffers";
        paramTable[2].EntryContext = &NumberOfBuffers;
        paramTable[2].DefaultType = REG_DWORD;
        paramTable[2].DefaultData = &NumberOfBuffers;
        paramTable[2].DefaultLength = sizeof(ULONG);
        paramTable[3].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[3].Name = L"BufferSize";
        paramTable[3].EntryContext = &BufferSize;
        paramTable[3].DefaultType = REG_DWORD;
        paramTable[3].DefaultData = &BufferSize;
        paramTable[3].DefaultLength = sizeof(ULONG);
        paramTable[4].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[4].Name = L"SetupDone";
        paramTable[4].EntryContext = &setupMode;
        paramTable[4].DefaultType = REG_DWORD;
        paramTable[4].DefaultData = &zero;
        paramTable[4].DefaultLength = sizeof(ULONG);

        if (!NT_SUCCESS(RtlQueryRegistryValues(
                                RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                path,
                                &paramTable[0],
                                NULL,
                                NULL))) {

            shouldBreak = 0;
            debugLevel = 0;

        }

        FdcInSetupMode = !(BOOLEAN)setupMode;

        FdcDump( FDCSHOW, ("FdcDriverEntry: FdcInSetupMode = %x\n",FdcInSetupMode) );

        if ( FdcInSetupMode ) {

            OBJECT_ATTRIBUTES keyAttributes;
            HANDLE keyHandle;
            UNICODE_STRING value;

            RtlInitUnicodeString( &value, L"SetupDone" );
            setupMode = 1;

            InitializeObjectAttributes( &keyAttributes,
                                        RegistryPath,
                                        OBJ_CASE_INSENSITIVE,
                                        NULL,
                                        NULL );

            ntStatus = ZwOpenKey( &keyHandle,
                                  KEY_ALL_ACCESS,
                                  &keyAttributes );

            if ( NT_SUCCESS(ntStatus) ) {

                FdcDump( FDCSHOW, ("FdcDriverEntry: Set SetupMode Value in Registry\n") );

                ZwSetValueKey( keyHandle,
                               &value,
                               0,
                               REG_DWORD,
                               &setupMode,
                               sizeof(ULONG) );

                ZwClose( keyHandle);
            }
        }

        //
        // Determine whether or not this type of system has a
        // model 30 floppy controller.
        //

        RtlZeroMemory(paramTable, sizeof(paramTable));
        RtlZeroMemory(path, pathLength);
        RtlMoveMemory(path,
                      systemPath.Buffer,
                      systemPath.Length);


        RtlZeroMemory(&identifier, sizeof(UNICODE_STRING));
        paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT |
                              RTL_QUERY_REGISTRY_REQUIRED;
        paramTable[0].Name = L"Identifier";
        paramTable[0].EntryContext = &identifier;

        if (NT_SUCCESS(RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                              path,
                                              paramTable,
                                              NULL,
                                              NULL))) {


            if (identifier.Length == thinkpad.Length &&
                RtlCompareMemory(identifier.Buffer, thinkpad.Buffer,
                                 thinkpad.Length) == thinkpad.Length) {

                Model30 = 1;

            } else if (identifier.Length == ps2e.Length &&
                       RtlCompareMemory(identifier.Buffer, ps2e.Buffer,
                                        ps2e.Length) == ps2e.Length) {

                Model30 = 1;
            } else {
                Model30 = 0;
            }
        } else {
            Model30 = 0;
        }

        //
        // This part gets from the parameters part of the registry
        // to see if the controller configuration needs to be disabled.
        // Doing this lets SMC 661, and 662 work.  On hardware that
        // works normally, this change will show a slowdown of up
        // to 40%.  So defining this variable is not recommended
        // unless things don't work without it.
        //
        //
        // Also check the model30 value in the parameters section
        // that is used to override the decision above.
        //

        RtlZeroMemory(&paramTable[0],
                      sizeof(paramTable));
        RtlZeroMemory(path,
                      RegistryPath->Length+parameters.Length+sizeof(WCHAR));
        RtlMoveMemory(path,
                      RegistryPath->Buffer,
                      RegistryPath->Length);
        RtlMoveMemory((PCHAR) path + RegistryPath->Length,
                      parameters.Buffer,
                      parameters.Length);

        paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name = L"NotConfigurable";
        paramTable[0].EntryContext = &NotConfigurable;
        paramTable[0].DefaultType = REG_DWORD;
        paramTable[0].DefaultData = &zero;
        paramTable[0].DefaultLength = sizeof(ULONG);

        paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name = L"Model30";
        paramTable[1].EntryContext = &Model30;
        paramTable[1].DefaultType = REG_DWORD;
        paramTable[1].DefaultData = Model30 ? &one : &zero;
        paramTable[1].DefaultLength = sizeof(ULONG);

        if (!NT_SUCCESS(RtlQueryRegistryValues(
                                RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                path,
                                &paramTable[0],
                                NULL,
                                NULL))) {

            NotConfigurable = 0;
        }

#ifdef TOSHIBAJ
        // Feb.9.1998 KIADP011 Get base address and identifier
        RtlZeroMemory(&paramTable[0],
                      sizeof(paramTable));
        paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[0].Name = L"ConfigurationBase";
        paramTable[0].EntryContext = &SmcConfigBase;
        paramTable[0].DefaultType = REG_DWORD;
        paramTable[0].DefaultData = &zero;
        paramTable[0].DefaultLength = sizeof(ULONG);
        paramTable[1].Flags = RTL_QUERY_REGISTRY_DIRECT;
        paramTable[1].Name = L"ControllerID";
        paramTable[1].EntryContext = &SmcConfigID;
        paramTable[1].DefaultType = REG_DWORD;
        paramTable[1].DefaultData = &zero;
        paramTable[1].DefaultLength = sizeof(ULONG);

        if (!NT_SUCCESS(RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                               path,
                                               &paramTable[0],
                                               NULL,
                                               NULL))) {
            SmcConfigBase = 0;
            SmcConfigID = 0;
        }

#endif

    }

    //
    // We don't need that path anymore.
    //
    if (path) {
        ExFreePool(path);
    }

#if DBG
    FdcDebugLevel = debugLevel;
#endif
    if (shouldBreak) {
        DbgBreakPoint();
    }


    FdcDump(FDCSHOW,
               ("Fdc: DriverEntry...\n"));


    //
    // Initialize the driver object with this driver's entry points.
    //

    DriverObject->MajorFunction[IRP_MJ_CREATE] =
    DriverObject->MajorFunction[IRP_MJ_CLOSE]  = FdcCreateClose;
    DriverObject->MajorFunction[IRP_MJ_POWER]  = FdcPower;
    DriverObject->MajorFunction[IRP_MJ_PNP]    = FdcPnp;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] =
                                                 FdcInternalDeviceControl;

    DriverObject->DriverStartIo = FdcStartIo;
    DriverObject->DriverExtension->AddDevice = FdcAddDevice;

    FDC_PAGE_INITIALIZE_DRIVER_WITH_MUTEX;

    return STATUS_SUCCESS;
}

NTSTATUS
FdcAddDevice(
    IN      PDRIVER_OBJECT DriverObject,
    IN OUT  PDEVICE_OBJECT BusPhysicalDeviceObject
    )
/*++
Routine Description.

    A floppy controller device has been enumerated by the root/firmware
    enumerator.  Create an FDO and attach it to this PDO.

Arguments:

    BusDeviceObject - Device object representing the floppy controller.  That
    to which we attach a new FDO.

    DriverObject - This driver.

Return Value:

    STATUS_SUCCESS if the device is successfully created.

--*/
{

    NTSTATUS            ntStatus = STATUS_SUCCESS;
    PDEVICE_OBJECT      deviceObject;
    PFDC_FDO_EXTENSION  fdoExtension;
    UNICODE_STRING      deviceName;

    FdcDump( FDCSHOW, ("FdcAddDevice:  CreateDeviceObject\n"));

    //
    //  Create the FDO device.
    //
    //  JB:TBD - Still need to resolve device naming.  For the time being,
    //  this device is unnamed (per the gameport example).
    //
    ntStatus = IoCreateDevice( DriverObject,
                               sizeof( FDC_FDO_EXTENSION ),
                               NULL,
                               FILE_DEVICE_CONTROLLER,
                               FILE_DEVICE_SECURE_OPEN,
                               TRUE,
                               &deviceObject );

    if ( NT_SUCCESS(ntStatus) ) {

        //
        //  Initialize the fdoExtension for this device.
        //
        fdoExtension = deviceObject->DeviceExtension;

        fdoExtension->IsFDO        = TRUE;
        fdoExtension->DriverObject = DriverObject;
        fdoExtension->Self         = deviceObject;
        fdoExtension->OutstandingRequests = 1;
        fdoExtension->TapeEnumerationPending = FALSE;

        KeInitializeEvent( &fdoExtension->TapeEnumerationEvent,
                           SynchronizationEvent,
                           TRUE );

        KeInitializeEvent( &fdoExtension->RemoveEvent,
                           SynchronizationEvent,
                           FALSE );

        InitializeListHead( &fdoExtension->PDOs );

        //
        //  Initialize a queue for power management.
        //
        InitializeListHead( &fdoExtension->PowerQueue );
        KeInitializeSpinLock( &fdoExtension->PowerQueueSpinLock );

        //
        //  Initialize a variable to hold the last motor settle
        //  time that we have seen.  We will use this when we turn
        //  the floppy motor back on after a power event.
        //
        fdoExtension->LastMotorSettleTime.QuadPart = 0;

        //
        // Set the PDO for use with PlugPlay functions
        //
        fdoExtension->UnderlyingPDO = BusPhysicalDeviceObject;

        //
        //  Now attach to the PDO so that we have a target for PnP and
        //  Power irps that we need to pass on.
        //
        FdcDump( FDCSHOW, ("AddDevice: Attaching %p to %p\n",
                           deviceObject,
                           BusPhysicalDeviceObject));

        fdoExtension->TargetObject = IoAttachDeviceToDeviceStack( deviceObject,
                                                                  BusPhysicalDeviceObject );

        deviceObject->Flags |= DO_DIRECT_IO;
        deviceObject->Flags |= DO_POWER_PAGABLE;

        if ( deviceObject->AlignmentRequirement < FILE_WORD_ALIGNMENT ) {

            deviceObject->AlignmentRequirement = FILE_WORD_ALIGNMENT;
        }

        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    }

    return ntStatus;
}

NTSTATUS
FdcPnp (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Determine if this Pnp request is directed towards an FDO or a PDO and
    pass the Irp on the the appropriate routine.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFDC_EXTENSION_HEADER extensionHeader;
    KIRQL oldIrq;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    extensionHeader = (PFDC_EXTENSION_HEADER)DeviceObject->DeviceExtension;

    //
    // Lock down the driver code in memory if it is not already.
    //

    FDC_PAGE_RESET_DRIVER_WITH_MUTEX;

    if ( extensionHeader->IsFDO ) {

        ntStatus = FdcFdoPnp( DeviceObject, Irp );

    } else {

        ntStatus = FdcPdoPnp( DeviceObject, Irp );
    }

    //
    //  Page out the driver if it is not busy elsewhere.
    //

    FDC_PAGE_ENTIRE_DRIVER_WITH_MUTEX;

    return ntStatus;
}

NTSTATUS
FdcFdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O system to perform Plug-and-Play
    functions.  This routine handles messages to the FDO which is part
    of the bus DevNode.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    STATUS_SUCCESS or STATUS_PENDING if recognized I/O control code,
    STATUS_INVALID_DEVICE_REQUEST otherwise.

--*/
{
    PFDC_FDO_EXTENSION fdoExtension;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpSp;
    KEVENT doneEvent;
    fdoExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ntStatus = STATUS_SUCCESS;

    //
    //  Incerement our queued request counter.
    //
    InterlockedIncrement( &fdoExtension->OutstandingRequests);

    if ( fdoExtension->Removed ) {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = STATUS_DELETE_PENDING;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        if ( InterlockedDecrement( &fdoExtension->OutstandingRequests ) == 0 ) {
            KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
        }
        return STATUS_DELETE_PENDING;
    }

    switch (irpSp->MinorFunction) {

    case IRP_MN_FILTER_RESOURCE_REQUIREMENTS:

        ntStatus = FdcFilterResourceRequirements( DeviceObject, Irp );

        break;

    case IRP_MN_START_DEVICE:

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_START_DEVICE - Irp: %p\n", Irp) );

        //
        // First we must pass this Irp on to the underlying PDO.
        //
        KeInitializeEvent( &doneEvent, NotificationEvent, FALSE );

        IoCopyCurrentIrpStackLocationToNext( Irp );

        IoSetCompletionRoutine( Irp,
                                FdcPnpComplete,
                                &doneEvent,
                                TRUE,
                                TRUE,
                                TRUE );

        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        if ( ntStatus == STATUS_PENDING ) {

            ntStatus = KeWaitForSingleObject( &doneEvent,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              NULL );

            ASSERT( ntStatus == STATUS_SUCCESS );

            ntStatus = Irp->IoStatus.Status;
        }
        //
        //  Try to start the floppy disk controller.
        //
        if ( NT_SUCCESS(ntStatus) ) {

            ntStatus = FdcStartDevice( DeviceObject, Irp );
        }

        Irp->IoStatus.Status = ntStatus;

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_START_DEVICE %08x %08x\n",Irp->IoStatus.Status,Irp->IoStatus.Information) );
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_QUERY_REMOVE_DEVICE - Irp: %p\n", Irp) );

        //
        //  If the controller is in use (acquired) then we will not allow
        //  the device to be removed.
        //

        KeWaitForSingleObject( &fdoExtension->TapeEnumerationEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL );

        if ( fdoExtension->ControllerInUse ||
             fdoExtension->TapeEnumerationPending ) {

            ntStatus = STATUS_DEVICE_BUSY;
            Irp->IoStatus.Status = ntStatus;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );

        } else {

            //
            //  If the controller was not in use we will set it so now
            //  so that any other attempted accesses to the fdc will have
            fdoExtension->ControllerInUse = TRUE;
            IoSkipCurrentIrpStackLocation( Irp );
            ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );
        }
        break;

    case IRP_MN_REMOVE_DEVICE:

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_REMOVE_DEVICE - Irp: %p\n", Irp) );

        IoSkipCurrentIrpStackLocation( Irp );
        IoCallDriver( fdoExtension->TargetObject, Irp );

        if ( fdoExtension->FdcEnablerFileObject != NULL ) {
            ObDereferenceObject( fdoExtension->FdcEnablerFileObject );
        }

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_REMOVE_DEVICE - Detach from device %p\n", fdoExtension->TargetObject) );
        IoDetachDevice( fdoExtension->TargetObject );

        //
        //  Close the named synchronization event we opened at start time.
        //
        ZwClose( fdoExtension->AcquireEventHandle );

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_REMOVE_DEVICE - Delete device %p\n", fdoExtension->Self) );
        IoDeleteDevice( fdoExtension->Self );

        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_CANCEL_REMOVE_DEVICE - Irp: %p\n", Irp) );
        fdoExtension->ControllerInUse = FALSE;

        IoSkipCurrentIrpStackLocation( Irp );
        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_QUERY_STOP_DEVICE - Irp: %p\n", Irp) );

        if ( fdoExtension->ControllerInUse ||
             fdoExtension->TapeEnumerationPending ) {

            ntStatus = STATUS_DEVICE_BUSY;
            Irp->IoStatus.Status = ntStatus;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );

        } else {

            fdoExtension->ControllerInUse = TRUE;
            IoSkipCurrentIrpStackLocation( Irp );
            ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );
        }

        break;

    case IRP_MN_STOP_DEVICE:

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_STOP_DEVICE - Irp: %p\n", Irp) );

        IoSkipCurrentIrpStackLocation( Irp );
        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_CANCEL_STOP_DEVICE - Irp: %p\n", Irp) );

        fdoExtension->ControllerInUse = FALSE;
        IoSkipCurrentIrpStackLocation( Irp );
        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        break;

    case IRP_MN_QUERY_DEVICE_RELATIONS:

        FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_QUERY_DEVICE_RELATIONS - Irp: %p\n", Irp) );

        ntStatus = FdcQueryDeviceRelations( DeviceObject, Irp );

        break;

    default:

        FdcDump( FDCSHOW, ("FdcFdoPnp: Unsupported PNP Request %x\n",irpSp->MinorFunction) );

        IoSkipCurrentIrpStackLocation( Irp );
        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        break;
    }

    if ( InterlockedDecrement( &fdoExtension->OutstandingRequests ) == 0 ) {
        KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
    }
    return ntStatus;
}

NTSTATUS
FdcPnpComplete (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN PVOID            Context
    )
/*++
Routine Description:

    A completion routine for use when calling the lower device objects to
    which our bus (FDO) is attached.  We use this completion routine when
    we must post-process the irp after we are sure that the PDO is done
    with it.

Arguments:

    DeviceObject - a pointer to our FDO
    Irp - a pointer to the completed Irp
    Context - an event that we will set indicating the irp is completed.

Return Value:

    STATUS_MORE_PROCESSING_REQUIRED so that control will be returned to
    our calling routine.

--*/
{

    if ( Irp->PendingReturned ) {

        IoMarkIrpPending( Irp );
    }

    KeSetEvent( (PKEVENT)Context, 1, FALSE );

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
FdcPdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O system to perform Plug-and-Play
    functions.  This routine handles messages to the PDO which is part
    of the bus DevNode.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/
{
    PFDC_PDO_EXTENSION pdoExtension;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpSp;
    KEVENT doneEvent;

    pdoExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ntStatus = Irp->IoStatus.Status;

    switch ( irpSp->MinorFunction ) {

    case IRP_MN_QUERY_CAPABILITIES: {

        PDEVICE_CAPABILITIES deviceCapabilities;

        FdcDump( FDCSHOW, ("FdcPdoPnp: IRP_MN_QUERY_CAPABILITIES - Irp: %p\n", Irp) );

        deviceCapabilities = irpSp->Parameters.DeviceCapabilities.Capabilities;

        //
        //  Fill in the device capabilities structure and return it.  The
        //  capabilities structure is in irpSp->Parameters.DeviceCapabilities.Capabilities;
        //
        //  The size and Version should already be set appropraitely.
        //
        ASSERT( deviceCapabilities->Version == 1 );
        ASSERT( deviceCapabilities->Size == sizeof(DEVICE_CAPABILITIES) );

        //
        //  JB:TBD - not sure how to set these flags.
        //
        deviceCapabilities->LockSupported = FALSE;  //  No locking.
        deviceCapabilities->EjectSupported = FALSE; //  No ejection mechanism.
        deviceCapabilities->Removable = FALSE;      //  Device is not removable (what about external laptop drives?)
        deviceCapabilities->DockDevice = FALSE;     //  Device is not a docking device (this probably should be TRUE)
        deviceCapabilities->UniqueID = FALSE;       //  ???
        deviceCapabilities->SilentInstall = TRUE;   //  ???
        deviceCapabilities->RawDeviceOK = FALSE;    //  ???

//        deviceCapabilities->Address;
//        deviceCapabilities->UINumber;
//
//        deviceCapabilities->DeviceState[PowerSystemMaximum];
//        deviceCapabilities->SystemWake;
//        deviceCapabilities->DeviceWake;
//
//        deviceCapabilities->D1Latency;
//        deviceCapabilities->D2Latency;
//        deviceCapabilities->D3Latency;

        ntStatus = STATUS_SUCCESS;
        break;
    }

    case IRP_MN_QUERY_ID:

        //
        // Query the IDs of the device
        //
        FdcDump( FDCSHOW, ("FdcPdoPnp: IRP_MN_QUERY_ID - Irp: %p\n", Irp) );
        FdcDump( FDCSHOW, ("FdcPdoPnp:   IdType %x\n", irpSp->Parameters.QueryId.IdType) );

        ntStatus = STATUS_SUCCESS;

        switch ( irpSp->Parameters.QueryId.IdType) {

        case BusQueryDeviceID:
            // return a WCHAR (null terminated) string describing the device
            // For symplicity we make it exactly the same as the Hardware ID.
        case BusQueryHardwareIDs: {

            UCHAR idString[25];
            ANSI_STRING ansiId;
            UNICODE_STRING uniId;
            PWCHAR buffer;
            ULONG length;

            RtlZeroMemory( idString, 25 );

            switch ( pdoExtension->DeviceType ) {

            case FloppyDiskDevice:

                // return a multi WCHAR (null terminated) string (null terminated)
                // array for use in matching hardare ids in inf files;
                //
                sprintf( idString, "FDC\\PNP07%02X", pdoExtension->Instance );

                break;

            case FloppyTapeDevice:

                //
                //  Examine the tape vendor id and build the id string
                //  appropriately.
                //
                if ( pdoExtension->TapeVendorId == -1 ) {

                    strcpy( idString, "FDC\\QICLEGACY" );

                } else {

                    sprintf( idString, "FDC\\QIC%04X", (USHORT)pdoExtension->TapeVendorId );

                }
                break;

            case FloppyControllerDevice:

                sprintf( idString, "FDC\\ENABLER" );

                break;
            }

            //
            //  Allocate enough memory for the string and 2 null characters since
            //  this is a multisz type.
            //
            length = strlen( idString ) * sizeof (WCHAR) + 2 * sizeof(WCHAR);

            buffer = ExAllocatePool (PagedPool, length);

            if ( buffer == NULL ) {

                ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            RtlZeroMemory( buffer, length );

            ansiId.Length = ansiId.MaximumLength = (USHORT) strlen( idString );
            ansiId.Buffer = idString;

            uniId.Length = 0;
            uniId.MaximumLength = (USHORT)length;
            uniId.Buffer = buffer;

            RtlAnsiStringToUnicodeString( &uniId, &ansiId, FALSE );

            Irp->IoStatus.Information = (UINT_PTR) buffer;

            break;
        }

        case BusQueryCompatibleIDs:{

            PWCHAR buffer = NULL;
            USHORT length;

            //
            // Build an instance ID.  This is what PnP uses to tell if it has
            // seen this thing before or not.  Build it from the first hardware
            // id and the port number.
            //
            switch ( pdoExtension->DeviceType ) {

            case FloppyDiskDevice:

                length = FDC_FLOPPY_COMPATIBLE_IDS_LENGTH * sizeof (WCHAR);

                buffer = ExAllocatePool( PagedPool, length );

                if ( buffer == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    RtlCopyMemory( buffer, FDC_FLOPPY_COMPATIBLE_IDS, length );
                    buffer[7] = L'0' + pdoExtension->Instance;
                }

                break;

            case FloppyTapeDevice:

                if ( pdoExtension->TapeVendorId != -1 ) {

                    length = FDC_TAPE_COMPATIBLE_IDS_LENGTH * sizeof (WCHAR);

                    buffer = ExAllocatePool( PagedPool, length );

                    if ( buffer == NULL ) {

                        ntStatus = STATUS_INSUFFICIENT_RESOURCES;

                    } else {

                        RtlCopyMemory( buffer, FDC_TAPE_COMPATIBLE_IDS, length );
                    }
                }
                break;

            case FloppyControllerDevice:

                length = FDC_CONTROLLER_COMPATIBLE_IDS_LENGTH * sizeof (WCHAR);

                buffer = ExAllocatePool( PagedPool, length );

                if ( buffer == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    RtlCopyMemory( buffer, FDC_CONTROLLER_COMPATIBLE_IDS, length );
                }

                break;
            }

            Irp->IoStatus.Information = (UINT_PTR)buffer;
            break;
        }

        case BusQueryInstanceID: {

            PWCHAR idString = L"0";
            PWCHAR buffer;

            //
            // Build an instance ID.  This is what PnP uses to tell if it has
            // seen this thing before or not.  Build it from the first hardware
            // id and the port number.

            buffer = ExAllocatePool( NonPagedPool, 4 );

            if ( buffer == NULL ) {

                ntStatus = STATUS_INSUFFICIENT_RESOURCES;

            } else {

                buffer[0] = L'0' + pdoExtension->Instance;
                buffer[1] = 0;

                Irp->IoStatus.Information = (UINT_PTR)buffer;
            }

            break;
        }
        }

        break;

    case IRP_MN_START_DEVICE:

        FdcDump( FDCSHOW, ("FdcPdoPnp: IRP_MN_START_DEVICE - Irp: %p\n", Irp) );
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_STOP_DEVICE:

        FdcDump( FDCSHOW, ("FdcPdoPnp: IRP_MN_QUERY_STOP_DEVICE - Irp: %p\n", Irp) );
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_STOP_DEVICE:

        FdcDump( FDCSHOW, ("FdcPdoPnp: IRP_MN_STOP_DEVICE - Irp: %p\n", Irp) );
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_STOP_DEVICE:

        FdcDump( FDCSHOW, ("FdcPdoPnp: IRP_MN_CANCEL_STOP_DEVICE - Irp: %p\n", Irp) );
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_QUERY_REMOVE_DEVICE:

        FdcDump( FDCSHOW, ("FdcPdoPnp: IRP_MN_QUERY_REMOVE_DEVICE - Irp: %p\n", Irp) );
        ntStatus = STATUS_DEVICE_BUSY;
        break;

    case IRP_MN_REMOVE_DEVICE:

        FdcDump( FDCSHOW, ("FdcPdoPnp: IRP_MN_REMOVE_DEVICE - Irp: %p\n", Irp) );
        pdoExtension->Removed = TRUE;
        IoDeleteDevice( DeviceObject );
        ntStatus = STATUS_SUCCESS;
        break;

    case IRP_MN_CANCEL_REMOVE_DEVICE:

        FdcDump( FDCSHOW, ("FdcPdoPnp: IRP_MN_CANCEL_REMOVE_DEVICE - Irp: %p\n", Irp) );
        ntStatus = STATUS_SUCCESS;
        break;

    default:

        FdcDump( FDCSHOW, ("FdcPdoPnp: Unsupported PNP Request %x\n",irpSp->MinorFunction) );

        // this is a leaf node
        // status = STATUS_NOT_IMPLEMENTED
        // For PnP requests to the PDO that we do not understand we should
        // return the IRP WITHOUT setting the status or information fields.
        // They may have already been set by a filter (eg acpi).

        break;
    }

    Irp->IoStatus.Status = ntStatus;
    FdcDump( FDCSHOW, ("FdcPdoPnp: Return Status - %08x\n", ntStatus) );
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return ntStatus;
}

NTSTATUS
FdcPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine is called by the I/O system to perform Power functions

Arguments:

    DeviceObject - a pointer to the object that represents the device.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/
{
    PFDC_FDO_EXTENSION fdoExtension;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PIO_STACK_LOCATION irpSp;
    KIRQL oldIrql;
    KEVENT doneEvent;

    fdoExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    FdcDump( FDCSHOW, ("FdcPower:\n"));

    if ( fdoExtension->IsFDO ) {

        if ( fdoExtension->Removed ) {

            ntStatus = STATUS_DELETE_PENDING;
            PoStartNextPowerIrp( Irp );
            Irp->IoStatus.Information = 0;
            Irp->IoStatus.Status = ntStatus;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );

        } else {

            switch ( irpSp->MinorFunction ) {

            case IRP_MN_WAIT_WAKE:
            case IRP_MN_POWER_SEQUENCE:
            case IRP_MN_QUERY_POWER:

                //
                //  Just forward this irp to the underlying device.
                //
                PoStartNextPowerIrp( Irp );
                IoSkipCurrentIrpStackLocation( Irp );
                ntStatus = PoCallDriver(fdoExtension->TargetObject, Irp );

                break;

            case IRP_MN_SET_POWER:

                //
                // Lock down the driver code in memory if it is not already.
                //

                FDC_PAGE_RESET_DRIVER_WITH_MUTEX;

                if ( irpSp->Parameters.Power.Type == SystemPowerState ) {

                    //
                    //  If we are transitioning to a 'sleep' state start queueing
                    //  irps.
                    //
                    if ( fdoExtension->CurrentPowerState <= PowerSystemWorking &&
                         irpSp->Parameters.Power.State.SystemState > PowerSystemWorking ) {

                        //
                        //  If the device queue is not empty, wait for it now.
                        //
                        fdoExtension->CurrentPowerState = irpSp->Parameters.Power.State.SystemState;

//                        KeWaitForSingleObject( &fdoExtension->RemoveEvent,
//                                               Executive,
//                                               KernelMode,
//                                               FALSE,
//                                               NULL );

                        //
                        //  Make sure that the motors are turned off
                        //
                        if (!IsNEC_98) {
                            WRITE_CONTROLLER(
                                fdoExtension->ControllerAddress.DriveControl,
                                (UCHAR)(fdoExtension->DriveControlImage & ~DRVCTL_MOTOR_MASK) );
                        } // (!IsNEC_98)

                        //
                        //  Now forward this irp to the underlying PDO.
                        //
                        PoStartNextPowerIrp( Irp );
                        IoSkipCurrentIrpStackLocation( Irp );
                        ntStatus = PoCallDriver(fdoExtension->TargetObject, Irp );

                    //
                    //  Otherwise, if we are transitioning from a non-working state
                    //  back to a working state turn the motor back on if it was on.
                    //
                    } else if ( fdoExtension->CurrentPowerState > PowerSystemWorking &&
                                irpSp->Parameters.Power.State.SystemState <= PowerSystemWorking ) {

                        //
                        // Pass this irp down to the PDO before proceeding.
                        //
                        KeInitializeEvent( &doneEvent, NotificationEvent, FALSE );

                        IoCopyCurrentIrpStackLocationToNext(Irp);

                        IoSetCompletionRoutine( Irp,
                                                FdcPnpComplete,
                                                &doneEvent,
                                                TRUE,
                                                TRUE,
                                                TRUE );

                        ntStatus = PoCallDriver( fdoExtension->TargetObject, Irp );

                        if ( ntStatus == STATUS_PENDING ) {

                            KeWaitForSingleObject( &doneEvent, Executive, KernelMode, FALSE, NULL );
                        }

                        if ( fdoExtension->DriveControlImage & DRVCTL_MOTOR_MASK ) {

                            WRITE_CONTROLLER(
                                fdoExtension->ControllerAddress.DriveControl,
                                fdoExtension->DriveControlImage );

                            if ( fdoExtension->LastMotorSettleTime.QuadPart > 0) {

                                KeDelayExecutionThread( KernelMode,
                                                        FALSE,
                                                        &fdoExtension->LastMotorSettleTime );
                            }
                        }

                        fdoExtension->CurrentPowerState = irpSp->Parameters.Power.State.SystemState;

                        //
                        //  Set a flag to simulate a disk change event so that
                        //  we will be sure to touch the floppy drive hardware
                        //  the next time it is accessed in case it was removed.
                        //
                        fdoExtension->WakeUp = TRUE;

                        PoStartNextPowerIrp( Irp );
                        IoCompleteRequest( Irp, IO_NO_INCREMENT );

                    } else {
                        //
                        //  We must just be changing non-working states.  We
                        //  ignore this activity but pass the irp on to the
                        //  underlying device.
                        //
                        PoStartNextPowerIrp( Irp );
                        IoSkipCurrentIrpStackLocation( Irp );
                        ntStatus = PoCallDriver(fdoExtension->TargetObject, Irp );
                    }

                } else {
                    //
                    //  We only handle system power states so if this is a
                    //  device state irp just forward it to the underlying
                    //  device.
                    //
                    PoStartNextPowerIrp( Irp );
                    IoSkipCurrentIrpStackLocation( Irp );
                    ntStatus = PoCallDriver(fdoExtension->TargetObject, Irp );
                }

                //
                //  Page out the driver if it is not busy elsewhere.
                //

                FDC_PAGE_ENTIRE_DRIVER_WITH_MUTEX;

                break;
            }
        }

    } else {

        //
        //  We are not yet doing any power management on the floppy controller.
        //
        switch (irpSp->MinorFunction) {
        case IRP_MN_WAIT_WAKE:
            break;

        case IRP_MN_POWER_SEQUENCE:
            break;

        case IRP_MN_SET_POWER:
            break;

        case IRP_MN_QUERY_POWER:
            break;
        }

        PoStartNextPowerIrp( Irp );
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return ntStatus;
}

NTSTATUS
FdcStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine attempts to start the floppy controller device.  Starting
    the floppy controller consists primarily of resetting it and configuring
    it, mostly just to make sure that it is there.

Arguments:

    DeviceObject - a pointer to the device object being started.
    Irp - a pointer to the start device Irp.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFDC_FDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpSp;

    BOOLEAN foundPortA = FALSE;
    BOOLEAN foundPortB = FALSE;
    BOOLEAN foundDma = FALSE;
    BOOLEAN foundInterrupt = FALSE;
    ULONG currentBase = 0xFFFFFFFF;

    PCM_RESOURCE_LIST translatedResources;
    PCM_FULL_RESOURCE_DESCRIPTOR fullList;
    PCM_PARTIAL_RESOURCE_LIST partialList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partial;
    ULONG i;
    ULONG startOffset;
    ULONG currentOffset;

    UCHAR ioPortMap;

#ifdef TOSHIBAJ
    BOOLEAN foundConfigIndex = FALSE;
    BOOLEAN foundConfigData = FALSE;
#endif

    fdoExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    //  Ask the PDO if it is a tape enabler device and, if so, what
    //  is the enabler device object.
    //
    FdcGetEnablerDevice( fdoExtension );

    if ( fdoExtension->FdcEnablerSupported ) {

        INTERFACE_TYPE InterfaceType;

        //
        //  This is a tape enabler card so we need to get the resources
        //  'the old-fashinoed way'.
        //
        for ( InterfaceType = 0;
              InterfaceType < MaximumInterfaceType;
              InterfaceType++ ) {

            CONFIGURATION_TYPE Dc = DiskController;

            ntStatus = IoQueryDeviceDescription( &InterfaceType,
                                                 NULL,
                                                 &Dc,
                                                 NULL,
                                                 NULL,
                                                 NULL,
                                                 FdcFdoConfigCallBack,
                                                 fdoExtension );

            if (!NT_SUCCESS(ntStatus) && (ntStatus != STATUS_OBJECT_NAME_NOT_FOUND)) {

                return ntStatus;
            }
        }

        if ( fdoExtension->FdcEnablerDeviceObject == NULL ) {

            ntStatus = STATUS_OBJECT_NAME_NOT_FOUND;

        } else {

            ntStatus = STATUS_SUCCESS;
        }

    } else {

        //
        //  Now that the PDO is done with the Irp we can have our way with
        //  it.
        //
        FdcDump( FDCSHOW, ("AllocatedResources = %08x\n",irpSp->Parameters.StartDevice.AllocatedResources));
        FdcDump( FDCSHOW, ("AllocatedResourcesTranslated = %08x\n",irpSp->Parameters.StartDevice.AllocatedResourcesTranslated));

        if ( irpSp->Parameters.StartDevice.AllocatedResources == NULL ||
             irpSp->Parameters.StartDevice.AllocatedResourcesTranslated == NULL ) {

            return STATUS_INSUFFICIENT_RESOURCES;
        }

        //
        //  Set up the resource information that we will use to access the
        //  controller hardware.  We always expect only 1 full set of resources.
        //  In that list we expect a DMA channel, an Interrupt vector, and 2 I/O Port
        //  ranges.  If we don't see all the required resources we will woof.
        //
        translatedResources = irpSp->Parameters.StartDevice.AllocatedResourcesTranslated;

        ASSERT( translatedResources->Count == 1 );

        fullList = &translatedResources->List[0];
        partialList = &translatedResources->List[0].PartialResourceList;

        //
        //  Enumerate the list of resources, adding them into our context as we go.
        //
        RtlZeroMemory( &fdoExtension->ControllerAddress, sizeof(CONTROLLER) );

        for ( i = 0; i < partialList->Count; i++ ) {

            partial = &partialList->PartialDescriptors[i];

            switch ( partial->Type ) {

            case CmResourceTypePort: {

                if (IsNEC_98) {
                    if ( partial->u.Port.Length == 1 ) {
                        if (!fdoExtension->ControllerAddress.Status) {
                            fdoExtension->ControllerAddress.Status
                                        = (PUCHAR)partial->u.Port.Start.LowPart;
                        } else if (!fdoExtension->ControllerAddress.Fifo) {
                            fdoExtension->ControllerAddress.Fifo
                                        = (PUCHAR)partial->u.Port.Start.LowPart;
                        } else if (!fdoExtension->ControllerAddress.DriveControl) {
                            fdoExtension->ControllerAddress.DriveControl
                                        = (PUCHAR)partial->u.Port.Start.LowPart;
                        } else if (!fdoExtension->ControllerAddress.ModeChange) {
                            fdoExtension->ControllerAddress.ModeChange
                                        = (PUCHAR)partial->u.Port.Start.LowPart;
                        } else if (!fdoExtension->ControllerAddress.ModeChangeEx) {
                            fdoExtension->ControllerAddress.ModeChangeEx
                                        = (PUCHAR)partial->u.Port.Start.LowPart;
                        }
                    }

                    break;
                }

                //
                //  If we get a base address that is lower than anything we have seen
                //  before, we assume that we have been working with aliased addresses
                //  and start over with the new base address.
                //
                if ( (partial->u.Port.Start.LowPart & 0xFFFFFFF8) < currentBase ) {

#ifdef TOSHIBAJ
                    // Skip the descriptor including config ports only.
                    if ( !TranslatedConfigBase
                      || ((partial->u.Port.Start.LowPart & 0xFFFFFFF8) != (ULONG)TranslatedConfigBase)
                      || ((partial->u.Port.Start.LowPart & 0x7) + partial->u.Port.Length > 2) ) {
                        RtlZeroMemory( &fdoExtension->ControllerAddress, sizeof(CONTROLLER) );
                        currentBase = partial->u.Port.Start.LowPart & 0xFFFFFFF8;
                        FdcDump( FDCINFO,
                            ("FdcStartDevice: Current base %04x\n", currentBase) );
                    }
#else
                    RtlZeroMemory( &fdoExtension->ControllerAddress, sizeof(CONTROLLER) );
                    currentBase = partial->u.Port.Start.LowPart & 0xFFFFFFF8;
#endif
                }

                //
                //  We only use resources that are associated with the current (lowest)
                //  base addressed.  All others are assumed to be aliased and are not
                //  used.
                //
                if ( (partial->u.Port.Start.LowPart & 0xFFFFFFF8) == currentBase ) {

                    FdcDump( FDCINFO,
                             ("FdcStartDevice: Adding - %04x, Length - %04x\n",
                             partial->u.Port.Start.LowPart,
                             partial->u.Port.Length) );

                    startOffset = partial->u.Port.Start.LowPart & 0x07;

                    if ( (partial->Flags & CM_RESOURCE_PORT_IO) == CM_RESOURCE_PORT_MEMORY ) {

                        fdoExtension->ControllerAddress.Address[startOffset] =
                            MmMapIoSpace( partial->u.Port.Start,
                                          partial->u.Port.Length,
                                          FALSE );

                        FdcDump( FDCINFO, ("FdcStartDevice: Mapped IoPort\n") );

                    } else {

                        fdoExtension->ControllerAddress.Address[startOffset] = (PUCHAR)partial->u.Port.Start.LowPart;
                    }

                    currentOffset = 1;
                    while ( currentOffset < partial->u.Port.Length ) {

                        fdoExtension->ControllerAddress.Address[startOffset + currentOffset] =
                            fdoExtension->ControllerAddress.Address[startOffset] + currentOffset;
                        ++currentOffset;
                    }
                }

#ifdef TOSHIBAJ
                // Are there configuration ports in a descriptor ?
                if ( TranslatedConfigBase
                  && (partial->u.Port.Start.LowPart <= (ULONG)TranslatedConfigBase)
                  && (partial->u.Port.Start.LowPart + partial->u.Port.Length > (ULONG)TranslatedConfigBase) ) {
                    foundConfigIndex = TRUE;
                    FdcDump( FDCINFO,
                        ("FdcStartDevice: Configration index port in %04x (length %04x)\n",
                        partial->u.Port.Start.LowPart,
                        partial->u.Port.Length) );
                }

                if ( TranslatedConfigBase
                  && (partial->u.Port.Start.LowPart <= (ULONG)TranslatedConfigBase + 1)
                  && (partial->u.Port.Start.LowPart + partial->u.Port.Length > (ULONG)TranslatedConfigBase + 1) ) {
                    foundConfigData = TRUE;
                    FdcDump( FDCINFO,
                        ("FdcStartDevice: Configration data port in %04x (length %04x)\n",
                        partial->u.Port.Start.LowPart,
                        partial->u.Port.Length) );
                }

                if (foundConfigIndex && foundConfigData) {
                    fdoExtension->ConfigBase = (PUCHAR)SmcConfigBase;
                    fdoExtension->Available3Mode = TRUE;
                }
#endif
                break;
            }

            case CmResourceTypeDma: {

                DEVICE_DESCRIPTION deviceDesc = {0};

                FdcDump( FDCINFO, ("FdcStartDevice: DMA - %04x\n", partial->u.Dma.Channel) );

                foundDma = TRUE;

                deviceDesc.Version = DEVICE_DESCRIPTION_VERSION1;

                if ( partial->u.Dma.Channel > 3 ) {
                    deviceDesc.DmaWidth = Width16Bits;
                } else {
                    deviceDesc.DmaWidth = Width8Bits;
                }

                deviceDesc.DemandMode    = TRUE;
                deviceDesc.MaximumLength = MAX_BYTES_PER_SECTOR * MAX_SECTORS_PER_TRACK;
                deviceDesc.IgnoreCount   = TRUE;

                //
                // Always ask for one more page than maximum transfer size.
                //
                deviceDesc.MaximumLength += PAGE_SIZE;

                deviceDesc.DmaChannel = partial->u.Dma.Channel;
                deviceDesc.InterfaceType = fullList->InterfaceType;
                deviceDesc.DmaSpeed = DEFAULT_DMA_SPEED;
                deviceDesc.AutoInitialize = FALSE;

                fdoExtension->AdapterObject =
                    HalGetAdapter( &deviceDesc,
                                   &fdoExtension->NumberOfMapRegisters );

                if (!fdoExtension->AdapterObject) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }

                //
                //  Here we can get another adapter object for formatting.  It
                //  should look the same as the previous one except AutoInitialize
                //  will be true.
                //

                break;
            }

            case CmResourceTypeInterrupt: {

                FdcDump( FDCINFO, ("FdcStartDevice: IRQ - %04x\n", partial->u.Interrupt.Vector) );

                foundInterrupt = TRUE;

                if ( partial->Flags & CM_RESOURCE_INTERRUPT_LATCHED) {

                    fdoExtension->InterruptMode = Latched;

                } else {

                    fdoExtension->InterruptMode = LevelSensitive;
                }

                if (IsNEC_98) {

                    //
                    // NOTENOTE: Invalid Interrupt Level and Vector.
                    //

                    partial->u.Interrupt.Level  = 0x0b;
                    partial->u.Interrupt.Vector = 0x13;

                    //
                    // We get the Vector with HalGetInterruptVector().
                    //

                    fdoExtension->ControllerVector =
                        HalGetInterruptVector( fullList->InterfaceType,
                                               fullList->BusNumber,
                                               partial->u.Interrupt.Level,
                                               partial->u.Interrupt.Vector,
                                               &fdoExtension->ControllerIrql,
                                               &fdoExtension->ProcessorMask );

                    FdcDump( FDCSHOW,
                             ("Resource Requirements - ControllerVector = 0x%x\n",
                             fdoExtension->ControllerVector) );

                } else {
                    fdoExtension->ControllerVector = partial->u.Interrupt.Vector;
                    fdoExtension->ProcessorMask = partial->u.Interrupt.Affinity;
                    fdoExtension->ControllerIrql = (KIRQL)partial->u.Interrupt.Level;
                }
                fdoExtension->SharableVector = TRUE;
                fdoExtension->SaveFloatState = FALSE;

                break;
            }

            default:

                break;
            }
        }

        FdcDump( FDCINFO, ("FdcStartDevice: ControllerAddress.StatusA      = %08x\n"
                           "FdcStartDevice: ControllerAddress.StatusB      = %08x\n"
                           "FdcStartDevice: ControllerAddress.DriveControl = %08x\n"
                           "FdcStartDevice: ControllerAddress.Tape         = %08x\n"
                           "FdcStartDevice: ControllerAddress.Status       = %08x\n"
                           "FdcStartDevice: ControllerAddress.Fifo         = %08x\n"
                           "FdcStartDevice: ControllerAddress.DRDC         = %08x\n",
                           fdoExtension->ControllerAddress.StatusA,
                           fdoExtension->ControllerAddress.StatusB,
                           fdoExtension->ControllerAddress.DriveControl,
                           fdoExtension->ControllerAddress.Tape,
                           fdoExtension->ControllerAddress.Status,
                           fdoExtension->ControllerAddress.Fifo,
                           fdoExtension->ControllerAddress.DRDC) );

        if (IsNEC_98) {
            FdcDump( FDCINFO, ("FdcStartDevice: ControllerAddress.ModeChange   = %08x\n"
                               "FdcStartDevice: ControllerAddress.ModeChangeEx = %08x\n",
                               fdoExtension->ControllerAddress.ModeChange,
                               fdoExtension->ControllerAddress.ModeChangeEx) );
        }

        if ( !foundDma ||
             !foundInterrupt ||
             fdoExtension->ControllerAddress.DriveControl == NULL ||
//             fdoExtension->ControllerAddress.Tape == NULL ||
             fdoExtension->ControllerAddress.Status == NULL ||
             fdoExtension->ControllerAddress.Fifo == NULL ||
             ((!IsNEC_98) ? (fdoExtension->ControllerAddress.DRDC.DataRate == NULL)
                         : ((fdoExtension->ControllerAddress.ModeChange == NULL) ||
                            (fdoExtension->ControllerAddress.ModeChangeEx == NULL)) )
              ) {

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }

        if ( NT_SUCCESS(ntStatus) ) {
            //
            //  Set up the bus information since we know it now.
            //
            fdoExtension->BusType = fullList->InterfaceType;
            fdoExtension->BusNumber = fullList->BusNumber;
        }
    }

    if ( NT_SUCCESS(ntStatus) ) {

        ntStatus = FdcInitializeDeviceObject( DeviceObject );

        //
        //  Connect the interrupt for the reset operation.
        //
        ntStatus = IoConnectInterrupt( &fdoExtension->InterruptObject,
                                       FdcInterruptService,
                                       fdoExtension,
                                       NULL,
                                       fdoExtension->ControllerVector,
                                       fdoExtension->ControllerIrql,
                                       fdoExtension->ControllerIrql,
                                       fdoExtension->InterruptMode,
                                       fdoExtension->SharableVector,
                                       fdoExtension->ProcessorMask,
                                       fdoExtension->SaveFloatState );

        FdcDump( FDCINFO, ("FdcStartDevice: IoConnectInterrupt - %08x\n", ntStatus) );

        fdoExtension->CurrentInterrupt = FALSE;

        if ( NT_SUCCESS(ntStatus) ) {

            //
            // Initialize (Reset) the controller hardware.  This will make
            // sure that the controller is really there and leave it in an
            // appropriate state for the rest of the system startup.
            //

            fdoExtension->AllowInterruptProcessing =
                fdoExtension->CurrentInterrupt = TRUE;

            //
            // Acquire the Fdc Enabler card if there is one
            //
            if (fdoExtension->FdcEnablerSupported) {

                LARGE_INTEGER acquireTimeOut;

                acquireTimeOut.QuadPart = -(ONE_SECOND * 15);

                ntStatus = FcFdcEnabler( fdoExtension->FdcEnablerDeviceObject,
//                                       IOCTL_ACQUIRE_FDC, // For spelling miss in flpyenbl.h
                                         IOCTL_AQUIRE_FDC,
                                         &acquireTimeOut);
            }

            if ( NT_SUCCESS(ntStatus) ) {

                ntStatus = FcInitializeControllerHardware( fdoExtension,
                                                           DeviceObject );

                FdcDump( FDCINFO, ("FdcStartDevice: FcInitializeControllerHardware - %08x\n", ntStatus) );

                //
                // Free the tape accelerator card if it was used.
                //
                if (fdoExtension->FdcEnablerSupported) {
                    FcFdcEnabler( fdoExtension->FdcEnablerDeviceObject,
                                  IOCTL_RELEASE_FDC,
                                  NULL);
                }

                fdoExtension->CurrentInterrupt = FALSE;
            }

            if ( NT_SUCCESS( ntStatus ) ) {

                fdoExtension->HardwareFailed = FALSE;
                ntStatus = FcGetFdcInformation ( fdoExtension );

            } else {

                fdoExtension->HardwareFailed = TRUE;
            }

            if (IsNEC_98) {
                //
                // NEC98's FDD driver can't not disconnect interrupt,
                // and can't not page out this driver. Because when a FD is inserted in FDD or
                // is ejected from FDD, then H/W calls FDD driver's interrupt routine.
                //

            } else { // (IsNEC_98)

                IoDisconnectInterrupt(fdoExtension->InterruptObject);

            } // (IsNEC_98)
        }
    }

    Irp->IoStatus.Information = 0;

    return ntStatus;
}
NTSTATUS
FdcInitializeDeviceObject(
    IN PDEVICE_OBJECT DeviceObject
    )
/*++

Routine Description:

    This routine initializes the DeviceObject resources.  DeviceObject resources
    only need to be initialized once, regardless of how many times this device
    is started.

Arguments:

    DeviceObject - a pointer to the device object being started.

Return Value:

--*/
{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFDC_FDO_EXTENSION fdoExtension;
    UNICODE_STRING unicodeEvent;
    USHORT      motorControlData;

    fdoExtension = DeviceObject->DeviceExtension;

    if ( !fdoExtension->DeviceObjectInitialized ) {

        //
        // Set the time to wait for an interrupt before timing out to a
        // few seconds.
        //
        fdoExtension->InterruptDelay.QuadPart = -(ONE_SECOND * 4);

        //
        // Set the minimum time that we can delay (10ms according to system
        // rules).  This will be used when we have to delay to, say, wait
        // for the FIFO - the FIFO should become ready is well under 10ms.
        //
        fdoExtension->Minimum10msDelay.QuadPart = -(10 * 1000 * 10);

        if (IsNEC_98) {
            //
            // Set initialize data to move state
            //
            fdoExtension->ResultStatus0[0] = 0xc0;
            fdoExtension->ResultStatus0[1] = 0xc1;
            fdoExtension->ResultStatus0[2] = 0xc2;
            fdoExtension->ResultStatus0[3] = 0xc3;

            //
            // Reset high
            //

            READ_CONTROLLER(fdoExtension->ControllerAddress.DriveControl);

            //
            // Initialize motor running status.
            //   0 - stop
            //   1 - just run
            //   2 - be running
            //

            fdoExtension->MotorRunning = 0;

            //
            // Get BIOS common area date.
            //

            {
                ULONG                       nodeNumber;
                CHAR                        AnsiBuffer[512];
                ANSI_STRING                 AnsiString;
                UNICODE_STRING              registryPath;
                ULONG                       Configuration;

                RTL_QUERY_REGISTRY_TABLE    paramTable[2];
                PUCHAR                      ConfigurationData1;

                ConfigurationData1 = ExAllocatePool(NonPagedPoolCacheAligned, 1192);

                if (ConfigurationData1 == NULL) {
                    return STATUS_INSUFFICIENT_RESOURCES;
                }

                RtlZeroMemory(ConfigurationData1, 1192);

                paramTable[0].QueryRoutine      = NULL;
                paramTable[0].Flags             = RTL_QUERY_REGISTRY_DIRECT;
                paramTable[0].Name              = L"Configuration Data";
                paramTable[0].EntryContext      = ConfigurationData1;
                paramTable[0].DefaultType       = REG_DWORD;
                paramTable[0].DefaultData       = (PVOID)&Configuration;
                paramTable[0].DefaultLength     = 0;

                paramTable[1].QueryRoutine      = NULL;
                paramTable[1].Flags             = 0;
                paramTable[1].Name              = NULL;
                paramTable[1].EntryContext      = NULL;
                paramTable[1].DefaultType       = REG_NONE;
                paramTable[1].DefaultData       = NULL;
                paramTable[1].DefaultLength     = 0;

                ((PULONG)ConfigurationData1)[0] = 1192;

                nodeNumber = FdcFindIsaBusNode();

                if ( nodeNumber != -1 ) {

                    //
                    // Build path buffer...
                    //

                    sprintf(AnsiBuffer,ISA_BUS_NODE,nodeNumber);
                    RtlInitAnsiString(&AnsiString,AnsiBuffer);
                    ntStatus = RtlAnsiStringToUnicodeString(&registryPath,&AnsiString,TRUE);

                    if (!(NT_SUCCESS(ntStatus))) {
                        ExFreePool(ConfigurationData1);
                        return ntStatus;
                    }

                    ntStatus = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                                      registryPath.Buffer,
                                                      paramTable,
                                                      NULL,
                                                      NULL);

                    RtlFreeUnicodeString(&registryPath);

                }

                if (!(NT_SUCCESS(ntStatus))) {

                    ExFreePool(ConfigurationData1);
                    return ntStatus;
                }

                //
                // Set disk dirve existing bit.
                //

                fdoExtension->FloppyEquip = (UCHAR)(FdcGet0Seg(ConfigurationData1, 0x55c) & 0x0F);

                //
                // Reset high
                //

                READ_CONTROLLER(fdoExtension->ControllerAddress.DriveControl);

                motorControlData  = READ_CONTROLLER(fdoExtension->ControllerAddress.ModeChange);
                motorControlData &= 0x03;
                motorControlData |= 0x04;

                //
                // Motor control.
                //

                WRITE_CONTROLLER(fdoExtension->ControllerAddress.ModeChange, motorControlData);

                ExFreePool(ConfigurationData1);
            }
        } // (IsNEC_98)

        //
        // Initialize the DPC structure in the device object, so that
        // the ISR can queue DPCs.
        //
        IoInitializeDpcRequest( fdoExtension->Self, FdcDeferredProcedure );

        //
        // Occasionally during stress we've seen the device lock up.
        // We create a dpc so that we can log that the device lock up
        // occured and that we reset the device.
        //
        KeInitializeDpc( &fdoExtension->LogErrorDpc,
                         FcLogErrorDpc,
                         fdoExtension );

        //
        // Assume there is a CONFIGURE command until found otherwise.
        // Other Booleans were zero-initialized to FALSE.
        //
        fdoExtension->ControllerConfigurable = NotConfigurable ? FALSE : TRUE;
        fdoExtension->Model30 = Model30 ? TRUE : FALSE;

        fdoExtension->AllowInterruptProcessing = TRUE;
        fdoExtension->CurrentInterrupt         = TRUE;
        fdoExtension->ControllerInUse          = FALSE;
        fdoExtension->CurrentIrp               = NULL;

        //
        // Start the timer
        //
        fdoExtension->InterruptTimer = CANCEL_TIMER;

        IoInitializeTimer( DeviceObject, FdcCheckTimer, fdoExtension );

        //
        // Initialize events to signal interrupts and adapter object
        // allocation
        //
        KeInitializeEvent( &fdoExtension->InterruptEvent,
                           SynchronizationEvent,
                           FALSE);

        KeInitializeEvent( &fdoExtension->AllocateAdapterChannelEvent,
                           NotificationEvent,
                           FALSE );

        fdoExtension->AdapterChannelRefCount = 0;

        RtlInitUnicodeString( &unicodeEvent, L"\\Device\\FloppyControllerEvent0" );

        fdoExtension->AcquireEvent = IoCreateSynchronizationEvent( &unicodeEvent,
                                                                   &fdoExtension->AcquireEventHandle);

        KeInitializeEvent( &fdoExtension->SynchEvent,
                           SynchronizationEvent,
                           FALSE);

    }

    fdoExtension->DeviceObjectInitialized = TRUE;

    return ntStatus;
}


NTSTATUS
FdcFdoConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )
/*++

Routine Description:

    This routine is used to acquire all of the configuration
    information for a tape enabler if we ever find one.

Arguments:

    Context - Pointer to our FDO extension

    PathName - unicode registry path.  Not Used.

    BusType - Internal, Isa, ...

    BusNumber - Which bus if we are on a multibus system.

    BusInformation - Configuration information about the bus. Not Used.

    ControllerType - Should always be DiskController.

    ControllerNumber - Which controller if there is more than one
                       controller in the system.

    ControllerInformation - Array of pointers to the three pieces of
                            registry information.

    PeripheralType - Should always be FloppyDiskPeripheral.

    PeripheralNumber - Which floppy if this controller is maintaining
                       more than one.

    PeripheralInformation - Arrya of pointers to the three pieces of
                            registry information.

Return Value:

    STATUS_SUCCESS if everything went ok, or STATUS_INSUFFICIENT_RESOURCES
    if it couldn't map the base csr or acquire the adapter object, or
    all of the resource information couldn't be acquired.

--*/
{

    PFDC_FDO_EXTENSION fdoExtension = (PFDC_FDO_EXTENSION)Context;
    NTSTATUS ntStatus;
    UNICODE_STRING pdoName;
    PDEVICE_OBJECT newPdo;
    PFDC_PDO_EXTENSION pdoExtension;
    RTL_QUERY_REGISTRY_TABLE paramTable[2];
    ULONG apiSupported;
    WCHAR idstr[200];
    UNICODE_STRING str;
    USHORT i;
    BOOLEAN foundPort = FALSE;
    BOOLEAN foundInterrupt = FALSE;
    BOOLEAN foundDma = FALSE;

    FdcDump( FDCSHOW, ("FdcFdoConfigCallBack:\n") );

    //
    //  The first thing to do is to go out and look for an enabler.  We
    //  know we are dealing with one if there is a registry value called
    //  APISupported.
    //
    str.Length = 0;
    str.MaximumLength = 200;
    str.Buffer = idstr;

    RtlZeroMemory( &paramTable[0], sizeof(paramTable) );

    paramTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT;
    paramTable[0].Name = L"APISupported";
    paramTable[0].EntryContext = &str;
    paramTable[0].DefaultType = REG_SZ;
    paramTable[0].DefaultData = L"";
    paramTable[0].DefaultLength = sizeof(WCHAR);

    ntStatus = RtlQueryRegistryValues( RTL_REGISTRY_ABSOLUTE | RTL_REGISTRY_OPTIONAL,
                                       PathName->Buffer,
                                       &paramTable[0],
                                       NULL,
                                       NULL);
    if ( !NT_SUCCESS( ntStatus ) ) {
        str.Buffer[0] = 0;
    }

    if ( str.Buffer[0] != 0 ) {

        FdcDump(FDCINFO,
               ("FdcFdoConfigCallBack: Got registry setting for EnablerAPI = %ls\n",
                (ULONG_PTR)str.Buffer) );

        ntStatus = IoGetDeviceObjectPointer( &str,
                                             FILE_READ_ACCESS,
                                             &fdoExtension->FdcEnablerFileObject,
                                             &fdoExtension->FdcEnablerDeviceObject);
    }

    if ( fdoExtension->FdcEnablerDeviceObject != NULL ) {

        PCM_FULL_RESOURCE_DESCRIPTOR controllerData =
            (PCM_FULL_RESOURCE_DESCRIPTOR)
            (((PUCHAR)ControllerInformation[IoQueryDeviceConfigurationData]) +
            ControllerInformation[IoQueryDeviceConfigurationData]->DataOffset);

        //
        // We have the pointer.  Save off the interface type and
        // the busnumber for use when we call the Hal and the
        // Io System.
        //
        fdoExtension->BusType = BusType;
        fdoExtension->BusNumber = BusNumber;
        fdoExtension->SharableVector = TRUE;
        fdoExtension->SaveFloatState = FALSE;

        //
        // We need to get the following information out of the partial
        // resource descriptors.
        //
        // The irql and vector.
        //
        // The dma channel.
        //
        // The base address and span covered by the floppy controllers
        // registers.
        //
        // It is not defined how these appear in the partial resource
        // lists, so we will just loop over all of them.  If we find
        // something we don't recognize, we drop that information on
        // the floor.  When we have finished going through all the
        // partial information, we validate that we got the above
        // three.
        //
        for ( i = 0;
              i < controllerData->PartialResourceList.Count;
              i++ ) {

            PCM_PARTIAL_RESOURCE_DESCRIPTOR partial =
                &controllerData->PartialResourceList.PartialDescriptors[i];

            switch ( partial->Type ) {

            case CmResourceTypePort: {

                foundPort = TRUE;

                //
                // Save of the pointer to the partial so
                // that we can later use it to report resources
                // and we can also use this later in the routine
                // to make sure that we got all of our resources.
                //
                fdoExtension->SpanOfControllerAddress = partial->u.Port.Length;
                fdoExtension->ControllerAddress.StatusA =
                    FdcGetControllerBase(
                        BusType,
                        BusNumber,
                        partial->u.Port.Start,
                        fdoExtension->SpanOfControllerAddress,
                        (BOOLEAN)!!partial->Flags );

                if ( fdoExtension->ControllerAddress.StatusA == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    fdoExtension->ControllerAddress.StatusB       = fdoExtension->ControllerAddress.StatusA + 1;
                    fdoExtension->ControllerAddress.DriveControl  = fdoExtension->ControllerAddress.StatusA + 2;
                    fdoExtension->ControllerAddress.Tape          = fdoExtension->ControllerAddress.StatusA + 3;
                    fdoExtension->ControllerAddress.Status        = fdoExtension->ControllerAddress.StatusA + 4;
                    fdoExtension->ControllerAddress.Fifo          = fdoExtension->ControllerAddress.StatusA + 5;
                    fdoExtension->ControllerAddress.DRDC.DataRate = fdoExtension->ControllerAddress.StatusA + 7;

                }

                break;
            }
            case CmResourceTypeInterrupt: {

                foundInterrupt = TRUE;

                if ( partial->Flags & CM_RESOURCE_INTERRUPT_LATCHED ) {

                    fdoExtension->InterruptMode = Latched;

                } else {

                    fdoExtension->InterruptMode = LevelSensitive;

                }

                fdoExtension->ControllerVector =
                    HalGetInterruptVector(
                        BusType,
                        BusNumber,
                        partial->u.Interrupt.Level,
                        partial->u.Interrupt.Vector,
                        &fdoExtension->ControllerIrql,
                        &fdoExtension->ProcessorMask
                        );

                break;
            }
            case CmResourceTypeDma: {

                DEVICE_DESCRIPTION deviceDesc = {0};

                //
                // Use IgnoreCount equal to TRUE to fix PS/1000.
                //
                foundDma = TRUE;

                deviceDesc.Version = DEVICE_DESCRIPTION_VERSION1;

                if ( partial->u.Dma.Channel > 3 ) {
                    deviceDesc.DmaWidth = Width16Bits;
                } else {
                    deviceDesc.DmaWidth = Width8Bits;
                }

                deviceDesc.DemandMode    = TRUE;
                deviceDesc.MaximumLength = MAX_BYTES_PER_SECTOR * MAX_SECTORS_PER_TRACK;
                deviceDesc.IgnoreCount   = TRUE;

                deviceDesc.DmaChannel = partial->u.Dma.Channel;
                deviceDesc.InterfaceType = BusType;
                deviceDesc.DmaSpeed = DEFAULT_DMA_SPEED;
                fdoExtension->AdapterObject =
                    HalGetAdapter(
                        &deviceDesc,
                        &fdoExtension->NumberOfMapRegisters
                        );

                if ( fdoExtension->AdapterObject == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                }
                break;
            }
            default:

                break;
            }
        }
        //
        // If we didn't get all the information then we return
        // insufficient resources.
        //
        if ( !foundPort || !foundInterrupt || !foundDma ) {

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;
        }
    }
    return ntStatus;
}

PVOID
FdcGetControllerBase(
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfBytes,
    BOOLEAN InIoSpace
    )
/*++

Routine Description:

    This routine maps an IO address to system address space.

Arguments:

    BusType - what type of bus - eisa, mca, isa
    IoBusNumber - which IO bus (for machines with multiple buses).
    IoAddress - base device address to be mapped.
    NumberOfBytes - number of bytes for which address is valid.
    InIoSpace - indicates an IO address.

Return Value:

    Mapped address

--*/
{
    PHYSICAL_ADDRESS cardAddress;
    ULONG addressSpace = InIoSpace;
    PVOID Address;

    if ( !HalTranslateBusAddress( BusType,
                                  BusNumber,
                                  IoAddress,
                                  &addressSpace,
                                  &cardAddress ) ){
        return NULL;
    }

    //
    // Map the device base address into the virtual address space
    // if the address is in memory space.
    //

    if ( !addressSpace ) {

        Address = MmMapIoSpace( cardAddress,
                                NumberOfBytes,
                                FALSE );

    } else {

        Address = (PCONTROLLER)cardAddress.LowPart;
    }
    return Address;
}


NTSTATUS
FcInitializeControllerHardware(
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:

    This routine is called at initialization time by FcInitializeDevice()
    - once for each controller that we have to support.

    When this routine is called, the controller data structures have all
    been allocated.

Arguments:

    ControllerData - the completed data structure associated with the
    controller hardware being initialized.

    DeviceObject - a pointer to a device object; this routine will cause
    an interrupt, and the ISR requires CurrentDeviceObject to be filled
    in.

Return Value:

    STATUS_SUCCESS if this controller appears to have been reset properly,
    error otherwise.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    UCHAR statusRegister0;
    UCHAR cylinder;
    UCHAR driveNumber;
    UCHAR retrycnt;

    FdcDump( FDCSHOW, ("Fdc: FcInitializeControllerHardware...\n") );

    for (retrycnt = 0; ; retrycnt++) {

        //
        // Reset the controller.  This will cause an interrupt.  Reset
        // CurrentDeviceObject until after the 10ms wait, in case any
        // stray interrupts come in.
        //
        DISABLE_CONTROLLER_IMAGE (FdoExtension);

        WRITE_CONTROLLER(
            FdoExtension->ControllerAddress.DriveControl,
            FdoExtension->DriveControlImage );

        KeStallExecutionProcessor( 10 );

        FdoExtension->CurrentDeviceObject = DeviceObject;
        FdoExtension->AllowInterruptProcessing = TRUE;
        FdoExtension->CommandHasResultPhase = FALSE;
        KeResetEvent( &FdoExtension->InterruptEvent );

        ENABLE_CONTROLLER_IMAGE (FdoExtension);

        WRITE_CONTROLLER(
            FdoExtension->ControllerAddress.DriveControl,
            FdoExtension->DriveControlImage );

        if (IsNEC_98) {
            //
            // NEC98 don't have to wait for interrupt.
            //

            ntStatus = STATUS_SUCCESS;

        } else { // (IsNEC_98)
            //
            // Wait for an interrupt.  Note that STATUS_TIMEOUT and
            // STATUS_SUCCESS are the only possible return codes, since we
            // aren't alertable and won't get APCs.
            //
            ntStatus = KeWaitForSingleObject( &FdoExtension->InterruptEvent,
                                              Executive,
                                              KernelMode,
                                              FALSE,
                                              &FdoExtension->InterruptDelay );
        } // (IsNEC_98)

        if (ntStatus == STATUS_TIMEOUT) {

            if (retrycnt >= 1) {
                break;
            }

            // Retry reset after configure command to enable polling
            // interrupt.

            FdoExtension->FifoBuffer[0] = COMMND_CONFIGURE;

            if (FdoExtension->Clock48MHz) {
                FdoExtension->FifoBuffer[0] |= COMMND_OPTION_CLK48;
            }

            FdoExtension->FifoBuffer[1] = 0;
            FdoExtension->FifoBuffer[2] = COMMND_CONFIGURE_FIFO_THRESHOLD;
            FdoExtension->FifoBuffer[3] = 0;

            ntStatus = FcIssueCommand( FdoExtension,
                                       FdoExtension->FifoBuffer,
                                       FdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            if (!NT_SUCCESS(ntStatus)) {
                ntStatus = STATUS_TIMEOUT;
                break;
            }

            KeStallExecutionProcessor( 500 );

        } else {

            break;

        }
    }

    if ( ntStatus == STATUS_TIMEOUT ) {

        //
        // Change info to an error.
        //

        ntStatus = STATUS_IO_TIMEOUT;

        FdoExtension->HardwareFailed = TRUE;
    }

    if ( !NT_SUCCESS( ntStatus ) ) {

        FdcDump(FDCDBGP,("Fdc: controller didn't interrupt after reset\n"));

        return ntStatus;
    }

    if (!IsNEC_98) {

        ntStatus = FcFinishReset( FdoExtension );

    } // (!IsNEC_98)

    return ntStatus;
}

NTSTATUS
FcGetFdcInformation(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine will attempt to identify the type of Floppy Controller

Arguments:

    FdoExtension - a pointer to our data area for the drive being
    accessed (any drive if a controller command is being given).

Return Value:

--*/
{
    NTSTATUS ntStatus;
    FDC_INFORMATION fdcInfo;

    if (FdoExtension->FdcEnablerSupported) {

        fdcInfo.structSize = sizeof(fdcInfo);

        ntStatus = FcFdcEnabler( FdoExtension->FdcEnablerDeviceObject,
                                 IOCTL_GET_FDC_INFO,
                                 &fdcInfo);

        if ( NT_SUCCESS( ntStatus ) ) {

            FdoExtension->FdcType = (UCHAR)fdcInfo.FloppyControllerType;
            FdoExtension->Clock48MHz =
                            (fdcInfo.ClockRatesSupported == FDC_CLOCK_48MHZ);
            FdoExtension->FdcSpeeds = (UCHAR)fdcInfo.SpeedsAvailable;

        }

    } else {

        //
        // First, assume that we don't know what kind of FDC is attached.
        //

        FdoExtension->FdcType = FDC_TYPE_UNKNOWN;


        // Check for an enhanced type controller by issuing the version command.

        FdoExtension->FifoBuffer[0] = COMMND_VERSION;

        ntStatus = FcIssueCommand( FdoExtension,
                                FdoExtension->FifoBuffer,
                                FdoExtension->FifoBuffer,
                                NULL,
                                0,
                                0 );

        if ( NT_SUCCESS( ntStatus ) ) {

            if (FdoExtension->FifoBuffer[0] == VALID_NEC_FDC) {

                FdoExtension->FdcType = FDC_TYPE_ENHANCED;

            } else {

                FdoExtension->FdcType = FDC_TYPE_NORMAL;

            }
        }

        // Determine if the controller is a National 8477 by issuing the NSC
        // command which is specific to National parts and returns 0x71. (This
        // command happens to be the same as the Intel Part ID command so we
        // will use it instead.) The lower four bits are subject to change by
        // National and will reflect the version of the part in question.  At
        // this point we will only test the high four bits.

        if ( FdoExtension->FdcType == FDC_TYPE_ENHANCED &&
             NT_SUCCESS( ntStatus ) ) {

            FdoExtension->FifoBuffer[0] = COMMND_PART_ID;

            ntStatus = FcIssueCommand( FdoExtension,
                                       FdoExtension->FifoBuffer,
                                       FdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            if ( NT_SUCCESS( ntStatus ) ) {

                if ( (FdoExtension->FifoBuffer[0] & NSC_MASK) ==
                     NSC_PRIMARY_VERSION) {

                    FdoExtension->FdcType = FDC_TYPE_NATIONAL;

                }
            }
        }

        // Determine if the controller is an 82077 by issuing the perpendicular
        // mode command which at this time is only valid on 82077's.

        if ( FdoExtension->FdcType == FDC_TYPE_ENHANCED &&
             NT_SUCCESS( ntStatus ) ) {

            FdoExtension->FifoBuffer[0] = COMMND_PERPENDICULAR_MODE;
            FdoExtension->FifoBuffer[1] = COMMND_PERPENDICULAR_MODE_OW;

            ntStatus = FcIssueCommand( FdoExtension,
                                       FdoExtension->FifoBuffer,
                                       FdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            if (ntStatus != STATUS_DEVICE_NOT_READY) {

                FdoExtension->FdcType = FDC_TYPE_82077;

            }
        }

        // Determine if the controller is an Intel 82078 by issuing the part id
        // command which is specific to Intel 82078 parts.

        if ( FdoExtension->FdcType == FDC_TYPE_82077 &&
             NT_SUCCESS( ntStatus ) ) {

            FdoExtension->FifoBuffer[0] = COMMND_PART_ID;

            ntStatus = FcIssueCommand( FdoExtension,
                                       FdoExtension->FifoBuffer,
                                       FdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            if ( NT_SUCCESS( ntStatus ) ) {

                if ((FdoExtension->FifoBuffer[0] & INTEL_MASK) ==
                    INTEL_64_PIN_VERSION) {

                    FdoExtension->FdcType = FDC_TYPE_82078_64;
                } else {
                    if ((FdoExtension->FifoBuffer[0] & INTEL_MASK) ==
                        INTEL_44_PIN_VERSION) {

                        FdoExtension->FdcType = FDC_TYPE_82078_44;
                    }
                }
            }
        }

        switch (FdoExtension->FdcType) {

        case FDC_TYPE_UNKNOWN   :
        case FDC_TYPE_NORMAL    :
        case FDC_TYPE_ENHANCED  :
        default:

            FdoExtension->FdcSpeeds = FDC_SPEED_250KB |
                                      FDC_SPEED_300KB |
                                      FDC_SPEED_500KB;
            break;

        case FDC_TYPE_82077     :
        case FDC_TYPE_82077AA   :
        case FDC_TYPE_82078_44  :
        case FDC_TYPE_NATIONAL  :

            FdoExtension->FdcSpeeds = FDC_SPEED_250KB |
                                      FDC_SPEED_300KB |
                                      FDC_SPEED_500KB |
                                      FDC_SPEED_1MB;
            break;

        case FDC_TYPE_82078_64  :

            FdoExtension->FdcSpeeds = FDC_SPEED_250KB |
                                      FDC_SPEED_300KB |
                                      FDC_SPEED_500KB |
                                      FDC_SPEED_1MB;

            if ( FdoExtension->Clock48MHz ) {

                FdoExtension->FdcSpeeds |= FDC_SPEED_2MB;
            }

            break;
        }
    }

    FdcDump( FDCINFO, ("Fdc: FdcType - %x\n", FdoExtension->FdcType));

    return ntStatus;
}
#define IO_PORT_REQ_MASK 0xbc

NTSTATUS
FdcFilterResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine examines the supplied resource list and adds resources if
    necessary.  The only resources that it is concerned with adding are io port
    resources.  Adding io port resources is necessary because of different bios
    configurations and specifications.

    The PC97(98) hardware specification defines only 3f2, 3f4, and 3f5 as
    io port resources for standard floppy controllers (based on IBM PC floppy
    controller configurations).  In addition to these resources, fdc.sys
    requires 3f7 for disk change detection and data rate programming and
    optionally 3f3 for floppy tape support.  In addition, some bioses define
    aliased resources (e.g. 3f2 & 7f2, etc.)

    This routine first forwards the irp to the underlying PDO.  Upon return,
    it examines the io resource list to determine if any additional resources
    will be required.  It maintains a linked list of all io port base addresses
    that it encounters, assuming that they define aliased resources.  N.B. - if
    alternative lists are present in the io resource requirements list, only the
    first list is examined.  If additional resources are required a new io
    resource list is created.  The first io resource list in the new resource
    requirements list will contain the original resources as well as the
    additional resources required.  If it was necessary to request the tape mode
    register (3f3), i.e. 3f3 was not in the original list, a second list is
    generated that is identical to the first new list except that 3f3 is excluded.
    This list is for the case where the tape mode register is not available.
    Finally, the original list(s) is(are) copied to the end of the new list and
    are treated as alternative io resource lists.

Arguments:

    DeviceObject - a pointer to the device object being started.
    Irp - a pointer to the start device Irp.

Return Value:

--*/
{
    NTSTATUS ntStatus;
    PFDC_FDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpSp;
    KEVENT doneEvent;
    PIO_RESOURCE_REQUIREMENTS_LIST resourceRequirementsIn;
    PIO_RESOURCE_REQUIREMENTS_LIST resourceRequirementsOut;
    ULONG listSize;
    ULONG i,j;
    PIO_RESOURCE_LIST ioResourceListIn;
    PIO_RESOURCE_LIST ioResourceListOut;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptorIn;
    PIO_RESOURCE_DESCRIPTOR ioResourceDescriptorOut;
    LIST_ENTRY ioPortList;
    PLIST_ENTRY links;
    PIO_PORT_INFO ioPortInfo;
    BOOLEAN foundBase;
    ULONG newDescriptors;
    BOOLEAN interruptResource = FALSE;
    BOOLEAN dmaResource = FALSE;
    UCHAR newPortMask;
    BOOLEAN requestTapeModeRegister = FALSE;
    USHORT in,out;

#ifdef TOSHIBAJ
    BOOLEAN foundConfigPort = FALSE;
    struct {
        ULONG start;
        ULONG length;
    } configNewPort = {0, 0};
#endif

    fdoExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ntStatus = STATUS_SUCCESS;
    InitializeListHead( &ioPortList );

    FdcDump( FDCSHOW, ("FdcFdoPnp: IRP_MN_FILTER_RESOURCE_REQUIREMENTS - Irp: %p\n", Irp) );

    //
    // Pass this irp down to the PDO before proceeding.
    //
    KeInitializeEvent( &doneEvent, NotificationEvent, FALSE );

    IoCopyCurrentIrpStackLocationToNext(Irp);

    IoSetCompletionRoutine( Irp,
                            FdcPnpComplete,
                            &doneEvent,
                            TRUE,
                            TRUE,
                            TRUE );

    ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

    if ( ntStatus == STATUS_PENDING ) {

        KeWaitForSingleObject( &doneEvent, Executive, KernelMode, FALSE, NULL );
    }

    //
    //  Modified resources are returned in Irp-IoStatus.Information, otherwise
    //  just use what's in the parameter list.
    //
    if ( Irp->IoStatus.Information == 0 ) {

        Irp->IoStatus.Information = (UINT_PTR)irpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList;

        if ( Irp->IoStatus.Information == (UINT_PTR)NULL ) {
            //
            //  NULL List, the PDO freed the incoming resource list but did not
            //  provide a new list.  Complete the IRP with the PDO's status.
            //
            ntStatus = Irp->IoStatus.Status;
            IoCompleteRequest( Irp, IO_NO_INCREMENT );
            return( ntStatus );
        }

    }

    resourceRequirementsIn = (PIO_RESOURCE_REQUIREMENTS_LIST)Irp->IoStatus.Information;

    FdcDump( FDCSHOW, ("Resource Requirements List = %p\n", resourceRequirementsIn) );

    if (IsNEC_98) {
        //
        // It is not necessary to modify the resources.
        //
        ntStatus = STATUS_SUCCESS;

        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );

        return ntStatus;
    }

    //
    //  Make a pass through the resource list and determine what resources are
    //  already there as well as the base address for the io port and any
    //  alias ioports.
    //
    ioResourceListIn  = resourceRequirementsIn->List;
    ioResourceDescriptorIn  = ioResourceListIn->Descriptors;

    ntStatus = STATUS_SUCCESS;

    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: examining %d resources\n", ioResourceListIn->Count));

    for ( i = 0; i < ioResourceListIn->Count && NT_SUCCESS(ntStatus); i++ ) {

        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: IoResourceDescritporIn = %p\n",ioResourceDescriptorIn));

        switch ( ioResourceDescriptorIn->Type ) {

        case CmResourceTypeInterrupt:

            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found Interrupt Resource\n"));
            interruptResource = TRUE;
            break;

        case CmResourceTypeDma:

            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found Dma Resource \n"));
            dmaResource = TRUE;
            break;

        case CmResourceTypePort:

            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found Port Resource\n"));
            //
            //  For the ioPorts we will make a list containing each detected
            //  'base' address as well as the currently allocated addresses
            //  on that base.  Later we will use this to request additional
            //  resources if necessary.
            //
            //  First, if this base isn't already in the list, create a new
            //  list entry for it.
            //

            foundBase = FALSE;

            for ( links = ioPortList.Flink;
                  links != &ioPortList;
                  links = links->Flink) {

                ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);

                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Examining %p for match\n",ioPortInfo));
                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements:   Base Address = %08x\n",ioPortInfo->BaseAddress.LowPart));
                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements:   Desc Address = %08x\n",ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart & 0xfffffff8));

                if ( ioPortInfo->BaseAddress.LowPart ==
                     (ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart & 0xfffffff8) ) {

                    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found %08x in the ioPortList\n",ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart));

                    foundBase = TRUE;
                    //
                    //  Add these resources into the resource map for this base
                    //  address.
                    //
                    for ( j = 0; j < ioResourceDescriptorIn->u.Port.Length; j++ ) {

                        ioPortInfo->Map |= 0x01 << ((ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart & 0x07) + j);
                    }
                    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: New IoPortInfo->Map = %x\n",ioPortInfo->Map));
                    break;
                }
            }

            if ( !foundBase ) {

                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Creating new ioPortList entry for %08x\n",ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart));
                ioPortInfo = ExAllocatePool( PagedPool, sizeof(IO_PORT_INFO) );
                if ( ioPortInfo == NULL ) {
                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;
                } else {
                    RtlZeroMemory( ioPortInfo, sizeof(IO_PORT_INFO) );
                    ioPortInfo->BaseAddress = ioResourceDescriptorIn->u.Port.MinimumAddress;
                    ioPortInfo->BaseAddress.LowPart &= 0xfffffff8;
                    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements:   Base Address = %08x\n",ioPortInfo->BaseAddress.LowPart));
                    for ( j = 0; j < ioResourceDescriptorIn->u.Port.Length; j++ ) {
                        ioPortInfo->Map |= 0x01 << ((ioResourceDescriptorIn->u.Port.MinimumAddress.LowPart & 0x07) + j);
                    }
                    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements:   New IoPortInfo->Map = %x\n",ioPortInfo->Map));
                    InsertTailList( &ioPortList, &ioPortInfo->ListEntry );
                }
            }
            break;

        default:

            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Found unknown resource\n"));
            break;
        }
        ioResourceDescriptorIn++;
    }

    //
    //  If we didn't see any io port resources, we will just return now
    //  since we can't be sure of what to ask for.  The subsequent start
    //  device will surely fail.  This also goes for the interrupt and
    //  dma resource.
    //
    if ( !NT_SUCCESS(ntStatus) ||
         IsListEmpty( &ioPortList ) ||
         !interruptResource ||
         !dmaResource ) {
        //
        //  Clean up the ioPortInfo list
        //
        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Bad Resources, Go directly to jail\n"));
        while ( !IsListEmpty( &ioPortList ) ) {
            links = RemoveHeadList( &ioPortList );
            ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);
            ExFreePool( ioPortInfo );
        }

        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return ntStatus;
    }

#ifdef TOSHIBAJ
    if (SmcConfigBase) {
        PHYSICAL_ADDRESS    configPort;
        ULONG               ioSpace;

        // Map I/O port
        configPort.QuadPart = 0;
        configPort.LowPart = SmcConfigBase;
        ioSpace = 1;                       // I/O port
        if (HalTranslateBusAddress(resourceRequirementsIn->InterfaceType,
                                    resourceRequirementsIn->BusNumber,
                                    configPort,
                                    &ioSpace,
                                    &configPort)) {
            TranslatedConfigBase = (PUCHAR)configPort.LowPart;
            if (FcCheckConfigPort(TranslatedConfigBase)) {
            FdcDump( FDCINFO,
                ("FdcFilterResourceRequirements: Configuration port %x\n",
                TranslatedConfigBase) );
            } else {
                SmcConfigBase = 0;
                TranslatedConfigBase = NULL;
            }
        } else {
            SmcConfigBase = 0;
            TranslatedConfigBase = NULL;
        }
    }
#endif

    //
    //  At this point, we know what resources we are currently assigned so
    //  we can determine what additional resources we need to request.  We
    //  need to know the size of the list we need to create so first count
    //  the number of resource descriptors we will have to add to the current
    //  list.
    //
    newDescriptors = 0;

    for ( links = ioPortList.Flink;
          links != &ioPortList;
          links = links->Flink) {

        ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);

        newPortMask = ~ioPortInfo->Map & IO_PORT_REQ_MASK;

        if ( newPortMask & 0x08 ) {
            requestTapeModeRegister = TRUE;
        }

        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Counting bits in %x\n",newPortMask));

        while ( newPortMask > 0 ) {
            if ( newPortMask & 0x01 ) {
                newDescriptors++;
            }
            newPortMask >>= 1;
        }

#ifdef TOSHIBAJ
        // Are there configuration ports in assigned resources ?
        if (SmcConfigBase && (ioPortInfo->BaseAddress.LowPart == SmcConfigBase)) {
            foundConfigPort = TRUE;
            if (!(ioPortInfo->Map & 0x01)) {
                configNewPort.start = SmcConfigBase;
                ++configNewPort.length;
            }
            if (!(ioPortInfo->Map & 0x02)) {
                if (!configNewPort.start) {
                    configNewPort.start = SmcConfigBase + 1;
                }
                configNewPort.length++;
            }
        }
#endif
    }

#ifdef TOSHIBAJ
    // Deteremine the address and length of the additional descriptor
    // for configuration ports.
    if (SmcConfigBase && !foundConfigPort) {
        configNewPort.start = SmcConfigBase;
        configNewPort.length = 2;
    }
    if (configNewPort.start) {
        newDescriptors++;
    }
#endif

    FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Create %d new descriptors\n", newDescriptors) );

    //
    //  If we need resources that were not in the list, we will need to
    //  allocate a new resource requirements list that includes these
    //  new resources.
    //
    if ( newDescriptors > 0 ) {

        //
        //  Allocate and initialize a resource requirements list.  Make it big
        //  enough to hold whatever was in the list to start with along with
        //  the new resource list.
        //
        listSize = resourceRequirementsIn->ListSize +
                   resourceRequirementsIn->ListSize +
                   newDescriptors * sizeof(IO_RESOURCE_DESCRIPTOR);

        //
        //  If we will be requesting the tape mode register we will need to
        //  make an alternate list without it in case we cannot get it.
        //
        if ( requestTapeModeRegister ) {

            listSize = listSize +
                       resourceRequirementsIn->ListSize +
                       newDescriptors * sizeof(IO_RESOURCE_DESCRIPTOR);
        }

        resourceRequirementsOut = ExAllocatePool( NonPagedPool, listSize );

        if ( resourceRequirementsOut == NULL ) {

            ntStatus = STATUS_INSUFFICIENT_RESOURCES;

        } else {

            RtlZeroMemory( resourceRequirementsOut, listSize);

            //
            //  Initialize the IO_RESOURCE_REQUIREMENTS_LIST header.
            //
            resourceRequirementsOut->ListSize = sizeof(IO_RESOURCE_REQUIREMENTS_LIST) -
                                                 sizeof(IO_RESOURCE_LIST);
            resourceRequirementsOut->InterfaceType = resourceRequirementsIn->InterfaceType;
            resourceRequirementsOut->BusNumber = resourceRequirementsIn->BusNumber;
            resourceRequirementsOut->SlotNumber = resourceRequirementsIn->SlotNumber;
            resourceRequirementsOut->Reserved[0] = resourceRequirementsIn->Reserved[0];
            resourceRequirementsOut->Reserved[1] = resourceRequirementsIn->Reserved[1];
            resourceRequirementsOut->Reserved[2] = resourceRequirementsIn->Reserved[2];
            resourceRequirementsOut->AlternativeLists = resourceRequirementsIn->AlternativeLists + 1;
            if ( requestTapeModeRegister ) {
                ++resourceRequirementsOut->AlternativeLists;
            }

            //
            //  Copy the primary list from the incoming IO_RESOURCE_REQUIREMENTS_LIST
            //  to the new list.
            //
            ioResourceListIn  = resourceRequirementsIn->List;
            ioResourceListOut = resourceRequirementsOut->List;

            listSize = sizeof(IO_RESOURCE_LIST) +
                      (ioResourceListIn->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR);
            RtlCopyMemory( ioResourceListOut, ioResourceListIn, listSize );

            resourceRequirementsOut->ListSize += listSize;

            //
            //  Add any additional resources that we are requesting.
            //
            ioResourceDescriptorOut = (PIO_RESOURCE_DESCRIPTOR)((ULONG_PTR)resourceRequirementsOut +
                                                                       resourceRequirementsOut->ListSize);
            for ( links = ioPortList.Flink;
                  links != &ioPortList;
                  links = links->Flink) {

                ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);

                newPortMask = ~ioPortInfo->Map & IO_PORT_REQ_MASK;
                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Add resource desc for each bit in %x\n",newPortMask));

                i = 0;
                while ( newPortMask != 0 ) {

                    if ( newPortMask & 0x01 ) {

                        ioResourceDescriptorOut->Option = IO_RESOURCE_PREFERRED;
                        ioResourceDescriptorOut->Type = CmResourceTypePort;
                        ioResourceDescriptorOut->ShareDisposition = CmResourceShareDeviceExclusive;
                        ioResourceDescriptorOut->Flags = CM_RESOURCE_PORT_IO;

                        ioResourceDescriptorOut->u.Port.Length = 1;
                        ioResourceDescriptorOut->u.Port.Alignment = 1;
                        ioResourceDescriptorOut->u.Port.MinimumAddress.QuadPart =
                        ioResourceDescriptorOut->u.Port.MaximumAddress.QuadPart =
                        ioPortInfo->BaseAddress.QuadPart + (ULONGLONG)i;

                        ++ioResourceListOut->Count;
                        resourceRequirementsOut->ListSize += sizeof(IO_RESOURCE_DESCRIPTOR);

                        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Add resource descriptor: %p\n",ioResourceDescriptorOut));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->Option           = %x\n",ioResourceDescriptorOut->Option          ));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->Type             = %x\n",ioResourceDescriptorOut->Type            ));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->ShareDisposition = %x\n",ioResourceDescriptorOut->ShareDisposition));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->Flags            = %x\n",ioResourceDescriptorOut->Flags           ));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->u.Port.Length    = %x\n",ioResourceDescriptorOut->u.Port.Length   ));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->u.Port.Alignment = %x\n",ioResourceDescriptorOut->u.Port.Alignment));
                        FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->u.Port.MinimumAddress.LowPart = %08x\n",ioResourceDescriptorOut->u.Port.MinimumAddress.LowPart));

                        ioResourceDescriptorOut++;
                    }
                    newPortMask >>= 1;
                    i++;
                }
            }

#ifdef TOSHIBAJ
            // Add the descriptor for configuration ports
            if (configNewPort.start) {
                ioResourceDescriptorOut->Option = IO_RESOURCE_PREFERRED;
                ioResourceDescriptorOut->Type = CmResourceTypePort;
                ioResourceDescriptorOut->ShareDisposition = CmResourceShareDeviceExclusive;
                ioResourceDescriptorOut->Flags = CM_RESOURCE_PORT_IO;

                ioResourceDescriptorOut->u.Port.Length = configNewPort.length;
                ioResourceDescriptorOut->u.Port.Alignment = 1;
                ioResourceDescriptorOut->u.Port.MinimumAddress.QuadPart =
                ioResourceDescriptorOut->u.Port.MaximumAddress.QuadPart = 0;
                ioResourceDescriptorOut->u.Port.MinimumAddress.LowPart =
                    configNewPort.start;
                ioResourceDescriptorOut->u.Port.MaximumAddress.LowPart =
                    configNewPort.start + configNewPort.length - 1;

                ++ioResourceListOut->Count;
                resourceRequirementsOut->ListSize += sizeof(IO_RESOURCE_DESCRIPTOR);

                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Add resource descriptor: %p\n",ioResourceDescriptorOut));
                FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->Option           = %x\n",ioResourceDescriptorOut->Option          ));
                FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->Type             = %x\n",ioResourceDescriptorOut->Type            ));
                FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->ShareDisposition = %x\n",ioResourceDescriptorOut->ShareDisposition));
                FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->Flags            = %x\n",ioResourceDescriptorOut->Flags           ));
                FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->u.Port.Length    = %x\n",ioResourceDescriptorOut->u.Port.Length   ));
                FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->u.Port.Alignment = %x\n",ioResourceDescriptorOut->u.Port.Alignment));
                FdcDump( FDCSHOW, ("     ioResourceDescriptorOut->u.Port.MinimumAddress.LowPart = %08x\n",ioResourceDescriptorOut->u.Port.MinimumAddress.LowPart));

                ioResourceDescriptorOut++;
            }
#endif

            if ( requestTapeModeRegister ) {

                ioResourceListIn = ioResourceListOut;
                ioResourceListOut = (PIO_RESOURCE_LIST)ioResourceDescriptorOut;

                ioResourceListOut->Version  = ioResourceListIn->Version;
                ioResourceListOut->Revision = ioResourceListIn->Revision;
                ioResourceListOut->Count    = 0;

                resourceRequirementsOut->ListSize += sizeof(IO_RESOURCE_LIST) -
                                                      sizeof(IO_RESOURCE_DESCRIPTOR);

                in = out = 0;

                do {

                    if ( (ioResourceListIn->Descriptors[in].Type != CmResourceTypePort) ||
                         ((ioResourceListIn->Descriptors[in].u.Port.MinimumAddress.LowPart & 0x07) != 0x03) ) {

                        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Add %08x to alternate list\n", resourceRequirementsOut->List[0].Descriptors[out]));
                        ioResourceListOut->Descriptors[out++] = ioResourceListIn->Descriptors[in++];
                        ++ioResourceListOut->Count;
                        resourceRequirementsOut->ListSize += sizeof(IO_RESOURCE_DESCRIPTOR);
                    } else {
                        FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Don't add %08x to alternate list\n", resourceRequirementsOut->List[0].Descriptors[out]));
                        in++;
                    }
                } while ( in < ioResourceListIn->Count );
            }

            //
            //  Copy the original list(s) to the end of our new list.
            //
            FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Copy %d existing resource list(s)\n",resourceRequirementsIn->AlternativeLists));
            ioResourceListIn = resourceRequirementsIn->List;
            ioResourceListOut = (PIO_RESOURCE_LIST)((ULONG_PTR)resourceRequirementsOut +
                                                           resourceRequirementsOut->ListSize);

            for ( in = 0; in < resourceRequirementsIn->AlternativeLists; in++ ) {

                FdcDump( FDCSHOW, ("FdcFilterResourceRequirements: Copy list %p\n",ioResourceListIn));

                listSize = sizeof(IO_RESOURCE_LIST) +
                          (ioResourceListIn->Count - 1) * sizeof(IO_RESOURCE_DESCRIPTOR);
                RtlCopyMemory( ioResourceListOut, ioResourceListIn, listSize );

                ioResourceListOut = (PIO_RESOURCE_LIST)((ULONG_PTR)ioResourceListOut + listSize);
                ioResourceListIn = (PIO_RESOURCE_LIST)((ULONG_PTR)ioResourceListIn + listSize);
                resourceRequirementsOut->ListSize += listSize;
            }

            FdcDump( FDCSHOW, ("Resource Requirements List = %p\n", resourceRequirementsOut) );

            Irp->IoStatus.Information = (UINT_PTR)resourceRequirementsOut;

            //
            // Free the caller's list
            //
            ExFreePool( resourceRequirementsIn );
            ntStatus = STATUS_SUCCESS;
        }
    }
    //
    //  Clean up the ioPortInfo list
    //
    while ( !IsListEmpty( &ioPortList ) ) {
        links = RemoveHeadList( &ioPortList );
        ioPortInfo = CONTAINING_RECORD(links, IO_PORT_INFO, ListEntry);
        ExFreePool( ioPortInfo );
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return ntStatus;
}

NTSTATUS
FdcQueryDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
/*++

Routine Description:

    This routine will report any devices that have been enumerated on the
    floppy controller.  If we don't know of any devices yet we will
    enumerate the registry hardware tree.

Arguments:

    DeviceObject - a pointer to the device object being started.
    Irp - a pointer to the start device Irp.

Return Value:

--*/
{
    PFDC_FDO_EXTENSION fdoExtension;
    PFDC_PDO_EXTENSION pdoExtension;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpSp;
    ULONG relationCount;
    ULONG relationLength;
    PDEVICE_RELATIONS relations;
    PLIST_ENTRY entry;

    fdoExtension = DeviceObject->DeviceExtension;
    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ntStatus = STATUS_SUCCESS;

    FdcDump( FDCSHOW, ("FdcQueryDeviceRelations:\n"));

    if ( irpSp->Parameters.QueryDeviceRelations.Type != BusRelations ) {
        //
        // We don't support this
        //
        FdcDump( FDCSHOW, ("FdcQueryDeviceRelations: Type = %d\n", irpSp->Parameters.QueryDeviceRelations.Type));

        IoSkipCurrentIrpStackLocation( Irp );
        ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

        return ntStatus;
    }

    //
    // Tell the plug and play system about all the PDOs.
    //
    // There might also be device relations below and above this FDO,
    // so, be sure to propagate the relations from the upper drivers.
    //

    //
    //  The current number of PDOs
    //
    relationCount = ( Irp->IoStatus.Information == 0 ) ? 0 :
        ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Count;

    //
    //  If we have not yet enumerated the hardware tree or all of our
    //  devices have been removed, enumerate it now.
    //
    if ( fdoExtension->NumPDOs == 0 ) {

        INTERFACE_TYPE InterfaceType;
        //
        //  Query the registry hardware tree to find out how many floppy
        //  drives were reported by the firmware.
        //
        for ( InterfaceType = 0;
              InterfaceType < MaximumInterfaceType;
              InterfaceType++ ) {

            CONFIGURATION_TYPE Dc = DiskController;
            CONFIGURATION_TYPE Fp = FloppyDiskPeripheral;

            ntStatus = IoQueryDeviceDescription(&InterfaceType,
                                              NULL,
                                              &Dc,
                                              NULL,
                                              &Fp,
                                              NULL,
                                              FdcConfigCallBack,
                                              fdoExtension );

            if (!NT_SUCCESS(ntStatus) && (ntStatus != STATUS_OBJECT_NAME_NOT_FOUND)) {

                return ntStatus;
            }
        }
    }

    FdcDump( FDCSHOW, ("FdcQueryDeviceRelations: My relations count - %d\n", fdoExtension->NumPDOs));

    relationLength = sizeof(DEVICE_RELATIONS) +
        (relationCount + fdoExtension->NumPDOs) * sizeof (PDEVICE_OBJECT);

    relations = (PDEVICE_RELATIONS) ExAllocatePool (NonPagedPool, relationLength);

    if ( relations == NULL ) {

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Copy in the device objects so far
    //
    if ( relationCount ) {
        RtlCopyMemory( relations->Objects,
                       ((PDEVICE_RELATIONS) Irp->IoStatus.Information)->Objects,
                       relationCount * sizeof (PDEVICE_OBJECT));
    }
    relations->Count = relationCount + fdoExtension->NumPDOs;

    //
    // For each PDO on this bus add a pointer to the device relations
    // buffer, being sure to take out a reference to that object.
    // The PlugPlay system will dereference the object when it is done with
    // it and free the device relations buffer.
    //
    for (entry = fdoExtension->PDOs.Flink;
         entry != &fdoExtension->PDOs;
         entry = entry->Flink, relationCount++) {

        pdoExtension = CONTAINING_RECORD( entry, FDC_PDO_EXTENSION, PdoLink );
        relations->Objects[relationCount] = pdoExtension->Self;
        ObReferenceObject( pdoExtension->Self );
    }

    //
    // Set up and pass the IRP further down the stack
    //
    Irp->IoStatus.Status = STATUS_SUCCESS;

    if ( Irp->IoStatus.Information != 0) {

        ExFreePool ((PVOID) Irp->IoStatus.Information);
    }

    Irp->IoStatus.Information = (UINT_PTR) relations;

    IoSkipCurrentIrpStackLocation( Irp );
    ntStatus = IoCallDriver( fdoExtension->TargetObject, Irp );

    return ntStatus;
}


NTSTATUS
FdcConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    )
/*++

Routine Description:

Arguments:

    Context - Pointer to our FDO extension

    PathName - unicode registry path.  Not Used.

    BusType - Internal, Isa, ...

    BusNumber - Which bus if we are on a multibus system.

    BusInformation - Configuration information about the bus. Not Used.

    ControllerType - Should always be DiskController.

    ControllerNumber - Which controller if there is more than one
                       controller in the system.

    ControllerInformation - Array of pointers to the three pieces of
                            registry information.

    PeripheralType - Should always be FloppyDiskPeripheral.

    PeripheralNumber - Which floppy if this controller is maintaining
                       more than one.

    PeripheralInformation - Arrya of pointers to the three pieces of
                            registry information.

Return Value:

    STATUS_SUCCESS if everything went ok, or STATUS_INSUFFICIENT_RESOURCES
    if it couldn't map the base csr or acquire the adapter object, or
    all of the resource information couldn't be acquired.

--*/
{

    PFDC_FDO_EXTENSION fdoExtension = (PFDC_FDO_EXTENSION)Context;
    NTSTATUS ntStatus;
    UNICODE_STRING pdoName;
    WCHAR   pdoNameBuffer[32];
    PDEVICE_OBJECT newPdo;
    PFDC_PDO_EXTENSION pdoExtension;
    USHORT floppyCount;

    FdcDump( FDCSHOW, ("FdcConfigCallBack:\n") );

    //
    //  Verify that this floppy disk drive is on the current
    //  floppy disk controller.
    //
    {
        USHORT i;
        BOOLEAN thisController = FALSE;
        PCM_FULL_RESOURCE_DESCRIPTOR controllerData =
            (PCM_FULL_RESOURCE_DESCRIPTOR)
            (((PUCHAR)ControllerInformation[IoQueryDeviceConfigurationData]) +
            ControllerInformation[IoQueryDeviceConfigurationData]->DataOffset);

        for ( i = 0;
              i < controllerData->PartialResourceList.Count;
              i++ ) {

            PCM_PARTIAL_RESOURCE_DESCRIPTOR partial =
                &controllerData->PartialResourceList.PartialDescriptors[i];

            FdcDump( FDCSHOW, ("FdcConfigCallBack: resource type = %x\n",partial->Type) );

            switch (partial->Type) {

            case CmResourceTypePort: {

                PUCHAR address;

                address = FdcGetControllerBase( BusType,
                                                BusNumber,
                                                partial->u.Port.Start,
                                                partial->u.Port.Length,
                                                (BOOLEAN)!!partial->Flags );

                FdcDump( FDCSHOW, ("FdcConfigCallBack: DriveControl = %04x %04x\n",fdoExtension->ControllerAddress.DriveControl,address + (IsNEC_98 ? 4 : 2) ));
                if ( fdoExtension->ControllerAddress.DriveControl == address + (IsNEC_98 ? 4 : 2)) {
                    thisController = TRUE;
                }
                }
                break;

            default:

                break;
            }
        }
        if ( !thisController ) {
            return STATUS_SUCCESS;
        }
    }

    floppyCount = (USHORT)(IoGetConfigurationInformation()->FloppyCount);
    swprintf(pdoNameBuffer, L"\\Device\\FloppyPDO%d", floppyCount);
    RtlInitUnicodeString(&pdoName, pdoNameBuffer);

    ntStatus = IoCreateDevice( fdoExtension->Self->DriverObject,
                               sizeof(FDC_PDO_EXTENSION),
                               &pdoName,
                               FILE_DEVICE_DISK,
                               (FILE_REMOVABLE_MEDIA |
                                FILE_FLOPPY_DISKETTE |
                                FILE_DEVICE_SECURE_OPEN),
                               FALSE,
                               &newPdo);

    if ( !NT_SUCCESS(ntStatus) ) {

        FdcDump( FDCSHOW, ("FdcConfigCallBack: Error - %08x\n", ntStatus) );
        return ntStatus;
    }

    FdcDump( FDCSHOW, ("FdcConfigCallBack: Created Device %d\n", floppyCount) );

    IoGetConfigurationInformation()->FloppyCount += 1;

    pdoExtension = (PFDC_PDO_EXTENSION) newPdo->DeviceExtension;

    pdoExtension->TargetObject = fdoExtension->Self;

    pdoExtension->IsFDO = FALSE;
    pdoExtension->Self = newPdo;
    pdoExtension->DeviceType = FloppyDiskDevice;

    pdoExtension->ParentFdo = fdoExtension->Self;

    pdoExtension->Instance = floppyCount + 1;
    pdoExtension->Removed = FALSE; // no irp_mn_remove as of yet

    fdoExtension->BusType = BusType;
    fdoExtension->BusNumber = BusNumber;
    fdoExtension->ControllerNumber = ControllerNumber;
    pdoExtension->PeripheralNumber = PeripheralNumber;

    newPdo->Flags |= DO_DIRECT_IO;
    newPdo->Flags |= DO_POWER_PAGABLE;
    newPdo->StackSize += fdoExtension->Self->StackSize;
    newPdo->Flags &= ~DO_DEVICE_INITIALIZING;

    InsertTailList(&fdoExtension->PDOs, &pdoExtension->PdoLink);
    fdoExtension->NumPDOs++;

    return STATUS_SUCCESS;
}

NTSTATUS
FdcCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called only rarely by the I/O system; it's mainly
    for layered drivers to call.  All it does is complete the IRP
    successfully.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    Always returns STATUS_SUCCESS, since this is a null operation.

--*/

{
    UNREFERENCED_PARAMETER( DeviceObject );

    FdcDump(
        FDCSHOW,
        ("FdcCreateClose...\n")
        );

    //
    // Null operation.  Do not give an I/O boost since
    // no I/O was actually done.  IoStatus.Information should be
    // FILE_OPENED for an open; it's undefined for a close.
    //

    Irp->IoStatus.Status = STATUS_SUCCESS;
    Irp->IoStatus.Information = FILE_OPENED;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return STATUS_SUCCESS;
}

NTSTATUS
FdcInternalDeviceControl (
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
/*++

Routine Description:

    Determine if this Pnp request is directed towards an FDO or a PDO and
    pass the Irp on the the appropriate routine.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS ntStatus = STATUS_SUCCESS;
    PFDC_EXTENSION_HEADER extensionHeader;
    KIRQL oldIrq;

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    extensionHeader = (PFDC_EXTENSION_HEADER)DeviceObject->DeviceExtension;

    if ( extensionHeader->IsFDO ) {

        ntStatus = FdcFdoInternalDeviceControl( DeviceObject, Irp );

    } else {

        ntStatus = FdcPdoInternalDeviceControl( DeviceObject, Irp );
    }

    return ntStatus;
}

NTSTATUS
FdcPdoInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to perform a device I/O
    control function.

    Most irps are put onto the driver queue (IoStartPacket).  Some irps do not
    require touching the hardware and are handled right here.

    In some cases the irp cannot be put on the queue because it cannot be
    completed at IRQL_DISPATCH_LEVEL.  However, the driver queue must be empty
    before the irp can be completed.  In these cases, the queue is
    'synchronized' before completing the irp.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    STATUS_SUCCESS or STATUS_PENDING if recognized I/O control code,
    STATUS_INVALID_DEVICE_REQUEST otherwise.

--*/

{
    PFDC_PDO_EXTENSION pdoExtension;
    PFDC_FDO_EXTENSION fdoExtension;
    BOOLEAN isFDO;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpSp;
    PIO_STACK_LOCATION nextIrpSp;
    PISSUE_FDC_ADAPTER_BUFFER_PARMS adapterBufferParms;

    pdoExtension = (PFDC_PDO_EXTENSION)DeviceObject->DeviceExtension;
    fdoExtension = (PFDC_FDO_EXTENSION)pdoExtension->ParentFdo->DeviceExtension;

    if ( pdoExtension->Removed) {
        //
        // This bus has received the PlugPlay remove IRP.  It will no longer
        // respond to external requests.
        //
        ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest( Irp, IO_DISK_INCREMENT );
        return ntStatus;
    }

    irpSp = IoGetCurrentIrpStackLocation( Irp );

    FdcDump( FDCSHOW,
             ("FdcPdoInternalDeviceControl: %x\n",
             irpSp->Parameters.DeviceIoControl.IoControlCode) );

    switch ( irpSp->Parameters.DeviceIoControl.IoControlCode ) {

    case IOCTL_DISK_INTERNAL_GET_ENABLER: {

        if ( pdoExtension->DeviceType == FloppyControllerDevice ) {

            *(PBOOLEAN)irpSp->Parameters.DeviceIoControl.Type3InputBuffer = TRUE;

        } else {

            *(PBOOLEAN)irpSp->Parameters.DeviceIoControl.Type3InputBuffer = FALSE;
        }

        ntStatus = STATUS_SUCCESS;

        break;
        }

    case IOCTL_DISK_INTERNAL_GET_FDC_INFO:

        FcReportFdcInformation( pdoExtension, fdoExtension, irpSp );

        ntStatus = STATUS_SUCCESS;

        break;

#ifdef TOSHIBAJ
    case IOCTL_DISK_INTERNAL_ENABLE_3_MODE:
        FdcDump(FDCSHOW,("IOCTL_Enable_3_MODE\n"));
        ntStatus = FcFdcEnable3Mode( fdoExtension , Irp );
        break;

    case    IOCTL_DISK_INTERNAL_AVAILABLE_3_MODE:
        FdcDump(FDCSHOW,("IOCTL_Availabe_3_MODE\n"));
        ntStatus = FcFdcAvailable3Mode( fdoExtension , Irp );
        break;
#endif

    default:

        IoSkipCurrentIrpStackLocation( Irp );

        //
        // Call the driver and request the operation
        //
        return IoCallDriver( pdoExtension->TargetObject, Irp );
    }

    Irp->IoStatus.Status = ntStatus;
    IoCompleteRequest( Irp, IO_DISK_INCREMENT );

    return ntStatus;
}

NTSTATUS
FdcFdoInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is called by the I/O system to perform a device I/O
    control function.

    Most irps are put onto the driver queue (IoStartPacket).  Some irps do not
    require touching the hardware and are handled right here.

    In some cases the irp cannot be put on the queue because it cannot be
    completed at IRQL_DISPATCH_LEVEL.  However, the driver queue must be empty
    before the irp can be completed.  In these cases, the queue is
    'synchronized' before completing the irp.

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

    STATUS_SUCCESS or STATUS_PENDING if recognized I/O control code,
    STATUS_INVALID_DEVICE_REQUEST otherwise.

--*/

{
    PFDC_FDO_EXTENSION fdoExtension;
    NTSTATUS ntStatus;
    PIO_STACK_LOCATION irpSp;
    PIO_STACK_LOCATION nextIrpSp;
    PISSUE_FDC_ADAPTER_BUFFER_PARMS adapterBufferParms;
    BOOLEAN powerQueueClear = FALSE;
    PLIST_ENTRY deferredRequest;
    PIRP currentIrp;
    ULONG ioControlCode;
    PFDC_DISK_CHANGE_PARMS fdcDiskChangeParms;
    PUCHAR dataRate;
    UCHAR tapeMode;
    PUCHAR precomp;
    PISSUE_FDC_COMMAND_PARMS issueCommandParms;
    PSET_HD_BIT_PARMS setHdBitParams;

    fdoExtension = (PFDC_FDO_EXTENSION)DeviceObject->DeviceExtension;

    InterlockedIncrement( &fdoExtension->OutstandingRequests );

    if ( fdoExtension->Removed ) {
        //
        // This device has received the PlugPlay remove IRP.  It will no longer
        // respond to external requests.
        //
        if ( InterlockedDecrement(&fdoExtension->OutstandingRequests ) == 0 ) {
            KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
        }
        ntStatus = STATUS_DELETE_PENDING;
        Irp->IoStatus.Status = ntStatus;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return ntStatus;
    }

    //
    //  If we are in a non-working power state then just queue the irp
    //  for later execution.
    //
    if ( fdoExtension->CurrentPowerState > PowerSystemWorking ) {

        ExInterlockedInsertTailList( &fdoExtension->PowerQueue,
                                     &Irp->Tail.Overlay.ListEntry,
                                     &fdoExtension->PowerQueueSpinLock );

        ntStatus = STATUS_PENDING;

        IoMarkIrpPending( Irp );

        return ntStatus;

    }

    do {

        deferredRequest = ExInterlockedRemoveHeadList( &fdoExtension->PowerQueue,
                                                       &fdoExtension->PowerQueueSpinLock );

        if ( deferredRequest == NULL ) {

            currentIrp = Irp;
            powerQueueClear = TRUE;

        } else {

            currentIrp = CONTAINING_RECORD( deferredRequest, IRP, Tail.Overlay.ListEntry );
        }

        irpSp = IoGetCurrentIrpStackLocation( currentIrp );

        FdcDump( FDCSHOW,
                 ("FdcFdoInternalDeviceControl: %x\n",
                 irpSp->Parameters.DeviceIoControl.IoControlCode) );

        ioControlCode = irpSp->Parameters.DeviceIoControl.IoControlCode;

        //
        //  GET_ENABLER and GET_FDC_INFO are handled in the PDO, not the FDO.
        //
        if ( ioControlCode == IOCTL_DISK_INTERNAL_GET_ENABLER ||
             ioControlCode == IOCTL_DISK_INTERNAL_GET_FDC_INFO ) {

            ntStatus = STATUS_INVALID_DEVICE_REQUEST;

        //
        //  If the controller is not acquired (in use) then then only
        //  operation that is allowed is to acquire the fdc.
        //
        } else if ( !fdoExtension->ControllerInUse &&
                    ioControlCode != IOCTL_DISK_INTERNAL_ACQUIRE_FDC ) {

            ntStatus = STATUS_INVALID_DEVICE_REQUEST;

        } else {

            switch ( ioControlCode ) {

            case IOCTL_DISK_INTERNAL_ACQUIRE_FDC:

                //
                // Try to Acquire the Fdc.  If the Fdc is busy, this call will
                // time out.
                //
                ntStatus = FcAcquireFdc(
                                    fdoExtension,
                                    (PLARGE_INTEGER)irpSp->
                                    Parameters.DeviceIoControl.Type3InputBuffer );
                //
                // Return the device object of the last device that called this
                // driver.  This can be used to determine if any other drivers
                // have messed with the fdc since it was last acquired.
                //
                if ( NT_SUCCESS(ntStatus) ) {

                    irpSp->Parameters.DeviceIoControl.Type3InputBuffer =
                                                    fdoExtension->LastDeviceObject;
                }
                break;

            case IOCTL_DISK_INTERNAL_ENABLE_FDC_DEVICE:

                //
                // Turn the motor on and select a floppy channel
                //
                ntStatus = FcTurnOnMotor( fdoExtension, irpSp );

                break;

            case IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND:

                issueCommandParms =
                    (PISSUE_FDC_COMMAND_PARMS)
                    irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                ntStatus = FcIssueCommand( fdoExtension,
                                           issueCommandParms->FifoInBuffer,
                                           issueCommandParms->FifoOutBuffer,
                                           issueCommandParms->IoHandle,
                                           issueCommandParms->IoOffset,
                                           issueCommandParms->TransferBytes );


                break;

            case IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND_QUEUED:

                IoMarkIrpPending( Irp );

                IoStartPacket( DeviceObject,
                               Irp,
                               NULL,
                               NULL );

                ntStatus = STATUS_PENDING;

                break;

            case IOCTL_DISK_INTERNAL_RESET_FDC:

                ntStatus = FcInitializeControllerHardware( fdoExtension,
                                                           DeviceObject );
                break;

            case IOCTL_DISK_INTERNAL_RELEASE_FDC:

                ntStatus = FcReleaseFdc( fdoExtension );
                //
                // Save the DeviceObject of the releasing device.  This is
                // returned with the subsequent acquire fdc request and
                // can be used to determine whether the floppy controller
                // has been messed with between release and acquisition
                //
                if ( NT_SUCCESS(ntStatus) ) {

                    fdoExtension->LastDeviceObject =
                        irpSp->Parameters.DeviceIoControl.Type3InputBuffer;
                }

                break;

            case IOCTL_DISK_INTERNAL_GET_ADAPTER_BUFFER:
                //
                // Allocate an MDL for the passed in buffer.
                //
                adapterBufferParms = (PISSUE_FDC_ADAPTER_BUFFER_PARMS)
                            irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                adapterBufferParms->Handle =
                             IoAllocateMdl( adapterBufferParms->IoBuffer,
                                            adapterBufferParms->TransferBytes,
                                            FALSE,
                                            FALSE,
                                            NULL );

                if ( adapterBufferParms->Handle == NULL ) {

                    ntStatus = STATUS_INSUFFICIENT_RESOURCES;

                } else {

                    MmBuildMdlForNonPagedPool( adapterBufferParms->Handle );

                    ntStatus = STATUS_SUCCESS;
                }

                break;

            case IOCTL_DISK_INTERNAL_FLUSH_ADAPTER_BUFFER:
                //
                // Free the MDL
                //
                adapterBufferParms = (PISSUE_FDC_ADAPTER_BUFFER_PARMS)
                            irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                if ( adapterBufferParms->Handle != NULL ) {

                    IoFreeMdl( adapterBufferParms->Handle );
                }

                ntStatus = STATUS_SUCCESS;

                break;

            case IOCTL_DISK_INTERNAL_FDC_START_READ:
            case IOCTL_DISK_INTERNAL_FDC_START_WRITE:

                ntStatus = STATUS_SUCCESS;

                if ( fdoExtension->FdcEnablerSupported ) {

                    FDC_MODE_SELECT fdcModeSelect;

                    fdcModeSelect.structSize = sizeof(fdcModeSelect);
                    //
                    // Reading from the media means writing to DMA memory and
                    // visa-versa for writing to the media.
                    //
                    if ( irpSp->Parameters.DeviceIoControl.IoControlCode ==
                         IOCTL_DISK_INTERNAL_FDC_START_READ ) {

                        fdcModeSelect.DmaDirection = FDC_WRITE_TO_MEMORY;

                    } else {

                        fdcModeSelect.DmaDirection = FDC_READ_FROM_MEMORY;
                    }

                    ntStatus = FcFdcEnabler(
                                    fdoExtension->FdcEnablerDeviceObject,
                                    IOCTL_SET_FDC_MODE,
                                    &fdcModeSelect);
                }
                break;

            case IOCTL_DISK_INTERNAL_DISABLE_FDC_DEVICE:

                ntStatus = FcTurnOffMotor( fdoExtension );

                break;

            case IOCTL_DISK_INTERNAL_GET_FDC_DISK_CHANGE:

                FdcDump(FDCINFO, ("Fdc: Read Disk Change\n") );

                fdcDiskChangeParms =
                    (PFDC_DISK_CHANGE_PARMS)irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                if (IsNEC_98) {
                    if((fdoExtension->ResultStatus0[fdcDiskChangeParms->DriveOnValue] &
                        STREG0_END_MASK) == STREG0_END_DRIVE_NOT_READY){

                        fdcDiskChangeParms->DriveStatus = DSKCHG_DISKETTE_REMOVED;
                    } else {

                        fdoExtension->ResultStatus0[fdcDiskChangeParms->DriveOnValue] = 0;
                        fdcDiskChangeParms->DriveStatus = DSKCHG_RESERVED;
                    }
                } else { // (IsNEC_98)
                    fdcDiskChangeParms->DriveStatus = READ_CONTROLLER(
                                                            fdoExtension->ControllerAddress.DRDC.DiskChange );
                    //
                    //  If we just waked up from hibernation, simulate a disk
                    //  change event so the upper levels will be sure to check
                    //  this disk.
                    //
                    if ( fdoExtension->WakeUp ) {

                        fdcDiskChangeParms->DriveStatus |= DSKCHG_DISKETTE_REMOVED;
                        fdoExtension->WakeUp = FALSE;
                    }
                } // (IsNEC_98)

                ntStatus = STATUS_SUCCESS;

                break;

            case IOCTL_DISK_INTERNAL_SET_FDC_DATA_RATE:

                if (IsNEC_98) {
                    //
                    // NEC98 have no function and have no DRDC.DataRate register.
                    //
                } else { // (IsNEC_98)
                    dataRate =
                        (PUCHAR)irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                    FdcDump(FDCINFO, ("Fdc: Write Data Rate: %x\n", *dataRate) );

                    WRITE_CONTROLLER( fdoExtension->ControllerAddress.DRDC.DataRate,
                                      *dataRate );

                } // (IsNEC_98)
                ntStatus = STATUS_SUCCESS;

                break;

            case IOCTL_DISK_INTERNAL_SET_FDC_TAPE_MODE:

                if (IsNEC_98) {
                    //
                    // NEC98 have no Tape register.
                    //
                } else { // (IsNEC_98)

                    tapeMode = READ_CONTROLLER( fdoExtension->ControllerAddress.Tape );
                    tapeMode &= 0xfc;
                    tapeMode |=
                        *((PUCHAR)irpSp->Parameters.DeviceIoControl.Type3InputBuffer);

                    FdcDump(FDCINFO,
                            ("Fdc: Write Tape Mode Register: %x\n", tapeMode)
                            );

                    WRITE_CONTROLLER(
                        fdoExtension->ControllerAddress.Tape,
                        tapeMode );

                } // (IsNEC_98)
                ntStatus = STATUS_SUCCESS;

                break;

            case IOCTL_DISK_INTERNAL_SET_FDC_PRECOMP:

                precomp = (PUCHAR)irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                FdcDump(FDCINFO,
                        ("Fdc: Write Precomp: %x\n", *precomp)
                        );

                WRITE_CONTROLLER(
                    fdoExtension->ControllerAddress.Status,
                    *precomp );

                ntStatus = STATUS_SUCCESS;

                break;

            case IOCTL_DISK_INTERNAL_SET_HD_BIT:

                if (IsNEC_98) {

                    FdcDump(FDCINFO,
                            ("Fdc: Set Hd Bit: \n")
                            );
                    setHdBitParams = (PSET_HD_BIT_PARMS)irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

                    FdcHdbit(DeviceObject, fdoExtension, setHdBitParams);

                    ntStatus = STATUS_SUCCESS;

                    break;
                } // (IsNEC_98)

                //
                // If not NEC98, then pass through to "default:".
                //

            default:
                //
                // Mark the Irp pending and queue it.
                //
                ntStatus = STATUS_INVALID_DEVICE_REQUEST;

                break;
            }
        }

        if ( ntStatus != STATUS_PENDING ) {

            if ( InterlockedDecrement(&fdoExtension->OutstandingRequests ) == 0 ) {
                KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
            }
            currentIrp->IoStatus.Status = ntStatus;
            IoCompleteRequest( currentIrp, IO_DISK_INCREMENT );
        }

    } while ( !powerQueueClear );

    return ntStatus;
}

VOID
FcReportFdcInformation(
    IN      PFDC_PDO_EXTENSION PdoExtension,
    IN      PFDC_FDO_EXTENSION FdoExtension,
    IN OUT  PIO_STACK_LOCATION IrpSp
    )

/*++

Routine Description:

    This routine reports information about the Floppy Disk Controller
    that a higher level driver might need; primarily information
    regarding the DMA Adapter.

Arguments:

    fdoExtension    - Pointer to this device's extension data.

    IrpSp           - Pointer to the current Irp

Return Value:

    STATUS_SUCCESS

--*/

{
    PFDC_INFO fdcInfo;
    ULONG bufferCount;
    ULONG bufferSize;
    ULONG i;

    FdcDump( FDCINFO, ("Fdc: Report FDC Information\n") );

    fdcInfo = (PFDC_INFO)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    //
    // save the requested buffer count and buffer size.
    //
    bufferCount = fdcInfo->BufferCount;
    bufferSize =  fdcInfo->BufferSize;

    //
    // fill in the floppy controller hardware information
    //
    fdcInfo->BusType = FdoExtension->BusType;
    fdcInfo->BusNumber = FdoExtension->BusNumber;
    fdcInfo->ControllerNumber = FdoExtension->ControllerNumber;
    if (IsNEC_98) {
        UCHAR floppyEquip;
        ULONG disketteCount = 0;

        floppyEquip = FdoExtension->FloppyEquip;

        //
        // Make PeripheralNumber.
        //
        for (i = 0 ; i < 4 ; i++) {

            if ((floppyEquip & 0x1) != 0) {

                disketteCount++;

                if(disketteCount > PdoExtension->PeripheralNumber){

                    break;
                }
            }
            floppyEquip = floppyEquip >> 1;
        }

        fdcInfo->UnitNumber = (UCHAR)i;
    } else {
        //
        // Only NEC98 is using it now, put Zero into UnitNumber.
        //
        fdcInfo->UnitNumber = 0;
    }
    fdcInfo->PeripheralNumber = PdoExtension->PeripheralNumber;

    fdcInfo->FloppyControllerType = FdoExtension->FdcType;
    fdcInfo->SpeedsAvailable = FdoExtension->FdcSpeeds;

    fdcInfo->MaxTransferSize = FdoExtension->NumberOfMapRegisters * PAGE_SIZE;

    fdcInfo->BufferSize = 0;
    fdcInfo->BufferCount = 0;

    if ( bufferSize <= FdoExtension->BufferSize ) {

        fdcInfo->BufferSize = bufferSize;
        fdcInfo->BufferCount = MIN( bufferCount,
                                    FdoExtension->BufferCount );
        FdoExtension->BuffersRequested = MAX( fdcInfo->BufferCount,
                                              FdoExtension->BuffersRequested );
    }

    for ( i = 0 ; i < fdcInfo->BufferCount ; i++ ) {

        fdcInfo->BufferAddress[i].Logical =
                                    FdoExtension->TransferBuffers[i].Logical;
        fdcInfo->BufferAddress[i].Virtual =
                                    FdoExtension->TransferBuffers[i].Virtual;
    }
}

VOID
FdcStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

    DeviceObject - a pointer to the object that represents the device
    that I/O is to be done on.

    Irp - a pointer to the I/O Request Packet for this request.

Return Value:

--*/

{
    PIO_STACK_LOCATION irpSp;
    NTSTATUS ntStatus;
    ULONG formatExParametersSize;
    PUCHAR diskChange;
    PUCHAR dataRate;
    PUCHAR tapeMode;
    PUCHAR precomp;
    PFDC_FDO_EXTENSION fdoExtension;
    PISSUE_FDC_COMMAND_PARMS issueCommandParms;
    PKDEVICE_QUEUE_ENTRY request;

    FdcDump( FDCSHOW, ("FdcStartIo...\n") );

    fdoExtension = DeviceObject->DeviceExtension;

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    ntStatus = STATUS_SUCCESS;

    switch( irpSp->Parameters.DeviceIoControl.IoControlCode ) {

        case IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND_QUEUED:

            issueCommandParms =
                (PISSUE_FDC_COMMAND_PARMS)
                irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

            if ( CommandTable[issueCommandParms->FifoInBuffer[0] &
                                            COMMAND_MASK].InterruptExpected ) {

                fdoExtension->CurrentDeviceObject = DeviceObject;
                fdoExtension->AllowInterruptProcessing = TRUE;
                fdoExtension->CommandHasResultPhase = FALSE;
                fdoExtension->InterruptTimer =
                    issueCommandParms->TimeOut ?
                    issueCommandParms->TimeOut + 1 : START_TIMER;
                fdoExtension->CurrentIrp = Irp;

            }

            ntStatus = FcStartCommand( fdoExtension,
                                       issueCommandParms->FifoInBuffer,
                                       issueCommandParms->FifoOutBuffer,
                                       issueCommandParms->IoHandle,
                                       issueCommandParms->IoOffset,
                                       issueCommandParms->TransferBytes,
                                       FALSE );

            if ( NT_SUCCESS( ntStatus )) {

                if ( CommandTable[issueCommandParms->FifoInBuffer[0] &
                                            COMMAND_MASK].InterruptExpected ) {

                    ntStatus = STATUS_PENDING;

                } else {

                    ntStatus = FcFinishCommand(
                                    fdoExtension,
                                    issueCommandParms->FifoInBuffer,
                                    issueCommandParms->FifoOutBuffer,
                                    issueCommandParms->IoHandle,
                                    issueCommandParms->IoOffset,
                                    issueCommandParms->TransferBytes,
                                    FALSE );

                }

            }

            break;

        default: {

            FdcDump(
                FDCDBGP,
                ("Fdc: invalid device request %x\n",
                irpSp->Parameters.DeviceIoControl.IoControlCode)
                );

            ntStatus = STATUS_INVALID_DEVICE_REQUEST;

            break;
        }
    }

    if ( ntStatus != STATUS_PENDING ) {
        Irp->IoStatus.Status = ntStatus;
        if (!NT_SUCCESS( ntStatus ) &&
            IoIsErrorUserInduced( ntStatus )) {

            IoSetHardErrorOrVerifyDevice( Irp, DeviceObject );
        }

        IoStartNextPacket( DeviceObject, FALSE );
    }
}

NTSTATUS
FcAcquireFdc(
    IN      PFDC_FDO_EXTENSION  FdoExtension,
    IN      PLARGE_INTEGER  TimeOut
    )

/*++

Routine Description:

    This routine acquires the floppy disk controller.  This includes
    allocating the adapter channel and connecting the interrupt.

    NOTE - This is where the sharing mechanism will be put into
    this driver.  That is, higher level drivers will 'reserve' the
    floppy controller with this ioctl.  Subsequent calls to this driver
    that are not from the 'reserving' drive will be rejected with a
    BUSY status.

Arguments:

    DeviceObject    - Device object for the current device

Return Value:

    STATUS_DEVICE_BUSY if we don't have the controller, otherwise
    STATUS_SUCCESS

--*/

{
    NTSTATUS ntStatus;

    FdcDump(FDCINFO,
           ("Fdc: Acquire the Floppy Controller\n")
           );

    //
    // Wait for the Fdc, either from the enabler or directly here.  Semaphores
    // are used to synchronize usage of the Fdc hardware.  If somebody else is
    // using the floppy controller now we must wait for them to finish.  If
    // this takes too long we will just let the caller know that the device is
    // busy.
    //
    if (FdoExtension->FdcEnablerSupported) {

        ntStatus = FcFdcEnabler( FdoExtension->FdcEnablerDeviceObject,
//                               IOCTL_ACQUIRE_FDC, // For spelling miss in flpyenbl.h
                                 IOCTL_AQUIRE_FDC,
                                 TimeOut);
    } else {

        ntStatus = KeWaitForSingleObject( FdoExtension->AcquireEvent,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          TimeOut );

        if ( ntStatus == STATUS_TIMEOUT ) {

            ntStatus = STATUS_DEVICE_BUSY;
        }
    }

    if ( NT_SUCCESS(ntStatus) ) {
        //
        // Lock down the driver code in memory.
        //

        FDC_PAGE_RESET_DRIVER_WITH_MUTEX;

        //
        // Allocate the adapter channel
        //
        FcAllocateAdapterChannel( FdoExtension );

        IoStartTimer(FdoExtension->Self);

        if (IsNEC_98) {
            //
            // NEC98's FDD driver can't not disconnect interrupt,
            // and can't not page out this driver. Because when a FD is inserted in FDD or
            // is ejected from FDD, then H/W calls FDD driver's interrupt routine.
            //
            ntStatus = STATUS_SUCCESS;

        } else { // (IsNEC_98)

            //
            // Connect the Interrupt
            //
            ntStatus = IoConnectInterrupt(&FdoExtension->InterruptObject,
                                        FdcInterruptService,
                                        FdoExtension,
                                        NULL,
                                        FdoExtension->ControllerVector,
                                        FdoExtension->ControllerIrql,
                                        FdoExtension->ControllerIrql,
                                        FdoExtension->InterruptMode,
                                        FdoExtension->SharableVector,
                                        FdoExtension->ProcessorMask,
                                        FdoExtension->SaveFloatState);
        } // (IsNEC_98)

        if ( NT_SUCCESS( ntStatus ) ) {
            FdoExtension->ControllerInUse = TRUE;
        } else {
            FcFreeAdapterChannel( FdoExtension );
            IoStopTimer(FdoExtension->Self);
        }
    } else {

        ntStatus = STATUS_DEVICE_BUSY;
    }

    return ntStatus;
}

NTSTATUS
FcReleaseFdc(
    IN      PFDC_FDO_EXTENSION  FdoExtension
    )

/*++

Routine Description:

    This routine releaese the floppy disk controller.  This includes
    freeing the adapter channel and disconnecting the interrupt.

    NOTE - This is where the sharing mechanism will be put into
    this driver.  That is, higher level drivers will 'reserve' the
    floppy controller with this ioctl.  Subsequent calls to this driver
    that are not from the 'reserving' drive will be rejected with a
    BUSY status.

Arguments:

    fdoExtension    - Pointer to this device's extension data.

Return Value:

    STATUS_DEVICE_BUSY if we don't have the controller, otherwise
    STATUS_SUCCESS

--*/

{
    FdcDump(FDCINFO, ("Fdc: Release the Floppy Controller\n") );

    //
    // Free the Adapter Channel
    //
    FcFreeAdapterChannel( FdoExtension );

    FdoExtension->AllowInterruptProcessing = FALSE;
    FdoExtension->ControllerInUse = FALSE;

    if (IsNEC_98) {
        //
        // NEC98's FDD driver can't not disconnect interrupt,
        // and can't not page out this driver. Because when a FD is inserted in FDD or
        // is ejected from FDD, then H/W calls FDD driver's interrupt routine.
        //

    } else { // (IsNEC_98)
        //
        // Disconnect the Interrupt
        //
        IoDisconnectInterrupt(FdoExtension->InterruptObject);

    } // (IsNEC_98)

    IoStopTimer(FdoExtension->Self);

    FDC_PAGE_ENTIRE_DRIVER_WITH_MUTEX;

    //
    // Release the Fdc Enabler card if there is one.  Otherwise, set the
    // floppy synchronization event.
    //
    if (FdoExtension->FdcEnablerSupported) {

        FcFdcEnabler( FdoExtension->FdcEnablerDeviceObject,
                      IOCTL_RELEASE_FDC,
                      NULL);
    } else {

        KeSetEvent( FdoExtension->AcquireEvent,
                    (KPRIORITY) 0,
                    FALSE );
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FcTurnOnMotor(
    IN      PFDC_FDO_EXTENSION  FdoExtension,
    IN OUT  PIO_STACK_LOCATION   IrpSp
    )

/*++

Routine Description:

    This routine turns on the motor if it not already running.

Arguments:

    fdoExtension    - Pointer to this device's extension data.

    IrpSp           - Pointer to the current Irp

Return Value:

    STATUS_DEVICE_BUSY if we don't have the controller, otherwise
    STATUS_SUCCESS

--*/

{
    UCHAR driveStatus;
    UCHAR newStatus;
    LARGE_INTEGER motorOnDelay;
    PFDC_ENABLE_PARMS fdcEnableParms;

    USHORT      lpc;
    UCHAR       resultStatus0Save[4];

    fdcEnableParms =
        (PFDC_ENABLE_PARMS)IrpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    FdcDump(FDCINFO,
           ("Fdc: Turn Motor On: %x\n",fdcEnableParms->DriveOnValue)
           );

    driveStatus = FdoExtension->DriveControlImage;
    if (IsNEC_98) {

        newStatus = DRVCTL_MOTOR_MASK;

    } else { // (IsNEC_98)

        newStatus = fdcEnableParms->DriveOnValue |
                                    DRVCTL_ENABLE_CONTROLLER |
                                    DRVCTL_ENABLE_DMA_AND_INTERRUPTS;
    } // (IsNEC_98)

    if ( driveStatus != newStatus ) {

        // If the drive is not on then check to see if we have
        // the controller.  Otherwise we assume that we have
        // the controller since we give it up only when we
        // turn off the motor.

        if (IsNEC_98) {
            if(FdoExtension->MotorRunning == 0){

                //
                // save status
                //
                for(lpc=0;lpc<4;lpc++){
                    resultStatus0Save[lpc] = FdoExtension->ResultStatus0[lpc];
                }

                FdcDump(
                    FDCSHOW,
                    ("Floppy: Turn on motor!\n")
                    );

                FdoExtension->DriveControlImage = 0x18;
                FdoExtension->DriveControlImage |= DRVCTL_AI_ENABLE;

                WRITE_CONTROLLER(
                     FdoExtension->ControllerAddress.DriveControl,
                     FdoExtension->DriveControlImage );
                FdoExtension->MotorRunning = 1;
            }
        } else { // (IsNEC_98)

            if (!FdoExtension->CurrentInterrupt) {

                FdoExtension->CurrentInterrupt = TRUE;

                driveStatus = FdoExtension->DriveControlImage;
            }

            FdoExtension->AllowInterruptProcessing = TRUE;

            FdoExtension->DriveControlImage = newStatus;

            WRITE_CONTROLLER(
                FdoExtension->ControllerAddress.DriveControl,
                FdoExtension->DriveControlImage );

        } // (IsNEC_98)


        if (fdcEnableParms->TimeToWait > 0) {

            if (IsNEC_98) {

                //
                // check if motor is on or not.
                //
                if(FdoExtension->MotorRunning == 1){
                    FdoExtension->MotorRunning = 2;
                    motorOnDelay.LowPart = (unsigned long)(- ( 10 * 1000 * 1000 ));
                    motorOnDelay.HighPart = -1;
                    KeDelayExecutionThread( KernelMode, FALSE, &motorOnDelay );

                    //
                    // after sense, restore status
                    //
                    for(lpc=0;lpc<4;lpc++){
                        FdoExtension->ResultStatus0[lpc] = resultStatus0Save[lpc];
                    }
                }

            } else { // (IsNEC_98)

                motorOnDelay.LowPart =
                    - ( 10 * 1000 * fdcEnableParms->TimeToWait );
                motorOnDelay.HighPart = -1;

                FdoExtension->LastMotorSettleTime = motorOnDelay;

                KeDelayExecutionThread( KernelMode, FALSE, &motorOnDelay );

            } // (IsNEC_98)

        }

        fdcEnableParms->MotorStarted = TRUE;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
FcTurnOffMotor(
    IN      PFDC_FDO_EXTENSION  FdoExtension
    )

/*++

Routine Description:

    This routine turns off all motors.  By default, Drive A is left selected
    by this routine since it is not possible to deselect all drives.  On a
    Power PC, drive D is left selected.

Arguments:

    fdoExtension   - Supplies the fdc extension.

Return Value:

    None.

--*/

{

    FdcDump(FDCINFO,
           ("Fdc: Turn Motor Off\n")
           );

    if (IsNEC_98) {

        if (FdoExtension->MotorRunning != 0){

            FdoExtension->DriveControlImage
                    = READ_CONTROLLER(FdoExtension->ControllerAddress.DriveControl);

            FdoExtension->DriveControlImage = 0x10;
            FdoExtension->DriveControlImage |= DRVCTL_AI_ENABLE;

            WRITE_CONTROLLER(
                    FdoExtension->ControllerAddress.DriveControl,
                    FdoExtension->DriveControlImage );

            if (FdoExtension->CurrentInterrupt) {
                FdoExtension->CurrentInterrupt = FALSE;

                KeSetEvent(FdoExtension->AcquireEvent,
                    (KPRIORITY) 0,
                    FALSE);
            }
            FdoExtension->MotorRunning = 0;
        }
    } else { // (IsNEC_98)

        FdoExtension->DriveControlImage =
            DRVCTL_ENABLE_DMA_AND_INTERRUPTS +
#ifdef _PPC_
            DRVCTL_DRIVE_MASK +
#endif
            DRVCTL_ENABLE_CONTROLLER;

        WRITE_CONTROLLER(
            FdoExtension->ControllerAddress.DriveControl,
            FdoExtension->DriveControlImage );

    } // (IsNEC_98)

    return STATUS_SUCCESS;
}

VOID
FcAllocateAdapterChannel(
    IN OUT  PFDC_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine allocates an adapter channel.  The caller of
    IoAllocateAdapterChannel routine must wait for the
    'AllocateAdapterChannelEvent' to be signalled before trying to use the
    adapter channel.

Arguments:

    fdoExtension   - Supplies the fdc extension.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    if ( (FdoExtension->AdapterChannelRefCount)++ ) {
        return;
    }

    KeResetEvent( &FdoExtension->AllocateAdapterChannelEvent );

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    IoAllocateAdapterChannel( FdoExtension->AdapterObject,
                              FdoExtension->Self,
                              FdoExtension->NumberOfMapRegisters,
                              FdcAllocateAdapterChannel,
                              FdoExtension );

    KeLowerIrql( oldIrql );

    KeWaitForSingleObject( &FdoExtension->AllocateAdapterChannelEvent,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL);
}

VOID
FcFreeAdapterChannel(
    IN OUT  PFDC_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine frees the previously allocated adapter channel.

Arguments:

    fdoExtension   - Supplies the fdc extension.

Return Value:

    None.

--*/

{
    KIRQL oldIrql;

    if ( --(FdoExtension->AdapterChannelRefCount) ) {
        return;
    }

    KeRaiseIrql( DISPATCH_LEVEL, &oldIrql );

    IoFreeAdapterChannel( FdoExtension->AdapterObject );

    KeLowerIrql( oldIrql );
}

IO_ALLOCATION_ACTION
FdcAllocateAdapterChannel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    )

/*++

Routine Description:

    This DPC is called whenever the fdc.sys driver is trying to allocate
    the adapter channel.  It saves the MapRegisterBase in the controller data
    area, and sets the AllocateAdapterChannelEvent to awaken the thread.

Arguments:

    DeviceObject - unused.

    Irp - unused.

    MapRegisterBase - the base of the map registers that can be used
    for this transfer.

    Context - a pointer to our controller data area.

Return Value:

    Returns Allocation Action 'KeepObject' which means that the adapter
    object will be held for now (to be released explicitly later).

--*/
{
    PFDC_FDO_EXTENSION fdoExtension = Context;

    UNREFERENCED_PARAMETER( DeviceObject );
    UNREFERENCED_PARAMETER( Irp );

    fdoExtension->MapRegisterBase = MapRegisterBase;

    KeSetEvent( &fdoExtension->AllocateAdapterChannelEvent,
                0L,
                FALSE );

    return KeepObject;
}

VOID
FcLogErrorDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    )

/*++

Routine Description:

    This routine is merely used to log an error that we had to reset the device.

Arguments:

    Dpc - The dpc object.

    DeferredContext - A pointer to the controller data.

    SystemContext1 - Unused.

    SystemContext2 - Unused.

Return Value:

    Mapped address

--*/

{

    PIO_ERROR_LOG_PACKET errorLogEntry;
    PFDC_FDO_EXTENSION fdoExtension = DeferredContext;

    errorLogEntry = IoAllocateErrorLogEntry(
                        fdoExtension->DriverObject,
                        (UCHAR)(sizeof(IO_ERROR_LOG_PACKET))
                        );

    if ( errorLogEntry != NULL) {

        errorLogEntry->ErrorCode = IO_ERR_RESET;
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->UniqueErrorValue = 0;
        errorLogEntry->FinalStatus = STATUS_SUCCESS;
        errorLogEntry->DumpDataSize = 0;

        IoWriteErrorLogEntry(errorLogEntry);

    }

}

NTSTATUS
FcIssueCommand(
    IN OUT  PFDC_FDO_EXTENSION  FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes
    )

/*++

Routine Description:

    This routine sends the command and all parameters to the controller,
    waits for the command to interrupt if necessary, and reads the result
    bytes from the controller, if any.

    Before calling this routine, the caller should put the parameters for
    the command in ControllerData->FifoBuffer[].  The result bytes will
    be returned in the same place.

    This routine runs off the CommandTable.  For each command, this says
    how many parameters there are, whether or not there is an interrupt
    to wait for, and how many result bytes there are.  Note that commands
    without result bytes actually have two, since the ISR will issue a
    SENSE INTERRUPT STATUS command on their behalf.

Arguments:

    Command - a byte specifying the command to be sent to the controller.

    fdoExtension - a pointer to our data area for this controller.

Return Value:

    STATUS_SUCCESS if the command was sent and bytes received properly;
    appropriate error propogated otherwise.

--*/

{
    NTSTATUS ntStatus;
    NTSTATUS ntStatus2;
    UCHAR i;
    PUCHAR fifoBuffer;
    UCHAR Command;
    BOOLEAN NeedToFlush = FALSE;


    //
    // If this command causes an interrupt, set CurrentDeviceObject and
    // reset the interrupt event.
    //

    Command = FifoInBuffer[0];

    FdcDump( FDCINFO,
             ("FcIssueCommand: Issue Command : %x\n",
             CommandTable[Command & COMMAND_MASK].OpCode)
             );


    if ( CommandTable[Command & COMMAND_MASK].InterruptExpected ) {

        FdoExtension->CurrentDeviceObject = FdoExtension->Self;
        FdoExtension->AllowInterruptProcessing = TRUE;
        FdoExtension->CommandHasResultPhase =
            !!CommandTable[Command & COMMAND_MASK].FirstResultByte;

        KeResetEvent( &FdoExtension->InterruptEvent );
    }

    //
    // Start up the command
    //

    ntStatus = FcStartCommand( FdoExtension,
                               FifoInBuffer,
                               FifoOutBuffer,
                               IoHandle,
                               IoOffset,
                               TransferBytes,
                               TRUE );

    if ( NT_SUCCESS( ntStatus ) ) {

        //
        // If there is an interrupt, wait for it.
        //

        if ( CommandTable[Command & COMMAND_MASK].InterruptExpected ) {

            ntStatus = KeWaitForSingleObject(
                &FdoExtension->InterruptEvent,
                Executive,
                KernelMode,
                FALSE,
                &FdoExtension->InterruptDelay );

            if ( ntStatus == STATUS_TIMEOUT ) {

                //
                // Change info to an error.  We'll just say
                // that the device isn't ready.
                //

                ntStatus = STATUS_DEVICE_NOT_READY;

                FdoExtension->HardwareFailed = TRUE;
            }
        }

        //
        // If successful so far, get the result bytes.
        //

        if ( NT_SUCCESS( ntStatus ) ) {

            ntStatus = FcFinishCommand( FdoExtension,
                                        FifoInBuffer,
                                        FifoOutBuffer,
                                        IoHandle,
                                        IoOffset,
                                        TransferBytes,
                                        TRUE );

        }
    }

    return ntStatus;
}

NTSTATUS
FcStartCommand(
    IN OUT  PFDC_FDO_EXTENSION  FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes,
    IN      BOOLEAN         AllowLongDelay
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    NTSTATUS ntStatus;
    NTSTATUS ntStatus2;
    UCHAR i = 0;
    PUCHAR fifoBuffer;
    UCHAR Command;
    BOOLEAN NeedToFlush = FALSE;
    PIO_STACK_LOCATION irpSp;
    UCHAR status0;

    //
    // If this command causes an interrupt, set CurrentDeviceObject and
    // reset the interrupt event.
    //

    Command = FifoInBuffer[0];

    FdcDump( FDCINFO,
             ("FcStartCommand: Issue Command : %x\n",
             CommandTable[Command & COMMAND_MASK].OpCode)
             );

    FdoExtension->CommandHasResultPhase =
        !!CommandTable[Command & COMMAND_MASK].FirstResultByte;

    // First we will need to set up the data transfer if there is one associated
    // with this request.
    //
    if (CommandTable[Command & COMMAND_MASK].DataTransfer == FDC_READ_DATA ) {
        //
        // Setup Adapter Channel for Read
        //
        IoMapTransfer(FdoExtension->AdapterObject,
                      IoHandle,
                      FdoExtension->MapRegisterBase,
                      (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle ) + IoOffset ),
                      &TransferBytes,
                      FALSE);

    } else if (CommandTable[Command & COMMAND_MASK].DataTransfer ==
               FDC_WRITE_DATA ) {
        //
        // Setup Adapter Channel for Write
        //

        IoMapTransfer(FdoExtension->AdapterObject,
                      IoHandle,
                      FdoExtension->MapRegisterBase,
                      (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle ) + IoOffset ),
                      &TransferBytes,
                      TRUE);

    }

    //
    // Send the command to the controller.
    //
    if ( Command == COMMND_CONFIGURE ) {
        if ( FdoExtension->Clock48MHz ) {
            Command |= COMMND_OPTION_CLK48;
        }
    }
    ntStatus = FcSendByte( (UCHAR)(CommandTable[Command & COMMAND_MASK].OpCode |
                                  (Command & ~COMMAND_MASK)),
                           FdoExtension,
                           AllowLongDelay );

    //
    // If the command was successfully sent, we can proceed.
    //

    if ( NT_SUCCESS( ntStatus ) ) {

        //
        // Send the parameters as long as we succeed.
        //

        for ( i = 1;
            ( i <= CommandTable[Command & COMMAND_MASK].NumberOfParameters ) &&
                ( NT_SUCCESS( ntStatus ) );
            i++ ) {

            ntStatus = FcSendByte( FifoInBuffer[i],
                                   FdoExtension,
                                   AllowLongDelay );
            //
            // The Drive Specification is a special case since we don't really know
            // how many bytes to send until we encounter the DONE bit (or we have sent
            // the maximum allowable bytes).
            //
            if ((Command == COMMND_DRIVE_SPECIFICATION) &&
                (FifoInBuffer[i] & COMMND_DRIVE_SPECIFICATION_DONE) ) {
                break;
            }
        }

    }

    //
    // If there was a problem, check to see if it was caused by an
    // unimplemented command.
    //

    if ( !NT_SUCCESS( ntStatus ) ) {

        if ( ( i == 2 ) &&
            ( !CommandTable[Command & COMMAND_MASK].AlwaysImplemented ) ) {

            //
            // This error is probably caused by a command that's not
            // implemented on this controller.  Read the error from the
            // controller, and we should be in a stable state.
            //

            ntStatus2 = FcGetByte( &status0,
                                   FdoExtension,
                                   AllowLongDelay );

            //
            // If GetByte went as planned, we'll return the original error.
            //

            if ( NT_SUCCESS( ntStatus2 ) ) {

                if ( status0 != STREG0_END_INVALID_COMMAND ) {

                    //
                    // Status isn't as we expect, so return generic error.
                    //

                    ntStatus = STATUS_FLOPPY_BAD_REGISTERS;

                    FdoExtension->HardwareFailed = TRUE;
                    FdcDump( FDCINFO,
                             ("FcStartCommand: unexpected error value %2x\n",
                             status0) );
                } else {
                    FdcDump( FDCINFO,
                             ("FcStartCommand: Invalid command error returned\n") );
                }

            } else {

                //
                // GetByte returned an error, so propogate THAT.
                //

                FdcDump( FDCINFO,
                         ("FcStartCommand: FcGetByte returned error %x\n",
                         ntStatus2) );
                ntStatus = ntStatus2;
            }
        }

        //
        // Flush the Adapter Channel if we allocated it.
        //

        if (CommandTable[Command & COMMAND_MASK].DataTransfer ==
            FDC_READ_DATA) {

            IoFlushAdapterBuffers( FdoExtension->AdapterObject,
                                   (PMDL)IoHandle,
                                   FdoExtension->MapRegisterBase,
                                   (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle) + IoOffset ),
                                   TransferBytes,
                                   FALSE);

        } else if (CommandTable[Command & COMMAND_MASK].DataTransfer ==
                   FDC_WRITE_DATA) {

            IoFlushAdapterBuffers( FdoExtension->AdapterObject,
                                   (PMDL)IoHandle,
                                   FdoExtension->MapRegisterBase,
                                   (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle) + IoOffset ),
                                   TransferBytes,
                                   TRUE);

        }
    }

    if ( !NT_SUCCESS( ntStatus ) ) {

        //
        // Print an error message unless the command isn't always
        // implemented, ie CONFIGURE.
        //

        if ( !( ( ntStatus == STATUS_DEVICE_NOT_READY ) &&
            ( !CommandTable[Command & COMMAND_MASK].AlwaysImplemented ) ) ) {

            FdcDump( FDCDBGP,
                     ("Fdc: err %x ------  while giving command %x\n",
                     ntStatus, Command) );
        }
    }

    return ntStatus;
}

NTSTATUS
FcFinishCommand(
    IN OUT  PFDC_FDO_EXTENSION  FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes,
    IN      BOOLEAN         AllowLongDelay
    )

/*++

Routine Description:

    This function is called to complete a command to the floppy controller.
    At this point the floppy controller has successfully been sent a command
    and has either generated an interrupt or is ready with its result phase.
    This routine will also flush the DMA Adapter Buffers if they have been
    allocated.

Arguments:

    FdoExtension - a pointer to our data area for this controller.

    IssueCommandParms - Floppy controller command parameters.

Return Value:

    STATUS_SUCCESS if the command is successfully completed.

--*/

{
    NTSTATUS ntStatus = STATUS_SUCCESS;
    NTSTATUS ntStatus2;
    UCHAR i;
    UCHAR Command;

    Command = FifoInBuffer[0];

    FdcDump(
        FDCSHOW,
        ("Fdc: FcFinishCommand...\n")
        );

    if (IsNEC_98) {

        if (Command == COMMND_SENSE_DRIVE_STATUS) {

            ntStatus = FcGetByte(
                &FdoExtension->FifoBuffer[0],
                FdoExtension,
                AllowLongDelay );

            if (NT_SUCCESS(ntStatus) && (FdoExtension->FifoBuffer[0] & STREG3_DRIVE_READY)) {

                FdoExtension->ResultStatus0[FifoInBuffer[1]] = 0;
            }

        }

        FifoOutBuffer[0] = FdoExtension->FifoBuffer[0];

        for ( i = 1;
            ( i < CommandTable[Command & COMMAND_MASK].NumberOfResultBytes ) &&
                ( NT_SUCCESS( ntStatus ) );
            i++ ) {

            ntStatus = FcGetByte(
                &FifoOutBuffer[i],
                FdoExtension,
                AllowLongDelay );
        }

        FdcRqmReadyWait(FdoExtension, 0);

    } else { // (IsNEC_98)

        if (CommandTable[Command & COMMAND_MASK].FirstResultByte > 0) {

            FifoOutBuffer[0] = FdoExtension->FifoBuffer[0];

        }

        for ( i = CommandTable[Command & COMMAND_MASK].FirstResultByte;
            ( i < CommandTable[Command & COMMAND_MASK].NumberOfResultBytes ) &&
                ( NT_SUCCESS( ntStatus ) );
            i++ ) {

            ntStatus = FcGetByte(
                &FifoOutBuffer[i],
                FdoExtension,
                AllowLongDelay );
        }
    } // (IsNEC_98)

    //
    // Flush the Adapter Channel
    //

    if (CommandTable[Command & COMMAND_MASK].DataTransfer == FDC_READ_DATA) {

       IoFlushAdapterBuffers(FdoExtension->AdapterObject,
                             (PMDL)IoHandle,
                             FdoExtension->MapRegisterBase,
                             (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle ) + IoOffset ),
                             TransferBytes,
                             FALSE);

    } else if (CommandTable[Command & COMMAND_MASK].DataTransfer ==
               FDC_WRITE_DATA) {
        //
        // Setup Adapter Channel for Write
        //

       IoFlushAdapterBuffers(FdoExtension->AdapterObject,
                             (PMDL)IoHandle,
                             FdoExtension->MapRegisterBase,
                             (PVOID)((ULONG_PTR)MmGetMdlVirtualAddress( (PMDL)IoHandle ) + IoOffset ),
                             TransferBytes,
                             TRUE);

    }

    return ntStatus;
}

NTSTATUS
FcSendByte(
    IN UCHAR ByteToSend,
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN BOOLEAN AllowLongDelay
    )

/*++

Routine Description:

    This routine is called to send a byte to the controller.  It won't
    send the byte unless the controller is ready to receive a byte; if
    it's not ready after checking FIFO_TIGHTLOOP_RETRY_COUNT times, we
    delay for the minimum possible time (10ms) and then try again.  It
    should always be ready after waiting 10ms.

Arguments:

    ByteToSend - the byte to send to the controller.

    ControllerData - a pointer to our data area for this controller.

Return Value:

    STATUS_SUCCESS if the byte was sent to the controller;
    STATUS_DEVICE_NOT_READY otherwise.

--*/

{
    ULONG i = 0;
    BOOLEAN byteWritten = FALSE;

    if (IsNEC_98) {

        // Always FALSE;
        AllowLongDelay = FALSE;
    }

    //
    // Sit in a tight loop for a while.  If the controller becomes ready,
    // send the byte.
    //

    do {

        if ( ( READ_CONTROLLER( FdoExtension->ControllerAddress.Status )
            & STATUS_IO_READY_MASK ) == STATUS_WRITE_READY ) {

            WRITE_CONTROLLER(
                FdoExtension->ControllerAddress.Fifo,
                ByteToSend );

            byteWritten = TRUE;

        } else {
            KeStallExecutionProcessor(1);
        }

        i++;

    } while ( (!byteWritten) && ( i < FIFO_TIGHTLOOP_RETRY_COUNT ) );

    //
    // We hope that in most cases the FIFO will become ready very quickly
    // and the above loop will have written the byte.  But if the FIFO
    // is not yet ready, we'll loop a few times delaying for 10ms and then
    // try it again.
    //

    if ( AllowLongDelay ) {

        i = 0;

        while ( ( !byteWritten ) && ( i < FIFO_DELAY_RETRY_COUNT ) ) {

            FdcDump(
                FDCINFO,
                ("Fdc: waiting for 10ms for controller write\n")
                );

            KeDelayExecutionThread(
                KernelMode,
                FALSE,
                &FdoExtension->Minimum10msDelay );

            i++;

            if ( (READ_CONTROLLER( FdoExtension->ControllerAddress.Status )
                & STATUS_IO_READY_MASK) == STATUS_WRITE_READY ) {

                WRITE_CONTROLLER(
                    FdoExtension->ControllerAddress.Fifo,
                    ByteToSend );

                byteWritten = TRUE;
            }
        }
    }

    if ( byteWritten ) {

        return STATUS_SUCCESS;

    } else {

        //
        // We've waited over 30ms, and the FIFO *still* isn't ready.
        // Return an error.
        //

        FdcDump(
            FDCWARN,
            ("Fdc: FIFO not ready to write after 30ms\n")
            );

        FdoExtension->HardwareFailed = TRUE;

        return STATUS_DEVICE_NOT_READY;
    }
}

NTSTATUS
FcGetByte(
    OUT PUCHAR ByteToGet,
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN BOOLEAN AllowLongDelay
    )

/*++

Routine Description:

    This routine is called to get a byte from the controller.  It won't
    read the byte unless the controller is ready to send a byte; if
    it's not ready after checking FIFO_RETRY_COUNT times, we delay for
    the minimum possible time (10ms) and then try again.  It should
    always be ready after waiting 10ms.

Arguments:

    ByteToGet - the address in which the byte read from the controller
    is stored.

    ControllerData - a pointer to our data area for this controller.

Return Value:

    STATUS_SUCCESS if a byte was read from the controller;
    STATUS_DEVICE_NOT_READY otherwise.

--*/

{
    ULONG i = 0;
    BOOLEAN byteRead = FALSE;

    if (IsNEC_98) {

        // Always FALSE;
        AllowLongDelay = FALSE;
    }

    //
    // Sit in a tight loop for a while.  If the controller becomes ready,
    // read the byte.
    //

    do {

        if ( ( READ_CONTROLLER( FdoExtension->ControllerAddress.Status )
            & STATUS_IO_READY_MASK ) == STATUS_READ_READY ) {

            *ByteToGet = READ_CONTROLLER(
                FdoExtension->ControllerAddress.Fifo );

            byteRead = TRUE;

        } else {
            KeStallExecutionProcessor(1);
        }

        i++;

    } while ( ( !byteRead ) && ( i < FIFO_TIGHTLOOP_RETRY_COUNT ) );

    //
    // We hope that in most cases the FIFO will become ready very quickly
    // and the above loop will have read the byte.  But if the FIFO
    // is not yet ready, we'll loop a few times delaying for 10ms and then
    // trying it again.
    //

    if ( AllowLongDelay ) {

        i = 0;

        while ( ( !byteRead ) && ( i < FIFO_DELAY_RETRY_COUNT ) ) {

            FdcDump(
                FDCINFO,
                ("Fdc: waiting for 10ms for controller read\n")
                );

            KeDelayExecutionThread(
                KernelMode,
                FALSE,
                &FdoExtension->Minimum10msDelay );

            i++;

            if ( (READ_CONTROLLER( FdoExtension->ControllerAddress.Status )
                & STATUS_IO_READY_MASK) == STATUS_READ_READY ) {

                *ByteToGet = READ_CONTROLLER(
                    FdoExtension->ControllerAddress.Fifo );

                byteRead = TRUE;

            }
        }
    }

    if ( byteRead ) {

        return STATUS_SUCCESS;

    } else {

        //
        // We've waited over 30ms, and the FIFO *still* isn't ready.
        // Return an error.
        //

        FdcDump(
            FDCWARN,
            ("Fdc: FIFO not ready to read after 30ms\n")
            );

        FdoExtension->HardwareFailed = TRUE;

        return STATUS_DEVICE_NOT_READY;
    }

}

VOID
FdcCheckTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine is called at DISPATCH_LEVEL once every second by the
    I/O system.

    If the timer is "set" (greater than 0) this routine will KeSync a
    routine to decrement it.  If it ever reaches 0, the hardware is
    assumed to be in an unknown state, and so we log an error and
    initiate a reset.

    If a timeout occurs while resetting the controller, the KeSync'd
    routine will return an error, and this routine will fail any IRPs
    currently being processed.  Future IRPs will try the hardware again.

    When this routine is called, the driver state is impossible to
    predict.  However, when it is called and the timer is running, we
    know that one of the disks on the controller is expecting an
    interrupt.  So no new packets are starting on the current disk due
    to device queues, and no code should be processing this packet since
    the packet is waiting for an interrupt.

Arguments:

    DeviceObject - a pointer to the device object associated with this
    timer.

    Fdcxtension - a pointer to the fdc extension data.

Return Value:

    None.

--*/

{
    PFDC_FDO_EXTENSION fdoExtension;
    PIRP irp;

    fdoExtension = (PFDC_FDO_EXTENSION)Context;
    irp = DeviceObject->CurrentIrp;

    //
    // When the counter is -1, the timer is "off" so we don't want to do
    // anything.  If it's on, we'll have to synchronize execution with
    // other routines while we mess with the variables (and, potentially,
    // the hardware).
    //

    if ( fdoExtension->InterruptTimer == CANCEL_TIMER ) {

        return;
    }

    //
    // In the unlikely event that we attempt to reset the controller due
    // to a timeout AND that reset times out, we will need to fail the
    // IRP that was in progress at the first timeout occurred.
    //

    if ( !KeSynchronizeExecution( fdoExtension->InterruptObject,
                                  FdcTimerSync,
                                  fdoExtension ) ) {

        //
        // We're done with the reset.  Return the IRP that was being
        // processed with an error, and release the controller object.
        //

        fdoExtension->ResettingController = RESET_NOT_RESETTING;

        irp->IoStatus.Status = STATUS_DEVICE_NOT_READY;

        IoSetHardErrorOrVerifyDevice( irp, DeviceObject );

        if ( InterlockedDecrement(&fdoExtension->OutstandingRequests ) == 0 ) {
            KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
        }
        IoCompleteRequest( irp, IO_DISK_INCREMENT );

        IoStartNextPacket( DeviceObject, FALSE );

    }
}

BOOLEAN
FdcTimerSync(
    IN OUT PVOID Context
    )

/*++

Routine Description:

    This routine is called at DIRQL by FdcCheckTimer() when
    InterruptTimer is greater than 0.

    If the timer is "set" (greater than 0) this routine will decrement
    it.  If it ever reaches 0, the hardware is assumed to be in an
    unknown state, and so we log an error and initiate a reset.

    When this routine is called, the driver state is impossible to
    predict.  However, when it is called and the timer is running, we
    know that one of the disks on the controller is expecting an
    interrupt.  So, no new packets are starting on the current disk due
    to device queues, and no code should be processing this packet since
    the packet is waiting for an interrupt.  The controller object must
    be held.

Arguments:

    Context - a pointer to the controller extension.

Return Value:

    Generally TRUE.

    FALSE is only returned if the controller timed out while resetting
    the drive, so this means that the hardware state is unknown.

--*/

{
    PFDC_FDO_EXTENSION fdoExtension;

    fdoExtension = (PFDC_FDO_EXTENSION)Context;

    //
    // When the counter is -1, the timer is "off" so we don't want to do
    // anything.  It may have changed since we last checked it in
    // FdcCheckTimer().
    //

    if ( fdoExtension->InterruptTimer == CANCEL_TIMER ) {

        return TRUE;
    }

    //
    // The timer is "on", so decrement it.
    //

    fdoExtension->InterruptTimer--;

    //
    // If we hit zero, the timer has expired and we'll reset the
    // controller.
    //

    if ( fdoExtension->InterruptTimer == EXPIRED_TIMER ) {

        //
        // If we were ALREADY resetting the controller when it timed out,
        // there's something seriously wrong.
        //

        FdcDump( FDCDBGP, ("Fdc: Operation Timed Out.\n") );

        if ( fdoExtension->ResettingController != RESET_NOT_RESETTING ) {

            //
            // Returning FALSE will cause the current IRP to be completed
            // with an error.  Future IRPs will probably get a timeout and
            // attempt to reset the controller again.  This will probably
            // never happen.
            //

            FdcDump( FDCDBGP, ("Fdc: Timeout Reset timed out.\n") );

            fdoExtension->InterruptTimer = CANCEL_TIMER;
            return FALSE;
        }

        //
        // Reset the controller.  This will cause an interrupt.  Reset
        // CurrentDeviceObject until after the 10ms wait, in case any
        // stray interrupts come in.
        //

        fdoExtension->ResettingController = RESET_DRIVE_RESETTING;

        DISABLE_CONTROLLER_IMAGE (fdoExtension);

#ifdef _PPC_
        fdoExtension->DriveControlImage |= DRVCTL_DRIVE_MASK;
#endif

        WRITE_CONTROLLER(
            fdoExtension->ControllerAddress.DriveControl,
            fdoExtension->DriveControlImage );

        KeStallExecutionProcessor( 10 );

        fdoExtension->CommandHasResultPhase = FALSE;
        fdoExtension->InterruptTimer = START_TIMER;

        ENABLE_CONTROLLER_IMAGE (fdoExtension);

        WRITE_CONTROLLER(
            fdoExtension->ControllerAddress.DriveControl,
            fdoExtension->DriveControlImage );

    }

    return TRUE;
}

BOOLEAN
FdcInterruptService(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    )

/*++

Routine Description:

    This routine is called at DIRQL by the system when the controller
    interrupts.

Arguments:

    Interrupt - a pointer to the interrupt object.

    Context - a pointer to our controller data area for the controller
    that interrupted.  (This was set up by the call to
    IoConnectInterrupt).

Return Value:

    Normally returns TRUE, but will return FALSE if this interrupt was
    not expected.

--*/

{
    PFDC_FDO_EXTENSION fdoExtension;
    PDEVICE_OBJECT currentDeviceObject;
    ULONG i;
    UCHAR statusByte;
    BOOLEAN controllerStateError;

    UCHAR resultStatus0;
    UCHAR aiStatus=0;
    UCHAR aiInterrupt=0;
    ULONG rqmReadyRetryCount;
    BOOLEAN Response;

    UNREFERENCED_PARAMETER( Interrupt );

#ifdef KEEP_COUNTERS
    FloppyIntrTime = KeQueryPerformanceCounter((PVOID)NULL);
    FloppyInterrupts++;
#endif

    FdcDump( FDCSHOW, ("FdcInterruptService: ") );

    fdoExtension = (PFDC_FDO_EXTENSION) Context;

    if (!IsNEC_98) {
        if (!fdoExtension->AllowInterruptProcessing) {
            FdcDump( FDCSHOW, ("processing not allowed\n") );
            return FALSE;
        }
    } // (!IsNEC_98)

    //
    // CurrentDeviceObject is set to the device object that is
    // expecting an interrupt.
    //

    currentDeviceObject = fdoExtension->CurrentDeviceObject;
    fdoExtension->CurrentDeviceObject = NULL;
    controllerStateError = FALSE;
    fdoExtension->InterruptTimer = CANCEL_TIMER;

    KeStallExecutionProcessor(10);

    if (IsNEC_98) {
        do {

            resultStatus0 = READ_CONTROLLER( fdoExtension->ControllerAddress.Status );

            resultStatus0 &= STATUS_DATA_REQUEST;

        } while (resultStatus0 != STATUS_DATA_REQUEST);
    } // (IsNEC_98)

    if ( fdoExtension->CommandHasResultPhase ) {

        //
        // Result phase of previous command.  (Note that we can't trust
        // the CMD_BUSY bit in the status register to tell us whether
        // there's result bytes or not; it's sometimes wrong).
        // By reading the first result byte, we reset the interrupt.
        // The other result bytes will be read by a thread.
        // Note that we want to do this even if the interrupt is
        // unexpected, to make sure the interrupt is dismissed.
        //

        FdcDump(
            FDCSHOW,
            ("have result phase\n")
            );

        if (IsNEC_98) {

            rqmReadyRetryCount = 0;

            while ( ( READ_CONTROLLER( fdoExtension->ControllerAddress.Status)
                    & STATUS_IO_READY_MASK1) != STATUS_RQM_READY ) {
                //
                // RQM READY CHECK**
                //

                rqmReadyRetryCount++;

                if( rqmReadyRetryCount > RQM_READY_RETRY_COUNT ) {
                    break;
                }

                KeStallExecutionProcessor( 10 );
            }

            if( rqmReadyRetryCount > ( RQM_READY_RETRY_COUNT - 1 ) ) {
                FdcDump(
                   FDCDBGP,
                   ("Floppy: Int RQM ready wait 1 error! \n")
                    );

                KeStallExecutionProcessor( 10 );
                goto FdcInterruptMidterm;

            }
        } // (IsNEC_98)

        if ( ( READ_CONTROLLER( fdoExtension->ControllerAddress.Status )
            & STATUS_IO_READY_MASK ) == STATUS_READ_READY ) {

            fdoExtension->FifoBuffer[0] =
                READ_CONTROLLER( fdoExtension->ControllerAddress.Fifo );

            FdcDump( FDCSHOW,
                     ("FdcInterruptService: 1st fifo byte %2x\n",
                     fdoExtension->FifoBuffer[0])
                     );

        } else {

            if (IsNEC_98) {

                FdcRqmReadyWait(fdoExtension, 2);

            } // (IsNEC_98)

            //
            // Should never get here.  If we do, DON'T wake up the thread;
            // let it time out and reset the controller, or let another
            // interrupt handle this.
            //

            FdcDump(
               FDCDBGP,
               ("FdcInterruptService: controller not ready to be read in ISR\n")
               );

            controllerStateError = TRUE;
        }

    } else {

        //
        // Previous command doesn't have a result phase. To read how it
        // completed, issue a sense interrupt command.  Don't read
        // the result bytes from the sense interrupt; that is the
        // responsibility of the calling thread.
        // Note that we want to do this even if the interrupt is
        // unexpected, to make sure the interrupt is dismissed.
        //

        FdcDump(
            FDCSHOW,
            ("no result phase\n")
            );
        i = 0;

        do {

            KeStallExecutionProcessor( 1 );
            statusByte =
                READ_CONTROLLER(fdoExtension->ControllerAddress.Status);
            i++;

        } while ( ( i < FIFO_ISR_TIGHTLOOP_RETRY_COUNT ) &&
            ( ( statusByte & STATUS_CONTROLLER_BUSY ) ||
            ( ( statusByte & STATUS_IO_READY_MASK ) != STATUS_WRITE_READY ) ) );

        if ( !( statusByte & STATUS_CONTROLLER_BUSY ) &&
            ( ( statusByte & STATUS_IO_READY_MASK ) == STATUS_WRITE_READY ) ) {

            WRITE_CONTROLLER(
                fdoExtension->ControllerAddress.Fifo,
                0x08 );
//                COMMND_SENSE_INTERRUPT_STATUS );

            //
            // Wait for the controller to ACK the SenseInterrupt command, by
            // showing busy.  On very fast machines we can end up running
            // driver's system-thread before the controller has had time to
            // set the busy bit.
            //

            for (i = ISR_SENSE_RETRY_COUNT; i; i--) {

                statusByte =
                    READ_CONTROLLER( fdoExtension->ControllerAddress.Status );
                if (statusByte & STATUS_CONTROLLER_BUSY) {
                    break;
                }

                KeStallExecutionProcessor( 1 );
            }

            if (!i) {
                FdcDump(
                    FDCSHOW,
                    ("FdcInterruptService: spin loop complete and controller NOT busy\n")
                    );
            }

            if ( currentDeviceObject == NULL ) {

                //
                // This is an unexpected interrupt, so nobody's going to
                // read the result bytes.  Read them now.
                //

                if (IsNEC_98) {

                    resultStatus0 = FdcRqmReadyWait(fdoExtension, 0);

                    if ((resultStatus0 & STREG0_END_DRIVE_NOT_READY) != STREG0_END_INVALID_COMMAND ) {

                        resultStatus0 = FdcRqmReadyWait(fdoExtension, 1);
                    }
                } else { // (IsNEC_98)

                    FdcDump(
                        FDCSHOW,
                        ("FdcInterruptService: Dumping fifo bytes!\n")
                        );
                    READ_CONTROLLER( fdoExtension->ControllerAddress.Fifo );
                    READ_CONTROLLER( fdoExtension->ControllerAddress.Fifo );
                } // (IsNEC_98)
            }

            if (IsNEC_98) {
                if ( currentDeviceObject != NULL ) {
                    FdcDump(
                            FDCSHOW,
                            ("Floppy: FloppyInt.---Deviceobject!=NULL2\n")
                            );

                    resultStatus0 = FdcRqmReadyWait(fdoExtension, 0);

                    //
                    // Check move state.
                    //

                    if((resultStatus0 & STREG0_END_MASK) == STREG0_END_DRIVE_NOT_READY) {

                        if(fdoExtension->ResetFlag){
                            aiStatus=1;
                            fdoExtension->CurrentDeviceObject = currentDeviceObject;
                        }

                    } else {

                        fdoExtension->FifoBuffer[0] = resultStatus0;

                        aiStatus=0;
                        aiInterrupt=1;
                    }


                    if (aiInterrupt == 0){
                        while( ((resultStatus0 & STREG0_END_DRIVE_NOT_READY) != STREG0_END_INVALID_COMMAND) && aiInterrupt==0 ) {

                            resultStatus0 = FdcRqmReadyWait(fdoExtension, 3);

                            do {
                                //
                                // Check move state.
                                //

                                if((resultStatus0 & STREG0_END_MASK) == STREG0_END_DRIVE_NOT_READY) {

                                     if(fdoExtension->ResetFlag){

                                        aiStatus=1;
                                        fdoExtension->CurrentDeviceObject = currentDeviceObject;
                                     }

                                } else {

                                    fdoExtension->FifoBuffer[0] = resultStatus0;

                                    aiStatus=0;
                                    aiInterrupt=1;
                                    break;
                                }

                                resultStatus0 = FdcRqmReadyWait(fdoExtension, 0);

                            } while ( aiInterrupt == 0 );
                        }

                        FdcDump(
                                FDCSHOW,
                                ("Floppy: FloppyInt.---Deviceobject!=NULL_out\n")
                                );
                    }
                }
            } // (IsNEC_98)

        } else {

            //
            // Shouldn't get here.  If we do, DON'T wake up the thread;
            // let it time out and reset the controller, or let another
            // interrupt take care of it.
            //

            FdcDump(
                FDCDBGP,
                ("Fdc: no result, but can't write SenseIntr\n")
                );

            controllerStateError = TRUE;
        }
    }

FdcInterruptMidterm:

    //
    // We've written to the controller, and we're about to leave.  On
    // machines with levelsensitive interrupts, we'll get another interrupt
    // if we RETURN before the port is flushed.  To make sure that doesn't
    // happen, we'll do a read here.
    //

    statusByte = READ_CONTROLLER( fdoExtension->ControllerAddress.Status );

    //
    // Let the interrupt settle.
    //

    KeStallExecutionProcessor(10);

#ifdef KEEP_COUNTERS
    FloppyEndIntrTime = KeQueryPerformanceCounter((PVOID)NULL);
    FloppyIntrDelay.QuadPart = FloppyIntrDelay.QuadPart +
                               (FloppyEndIntrTime.QuadPart -
                                FloppyIntrTime.QuadPart);
#endif

    if (IsNEC_98) {
        if(!(fdoExtension->ResetFlag)){
            fdoExtension->ResetFlag = TRUE;
        }
    } // (IsNEC_98)

    if ( currentDeviceObject == NULL ) {

        //
        // We didn't expect this interrupt.  We've dismissed it just
        // in case, but now return FALSE withOUT waking up the thread.
        //

        FdcDump(FDCDBGP,
                   ("Fdc: unexpected interrupt\n"));

        return FALSE;
    }

    if ( !controllerStateError ) {

        //
        // Request a DPC for execution later to get the remainder of the
        // floppy state.
        //

        fdoExtension->IsrReentered = 0;
        fdoExtension->AllowInterruptProcessing = FALSE;

        if (IsNEC_98) {
            if(aiStatus==0){
                IoRequestDpc(currentDeviceObject,
                             currentDeviceObject->CurrentIrp,
                             (PVOID) NULL );
            }
        } else { // (IsNEC_98)

            IoRequestDpc(currentDeviceObject,
                         currentDeviceObject->CurrentIrp,
                         (PVOID) NULL);

        } // (IsNEC_98)

    } else {

        //
        // Running the floppy (at least on R4000 boxes) we've seen
        // examples where the device interrupts, yet it never says
        // it *ISN'T* busy.  If this ever happens on non-MCA x86 boxes
        // it would be ok since we use latched interrupts.  Even if
        // the device isn't touched so that the line would be pulled
        // down, on the latched machine, this ISR wouldn't be called
        // again.  The normal timeout code for a request would eventually
        // reset the controller and retry the request.
        //
        // On the R4000 boxes and on MCA machines, the floppy is using
        // level sensitive interrupts.  Therefore if we don't do something
        // to lower the interrupt line, we will be called over and over,
        // *forever*.  This makes it look as though the machine is hung.
        // Unless we were lucky enough to be on a multiprocessor, the
        // normal timeout code would NEVER get a chance to run because
        // the timeout code runs at dispatch level, and we will never
        // leave device level.
        //
        // What we will do is keep a counter that is incremented every
        // time we reach this section of code.  When the counter goes
        // over the threshold we will do a hard reset of the device
        // and reset the counter down to zero.  The counter will be
        // initialized when the device is first initialized.  It will
        // be set to zero in the other arm of this if, and it will be
        // reset to zero by the normal timeout logic.
        //

        fdoExtension->CurrentDeviceObject = currentDeviceObject;
        if (fdoExtension->IsrReentered > FLOPPY_RESET_ISR_THRESHOLD) {

            //
            // Reset the controller.  This could cause an interrupt
            //

            fdoExtension->IsrReentered = 0;

            DISABLE_CONTROLLER_IMAGE (fdoExtension);

#ifdef _PPC_
            fdoExtension->DriveControlImage |= DRVCTL_DRIVE_MASK;
#endif

            WRITE_CONTROLLER(fdoExtension->ControllerAddress.DriveControl,
                             fdoExtension->DriveControlImage);

            KeStallExecutionProcessor( 10 );

            ENABLE_CONTROLLER_IMAGE (fdoExtension);

            WRITE_CONTROLLER(fdoExtension->ControllerAddress.DriveControl,
                             fdoExtension->DriveControlImage);

            if (IsNEC_98) {

                fdoExtension->ResetFlag = TRUE;

            } // (IsNEC_98)

            //
            // Give the device plenty of time to be reset and
            // interrupt again.  Then just do the sense interrupt.
            // this should quiet the device.  We will then let
            // the normal timeout code do its work.
            //

            KeStallExecutionProcessor(500);
            WRITE_CONTROLLER(fdoExtension->ControllerAddress.Fifo,
                             0x08 );
//                           COMMND_SENSE_INTERRUPT_STATUS );
            KeStallExecutionProcessor(500);

            KeInsertQueueDpc(&fdoExtension->LogErrorDpc,
                             NULL,
                             NULL);
        } else {

            fdoExtension->IsrReentered++;
        }

    }
    return TRUE;
}

VOID
FdcDeferredProcedure(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )

/*++

Routine Description:

    This routine is called at DISPATCH_LEVEL by the system at the
    request of FdcInterruptService().  It simply sets the interrupt
    event, which wakes up the floppy thread.

Arguments:

    Dpc - a pointer to the DPC object used to invoke this routine.

    DeferredContext - a pointer to the device object associated with this
    DPC.

    SystemArgument1 - unused.

    SystemArgument2 - unused.

Return Value:

    None.

--*/

{
    NTSTATUS ntStatus;
    PDEVICE_OBJECT deviceObject;
//    PFDC_PDO_EXTENSION pdoExtension;
    PFDC_FDO_EXTENSION fdoExtension;
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    PLIST_ENTRY request;
    PISSUE_FDC_COMMAND_PARMS issueCommandParms;

    UNREFERENCED_PARAMETER( Dpc );
    UNREFERENCED_PARAMETER( SystemArgument1 );
    UNREFERENCED_PARAMETER( SystemArgument2 );

#ifdef KEEP_COUNTERS
    FloppyDPCs++;
    FloppyDPCTime = KeQueryPerformanceCounter((PVOID)NULL);

    FloppyDPCDelay.QuadPart = FloppyDPCDelay.QuadPart +
                              (FloppyDPCTime.QuadPart -
                               FloppyIntrTime.QuadPart);
#endif

    deviceObject = (PDEVICE_OBJECT) DeferredContext;
    fdoExtension = deviceObject->DeviceExtension;

    irp = deviceObject->CurrentIrp;

    if ( irp != NULL ) {

        irpSp = IoGetCurrentIrpStackLocation( irp );
    }

    if ( irp != NULL &&
         irpSp->Parameters.DeviceIoControl.IoControlCode ==
            IOCTL_DISK_INTERNAL_ISSUE_FDC_COMMAND_QUEUED ) {

        issueCommandParms =
            (PISSUE_FDC_COMMAND_PARMS)
            irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

        ntStatus = FcFinishCommand(
                        fdoExtension,
                        issueCommandParms->FifoInBuffer,
                        issueCommandParms->FifoOutBuffer,
                        issueCommandParms->IoHandle,
                        issueCommandParms->IoOffset,
                        issueCommandParms->TransferBytes,
                        FALSE );

        irp->IoStatus.Status = ntStatus;

        if ( !NT_SUCCESS( ntStatus ) &&
            IoIsErrorUserInduced( ntStatus ) ) {

            IoSetHardErrorOrVerifyDevice( irp, deviceObject );
        }

        if ( InterlockedDecrement(&fdoExtension->OutstandingRequests ) == 0 ) {
            KeSetEvent( &fdoExtension->RemoveEvent, 0, FALSE );
        }
        IoCompleteRequest( irp, IO_NO_INCREMENT );

        IoStartNextPacket( deviceObject, FALSE );

    } else {

        FdcDump( FDCSHOW, ("FdcDeferredProcedure: Set Event\n") );

        KeSetEvent( &fdoExtension->InterruptEvent, (KPRIORITY) 0, FALSE );
    }
}

NTSTATUS
FcFinishReset(
    IN OUT  PFDC_FDO_EXTENSION FdoExtension
    )

/*++

Routine Description:

    This routine is called to complete a reset operation which entails
    reading the interrupt status from each active channel on the floppy
    controller.

Arguments:

    FdoExtension - a pointer to our data area for this controller.

Return Value:

    STATUS_SUCCESS if this controller appears to have been reset properly,
    error otherwise.

--*/

{
    NTSTATUS    ntStatus = STATUS_SUCCESS;
    UCHAR       statusRegister0;
    UCHAR       cylinder;
    UCHAR       driveNumber;

    FdcDump(
        FDCSHOW,
        ("Fdc: FcFinishReset\n")
        );

    //
    // Sense interrupt status for all drives.
    //
    for ( driveNumber = 0;
        ( driveNumber < MAXIMUM_DISKETTES_PER_CONTROLLER ) &&
            ( NT_SUCCESS( ntStatus ) );
        driveNumber++ ) {

        if ( driveNumber != 0 ) {

            //
            // Note that the ISR issued first SENSE INTERRUPT for us.
            //

            ntStatus = FcSendByte(
                          CommandTable[COMMND_SENSE_INTERRUPT_STATUS].OpCode,
                          FdoExtension,
                          TRUE );
        }

        if ( NT_SUCCESS( ntStatus ) ) {

            ntStatus = FcGetByte( &statusRegister0, FdoExtension, TRUE );

            if ( NT_SUCCESS( ntStatus ) ) {

                ntStatus = FcGetByte( &cylinder, FdoExtension, TRUE );
            }
        }
    }

    return ntStatus;
}

NTSTATUS
FcFdcEnabler(
    IN      PDEVICE_OBJECT DeviceObject,
    IN      ULONG Ioctl,
    IN OUT  PVOID Data
    )
/*++

Routine Description:

    Call the floppy enabler driver to execute a command.  This is always a
    synchronous call and, since it includes waiting for an event, should only
    be done at IRQL_PASSIVE_LEVEL.

    All communication with the Floppy Enabler driver is carried out through
    device i/o control requests.  Any data that is to be sent to or received
    from the floppy enabler driver is included in the Type3InputBuffer section
    of the irp.

Arguments:

    DeviceObject - a pointer to the current device object.

    Ioctl - the IoControl code that will be sent to the Floppy Enabler.

    Data - a pointer to data that will be sent to or received from the Floppy
           Enabler.

Return Value:

    STATUS_TIMEOUT if the Floppy Enabler does not respond in a timely manner.
    otherwise IoStatus.Status from the Floppy Enabler is returned.

--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    KEVENT doneEvent;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS ntStatus;

    FdcDump(FDCINFO,("FcFdcEnabler: Calling fdc enabler with %x\n", Ioctl));

    KeInitializeEvent( &doneEvent,
                       NotificationEvent,
                       FALSE);

    //
    // Create an IRP for enabler
    //
    irp = IoBuildDeviceIoControlRequest( Ioctl,
                                         DeviceObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,
                                         &doneEvent,
                                         &ioStatus );

    if (irp == NULL) {

        FdcDump(FDCDBGP,("FcFdcEnabler: Can't allocate Irp\n"));
        //
        // If an Irp can't be allocated, then this call will
        // simply return. This will leave the queue frozen for
        // this device, which means it can no longer be accessed.
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation(irp);
    irpStack->Parameters.DeviceIoControl.Type3InputBuffer = Data;

    //
    // Call the driver and request the operation
    //
    ntStatus = IoCallDriver(DeviceObject, irp);

    if ( ntStatus == STATUS_PENDING ) {

        //
        // Now wait for operation to complete (should already be done,  but
        // maybe not)
        //
        KeWaitForSingleObject( &doneEvent,
                               Executive,
                               KernelMode,
                               FALSE,
                               NULL);

        ntStatus = ioStatus.Status;
    }

    return ntStatus;
}
VOID
FdcGetEnablerDevice(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    )
{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    KEVENT doneEvent;
    IO_STATUS_BLOCK ioStatus;
    NTSTATUS ntStatus;

    FdcDump(FDCINFO,("FdcGetEnablerDevice:\n"));

    KeInitializeEvent( &doneEvent,
                       NotificationEvent,
                       FALSE);

    //
    // Create an IRP for enabler
    //
    irp = IoBuildDeviceIoControlRequest( IOCTL_DISK_INTERNAL_GET_ENABLER,
                                         FdoExtension->TargetObject,
                                         NULL,
                                         0,
                                         NULL,
                                         0,
                                         TRUE,
                                         &doneEvent,
                                         &ioStatus );

    if (irp == NULL) {

        FdcDump(FDCDBGP,("FdcGetEnablerDevice: Can't allocate Irp\n"));
        //
        // If an Irp can't be allocated, then this call will
        // simply return. This will leave the queue frozen for
        // this device, which means it can no longer be accessed.
        //
        return;
    }

    irpSp = IoGetNextIrpStackLocation( irp );
    irpSp->Parameters.DeviceIoControl.Type3InputBuffer = &FdoExtension->FdcEnablerSupported;

    //
    // Call the driver and request the operation
    //
    ntStatus = IoCallDriver( FdoExtension->TargetObject, irp );

    //
    // Now wait for operation to complete (should already be done,  but
    // maybe not)
    //
    if ( ntStatus == STATUS_PENDING ) {

        ntStatus = KeWaitForSingleObject( &doneEvent,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL);
    }
    return;
}


ULONG
FdcFindIsaBusNode(
    IN OUT VOID
    )

/*++

Routine Description:

    Find Isa bus node in the registry.

Arguments:


Return Value:

    Node number.

--*/

{
    ULONG   NodeNumber = 0;
    BOOLEAN FoundBus = FALSE;

    NTSTATUS Status;

    RTL_QUERY_REGISTRY_TABLE parameters[2];

    UNICODE_STRING invalidBusName;
    UNICODE_STRING targetBusName;
    UNICODE_STRING isaBusName;

    //
    // Initialize invalid bus name.
    //
    RtlInitUnicodeString(&invalidBusName,L"BADBUS");

    //
    // Initialize "ISA" bus name.
    //
    RtlInitUnicodeString(&isaBusName,L"ISA");

    parameters[0].QueryRoutine = NULL;
    parameters[0].Flags = RTL_QUERY_REGISTRY_REQUIRED |
                          RTL_QUERY_REGISTRY_DIRECT;
    parameters[0].Name = L"Identifier";
    parameters[0].EntryContext = &targetBusName;
    parameters[0].DefaultType = REG_SZ;
    parameters[0].DefaultData = &invalidBusName;
    parameters[0].DefaultLength = 0;

    parameters[1].QueryRoutine = NULL;
    parameters[1].Flags = 0;
    parameters[1].Name = NULL;
    parameters[1].EntryContext = NULL;

    do {
        CHAR AnsiBuffer[512];

        ANSI_STRING AnsiString;
        UNICODE_STRING registryPath;

        //
        // Build path buffer...
        //
        sprintf(AnsiBuffer,ISA_BUS_NODE,NodeNumber);
        RtlInitAnsiString(&AnsiString,AnsiBuffer);
        Status = RtlAnsiStringToUnicodeString(&registryPath,&AnsiString,TRUE);

        if (!(NT_SUCCESS(Status))) {
            break;
        }

        //
        // Initialize recieve buffer.
        //
        targetBusName.Buffer = NULL;

        //
        // Query it.
        //
        Status = RtlQueryRegistryValues(RTL_REGISTRY_ABSOLUTE,
                                        registryPath.Buffer,
                                        parameters,
                                        NULL,
                                        NULL);

        RtlFreeUnicodeString(&registryPath);

        if (!NT_SUCCESS(Status) || (targetBusName.Buffer == NULL)) {
            break;
        }

        //
        // Is this "ISA" node ?
        //
        if (RtlCompareUnicodeString(&targetBusName,&isaBusName,TRUE) == 0) {
            //
            // Found.
            //
            FoundBus = TRUE;
            break;
        }

        //
        // Can we find any node for this ??
        //
        if (RtlCompareUnicodeString(&targetBusName,&invalidBusName,TRUE) == 0) {
            //
            // Not found.
            //
            break;
        }

        RtlFreeUnicodeString(&targetBusName);

        //
        // Next node number..
        //
        NodeNumber++;

    } while (TRUE);

    if (targetBusName.Buffer) {
        RtlFreeUnicodeString(&targetBusName);
    }

    if (!FoundBus) {
        NodeNumber = (ULONG)-1;
    }

    return (NodeNumber);
}


NTSTATUS
FdcHdbit(
    IN PDEVICE_OBJECT      DeviceObject,
    IN PFDC_FDO_EXTENSION  FdoExtension,
    IN PSET_HD_BIT_PARMS   SetHdBitParams
    )

/*++

Routine Description:

    Set a Hd bit or a FDD EXC bit.

Arguments:

    fdoExtension - a pointer to our data area for the device extension.


Return Value:

        TRUE : Changed HD bit
        FALSE: No changed HD bit

--*/

{
    NTSTATUS ntStatus;
    USHORT   st;                // State of HD bit
    USHORT   st2;               // Set on/off HD bit
    USHORT   st3;               // When set HD bit, then st3=1
    USHORT   st4;               // 1.44MB bit for 1.44MB media
    SHORT    sel;               // 1.44MB Selector No for 1.44MB media
    SHORT    st5=0;             // 1.44MB on: wait for spin for 1.44MB media
    LARGE_INTEGER motorOnDelay;

    USHORT      lpc;
    UCHAR       resultStatus0Save[4];
    USHORT      resultStatus0;
    ULONG       getStatusRetryCount;
    ULONG       rqmReadyRetryCount;

    BOOLEAN     media144MB;
    BOOLEAN     mediaMore120MB;
    BOOLEAN     supportDrive;

    media144MB      = SetHdBitParams->Media144MB;
    mediaMore120MB  = SetHdBitParams->More120MB;
    sel             = SetHdBitParams->DeviceUnit;
    SetHdBitParams->ChangedHdBit = FALSE;


    ASSERT( FdoExtension->ControllerAddress.ModeChange   == (PUCHAR)0xbe );
    ASSERT( FdoExtension->ControllerAddress.ModeChangeEx == (PUCHAR)0x4be );

    supportDrive    = TRUE;

    st3=0;

    ntStatus=0;

    //
    // Normal mode.
    //

    st = READ_CONTROLLER(FdoExtension->ControllerAddress.ModeChange);
    st2 = st & 0x02;

    //
    // Normal mode.
    // Check dip switch.
    //

    st4 = READ_CONTROLLER(FdoExtension->ControllerAddress.DriveControl);
    st4 = st4 & 0x04;

    if (((FdoExtension->FloppyEquip) & 0x0c) != 0) {
        //
        // Exist out side FDD unit.
        //

        if ( st4 == 0 ) {
            //
            // DIP SW 1-4 on
            //

            sel = sel - 2;

            if( sel < 0 ) {
                sel = sel + 4;
            }
        }
    }

    if ( supportDrive ) {

        for( lpc = 0 ; lpc < 4 ; lpc++ ) {

            resultStatus0Save[lpc]=FdoExtension->ResultStatus0[lpc];
        }

        if ( SetHdBitParams->DriveType144MB ) {
            //
            // 1.44MB drive.
            //

            st4=sel*32;
            WRITE_CONTROLLER(FdoExtension->ControllerAddress.ModeChangeEx,st4);

            st4 = READ_CONTROLLER(FdoExtension->ControllerAddress.ModeChangeEx);
            st4 = st4 & 0x01;

            if ( media144MB ) {

                //
                // 1.44MB media.
                //

                if(st4==0){

                    //
                    // WRE on, IHMD off.
                    //

                    st4=sel*32+0x11;
                    WRITE_CONTROLLER(FdoExtension->ControllerAddress.ModeChangeEx,st4);
                    st5=1;
                }

            } else {

                //
                // Not 1.44MB media.
                //

                if(st4!=0){

                    //
                    // WRE on, IHMD off.
                    //

                    st4=sel*32+0x10;
                    WRITE_CONTROLLER(FdoExtension->ControllerAddress.ModeChangeEx,st4);
                    st5=1;
                }
            }
        }

        if ( mediaMore120MB ) {
            //
            // Media 1.2MB and More.
            //

            if(st2==0){
                //
                // When FDD exc bit is on,
                // then set  FDD exc bit off,
                // and set emotion bit on.
                //
                st |= 0x02;
                st |= 0x04;

                WRITE_CONTROLLER(FdoExtension->ControllerAddress.ModeChange,st);
                st3 = 1;

            }
        } else {
            //
            // Media between 160 and 720
            //

            if ( st2 != 0 ) {
                //
                // When FDD exc bit is on,
                // then set  FDD exc bit off,
                // and set emotion bit on.
                //

                st &= 0xfd;
                st |= 0x04;

                WRITE_CONTROLLER(FdoExtension->ControllerAddress.ModeChange,st);
                st3 = 1;

            }
        }

        if(st5==1){

            //
            // Wait until motor spin up.
            //

            motorOnDelay.LowPart = (unsigned long)(- ( 10 * 1000 * 600 ));   /*500ms*/
            motorOnDelay.HighPart = -1;
            (VOID) KeDelayExecutionThread( KernelMode, FALSE, &motorOnDelay );

            //
            // Sense target drive and get all data at transition of condistion.
            //

            FdoExtension->FifoBuffer[0] = COMMND_SENSE_DRIVE_STATUS;
            FdoExtension->FifoBuffer[1] = SetHdBitParams->DeviceUnit;

            ntStatus = FcIssueCommand( FdoExtension,
                                       FdoExtension->FifoBuffer,
                                       FdoExtension->FifoBuffer,
                                       NULL,
                                       0,
                                       0 );

            resultStatus0 = FdcRqmReadyWait(FdoExtension, 0);

        }

        for(lpc=0;lpc<4;lpc++){
            FdoExtension->ResultStatus0[lpc] = resultStatus0Save[lpc];
        }

        //
        // Change HD bit?
        //

        if(st3==1){
            FcInitializeControllerHardware(FdoExtension,DeviceObject);
            SetHdBitParams->ChangedHdBit = TRUE;
        }

    }

    FdcDump(
            FDCSTATUS,
            ("Floppy : HdBit resultStatus0 = %x \n",
            resultStatus0)
            );

    return ntStatus;
}


ULONG
FdcGet0Seg(
    IN PUCHAR   ConfigurationData1,
    IN ULONG    Offset
    )

/*++

Routine Description:

    This routine get BIOS common area data and return it.
        0x500 :    1MB port or not
        0x501 :    High resolution/Normal, 386/768KB
        0x55c :    1MB drive : [#0,#1] or [#0,#1,#2,#3]

Arguments:

    Offset - Offset value from 0 segment(0:<Offset>).

Return Value:

        BIOS common area data.

--*/

{
        UCHAR           biosCommonAreaData   = 0;

        if ((Offset<0x400) || (Offset>0x5ff)) {

                return (ULONG)0xffff;
        }

        //
        // Get BIOS common area data.
        //

        biosCommonAreaData = ConfigurationData1[40+(Offset-0x400)];

        return (ULONG)biosCommonAreaData;
}

UCHAR
FdcRqmReadyWait(
    IN PFDC_FDO_EXTENSION  FdoExtension,
    IN ULONG               IssueSenseInterrupt
    )

/*++

Routine Description:

    RQM Ready wait

Arguments:

    FdoExtension         - a pointer to our data area for the device extension.
    IssueSenseInterrupt  - Indicate issue COMMND_SENSE_INTERRUPT_STATUS.
                            0 - Issue no COMMND_SENSE_INTERRUPT_STATUS.
                            1 - Issue COMMND_SENSE_INTERRUPT_STATUS with RQM Check.
                            2 - Issue COMMND_SENSE_INTERRUPT_STATUS without RQM Check.
                            3 - Issue COMMND_SENSE_INTERRUPT_STATUS for AI Interrupt.


Return Value:

    ntStatus - STATUS_SUCCESS

--*/

{

    ULONG       getStatusRetryCount;
    ULONG       rqmReadyRetryCount;
    ULONG       j;
    UCHAR       resultStatus0;
    UCHAR       statusByte;

    ASSERT(IssueSenseInterrupt < 4);

    do{
        if (IssueSenseInterrupt != 0) {

            //
            // Sense Interrupt status.
            // RQM ready wait.
            //

            if ((IssueSenseInterrupt == 1) || (IssueSenseInterrupt == 3)) {

                rqmReadyRetryCount=0;
                //
                // RQM ready check.
                //
                while ((READ_CONTROLLER( FdoExtension->ControllerAddress.Status)
                        & STATUS_IO_READY_MASK1) != STATUS_RQM_READY){

                    rqmReadyRetryCount++;

                    if(rqmReadyRetryCount > RQM_READY_RETRY_COUNT){
                            break;
                    }
                    KeStallExecutionProcessor( 1 );
                }
                if(rqmReadyRetryCount > (RQM_READY_RETRY_COUNT-1)){
                    FdcDump(
                            FDCDBGP,
                            ("Floppy: Issue RQM ready wait 1 error! \n")
                             );
                    if (IssueSenseInterrupt == 1) {
                        break;
                    }
                }

            }

            //
            // Issue sense interrupt forcibly.
            //

            WRITE_CONTROLLER(
                  FdoExtension->ControllerAddress.Fifo,
                  0x08);
//                  COMMND_SENSE_INTERRUPT_STATUS ); //******C-Phase DATA WRITE*

            //
            // Wait for busy.
            //
            for (rqmReadyRetryCount = ISR_SENSE_RETRY_COUNT; rqmReadyRetryCount; rqmReadyRetryCount--) {
                statusByte = READ_CONTROLLER(
                FdoExtension->ControllerAddress.Status );
                if (statusByte & STATUS_CONTROLLER_BUSY)
                    break;

                KeStallExecutionProcessor( 1 );

            }
        }

        //
        // Get status.
        //

        getStatusRetryCount = 0;

        j = 0;

        do {
            //
            // Check RQM ready.
            //

            rqmReadyRetryCount=0;

            while ((READ_CONTROLLER( FdoExtension->ControllerAddress.Status)
                  & STATUS_IO_READY_MASK1) != STATUS_RQM_READY){

                rqmReadyRetryCount++;

                if(rqmReadyRetryCount > RQM_READY_RETRY_COUNT){
                    break;
                }

                KeStallExecutionProcessor( 1 );
            }

            if(rqmReadyRetryCount > (RQM_READY_RETRY_COUNT-1)){

                FdcDump(
                    FDCDBGP,
                    ("Floppy: Int RQM ready wait \n")
                     );

                KeStallExecutionProcessor( 1 );
                break;
            }

            //
            // Get status even if it is transition of condition.
            //

            statusByte = READ_CONTROLLER(FdoExtension->ControllerAddress.Status);

            if ((statusByte & STATUS_IO_READY_MASK) == STATUS_WRITE_READY) {

                //
                // DIO is 1.
                //

                break;
            }

            if (j == 0) {

                //
                // R-Phase: Data read.
                //

                resultStatus0 = READ_CONTROLLER( FdoExtension->ControllerAddress.Fifo );

                j=1;

                //
                // Check transition of condition.
                //

                if((resultStatus0 & STREG0_END_MASK)==STREG0_END_INVALID_COMMAND){
                    //
                    // Invalid
                    //
                    break;
                }

                if((resultStatus0 & STREG0_END_MASK) == STREG0_END_DRIVE_NOT_READY){
                    if(FdoExtension->ResetFlag){
                        FdoExtension->ResultStatus0[resultStatus0 & 3] = resultStatus0;
                    }
                }

            } else {

                //
                // R-Phase: Data read.
                //
                READ_CONTROLLER( FdoExtension->ControllerAddress.Fifo );
            }

            getStatusRetryCount++;

        } while (getStatusRetryCount > RQM_READY_RETRY_COUNT);

        if(getStatusRetryCount > RQM_READY_RETRY_COUNT-1){

            KeStallExecutionProcessor( 1 );
            FdcDump(
                FDCDBGP,
                ("Floppy: Issue status overflow error! \n")
                );
        }

    } while ((IssueSenseInterrupt != 0) &&
             ((resultStatus0 & STREG0_END_MASK) != STREG0_END_INVALID_COMMAND));

    return resultStatus0;

}

#ifdef TOSHIBAJ
/*
    IOCTL_DISK_INTERNAL_ENABLE_3_MODE:

    Media   Speed   T/F
  -------------------------
    1.44MB  300RPM  FALSE
    1.23MB  360RPM  TRUE

*/
#define RPM_300 1   // 1.44MB media format
#define RPM_360 2   // 1.2MB,1.23MB media format
NTSTATUS FcFdcEnable3Mode(
    IN      PFDC_FDO_EXTENSION FdoExtension,
    IN      PIRP Irp
    )
{   NTSTATUS    ntStatus;
    PENABLE_3_MODE  param;
    PIO_STACK_LOCATION irpSp;
    UCHAR           motorSpeed;
    UCHAR           unitNumber;
    PUCHAR          configPort;
    UCHAR           configDataValue = 0;
    LARGE_INTEGER   changeRotationDelay;

    irpSp = IoGetCurrentIrpStackLocation( Irp );
    param = (PENABLE_3_MODE)irpSp->Parameters.DeviceIoControl.Type3InputBuffer;

    FdcDump(FDCSHOW,("FcFdcEnable3MODE()\n"));
    if( param == NULL )
        return STATUS_SUCCESS;  // may be later...

    FdcDump(FDCSHOW,("Parameters...%d %d\n",
//          param->DeviceUnit, param->Enable3Mode, param->Context));
            param->DeviceUnit, param->Enable3Mode));

    if (FdoExtension->Available3Mode==FALSE)
        return STATUS_SUCCESS;

//  if(param->Context==TRUE)
//      return  STATUS_SUCCESS;

    unitNumber = param->DeviceUnit;
    motorSpeed = (param->Enable3Mode)? SMC_DENSEL_LOW: SMC_DELSEL_HIGH; // 360:300

    // Feb.9.1998 KIADP013 Change Speed
    // Change speed
    // 1.Enter configuration state
    // 2.Select device
    // 3.Change speed
    //   Write 'f1h' to index port
    //   Read from data port
    //   Rewrite to data port
    //     bit [3:2] Densel speed
    //       10       H     360rpm
    //       11       L     300rpm
    // 4.Exit configuration state

    configPort = FdoExtension->ConfigBase;

    FdcDump(
        FDCSHOW,
        ("Config: index port %x, data port %x\n",
         SMC_INDEX_PORT(configPort), SMC_DATA_PORT(configPort))
    );

    // Must change data transfer rate to 500BPS when change FDD rotation.
    WRITE_CONTROLLER(FdoExtension->ControllerAddress.DRDC.DataRate, DATART_0500 );

    // Change speed
    WRITE_PORT_UCHAR(configPort, SMC_KEY_ENTER_CONFIG);   // Enter config state

    // Select FDD
    WRITE_PORT_UCHAR(SMC_INDEX_PORT(configPort), SMC_INDEX_DEVICE);
    WRITE_PORT_UCHAR(SMC_DATA_PORT(configPort), SMC_DEVICE_FDC);

    // Get current value
    WRITE_PORT_UCHAR(SMC_INDEX_PORT(configPort), SMC_INDEX_FDC_OPT);
    configDataValue = READ_PORT_UCHAR(SMC_DATA_PORT(configPort));
    if ((configDataValue & SMC_MASK_DENSEL) == motorSpeed) {
        WRITE_PORT_UCHAR(configPort, SMC_KEY_EXIT_CONFIG);
        return STATUS_SUCCESS;
    }
    // Set speed
    configDataValue &= ~SMC_MASK_DENSEL;
    configDataValue |= motorSpeed;
    WRITE_PORT_UCHAR(SMC_DATA_PORT(configPort), configDataValue);

    WRITE_PORT_UCHAR(configPort, SMC_KEY_EXIT_CONFIG);    // Exit config state

    if (motorSpeed == SMC_DENSEL_LOW) {
        FdcDump(
            FDCSHOW,
            ("------- FDD rotation change: 300rpm -> 360rpm\n")
        );
    } else {
        FdcDump(
            FDCSHOW,
            ("------- FDD rotation change: 360rpm -> 300rpm\n")
        );
    }

    // Set Delay time to 500ms
    changeRotationDelay.LowPart =(ULONG)( - ( 10 * 1000 * 500 ));   // 17-Oct-1994 RKBUG001
    changeRotationDelay.HighPart = -1;

    FdoExtension->LastMotorSettleTime = changeRotationDelay;

    // Delay 500ms
    KeDelayExecutionThread( KernelMode, FALSE, &changeRotationDelay );

    return STATUS_SUCCESS;
}

NTSTATUS FcFdcAvailable3Mode(
    IN      PFDC_FDO_EXTENSION FdoExtension,
    IN      PIRP Irp
    )
{
    PIO_STACK_LOCATION irpSp;

    FdcDump(FDCSHOW,("FcFdcAvailabe3MODE\n"));
    irpSp = IoGetCurrentIrpStackLocation( Irp );

    // Feb.9.1998 KIADP012 Identify controller
    // Feb.12.1998 KIADP014 Get the address of config port

    return (FdoExtension->Available3Mode)? STATUS_SUCCESS: STATUS_UNSUCCESSFUL;
}

//  Feb.12.1998 KIADP014 Get the address of config port
BOOLEAN
FcCheckConfigPort(
    IN PUCHAR  ConfigPort
    )
{
    BOOLEAN             found = FALSE;
    ULONG               configAddr = 0;
    UCHAR               controllerId = 0;

    FdcDump( FDCSHOW, ("FcCheckConfigPort: Configuration Port %x\n", ConfigPort) );

    if (!SmcConfigID) {
        return found;
    }

    // Get data
    if (ConfigPort) {
        WRITE_PORT_UCHAR(ConfigPort, SMC_KEY_ENTER_CONFIG);

        // Controller ID
        if (SmcConfigID) {
            WRITE_PORT_UCHAR(SMC_INDEX_PORT(ConfigPort), SMC_INDEX_IDENTIFY);
            controllerId = READ_PORT_UCHAR(SMC_DATA_PORT(ConfigPort));
            FdcDump( FDCINFO, ("Fdc: Controller ID %x\n", controllerId) );
        }

        WRITE_PORT_UCHAR(ConfigPort,SMC_KEY_EXIT_CONFIG);
    }


    // Check data
    if (controllerId == SmcConfigID) {
            found = TRUE;
    }

    return found;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\fdc\mode3fdc\desk2fdc\fdc_data.h ===
/*++

Copyright (C) Microsoft Corporation, 1991 - 1999

Module Name:

    fdc_data.h

Abstract:

    This file includes data and hardware declarations for the NEC PD765
    (aka AT, ISA, and ix86) and Intel 82077 (aka MIPS) floppy driver for
    NT.

Author:


Environment:

    Kernel mode only.

Notes:


--*/


#if DBG
//
// For checked kernels, define a macro to print out informational
// messages.
//
// FdcDebug is normally 0.  At compile-time or at run-time, it can be
// set to some bit pattern for increasingly detailed messages.
//
// Big, nasty errors are noted with DBGP.  Errors that might be
// recoverable are handled by the WARN bit.  More information on
// unusual but possibly normal happenings are handled by the INFO bit.
// And finally, boring details such as routines entered and register
// dumps are handled by the SHOW bit.
//
#define FDCDBGP              ((ULONG)0x00000001)
#define FDCWARN              ((ULONG)0x00000002)
#define FDCINFO              ((ULONG)0x00000004)
#define FDCSHOW              ((ULONG)0x00000008)
#define FDCIRPPATH           ((ULONG)0x00000010)
#define FDCFORMAT            ((ULONG)0x00000020)
#define FDCSTATUS            ((ULONG)0x00000040)

extern ULONG FdcDebugLevel;
#define FdcDump(LEVEL,STRING) \
        do { \
            if (FdcDebugLevel & LEVEL) { \
                DbgPrint STRING; \
            } \
        } while (0)
#else
#define FdcDump(LEVEL,STRING) do {NOTHING;} while (0)
#endif


//
// Macros to access the controller.  Note that the *_PORT_UCHAR macros
// work on all machines, whether the I/O ports are separate or in
// memory space.
//

#define READ_CONTROLLER( Address )                         \
    READ_PORT_UCHAR( ( PUCHAR )Address )

#define WRITE_CONTROLLER( Address, Value )                 \
    WRITE_PORT_UCHAR( ( PUCHAR )Address, ( UCHAR )Value )


//
// Retry counts -
//
// When moving a byte to/from the FIFO, we sit in a tight loop for a while
// waiting for the controller to become ready.  The number of times through
// the loop is controlled by FIFO_TIGHTLOOP_RETRY_COUNT.  When that count
// expires, we'll wait in 10ms increments.  FIFO_DELAY_RETRY_COUNT controls
// how many times we wait.
//
// The ISR_SENSE_RETRY_COUNT is the maximum number of 1 microsecond
// stalls that the ISR will do waiting for the controller to accept
// a SENSE INTERRUPT command.  We do this because there is a hardware
// quirk in at least the NCR 8 processor machine where it can take
// up to 50 microseconds to accept the command.
//
// When attempting I/O, we may run into many different errors.  The
// hardware retries things 8 times invisibly.  If the hardware reports
// any type of error, we will recalibrate and retry the operation
// up to RECALIBRATE_RETRY_COUNT times.  When this expires, we check to
// see if there's an overrun - if so, the DMA is probably being hogged
// by a higher priority device, so we repeat the earlier loop up to
// OVERRUN_RETRY_COUNT times.
//
// Any packet that is about to be returned with an error caused by an
// unexpected hardware error or state will be restarted from the very
// beginning after resetting the hardware HARDWARE_RESET_RETRY_COUNT
// times.
//

#define FIFO_TIGHTLOOP_RETRY_COUNT         500
#define FIFO_ISR_TIGHTLOOP_RETRY_COUNT     25
#define ISR_SENSE_RETRY_COUNT              50
#define FIFO_DELAY_RETRY_COUNT             5
#define RECALIBRATE_RETRY_COUNT            3
#define OVERRUN_RETRY_COUNT                1
#define HARDWARE_RESET_RETRY_COUNT         2
#define FLOPPY_RESET_ISR_THRESHOLD         20
#define RQM_READY_RETRY_COUNT              100

#define ONE_SECOND                         (10 * 1000 * 1000) // 100ns increments
#define CANCEL_TIMER                       -1
#define START_TIMER                        (IsNEC_98 ? 15 : 9)
#define EXPIRED_TIMER                      0

#define RESET_NOT_RESETTING                 0
#define RESET_DRIVE_RESETTING               1

//
// Need some maximum size values so that we can appropriately set up the DMA
// channels
//

#define MAX_BYTES_PER_SECTOR              (IsNEC_98 ? 1024 : 512)
#define MAX_SECTORS_PER_TRACK             36


//
// Boot Configuration Information
//

//
// Define the maximum number of controllers and floppies per controller
// that this driver will support.
//
// The number of floppies per controller is fixed at 4, since the
// controllers don't have enough bits to select more than that (and
// actually, many controllers will only support 2).  The number of
// controllers per machine is arbitrary; 3 should be more than enough.
//

#define MAXIMUM_CONTROLLERS_PER_MACHINE    3
#define MAXIMUM_DISKETTES_PER_CONTROLLER   4

//
// Floppy register structure.  The base address of the controller is
// passed in by configuration management.  Note that this is the 82077
// structure, which is a superset of the PD765 structure.  Not all of
// the registers are used.
//

typedef union _CONTROLLER {

    struct {
        PUCHAR StatusA;
        PUCHAR StatusB;
        PUCHAR DriveControl;
        PUCHAR Tape;
        PUCHAR Status;
        PUCHAR Fifo;
        PUCHAR Reserved;
        union {
            PUCHAR DataRate;
            PUCHAR DiskChange;
        } DRDC;
        PUCHAR ModeChange;   // for NEC98 : 0xbe
        PUCHAR ModeChangeEx; // for NEC98 : 0x4be
    };

    PUCHAR Address[8];

} CONTROLLER, *PCONTROLLER;

//
//  Io Port address information structure.  This structure is used to save
//  information about ioport addresses as it is collected from a resource
//  requirements list.
//
typedef struct _IO_PORT_INFO {
    LARGE_INTEGER BaseAddress;
    UCHAR Map;
    LIST_ENTRY ListEntry;
} IO_PORT_INFO, *PIO_PORT_INFO;


//
// Parameter fields passed to the CONFIGURE command.
//

#define COMMND_CONFIGURE_IMPLIED_SEEKS     0x40
#define COMMND_CONFIGURE_FIFO_THRESHOLD    0x0F
#define COMMND_CONFIGURE_DISABLE_FIFO      0x20
#define COMMND_CONFIGURE_DISABLE_POLLING   0x10

//
// Write Enable bit for PERPENDICULAR MODE command.
//

#define COMMND_PERPENDICULAR_MODE_OW       0x80

//
// The command table is used by FlIssueCommand() to determine how many
// bytes to get and receive, and whether or not to wait for an interrupt.
// Some commands have extra bits; COMMAND_MASK takes these off.
// FirstResultByte indicates whether the command has a result stage
// or not; if so, it's 1 because the ISR read the 1st byte, and
// NumberOfResultBytes is 1 less than expected.  If not, it's 0 and
// NumberOfResultBytes is 2, since the ISR will have issued a SENSE
// INTERRUPT STATUS command.
//

#define COMMAND_MASK        0x1f
#define FDC_NO_DATA         0x00
#define FDC_READ_DATA       0x01
#define FDC_WRITE_DATA      0x02

typedef struct _COMMAND_TABLE {
    UCHAR   OpCode;
    UCHAR   NumberOfParameters;
    UCHAR   FirstResultByte;
    UCHAR   NumberOfResultBytes;
    BOOLEAN InterruptExpected;
    BOOLEAN AlwaysImplemented;
    UCHAR    DataTransfer;
} COMMAND_TABLE;

//
// Bits in the DRIVE_CONTROL register.
//

#define DRVCTL_RESET                       0x00
#define DRVCTL_ENABLE_CONTROLLER           (IsNEC_98 ? 0x80 : 0x04)
#define DRVCTL_ENABLE_DMA_AND_INTERRUPTS   (IsNEC_98 ? 0x10 : 0x08)
#define DRVCTL_DRIVE_0                     0x10
#define DRVCTL_DRIVE_1                     0x21
#define DRVCTL_DRIVE_2                     0x42
#define DRVCTL_DRIVE_3                     0x83
#define DRVCTL_DRIVE_MASK                  0x03
#define DRVCTL_MOTOR_MASK                  (IsNEC_98 ? 0x08 : 0xf0)
#define DRVCTL_HD_BIT                      0x20 // for NEC98
#define DRVCTL_AI_ENABLE                   0x20 // for NEC98. Indicate AI enable bit.

//
// Bits in the STATUS register.
//

#define STATUS_DRIVE_0_BUSY                0x01
#define STATUS_DRIVE_1_BUSY                0x02
#define STATUS_DRIVE_2_BUSY                0x04
#define STATUS_DRIVE_3_BUSY                0x08
#define STATUS_CONTROLLER_BUSY             0x10
#define STATUS_DMA_UNUSED                  0x20
#define STATUS_DIRECTION_READ              0x40
#define STATUS_DATA_REQUEST                0x80

#define STATUS_IO_READY_MASK               0xc0
#define STATUS_READ_READY                  0xc0
#define STATUS_WRITE_READY                 0x80
#define STATUS_IO_READY_MASK1              0x80 // for NEC98.
#define STATUS_RQM_READY                   0x80 // for NEC98.

//
// Bits in the DATA_RATE register.
//

#define DATART_0125                        0x03
#define DATART_0250                        0x02
#define DATART_0300                        0x01
#define DATART_0500                        0x00
#define DATART_1000                        0x03
#define DATART_RESERVED                    0xfc

//
// Bits in the DISK_CHANGE register.
//

#define DSKCHG_RESERVED                    0x7f
#define DSKCHG_DISKETTE_REMOVED            0x80

//
// Bits in status register 0.
//

#define STREG0_DRIVE_0                     0x00
#define STREG0_DRIVE_1                     0x01
#define STREG0_DRIVE_2                     0x02
#define STREG0_DRIVE_3                     0x03
#define STREG0_HEAD                        0x04
#define STREG0_DRIVE_NOT_READY             0x08
#define STREG0_DRIVE_FAULT                 0x10
#define STREG0_SEEK_COMPLETE               0x20
#define STREG0_END_NORMAL                  0x00
#define STREG0_END_ERROR                   0x40
#define STREG0_END_INVALID_COMMAND         0x80
#define STREG0_END_DRIVE_NOT_READY         0xC0
#define STREG0_END_MASK                    0xC0

//
// Bits in status register 1.
//

#define STREG1_ID_NOT_FOUND                0x01
#define STREG1_WRITE_PROTECTED             0x02
#define STREG1_SECTOR_NOT_FOUND            0x04
#define STREG1_RESERVED1                   0x08
#define STREG1_DATA_OVERRUN                0x10
#define STREG1_CRC_ERROR                   0x20
#define STREG1_RESERVED2                   0x40
#define STREG1_END_OF_DISKETTE             0x80

//
// Bits in status register 2.
//

#define STREG2_SUCCESS                     0x00
#define STREG2_DATA_NOT_FOUND              0x01
#define STREG2_BAD_CYLINDER                0x02
#define STREG2_SCAN_FAIL                   0x04
#define STREG2_SCAN_EQUAL                  0x08
#define STREG2_WRONG_CYLINDER              0x10
#define STREG2_CRC_ERROR                   0x20
#define STREG2_DELETED_DATA                0x40
#define STREG2_RESERVED                    0x80

//
// Bits in status register 3.
//

#define STREG3_DRIVE_0                     0x00
#define STREG3_DRIVE_1                     0x01
#define STREG3_DRIVE_2                     0x02
#define STREG3_DRIVE_3                     0x03
#define STREG3_HEAD                        0x04
#define STREG3_TWO_SIDED                   0x08
#define STREG3_TRACK_0                     0x10
#define STREG3_DRIVE_READY                 0x20
#define STREG3_WRITE_PROTECTED             0x40
#define STREG3_DRIVE_FAULT                 0x80

#define VALID_NEC_FDC                      0x90    // version number
#define NSC_PRIMARY_VERSION                0x70    // National 8477 verion number
#define NSC_MASK                           0xF0    // mask for National version number
#define INTEL_MASK                         0xe0
#define INTEL_44_PIN_VERSION               0x40
#define INTEL_64_PIN_VERSION               0x00

#define DMA_DIR_UNKNOWN    0xff   /* The DMA direction is not currently known */
#define DMA_WRITE          0   /* Program the DMA to write (FDC->DMA->RAM) */
#define DMA_READ           1   /* Program the DMA to read (RAM->DMA->FDC) */

//
//  Strings for PnP Identification.
//
#define FDC_FLOPPY_COMPATIBLE_IDS L"*PNP0700\0GenFloppyDisk\0\0"
#define FDC_FLOPPY_COMPATIBLE_IDS_LENGTH 24 // NB wide characters.

#define FDC_TAPE_COMPATIBLE_IDS L"QICPNP\0\0"
#define FDC_TAPE_COMPATIBLE_IDS_LENGTH 8 // NB wide characters.

#define FDC_CONTROLLER_COMPATIBLE_IDS L"*PNP0700\0\0"
#define FDC_CONTROLLER_COMPATIBLE_IDS_LENGTH 10 // NB wide characters.



//
// Runtime device structures
//

//
// There is one FDC_EXTENSION attached to the device object of each
// floppy drive.  Only data directly related to that drive (and the media
// in it) is stored here; common data is in CONTROLLER_DATA.  So the
// FDC_EXTENSION has a pointer to the CONTROLLER_DATA.
//

typedef struct _FDC_EXTENSION_HEADER {

    //
    //  A flag to indicate whether this is a FDO or a PDO
    //
    BOOLEAN             IsFDO;

    //
    //  A pointer to our own device object.
    //
    PDEVICE_OBJECT      Self;

} FDC_EXTENSION_HEADER, *PFDC_EXTENSION_HEADER;

typedef enum _FDC_DEVICE_TYPE {

    FloppyControllerDevice,
    FloppyDiskDevice,
    FloppyTapeDevice

} FDC_DEVICE_TYPE;

typedef struct _FDC_PDO_EXTENSION {

    FDC_EXTENSION_HEADER;

    //
    //  A pointer to the FDO that created us.
    //
    PDEVICE_OBJECT  ParentFdo;

    //
    //  The instance number for this PDO.  Determined by the order of the
    //  callbacks from IoQueryDeviceDescription.
    //
    USHORT          Instance;

    //
    //  The type of device this PDO supports.  Currently disk or tape.
    //
    FDC_DEVICE_TYPE DeviceType;

    SHORT           TapeVendorId;

    //
    //  A flag that indicates whether this PDO is pending removal.
    //
    BOOLEAN         Removed;

    //
    //  This PDO's entry in its parent's list of related PDOs.
    //
    LIST_ENTRY      PdoLink;

    //
    //  The enumerated  number of this specific device, as returned from
    //  IoQueryDeviceDescription.
    //
    ULONG           PeripheralNumber;

    PDEVICE_OBJECT  TargetObject;

} FDC_PDO_EXTENSION, *PFDC_PDO_EXTENSION;

typedef struct _FDC_FDO_EXTENSION {

    FDC_EXTENSION_HEADER;

    //
    //  A kernel resource for controlling access to the FDC.
    //
    ERESOURCE Resource;
    //
    //  A pointer to the PDO to which this FDO is attached.
    //
    PDEVICE_OBJECT      UnderlyingPDO;

    //
    //  The top of the object stack to which this FDO is attached.
    //
    PDEVICE_OBJECT      TargetObject;

    //
    //  A list and count of PDOs that were created by this FDO.
    //
    LIST_ENTRY          PDOs;
    ULONG               NumPDOs;
    BOOLEAN             Removed;
    ULONG               OutstandingRequests;
    KEVENT              RemoveEvent;
    BOOLEAN             TapeEnumerationPending;
    KEVENT              TapeEnumerationEvent;

    //
    //  Some stuff for power management
    //
    LIST_ENTRY          PowerQueue;
    KSPIN_LOCK          PowerQueueSpinLock;
    KEVENT              PowerEvent;
    SYSTEM_POWER_STATE  CurrentPowerState;
    LARGE_INTEGER       LastMotorSettleTime;
    BOOLEAN             WakeUp;

    //
    //  The bus number on which this physical device lives.
    //
    INTERFACE_TYPE      BusType;
    ULONG               BusNumber;
    ULONG               ControllerNumber;

    BOOLEAN             DeviceObjectInitialized;
    LARGE_INTEGER       InterruptDelay;
    LARGE_INTEGER       Minimum10msDelay;
    KEVENT              InterruptEvent;
    LONG                InterruptTimer;
    CCHAR               ResettingController;
    KEVENT              AllocateAdapterChannelEvent;
    LONG                AdapterChannelRefCount;
    PKEVENT             AcquireEvent;
    HANDLE              AcquireEventHandle;
    KEVENT              SynchEvent;
    KDPC                LogErrorDpc;
    KDPC                BufferTimerDpc;
    KTIMER              BufferTimer;
    PKINTERRUPT         InterruptObject;
    PVOID               MapRegisterBase;
    PADAPTER_OBJECT     AdapterObject;
    PDEVICE_OBJECT      CurrentDeviceObject;
    PDRIVER_OBJECT      DriverObject;
    CONTROLLER          ControllerAddress;
    ULONG               SpanOfControllerAddress;
    ULONG               NumberOfMapRegisters;
    ULONG               BuffersRequested;
    ULONG               BufferCount;
    ULONG               BufferSize;
    PTRANSFER_BUFFER    TransferBuffers;
    ULONG               IsrReentered;
    ULONG               ControllerVector;
    KIRQL               ControllerIrql;
    KINTERRUPT_MODE     InterruptMode;
    KAFFINITY           ProcessorMask;
    UCHAR               FifoBuffer[10];
    BOOLEAN             AllowInterruptProcessing;
    BOOLEAN             SharableVector;
    BOOLEAN             SaveFloatState;
    BOOLEAN             HardwareFailed;
    BOOLEAN             CommandHasResultPhase;
    BOOLEAN             ControllerConfigurable;
    BOOLEAN             MappedControllerAddress;
    BOOLEAN             CurrentInterrupt;
    BOOLEAN             Model30;
    UCHAR               PerpendicularDrives;
    UCHAR               NumberOfDrives;
    UCHAR               DriveControlImage;
    UCHAR               HardwareFailCount;
    BOOLEAN             ControllerInUse;
    UCHAR               FdcType;
    UCHAR               FdcSpeeds;
    PIRP                CurrentIrp;
    UCHAR               DriveOnValue;
    PDEVICE_OBJECT      LastDeviceObject;
    BOOLEAN             Clock48MHz;
    BOOLEAN             FdcEnablerSupported;
    PDEVICE_OBJECT      FdcEnablerDeviceObject;
    PFILE_OBJECT        FdcEnablerFileObject;
    BOOLEAN             ResetFlag;              // for NEC98
    BOOLEAN             FloppyEquip;            // for NEC98
    UCHAR               MotorRunning;           // for NEC98
    UCHAR               ResultStatus0[4];       // for NEC98

#ifdef TOSHIBAJ
    // For 3mode support
    BOOLEAN     Available3Mode;
    //  Feb.9.1998 KIADP010 Assign Toshiba special registers.
    PUCHAR      ConfigBase;
#endif

} FDC_FDO_EXTENSION, *PFDC_FDO_EXTENSION;


#ifdef TOSHIBAJ
    // Feb.9.1998 KIADP011 Get base address and identifier
    // Feb.9.1998 KIADP012 Identify controller
    // Feb.9.1998 KIADP013 Change Speed

// Definitions for SMC 37C67X/777

// Ports
#define SMC_INDEX_PORT(port) (port)
#define SMC_DATA_PORT(port)  (port)+1

// Key
#define SMC_KEY_ENTER_CONFIG    0x55
#define SMC_KEY_EXIT_CONFIG     0xaa

#define SMC_CONFIG_PORT_LENGTH  2

// Index
#define SMC_INDEX_DEVICE        0x07
#define SMC_INDEX_IDENTIFY      0x20
#define SMC_INDEX_CONF_ADDR_0   0x26
#define SMC_INDEX_CONF_ADDR_1   0x27
#define SMC_INDEX_FDC_OPT       0xf1

// Device
#define SMC_DEVICE_FDC 0x00

// Mask
#define SMC_MASK_DENSEL 0x0c

// Dencity select
#define SMC_DELSEL_HIGH 0x08  // 300rpm
#define SMC_DENSEL_LOW  0x0c  // 360rpm

#endif

//
// NEC98: Registory path of MultifunctionAdapter.
//
#define ISA_BUS_NODE \
        "\\Registry\\MACHINE\\HARDWARE\\DESCRIPTION\\System\\MultifunctionAdapter\\%d"

//
// Macro
//

//
// Enable/Disable Controller
//

#define DISABLE_CONTROLLER_IMAGE(FdoExtension) \
{ \
    if (IsNEC_98) { \
        FdoExtension->DriveControlImage |= DRVCTL_ENABLE_DMA_AND_INTERRUPTS; \
        FdoExtension->DriveControlImage |= DRVCTL_ENABLE_CONTROLLER; \
        FdoExtension->ResetFlag          = FALSE; \
    } else { \
        FdoExtension->DriveControlImage |= DRVCTL_ENABLE_DMA_AND_INTERRUPTS; \
        FdoExtension->DriveControlImage &= ~( DRVCTL_ENABLE_CONTROLLER ); \
    } \
}

#define ENABLE_CONTROLLER_IMAGE(FdoExtension) \
{ \
    if (IsNEC_98) { \
        FdoExtension->DriveControlImage &= ~( DRVCTL_ENABLE_CONTROLLER ); \
        FdoExtension->DriveControlImage |= DRVCTL_AI_ENABLE; \
    } else { \
        FdoExtension->DriveControlImage |= DRVCTL_ENABLE_CONTROLLER; \
    } \
}

//
// Dma speed
//
#define DEFAULT_DMA_SPEED      (IsNEC_98 ? Compatible : TypeA)

//
// Paging Driver with Mutex
//
#define FDC_PAGE_INITIALIZE_DRIVER_WITH_MUTEX \
{ \
    if (!IsNEC_98) { \
        PagingMutex = ExAllocatePool(NonPagedPool, sizeof(FAST_MUTEX)); \
        if (!PagingMutex) { \
            return STATUS_INSUFFICIENT_RESOURCES; \
        } \
        ExInitializeFastMutex(PagingMutex); \
        MmPageEntireDriver(DriverEntry); \
    } \
}

#define FDC_PAGE_RESET_DRIVER_WITH_MUTEX \
{ \
    if (!IsNEC_98) { \
        ExAcquireFastMutex( PagingMutex ); \
        if ( ++PagingReferenceCount == 1 ) { \
            MmResetDriverPaging( DriverEntry ); \
        } \
        ExReleaseFastMutex( PagingMutex ); \
    } \
}

#define FDC_PAGE_ENTIRE_DRIVER_WITH_MUTEX \
{ \
    if (!IsNEC_98) { \
        ExAcquireFastMutex(PagingMutex); \
        if (--PagingReferenceCount == 0) { \
            MmPageEntireDriver(DriverEntry); \
        } \
        ExReleaseFastMutex(PagingMutex); \
    } \
}


//
// Prototypes of external routines.
//

/*
LONG
sprintf(
    CHAR *,
    const CHAR *,
    ...
    );
    */

//
// Prototypes of driver routines.
//

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
FcAllocateCommonBuffers(
    IN PFDC_FDO_EXTENSION FdoExtension
    );

NTSTATUS
FcInitializeControllerHardware(
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
FdcCreateClose(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcAddDevice(
    IN      PDRIVER_OBJECT DriverObject,
    IN OUT  PDEVICE_OBJECT PhysicalDeviceObject
    );

BOOLEAN
FdcInterruptService(
    IN PKINTERRUPT Interrupt,
    IN PVOID Context
    );

VOID
FdcDeferredProcedure(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

NTSTATUS
FcAcquireFdc(
    IN OUT PFDC_FDO_EXTENSION FdoExtension,
    IN      PLARGE_INTEGER  TimeOut
    );

NTSTATUS
FcReleaseFdc(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    );

VOID
FcReportFdcInformation(
    IN      PFDC_PDO_EXTENSION PdoExtension,
    IN      PFDC_FDO_EXTENSION FdcExtension,
    IN OUT  PIO_STACK_LOCATION IrpSp
    );

NTSTATUS
FcTurnOnMotor(
    IN      PFDC_FDO_EXTENSION  FdcExtension,
    IN OUT  PIO_STACK_LOCATION  irpSp
    );

NTSTATUS
FcTurnOffMotor(
    IN      PFDC_FDO_EXTENSION  FdoExtension
    );

VOID
FcAllocateAdapterChannel(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    );

VOID
FcFreeAdapterChannel(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    );

IO_ALLOCATION_ACTION
FdcAllocateAdapterChannel(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID MapRegisterBase,
    IN PVOID Context
    );

NTSTATUS
FcSendByte(
    IN UCHAR ByteToSend,
    IN PFDC_FDO_EXTENSION FdoExtension,
    IN BOOLEAN AllowLongDelay
    );

NTSTATUS
FcGetByte(
    OUT PUCHAR ByteToGet,
    IN OUT PFDC_FDO_EXTENSION FdoExtension,
    IN BOOLEAN AllowLongDelay
    );

NTSTATUS
FcIssueCommand(
    IN OUT  PFDC_FDO_EXTENSION FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes
    );

VOID
FcLogErrorDpc(
    IN PKDPC Dpc,
    IN PVOID DeferredContext,
    IN PVOID SystemContext1,
    IN PVOID SystemContext2
    );

BOOLEAN
FcClearIsrReentered(
    IN PVOID Context
    );

NTSTATUS
FcGetFdcInformation(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    );

VOID
FdcCheckTimer(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PVOID Context
    );

BOOLEAN
FdcTimerSync(
    IN OUT PVOID Context
    );

VOID
FdcStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FcStartCommand(
    IN OUT PFDC_FDO_EXTENSION FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes,
    IN      BOOLEAN         AllowLongDelay
    );

NTSTATUS
FcFinishCommand(
    IN OUT PFDC_FDO_EXTENSION FdoExtension,
    IN      PUCHAR          FifoInBuffer,
       OUT  PUCHAR          FifoOutBuffer,
    IN      PVOID           IoHandle,
    IN      ULONG           IoOffset,
    IN      ULONG           TransferBytes,
    IN      BOOLEAN         AllowLongDelay
    );

NTSTATUS
FcFinishReset(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    );

VOID
FdcBufferThread(
    IN PVOID Context
    );

NTSTATUS
FcFdcEnabler(
    IN      PDEVICE_OBJECT DeviceObject,
    IN      ULONG Ioctl,
    IN OUT  PVOID Data
    );

NTSTATUS
FcSynchronizeQueue(
    IN OUT PFDC_FDO_EXTENSION FdoExtension,
    IN PIRP Irp
    );

NTSTATUS
FdcPnpComplete(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

NTSTATUS
FdcStartDevice(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcInitializeDeviceObject( 
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
FdcFdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcPdoPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcFilterResourceRequirements( 
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcQueryDeviceRelations(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

NTSTATUS
FdcFdoConfigCallBack(
    IN PVOID Context,
    IN PUNICODE_STRING PathName,
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    IN PKEY_VALUE_FULL_INFORMATION *BusInformation,
    IN CONFIGURATION_TYPE ControllerType,
    IN ULONG ControllerNumber,
    IN PKEY_VALUE_FULL_INFORMATION *ControllerInformation,
    IN CONFIGURATION_TYPE PeripheralType,
    IN ULONG PeripheralNumber,
    IN PKEY_VALUE_FULL_INFORMATION *PeripheralInformation
    );

NTSTATUS
FdcEnumerateQ117(
    IN PFDC_FDO_EXTENSION FdoExtension
    );

VOID
FdcGetEnablerDevice(
    IN OUT PFDC_FDO_EXTENSION FdoExtension
    );

NTSTATUS
FdcPdoInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
FdcFdoInternalDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

PVOID
FdcGetControllerBase(
    IN INTERFACE_TYPE BusType,
    IN ULONG BusNumber,
    PHYSICAL_ADDRESS IoAddress,
    ULONG NumberOfBytes,
    BOOLEAN InIoSpace
    );

//
// For NEC98
//

NTSTATUS
FdcHdbit(
    IN PDEVICE_OBJECT DeviceObject,
    IN PFDC_FDO_EXTENSION  FdoExtension,
    IN PSET_HD_BIT_PARMS   SetHdBitParams
    );

ULONG
FdcGet0Seg(
    IN PUCHAR   ConfigrationData1,
    IN ULONG   Offset
    );

ULONG
FdcFindIsaBusNode(
    IN OUT VOID
    );

UCHAR
FdcRqmReadyWait(
    IN PFDC_FDO_EXTENSION  FdoExtension,
    IN ULONG               IssueSenseInterrupt
    );


#ifdef TOSHIBAJ

NTSTATUS FcFdcEnable3Mode(
    IN      PFDC_FDO_EXTENSION FdoExtension,
    IN      PIRP Irp
    );

NTSTATUS FcFdcAvailable3Mode(
    IN      PFDC_FDO_EXTENSION FdoExtension,
    IN      PIRP Irp
    );

BOOLEAN
FcCheckConfigPort(
    IN PUCHAR  ConfigPort
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\acpiutil.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1998 - 1998
//
//  File:       acpiutil.h
//
//--------------------------------------------------------------------------

#if !defined (___acpiutil_h___)
#define ___acpiutil_h___

//
// ACPI Control Method Stuff
//
#define ACPI_METHOD_GET_TASK_FILE   ((ULONG) 'FTG_') // _GTF
#define ACPI_METHOD_GET_TIMING      ((ULONG) 'MTG_') // _GTM
#define ACPI_METHOD_SET_TIMING      ((ULONG) 'MTS_') // _STM

#define ACPI_XFER_MODE_NOT_SUPPORT     (0xffffffff)

#pragma pack(1)
typedef struct _ACPI_GTF_IDE_REGISTERS {
    UCHAR    FeaturesReg;
    UCHAR    SectorCountReg;
    UCHAR    SectorNumberReg;
    UCHAR    CylLowReg;
    UCHAR    CylHighReg;
    UCHAR    DriveHeadReg;
    UCHAR    CommandReg;
} ACPI_GTF_IDE_REGISTERS, *PACPI_GTF_IDE_REGISTERS;
#pragma pack()

typedef struct _ACPI_IDE_TIMING {

    struct _TIMING {

        ULONG Pio;
        ULONG Dma;

    } Speed[MAX_IDE_DEVICE];

    union {
        struct {
            ULONG UltraDma0:1;
            ULONG IoChannelReady0:1;
            ULONG UltraDma1:1;
            ULONG IoChannelReady1:1;
            ULONG IndependentTiming:1;
            ULONG Reserved:27;
        } b;
        ULONG AsULong;
    } Flags;
} ACPI_IDE_TIMING, *PACPI_IDE_TIMING;
                          
                          
NTSTATUS
DeviceQueryFirmwareBootSettings (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PDEVICE_SETTINGS *IdeBiosSettings
    );
                         
NTSTATUS
DeviceQueryACPISettings (
    IN PDEVICE_EXTENSION_HEADER DoExtension,
    IN ULONG ControlMethodName,
    OUT PACPI_EVAL_OUTPUT_BUFFER *QueryResult
    );

NTSTATUS
DeviceQueryACPISettingsCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
DeviceQueryChannelTimingSettings (
    IN PFDO_EXTENSION FdoExtension,
    IN OUT PACPI_IDE_TIMING TimimgSettings
    );
                          
typedef struct _SYNC_SET_ACPI_TIMING_CONTEXT {

    KEVENT Event;
    NTSTATUS IrpStatus;

} SYNC_SET_ACPI_TIMING_CONTEXT, *PSYNC_SET_ACPI_TIMING_CONTEXT;

NTSTATUS
ChannelSyncSetACPITimingSettings (
    IN PFDO_EXTENSION FdoExtension,
    IN PACPI_IDE_TIMING TimimgSettings,
    IN PIDENTIFY_DATA AtaIdentifyData[MAX_IDE_DEVICE]
    );

NTSTATUS
ChannelSyncSetACPITimingSettingsCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PVOID Context
    );

typedef
NTSTATUS
(*PSET_ACPI_TIMING_COMPLETION_ROUTINE) (
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PVOID Context
    );

typedef struct _ASYNC_SET_ACPI_TIMING_CONTEXT {

    PFDO_EXTENSION FdoExtension;

    PSET_ACPI_TIMING_COMPLETION_ROUTINE CallerCompletionRoutine;
    PVOID CallerContext;

} ASYNC_SET_ACPI_TIMING_CONTEXT, *PASYNC_SET_ACPI_TIMING_CONTEXT;

NTSTATUS
ChannelSetACPITimingSettings (
    IN PFDO_EXTENSION FdoExtension,
    IN PACPI_IDE_TIMING TimimgSettings,
    IN PIDENTIFY_DATA AtaIdentifyData[MAX_IDE_DEVICE],
    IN PSET_ACPI_TIMING_COMPLETION_ROUTINE CallerCompletionRoutine,
    IN PVOID CallerContext
    );

NTSTATUS
ChannelSetACPITimingSettingsCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

#endif // ___acpiutil_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\atapi.h ===
#if !defined (___atapi_h___)
#define ___atapi_h___

/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    atapi.h

Abstract:

    This module contains the structures and definitions for the ATAPI
    IDE miniport driver.

Author:

    Mike Glass


Revision History:

--*/

#include "scsi.h"
#include "stdio.h"
#include "string.h"

ULONG
AtapiParseArgumentString(
    IN PCHAR String,
    IN PCHAR KeyWord
    );

//
// IDE register definition
//
typedef struct _IDE_REGISTERS_3 {
    ULONG Data;
    UCHAR Others[4];
} IDE_REGISTERS_3, *PIDE_REGISTERS_3;

typedef struct _ATA_COMMAND_BLOCK_READ_REGISTERS {

    union {

        struct {
            PUSHORT Data16;
        } w;

        struct {
            PUCHAR Data8;
            PUCHAR Error;
            PUCHAR SectorCount;
            PUCHAR SectorNumber;
            PUCHAR CylinderLow;
            PUCHAR CylinderHigh;
            PUCHAR DriveSelect;
            PUCHAR Status;
        } b;

    } size;

} ATA_COMMAND_BLOCK_READ_REGISTERS, *PATA_COMMAND_BLOCK_READ_REGISTERS;

typedef struct _ATA_COMMAND_BLOCK_WRITE_REGISTERS {

    union {

        struct {
            PUSHORT Data16;
        } w;

        struct {
            PUCHAR Data8;
            PUCHAR Feature;
            PUCHAR SectorCount;
            PUCHAR SectorNumber;
            PUCHAR CylinderLow;
            PUCHAR CylinderHigh;
            PUCHAR DriveSelect;
            PUCHAR Command;
        } b;

    } size;

} ATA_COMMAND_BLOCK_WRITE_REGISTERS, *PATA_COMMAND_BLOCK_WRITE_REGISTERS;

typedef struct _ATAPI_COMMAND_BLOCK_READ_REGISTERS {

    union {

        struct {
            PUSHORT Data16;
        } w;

        struct {
            PUCHAR Data8;
            PUCHAR Error;
            PUCHAR InterruptReason;
            PUCHAR Reserved;
            PUCHAR ByteCountLow;
            PUCHAR ByteCountHigh;
            PUCHAR DriveSelect;
            PUCHAR Status;
        } b;

    } size;

} ATAPI_COMMAND_BLOCK_READ_REGISTERS, *PATAPI_COMMAND_BLOCK_READ_REGISTERS;

typedef struct _ATAPI_COMMAND_BLOCK_WRITE_REGISTERS {

    union {

        struct {
            PUSHORT Data16;
        } w;

        struct {
            PUCHAR Data8;
            PUCHAR Feature;
            PUCHAR Resereved0;
            PUCHAR Resereved1;
            PUCHAR ByteCountLow;
            PUCHAR ByteCountHigh;
            PUCHAR DriveSelect;
            PUCHAR Command;
        } b;
    } size;

} ATAPI_COMMAND_BLOCK_WRITE_REGISTERS, *PATAPI_COMMAND_BLOCK_WRITE_REGISTERS;

typedef struct _IDE_COMMAND_BLOCK_WRITE_REGISTERS {

    PUCHAR  RegistersBaseAddress;

    union {

        union {

            ATA_COMMAND_BLOCK_READ_REGISTERS r;
            ATA_COMMAND_BLOCK_WRITE_REGISTERS w;

        } ata;

        union {

            ATAPI_COMMAND_BLOCK_READ_REGISTERS r;
            ATAPI_COMMAND_BLOCK_WRITE_REGISTERS w;

        } atapi;

    } type;

} IDE_COMMAND_BLOCK_WRITE_REGISTERS, *PIDE_COMMAND_BLOCK_WRITE_REGISTERS;

//
// handy ata macros
//

#define ATA_DATA16_REG(baseAddress)             (baseAddress)->type.ata.r.size.w.Data16
#define ATA_ERROR_REG(baseAddress)              (baseAddress)->type.ata.r.size.b.Error
#define ATA_SECTOR_COUNT_REG(baseAddress)       (baseAddress)->type.ata.r.size.b.SectorCount
#define ATA_SECTOR_NUMBER_REG(baseAddress)      (baseAddress)->type.ata.r.size.b.SectorNumber
#define ATA_CYLINDER_LOW_REG(baseAddress)       (baseAddress)->type.ata.r.size.b.CylinderLow
#define ATA_CYLINDER_HIGH_REG(baseAddress)      (baseAddress)->type.ata.r.size.b.CylinderHigh
#define ATA_DRIVE_SELECT_REG(baseAddress)       (baseAddress)->type.ata.r.size.b.DriveSelect
#define ATA_STATUS_REG(baseAddress)             (baseAddress)->type.ata.r.size.b.Status

#define ATA_FEATURE_REG(baseAddress)            (baseAddress)->type.ata.w.size.b.Feature
#define ATA_COMMAND_REG(baseAddress)            (baseAddress)->type.ata.w.size.b.Command

//
// handy atapi macros
//
#define ATAPI_DATA16_REG(baseAddress)           (baseAddress)->type.atapi.r.size.w.Data16
#define ATAPI_ERROR_REG(baseAddress)            (baseAddress)->type.atapi.r.size.b.Error
#define ATAPI_INTERRUPT_REASON_REG(baseAddress) (baseAddress)->type.atapi.r.size.b.InterruptReason
#define ATAPI_BYTECOUNT_LOW_REG(baseAddress)    (baseAddress)->type.atapi.r.size.b.ByteCountLow
#define ATAPI_BYTECOUNT_HIGH_REG(baseAddress)   (baseAddress)->type.atapi.r.size.b.ByteCountHigh
#define ATAPI_DRIVE_SELECT_REG(baseAddress)     (baseAddress)->type.atapi.r.size.b.DriveSelect
#define ATAPI_STATUS_REG(baseAddress)           (baseAddress)->type.atapi.r.size.b.Status

#define ATAPI_FEATURE_REG(baseAddress)          (baseAddress)->type.atapi.w.size.b.Feature
#define ATAPI_COMMAND_REG(baseAddress)          (baseAddress)->type.atapi.w.size.b.Command


//
// Device Extension Device Flags
//

#define DFLAGS_DEVICE_PRESENT        (1 << 0)    // Indicates that some device is present.
#define DFLAGS_ATAPI_DEVICE          (1 << 1)    // Indicates whether Atapi commands can be used.
#define DFLAGS_TAPE_DEVICE           (1 << 2)    // Indicates whether this is a tape device.
#define DFLAGS_INT_DRQ               (1 << 3)    // Indicates whether device interrupts as DRQ is set after
                                                 // receiving Atapi Packet Command

#define DFLAGS_REMOVABLE_DRIVE       (1 << 4)    // Indicates that the drive has the 'removable' bit set in
                                                 // identify data (offset 128)
#define DFLAGS_MEDIA_STATUS_ENABLED  (1 << 5)    // Media status notification enabled

#define DFLAGS_USE_DMA               (1 << 9)    // Indicates whether device can use DMA
#define DFLAGS_LBA                   (1 << 10)   // support LBA addressing
#define DFLAGS_MULTI_LUN_INITED      (1 << 11)   // Indicates that the init path for multi-lun has already been done.

#define DFLAGS_MSN_SUPPORT           (1 << 12)   // Device support media status notification
#define DFLAGS_AUTO_EJECT_ZIP        (1 << 13)   // bootup default enables auto eject
#define DFLAGS_WD_MODE               (1 << 14)   // Indicates that unit is WD-Mode(not SFF-Mode).
#define DFLAGS_LS120_FORMAT          (1 << 15)   // Indicates that unit uses ATAPI_LS120_FORMAT_UNIT to format

#define DFLAGS_USE_UDMA              (1 << 16)    // Indicates whether device can use UDMA
#define DFLAGS_IDENTIFY_VALID        (1 << 17)    // Indicates whether the Identify data is valid or not
#define DFLAGS_IDENTIFY_INVALID      (1 << 18)    // Indicates whether the Identify data is valid or not
#define DFLAGS_RDP_SET               (1 << 19)    // If the srb is for RDP

#define DFLAGS_SONY_MEMORYSTICK      (1 << 20)    // If the device is a Sony Memorystick
#define DFLAGS_48BIT_LBA      		 (1 << 21)    // If the device supports 48-bit LBA
#define DFLAGS_DEVICE_ERASED         (1 << 22)    // Indicates that some device is temporarily blocked for access.

//
// Used to disable 'advanced' features.
//

#define MAX_ERRORS                     4

//
// ATAPI command definitions
//

#define ATAPI_MODE_SENSE   0x5A
#define ATAPI_MODE_SELECT  0x55
#define ATAPI_LS120_FORMAT_UNIT  0x24

//
// ATAPI mode page page code
//
#define ATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE_PAGECODE     (0x00)
#define ATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES_PAGECODE  (0x1b)


//
// ATAPI Command Descriptor Block
//
typedef struct _MODE_PARAMETER_HEADER_10 {
    UCHAR ModeDataLengthMsb;
    UCHAR ModeDataLengthLsb;
    UCHAR MediumType;
    UCHAR Reserved[5];
}MODE_PARAMETER_HEADER_10, *PMODE_PARAMETER_HEADER_10;


typedef struct _ATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES {

    UCHAR PageCode : 6;
    UCHAR Reserved0 : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;

    UCHAR Reserved2:6;
    UCHAR SRFP:1;
    UCHAR SFLP:1;

    UCHAR TotalLun:3;
    UCHAR Reserved3:3;
    UCHAR SML:1;
    UCHAR NCD:1;

    UCHAR Reserved[8];

} ATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES, *PATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES;

typedef struct _ATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE {

    UCHAR PageCode : 6;
    UCHAR Reserved0 : 1;
    UCHAR PSBit : 1;

    UCHAR PageLength;

    UCHAR Reserved2:5;
    UCHAR DVW:1;
    UCHAR SLR:1;
    UCHAR SLM:1;

    UCHAR Reserved3:4;
    UCHAR DDE:1;
    UCHAR Reserved4:3;

} ATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE, *PATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE;


//
// IDE command definitions
//

#define IDE_COMMAND_NOP                         0x00
#define IDE_COMMAND_ATAPI_RESET                 0x08
#define IDE_COMMAND_RECALIBRATE                 0x10
#define IDE_COMMAND_READ                        0x20
#define IDE_COMMAND_READ_EXT                    0x24
#define IDE_COMMAND_READ_DMA_EXT                0x25
#define IDE_COMMAND_READ_DMA_QUEUED_EXT         0x26
#define IDE_COMMAND_READ_MULTIPLE_EXT           0x29
#define IDE_COMMAND_WRITE                       0x30
#define IDE_COMMAND_WRITE_EXT                   0x34
#define IDE_COMMAND_WRITE_DMA_EXT               0x35
#define IDE_COMMAND_WRITE_DMA_QUEUED_EXT        0x36
#define IDE_COMMAND_WRITE_MULTIPLE_EXT          0x39
#define IDE_COMMAND_VERIFY                      0x40
#define IDE_COMMAND_VERIFY_EXT                  0x42
#define IDE_COMMAND_SEEK                        0x70
#define IDE_COMMAND_EXECUTE_DEVICE_DIAGNOSTIC   0x90
#define IDE_COMMAND_SET_DRIVE_PARAMETERS        0x91
#define IDE_COMMAND_ATAPI_PACKET                0xA0
#define IDE_COMMAND_ATAPI_IDENTIFY              0xA1
#define IDE_COMMAND_READ_MULTIPLE               0xC4
#define IDE_COMMAND_WRITE_MULTIPLE              0xC5
#define IDE_COMMAND_SET_MULTIPLE                0xC6
#define IDE_COMMAND_READ_DMA                    0xC8
#define IDE_COMMAND_WRITE_DMA                   0xCA
#define IDE_COMMAND_GET_MEDIA_STATUS            0xDA
#define IDE_COMMAND_STANDBY_IMMEDIATE           0xE0
#define IDE_COMMAND_IDLE_IMMEDIATE              0xE1
#define IDE_COMMAND_CHECK_POWER                 0xE5
#define IDE_COMMAND_SLEEP                       0xE6
#define IDE_COMMAND_FLUSH_CACHE                 0xE7
#define IDE_COMMAND_FLUSH_CACHE_EXT             0xEA
#define IDE_COMMAND_IDENTIFY                    0xEC
#define IDE_COMMAND_MEDIA_EJECT                 0xED
#define IDE_COMMAND_SET_FEATURE                 0xEF
#define IDE_COMMAND_DOOR_LOCK                   0xDE
#define IDE_COMMAND_DOOR_UNLOCK                 0xDF
#define IDE_COMMAND_NO_FLUSH                    0xFF // Commmand value to indicate the target device can't handle any flush command

//
// IDE Set Transfer Mode
//
#define IDE_SET_DEFAULT_PIO_MODE(mode)      ((UCHAR) 1)     // disable I/O Ready
#define IDE_SET_ADVANCE_PIO_MODE(mode)      ((UCHAR) ((1 << 3) | (mode)))
#define IDE_SET_SWDMA_MODE(mode)            ((UCHAR) ((1 << 4) | (mode)))
#define IDE_SET_MWDMA_MODE(mode)            ((UCHAR) ((1 << 5) | (mode)))
#define IDE_SET_UDMA_MODE(mode)             ((UCHAR) ((1 << 6) | (mode)))

#define IDE_SET_FEATURE_SET_TRANSFER_MODE   0x3
#define IDE_SET_FEATURE_ENABLE_WRITE_CACHE  0x2
#define IDE_SET_FEATURE_DISABLE_WRITE_CACHE 0x82

//
// Media Status Set Feature
//
#define IDE_SET_FEATURE_ENABLE_MSN          0x95
#define IDE_SET_FEATURE_DISABLE_MSN         0x31
#define IDE_SET_FEATURE_DISABLE_REVERT_TO_POWER_ON 0x66

//
// IDE drive select/head definitions
//

#define IDE_DRIVE_SELECT_1           0xA0
#define IDE_DRIVE_SELECT_2           0x10

//
// IDE error definitions
//

#define IDE_ERROR_BAD_BLOCK          0x80
#define IDE_ERROR_CRC_ERROR          IDE_ERROR_BAD_BLOCK
#define IDE_ERROR_DATA_ERROR         0x40
#define IDE_ERROR_MEDIA_CHANGE       0x20
#define IDE_ERROR_ID_NOT_FOUND       0x10
#define IDE_ERROR_MEDIA_CHANGE_REQ   0x08
#define IDE_ERROR_COMMAND_ABORTED    0x04
#define IDE_ERROR_END_OF_MEDIA       0x02
#define IDE_ERROR_ILLEGAL_LENGTH     0x01

//
// ATAPI register definition
//

typedef struct _ATAPI_REGISTERS_1 {
    PUCHAR RegistersBaseAddress;

    PUSHORT Data;
    PUCHAR Error;
    PUCHAR InterruptReason;
    PUCHAR Unused1;
    PUCHAR ByteCountLow;
    PUCHAR ByteCountHigh;
    PUCHAR DriveSelect;
    PUCHAR Command;
} ATAPI_REGISTERS_1, *PATAPI_REGISTERS_1;

typedef struct _ATAPI_REGISTERS_2 {
    PUCHAR RegistersBaseAddress;

    PUCHAR DeviceControl;
    PUCHAR DriveAddress;
} ATAPI_REGISTERS_2, *PATAPI_REGISTERS_2;


//
// ATAPI interrupt reasons
//

#define ATAPI_IR_COD 0x01
#define ATAPI_IR_IO  0x02

//
// IDENTIFY data
//
/**************** Moved to ide.h *************
#pragma pack (1)
typedef struct _IDENTIFY_DATA {
    USHORT GeneralConfiguration;            // 00 00
    USHORT NumCylinders;                    // 02  1
    USHORT Reserved1;                       // 04  2
    USHORT NumHeads;                        // 06  3
    USHORT UnformattedBytesPerTrack;        // 08  4
    USHORT UnformattedBytesPerSector;       // 0A  5
    USHORT NumSectorsPerTrack;              // 0C  6
    USHORT VendorUnique1[3];                // 0E  7-9
    UCHAR  SerialNumber[20];                // 14  10-19
    USHORT BufferType;                      // 28  20
    USHORT BufferSectorSize;                // 2A  21
    USHORT NumberOfEccBytes;                // 2C  22
    UCHAR  FirmwareRevision[8];             // 2E  23-26
    UCHAR  ModelNumber[40];                 // 36  27-46
    UCHAR  MaximumBlockTransfer;            // 5E  47
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60  48
    USHORT Capabilities;                    // 62  49
    USHORT Reserved2;                       // 64  50
    UCHAR  VendorUnique3;                   // 66  51
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68  52
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:3;        // 6A  53
    USHORT Reserved3:13;
    USHORT NumberOfCurrentCylinders;        // 6C  54
    USHORT NumberOfCurrentHeads;            // 6E  55
    USHORT CurrentSectorsPerTrack;          // 70  56
    ULONG  CurrentSectorCapacity;           // 72  57-58
    USHORT CurrentMultiSectorSetting;       //     59
    ULONG  UserAddressableSectors;          //     60-61
    USHORT SingleWordDMASupport : 8;        //     62
    USHORT SingleWordDMAActive : 8;
    USHORT MultiWordDMASupport : 8;         //     63
    USHORT MultiWordDMAActive : 8;
    USHORT AdvancedPIOModes : 8;            //     64
    USHORT Reserved4 : 8;
    USHORT MinimumMWXferCycleTime;          //     65
    USHORT RecommendedMWXferCycleTime;      //     66
    USHORT MinimumPIOCycleTime;             //     67
    USHORT MinimumPIOCycleTimeIORDY;        //     68
    USHORT Reserved5[11];                   //     69-79
    USHORT MajorRevision;                   //     80
    USHORT MinorRevision;                   //     81
    USHORT Reserved6[6];                    //     82-87
    USHORT UltraDMASupport : 8;             //     88
    USHORT UltraDMAActive  : 8;             //
    USHORT Reserved7[37];                   //     89-125
    USHORT LastLun:3;                       //     126
    USHORT Reserved8:13;
    USHORT MediaStatusNotification:2;       //     127
    USHORT Reserved9:6;
    USHORT DeviceWriteProtect:1;
    USHORT Reserved10:7;
    USHORT Reserved11[128];                  //     128-255
} IDENTIFY_DATA, *PIDENTIFY_DATA;

//
// Identify data without the Reserved4.
//

//typedef struct _IDENTIFY_DATA2 {
//    USHORT GeneralConfiguration;            // 00 00
//    USHORT NumCylinders;                    // 02  1
//    USHORT Reserved1;                       // 04  2
//    USHORT NumHeads;                        // 06  3
//    USHORT UnformattedBytesPerTrack;        // 08  4
//    USHORT UnformattedBytesPerSector;       // 0A  5
//    USHORT NumSectorsPerTrack;              // 0C  6
//    USHORT VendorUnique1[3];                // 0E  7-9
//    UCHAR  SerialNumber[20];                // 14  10-19
//    USHORT BufferType;                      // 28  20
//    USHORT BufferSectorSize;                // 2A  21
//    USHORT NumberOfEccBytes;                // 2C  22
//    UCHAR  FirmwareRevision[8];             // 2E  23-26
//    UCHAR  ModelNumber[40];                 // 36  27-46
//    UCHAR  MaximumBlockTransfer;            // 5E  47
//    UCHAR  VendorUnique2;                   // 5F
//    USHORT DoubleWordIo;                    // 60  48
//    USHORT Capabilities;                    // 62  49
//    USHORT Reserved2;                       // 64  50
//    UCHAR  VendorUnique3;                   // 66  51
//    UCHAR  PioCycleTimingMode;              // 67
//    UCHAR  VendorUnique4;                   // 68  52
//    UCHAR  DmaCycleTimingMode;              // 69
//    USHORT TranslationFieldsValid:3;        // 6A  53
//    USHORT Reserved3:13;
//    USHORT NumberOfCurrentCylinders;        // 6C  54
//    USHORT NumberOfCurrentHeads;            // 6E  55
//    USHORT CurrentSectorsPerTrack;          // 70  56
//    ULONG  CurrentSectorCapacity;           // 72  57-58
//    USHORT CurrentMultiSectorSetting;       //     59
//    ULONG  UserAddressableSectors;          //     60-61
//    USHORT SingleWordDMASupport : 8;        //     62
//    USHORT SingleWordDMAActive : 8;
//    USHORT MultiWordDMASupport : 8;         //     63
//    USHORT MultiWordDMAActive : 8;
//    USHORT AdvancedPIOModes : 8;            //     64
//    USHORT Reserved4 : 8;
//    USHORT MinimumMWXferCycleTime;          //     65
//    USHORT RecommendedMWXferCycleTime;      //     66
//    USHORT MinimumPIOCycleTime;             //     67
//    USHORT MinimumPIOCycleTimeIORDY;        //     68
//    USHORT Reserved5[11];                   //     69-79
//    USHORT MajorRevision;                   //     80
//    USHORT MinorRevision;                   //     81
//    USHORT Reserved6[6];                    //     82-87
//    USHORT UltraDMASupport : 8;             //     88
//    USHORT UltraDMAActive  : 8;             //
//    USHORT Reserved7[37];                   //     89-125
//    USHORT LastLun:3;                       //     126
//    USHORT Reserved8:13;
//    USHORT MediaStatusNotification:2;       //     127
//    USHORT Reserved9:6;
//    USHORT DeviceWriteProtect:1;
//    USHORT Reserved10:7;
//} IDENTIFY_DATA2, *PIDENTIFY_DATA2;
#pragma pack ()

#define IDENTIFY_DATA_SIZE sizeof(IDENTIFY_DATA)
******************************************************/

//
// Identify Data General Configuration Bit Definition
//
#define IDE_IDDATA_DEVICE_TYPE_MASK          ((1 << 15) | (1 << 14))
#define IDE_IDDATA_ATAPI_DEVICE              ((1 << 15 | (0 << 14))

#define IDE_IDDATA_ATAPI_DEVICE_MASK         ((1 << 12) | (1 << 11) | (1 << 10) | (1 << 9) | (1 << 8))

#define IDE_IDDATA_REMOVABLE                 (1 << 7)

#define IDE_IDDATA_DRQ_TYPE_MASK             ((1 << 6) | (1 << 5))
#define IDE_IDDATA_INTERRUPT_DRQ             ((1 << 6) | (0 << 5))

//
// Identify Data 48 bit lba support
//
#define IDE_IDDATA_48BIT_LBA_SUPPORT		(1<<10)


//
// IDENTIFY capability bit definitions.
//

#define IDENTIFY_CAPABILITIES_DMA_SUPPORTED             (1 << 8)
#define IDENTIFY_CAPABILITIES_LBA_SUPPORTED             (1 << 9)
#define IDENTIFY_CAPABILITIES_IOREADY_CAN_BE_DISABLED   (1 << 10)
#define IDENTIFY_CAPABILITIES_IOREADY_SUPPORTED         (1 << 11)


//
// Identify MediaStatusNotification
//
#define IDENTIFY_MEDIA_STATUS_NOTIFICATION_SUPPORTED    (0x1)

//
// Select LBA mode when progran IDE device
//
#define IDE_LBA_MODE                                    (1 << 6)

//
// ID DATA
//
/********** Not needed ****************
#define IDD_UDMA_MODE0_ACTIVE           (1 << 0)
#define IDD_UDMA_MODE1_ACTIVE           (1 << 1)
#define IDD_UDMA_MODE2_ACTIVE           (1 << 2)
#define IDD_UDMA_MODE3_ACTIVE           (1 << 3)
#define IDD_UDMA_MODE4_ACTIVE           (1 << 4)
#define IDD_UDMA_MODE5_ACTIVE           (1 << 5)

#define IDD_MWDMA_MODE0_ACTIVE          (1 << 0)
#define IDD_MWDMA_MODE1_ACTIVE          (1 << 1)
#define IDD_MWDMA_MODE2_ACTIVE          (1 << 2)

#define IDD_SWDMA_MODE0_ACTIVE          (1 << 0)
#define IDD_SWDMA_MODE1_ACTIVE          (1 << 1)
#define IDD_SWDMA_MODE2_ACTIVE          (1 << 2)

#define IDD_UDMA_MODE0_SUPPORTED        (1 << 0)
#define IDD_UDMA_MODE1_SUPPORTED        (1 << 1)
#define IDD_UDMA_MODE2_SUPPORTED        (1 << 2)

#define IDD_MWDMA_MODE0_SUPPORTED       (1 << 0)
#define IDD_MWDMA_MODE1_SUPPORTED       (1 << 1)
#define IDD_MWDMA_MODE2_SUPPORTED       (1 << 2)

#define IDD_SWDMA_MODE0_SUPPORTED       (1 << 0)
#define IDD_SWDMA_MODE1_SUPPORTED       (1 << 1)
#define IDD_SWDMA_MODE2_SUPPORTED       (1 << 2)
************/

//
// Beautification macros
//

#define HasSlaveDevice(HwExt, Target) (HwExt->DeviceFlags[(Target+1)%MAX_IDE_DEVICE] & DFLAGS_DEVICE_PRESENT)

#ifdef ENABLE_ATAPI_VERIFIER
#define GetBaseStatus(BaseIoAddress, Status) \
            Status = ViIdeGetBaseStatus((PIDE_REGISTERS_1)BaseIoAddress);
                       
#define GetErrorByte(BaseIoAddress, ErrorByte) \
            ErrorByte = ViIdeGetErrorByte((PIDE_REGISTERS_1)BaseIoAddress);
#else
#define GetBaseStatus(BaseIoAddress, Status) \
        Status = IdePortInPortByte((BaseIoAddress)->Command);

#define GetErrorByte(BaseIoAddress, ErrorByte) \
        ErrorByte = IdePortInPortByte((BaseIoAddress)->Error);
#endif

#define WriteCommand(BaseIoAddress, Command) \
    IdePortOutPortByte((BaseIoAddress)->Command, Command);



#define ReadBuffer(BaseIoAddress, Buffer, Count) \
    IdePortInPortWordBuffer((PUSHORT)(BaseIoAddress)->Data, Buffer, Count);

#define WriteBuffer(BaseIoAddress, Buffer, Count) \
    IdePortOutPortWordBuffer((PUSHORT)(BaseIoAddress)->Data, Buffer, Count);

#define WaitOnBusy(BaseIoAddress, Status) \
{ \
    ULONG stallTime;                                                \
    ULONG sec;                                                      \
    ULONG i;                                                        \
    for (sec=0; sec<10; sec++) {  \
        /**/                                                        \
        /* one second loop */                                       \
        /**/                                                        \
        for (i=0; i<25000; i++) {                                   \
            GetStatus(BaseIoAddress, Status);                       \
            if (Status & IDE_STATUS_BUSY) {                         \
                stallTime = 40;                                     \
                KeStallExecutionProcessor(stallTime);               \
                continue;                                           \
            } else {                                                \
                break;                                              \
            }                                                       \
        }                                                           \
        if (Status & IDE_STATUS_BUSY) {                             \
            DebugPrint ((1, "ATAPI: after 1 sec wait, device is still busy with 0x%x status = 0x%x\n", (BaseIoAddress)->RegistersBaseAddress, (ULONG) (Status))); \
        } else {                                                    \
            break;                                                  \
        }                                                           \
    }                                                               \
    if (Status & IDE_STATUS_BUSY) {                                 \
        DebugPrint ((0, "WaitOnBusy failed in %s line %u. 0x%x status = 0x%x\n", __FILE__, __LINE__, (BaseIoAddress)->RegistersBaseAddress, (ULONG) (Status))); \
    }                                                               \
}

#define WaitForDRDY(BaseIoAddress, Status) \
{ \
    ULONG i; \
    WaitOnBusy(BaseIoAddress, Status);\
    for (i=0; i<20000; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (!(Status & IDE_STATUS_IDLE)) { \
            KeStallExecutionProcessor(150); \
            continue; \
        } else { \
            break; \
        } \
    } \
    if (i == 20000) \
        DebugPrint ((0, "WaitForDRDY failed in %s line %u. 0x%x status = 0x%x\n", __FILE__, __LINE__, (BaseIoAddress)->RegistersBaseAddress, (ULONG) (Status))); \
}


#define WaitOnBusyUntil(BaseIoAddress, Status, Millisec) \
{ \
    ULONG i; \
    ULONG maxCount = Millisec * 10;\
    for (i=0; i<maxCount; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            KeStallExecutionProcessor(100); \
            continue; \
        } else { \
            break; \
        } \
    } \
    if (i == maxCount) \
        DebugPrint ((0, "WaitOnBusyUntil failed in %s line %u. status = 0x%x\n", __FILE__, __LINE__, (ULONG) (Status))); \
}


#define WaitOnBaseBusy(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<20000; i++) { \
        GetBaseStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            KeStallExecutionProcessor(150); \
            continue; \
        } else { \
            break; \
        } \
    } \
}

#define WaitForDrq(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<1000; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            KeStallExecutionProcessor(100); \
        } else if (Status & IDE_STATUS_DRQ) { \
            break; \
        } else { \
            KeStallExecutionProcessor(200); \
        } \
    } \
}



#define WaitShortForDrq(BaseIoAddress, Status) \
{ \
    ULONG i; \
    for (i=0; i<2; i++) { \
        GetStatus(BaseIoAddress, Status); \
        if (Status & IDE_STATUS_BUSY) { \
            KeStallExecutionProcessor(100); \
        } else if (Status & IDE_STATUS_DRQ) { \
            break; \
        } else { \
            KeStallExecutionProcessor(100); \
        } \
    } \
}

#define AtapiSoftReset(BaseIoAddress1, BaseIoAddress2, DeviceNumber, interruptOff) \
{\
    ULONG __i;\
    UCHAR statusByte; \
    SelectIdeDevice(BaseIoAddress1, DeviceNumber, 0); \
    KeStallExecutionProcessor(500);\
    IdePortOutPortByte((BaseIoAddress1)->Command, IDE_COMMAND_ATAPI_RESET); \
    KeStallExecutionProcessor(500);\
    SelectIdeDevice(BaseIoAddress1, DeviceNumber, 0); \
    WaitOnBusy(BaseIoAddress1, statusByte); \
    if ( !Is98LegacyIde(BaseIoAddress1) ) { \
        KeStallExecutionProcessor(500); \
    } else { \
        for (__i = 0; __i < 20; __i++) { \
            KeStallExecutionProcessor(500); \
        } \
    } \
    if (interruptOff) { \
        IdePortOutPortByte(BaseIoAddress2->DeviceControl, IDE_DC_DISABLE_INTERRUPTS); \
    } \
}

#define SAVE_ORIGINAL_CDB(DeviceExtension, Srb) \
	RtlCopyMemory(DeviceExtension->OriginalCdb, Srb->Cdb, sizeof(CDB));

#define RESTORE_ORIGINAL_CDB(DeviceExtension, Srb) \
	RtlCopyMemory(Srb->Cdb, DeviceExtension->OriginalCdb, sizeof(CDB));
	
//
// NEC 98: Buffer size of mode sense data.
//
#define MODE_DATA_SIZE          192

typedef enum {
    IdeResetBegin = 0,
    ideResetBusResetInProgress,

    ideResetAtapiReset,
    ideResetAtapiResetInProgress,
    ideResetAtapiIdentifyData,

    ideResetAtaIDP,
    ideResetAtaIDPInProgress,
    ideResetAtaMSN,

    ideResetFinal
} IDE_RESET_STATE;


//
// Definition in ide.h
//
struct IDENTIFY_DATA;
//
// Device extension
//
typedef struct _HW_DEVICE_EXTENSION {

    //
    // Current request on controller.
    //

    PSCSI_REQUEST_BLOCK CurrentSrb;

    //
    // Base register locations
    //

    IDE_REGISTERS_1            BaseIoAddress1;
    IDE_REGISTERS_2            BaseIoAddress2;

    //
    // Register length.
    //

    ULONG   BaseIoAddress1Length;
    ULONG   BaseIoAddress2Length;

    //
    // Max ide device/target-id
    //

    ULONG   MaxIdeDevice;
    ULONG   MaxIdeTargetId;

    //
    // Variables to check empty channel
    //
#ifdef DPC_FOR_EMPTY_CHANNEL
    ULONG CurrentIdeDevice;
    ULONG MoreWait;
    ULONG NoRetry;
#endif
    //
    // Drive Geometry
    //
    ULONG   NumberOfCylinders[MAX_IDE_DEVICE * MAX_IDE_LINE];
    ULONG   NumberOfHeads[MAX_IDE_DEVICE * MAX_IDE_LINE];
    ULONG   SectorsPerTrack[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Interrupt Mode (Level or Edge)
    //

    ULONG InterruptMode;

    //
    // Data buffer pointer.
    //

    PUCHAR DataBuffer;

    //
    // Data words left.
    //

    ULONG BytesLeft;

    //
    // Count of errors. Used to turn off features.
    //

    ULONG ErrorCount;

    //
    // Count of timeouts. Used to turn off features.
    //

    ULONG TimeoutCount[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Indicates number of platters on changer-ish devices.
    //

    ULONG LastLun[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Flags word for each possible device.
    //

    ULONG DeviceFlags[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Indicates the number of blocks transferred per int. according to the
    // identify data.
    //

    UCHAR MaximumBlockXfer[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Indicates expecting an interrupt
    //

    BOOLEAN ExpectingInterrupt;

    //
    // Indicates DMA is in progress
    //

    BOOLEAN DMAInProgress;

    //
    // Keep track of whether we convert a SCSI command to ATAPI on the fly
    //
    BOOLEAN scsi2atapi;

    //
    // Indicate last tape command was DSC Restrictive.
    //

    BOOLEAN RDP;

    //
    // Driver is being used by the crash dump utility or ntldr.
    //

    BOOLEAN DriverMustPoll;

    //
    // Indicates whether '0x1f0' is the base address. Used
    // in SMART Ioctl calls.
    //

    BOOLEAN PrimaryAddress;
    BOOLEAN SecondaryAddress;

    //
    // No IDE_SET_FEATURE_SET_TRANSFER_MODE
    //
    BOOLEAN NoPioSetTransferMode;

    //
    // Placeholder for the original cdb
    //
	UCHAR OriginalCdb[16];

    //
    // Placeholder for the sub-command value of the last
    // SMART command.
    //

    UCHAR SmartCommand;

    //
    // Placeholder for status register after a GET_MEDIA_STATUS command
    //
    UCHAR ReturningMediaStatus;

    //
    // Identify data for device
    //
    IDENTIFY_DATA IdentifyData[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // PCI IDE Parent bus master interface
    //
    PCIIDE_BUSMASTER_INTERFACE BusMasterInterface;

    //
    // Device Specific Info.
    //
    struct _DEVICE_PARAMETERS {

        ULONG   MaxBytePerPioInterrupt;

        UCHAR   IdePioReadCommand;
        UCHAR   IdePioWriteCommand;
        UCHAR   IdeFlushCommand;

        UCHAR   IdePioReadCommandExt;
        UCHAR   IdePioWriteCommandExt;
        UCHAR   IdeFlushCommandExt;

        //
        // Timing Stuff
        //
        BOOLEAN IoReadyEnabled;
        ULONG   BestPioCycleTime;
        ULONG   BestSwDmaCycleTime;
        ULONG   BestMwDmaCycleTime;
        ULONG   BestUDmaCycleTime;

        ULONG   TransferModeSupported;
        ULONG   BestPioMode;
        ULONG   BestSwDmaMode;
        ULONG   BestMwDmaMode;
        ULONG   BestUDmaMode;

        ULONG   TransferModeCurrent;

        ULONG   TransferModeSelected;

        ULONG   TransferModeMask;

    } DeviceParameters[MAX_IDE_DEVICE * MAX_IDE_LINE];

#define RESET_STATE_TABLE_LEN   (((2 + 3 * MAX_IDE_DEVICE) * MAX_IDE_LINE) + 1)

    struct RESET_STATE {

        ULONG WaitBusyCount;

        IDE_RESET_STATE State[RESET_STATE_TABLE_LEN];
        IDE_RESET_STATE DeviceNumber[RESET_STATE_TABLE_LEN];

    } ResetState;

} HW_DEVICE_EXTENSION, *PHW_DEVICE_EXTENSION;

//
// max number of CHS addressable sectors
//
//#define MAX_NUM_CHS_ADDRESSABLE_SECTORS     ((ULONG) (16515072 - 1))
#define MAX_NUM_CHS_ADDRESSABLE_SECTORS     ((ULONG) (16514064))
#define MAX_28BIT_LBA     ((ULONG) (1<<28))

//
// IDE Cycle Timing
//
/****************************Moved to idep.h****************
#define PIO_MODE0_CYCLE_TIME        600
#define PIO_MODE1_CYCLE_TIME        383
#define PIO_MODE2_CYCLE_TIME        240
#define PIO_MODE3_CYCLE_TIME        180
#define PIO_MODE4_CYCLE_TIME        120

#define SWDMA_MODE0_CYCLE_TIME      960
#define SWDMA_MODE1_CYCLE_TIME      480
#define SWDMA_MODE2_CYCLE_TIME      240

#define MWDMA_MODE0_CYCLE_TIME      480
#define MWDMA_MODE1_CYCLE_TIME      150
#define MWDMA_MODE2_CYCLE_TIME      120

#define UDMA_MODE0_CYCLE_TIME       120
#define UDMA_MODE1_CYCLE_TIME       80
#define UDMA_MODE2_CYCLE_TIME       60
#define UDMA_MODE3_CYCLE_TIME       45
#define UDMA_MODE4_CYCLE_TIME       30
#define UDMA_MODE5_CYCLE_TIME       15

#define UNINITIALIZED_CYCLE_TIME    0xffffffff
#define UNINITIALIZED_TRANSFER_MODE 0xffffffff
*/
BOOLEAN
AtapiInterrupt(
    IN PVOID HwDeviceExtension
    );

BOOLEAN
AtapiHwInitialize(
    IN PVOID HwDeviceExtension,
    IN UCHAR FlushCommand[MAX_IDE_DEVICE * MAX_IDE_LINE]
    );

BOOLEAN
AtapiStartIo(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

BOOLEAN
AtapiResetController(
    IN PVOID  HwDeviceExtension,
    IN ULONG  PathId,
    IN PULONG CallAgain
    );

VOID
InitDeviceParameters (
    IN PVOID HwDeviceExtension,
    IN UCHAR FlushCommand[MAX_IDE_DEVICE * MAX_IDE_LINE]
    );

VOID
AtapiProgramTransferMode (
    PHW_DEVICE_EXTENSION DeviceExtension
    );

VOID
AtapiHwInitializeMultiLun (
    IN PVOID HwDeviceExtension,
    IN ULONG TargetId,
    IN ULONG numSlot
    );

ULONG
AtapiSendCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

ULONG
IdeBuildSenseBuffer(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
IdeMediaStatus(
    IN BOOLEAN EnableMSN,
    IN PVOID HwDeviceExtension,
    IN ULONG DeviceNumber
    );

VOID
DeviceSpecificInitialize(
    IN PVOID HwDeviceExtension
    );

BOOLEAN
EnableBusMasterController (
    IN PVOID HwDeviceExtension,
    IN PCHAR userArgumentString
    );

BOOLEAN
AtapiDeviceDMACapable (
    IN PVOID HwDeviceExtension,
    IN ULONG deviceNumber
    );

BOOLEAN
GetAtapiIdentifyQuick (
    PIDE_REGISTERS_1    BaseIoAddress1,
    PIDE_REGISTERS_2    BaseIoAddress2,
    IN ULONG            DeviceNumber,
    OUT PIDENTIFY_DATA  IdentifyData
    );

BOOLEAN
IssueIdentify(
    PIDE_REGISTERS_1    CmdBaseAddr,
    PIDE_REGISTERS_2    CtrlBaseAddr,
    IN ULONG            DeviceNumber,
    IN UCHAR            Command,
    IN BOOLEAN          InterruptOff,
    OUT PIDENTIFY_DATA  IdentifyData
    );

VOID
InitDeviceGeometry(
    PHW_DEVICE_EXTENSION HwDeviceExtension,
    ULONG                Device,
    ULONG                NumberOfCylinders,
    ULONG                NumberOfHeads,
    ULONG                SectorsPerTrack
    );

VOID
InitHwExtWithIdentify(
    IN PVOID           HwDeviceExtension,
    IN ULONG           DeviceNumber,
    IN UCHAR           Command,
    IN PIDENTIFY_DATA  IdentifyData,
    IN BOOLEAN         RemovableMedia
    );

BOOLEAN
SetDriveParameters(
    IN PVOID HwDeviceExtension,
    IN ULONG DeviceNumber,
    IN BOOLEAN Sync
    );

BOOLEAN
FindDevices(
    IN PVOID HwDeviceExtension,
    IN BOOLEAN AtapiOnly
    );

ULONG
IdeSendPassThroughCommand(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

ULONG
IdeSendAtaPassThroughExCommand(
    IN PVOID HwDeviceExtension, 
    IN PSCSI_REQUEST_BLOCK Srb 
    );

BOOLEAN
AtapiSyncResetController(
    IN PVOID  HwDeviceExtension,
    IN ULONG  PathId
    );

NTSTATUS
IdeHardReset (
    PIDE_REGISTERS_1     BaseIoAddress1,
    PIDE_REGISTERS_2     BaseIoAddress2,
    BOOLEAN              InterruptOff,
    BOOLEAN              Sync
    );

ULONG
IdeReadWriteExt(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

ULONG
IdeReadWrite(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
AtapiTaskRegisterSnapshot (
    IN PIDE_REGISTERS_1 CmdRegBase,
    IN OUT PIDEREGS     IdeReg
);

NTSTATUS
AtapiSetTransferMode (
    PHW_DEVICE_EXTENSION DeviceExtension,
    ULONG                DeviceNumber,
    UCHAR                ModeValue
    );

#define     ATA_VERSION_MASK    (0xfffe)
#define     ATA1_COMPLIANCE     (1 << 1)
#define     ATA2_COMPLIANCE     (1 << 2)
#define     ATA3_COMPLIANCE     (1 << 3)
#define     ATA4_COMPLIANCE     (1 << 4)


#endif // ___atapi_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\atapinit.h ===
#if !defined (___atapinit_h___)
/*++

Copyright (C) Microsoft Corporation, 1993 - 1999

Module Name:

    atapinit.h

Abstract:

--*/
#define ___atapinit_h___

BOOLEAN
IdePortInitHwDeviceExtension (
    IN OUT PFDO_EXTENSION FdoExtension
    );
      
VOID
AnalyzeDeviceCapabilities(
    IN OUT PFDO_EXTENSION FdoExtension,
    IN BOOLEAN            MustBePio[MAX_IDE_DEVICE * MAX_IDE_LINE]
    );
      
VOID
AtapiSyncSelectTransferMode (
    IN PFDO_EXTENSION FdoExtension,
    IN OUT PHW_DEVICE_EXTENSION DeviceExtension,
    IN ULONG TimingModeAllowed[MAX_IDE_TARGETID * MAX_IDE_LINE]
    );
      
BOOLEAN
AtapiFindDevices(
    IN PFDO_EXTENSION FdoExtension,
    IN OUT PVOID HwDeviceExtension
    );
    
BOOLEAN
AtapiDMACapable (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN ULONG deviceNumber
    );

IDE_DEVICETYPE
AtapiDetectDevice (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN OUT PPDO_EXTENSION PdoExtension,
    IN OUT PIDENTIFY_DATA IdentifyData,
    IN     BOOLEAN          MustSucceed
    );
    
NTSTATUS
IdePortSelectCHS (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN ULONG              Device,
    IN PIDENTIFY_DATA     IdentifyData
    );

NTSTATUS
IdePortScanBus (
    IN OUT PFDO_EXTENSION FdoExtension
    );
    
#endif // ___atapinit_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\atapinit.c ===
/*++

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    atapinit.c

Abstract:

    This contain routine to enumrate IDE devices on the IDE bus

Author:

    Joe Dai (joedai)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "ideport.h"

extern PULONG InitSafeBootMode;  // imported from NTOS (init.c), must use a pointer to reference the data

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IdePortInitHwDeviceExtension)
#pragma alloc_text(PAGE, AtapiDetectDevice)
#pragma alloc_text(PAGE, IdePreAllocEnumStructs)
#pragma alloc_text(PAGE, IdeFreeEnumStructs)

#pragma alloc_text(NONPAGE, AtapiSyncSelectTransferMode)
                          
#pragma alloc_text(PAGESCAN, AnalyzeDeviceCapabilities)
#pragma alloc_text(PAGESCAN, AtapiDMACapable)
#pragma alloc_text(PAGESCAN, IdePortSelectCHS)
#pragma alloc_text(PAGESCAN, IdePortScanBus)

LONG IdePAGESCANLockCount = 0;
#endif // ALLOC_PRAGMA

#ifdef IDE_MEASURE_BUSSCAN_SPEED
static PWCHAR IdePortBootTimeRegKey[6]= {
    L"IdeBusResetTime",
    L"IdeEmptyChannelCheckTime",
    L"IdeDetectMasterDeviceTime",
    L"IdeDetectSlaveDeviceTime",
    L"IdeCriticalSectionTime",
    L"IdeLastStageScanTime"
};
#endif

static PWCHAR IdePortRegistryDeviceTimeout[MAX_IDE_DEVICE * MAX_IDE_LINE] = {
    MASTER_DEVICE_TIMEOUT,
    SLAVE_DEVICE_TIMEOUT
};

static PWCHAR IdePortRegistryDeviceTypeName[MAX_IDE_DEVICE * MAX_IDE_LINE] = {
    MASTER_DEVICE_TYPE_REG_KEY,
    SLAVE_DEVICE_TYPE_REG_KEY,
    MASTER_DEVICE_TYPE2_REG_KEY,
    SLAVE_DEVICE_TYPE2_REG_KEY
};

static PWCHAR IdePortRegistryDeviceTimingModeName[MAX_IDE_DEVICE * MAX_IDE_LINE] = {
    MASTER_DEVICE_TIMING_MODE,
    SLAVE_DEVICE_TIMING_MODE,
    MASTER_DEVICE_TIMING_MODE2,
    SLAVE_DEVICE_TIMING_MODE2
};

static PWCHAR IdePortRegistryDeviceTimingModeAllowedName[MAX_IDE_DEVICE * MAX_IDE_LINE] = {
    MASTER_DEVICE_TIMING_MODE_ALLOWED,
    SLAVE_DEVICE_TIMING_MODE_ALLOWED,
    MASTER_DEVICE_TIMING_MODE_ALLOWED2,
    SLAVE_DEVICE_TIMING_MODE_ALLOWED2
};

static PWCHAR IdePortRegistryIdentifyDataChecksum[MAX_IDE_DEVICE * MAX_IDE_LINE] = {
    MASTER_IDDATA_CHECKSUM,
    SLAVE_IDDATA_CHECKSUM,
    MASTER_IDDATA_CHECKSUM2,
    SLAVE_IDDATA_CHECKSUM2
};

static PWCHAR IdePortUserRegistryDeviceTypeName[MAX_IDE_DEVICE * MAX_IDE_LINE] = {
    USER_MASTER_DEVICE_TYPE_REG_KEY,
    USER_SLAVE_DEVICE_TYPE_REG_KEY,
    USER_MASTER_DEVICE_TYPE2_REG_KEY,
    USER_SLAVE_DEVICE_TYPE2_REG_KEY
};

static PWCHAR IdePortRegistryUserDeviceTimingModeAllowedName[MAX_IDE_DEVICE * MAX_IDE_LINE] = {
    USER_MASTER_DEVICE_TIMING_MODE_ALLOWED,
    USER_SLAVE_DEVICE_TIMING_MODE_ALLOWED,
    USER_MASTER_DEVICE_TIMING_MODE_ALLOWED2,
    USER_SLAVE_DEVICE_TIMING_MODE_ALLOWED2
};

VOID
AnalyzeDeviceCapabilities(
    IN OUT PFDO_EXTENSION FdoExtension,
    IN BOOLEAN            MustBePio[MAX_IDE_DEVICE * MAX_IDE_LINE]
    )
/*++

Routine Description:

    software-initialize devices on the ide bus

    figure out
        if the attached devices are dma capable
        if the attached devices are LBA ready

Arguments:

    HwDeviceExtension   - HW Device Extension

Return Value:

    none

--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = FdoExtension->HwDeviceExtension;
    ULONG deviceNumber;
    BOOLEAN pioDevicePresent;
    PIDENTIFY_DATA identifyData;
    struct _DEVICE_PARAMETERS * deviceParameters;
    ULONG cycleTime;
    ULONG xferMode;
    ULONG bestXferMode;
    ULONG currentMode;
    ULONG tempMode;

    ULONG numberOfCylinders;
    ULONG numberOfHeads;
    ULONG sectorsPerTrack;

    PULONG TransferModeTimingTable=FdoExtension->TransferModeInterface.TransferModeTimingTable;
    ULONG transferModeTableLength=FdoExtension->TransferModeInterface.TransferModeTableLength;
    ASSERT(TransferModeTimingTable);

    //
    // Code is paged until locked down.
    //
	PAGED_CODE();
#ifdef ALLOC_PRAGMA
	ASSERT(IdePAGESCANLockCount > 0);
#endif

    //
    // Figure out who can do DMA and who cannot
    //
    for (deviceNumber = 0; deviceNumber < deviceExtension->MaxIdeDevice; deviceNumber++) {

        if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT) {

            //
            // check LBA capabilities
            //
            CLRMASK (deviceExtension->DeviceFlags[deviceNumber], DFLAGS_LBA);

            // Some drives lie about their ability to do LBA
            // we don't want to do LBA unless we have to (>8G drive)
            if (deviceExtension->IdentifyData[deviceNumber].UserAddressableSectors > MAX_NUM_CHS_ADDRESSABLE_SECTORS) {

                // some device has a bogus value in the UserAddressableSectors field
                // make sure these 3 fields are max. out as defined in ATA-3 (X3T10 Rev. 6)
                if ((deviceExtension->IdentifyData[deviceNumber].NumCylinders == 16383) &&
                    (deviceExtension->IdentifyData[deviceNumber].NumHeads<= 16) &&
                    (deviceExtension->IdentifyData[deviceNumber].NumSectorsPerTrack== 63)) {

                    deviceExtension->DeviceFlags[deviceNumber] |= DFLAGS_LBA;
                }

				if (!Is98LegacyIde(&deviceExtension->BaseIoAddress1)) {

					//
					// words 1, 3 and 6
					//
					numberOfCylinders = deviceExtension->IdentifyData[deviceNumber].NumCylinders;
					numberOfHeads     = deviceExtension->IdentifyData[deviceNumber].NumHeads;
					sectorsPerTrack   = deviceExtension->IdentifyData[deviceNumber].NumSectorsPerTrack;

					if (deviceExtension->IdentifyData[deviceNumber].UserAddressableSectors >
						(numberOfCylinders * numberOfHeads * sectorsPerTrack)) {

						//
						// some ide driver has a 2G jumer to get around bios
						// problem.  make sure we are not tricked the same way.
						//
						if ((numberOfCylinders <= 0xfff) &&
							(numberOfHeads == 0x10) &&
							(sectorsPerTrack == 0x3f)) {
	
							deviceExtension->DeviceFlags[deviceNumber] |= DFLAGS_LBA;
						}
					}
				}
            }

#ifdef ENABLE_48BIT_LBA
			{
				USHORT commandSetSupport = deviceExtension->IdentifyData[deviceNumber].CommandSetSupport;
				USHORT commandSetActive = deviceExtension->IdentifyData[deviceNumber].CommandSetActive;

				if ((commandSetSupport & IDE_IDDATA_48BIT_LBA_SUPPORT) &&
					(commandSetActive & IDE_IDDATA_48BIT_LBA_SUPPORT)) {
					ULONG maxLBA;

					//
					// get words 100-103 and make sure that it is the same or 
					// greater than words 57-58.
					//
					ASSERT(deviceExtension->IdentifyData[deviceNumber].Max48BitLBA[0] != 0);
					maxLBA = deviceExtension->IdentifyData[deviceNumber].Max48BitLBA[0];
					ASSERT(deviceExtension->IdentifyData[deviceNumber].Max48BitLBA[1] == 0);

					ASSERT(maxLBA >= deviceExtension->IdentifyData[deviceNumber].UserAddressableSectors);

					DebugPrint((0,
								"Max LBA supported is 0x%x\n",
								maxLBA
								));

					if ((FdoExtension->EnableBigLba == 1) && 
						(maxLBA >= MAX_28BIT_LBA)) {

						deviceExtension->DeviceFlags[deviceNumber] |= DFLAGS_48BIT_LBA;
						deviceExtension->DeviceFlags[deviceNumber] |= DFLAGS_LBA;

					} else {

						DebugPrint((1, "big lba disabled\n"));
					}
				}
			}
#endif
            if (deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_LBA) {
                DebugPrint ((DBG_BUSSCAN, "atapi: target %d supports LBA\n", deviceNumber));
            }

            xferMode  = 0;
            cycleTime = UNINITIALIZED_CYCLE_TIME;
            bestXferMode = 0;

            //
            // check for IoReady Line
            //
            if (deviceExtension->IdentifyData[deviceNumber].Capabilities & IDENTIFY_CAPABILITIES_IOREADY_SUPPORTED) {

                deviceExtension->DeviceParameters[deviceNumber].IoReadyEnabled = TRUE;

            } else {

                deviceExtension->DeviceParameters[deviceNumber].IoReadyEnabled = FALSE;
            }

            //
            // Check for PIO mode
            //
            bestXferMode = (deviceExtension->IdentifyData[deviceNumber].PioCycleTimingMode & 0x00ff)+PIO0;

            if (bestXferMode > PIO2) {
                bestXferMode = PIO0;
            }

            ASSERT(bestXferMode < PIO3);

            cycleTime = TransferModeTimingTable[bestXferMode];
            ASSERT(cycleTime);

            GenTransferModeMask(bestXferMode, xferMode);
            currentMode = 1<<bestXferMode;

            if (deviceExtension->IdentifyData[deviceNumber].TranslationFieldsValid & (1 << 1)) {

                if (deviceExtension->DeviceParameters[deviceNumber].IoReadyEnabled) {

                    cycleTime = deviceExtension->IdentifyData[deviceNumber].MinimumPIOCycleTimeIORDY;

                } else {

                    cycleTime = deviceExtension->IdentifyData[deviceNumber].MinimumPIOCycleTime;
                }

                if (deviceExtension->IdentifyData[deviceNumber].AdvancedPIOModes & (1 << 0)) {

                    xferMode |= PIO_MODE3;
                    bestXferMode = 3;

                    currentMode = PIO_MODE3;
                }

                if (deviceExtension->IdentifyData[deviceNumber].AdvancedPIOModes & (1 << 1)) {

                    xferMode |= PIO_MODE4;
                    bestXferMode = 4;

                    currentMode = PIO_MODE4;
                }

                // check if any of the bits > 1 are set. If so, default to PIO_MODE4
                if (deviceExtension->IdentifyData[deviceNumber].AdvancedPIOModes) {
                    GetHighestTransferMode( deviceExtension->IdentifyData[deviceNumber].AdvancedPIOModes,
                                               bestXferMode);
                    bestXferMode += PIO3;

                    if (bestXferMode > PIO4) {
                        DebugPrint((DBG_ALWAYS, 
                                    "ATAPI: AdvancePIOMode > PIO_MODE4. Defaulting to PIO_MODE4. \n"));
                        bestXferMode = PIO4;
                    }

                    currentMode = 1<<bestXferMode;
                    xferMode |= currentMode;
                }

                DebugPrint ((DBG_BUSSCAN,
                             "atapi: target %d IdentifyData AdvancedPIOModes = 0x%x\n",
                             deviceNumber,
                             deviceExtension->IdentifyData[deviceNumber].AdvancedPIOModes));
            }

            ASSERT (cycleTime != UNINITIALIZED_CYCLE_TIME);
            ASSERT (xferMode);
            ASSERT (currentMode);
            deviceExtension->DeviceParameters[deviceNumber].BestPioCycleTime      = cycleTime;
            deviceExtension->DeviceParameters[deviceNumber].BestPioMode           = bestXferMode;

            //
            // can't really figure out the current PIO mode
            // just use the best mode
            //
            deviceExtension->DeviceParameters[deviceNumber].TransferModeCurrent   = currentMode;

            //
            // figure out all the DMA transfer mode this device supports
            //
            currentMode = 0;

            //
            // check singleword DMA timing
            //
            cycleTime = UNINITIALIZED_CYCLE_TIME;
            bestXferMode = UNINITIALIZED_TRANSFER_MODE;

            if (deviceExtension->IdentifyData[deviceNumber].SingleWordDMASupport) {

                DebugPrint ((DBG_BUSSCAN,
                             "atapi: target %d IdentifyData SingleWordDMASupport = 0x%x\n",
                             deviceNumber,
                             deviceExtension->IdentifyData[deviceNumber].SingleWordDMASupport));
                DebugPrint ((DBG_BUSSCAN,
                             "atapi: target %d IdentifyData SingleWordDMAActive = 0x%x\n",
                             deviceNumber,
                             deviceExtension->IdentifyData[deviceNumber].SingleWordDMAActive));

                GetHighestTransferMode( deviceExtension->IdentifyData[deviceNumber].SingleWordDMASupport,
                                           bestXferMode);

                if ((bestXferMode+SWDMA0) > SWDMA2) {
                    bestXferMode = SWDMA2-SWDMA0;
                }

                cycleTime = TransferModeTimingTable[bestXferMode+SWDMA0];
                ASSERT(cycleTime);

                tempMode = 0;
                GenTransferModeMask(bestXferMode, tempMode);

                xferMode |= (tempMode << SWDMA0);

                if (deviceExtension->IdentifyData[deviceNumber].SingleWordDMAActive) {

                    GetHighestTransferMode( deviceExtension->IdentifyData[deviceNumber].SingleWordDMAActive,
                                               currentMode);

                    if ((currentMode+SWDMA0) > SWDMA2) {
                        currentMode = SWDMA2 - SWDMA0;
                    }
                    currentMode = 1 << (currentMode+SWDMA0);
                }
            }

            deviceExtension->DeviceParameters[deviceNumber].BestSwDmaCycleTime    = cycleTime;
            deviceExtension->DeviceParameters[deviceNumber].BestSwDmaMode         = bestXferMode;

            //
            // check multiword DMA timing
            //
            cycleTime = UNINITIALIZED_CYCLE_TIME;
            bestXferMode = UNINITIALIZED_TRANSFER_MODE;

            if (deviceExtension->IdentifyData[deviceNumber].MultiWordDMASupport) {

                DebugPrint ((DBG_BUSSCAN,
                             "atapi: target %d IdentifyData MultiWordDMASupport = 0x%x\n",
                             deviceNumber,
                             deviceExtension->IdentifyData[deviceNumber].MultiWordDMASupport));
                DebugPrint ((DBG_BUSSCAN,
                             "atapi: target %d IdentifyData MultiWordDMAActive = 0x%x\n",
                             deviceNumber,
                             deviceExtension->IdentifyData[deviceNumber].MultiWordDMAActive));

                GetHighestTransferMode( deviceExtension->IdentifyData[deviceNumber].MultiWordDMASupport,
                                           bestXferMode);

                if ((bestXferMode+MWDMA0) > MWDMA2) {
                    bestXferMode = MWDMA2 - MWDMA0;
                }

                cycleTime = TransferModeTimingTable[bestXferMode+MWDMA0];
                ASSERT(cycleTime);

                tempMode = 0;
                GenTransferModeMask(bestXferMode, tempMode);

                xferMode |= (tempMode << MWDMA0);

                if (deviceExtension->IdentifyData[deviceNumber].MultiWordDMAActive) {

                    GetHighestTransferMode( deviceExtension->IdentifyData[deviceNumber].MultiWordDMAActive,
                                               currentMode);

                    if ((currentMode+MWDMA0) > MWDMA2) {
                        currentMode = MWDMA2 - MWDMA0;
                    }
                    currentMode = 1 << (currentMode+MWDMA0);
                }
            }

            if (deviceExtension->IdentifyData[deviceNumber].TranslationFieldsValid & (1 << 1)) {

                DebugPrint ((DBG_BUSSCAN, "atapi: target %d IdentifyData word 64-70 are valid\n", deviceNumber));

                if (deviceExtension->IdentifyData[deviceNumber].MinimumMWXferCycleTime &&
                    deviceExtension->IdentifyData[deviceNumber].RecommendedMWXferCycleTime) {

                    DebugPrint ((DBG_BUSSCAN,
                                 "atapi: target %d IdentifyData MinimumMWXferCycleTime = 0x%x\n",
                                 deviceNumber,
                                 deviceExtension->IdentifyData[deviceNumber].MinimumMWXferCycleTime));
                    DebugPrint ((DBG_BUSSCAN,
                                 "atapi: target %d IdentifyData RecommendedMWXferCycleTime = 0x%x\n",
                                 deviceNumber,
                                 deviceExtension->IdentifyData[deviceNumber].RecommendedMWXferCycleTime));

                    cycleTime = deviceExtension->IdentifyData[deviceNumber].MinimumMWXferCycleTime;
                }
            }

            deviceExtension->DeviceParameters[deviceNumber].BestMwDmaCycleTime = cycleTime;
            deviceExtension->DeviceParameters[deviceNumber].BestMwDmaMode      = bestXferMode;

            //
            // figure out the ultra DMA timing the device supports
            //
            cycleTime = UNINITIALIZED_CYCLE_TIME;
            bestXferMode = UNINITIALIZED_TRANSFER_MODE;
            tempMode = UNINITIALIZED_TRANSFER_MODE; // to set the current mode correctly

            //
            // Consult the channel driver for the UDMA modes that are supported.
            // This will allow new udma modes to be supported. Always trust this funtion.
            // 
            if (FdoExtension->TransferModeInterface.UdmaModesSupported) {

                NTSTATUS status = FdoExtension->TransferModeInterface.UdmaModesSupported (
                             deviceExtension->IdentifyData[deviceNumber],
                             &bestXferMode,
                             &tempMode
                             );

                if (!NT_SUCCESS(status)) {
                    bestXferMode = UNINITIALIZED_TRANSFER_MODE;
                    tempMode = UNINITIALIZED_TRANSFER_MODE;
                }

            }  else {
            
                //
                // No udma support funtions to interpret Identify data in the channel driver. 
                // Interpret in the known way.
                //

                if (deviceExtension->IdentifyData[deviceNumber].TranslationFieldsValid & (1 << 2)) {

                    if (deviceExtension->IdentifyData[deviceNumber].UltraDMASupport) {

                        GetHighestTransferMode( deviceExtension->IdentifyData[deviceNumber].UltraDMASupport,
                                                   bestXferMode);
                    }

                    if (deviceExtension->IdentifyData[deviceNumber].UltraDMAActive) {

                        GetHighestTransferMode( deviceExtension->IdentifyData[deviceNumber].UltraDMAActive,
                                                   tempMode);
                    }

                }
            }


            //
            // Use the current mode if we actually got one
            //
            if (tempMode != UNINITIALIZED_TRANSFER_MODE) {

                currentMode = tempMode;

                if (transferModeTableLength <= (currentMode + UDMA0)) {
                    currentMode = transferModeTableLength-UDMA0-1;
                } 

                currentMode = 1 << (currentMode+UDMA0);
            }

            //
            // make sure that bestXferMode is initialized. if not it indicates that
            // the device does not support udma.
            //
            if (bestXferMode != UNINITIALIZED_TRANSFER_MODE) {

                if (transferModeTableLength <= (bestXferMode + UDMA0)) {
                    bestXferMode = transferModeTableLength-UDMA0-1;
                }

                cycleTime = TransferModeTimingTable[bestXferMode+UDMA0];
                ASSERT(cycleTime);

                tempMode = 0;
                GenTransferModeMask(bestXferMode, tempMode);

                xferMode |= (tempMode << UDMA0);
            }

            //
            // Doesn't really know the ultra dma cycle time
            //
            deviceExtension->DeviceParameters[deviceNumber].BestUDmaCycleTime = cycleTime;
            deviceExtension->DeviceParameters[deviceNumber].BestUDmaMode      = bestXferMode;

            deviceExtension->DeviceParameters[deviceNumber].TransferModeSupported = xferMode;
            deviceExtension->DeviceParameters[deviceNumber].TransferModeCurrent  |= currentMode;

            //
            // Check to see if the device is in the Hall of Shame!
            //
            if (MustBePio[deviceNumber] || 
                !AtapiDMACapable (FdoExtension, deviceNumber) ||
                (*InitSafeBootMode == SAFEBOOT_MINIMAL)) {

                DebugPrint((DBG_XFERMODE,
                            "ATAPI: Reseting DMA Information\n"
                            ));
                //
                // Remove all DMA info
                //
                deviceExtension->DeviceParameters[deviceNumber].BestSwDmaCycleTime = 0;
                deviceExtension->DeviceParameters[deviceNumber].BestMwDmaCycleTime = 0;
                deviceExtension->DeviceParameters[deviceNumber].BestUDmaCycleTime  = 0;
                deviceExtension->DeviceParameters[deviceNumber].BestSwDmaMode      = 0;
                deviceExtension->DeviceParameters[deviceNumber].BestMwDmaMode      = 0;
                deviceExtension->DeviceParameters[deviceNumber].BestUDmaMode       = 0;
                deviceExtension->DeviceParameters[deviceNumber].TransferModeCurrent   &= PIO_SUPPORT;
                deviceExtension->DeviceParameters[deviceNumber].TransferModeSupported &= PIO_SUPPORT;
            }

            // if DMADetectionLevel = 0, clear current DMA mode
            // if DMADetectionLevel = 1, set current mode
            // if DMADetectionLevel = 2, clear all current mode
            // pciidex takes care of this for non-acpi machines. 
            // In acpi systems, it is better to trust the GTM settings.

            //
            // If a device supports any of the advanced PIO mode, we are assuming that
            // the device is a "newer" drive and IDE_COMMAND_READ_MULTIPLE should work.
            // Otherwise, we will turn off IDE_COMMAND_READ_MULTIPLE
            //
            if (deviceExtension->DeviceParameters[deviceNumber].BestPioMode > 2) {

                if (!Is98LegacyIde(&deviceExtension->BaseIoAddress1)) {

                    deviceExtension->MaximumBlockXfer[deviceNumber] =
                        (UCHAR)(deviceExtension->IdentifyData[deviceNumber].MaximumBlockTransfer & 0xFF);

                } else {

                    //
                    // MaximumBlockXfer is less or equal 16
                    //
                    deviceExtension->MaximumBlockXfer[deviceNumber] =
                        ((UCHAR)(deviceExtension->IdentifyData[deviceNumber].MaximumBlockTransfer & 0xFF) > 16)?
                            16 : (UCHAR)(deviceExtension->IdentifyData[deviceNumber].MaximumBlockTransfer & 0xFF);
                }
            } else {

                deviceExtension->MaximumBlockXfer[deviceNumber] = 0;
            }

            DebugPrint ((DBG_XFERMODE,
                         "atapi: target %d transfer timing:\n"
                         "atapi: PIO mode supported   = %4x and best cycle time = %5d ns\n"
                         "atapi: SWDMA mode supported = %4x and best cycle time = %5d ns\n"
                         "atapi: MWDMA mode supported = %4x and best cycle time = %5d ns\n"
                         "atapi: UDMA mode supported  = %x and best cycle time = %5d ns\n"
                         "atapi: Current mode bitmap  = %4x\n",
                         deviceNumber,
                         deviceExtension->DeviceParameters[deviceNumber].TransferModeSupported & PIO_SUPPORT,
                         deviceExtension->DeviceParameters[deviceNumber].BestPioCycleTime,
                         deviceExtension->DeviceParameters[deviceNumber].TransferModeSupported & SWDMA_SUPPORT,
                         deviceExtension->DeviceParameters[deviceNumber].BestSwDmaCycleTime,
                         deviceExtension->DeviceParameters[deviceNumber].TransferModeSupported & MWDMA_SUPPORT,
                         deviceExtension->DeviceParameters[deviceNumber].BestMwDmaCycleTime,
                         deviceExtension->DeviceParameters[deviceNumber].TransferModeSupported & UDMA_SUPPORT,
                         deviceExtension->DeviceParameters[deviceNumber].BestUDmaCycleTime,
                         deviceExtension->DeviceParameters[deviceNumber].TransferModeCurrent
                         ));
        }
    }

} // AnalyzeDeviceCapabilities


VOID
AtapiSyncSelectTransferMode (
    IN PFDO_EXTENSION FdoExtension,
    IN OUT PHW_DEVICE_EXTENSION DeviceExtension,
    IN ULONG TimingModeAllowed[MAX_IDE_TARGETID * MAX_IDE_LINE]
    )
/*++

Routine Description:

    query the best transfer mode for our devices

Arguments:

    FdoExtension
    DeviceExtension   - HW Device Extension
    TimingModeAllowed - Allowed transfer modes

Return Value:

    none

--*/
{
    PCIIDE_TRANSFER_MODE_SELECT  transferModeSelect;
    ULONG                        i;
    NTSTATUS                     status;


    if (!IsNEC_98) {
                                                 
        RtlZeroMemory (&transferModeSelect, sizeof(transferModeSelect));
    
        for (i=0; i<DeviceExtension->MaxIdeDevice; i++) {

            transferModeSelect.DevicePresent[i] = DeviceExtension->DeviceFlags[i] & DFLAGS_DEVICE_PRESENT ? TRUE : FALSE;
    
            //
            // ISSUE: 07/31/2000: How about atapi hard disk
			// We don't know of any. This would suffice for the time being.
            //
            transferModeSelect.FixedDisk[i]     = !(DeviceExtension->DeviceFlags[i] & DFLAGS_ATAPI_DEVICE);
    
            transferModeSelect.BestPioCycleTime[i] = DeviceExtension->DeviceParameters[i].BestPioCycleTime;
            transferModeSelect.BestSwDmaCycleTime[i] = DeviceExtension->DeviceParameters[i].BestSwDmaCycleTime;
            transferModeSelect.BestMwDmaCycleTime[i] = DeviceExtension->DeviceParameters[i].BestMwDmaCycleTime;
            transferModeSelect.BestUDmaCycleTime[i] = DeviceExtension->DeviceParameters[i].BestUDmaCycleTime;
    
            transferModeSelect.IoReadySupported[i] = DeviceExtension->DeviceParameters[i].IoReadyEnabled;
    
            transferModeSelect.DeviceTransferModeSupported[i] = DeviceExtension->DeviceParameters[i].TransferModeSupported;
            transferModeSelect.DeviceTransferModeCurrent[i]   = DeviceExtension->DeviceParameters[i].TransferModeCurrent;
    
            //
            // if we don't have a busmaster capable parent or
            // the device is a tape, stay with pio mode
            //
            // (tape may transfer fewer bytes than requested.
            //  we can't figure exactly byte transfered with DMA)
            //
          //  if ((!FdoExtension->BoundWithBmParent) ||
           //     (DeviceExtension->DeviceFlags[i] & DFLAGS_TAPE_DEVICE)) {
            if (!FdoExtension->BoundWithBmParent) {
    
                transferModeSelect.DeviceTransferModeSupported[i] &= PIO_SUPPORT;
                transferModeSelect.DeviceTransferModeCurrent[i]   &= PIO_SUPPORT;
            }

            //
            // Some miniports need this
            //
            transferModeSelect.IdentifyData[i]=DeviceExtension->IdentifyData[i];
    
            transferModeSelect.UserChoiceTransferMode[i] = FdoExtension->UserChoiceTransferMode[i];
            //
            // honor user's choice and/or last knowen good mode
            //
            transferModeSelect.DeviceTransferModeSupported[i] &= TimingModeAllowed[i];
            transferModeSelect.DeviceTransferModeCurrent[i] &= TimingModeAllowed[i];
    
            // should look at dmadetectionlevel and set DeviceTransferModeDesired
            // we look at dmaDetectionlecel in TransferModeSelect function below.
            // the parameters set here should be honoured anyways, I feel.

        }

        transferModeSelect.TransferModeTimingTable= FdoExtension->
                                                        TransferModeInterface.TransferModeTimingTable;
        transferModeSelect.TransferModeTableLength= FdoExtension->
                                                        TransferModeInterface.TransferModeTableLength;

        ASSERT(FdoExtension->TransferModeInterface.TransferModeSelect);
        status = FdoExtension->TransferModeInterface.TransferModeSelect (
                     FdoExtension->TransferModeInterface.Context,
                     &transferModeSelect
                     );
    } else {                     
        //
        // Always fail for nec98 machines
        //
        status = STATUS_UNSUCCESSFUL; 
    }

    if (!NT_SUCCESS(status)) {
    
        //
        // Unable to get the mode select, default to current PIO mode
        //
        for (i=0; i<DeviceExtension->MaxIdeDevice; i++) {
            DeviceExtension->DeviceParameters[i].TransferModeSelected =
                DeviceExtension->DeviceParameters[i].TransferModeCurrent & PIO_SUPPORT;
                
            DebugPrint ((DBG_XFERMODE,
                         "Atapi: DEFAULT device %d transfer mode current 0x%x  and selected bitmap 0x%x\n",
                         i,
                         DeviceExtension->DeviceParameters[i].TransferModeCurrent,
                         DeviceExtension->DeviceParameters[i].TransferModeSelected));
        }
        
    } else {
    
        for (i=0; i<DeviceExtension->MaxIdeDevice; i++) {
    
            DeviceExtension->DeviceParameters[i].TransferModeSelected =
                transferModeSelect.DeviceTransferModeSelected[i];
    
            DebugPrint ((DBG_XFERMODE,
                         "Atapi: device %d transfer mode current 0x%x  and selected bitmap 0x%x\n",
                         i,
                         DeviceExtension->DeviceParameters[i].TransferModeCurrent,
                         DeviceExtension->DeviceParameters[i].TransferModeSelected));
        }                         
    }

    return;

} // AtapiSelectTransferMode


UCHAR SpecialWDDevicesFWVersion[][9] = {
    {"14.04E28"},
    {"25.26H35"},
    {"26.27J38"},
    {"27.25C38"},
    {"27.25C39"}
};
#define NUMBER_OF_SPECIAL_WD_DEVICES (sizeof(SpecialWDDevicesFWVersion) / (sizeof (UCHAR) * 9))

BOOLEAN
AtapiDMACapable (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN ULONG deviceNumber
    )
/*++

Routine Description:

    check the given device whether it is on our bad device list (non dma device)

Arguments:

    HwDeviceExtension   - HBA miniport driver's adapter data storage
    deviceNumber        - device number

Return Value:

    TRUE if dma capable
    FALSE if not dma capable

--*/
{
    PHW_DEVICE_EXTENSION    deviceExtension = FdoExtension->HwDeviceExtension;
    UCHAR modelNumber[41];
    UCHAR firmwareVersion[9];
    ULONG i;
    BOOLEAN turnOffDMA = FALSE;

    //
    // Code is paged until locked down.
    //
	PAGED_CODE();

#ifdef ALLOC_PRAGMA
	ASSERT(IdePAGESCANLockCount > 0);
#endif

    if (!(deviceExtension->DeviceFlags[deviceNumber] & DFLAGS_DEVICE_PRESENT)) {
        return FALSE;
    }

    //
    // byte swap model number
    //
    for (i=0; i<40; i+=2) {
        modelNumber[i + 0] = deviceExtension->IdentifyData[deviceNumber].ModelNumber[i + 1];
        modelNumber[i + 1] = deviceExtension->IdentifyData[deviceNumber].ModelNumber[i + 0];
    }
    modelNumber[i] = 0;

    //
    // if we have a Western Digial device
    //     if the best dma mode is multi word dma mode 1
    //         if the identify data word offset 129 is not 0x5555
    //            turn off dma unless
    //            if the device firmware version is on the list and
    //            it is the only drive on the bus
    //
    if (3 == RtlCompareMemory(modelNumber, "WDC", 3)) {
        if ((deviceExtension->DeviceParameters[deviceNumber].TransferModeSupported &
            (MWDMA_MODE2 | MWDMA_MODE1)) == MWDMA_MODE1) {

            for (i=0; i<8; i+=2) {
                firmwareVersion[i + 0] = deviceExtension->IdentifyData[deviceNumber].FirmwareRevision[i + 1];
                firmwareVersion[i + 1] = deviceExtension->IdentifyData[deviceNumber].FirmwareRevision[i + 0];
            }
            firmwareVersion[i] = 0;

            //
            // Check the special flag.  If not found, can't use dma
            //
            if (*(((PUSHORT)&deviceExtension->IdentifyData[deviceNumber]) + 129) != 0x5555) {

                DebugPrint ((0, "ATAPI: found mode 1 WD drive. no dma unless it is the only device\n"));

                turnOffDMA = TRUE;

                for (i=0; i<NUMBER_OF_SPECIAL_WD_DEVICES; i++) {

                    if (8 == RtlCompareMemory (firmwareVersion, SpecialWDDevicesFWVersion[i], 8)) {

                        ULONG otherDeviceNumber;

                        //
                        // 0 becomes 1
                        // 1 becomes 0
                        // 2 becomes 3
                        // 3 becomes 2
                        //
                        otherDeviceNumber = ((deviceNumber & 0x2) | ((deviceNumber & 0x1) ^ 1));

                        //
                        // if the device is alone on the bus, we can use dma
                        //
                        if (!(deviceExtension->DeviceFlags[otherDeviceNumber] & DFLAGS_DEVICE_PRESENT)) {
                            turnOffDMA = FALSE;
                            break;
                        }
                    }
                }
            }
        }
    }

    if (turnOffDMA) {
        return FALSE;
    } else {
        return TRUE;
    }
}


IDE_DEVICETYPE
AtapiDetectDevice (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN OUT PPDO_EXTENSION PdoExtension,
    IN OUT PIDENTIFY_DATA IdentifyData,
    IN     BOOLEAN          MustSucceed
    )
/**++

Routine Description:

    Detect the device at this location.
    
    1. Send "ec".
    2. if success read the Identify data and return the device type
    3. else send "a1"
    4. if success read the Identify data and return the device type
    5. else return no device
    
Arguments:
    
    FdoExtension: 
    PdoExtension:
    IdentifyData: Identify data is copied into this buffer if a device is detected.
    MustSucceed:  TRUE if pre-alloced memory is to be used.
    
Return Value:    

    device type: ATA, ATAPI or NO Device
    
--**/
{
    PATA_PASS_THROUGH       ataPassThroughData;
    UCHAR                   ataPassThroughDataBuffer[sizeof(*ataPassThroughData) + sizeof (*IdentifyData)];
    BOOLEAN                 foundIt;
    NTSTATUS                status;

    PIDE_REGISTERS_1        cmdRegBase;
    UCHAR                   statusByte1;
    LONG                    i;
    ULONG                   j;
    IDEREGS                 identifyCommand[3];

    IDE_DEVICETYPE          deviceType;
    BOOLEAN                 resetController = FALSE;

    LARGE_INTEGER           tickCount;
    ULONG                   timeDiff;
    ULONG                   timeoutValue = 0;
    ULONG                   retryCount = 0;
	BOOLEAN					defaultTimeout = FALSE;

    HANDLE                  deviceHandle;

    PAGED_CODE();

    ASSERT(FdoExtension);
    ASSERT(PdoExtension);
    ASSERT(PdoExtension->PathId == 0);
    ASSERT(PdoExtension->TargetId < FdoExtension->HwDeviceExtension->MaxIdeTargetId);

#ifdef ENABLE_ATAPI_VERIFIER
    if (ViIdeFakeMissingDevice(FdoExtension, PdoExtension->TargetId)) {

        IdeLogDeadMeatEvent( PdoExtension->DeadmeatRecord.FileName,
                             PdoExtension->DeadmeatRecord.LineNumber
                             );

        return DeviceNotExist;
    }
#endif //ENABLE_ATAPI_VERIFIER

    ataPassThroughData = (PATA_PASS_THROUGH)ataPassThroughDataBuffer;

    foundIt = FALSE;
    cmdRegBase = &FdoExtension->HwDeviceExtension->BaseIoAddress1;

    if (FdoExtension->UserChoiceDeviceType[PdoExtension->TargetId] == DeviceNotExist) {

        deviceType = DeviceNotExist;

    } else {

        //
        // Look into the registry for last boot configration
        //
        deviceType = DeviceUnknown;
        IdePortGetDeviceParameter(
            FdoExtension,
            IdePortRegistryDeviceTypeName[PdoExtension->TargetId],
            (PULONG)&deviceType
            );

        DebugPrint((DBG_BUSSCAN, 
                    "AtapiDetectDevice - last boot config deviceType = 0x%x\n", 
                    deviceType));

        //
        // Obtain the timeout value.
        // ISSUE: should not be in the class section.
        //

/*****
   status = IoOpenDeviceRegistryKey(
                                    FdoExtension->AttacheePdo,
                                    PLUGPLAY_REGKEY_DEVICE, 
                                    KEY_QUERY_VALUE, 
                                    &deviceHandle);

   DebugPrint((0, "DetectDevice status = %x\n", status));
   ZwClose(deviceHandle);
****/

        IdePortGetDeviceParameter(
            FdoExtension,
            IdePortRegistryDeviceTimeout[PdoExtension->TargetId],
            (PULONG)&timeoutValue
            );

        //
        // if there is no registry entry use the default
        //
        if (timeoutValue == 0) {
            timeoutValue = (PdoExtension->TargetId & 0x1)==0 ? 10 : 3;
			defaultTimeout = TRUE;
        }

        //
        // Use 3s timeout for slave devices in safe boot mode. Why??
        //
        if (*InitSafeBootMode == SAFEBOOT_MINIMAL) {
            timeoutValue = (PdoExtension->TargetId & 0x1)==0 ? 10 : 3;
        }

        //
        // invalidate the last boot configuration
        // we will update it with a new setting if we
        // detect a device
        //
        IdePortSaveDeviceParameter(
            FdoExtension,
            IdePortRegistryDeviceTypeName[PdoExtension->TargetId],
            DeviceUnknown
            );

        if ((PdoExtension->TargetId == 1) && 
            (FdoExtension->MayHaveSlaveDevice == 0)) {
            deviceType = DeviceNotExist;
        } 
    }

#if ENABLE_ATAPI_VERIFIER
    if (!Is98LegacyIde(cmdRegBase)) {
        //
        // simulate device change
        //
        if (deviceType == DeviceIsAta) {
            deviceType = DeviceIsAtapi;
        } else if (deviceType == DeviceIsAtapi) {
            deviceType = DeviceIsAta;
        }
    }
#endif 

    //
    // command to issue
    //
    RtlZeroMemory (identifyCommand, sizeof (identifyCommand));
    if (deviceType == DeviceNotExist) {

        IdeLogDeadMeatEvent( PdoExtension->DeadmeatRecord.FileName,
                             PdoExtension->DeadmeatRecord.LineNumber
                             );
        return DeviceNotExist;

    } else if (deviceType == DeviceIsAta) {

        identifyCommand[0].bCommandReg = IDE_COMMAND_IDENTIFY;
        identifyCommand[0].bReserved   = ATA_PTFLAGS_STATUS_DRDY_REQUIRED | ATA_PTFLAGS_ENUM_PROBING;

        identifyCommand[1].bCommandReg = IDE_COMMAND_ATAPI_IDENTIFY;
        identifyCommand[1].bReserved   = ATA_PTFLAGS_ENUM_PROBING;

    } else {

        identifyCommand[0].bCommandReg = IDE_COMMAND_ATAPI_IDENTIFY;
        identifyCommand[0].bReserved   = ATA_PTFLAGS_ENUM_PROBING;

        identifyCommand[1].bCommandReg = IDE_COMMAND_IDENTIFY;
        identifyCommand[1].bReserved   = ATA_PTFLAGS_STATUS_DRDY_REQUIRED | ATA_PTFLAGS_ENUM_PROBING;
    }
    
    //
    // IDE HACK
    //
    // If we are talking to a non-existing device, the
    // status register value may be unstable.
    // Reading it a few time seems to stablize it.
    //
    RtlZeroMemory (ataPassThroughData, sizeof (*ataPassThroughData));
    ataPassThroughData->IdeReg.bReserved = ATA_PTFLAGS_NO_OP | ATA_PTFLAGS_ENUM_PROBING;
    //
    // Repeat 10 times
    //
    ataPassThroughData->IdeReg.bSectorCountReg = 10;

    LogBusScanStartTimer(&tickCount);

    status = IssueSyncAtaPassThroughSafe (
                 FdoExtension,
                 PdoExtension,
                 ataPassThroughData,
                 FALSE,
                 FALSE,
                 3,
                 MustSucceed
                 );

    timeDiff = LogBusScanStopTimer(&tickCount);
    DebugPrint((DBG_SPECIAL,
                "DetectDevice: Hack for device %d at %x took %u ms\n",
                PdoExtension->TargetId,
                FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                timeDiff
                ));
                
    statusByte1 = ataPassThroughData->IdeReg.bCommandReg;

    if (Is98LegacyIde(cmdRegBase)) {
        UCHAR   driveHeadReg;

        driveHeadReg = ataPassThroughData->IdeReg.bDriveHeadReg;

        if (driveHeadReg != ((PdoExtension->TargetId & 0x1) << 4 | 0xA0)) {
            //
            // Bad controller.
            //

            IdeLogDeadMeatEvent( PdoExtension->DeadmeatRecord.FileName,
                                 PdoExtension->DeadmeatRecord.LineNumber
                                 );
            IdeLogDeadMeatTaskFile( PdoExtension->DeadmeatRecord.IdeReg, 
                                    ataPassThroughData->IdeReg
                                    );

            return DeviceNotExist;
        }

        //
        // There are some H/W as follow...
        //

        if ((statusByte1 & 0xe8) == 0xa8) {

            IdeLogDeadMeatEvent( PdoExtension->DeadmeatRecord.FileName,
                                 PdoExtension->DeadmeatRecord.LineNumber
                                 );
            IdeLogDeadMeatTaskFile( PdoExtension->DeadmeatRecord.IdeReg, 
                                    ataPassThroughData->IdeReg
                                    );
            return DeviceNotExist;
        }
    }

    if (statusByte1 == 0xff) {

        //
        // nothing here
        //

        IdeLogDeadMeatEvent( PdoExtension->DeadmeatRecord.FileName,
                             PdoExtension->DeadmeatRecord.LineNumber
                             );
        IdeLogDeadMeatTaskFile( PdoExtension->DeadmeatRecord.IdeReg, 
                                ataPassThroughData->IdeReg
                                );
        return DeviceNotExist;
    }

    //
    // If the statusByte1 is 80 then try a reset
    //
    if (statusByte1 & IDE_STATUS_BUSY)  {

        //
        // look like it is hung, try reset to bring it back
        //
        RtlZeroMemory (ataPassThroughData, sizeof (*ataPassThroughData));
        ataPassThroughData->IdeReg.bReserved = ATA_PTFLAGS_BUS_RESET;

        LogBusScanStartTimer(&tickCount);
        status = IssueSyncAtaPassThroughSafe(
                     FdoExtension,
                     PdoExtension,
                     ataPassThroughData,
                     FALSE,
                     FALSE,
                     30,
                     MustSucceed
                     );
        timeDiff = LogBusScanStopTimer(&tickCount);
        LogBusScanTimeDiff(FdoExtension, IdePortBootTimeRegKey[0], timeDiff);
        DebugPrint((DBG_SPECIAL, 
                    "DtectDevice: Reset device %d ata %x took %u ms\n",
                    PdoExtension->TargetId,
                    FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                    timeDiff
                    ));
    }

    LogBusScanStartTimer(&tickCount);

    retryCount = 0;

    for (i=0; i<2; i++) {

        BOOLEAN ataIdentify;

        ataIdentify = identifyCommand[i].bCommandReg == IDE_COMMAND_IDENTIFY ? TRUE : FALSE;

        if (ataIdentify) {


            //
            // IDE HACK
            //
            // If we are talking to a non-existing device, the
            // status register value may be unstable.
            // Reading it a few time seems to stablize it.
            //
            RtlZeroMemory (ataPassThroughData, sizeof (*ataPassThroughData));
            ataPassThroughData->IdeReg.bReserved = ATA_PTFLAGS_NO_OP | ATA_PTFLAGS_ENUM_PROBING;
            //
            // Repeat 10 times
            //
            ataPassThroughData->IdeReg.bSectorCountReg = 10;

            status = IssueSyncAtaPassThroughSafe(
                         FdoExtension,
                         PdoExtension,
                         ataPassThroughData,
                         FALSE,
                         FALSE,
                         3,
                         MustSucceed
                         );

            statusByte1 = ataPassThroughData->IdeReg.bCommandReg;


            //
            // a real ATA device should never return this
            //
            if ((statusByte1 == 0x00) ||
                (statusByte1 == 0x01)) {

                //
                // nothing here
                //
                continue;
            }

            deviceType = DeviceIsAta;

            if (Is98LegacyIde(cmdRegBase)) {
               UCHAR               systemPortAData;

               //
               // dip-switch 2 read.
               //
               systemPortAData = IdePortInPortByte( (PUCHAR)SYSTEM_PORT_A );
               DebugPrint((DBG_BUSSCAN, "atapi:AtapiFindNewDevices - ide dip switch %x\n",systemPortAData));
               if (!(systemPortAData & 0x20)) {

                   //
                   // Internal-hd(ide) has been disabled with system-menu.
                   //
                   deviceType = DeviceNotExist;
                   break;
               }
            }

        } else {

            RtlZeroMemory (ataPassThroughData, sizeof (*ataPassThroughData));
            ataPassThroughData->IdeReg.bReserved = ATA_PTFLAGS_NO_OP | ATA_PTFLAGS_ENUM_PROBING;

            status = IssueSyncAtaPassThroughSafe (
                         FdoExtension,
                         PdoExtension,
                         ataPassThroughData,
                         FALSE,
                         FALSE,
                         3,
                         MustSucceed
                         );
            statusByte1 = ataPassThroughData->IdeReg.bCommandReg;

            deviceType = DeviceIsAtapi;
        }

        if ((statusByte1 == 0xff) ||
            (statusByte1 == 0xfe)) {

            //
            // nothing here
            //

            IdeLogDeadMeatEvent( PdoExtension->DeadmeatRecord.FileName,
                                 PdoExtension->DeadmeatRecord.LineNumber
                                 );
            IdeLogDeadMeatTaskFile( PdoExtension->DeadmeatRecord.IdeReg, 
                                    ataPassThroughData->IdeReg
                                    );
            deviceType = DeviceNotExist;
            break;
        }

        //
        // build the ata pass through the id data command
        //
        RtlZeroMemory (ataPassThroughData, sizeof (*ataPassThroughData));
        ataPassThroughData->DataBufferSize = sizeof (*IdentifyData);
        RtlMoveMemory (&ataPassThroughData->IdeReg, identifyCommand + i, sizeof(ataPassThroughData->IdeReg));

        ASSERT(timeoutValue);
        //
        // Issue an id data command to the device
        //
        // some device (Kingston PCMCIA Datapak (non-flash)) takes a long time to response.  we
        // can possibly timeout even an device exists.
        //
        // we have to make a compromise here.  We want to detect slow devices without causing
        // many systems to boot slow.
        //
        // here is the logic:
        //
        // Since we are here (IsChannelEmpty() == FALSE), we are guessing we have at least
        // one device attached and it is a master device.  It should be ok to allow longer
        // timeout when sending ID data to the master.  We should never timeout unless
        // the channel has only a slave device.
        //
        // Yes, we will not detect slow slave device for now.  If anyone complain, we will
        // fix it.
        //
        // You can never win as long as we have broken ATA devices!
        //
        status = IssueSyncAtaPassThroughSafe (
                     FdoExtension,
                     PdoExtension,
                     ataPassThroughData,
                     TRUE,
                     FALSE,
                     timeoutValue,
                     MustSucceed
                     );
        //(PdoExtension->TargetId & 0x1)==0 ? 10 : 1,

        if (NT_SUCCESS(status)) {

            if (!(ataPassThroughData->IdeReg.bCommandReg & IDE_STATUS_ERROR)) {

                DebugPrint ((DBG_BUSSCAN, "IdePort: Found a child on 0x%x target 0x%x\n", cmdRegBase->RegistersBaseAddress, PdoExtension->TargetId));

                foundIt = TRUE;

                if (ataIdentify) {

                    IdePortFudgeAtaIdentifyData(
                        (PIDENTIFY_DATA) ataPassThroughData->DataBuffer
                        );
                }

                break;

            } else {

                DebugPrint ((DBG_BUSSCAN, "AtapiDetectDevice:Command %x,  0x%x target 0x%x failed 0x%x with status 0x%x\n",
                             i,
                             cmdRegBase->RegistersBaseAddress,
                             PdoExtension->TargetId,
                             identifyCommand[i].bCommandReg,
                             ataPassThroughData->IdeReg.bCommandReg
                             ));
            }

        } else {
            DebugPrint ((DBG_BUSSCAN, "AtapiDetectDevice:The irp with command %x,  0x%x target 0x%x failed 0x%x with status 0x%x\n",
                             i,
                             cmdRegBase->RegistersBaseAddress,
                             PdoExtension->TargetId,
                             identifyCommand[i].bCommandReg,
                             status 
                             ));

            deviceType = DeviceNotExist;

            IdeLogDeadMeatEvent( PdoExtension->DeadmeatRecord.FileName,
                                 PdoExtension->DeadmeatRecord.LineNumber
                                 );
            IdeLogDeadMeatTaskFile( PdoExtension->DeadmeatRecord.IdeReg, 
                                    ataPassThroughData->IdeReg
                                    );

            if ((FdoExtension->HwDeviceExtension->DeviceFlags[PdoExtension->TargetId] & DFLAGS_DEVICE_PRESENT) &&
                !(FdoExtension->HwDeviceExtension->DeviceFlags[PdoExtension->TargetId] & DFLAGS_ATAPI_DEVICE) &&
                (retryCount < 2)) {

                //
                // BAD BAD BAD device
                //
                //     SAMSUNG WU32543A (2.54GB)
                //
                // when it does a few UDMA transfers, it kind of forgets
                // how to do ATA identify data so it looks like the device
                // is gone.
                //
                // we better try harder to make sure if it is really gone
                // we will do that by issuing a hard reset and try identify
                // data again.
                //

                if (identifyCommand[i].bCommandReg == IDE_COMMAND_IDENTIFY) {

                    //
                    // ask for an "inline" hard reset before issuing identify command
                    //
                    identifyCommand[i].bReserved |= ATA_PTFLAGS_INLINE_HARD_RESET;

                    //
                    // redo the last command
                    //
                    i -= 1;

                    resetController = TRUE;
                    retryCount++;
                }

            } else {

                if (status == STATUS_IO_TIMEOUT) {

                    //
                    // looks like there is no device there
					// update the registry with a low timeout value if
					// this is the slave device.
                    //
					if ((PdoExtension->TargetId & 0x1) &&
						defaultTimeout) {

						//
						// Use the timeout value of 1s for the next boot.
						//
						DebugPrint((1,
									"Updating the registry with 1s value for device %d\n",
									PdoExtension->TargetId
									));

						IdePortSaveDeviceParameter(
							FdoExtension,
							IdePortRegistryDeviceTimeout[PdoExtension->TargetId],
							1	
							);

					}
                    break;
                }
            }
        }

        //
        // try the next command
        //
    }

    timeDiff = LogBusScanStopTimer(&tickCount);
    DebugPrint((DBG_SPECIAL,
                "DetectDevice: Identify Data for device %d at %x took %u ms\n",
                PdoExtension->TargetId,
                FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                timeDiff
                ));
    //
    // save for the next boot
    //
    IdePortSaveDeviceParameter(
        FdoExtension,
        IdePortRegistryDeviceTypeName[PdoExtension->TargetId],
        deviceType == DeviceNotExist? DeviceUnknown : deviceType
        );

    if (foundIt) {

        RtlMoveMemory (IdentifyData, ataPassThroughData->DataBuffer, sizeof (*IdentifyData));

#if DBG
        {

            UCHAR string[41];

            for (i=0; i<8; i+=2) {
               string[i]     = IdentifyData->FirmwareRevision[i + 1];
               string[i + 1] = IdentifyData->FirmwareRevision[i];
            }
            string[i] = 0;
            DebugPrint((DBG_BUSSCAN, "AtapiDetectDevice: firmware version: %s\n", string));

            for (i=0; i<40; i+=2) {
               string[i]     = IdentifyData->ModelNumber[i + 1];
               string[i + 1] = IdentifyData->ModelNumber[i];
            }
            string[i] = 0;
            DebugPrint((DBG_BUSSCAN, "AtapiDetectDevice: model number: %s\n", string));

            for (i=0; i<20; i+=2) {
               string[i]     = IdentifyData->SerialNumber[i + 1];
               string[i + 1] = IdentifyData->SerialNumber[i];
            }
            string[i] = 0;
            DebugPrint((DBG_BUSSCAN, "AtapiDetectDevice: serial number: %s\n", string));
        }
#endif // DBG
    } else {

        deviceType = DeviceNotExist;
    }

    if (deviceType == DeviceNotExist) {

        IdeLogDeadMeatEvent( PdoExtension->DeadmeatRecord.FileName,
                             PdoExtension->DeadmeatRecord.LineNumber
                             );

        IdeLogDeadMeatTaskFile( PdoExtension->DeadmeatRecord.IdeReg, 
                                ataPassThroughData->IdeReg
                                );

    }

    return deviceType;
}


NTSTATUS
IdePortSelectCHS (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN ULONG              Device,
    IN PIDENTIFY_DATA     IdentifyData
    )
{
    IN PHW_DEVICE_EXTENSION HwDeviceExtension;
    BOOLEAN                 skipSetParameters = FALSE;

    //
    // Code is paged until locked down.
    //
	PAGED_CODE();

#ifdef ALLOC_PRAGMA
	ASSERT(IdePAGESCANLockCount > 0);
#endif

    ASSERT(FdoExtension);
    ASSERT(IdentifyData);

    HwDeviceExtension = FdoExtension->HwDeviceExtension;
    ASSERT (HwDeviceExtension);
    ASSERT(Device < HwDeviceExtension->MaxIdeDevice);

    // LBA???
    // We set the LBA flag in AnalyzeDeviceCapabilities.
    //

    if (!((HwDeviceExtension->DeviceFlags[Device] & DFLAGS_DEVICE_PRESENT) &&
         (!(HwDeviceExtension->DeviceFlags[Device] & DFLAGS_ATAPI_DEVICE)))) {

        return STATUS_SUCCESS;
    }

    if (!Is98LegacyIde(&HwDeviceExtension->BaseIoAddress1) &&
        (((IdentifyData->NumberOfCurrentCylinders *
           IdentifyData->NumberOfCurrentHeads *
           IdentifyData->CurrentSectorsPerTrack) <
          (IdentifyData->NumCylinders *
           IdentifyData->NumHeads *
           IdentifyData->NumSectorsPerTrack)) ||  // discover a larger drive
          (IdentifyData->MajorRevision == 0) ||
          ((IdentifyData->NumberOfCurrentCylinders == 0) ||
           (IdentifyData->NumberOfCurrentHeads == 0) ||
           (IdentifyData->CurrentSectorsPerTrack == 0))) ) {

        HwDeviceExtension->NumberOfCylinders[Device] = IdentifyData->NumCylinders;
        HwDeviceExtension->NumberOfHeads[Device]     = IdentifyData->NumHeads;
        HwDeviceExtension->SectorsPerTrack[Device]   = IdentifyData->NumSectorsPerTrack;

    } else {

        HwDeviceExtension->NumberOfCylinders[Device] = IdentifyData->NumberOfCurrentCylinders;
        HwDeviceExtension->NumberOfHeads[Device]     = IdentifyData->NumberOfCurrentHeads;
        HwDeviceExtension->SectorsPerTrack[Device]   = IdentifyData->CurrentSectorsPerTrack;
    }

    if ((IdentifyData->NumCylinders != IdentifyData->NumberOfCurrentCylinders) ||
        (IdentifyData->NumHeads     != IdentifyData->NumberOfCurrentHeads)     ||
        (IdentifyData->NumSectorsPerTrack != IdentifyData->CurrentSectorsPerTrack)) {

        DebugPrint ((
            DBG_ALWAYS,
            "0x%x device %d current CHS (%x,%x,%x) differs from default CHS (%x,%x,%x)\n",
            HwDeviceExtension->BaseIoAddress1.RegistersBaseAddress,
            Device,
            IdentifyData->NumberOfCurrentCylinders,
            IdentifyData->NumberOfCurrentHeads,
            IdentifyData->CurrentSectorsPerTrack,
            IdentifyData->NumCylinders,
            IdentifyData->NumHeads,
            IdentifyData->NumSectorsPerTrack
            ));
    }

    //
    // This hideous hack is to deal with ESDI devices that return
    // garbage geometry in the IDENTIFY data.
    // This is ONLY for the crashdump environment as
    // these are ESDI devices.
    //

    if (HwDeviceExtension->SectorsPerTrack[Device] ==
            0x35 &&
        HwDeviceExtension->NumberOfHeads[Device] ==
            0x07) {

        DebugPrint((DBG_ALWAYS,
                   "FindDevices: Fix up the geometry for ESDI!\n"));

        //
        // Change these values to something reasonable.
        //

        HwDeviceExtension->SectorsPerTrack[Device] =
            0x34;
        HwDeviceExtension->NumberOfHeads[Device] =
            0x0E;
    }

    if (HwDeviceExtension->SectorsPerTrack[Device] ==
            0x35 &&
        HwDeviceExtension->NumberOfHeads[Device] ==
            0x0F) {

        DebugPrint((DBG_ALWAYS,
                   "FindDevices: Fix up the geometry for ESDI!\n"));
         

        //
        // Change these values to something reasonable.
        //

        HwDeviceExtension->SectorsPerTrack[Device] =
            0x34;
        HwDeviceExtension->NumberOfHeads[Device] =
            0x0F;
    }


    if (HwDeviceExtension->SectorsPerTrack[Device] ==
            0x36 &&
        HwDeviceExtension->NumberOfHeads[Device] ==
            0x07) {

        DebugPrint((DBG_ALWAYS,
                   "FindDevices: Fix up the geometry for ESDI!\n"));

        //
        // Change these values to something reasonable.
        //

        HwDeviceExtension->SectorsPerTrack[Device] =
            0x3F;
        HwDeviceExtension->NumberOfHeads[Device] =
            0x10;
        skipSetParameters = TRUE;
    }

    if (Is98LegacyIde(&HwDeviceExtension->BaseIoAddress1)) {

        skipSetParameters = TRUE;
    }

    if (!skipSetParameters) {

        PIDE_REGISTERS_1 baseIoAddress1 = &HwDeviceExtension->BaseIoAddress1;
        PIDE_REGISTERS_2 baseIoAddress2 = &HwDeviceExtension->BaseIoAddress2;
        UCHAR            statusByte;

        DebugPrintTickCount (FindDeviceTimer, 0);

        DebugPrint ((DBG_BUSSCAN, "IdePortSelectCHS: %s %d\n", __FILE__, __LINE__));

        //
        // Select the device.
        //
        SelectIdeDevice(baseIoAddress1, Device, 0);

        DebugPrint ((DBG_BUSSCAN, "IdePortSelectCHS: %s %d\n", __FILE__, __LINE__));

        WaitOnBusy(baseIoAddress1,statusByte);

        DebugPrint ((DBG_BUSSCAN, "IdePortSelectCHS: %s %d\n", __FILE__, __LINE__));

        if (statusByte & IDE_STATUS_BUSY) {
            ULONG  waitCount = 20000;

            DebugPrintTickCount (FindDeviceTimer, 0);

            //
            // Reset the device.
            //

            DebugPrint((2,
                        "FindDevices: Resetting controller before SetDriveParameters.\n"));

            DebugPrint ((DBG_BUSSCAN, "IdePortSelectCHS: %s %d\n", __FILE__, __LINE__));

            IdeHardReset (
                baseIoAddress1,
                baseIoAddress2,
                FALSE,
                TRUE
                );

            DebugPrint ((DBG_BUSSCAN, "IdePortSelectCHS: %s %d\n", __FILE__, __LINE__));

            DebugPrintTickCount (FindDeviceTimer, 0);
        }

        DebugPrint ((DBG_BUSSCAN, "IdePortSelectCHS: %s %d\n", __FILE__, __LINE__));

        WaitOnBusy(baseIoAddress1,statusByte);

        DebugPrint ((DBG_BUSSCAN, "IdePortSelectCHS: %s %d\n", __FILE__, __LINE__));

        DebugPrintTickCount (FindDeviceTimer, 0);

        DebugPrint((2,
                    "FindDevices: Status before SetDriveParameters: (%x) (%x)\n",
                    statusByte,
                    IdePortInPortByte (baseIoAddress1->DriveSelect)));

        //
        // Use the IDENTIFY data to set drive parameters.
        //

        DebugPrint ((DBG_BUSSCAN, "IdePortSelectCHS: %s %d\n", __FILE__, __LINE__));

        if (!SetDriveParameters(HwDeviceExtension,Device,TRUE)) {

            DebugPrint((0,
                       "IdePortFixUpCHS: Set drive parameters for device %d failed\n",
                       Device));

            //
            // Don't use this device as writes could cause corruption.
            //

            HwDeviceExtension->DeviceFlags[Device] = 0;
        }

        DebugPrint ((DBG_BUSSCAN, "IdePortSelectCHS: %s %d\n", __FILE__, __LINE__));
    }

    return STATUS_SUCCESS;
}

NTSTATUS
IdePortScanBus (
    IN OUT PFDO_EXTENSION FdoExtension
    )
/**++

Routine Description:

    Scans the IDE bus (channel) for devices. It also configures the detected devices.
    The "safe" routines used in the procedure are not thread-safe, they use pre-allocated
    memory. The important steps in the enumeration of a channel are:
      
    1. Detect the devices on the channel
    2. Stop all the device queues
    3. Determine and set the transfer modes and the other flags
    4. Start all the device queues
    5. IssueInquiry 
    
Arguments:

    FdoExtension: Functional device extension

Return Value:

    STATUS_SUCCESS : if the operation succeeded
    Failure status : if the operation fails
    
--**/
{
    NTSTATUS                status;
    IDE_PATH_ID             pathId;
    ULONG                   target;
    ULONG                   lun;

    PPDO_EXTENSION          pdoExtension;
    PHW_DEVICE_EXTENSION    hwDeviceExtension;
    PIDEDRIVER_EXTENSION    ideDriverExtension;

    INQUIRYDATA             InquiryData;
    IDENTIFY_DATA           identifyData[MAX_IDE_TARGETID * MAX_IDE_LINE];
    ULONG                   idDatacheckSum[MAX_IDE_TARGETID * MAX_IDE_LINE];
    SPECIAL_ACTION_FLAG     specialAction[MAX_IDE_TARGETID*MAX_IDE_LINE];
    IDE_DEVICETYPE          deviceType[MAX_IDE_TARGETID * MAX_IDE_LINE];
    BOOLEAN                 mustBePio[MAX_IDE_TARGETID * MAX_IDE_LINE];
    BOOLEAN                 pioByDefault[MAX_IDE_TARGETID * MAX_IDE_LINE];
    UCHAR                   flushCommand[MAX_IDE_TARGETID * MAX_IDE_LINE];
    BOOLEAN                 removableMedia[MAX_IDE_TARGETID * MAX_IDE_LINE];
    BOOLEAN                 isLs120[MAX_IDE_TARGETID * MAX_IDE_LINE];
    BOOLEAN                 noPowerDown[MAX_IDE_TARGETID * MAX_IDE_LINE];
    BOOLEAN                 isSameDevice[MAX_IDE_TARGETID * MAX_IDE_LINE];
    ULONG                   lastKnownGoodTimingMode[MAX_IDE_TARGETID * MAX_IDE_LINE];
    ULONG                   savedTransferMode[MAX_IDE_TARGETID * MAX_IDE_LINE];
	PULONG 					enableBigLba;

    ULONG                   numSlot=0;
    ULONG                   numPdoChildren;
    UCHAR                   targetModelNum[MAX_MODELNUM_SIZE+sizeof('\0')]; //extra bytes for '\0'
    HANDLE                  pageScanCodePageHandle;
    BOOLEAN                 newPdo;
    BOOLEAN                 check4EmptyChannel;
    BOOLEAN                 emptyChannel;
    BOOLEAN                 mustSucceed=TRUE;
    KIRQL                   currentIrql;
    BOOLEAN                 inSetup;
    PULONG                  waitOnPowerUp;

    LARGE_INTEGER           tickCount;
    ULONG                   timeDiff;
    LARGE_INTEGER           totalDeviceDetectionTime;
    totalDeviceDetectionTime.QuadPart = 0;

//
// This macro is used in IdePortScanBus
//
#define RefLuExt(pdoExtension, fdoExtension, pathId, removedOk, newPdo) {\
        pdoExtension = RefLogicalUnitExtensionWithTag( \
                           fdoExtension, \
                           (UCHAR) pathId.b.Path, \
                           (UCHAR) pathId.b.TargetId, \
                           (UCHAR) pathId.b.Lun, \
                           removedOk, \
                           IdePortScanBus \
                           ); \
        if (pdoExtension == NULL) { \
            pdoExtension = AllocatePdoWithTag( \
                               fdoExtension, \
                               pathId, \
                               IdePortScanBus \
                               ); \
            newPdo = TRUE; \
        } \
}

//
// This macro is used in IdePortScanBus
//
#define UnRefLuExt(pdoExtension, fdoExtension, sync, callIoDeleteDevice, newPdo) { \
        if (newPdo) { \
            FreePdoWithTag( \
                pdoExtension, \
                sync, \
                callIoDeleteDevice, \
                IdePortScanBus \
                ); \
        } else { \
            UnrefLogicalUnitExtensionWithTag ( \
                fdoExtension, \
                pdoExtension, \
                IdePortScanBus \
                ); \
        } \
}
    //
    // Before getting in to this critical region, we must lock down
    // all the code and data because we may have stopped the paging
    // device!
    //
    // lock down all code that belongs to PAGESCAN
    //
#ifdef ALLOC_PRAGMA
    pageScanCodePageHandle = MmLockPagableCodeSection(
                                 IdePortScanBus
                                 );
	InterlockedIncrement(&IdePAGESCANLockCount);
#endif
                                 

    ASSERT(FdoExtension);
    ASSERT(FdoExtension->PreAllocEnumStruct);

    hwDeviceExtension = FdoExtension->HwDeviceExtension;

    if (FdoExtension->InterruptObject == NULL) {
        
        //
        // we are started with no irq.  it means
        // we have no children.  it is ok to poke
        // at the ports directly
        //
        if (IdePortChannelEmpty (&hwDeviceExtension->BaseIoAddress1, 
                                 &hwDeviceExtension->BaseIoAddress2, 
                                 hwDeviceExtension->MaxIdeDevice) == FALSE) {

            //
            // this channel is started with out an irq
            // it was because the channel looked empty
            // but, now it doesn't look empty.  we need
            // to restart with an irq resource
            //
            if (FdoExtension->RequestProperResourceInterface) {
                FdoExtension->RequestProperResourceInterface (FdoExtension->AttacheePdo);
            }
            else {
                DebugPrint((DBG_ALWAYS, 
                            "No interface to request resources. Probably a pcmcia parent\n"));
            }
        }
        goto done;
    }

    DebugPrint ((
        DBG_BUSSCAN,
        "IdePort: scan bus 0x%x\n",
        FdoExtension->IdeResource.TranslatedCommandBaseAddress
        ));

    inSetup = IdePortInSetup(FdoExtension);

    DebugPrint((DBG_BUSSCAN,
                "ATAPI: insetup = 0x%x\n",
                inSetup?  1: 0
                ));

    waitOnPowerUp = NULL;

    IdePortGetParameterFromServiceSubKey (
                            FdoExtension->DriverObject,
                            L"WaitOnBusyOnPowerUp",
                            REG_DWORD,
                            TRUE,
                            (PVOID) &waitOnPowerUp,
                            0
                            );

    FdoExtension->WaitOnPowerUp = PtrToUlong(waitOnPowerUp);

    check4EmptyChannel = FALSE;
    FdoExtension->DeviceChanged = FALSE;
    pathId.l = 0;
    for (target = 0; target < hwDeviceExtension->MaxIdeTargetId; target++) {

        pathId.b.TargetId = target;
        pathId.b.Lun = 0;
        newPdo = FALSE;
        mustBePio[target] = FALSE;

        RefLuExt(pdoExtension, FdoExtension, pathId, TRUE, newPdo);

        if (!newPdo && (pdoExtension->PdoState & PDOS_DEADMEAT)) {

            //
            // device marked dead already
            //
            UnrefLogicalUnitExtensionWithTag (
                FdoExtension,
                pdoExtension,
                IdePortScanBus
                );
            ASSERT (FALSE);
            pdoExtension = NULL;
        }

        if (!pdoExtension) {

            DebugPrint ((DBG_ALWAYS,
                         "ATAPI: IdePortScanBus() is unable to get pdo (%d,%d,%d)\n",
                         pathId.b.Path,
                         pathId.b.TargetId,
                         pathId.b.Lun));

            deviceType[target] = DeviceNotExist;
            continue;
        }
        
        if (!check4EmptyChannel) {

            ULONG i;
            UCHAR statusByte1;
            ATA_PASS_THROUGH ataPassThroughData;

            check4EmptyChannel = TRUE;

            //
            // make sure the channel is not empty
            //
            RtlZeroMemory (&ataPassThroughData, sizeof (ataPassThroughData));
            ataPassThroughData.IdeReg.bReserved = ATA_PTFLAGS_EMPTY_CHANNEL_TEST;

            LogBusScanStartTimer(&tickCount);

            status = IssueSyncAtaPassThroughSafe(
                         FdoExtension,
                         pdoExtension,
                         &ataPassThroughData,
                         FALSE,
                         FALSE,
                         30,
                         TRUE
                         );
            if (NT_SUCCESS(status)) {
                emptyChannel = TRUE;
            } else {
                emptyChannel = FALSE;
            }

            timeDiff = LogBusScanStopTimer(&tickCount);
            LogBusScanTimeDiff(FdoExtension, IdePortBootTimeRegKey[1], timeDiff);
            DebugPrint((DBG_SPECIAL,
                        "BusScan: Empty Channel check for fdoe %x took %u ms\n",
                        FdoExtension,
                        timeDiff
                        ));
        }

        LogBusScanStartTimer(&tickCount);

        if (!emptyChannel) {

            deviceType[target] = AtapiDetectDevice (FdoExtension, pdoExtension, 
                                                    identifyData + target, TRUE);
            
            if (deviceType[target] != DeviceNotExist) {

                SETMASK (hwDeviceExtension->DeviceFlags[target], DFLAGS_DEVICE_PRESENT);

                if (deviceType[target] == DeviceIsAtapi) {
                    SETMASK (hwDeviceExtension->DeviceFlags[target], DFLAGS_ATAPI_DEVICE);
                }

                //
                // Check for special action requests for the device
                //
                GetTargetModelId((identifyData+target), targetModelNum);

                specialAction[target] = IdeFindSpecialDevice(targetModelNum, NULL);

                if (specialAction[target] == setFlagSonyMemoryStick ) {

                    ULONG i;

                    // SonyMemoryStick device.
                    SETMASK (hwDeviceExtension->DeviceFlags[target], DFLAGS_SONY_MEMORYSTICK);

                    //
                    // Truncate the hardware id, so that the size of
                    // the memory stick is not included in it.
                    //
                    for (i=strlen("MEMORYSTICK");i<sizeof((identifyData+target)->ModelNumber);i++) {
                        (identifyData+target)->ModelNumber[i+1]='\0';
                    }
                }
            }
            else {
                DebugPrint((DBG_BUSSCAN, "Didn't detect the device %d\n", target));
            }
            
        } else {

            DebugPrint((DBG_SPECIAL,
                        "BusScan: IdeDevicePresent %x detected no device %d\n",
                        FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                        target
                        ));

            //
            // invalidate the last boot configuration
            //
            IdePortSaveDeviceParameter(
                FdoExtension,
                IdePortRegistryDeviceTypeName[pdoExtension->TargetId],
                DeviceUnknown
                );

            deviceType[target] = DeviceNotExist;
        }

        ASSERT (deviceType[target] <= DeviceNotExist);


        timeDiff = LogBusScanStopTimer(&tickCount);
        LogBusScanTimeDiff(FdoExtension, IdePortBootTimeRegKey[2+target], timeDiff);
        DebugPrint((DBG_SPECIAL,
                    "BusScan: Detect device %d for %x took %u ms\n",
                    target,
                    FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                    timeDiff
                    ));
        totalDeviceDetectionTime.QuadPart += timeDiff;

        ASSERT (deviceType[target] <= DeviceNotExist);
        ASSERT (deviceType[target] != DeviceUnknown);
        ASSERT (pdoExtension->TargetId == target);

        if (deviceType[target] != DeviceNotExist) {

            if (target & 1) {

                if (deviceType[(LONG) target - 1] != DeviceNotExist) {

                    if (IdePortSlaveIsGhost (
                            FdoExtension,
                            identifyData + target - 1,
                            identifyData + target - 0)) {

                        //
                        // remove the slave device
                        //
                        deviceType[target] = DeviceNotExist;
                    }
                }
            }
        }

        ASSERT (deviceType[target] <= DeviceNotExist);
        if (deviceType[target] == DeviceNotExist) {

            CLRMASK (hwDeviceExtension->DeviceFlags[target], DFLAGS_IDENTIFY_VALID);
            if (FdoExtension->HwDeviceExtension->DeviceFlags[target] & DFLAGS_DEVICE_PRESENT) {

                IDE_PATH_ID tempPathId;
                PPDO_EXTENSION deadPdoExtension;

                //
                // device went away
                //
                FdoExtension->DeviceChanged = TRUE;

                //
                // mark all PDOs for the missing device DEADMEAT
                //
                tempPathId.l = 0;
                tempPathId.b.TargetId = target;

                while (deadPdoExtension = NextLogUnitExtensionWithTag(
                                          FdoExtension,
                                          &tempPathId,
                                          TRUE,
                                          (PVOID) (~(ULONG_PTR)IdePortScanBus)
                                          )) {

                    if (deadPdoExtension->TargetId == target) {

                        DebugPrint((DBG_BUSSCAN, "Enum Failed for target=%d, PDOe=0x%x\n",
                                                target, deadPdoExtension));

                        KeAcquireSpinLock(&deadPdoExtension->PdoSpinLock, &currentIrql);

                        SETMASK (deadPdoExtension->PdoState, PDOS_DEADMEAT);

                        IdeLogDeadMeatReason( deadPdoExtension->DeadmeatRecord.Reason,
                                              enumFailed;
                                             );

                        KeReleaseSpinLock(&deadPdoExtension->PdoSpinLock, currentIrql);

                        UnrefPdoWithTag (deadPdoExtension, (PVOID) (~(ULONG_PTR)IdePortScanBus));

                    } else {

                        UnrefPdoWithTag (deadPdoExtension, (PVOID) (~(ULONG_PTR)IdePortScanBus));
                        break;
                    }
                }
            }

        } else {

            idDatacheckSum[target] = IdePortSimpleCheckSum (
                                         0,
                                         identifyData[target].ModelNumber,
                                         sizeof(identifyData[target].ModelNumber)
                                         );
            idDatacheckSum[target] += IdePortSimpleCheckSum (
                                         idDatacheckSum[target],
                                         identifyData[target].SerialNumber,
                                         sizeof(identifyData[target].SerialNumber)
                                         );
            idDatacheckSum[target] += IdePortSimpleCheckSum (
                                         idDatacheckSum[target],
                                         identifyData[target].FirmwareRevision,
                                         sizeof(identifyData[target].FirmwareRevision)
                                         );
            if (newPdo) {

                //
                // new device
                //
                FdoExtension->DeviceChanged = TRUE;
                DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: Found a new device. pdoe = x%x\n", pdoExtension));

            } else {

#ifdef ENABLE_ATAPI_VERIFIER
                idDatacheckSum[target] += ViIdeFakeDeviceChange(FdoExtension, target);
#endif //ENABLE_ATAPI_VERIFIER

                if (idDatacheckSum[target] != pdoExtension->IdentifyDataCheckSum) {

                    FdoExtension->DeviceChanged = TRUE;
                    DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: bad bad bad user.  a device is replaced by a different device. pdoe = x%x\n", pdoExtension));

                    //
                    // mark the old device deadmeat
                    //
                    KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

                    SETMASK (pdoExtension->PdoState, PDOS_DEADMEAT | PDOS_NEED_RESCAN);

                    IdeLogDeadMeatReason( pdoExtension->DeadmeatRecord.Reason,
                                          replacedByUser;
                                         );

                    KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

                    //
                    // pretend we have seen the new device.
                    // we will re-enum when the old one is removed.
                    //
                    deviceType[target] = DeviceNotExist;
                }
            }
        }

        ASSERT (deviceType[target] <= DeviceNotExist);
        if (deviceType[target] != DeviceNotExist) {

            ULONG savedIdDataCheckSum;

            mustBePio[target] = IdePortMustBePio (
                                    FdoExtension,
                                    identifyData + target
                                    );
            pioByDefault[target] = IdePortPioByDefaultDevice (
                                    FdoExtension,
                                    identifyData + target
                                    );

            ASSERT (deviceType[target] <= DeviceNotExist);

            LogBusScanStartTimer(&tickCount);

            flushCommand[target] = IDE_COMMAND_NO_FLUSH;

            //
            // we need this only for ata devices
            //
            if (deviceType[target] != DeviceIsAtapi) {

                flushCommand[target] = IdePortGetFlushCommand (
                                           FdoExtension,
                                           pdoExtension,
                                           identifyData + target
                                           );
            }

            timeDiff = LogBusScanStopTimer(&tickCount);
            DebugPrint((DBG_SPECIAL,
                        "BusScan: Flush command for device %d at %x took %u ms\n",
                        target,
                        FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                        timeDiff
                        ));

            ASSERT (deviceType[target] <= DeviceNotExist);

            removableMedia[target] = IdePortDeviceHasNonRemovableMedia (
                                         FdoExtension,
                                         identifyData + target
                                         );

            ASSERT (deviceType[target] <= DeviceNotExist);

            isLs120[target] = IdePortDeviceIsLs120 (
                                  FdoExtension,
                                  identifyData + target
                                  );
            ASSERT (deviceType[target] <= DeviceNotExist);

            noPowerDown[target] = IdePortNoPowerDown (
                                      FdoExtension,
                                      identifyData + target
                                      );
            ASSERT (deviceType[target] <= DeviceNotExist);


            //
            // init. the default value to an abnormal #.
            //
            FdoExtension->UserChoiceTransferMode[target] = 0x12345678;

            IdePortGetDeviceParameter(
                FdoExtension,
                IdePortRegistryUserDeviceTimingModeAllowedName[target],
                FdoExtension->UserChoiceTransferMode + target
                );

            if (FdoExtension->UserChoiceTransferMode[target] == 0x12345678) {

                //
                // This value is used to decide whether a user choice was indicated
                // or not. This helps us to set the transfer mode to a default value
                // if the user doesn't choose a particular transfer mode. Otherwise we
                // honour the user choice.
                //
                FdoExtension->UserChoiceTransferMode[target] = UNINITIALIZED_TRANSFER_MODE;

                //
                // we know the register doesn't have what we are looking for
                // set the default atapi-override setting to a value 
                // that will force pio only on atapi device
                //
                FdoExtension->UserChoiceTransferModeForAtapiDevice[target] = PIO_SUPPORT;
            } else {

                //
                // user acutally picked the transfer mode settings.
                // set the default atapi-override setting to a value (-1)
                // that will not affect the user choice.
                FdoExtension->UserChoiceTransferModeForAtapiDevice[target] = MAXULONG;
            }

            // 
            // get the previous mode
            //
            IdePortGetDeviceParameter(
                FdoExtension,
                IdePortRegistryDeviceTimingModeName[target],
                savedTransferMode+target
                );

            savedIdDataCheckSum = 0;
            IdePortGetDeviceParameter(
                FdoExtension,
                IdePortRegistryIdentifyDataChecksum[target],
                &savedIdDataCheckSum
                );

            ASSERT (deviceType[target] <= DeviceNotExist);

            //
            // figure out what transfer mode we can use
            //
            if (savedIdDataCheckSum == idDatacheckSum[target]) {

                //
                // same device. if we program the same transfer mode then
                // we can skip the DMA test
                //
                isSameDevice[target] = TRUE;

                //
                // it is the same device, use
                // the lastKnownGoodTimingMode
                // in the registry
                //
                lastKnownGoodTimingMode[target] = MAXULONG;
                IdePortGetDeviceParameter(
                    FdoExtension,
                    IdePortRegistryDeviceTimingModeAllowedName[target],
                    lastKnownGoodTimingMode + target
                    );

            } else {

                isSameDevice[target] = FALSE;
                lastKnownGoodTimingMode[target] = MAXULONG;

            }


            ASSERT (deviceType[target] <= DeviceNotExist);

            FdoExtension->TimingModeAllowed[target] =
                lastKnownGoodTimingMode[target] &
                FdoExtension->UserChoiceTransferMode[target];
                              
            //
            // TransferModeMask is initially 0.
            //
            FdoExtension->TimingModeAllowed[target] &= ~(hwDeviceExtension->
                                                         DeviceParameters[target].TransferModeMask);

            if (pdoExtension->CrcErrorCount >= PDO_UDMA_CRC_ERROR_LIMIT)  {

                //
                //Reset the error count
                //
                pdoExtension->CrcErrorCount =0;
            }

            DebugPrint ((DBG_XFERMODE, "TMAllowed=%x, TMMask=%x, UserChoice=%x\n",
                         FdoExtension->TimingModeAllowed[target],
                         hwDeviceExtension->DeviceParameters[target].TransferModeMask,
                         FdoExtension->UserChoiceTransferMode[target]));

            ASSERT (deviceType[target] <= DeviceNotExist);
        }

        UnRefLuExt(pdoExtension, FdoExtension, TRUE, TRUE, newPdo);

        pdoExtension = NULL;
    }


#ifdef IDE_MEASURE_BUSSCAN_SPEED
    if (FdoExtension->BusScanTime == 0) {

        FdoExtension->BusScanTime = totalDeviceDetectionTime.LowPart;
    }
#endif // IDE_MEASURE_BUSSCAN_SPEED

#ifdef ENABLE_48BIT_LBA

    //
    // enable big lba support by default
    //
	FdoExtension->EnableBigLba = 1;

#endif

//    if (!deviceChanged && !DBG) {
//
//        //
//        // didn't find anything different than before
//        //
//        return STATUS_SUCCESS;
//    }

    DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: detect a change of device...re-initializing\n"));


    // ISSUE: check if device got removed!!!

    //
    // Begin of a critial region
    // must stop all children, do the stuff, and restart all children
    //

    //
    // cycle through all children and stop their device queue
    //

    LogBusScanStartTimer(&tickCount);

    pathId.l = 0;
    numPdoChildren = 0;
    status = STATUS_SUCCESS;
    while (pdoExtension = NextLogUnitExtensionWithTag(
                              FdoExtension,
                              &pathId,
                              TRUE,
                              IdePortScanBus
                              )) {

        DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: stopping pdo 0x%x\n", pdoExtension));

        status = DeviceStopDeviceQueueSafe (pdoExtension, PDOS_QUEUE_FROZEN_BY_PARENT, TRUE);

        DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: stopped pdo 0x%x\n", pdoExtension));

        UnrefLogicalUnitExtensionWithTag (
            FdoExtension,
            pdoExtension,
            IdePortScanBus
            );
        numPdoChildren++;

        if (!NT_SUCCESS(status)) {
            break;
        }
    }

    if (NT_SUCCESS(status)) {

        BOOLEAN foundAtLeastOneIdeDevice = FALSE;
        BOOLEAN useDma;

        DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: all children are stoped\n"));

        pathId.l = 0;
        for (target = 0; target < hwDeviceExtension->MaxIdeTargetId; target++) {

            ASSERT (deviceType[target] <= DeviceNotExist);
            if (deviceType[target] != DeviceNotExist) {

                pathId.b.TargetId = target;

                newPdo = FALSE;

                RefLuExt(pdoExtension, FdoExtension, pathId, TRUE, newPdo);

                if (!pdoExtension) {
                    continue;
                }
                ASSERT (pdoExtension);

                foundAtLeastOneIdeDevice = TRUE;

                SETMASK (hwDeviceExtension->DeviceFlags[target], DFLAGS_DEVICE_PRESENT);

                if (deviceType[target] == DeviceIsAtapi) {

                    SETMASK (hwDeviceExtension->DeviceFlags[target], DFLAGS_ATAPI_DEVICE);

                    useDma=FALSE;

                    //
                    // skip the dvd test, if ModeSense command is not to be
                    // sent to the device or if we are in setup
                    //
                    if (inSetup) {

                        mustBePio[target] = TRUE;

                    } else if ((specialAction[target] != skipModeSense) &&
                               (!pioByDefault[target])) {

                        useDma = IdePortDmaCdromDrive(FdoExtension,
                                                pdoExtension,
                                                TRUE
                                                );
                    }

					//
					// Don't force PIO if we have seen this before. If it was doing PIO
					// TimingModeAllowed would reflect that. 
					// Set UserChoiceForAtapi to 0xffffffff
					// This won't anyway affect the user choice
					//
                    if ( useDma) {

                        DebugPrint((DBG_BUSSCAN, 
                                    "IdePortScanBus: USE DMA FOR target %d\n",
                                    target
                                    ));

                        FdoExtension->UserChoiceTransferModeForAtapiDevice[target] = MAXULONG;

                    }


                    FdoExtension->TimingModeAllowed[target] &= 
                        FdoExtension->UserChoiceTransferModeForAtapiDevice[target];


                }

                //
                // allow LS-120 Format Command
                //
                if (isLs120[target]) {

                    SETMASK (hwDeviceExtension->DeviceFlags[target], DFLAGS_LS120_FORMAT);
                }

                RtlMoveMemory (
                    hwDeviceExtension->IdentifyData + target,
                    identifyData + target,
                    sizeof (IDENTIFY_DATA)
                    );

                //
                // Always re-use identify data
                // This will get cleared if it is a removable media
                // The queue is stopped. Now I can safely set this flag.
                //
                SETMASK (hwDeviceExtension->DeviceFlags[target], DFLAGS_IDENTIFY_VALID);

                DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: Calling InitHwExtWithIdentify\n"));

                //
                // IdentifyValid flag should be cleared, if it is a removable media
                //
                InitHwExtWithIdentify(
                    hwDeviceExtension,
                    target,
                    (UCHAR) (deviceType[target] == DeviceIsAtapi ? IDE_COMMAND_ATAPI_IDENTIFY : IDE_COMMAND_IDENTIFY),
                    hwDeviceExtension->IdentifyData + target,
                    removableMedia[target]
                    );

                DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: Calling IdePortSelectCHS\n"));

                IdePortSelectCHS (
                    FdoExtension,
                    target,
                    identifyData + target
                    );

                DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: back from IdePortSelectCHS\n"));

                UnRefLuExt(pdoExtension, FdoExtension, TRUE, TRUE, newPdo);

            } else {

                hwDeviceExtension->DeviceFlags[target] = 0;
            }
        }

        if (foundAtLeastOneIdeDevice) {

            DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: Calling AnalyzeDeviceCapabilities\n"));

            //
            // could move this out of the critial region
            //
            AnalyzeDeviceCapabilities (
                FdoExtension,
                mustBePio
                );

            DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: Calling AtapiSelectTransferMode\n"));

			//
            // could move this out of the critial region
            //
            AtapiSyncSelectTransferMode (
                FdoExtension,
                hwDeviceExtension,
                FdoExtension->TimingModeAllowed
                );

            DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: Calling AtapiHwInitialize\n"));

            AtapiHwInitialize (
                FdoExtension->HwDeviceExtension,
                flushCommand
                );
        }

    } else {

        //
        // unable to stop all children, so force an buscheck to try again
        //
//        IoInvalidateDeviceRelations (
//            FdoExtension->AttacheePdo,
//            BusRelations
//            );
    }


    //
    // cycle through all children and restart their device queue
    //
    pathId.l = 0;
    numPdoChildren = 0;
    while (pdoExtension = NextLogUnitExtensionWithTag(
                              FdoExtension,
                              &pathId,
                              TRUE,
                              IdePortScanBus
                              )) {

        DebugPrint ((DBG_BUSSCAN, "IdePortScanBus: re-start pdo 0x%x\n", pdoExtension));

        DeviceStartDeviceQueue (pdoExtension, PDOS_QUEUE_FROZEN_BY_PARENT);

        UnrefLogicalUnitExtensionWithTag (
            FdoExtension,
            pdoExtension,
            IdePortScanBus
            );
        numPdoChildren++;
    }

    timeDiff = LogBusScanStopTimer(&tickCount);
    LogBusScanTimeDiff(FdoExtension, IdePortBootTimeRegKey[4], timeDiff);
    DebugPrint((DBG_SPECIAL,
                "BusScan : Critical section %x took %u ms\n",
                FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                timeDiff
                ));

    if (NT_SUCCESS(status)) {

        //
        // second stage scanning
        //
        pathId.l = 0;

        LogBusScanStartTimer(&tickCount);

        for (target = 0; target < hwDeviceExtension->MaxIdeTargetId; target++) {

            if (deviceType[target] == DeviceNotExist) {

                continue;
            }

            pathId.b.TargetId = target;

            for (lun = 0; lun < FdoExtension->MaxLuCount; lun++) {

                LARGE_INTEGER  tempTickCount;
                pathId.b.Lun = lun;
                newPdo = FALSE;

                RefLuExt(pdoExtension, FdoExtension, pathId, TRUE, newPdo);

                if (!pdoExtension) {
                    continue;
                }

                ASSERT (pdoExtension);

                if (lun == 0) {

#if defined (ALWAYS_VERIFY_DMA)
#undef ALWAYS_VERIFY_DMA
#define ALWAYS_VERIFY_DMA TRUE
#else
#define ALWAYS_VERIFY_DMA FALSE
#endif

                    ASSERT (ALL_MODE_SUPPORT != MAXULONG);
                    if ((FdoExtension->HwDeviceExtension->
                            DeviceParameters[target].TransferModeSelected & DMA_SUPPORT) ||
                        ALWAYS_VERIFY_DMA) {

                        ULONG mode = FdoExtension->HwDeviceExtension->
                            DeviceParameters[target].TransferModeSelected;
                        //
                        // if lastKnownGoodTimingMode is MAX_ULONG, it means
                        // we have never seen this device before and the user
                        // hasn't said anything about what dma mode to use.
                        //
                        // we have chosen to use dma because all the software
                        // detectable parameters (identify dma, pci config data)
                        // looks good for DMA.
                        //
                        // the only thing that can stop us from using DMA now
                        // is bad device.  before we go on, do a little test
                        // to verify dma is ok

                        //
                        // could re-use the inquiry data obtained here.
                        //
                        //
                        // skip the test if we have already seen the device
                        //

                        LogBusScanStartTimer(&tempTickCount);
                        if (isSameDevice[target] &&
                            mode == savedTransferMode[target]) { 

                            DebugPrint((DBG_BUSSCAN, 
                                        "Skip dma test for %d\n", target));

                        } else {

                            IdePortVerifyDma (
                                pdoExtension,
                                deviceType[target]
                                );
                        }
                        timeDiff = LogBusScanStopTimer(&tempTickCount);
                        DebugPrint((DBG_SPECIAL,
                                    "ScanBus: VerifyDma for %x device %d took %u ms\n",
                                    FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                                    target,
                                    timeDiff
                                    ));


                    }

                    //
                    // Initialize numSlot to 0
                    //
                    numSlot=0;

                    //
                    // If this is in the bad cd-rom drive list, then don't
                    // send these Mode Sense command. The drive might lock up.
                    //
                    LogBusScanStartTimer(&tempTickCount);
                    if (specialAction[target] != skipModeSense) {
                        //
                        // Non-CD device
                        //
                        numSlot = IdePortQueryNonCdNumLun (
                                          FdoExtension,
                                          pdoExtension,
                                          FALSE
                                          );
                    } else {
                        DebugPrint((DBG_BUSSCAN, "Skip modesense\n"));
                    }

                    timeDiff = LogBusScanStopTimer(&tempTickCount);
                    DebugPrint((DBG_SPECIAL,
                                "ScanBus: Initialize Luns for %x device %d took %u ms\n",
                                FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                                target,
                                timeDiff
                                ));

                    AtapiHwInitializeMultiLun (
                        FdoExtension->HwDeviceExtension,
                        pdoExtension->TargetId,
                        numSlot
                        );
                }

                if (pdoExtension) {

                    LogBusScanStartTimer(&tempTickCount);
                    status = IssueInquirySafe(FdoExtension, pdoExtension, &InquiryData, TRUE);
                    timeDiff = LogBusScanStopTimer(&tempTickCount);
                    DebugPrint((DBG_SPECIAL,
                                "ScanBus: Inquiry %x for  Lun  %d device %d took %u ms\n",
                                FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                                lun,
                                target,
                                timeDiff
                                ));

                    if (NT_SUCCESS(status) || (status == STATUS_DATA_OVERRUN)) {

                        DeviceInitDeviceType (
                            pdoExtension,
                            &InquiryData
                            );

                        //
                        // Init Ids String for PnP Query ID
                        //
                        DeviceInitIdStrings (
                            pdoExtension,
                            deviceType[target],
                            &InquiryData,
                            identifyData + target
                            );

                        //
                        // Clear rescan flag. Since this LogicalUnit will not be freed,
                        // the IOCTL_SCSI_MINIPORT requests can safely attach.
                        //
                        CLRMASK (pdoExtension->LuFlags, PD_RESCAN_ACTIVE);

                        DebugPrint((DBG_BUSSCAN,"IdePortScanBus: Found device at "));
                        DebugPrint((DBG_BUSSCAN,"   Bus         %d", pdoExtension->PathId));
                        DebugPrint((DBG_BUSSCAN,"   Target Id   %d", pdoExtension->TargetId));
                        DebugPrint((DBG_BUSSCAN,"   LUN         %d\n", pdoExtension->Lun));

                        if (noPowerDown[target] ||
                            (pdoExtension->ScsiDeviceType == READ_ONLY_DIRECT_ACCESS_DEVICE)) {

                            KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

                            SETMASK (pdoExtension->PdoState, PDOS_NO_POWER_DOWN);

                            KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);
                        }

                        pdoExtension->IdentifyDataCheckSum = idDatacheckSum[target];

                        //
                        // done using the current logical unit extension
                        //
                        UnrefLogicalUnitExtensionWithTag (
                            FdoExtension,
                            pdoExtension,
                            IdePortScanBus
                            );

                        pdoExtension = NULL;
                    }

                } else {

                    ASSERT (pdoExtension);

                    DebugPrint ((DBG_ALWAYS, "IdePort: unable to create new pdo\n"));
                }

                if (pdoExtension) {

                    if (!newPdo) {

                        DebugPrint((DBG_BUSSCAN, "IdePortScanBus: pdoe 0x%x is missing.  (physically removed)\n", pdoExtension));
                    }

                    //
                    // get the pdo states
                    //
                    KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

                    SETMASK (pdoExtension->PdoState, PDOS_DEADMEAT);

                    KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);


                    UnRefLuExt(pdoExtension, FdoExtension, TRUE, TRUE, newPdo);

                    pdoExtension = NULL;
                }
            }
        }

        //
        // Get all PDOs ready
        //
        pathId.l = 0;
        while (pdoExtension = NextLogUnitExtensionWithTag(
                                  FdoExtension,
                                  &pathId,
                                  FALSE,
                                  IdePortScanBus
                                  )) {

            //
            // PO Idle Timer
            //
            DeviceRegisterIdleDetection (
                pdoExtension,
                DEVICE_DEFAULT_IDLE_TIMEOUT,
                DEVICE_DEFAULT_IDLE_TIMEOUT
                );

            CLRMASK (pdoExtension->DeviceObject->Flags, DO_DEVICE_INITIALIZING);

            UnrefLogicalUnitExtensionWithTag (
                FdoExtension,
                pdoExtension,
                IdePortScanBus
                );
        }

        //
        // Update the device map.
        //
        ideDriverExtension = IoGetDriverObjectExtension(
                                 FdoExtension->DriverObject,
                                 DRIVER_OBJECT_EXTENSION_ID
                                 );
        IdeBuildDeviceMap(FdoExtension, &ideDriverExtension->RegistryPath);
    }

    timeDiff = LogBusScanStopTimer(&tickCount);
    LogBusScanTimeDiff(FdoExtension, IdePortBootTimeRegKey[5], timeDiff);
    DebugPrint((DBG_SPECIAL,
                "BusScan: Last Stage scanning for %x took %u ms\n",
                FdoExtension->IdeResource.TranslatedCommandBaseAddress,
                timeDiff
                ));
    //
    // save current transfer mode setting in the registry
    //
    for (target = 0; target < hwDeviceExtension->MaxIdeTargetId; target++) {

        ULONG mode;

        pdoExtension = RefLogicalUnitExtensionWithTag(
                           FdoExtension,
                           0,
                           (UCHAR) target,
                           0,
                           TRUE,
                           IdePortScanBus
                           );

        if (pdoExtension) {

            mode = FdoExtension->HwDeviceExtension->DeviceParameters[target].TransferModeSelected;

            if (pdoExtension->DmaTransferTimeoutCount >= PDO_DMA_TIMEOUT_LIMIT) {
            
                mode &= PIO_SUPPORT;
                lastKnownGoodTimingMode[target] &= PIO_SUPPORT;
            }

            UnrefLogicalUnitExtensionWithTag (
                FdoExtension,
                pdoExtension,
                IdePortScanBus
                );

            IdePortSaveDeviceParameter(
                FdoExtension,
                IdePortRegistryDeviceTimingModeName[target],
                mode
                );

            IdePortSaveDeviceParameter(
                FdoExtension,
                IdePortRegistryDeviceTimingModeAllowedName[target],
                lastKnownGoodTimingMode[target]
                );

            IdePortSaveDeviceParameter(
                FdoExtension,
                IdePortRegistryIdentifyDataChecksum[target],
                idDatacheckSum[target]
                );

        } else {

            IdePortSaveDeviceParameter(
                FdoExtension,
                IdePortRegistryDeviceTimingModeName[target],
                0
                );
        }
    }

done:
    //
    // unlock BUSSCAN code pages
    //
#ifdef ALLOC_PRAGMA
    InterlockedDecrement(&IdePAGESCANLockCount);
    MmUnlockPagableImageSection(
        pageScanCodePageHandle
        );
#endif
    
    return STATUS_SUCCESS;
}


BOOLEAN
IdePreAllocEnumStructs (
    IN PFDO_EXTENSION FdoExtension
)
/**++

Routine Description:

    Pre-Allocates Memory for structures used during enumertion. This is not protected by a lock.
    Thus if multiple threads cannot use the structures at the same time. Any routine using these
    structures should be aware of this fact.

Arguments:

    FdoExtension : Functional Device Extension    
    
Return Value:

    TRUE: if allocations succeeded.
    FALSE: if any of the allocations failed    

--**/
{
    PENUMERATION_STRUCT enumStruct;
    PIRP irp1;
    ULONG deviceRelationsSize;
    PULONG DataBuffer;
    ULONG currsize=0;
    PIDE_WORK_ITEM_CONTEXT          workItemContext;

	PAGED_CODE();

    //
    // Lock
    //
    ASSERT(InterlockedCompareExchange(&(FdoExtension->EnumStructLock), 1, 0) == 0);

    if (FdoExtension->PreAllocEnumStruct) {

        //
        // Unlock
        //
        ASSERT(InterlockedCompareExchange(&(FdoExtension->EnumStructLock), 0, 1) == 1);
        return TRUE;
    }

    enumStruct = ExAllocatePool(NonPagedPool, sizeof(ENUMERATION_STRUCT));
    if (enumStruct == NULL) {

        //
        // Unlock
        //
        ASSERT(InterlockedCompareExchange(&(FdoExtension->EnumStructLock), 0, 1) == 1);
        ASSERT(FdoExtension->EnumStructLock == 0);
        return FALSE;
    }
    currsize += sizeof(ENUMERATION_STRUCT);
    
    RtlZeroMemory(enumStruct, sizeof(ENUMERATION_STRUCT));

    //
    // Allocate ATaPassThru context
    //
    enumStruct->Context = ExAllocatePool(NonPagedPool, sizeof (ATA_PASSTHROUGH_CONTEXT));
    if (enumStruct->Context == NULL) {
        goto getout;
    }

    currsize += sizeof(ATA_PASSTHROUGH_CONTEXT);

	//
	// Allocate the WorkItemContext for the enumeration
	//
	ASSERT(enumStruct->EnumWorkItemContext == NULL);

	enumStruct->EnumWorkItemContext = ExAllocatePool (NonPagedPool, 
											 sizeof(IDE_WORK_ITEM_CONTEXT)
											 );
	if (enumStruct->EnumWorkItemContext == NULL) {
		goto getout;
	}

    currsize += sizeof(IDE_WORK_ITEM_CONTEXT);

	//
	// Allocate the WorkItem
	//
	workItemContext = (PIDE_WORK_ITEM_CONTEXT) (enumStruct->EnumWorkItemContext);
	workItemContext->WorkItem = IoAllocateWorkItem(FdoExtension->DeviceObject);

	if (workItemContext->WorkItem == NULL) {
		goto getout;
	}

    //
    // StopQueu Context, used to stop the device queue
    //
    enumStruct->StopQContext = ExAllocatePool(NonPagedPool, sizeof (PDO_STOP_QUEUE_CONTEXT));
    if (enumStruct->StopQContext == NULL) {
        goto getout;
    }

    currsize += sizeof(PDO_STOP_QUEUE_CONTEXT);

    //
    // Sense Info buffer
    //
    enumStruct->SenseInfoBuffer = ExAllocatePool( NonPagedPoolCacheAligned, SENSE_BUFFER_SIZE);
    if (enumStruct->SenseInfoBuffer == NULL) {
        goto getout;
    }

    currsize += SENSE_BUFFER_SIZE;

    //
    // Srb to send pass thru requests
    //
    enumStruct->Srb = ExAllocatePool (NonPagedPool, sizeof (SCSI_REQUEST_BLOCK));
    if (enumStruct->Srb == NULL) {
        goto getout;
    }

    currsize += sizeof(SCSI_REQUEST_BLOCK);

    //
    // irp for pass thru requests
    //
    irp1 = IoAllocateIrp (
              (CCHAR) (PREALLOC_STACK_LOCATIONS),
              FALSE
              );

    if (irp1 == NULL) {
        goto getout;
    }

    enumStruct->Irp1 = irp1;

    //
    // Data buffer to hold inquiry data or Identify data
    //
    enumStruct->DataBufferSize = sizeof(ATA_PASS_THROUGH)+INQUIRYDATABUFFERSIZE+
                                        sizeof(IDENTIFY_DATA);

    currsize += enumStruct->DataBufferSize;

    DataBuffer = ExAllocatePool(NonPagedPoolCacheAligned, 
                                enumStruct->DataBufferSize);

    if (DataBuffer == NULL) {
        enumStruct->DataBufferSize=0;
        goto getout;
    }

    enumStruct->DataBuffer = DataBuffer;

    enumStruct->MdlAddress = IoAllocateMdl( DataBuffer,
                                     enumStruct->DataBufferSize,
                                     FALSE,
                                     FALSE,
                                     (PIRP) NULL );
    if (enumStruct->MdlAddress == NULL) {
        goto getout;
    }

    MmBuildMdlForNonPagedPool(enumStruct->MdlAddress);

    FdoExtension->PreAllocEnumStruct=enumStruct;

    DebugPrint((DBG_BUSSCAN, "BusScan: TOTAL PRE_ALLOCED MEM=%x\n", currsize));

    //
    // Unlock
    //
    ASSERT(InterlockedCompareExchange(&(FdoExtension->EnumStructLock), 0, 1) == 1);

    return TRUE;

getout:

    //
    // Some allocations failed. Free the already allocated ones.
    //
    IdeFreeEnumStructs(enumStruct);

    FdoExtension->PreAllocEnumStruct=NULL;

    //
    // Unlock
    //
    ASSERT(InterlockedCompareExchange(&(FdoExtension->EnumStructLock), 0, 1) == 1);
    ASSERT(FALSE);
    return FALSE;
}

VOID
IdeFreeEnumStructs(
    PENUMERATION_STRUCT enumStruct
    )
/**++

Routine Description:

    Frees the pre-allocated memory.
    
Arguments
    
    Pointer to the Enumeration Structure that is to be freed
    
Return Value:

    None        
--**/
{
	PAGED_CODE();

    if (enumStruct != NULL) { 
        if (enumStruct->Context) {
            ExFreePool (enumStruct->Context);
        }

        if (enumStruct->SenseInfoBuffer) {
            ExFreePool (enumStruct->SenseInfoBuffer);
        }

        if (enumStruct->Srb) {
            ExFreePool(enumStruct->Srb);
        }

        if (enumStruct->StopQContext) {
            ExFreePool(enumStruct->StopQContext);
        }

        if (enumStruct->DataBuffer) {
            ExFreePool(enumStruct->DataBuffer);
        }

        if (enumStruct->Irp1) {
            IoFreeIrp(enumStruct->Irp1);
        }

        if (enumStruct->MdlAddress) {
            ExFreePool(enumStruct->MdlAddress);
        }

		if (enumStruct->EnumWorkItemContext) {
			PIDE_WORK_ITEM_CONTEXT	workItemContext = (PIDE_WORK_ITEM_CONTEXT)enumStruct->
																					EnumWorkItemContext;
			if (workItemContext->WorkItem) {
				IoFreeWorkItem(workItemContext->WorkItem);
			}

			ExFreePool (enumStruct->EnumWorkItemContext);
		}

        ExFreePool(enumStruct);
        enumStruct = NULL;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\detect.c ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    detect.c

Abstract:

    This contain legacy detection routines

Author:

    Joe Dai (joedai)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "ideport.h"

#if !defined(NO_LEGACY_DRIVERS)

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, IdePortDetectLegacyController)
#pragma alloc_text(INIT, IdePortCreateDetectionList)
#pragma alloc_text(INIT, IdePortTranslateAddress)
#pragma alloc_text(INIT, IdePortFreeTranslatedAddress)
#pragma alloc_text(INIT, IdePortDetectAlias)
#endif // ALLOC_PRAGMA

NTSTATUS
IdePortDetectLegacyController (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
)
/*++

Routine Description:

    Detect legacy IDE controllers and report them to PnP

Arguments:

    DriverObject - this driver's driver object

    RegistryPath - this driver's registry path

Return Value:

    NT Status

--*/
{
    ULONG                           cmResourceListSize;
    PCM_RESOURCE_LIST               cmResourceList = NULL;
    PCM_FULL_RESOURCE_DESCRIPTOR    cmFullResourceDescriptor;
    PCM_PARTIAL_RESOURCE_LIST       cmPartialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR cmPartialDescriptors;

    BOOLEAN                         conflictDetected;
    BOOLEAN                         resourceIsCmdPort;

    PDEVICE_OBJECT                  detectedPhysicalDeviceObject;
    PFDO_EXTENSION                  fdoExtension = NULL;

    UNICODE_STRING                  deviceClassName;

    NTSTATUS                        status;
    PDETECTION_PORT                 detectionPort;
    ULONG                           numPort;

    ULONG                           portNumber;
    ULONG                           deviceNumber;
    ULONG                           descriptorNumber;
    ULONG                           cmdAddressSpace;
    ULONG                           ctrlAddressSpace;
    PUCHAR                          cmdRegBase;
    PUCHAR                          ctrlRegBase;
    IDE_REGISTERS_1                 baseIoAddress1;
    IDE_REGISTERS_2                 baseIoAddress2;
    PHYSICAL_ADDRESS                cmdRegMemoryBase;
    PHYSICAL_ADDRESS                ctrlRegMemoryBase;
    UCHAR                           statusByte;
    ULONG                           baseIoAddress1Length;
    ULONG                           baseIoAddress2Length;
    ULONG                           maxIdeDevice;

    UCHAR                           altMasterStatus;
    UCHAR                           altSlaveStatus;


#if !defined (ALWAYS_DO_LEGACY_DETECTION)
    if (!IdePortOkToDetectLegacy(DriverObject)) {

        //
        // legacy detection is not enabled
        //
        return STATUS_SUCCESS;
    }
#endif

    //
    // make up a list of popular legacy I/O ports
    //
    status = IdePortCreateDetectionList (
                 DriverObject,
                 &detectionPort,
                 &numPort
                 );
    if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

    //
    // Resource Requirement List
    //
    cmResourceListSize = sizeof (CM_RESOURCE_LIST) +
                         sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR) * (((!IsNEC_98) ? 3 : 12) - 1);
    cmResourceList = ExAllocatePool (PagedPool, cmResourceListSize);
    if (cmResourceList == NULL){

        status = STATUS_NO_MEMORY;
        goto GetOut;

    }

    RtlZeroMemory(cmResourceList, cmResourceListSize);
    RtlInitUnicodeString(&deviceClassName, L"ScsiAdapter");

    for (portNumber=0; portNumber<numPort; portNumber++) {

        //
        // Build io address structure.
        //

        AtapiBuildIoAddress ( (PUCHAR)detectionPort[portNumber].CommandRegisterBase,
                              (PUCHAR)detectionPort[portNumber].ControlRegisterBase,
                              &baseIoAddress1,
                              &baseIoAddress2,
                              &baseIoAddress1Length,
                              &baseIoAddress2Length,
                              &maxIdeDevice,
                              NULL);

        //
        // Build resource requirement list
        //
        cmResourceList->Count = 1;

        cmFullResourceDescriptor = cmResourceList->List;
        cmFullResourceDescriptor->InterfaceType = Isa;
        cmFullResourceDescriptor->BusNumber = 0;

        cmPartialResourceList = &cmFullResourceDescriptor->PartialResourceList;
        cmPartialResourceList->Version = 1;
        cmPartialResourceList->Revision = 1;
        cmPartialResourceList->Count = 3;

        cmPartialDescriptors = cmPartialResourceList->PartialDescriptors;

        cmPartialDescriptors[0].Type             = CmResourceTypePort;
        cmPartialDescriptors[0].ShareDisposition = CmResourceShareDeviceExclusive;
        cmPartialDescriptors[0].Flags            = CM_RESOURCE_PORT_IO |
                           (!Is98LegacyIde(&baseIoAddress1)? CM_RESOURCE_PORT_10_BIT_DECODE :
                                                             CM_RESOURCE_PORT_16_BIT_DECODE);
        cmPartialDescriptors[0].u.Port.Length    = baseIoAddress1Length;
        cmPartialDescriptors[0].u.Port.Start.QuadPart = detectionPort[portNumber].CommandRegisterBase;

        cmPartialDescriptors[1].Type             = CmResourceTypePort;
        cmPartialDescriptors[1].ShareDisposition = CmResourceShareDeviceExclusive;
        cmPartialDescriptors[1].Flags            = CM_RESOURCE_PORT_IO |
                           (!Is98LegacyIde(&baseIoAddress1)? CM_RESOURCE_PORT_10_BIT_DECODE :
                                                             CM_RESOURCE_PORT_16_BIT_DECODE);
        cmPartialDescriptors[1].u.Port.Length    = 1;
        cmPartialDescriptors[1].u.Port.Start.QuadPart = detectionPort[portNumber].ControlRegisterBase;

        cmPartialDescriptors[2].Type             = CmResourceTypeInterrupt;
        cmPartialDescriptors[2].ShareDisposition = CmResourceShareDeviceExclusive;
        cmPartialDescriptors[2].Flags            = CM_RESOURCE_INTERRUPT_LATCHED;
        cmPartialDescriptors[2].u.Interrupt.Level = detectionPort[portNumber].IrqLevel;
        cmPartialDescriptors[2].u.Interrupt.Vector = detectionPort[portNumber].IrqLevel;
        cmPartialDescriptors[2].u.Interrupt.Affinity = -1;

        if (Is98LegacyIde(&baseIoAddress1)) {

            ULONG resourceCount;
            ULONG commandRegisters;

            commandRegisters = detectionPort[portNumber].CommandRegisterBase + 2;
            resourceCount = 3;

            while (commandRegisters < (IDE_NEC98_COMMAND_PORT_ADDRESS + 0x10)) {
                cmPartialDescriptors[resourceCount].Type             = CmResourceTypePort;
                cmPartialDescriptors[resourceCount].ShareDisposition = CmResourceShareDeviceExclusive;
                cmPartialDescriptors[resourceCount].Flags            = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                cmPartialDescriptors[resourceCount].u.Port.Length    = 1;
                cmPartialDescriptors[resourceCount].u.Port.Start.QuadPart = commandRegisters;

                resourceCount++;
                commandRegisters += 2;
            }

            cmPartialDescriptors[resourceCount].Type             = CmResourceTypePort;
            cmPartialDescriptors[resourceCount].ShareDisposition = CmResourceShareDeviceExclusive;
            cmPartialDescriptors[resourceCount].Flags            = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
            cmPartialDescriptors[resourceCount].u.Port.Length    = 2;
            cmPartialDescriptors[resourceCount].u.Port.Start.QuadPart = (ULONG_PTR)SELECT_IDE_PORT;

            resourceCount++;

            cmPartialDescriptors[resourceCount].Type             = CmResourceTypePort;
            cmPartialDescriptors[resourceCount].ShareDisposition = CmResourceShareDeviceExclusive;
            cmPartialDescriptors[resourceCount].Flags            = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
            cmPartialDescriptors[resourceCount].u.Port.Length    = 1;
            cmPartialDescriptors[resourceCount].u.Port.Start.QuadPart = (ULONG_PTR)SELECT_IDE_PORT + 3;

            resourceCount++;

            cmPartialResourceList->Count = resourceCount;
        }

        //
        // check to see if the resource is available
        // if not, assume no legacy IDE controller
        // is at the this location
        //
        for (deviceNumber=0; deviceNumber<2; deviceNumber++) {

            status = IoReportResourceForDetection (
                         DriverObject,
                         cmResourceList,
                         cmResourceListSize,
                         NULL,
                         NULL,
                         0,
                         &conflictDetected
                         );

            if (NT_SUCCESS(status) && !conflictDetected) {

                //
                // got our resources
                //
                break;

            } else {

                if (NT_SUCCESS(status)) {

                    IoReportResourceForDetection (
                                 DriverObject,
                                 NULL,
                                 0,
                                 NULL,
                                 NULL,
                                 0,
                                 &conflictDetected
                                 );

                    status = STATUS_UNSUCCESSFUL;
                }

                //
                // try 16 bit decode
                //
                cmPartialDescriptors[0].Flags = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                cmPartialDescriptors[1].Flags = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;

                if (Is98LegacyIde(&baseIoAddress1)) {
                    ULONG k;

                    for (k=3; k<12; k++) {
                        cmPartialDescriptors[k].Flags = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                    }
                }
            }
        }

        if (!NT_SUCCESS(status)) {

            continue;
        }


        //
        // translate the i/o port via Hal
        //

        status = STATUS_SUCCESS;

        if (Is98LegacyIde(&baseIoAddress1)) {
            for (descriptorNumber=3; descriptorNumber<12; descriptorNumber++) {
                cmdRegBase = NULL;
                cmdAddressSpace = IO_SPACE;

                status = IdePortTranslateAddress (
                             cmFullResourceDescriptor->InterfaceType,
                             cmFullResourceDescriptor->BusNumber,
                             cmPartialDescriptors[descriptorNumber].u.Port.Start,
                             cmPartialDescriptors[descriptorNumber].u.Port.Length,
                             &cmdAddressSpace,
                             &cmdRegBase,
                             &cmdRegMemoryBase
                             );
                if (!NT_SUCCESS(status)) {
                    break;
                }
            }
        }

        if (NT_SUCCESS(status)) {

            cmdRegBase = NULL;
            ctrlRegBase = NULL;
            cmdAddressSpace = IO_SPACE;

            status = IdePortTranslateAddress (
                         cmFullResourceDescriptor->InterfaceType,
                         cmFullResourceDescriptor->BusNumber,
                         cmPartialDescriptors[0].u.Port.Start,
                         cmPartialDescriptors[0].u.Port.Length,
                         &cmdAddressSpace,
                         &cmdRegBase,
                         &cmdRegMemoryBase
                         );
        }

        if (NT_SUCCESS(status)) {

            ctrlRegBase = NULL;
            ctrlAddressSpace = IO_SPACE;
            status = IdePortTranslateAddress (
                         cmFullResourceDescriptor->InterfaceType,
                         cmFullResourceDescriptor->BusNumber,
                         cmPartialDescriptors[1].u.Port.Start,
                         cmPartialDescriptors[1].u.Port.Length,
                         &ctrlAddressSpace,
                         &ctrlRegBase,
                         &ctrlRegMemoryBase
                         );
        }

        if (NT_SUCCESS(status)) {

            //
            // 2nd build io address structure.
            //

            AtapiBuildIoAddress ( cmdRegBase,
                                  ctrlRegBase,
                                  &baseIoAddress1,
                                  &baseIoAddress2,
                                  &baseIoAddress1Length,
                                  &baseIoAddress2Length,
                                  &maxIdeDevice,
                                  NULL);

            //
            // The IBM Aptiva ide channel with the external cdrom doesn't power up with any device selected
            // we must select a device; otherwise, we get a 0xff from all IO ports
            //
            SelectIdeDevice(&baseIoAddress1, 0, 0);
            altMasterStatus = IdePortInPortByte(baseIoAddress2.DeviceControl);

            SelectIdeDevice(&baseIoAddress1, 1, 0);
            altSlaveStatus = IdePortInPortByte(baseIoAddress2.DeviceControl);

            if ((!Is98LegacyIde(&baseIoAddress1)) && (altMasterStatus == 0xff) && (altSlaveStatus == 0xff)) {

                //
                // the alternate status byte is 0xff,
                // guessing we have a SCSI adapter (DPT) that emulate IDE controller
                // say the channel is empty, let the real SCSI driver picks up
                // the controller
                //
                status = STATUS_UNSUCCESSFUL;

                //
                // Note: The IDE port on SB16/AWE32 does not have the alternate status
                // register.  Because of this alternate status test, we will fail to
                // detect this IDE port.  However, this IDE port should be enumerated
                // by ISA-PnP bus driver.
                //

            } else if (IdePortChannelEmpty (&baseIoAddress1, &baseIoAddress2, maxIdeDevice)) {

                //
                // channel looks empty
                //
                status = STATUS_UNSUCCESSFUL;

            } else {

                BOOLEAN             deviceFound;
                IDENTIFY_DATA       IdentifyData;
                ULONG               i;

                for (i=0; i<maxIdeDevice; i++) {

                    if (Is98LegacyIde(&baseIoAddress1)) {
                        UCHAR driveHeadReg;

                        //
                        // Check master device only.
                        //

                        if ( i & 0x1 ) {

                            continue;
                        }

                        //
                        // Check device is present.
                        //

                        SelectIdeDevice(&baseIoAddress1, i, 0);
                        driveHeadReg = IdePortInPortByte(baseIoAddress1.DriveSelect);

                        if (driveHeadReg != ((i & 0x1) << 4 | 0xA0)) {
                            //
                            // Bad controller.
                            //
                            continue;
                        }
                    }

                    //
                    // Is there a ATA device?
                    //
                    deviceFound = IssueIdentify(
                                      &baseIoAddress1,
                                      &baseIoAddress2,
                                      i,
                                      IDE_COMMAND_IDENTIFY,
                                      TRUE,
                                      &IdentifyData
                                      );
                    if (deviceFound) {
                        break;
                    }

                    //
                    // Is there a ATAPI device?
                    //
                    deviceFound = IssueIdentify(
                                      &baseIoAddress1,
                                      &baseIoAddress2,
                                      i,
                                      IDE_COMMAND_ATAPI_IDENTIFY,
                                      TRUE,
                                      &IdentifyData
                                      );
                    if (deviceFound) {
                        break;
                    }
                }

                if (!deviceFound) {

                    status = STATUS_UNSUCCESSFUL;
                }
            }
        }

        if (!NT_SUCCESS (status)) {

            //
            // if we didn't found anything,
            // unmap the reosurce
            //

            if (cmdRegBase) {

                IdePortFreeTranslatedAddress (
                    cmdRegBase,
                    cmPartialDescriptors[0].u.Port.Length,
                    cmdAddressSpace
                    );

                if (Is98LegacyIde(&baseIoAddress1)) {
                    for (descriptorNumber=3; descriptorNumber<12; descriptorNumber++) {
                        IdePortFreeTranslatedAddress (
                            cmdRegBase,
                            cmPartialDescriptors[descriptorNumber].u.Port.Length,
                            cmdAddressSpace
                            );
                    }
                }
            }

            if (ctrlRegBase) {

                IdePortFreeTranslatedAddress (
                    ctrlRegBase,
                    cmPartialDescriptors[1].u.Port.Length,
                    ctrlAddressSpace
                    );
            }

        } else {

            //
            // check for alias ports
            //
            if (cmPartialDescriptors[0].Flags & CM_RESOURCE_PORT_10_BIT_DECODE) {

                if (!IdePortDetectAlias (&baseIoAddress1)) {

                    cmPartialDescriptors[0].Flags = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                    cmPartialDescriptors[1].Flags = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;

                    if (Is98LegacyIde(&baseIoAddress1)) {
                        for (descriptorNumber=3; descriptorNumber<12; descriptorNumber++) {
                            cmPartialDescriptors[descriptorNumber].Flags = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                        }
                    }
                }
            }
        }

        //
        // release the resources we have grab, IoReportDetectedDevice()
        // will grab them for us again when we call and it will grab them
        // on behalf of the detected PDO.
        //
        IoReportResourceForDetection (
                     DriverObject,
                     NULL,
                     0,
                     NULL,
                     NULL,
                     0,
                     &conflictDetected
                     );

        if (NT_SUCCESS(status)) {

            detectedPhysicalDeviceObject = NULL;

            status = IoReportDetectedDevice(DriverObject,
                                            InterfaceTypeUndefined,
                                            -1,
                                            -1,
                                            cmResourceList,
                                            NULL,
                                            FALSE,
                                            &detectedPhysicalDeviceObject);

            if (NT_SUCCESS (status)) {

                //
                // create a FDO and attach it to the detected PDO
                //
                status = ChannelAddChannel (
                             DriverObject,
                             detectedPhysicalDeviceObject,
                             &fdoExtension
                             );

                if (NT_SUCCESS (status)) {

                    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
                    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
                    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
                    ULONG i, j;

                    //
                    // translate resources
                    //
                    fullResourceList = cmResourceList->List;
                    for (i=0; i<cmResourceList->Count; i++) {

                        partialResourceList = &(fullResourceList->PartialResourceList);
                        partialDescriptors  = fullResourceList->PartialResourceList.PartialDescriptors;

                        for (j=0; j<partialResourceList->Count; j++) {

                            resourceIsCmdPort = FALSE;

                            if (!Is98LegacyIde(&baseIoAddress1)) {

                                if ((partialDescriptors[j].Type == CmResourceTypePort) &&
                                    (partialDescriptors[j].u.Port.Length == baseIoAddress1Length)) {

                                    resourceIsCmdPort = TRUE;
                                }
                            } else {

                                if ((partialDescriptors[j].Type == CmResourceTypePort) &&
                                    (partialDescriptors[j].u.Port.Start.QuadPart == IDE_NEC98_COMMAND_PORT_ADDRESS)) {

                                    resourceIsCmdPort = TRUE;

                                } else if ((partialDescriptors[j].Type == CmResourceTypePort) &&
                                           (partialDescriptors[j].u.Port.Start.QuadPart != IDE_NEC98_COMMAND_PORT_ADDRESS) &&
                                           (partialDescriptors[j].u.Port.Start.QuadPart != (IDE_NEC98_COMMAND_PORT_ADDRESS + 0x10C))) {

                                    //
                                    // This is not the base port address for Legacy ide on NEC98;
                                    //

                                    continue;
                                }
                            }

                            if (resourceIsCmdPort) {

                                if (cmdAddressSpace == MEMORY_SPACE) {

                                    partialDescriptors[j].Type = CmResourceTypeMemory;
                                    partialDescriptors[j].u.Memory.Start = cmdRegMemoryBase;
                                    partialDescriptors[j].u.Memory.Length = partialDescriptors[j].u.Port.Length;

                                } else {

                                    partialDescriptors[j].u.Port.Start.QuadPart = (ULONG_PTR) cmdRegBase;
                                }

                            } else if ((partialDescriptors[j].Type == CmResourceTypePort) &&
                                  (partialDescriptors[j].u.Port.Length == 1)) {

                                if (ctrlAddressSpace == MEMORY_SPACE) {

                                    partialDescriptors[j].Type = CmResourceTypeMemory;
                                    partialDescriptors[j].u.Memory.Start = ctrlRegMemoryBase;
                                    partialDescriptors[j].u.Memory.Length = partialDescriptors[j].u.Port.Length;

                                } else {

                                    partialDescriptors[j].u.Port.Start.QuadPart = (ULONG_PTR) ctrlRegBase;
                                }

                            } else if (partialDescriptors[j].Type == CmResourceTypeInterrupt) {

                                partialDescriptors[j].u.Interrupt.Vector = HalGetInterruptVector(fullResourceList->InterfaceType,
                                                                               fullResourceList->BusNumber,
                                                                               partialDescriptors[j].u.Interrupt.Level,
                                                                               partialDescriptors[j].u.Interrupt.Vector,
                                                                               (PKIRQL) &partialDescriptors[j].u.Interrupt.Level,
                                                                               &partialDescriptors[j].u.Interrupt.Affinity);
                            }
                        }
                        fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + j);
                    }

                    //
                    // start the FDO
                    //
                    status = ChannelStartChannel (fdoExtension,
                                                  cmResourceList);      // callee is keeping this if no error
                }

                if (!NT_SUCCESS (status)) {

                    //
                    // go through the remove sequence
                    //
                    if (fdoExtension) {

                        ChannelRemoveChannel (fdoExtension);

                        IoDetachDevice (fdoExtension->AttacheeDeviceObject);

                        IoDeleteDevice (fdoExtension->DeviceObject);
                    }

                    DebugPrint ((0, "IdePort: Unable to start detected device\n"));
                    ASSERT (FALSE);

                } else {

                   IoInvalidateDeviceRelations (
                       fdoExtension->AttacheePdo,
                       BusRelations
                       );
                }
            }
        }
    }

GetOut:
    if (cmResourceList) {
        ExFreePool (cmResourceList);
    }

    if (detectionPort) {
        ExFreePool (detectionPort);
    }

    return status;

} //IdePortDetectLegacyController



NTSTATUS
IdePortCreateDetectionList (
    IN  PDRIVER_OBJECT  DriverObject,
    OUT PDETECTION_PORT *DetectionPort,
    OUT PULONG          NumPort
)
/*++

Routine Description:

    create a list of popular legacy ports

Arguments:

    DriverObject - this driver's driver object

    DetectionPort - pointer to port list

    NumPort - number of ports in the list

Return Value:

    NT Status

--*/
{
    NTSTATUS                status;
    CCHAR                   deviceBuffer[50];
    ANSI_STRING             ansiString;
    UNICODE_STRING          subKeyPath;
    HANDLE                  subServiceKey;

    PDETECTION_PORT         detectionPort;
    ULONG                   numDevices;
    ULONG                   i;
    ULONG                   j;

    CUSTOM_DEVICE_PARAMETER customDeviceParameter;

    PCONFIGURATION_INFORMATION configurationInformation = IoGetConfigurationInformation();

    numDevices = 0;
    status = STATUS_SUCCESS;

#ifdef DRIVER_PARAMETER_REGISTRY_SUPPORT

    //
    // look for non-standard legacy port setting in the registry
    //      9
    do {
        sprintf (deviceBuffer, "Parameters\\Device%d", numDevices);
        RtlInitAnsiString(&ansiString, deviceBuffer);
        status = RtlAnsiStringToUnicodeString(&subKeyPath, &ansiString, TRUE);

        if (NT_SUCCESS(status)) {

            subServiceKey = IdePortOpenServiceSubKey (
                                DriverObject,
                                &subKeyPath
                                );

            RtlFreeUnicodeString (&subKeyPath);

            if (subServiceKey) {

                numDevices++;
                IdePortCloseServiceSubKey (
                    subServiceKey
                    );

            } else {

                status = STATUS_UNSUCCESSFUL;
            }
        }
    } while (NT_SUCCESS(status));

#endif // DRIVER_PARAMETER_REGISTRY_SUPPORT

    //
    // always have at least 4 to return
    //
    detectionPort = ExAllocatePool (
                        PagedPool,
                        (numDevices + 4) * sizeof (DETECTION_PORT)
                        );

    if (detectionPort) {

        for (i = j = 0; i < numDevices; i++) {

#ifdef DRIVER_PARAMETER_REGISTRY_SUPPORT

            //
            // look for non-standard legacy port setting in the registry
            //

            sprintf (deviceBuffer, "Parameters\\Device%d", i);
            RtlInitAnsiString(&ansiString, deviceBuffer);
            status = RtlAnsiStringToUnicodeString(&subKeyPath, &ansiString, TRUE);

            if (NT_SUCCESS(status)) {

                subServiceKey = IdePortOpenServiceSubKey (
                                    DriverObject,
                                    &subKeyPath
                                    );

                RtlFreeUnicodeString (&subKeyPath);

                if (subServiceKey) {

                    RtlZeroMemory (
                        &customDeviceParameter,
                        sizeof (CUSTOM_DEVICE_PARAMETER)
                        );

                    IdeParseDeviceParameters (
                        subServiceKey,
                        &customDeviceParameter
                        );

                    if (customDeviceParameter.CommandRegisterBase) {

                        detectionPort[j].CommandRegisterBase =
                            customDeviceParameter.CommandRegisterBase;

                        detectionPort[j].ControlRegisterBase =
                            customDeviceParameter.CommandRegisterBase + 0x206;

                        detectionPort[j].IrqLevel =
                            customDeviceParameter.IrqLevel;

                        j++;
                    }

                    IdePortCloseServiceSubKey (
                        subServiceKey
                        );
                }
            }
#endif // DRIVER_PARAMETER_REGISTRY_SUPPORT
        }

        //
        // populate the list with popular i/o ports
        //

        if ( !IsNEC_98 ) {
            if (configurationInformation->AtDiskPrimaryAddressClaimed == FALSE) {

                detectionPort[j].CommandRegisterBase = 0x1f0;
                detectionPort[j].ControlRegisterBase = 0x1f0 + 0x206;
                detectionPort[j].IrqLevel            = 14;
                j++;
            }

            if (configurationInformation->AtDiskSecondaryAddressClaimed == FALSE) {

                detectionPort[j].CommandRegisterBase = 0x170;
                detectionPort[j].ControlRegisterBase = 0x170 + 0x206;
                detectionPort[j].IrqLevel            = 15;
                j++;
            }

            detectionPort[j].CommandRegisterBase = 0x1e8;
            detectionPort[j].ControlRegisterBase = 0x1e8 + 0x206;
            detectionPort[j].IrqLevel            = 11;
// DEC Hi-Note hack
//        detectionPort[j].ControlRegisterBase = 0x1e8 + 0x1f - 0x2;
//        detectionPort[j].IrqLevel            = 7;
// DEC Hi-Note hack
            j++;

            detectionPort[j].CommandRegisterBase = 0x168;
            detectionPort[j].ControlRegisterBase = 0x168 + 0x206;
            detectionPort[j].IrqLevel            = 10;
            j++;

        } else { // IsNEC_98

            if ((configurationInformation->AtDiskPrimaryAddressClaimed   == FALSE) &&
                (configurationInformation->AtDiskSecondaryAddressClaimed == FALSE)) {

                detectionPort[j].CommandRegisterBase = 0x640;
                detectionPort[j].ControlRegisterBase = 0x640 + 0x10c; //0x74c
                detectionPort[j].IrqLevel            = 9;
                j++;
            }

        }

        *NumPort = j;
        *DetectionPort = detectionPort;
        return STATUS_SUCCESS;
    } else {

        *NumPort = 0;
        *DetectionPort = NULL;
        return STATUS_INSUFFICIENT_RESOURCES;
    }
} // IdePortCreateDetectionList


NTSTATUS
IdePortTranslateAddress (
    IN INTERFACE_TYPE      InterfaceType,
    IN ULONG               BusNumber,
    IN PHYSICAL_ADDRESS    StartAddress,
    IN LONG                Length,
    IN OUT PULONG          AddressSpace,
    OUT PVOID              *TranslatedAddress,
    OUT PPHYSICAL_ADDRESS  TranslatedMemoryAddress
    )
/*++

Routine Description:

    translate i/o address

Arguments:

    InterfaceType - bus interface

    BusNumber - bus number

    StartAddress - address to translate

    Length - number of byte to translate

    AddressSpace - address space for the given address

Return Value:

    AddressSpace - address space for the translated address

    TranslatedAddress - translated address

    TranslatedMemoryAddress - tranlated memory address if translated to memory space

    NT Status

--*/
{
    PHYSICAL_ADDRESS       translatedAddress;

    ASSERT (Length);
    ASSERT (AddressSpace);
    ASSERT (TranslatedAddress);

    *TranslatedAddress = NULL;
    TranslatedMemoryAddress->QuadPart = (ULONGLONG) NULL;

    if (HalTranslateBusAddress(InterfaceType,
                               BusNumber,
                               StartAddress,
                               AddressSpace,
                               &translatedAddress)) {


        if (*AddressSpace == IO_SPACE) {

            *TranslatedAddress = (PVOID) translatedAddress.u.LowPart;

        } else if (*AddressSpace == MEMORY_SPACE) {

            //
            // translated address is in memory space,
            // need to map it to I/O space.
            //
            *TranslatedMemoryAddress = translatedAddress;

            *TranslatedAddress = MmMapIoSpace(
                                    translatedAddress,
                                    Length,
                                    FALSE);
        }
    }

    if (*TranslatedAddress) {

        return STATUS_SUCCESS;

    } else {

        return STATUS_INVALID_PARAMETER;
    }
} // IdePortTranslateAddress


VOID
IdePortFreeTranslatedAddress (
    IN PVOID               TranslatedAddress,
    IN LONG                Length,
    IN ULONG               AddressSpace
    )
/*++

Routine Description:

    free resources created for a translated address

Arguments:

    TranslatedAddress - translated address

    Length - number of byte to translated

    AddressSpace - address space for the translated address

Return Value:

    None

--*/
{
    if (TranslatedAddress) {

        if (AddressSpace == MEMORY_SPACE) {

            MmUnmapIoSpace (
                TranslatedAddress,
                Length
                );
        }
    }
    return;
} // IdePortFreeTranslatedAddress


BOOLEAN
IdePortDetectAlias (
    PIDE_REGISTERS_1 CmdRegBase
    )
{
    PIDE_REGISTERS_1 cmdRegBaseAlias;
    PUCHAR cylinderHighAlias;
    PUCHAR cylinderLowAlias;

    //
    // alias port
    //
    cylinderHighAlias = (PUCHAR) ((ULONG_PTR) CmdRegBase->CylinderHigh | (1 << 15));
    cylinderLowAlias = (PUCHAR) ((ULONG_PTR) CmdRegBase->CylinderLow | (1 << 15));

    IdePortOutPortByte (CmdRegBase->CylinderHigh, SAMPLE_CYLINDER_HIGH_VALUE);
    IdePortOutPortByte (CmdRegBase->CylinderLow,  SAMPLE_CYLINDER_LOW_VALUE);

    //
    // Check if indentifier can be read back via the alias port
    //
    if ((IdePortInPortByte (cylinderHighAlias) != SAMPLE_CYLINDER_HIGH_VALUE) ||
        (IdePortInPortByte (cylinderLowAlias)  != SAMPLE_CYLINDER_LOW_VALUE)) {

        return FALSE;

    } else {

        return TRUE;
    }
}

#endif // NO_LEGACY_DRIVERS
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\crashdmp.c ===
/*++

Copyright (c) 1997 - 2002  Microsoft Corporation

Module Name:

    crashdmp.c

Abstract:

    Implementation of crashdump functions for atapi.

Author:

    Krishnan Varadarajan (krishvar) 

--*/


#include <ntosp.h>

#include "io.h"
#include "ideport.h"

NTSTATUS
AtapiCrashDumpIdeWriteDMA (
    IN LONG Action,
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl,
    IN PVOID LocalData
    );

VOID
AtapiCrashDumpBmCallback (
    IN PVOID Context
    );

NTSTATUS
AtapiDumpGetCrashInfo(
    IN PPDO_EXTENSION PdoExtension,
    IN PATAPI_DUMP_PDO_INFO PdoDumpInfo
    );


#ifdef ALLOC_PRAGMA
//
// All the crash dump code can be marked "INIT".
// during crash dump or hibernate dump, a new copy
// of this driver gets loaded and its INIT code
// doesn't get thrown away when DriverEnry returns
//
#pragma alloc_text(INIT, AtapiCrashDumpDriverEntry)
#pragma alloc_text(INIT, AtapiCrashDumpOpen)
#pragma alloc_text(INIT, AtapiCrashDumpIdeWrite)
#pragma alloc_text(INIT, AtapiCrashDumpFinish)
#pragma alloc_text(INIT, AtapiCrashDumpBmCallback)
#pragma alloc_text(INIT, AtapiCrashDumpIdeWriteDMA)
#endif // ALLOC_PRAGMA


ULONG
AtapiCrashDumpDriverEntry (
    PVOID Context
    )
/*++

Routine Description:

    dump driver entry point

Arguments:

    Context - PCRASHDUMP_INIT_DATA

Return Value:

    NT Status

--*/
{
    PDUMP_INITIALIZATION_CONTEXT context = Context;

    DebugPrint ((DBG_CRASHDUMP, "ATAPI: Entering AtapiCrashDumpDriverEntry...\n"));

    //
    // Put away what we need later
    //
    DumpData.CrashInitData = (PCRASHDUMP_INIT_DATA) context->PortConfiguration;
    DumpData.StallRoutine  = context->StallRoutine;

    //
    // return our dump interface
    //
    context->OpenRoutine    = AtapiCrashDumpOpen;
    context->WriteRoutine   = AtapiCrashDumpIdeWrite;
    context->FinishRoutine  = AtapiCrashDumpFinish;
    context->WritePendingRoutine = AtapiCrashDumpIdeWriteDMA;


    DebugPrint ((DBG_CRASHDUMP, "ATAPI: Leaving AtapiCrashDumpDriverEntry...\n"));

    return STATUS_SUCCESS;
}

BOOLEAN
AtapiCrashDumpOpen (
    IN LARGE_INTEGER PartitionOffset
    )
{
    ULONG i;
    PHW_DEVICE_EXTENSION        hwExtension; 
    PPCIIDE_BUSMASTER_INTERFACE bmInterface;

    DebugPrint ((DBG_CRASHDUMP, "ATAPI: Entering AtapiCrashDumpOpen...PartitionOffset = 0x%x%08x...\n", PartitionOffset.HighPart, PartitionOffset.LowPart));

    // if we are crashdumping, reset the cotroller - Not necessary

    //
    // ISSUE 08/26/2000: Check for disk signature - Why?
    //
    DumpData.PartitionOffset = PartitionOffset;

    RtlMoveMemory (
        &DumpData.HwDeviceExtension,
        DumpData.CrashInitData->LiveHwDeviceExtension,
        sizeof (HW_DEVICE_EXTENSION)
        );

  //  for (i=0; i<DumpData.HwDeviceExtension.MaxIdeDevice; i++) {

//
// AKadatch: we may use DMA and will use DMA if its available
// Do it in AtapiCrashDumpIdeWrite instead
//        CLRMASK (DumpData.HwDeviceExtension.DeviceFlags[i], DFLAGS_USE_DMA);


        DumpData.HwDeviceExtension.CurrentSrb             = NULL;
        DumpData.HwDeviceExtension.DataBuffer             = NULL;
        DumpData.HwDeviceExtension.BytesLeft              = 0;
        DumpData.HwDeviceExtension.ExpectingInterrupt     = FALSE;
        DumpData.HwDeviceExtension.DMAInProgress          = FALSE;
        DumpData.HwDeviceExtension.DriverMustPoll         = TRUE;
   // }

    DumpData.BytesPerSector = 512;
    DumpData.MaxBlockSize = DumpData.BytesPerSector * 256;

    hwExtension = &DumpData.HwDeviceExtension;
    bmInterface = &(hwExtension->BusMasterInterface);

    if (bmInterface->BmCrashDumpInitialize) {
        bmInterface->BmCrashDumpInitialize(bmInterface->Context);
    } else {

        // Don't use DMA
        for (i=0; i<DumpData.HwDeviceExtension.MaxIdeDevice; i++) {
            CLRMASK (DumpData.HwDeviceExtension.DeviceFlags[i], DFLAGS_USE_DMA);
            CLRMASK (DumpData.HwDeviceExtension.DeviceFlags[i], DFLAGS_USE_UDMA);
        }

    }

    DebugPrint ((DBG_CRASHDUMP, "ATAPI: Leaving AtapiCrashDumpOpen...\n"));
    return TRUE;
}

NTSTATUS
AtapiCrashDumpIdeWrite (
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl
    )
{
    SCSI_REQUEST_BLOCK  SrbData;    // Store Srb on stack, don't modify memory!
    ULONG               retryCount;
    ULONG               srbStatus;
    NTSTATUS            status;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    ULONG               blockOffset;
    ULONG               blockCount;
    ULONG               blockSize;
    ULONG               bytesWritten;
    UCHAR               ideStatus;
    ULONG               i;
    ULONG               writeMulitpleBlockSize;

    for (i=0; i<DumpData.HwDeviceExtension.MaxIdeDevice; i++) {
        CLRMASK (DumpData.HwDeviceExtension.DeviceFlags[i], DFLAGS_USE_DMA);
    }

    DebugPrint((DBG_CRASHDUMP,
               "AtapiCrashDumpWrite: Write memory at 0x%x for 0x%x bytes\n",
                Mdl->MappedSystemVa,
                Mdl->ByteCount));

    if (Mdl->ByteCount % DumpData.BytesPerSector) {

        //
        // must be complete sectors
        //
        DebugPrint ((DBG_ALWAYS, "AtapiCrashDumpWrite ERROR: not writing full sectors\n"));

        return STATUS_INVALID_PARAMETER;
    }

    if ((Mdl->ByteCount / DumpData.BytesPerSector) > 256) {

        //
        // need code to split request up
        //
        DebugPrint ((DBG_ALWAYS, "AtapiCrashDumpWrite ERROR: can't handle large write\n"));

        return STATUS_INVALID_PARAMETER;
    }

    //
    // get the WRITE MULTIPLE blocksize per interrupt for later use
    //
    if (DumpData.HwDeviceExtension.MaximumBlockXfer[DumpData.CrashInitData->TargetId]) {

        writeMulitpleBlockSize =
            DumpData.HwDeviceExtension.
                MaximumBlockXfer[DumpData.CrashInitData->TargetId] *
            DumpData.BytesPerSector;

    } else {

        writeMulitpleBlockSize = 1 * DumpData.BytesPerSector;
    }

    srb = &SrbData;
    cdb = (PCDB)srb->Cdb;

    //
    // Zero SRB.
    //
    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Initialize SRB.
    //

    srb->Length   = sizeof(SCSI_REQUEST_BLOCK);
    srb->PathId   = DumpData.CrashInitData->PathId;
    srb->TargetId = DumpData.CrashInitData->TargetId;
    srb->Lun      = DumpData.CrashInitData->Lun;
    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->SrbFlags = SRB_FLAGS_DATA_OUT |
                    SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                    SRB_FLAGS_DISABLE_DISCONNECT |
                    SRB_FLAGS_DISABLE_AUTOSENSE;
    srb->SrbStatus = srb->ScsiStatus = 0;
    srb->NextSrb = 0;
    srb->TimeOutValue = 10;
    srb->CdbLength = 10;

    //
    // Initialize CDB for write command.
    //
    cdb->CDB10.OperationCode = SCSIOP_WRITE;

    MARK_SRB_FOR_PIO(srb);

    bytesWritten = 0;
    do {

        if ((Mdl->ByteCount - bytesWritten) > DumpData.MaxBlockSize) {

            blockSize = DumpData.MaxBlockSize;
            DebugPrint ((DBG_CRASHDUMP, "ATAPI: AtapiCrashDumpWrite: can't do a single write...\n"));

        } else {

            blockSize = Mdl->ByteCount - bytesWritten;
        }

        blockCount =  blockSize / DumpData.BytesPerSector;

        status = STATUS_UNSUCCESSFUL;
        for (retryCount=0; (retryCount<2) && !NT_SUCCESS(status); retryCount++) {

            srb->DataTransferLength = blockSize;
            srb->DataBuffer = ((PUCHAR) Mdl->MappedSystemVa) + bytesWritten;

            //
            // Convert disk byte offset to block offset.
            //

            blockOffset = (ULONG)((DumpData.PartitionOffset.QuadPart +
                                  (*DiskByteOffset).QuadPart +
                                  (ULONGLONG) bytesWritten) / DumpData.BytesPerSector);

            //
            // Fill in CDB block address.
            //

            cdb->CDB10.LogicalBlockByte0 = ((PFOUR_BYTE)&blockOffset)->Byte3;
            cdb->CDB10.LogicalBlockByte1 = ((PFOUR_BYTE)&blockOffset)->Byte2;
            cdb->CDB10.LogicalBlockByte2 = ((PFOUR_BYTE)&blockOffset)->Byte1;
            cdb->CDB10.LogicalBlockByte3 = ((PFOUR_BYTE)&blockOffset)->Byte0;

            cdb->CDB10.TransferBlocksMsb = ((PFOUR_BYTE)&blockCount)->Byte1;
            cdb->CDB10.TransferBlocksLsb = ((PFOUR_BYTE)&blockCount)->Byte0;


            status = AtapiCrashDumpIdeWritePio(srb);

            if (NT_SUCCESS(status)) {

                bytesWritten += blockSize;
            }

        }

        if (!NT_SUCCESS(status)) {

            IdeHardReset (
                &DumpData.HwDeviceExtension.BaseIoAddress1,
                &DumpData.HwDeviceExtension.BaseIoAddress2,
                TRUE,
                TRUE
                );

            //
            // model:    WDC AC31000H
            // version:  19.19E22
            // serial #: DWW-2T27518018 6
            //
            // found out this device can't handle WRITE with more sectors than 16,
            // the blocks per interrupt setting in ID data word 59.
            //
            // Therefore, it we see an error, we will change to blocksize to it.
            // If it still fails, we will keep shrinking the blocksize by half
            // until it gets to zero.  Then, we will return an error
            //

            //
            // last write fail, try a smaller block size
            //
            if (blockSize > writeMulitpleBlockSize) {

                blockSize = writeMulitpleBlockSize;
            } else {

                blockSize /= 2;
            }

            if (blockSize) {

                DebugPrint ((DBG_ALWAYS, "ATAPI: AtapiCrashDumpWrite max write block size is down to 0x%x\n", blockSize));
                DumpData.MaxBlockSize = blockSize;

            } else {

                break;
            }
        }

    } while (bytesWritten < Mdl->ByteCount);

    DebugPrint ((DBG_CRASHDUMP, "ATAPI: Leaving AtapiCrashDumpWrite...\n"));
    return status;
}

VOID
AtapiCrashDumpFinish (
    VOID
    )
{
    SCSI_REQUEST_BLOCK  SrbData;    // Store Srb on stack, don't modify memory!
    PSCSI_REQUEST_BLOCK srb = &SrbData;
    PCDB                cdb;
    ULONG               srbStatus;
    ATA_PASS_THROUGH    ataPassThroughData;
    UCHAR               flushCommand;
    UCHAR ideStatus = 0;

    DebugPrint ((DBG_CRASHDUMP, "ATAPI: Entering AtapiCrashDumpFinish...\n"));

#ifdef ENABLE_48BIT_LBA

    if (DumpData.HwDeviceExtension.DeviceFlags[DumpData.CrashInitData->TargetId] & DFLAGS_48BIT_LBA) {

        flushCommand =
            DumpData.HwDeviceExtension.DeviceParameters[DumpData.CrashInitData->TargetId].IdeFlushCommandExt;

    } else {
#endif

        flushCommand =
            DumpData.HwDeviceExtension.DeviceParameters[DumpData.CrashInitData->TargetId].IdeFlushCommand;

#ifdef ENABLE_48BIT_LBA
    }
#endif

    if (flushCommand != IDE_COMMAND_NO_FLUSH) {

        WaitOnBusy(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);

        //
        // Zero SRB and ATA_PASS_THROUGH
        //
        RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));
        RtlZeroMemory(&ataPassThroughData, sizeof(ATA_PASS_THROUGH));

        //
        // Initialize SRB.
        //
        srb->Length   = sizeof(SCSI_REQUEST_BLOCK);
        srb->PathId   = DumpData.CrashInitData->PathId;
        srb->TargetId = DumpData.CrashInitData->TargetId;
        srb->Lun      = DumpData.CrashInitData->Lun;
        srb->Function = SRB_FUNCTION_ATA_PASS_THROUGH;
        srb->SrbFlags = SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                        SRB_FLAGS_DISABLE_DISCONNECT;
        srb->SrbStatus = srb->ScsiStatus = 0;
        srb->NextSrb = 0;
        srb->TimeOutValue = 10;
        srb->CdbLength = 10;
        srb->DataTransferLength = sizeof (ataPassThroughData);

        srb->DataBuffer = &ataPassThroughData;

        ataPassThroughData.IdeReg.bCommandReg = flushCommand;

        ataPassThroughData.IdeReg.bReserved = ATA_PTFLAGS_STATUS_DRDY_REQUIRED;

        srbStatus = IdeSendPassThroughCommand(
                        &DumpData.HwDeviceExtension,
                        srb
                        );

        if (srbStatus == SRB_STATUS_PENDING) {



            WaitOnBusy(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);

            DebugPrint ((DBG_ALWAYS, "flush = 0x%x, status = 0x%x...\n", flushCommand, ideStatus));

        } else if (srbStatus != SRB_STATUS_SUCCESS) {

            DebugPrint ((DBG_ALWAYS, "AtapiCrashDumpFinish: flush failed...\n"));
        }
    }

    //
    // issue an standby to park the drive head
    //
    srb = &DumpData.Srb;

    //
    // Zero SRB and ATA_PASS_THROUGH
    //
    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));
    RtlZeroMemory(&ataPassThroughData, sizeof(ATA_PASS_THROUGH));

    //
    // Initialize SRB.
    //
    srb->Length   = sizeof(SCSI_REQUEST_BLOCK);
    srb->PathId   = DumpData.CrashInitData->PathId;
    srb->TargetId = DumpData.CrashInitData->TargetId;
    srb->Lun      = DumpData.CrashInitData->Lun;
    srb->Function = SRB_FUNCTION_ATA_PASS_THROUGH;
    srb->SrbFlags = SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                    SRB_FLAGS_DISABLE_DISCONNECT;
    srb->SrbStatus = srb->ScsiStatus = 0;
    srb->NextSrb = 0;
    srb->TimeOutValue = 10;
    srb->CdbLength = 10;
    srb->DataTransferLength = sizeof (ataPassThroughData);

    srb->DataBuffer = &ataPassThroughData;

    ataPassThroughData.IdeReg.bCommandReg = IDE_COMMAND_STANDBY_IMMEDIATE;
    ataPassThroughData.IdeReg.bReserved = ATA_PTFLAGS_STATUS_DRDY_REQUIRED;

    srbStatus = IdeSendPassThroughCommand(
                    &DumpData.HwDeviceExtension,
                    srb
                    );

    if (srbStatus == SRB_STATUS_PENDING) {


        WaitOnBusy(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);

        WaitOnBusy(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);

        WaitOnBusy(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);

    } else if (srbStatus != SRB_STATUS_SUCCESS) {

        DebugPrint ((DBG_ALWAYS, "AtapiCrashDumpFinish: flush failed...\n"));
    }


    //
    //the disk will be powered off.
    //

    DebugPrint ((DBG_CRASHDUMP, "ATAPI: Leaving AtapiCrashDumpFinish...\n"));
    return;
}





/* ---------------------------- DMA --------------------------- */
/*                              ---                             */

VOID
AtapiCrashDumpBmCallback (
  IN PVOID Context
)
{
  // Just to make BmSetup happy -- it must be supplied
}


// Local variables that needs to be preserved across the calls
#define ENUM_DUMP_LOCALS(X) \
    X(LARGE_INTEGER,       DiskByteOffset) \
    X(PSCSI_REQUEST_BLOCK, srb) \
    X(PCDB,                cdb) \
    X(PMDL,                Mdl) \
    X(ULONG,               blockSize) \
    X(ULONG,               bytesWritten)

// States
#define STATE_READY       0
#define STATE_WAIT_DMA    1
#define STATE_WAIT_IDE    2
#define STATE_BAD_DMA     3
#define STATE_IO_FAIL     4

#define DMA_MAGIC   'XDma'

typedef struct
{
  UCHAR RegionDescriptorTablePage[PAGE_SIZE];

  LONG State;
  LONG Magic;

  SCSI_REQUEST_BLOCK Srb;

  PMDL Mdl;

  LARGE_INTEGER DiskByteOffset;

  ULONG BytesWritten;

  ULONG RetryCount;

  // Keep contents of BusMasterInterface.Context in safe place because
  // originally it's stored in memory that's saved by hibernation.
  // Unfortunately, BmSetup saves its arguments in PdoContext thus
  // constantly modifying memory. Special troubleshooting code in
  // po\hiber.c detects and reports such memory changes, and despite in this
  // case it's absolutely harmless it's better be avoided.

  PVOID BmContext;
  UCHAR BmContextBuffer[1024];
}
DUMP_LOCALS;

BOOLEAN
AtapiCrashDumpInterrupt(
    PVOID DeviceExtension
    )
/*++

  Routine Description:
  
    This is the ISR for crashdump. Should be called in a polling mode and works
    only for DMA requests. Doesn't need any of the flags, since we get called 
    in a synchronized manner.
    
  Arguments:
  
    DeviceExtension : The hardware device extension.
    
  Return Value:
  
    TRUE : if it is our interrupt.
    FALSE : if it is not our interrupt or if there are no pending requests.        
    
--*/
{
    PHW_DEVICE_EXTENSION deviceExtension = DeviceExtension;
    PPCIIDE_BUSMASTER_INTERFACE bmInterface = &deviceExtension->BusMasterInterface;
    PIDE_REGISTERS_1 baseIoAddress1 = &DumpData.HwDeviceExtension.BaseIoAddress1;
    PIDE_REGISTERS_2 baseIoAddress2 = &DumpData.HwDeviceExtension.BaseIoAddress2;
    PSCSI_REQUEST_BLOCK srb;
    BMSTATUS bmStatus;
    UCHAR statusByte;
    ULONG i;
    ULONG status;

    //
    // This interface should exist
    //
    ASSERT(bmInterface->BmStatus);

    //
    // poll the bus master status register
    //
    bmStatus = bmInterface->BmStatus(bmInterface->Context);

    //
    // return false if it is not our interrupt
    //
    if (!(bmStatus & BMSTATUS_INTERRUPT)) {

        DebugPrint((DBG_CRASHDUMP,
                    "Not our interrupt\n"
                    ));

        return FALSE;
    }

    //
    // Some VIA motherboards do not work without it
    //
    KeStallExecutionProcessor (5);

    //
    // disarm DMA and clear bus master interrupt
    //
    bmInterface->BmDisarm(bmInterface->Context);

    //
    // Get the current request
    //
    srb = deviceExtension->CurrentSrb;

    //
    // we will return false if there are no pending requests
    //
    if (srb == NULL) {

        DebugPrint((DBG_CRASHDUMP,
                    "No pending request\n"
                    ));

        return FALSE;
    }
    
    //
    // ignore the dma active bit
    //
    if (bmInterface->IgnoreActiveBitForAtaDevice) {
        CLRMASK (bmStatus, BMSTATUS_NOT_REACH_END_OF_TRANSFER);
    }

    //
    // Select IDE line(Primary or Secondary).
    //
    SelectIdeLine(baseIoAddress1, srb->TargetId >> 1);

    //
    // Clear interrupt by reading status.
    //
    GetBaseStatus(baseIoAddress1, statusByte);

    //
    // should be an ATA device
    //
    ASSERT(!(deviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_ATAPI_DEVICE));

    //
    // Check for error conditions.
    //
    if (statusByte & IDE_STATUS_ERROR) {

        //
        // Fail this request.
        //
        status = SRB_STATUS_ERROR;
        goto CompleteRequest;
    }

    WaitOnBusyUntil(baseIoAddress1, statusByte, 500);

    ASSERT(!(statusByte & IDE_STATUS_BUSY));

    //
    // interrupt indicates that the dma engine has finished the transfer
    //
    deviceExtension->BytesLeft = 0;

    //
    // bmStatus is initalized eariler.
    //
    if (!BMSTATUS_SUCCESS(bmStatus)) {

        if (bmStatus & BMSTATUS_ERROR_TRANSFER) {

            status = SRB_STATUS_ERROR;
        }

        if (bmStatus & BMSTATUS_NOT_REACH_END_OF_TRANSFER){

            status = SRB_STATUS_DATA_OVERRUN;
        }
    } else {

        status = SRB_STATUS_SUCCESS;
    }



CompleteRequest:

    //
    // should we translate the srb error
    // and a complicated retry mechanism.
    //

    //
    // check if drq is still up
    //
    i=0;
    while (statusByte & IDE_STATUS_DRQ) {

        GetStatus(baseIoAddress1,statusByte);

        i++;

        if (i > 5) {

            status = SRB_STATUS_BUSY;
        }

        KeStallExecutionProcessor(100);
    }

    //
    // check if the device is busy
    //
    if (statusByte & IDE_STATUS_BUSY) {

        status = SRB_STATUS_BUSY;

    }

    //
    // Set the srb status
    //
    srb->SrbStatus = (UCHAR)status;

    //
    // request is done.
    //
    deviceExtension->CurrentSrb = NULL;

    return TRUE;

}

NTSTATUS
AtapiCrashDumpIdeWriteDMA (
    IN LONG Action,
    IN PLARGE_INTEGER ArgDiskByteOffset,
    IN PMDL ArgMdl,
    IN PVOID LocalData
    )
/*++

  Routine Description:
    Asynchronous DMA write routine.

  Arguments:

    Action        - one of following:
        IO_DUMP_WRITE_INIT    - Initialize LocalData (must be first call)
        IO_DUMP_WRITE_FULFILL - Perform IO and wait until completion
        IO_DUMP_WRITE_START   - Start IO and return ASAP
        IO_DUMP_WRITE_RESUME  - Resume previousely started IO
        IO_DUMP_WRITE_FINISH  - Complete previous IO request (wait if necessary)

        Attention! It is caller's responsibility to make sure that
          a) WriteDMA is always called with absolutely the same value of LocalData
          b) Contents of *ArgMdl will be preserved between Start/Resume/Finish
          c) Memory given by ArgMdl is not modified until the end of operation

    ArgDiskByteOffset - Offset on hard disk in bytes

    ArgMdl            - MDL giving output memory layout
        Attn: for DMA the best IO size is 4 KB; for PIO the more the better
            
    LocalData         - Memory region where WriteDMA will keep all the data
                        that need to be preserved between Start/Resume/Finish.
         Attn: this region shall be of at least IO_DUMP_WRITE_DATA_SIZE bytes,
               and it must be page-aligned

  Return Value:

    STATUS_SUCCESS      - operation completed successfully
    STATUS_PENDING      - operation started but not completed yet
    STATUS_UNSUCCESSFUL - operation failed; use of WriteRoutine (PIO-based IO) adviced
                          (however if user will keep on using WriteDMA it will redirect
                          all requests to PIO itself)
    STATUS_INVALID_PARAMETER - previously started operation wasn't finished, or
                          incorrect parameter indeed
--*/
{

    DUMP_LOCALS                 *Locals = LocalData;
    PHW_DEVICE_EXTENSION        hwExtension = &DumpData.HwDeviceExtension;
    PPCIIDE_BUSMASTER_INTERFACE bmInterface = &hwExtension->BusMasterInterface;
    LONG                        targetId = DumpData.CrashInitData->TargetId;
    PSCSI_REQUEST_BLOCK         srb;
    NTSTATUS                    status;
    ULONG                       srbStatus;
    BMSTATUS                    bmStatus;
    ULONG                       i;
    PCDB                        cdb;
    UCHAR                       statusByte;
    PMDL                        mdl;
    BOOLEAN                     interruptCleared;
    BOOLEAN                     usePio = FALSE;

    if (IO_DUMP_WRITE_DATA_SIZE < sizeof (*Locals)) {
        DebugPrint ((DBG_CRASHDUMP, "AtapiCrashDumpIdeWriteDMA: IO_DUMP_WRITE_DATA_SIZE = %d, sizeof (*Locals) == %d\n",
                     IO_DUMP_WRITE_DATA_SIZE, sizeof (*Locals)));
        return STATUS_INVALID_PARAMETER;
    }

    switch (Action) {
        case IO_DUMP_WRITE_INIT:

            //
            // initalize the state to bad_dma
            //
            Locals->State = STATE_BAD_DMA;
            Locals->Magic = 0;

            //
            // Check alignment
            //
            if (((ULONG_PTR) Locals) & (PAGE_SIZE-1)) {
                DebugPrint ((DBG_CRASHDUMP, "AtapiCrashDumpIdeWriteDMA: misaligned Locals = %p\n", Locals));
                return STATUS_UNSUCCESSFUL;
            }


            //
            // Make sure we may use UDMA; do not try to use pure DMA --
            // it won't work on some machines (e.g. Compaq Armada 7800)
            //
            if (!(hwExtension->DeviceFlags[targetId] & DFLAGS_DEVICE_PRESENT) ||
                !(hwExtension->DeviceParameters[targetId].TransferModeSupported & UDMA_SUPPORT) ||
                !(hwExtension->DeviceParameters[targetId].TransferModeSelected & UDMA_SUPPORT) ||
                !(hwExtension->DeviceFlags[targetId] & DFLAGS_USE_UDMA) ||
                bmInterface->MaxTransferByteSize <= 0
               ) {
                DebugPrint ((DBG_CRASHDUMP, "AtapiCrashDumpIdeWriteDMA: UDMA is not available\n"));
                return STATUS_UNSUCCESSFUL;
            }



            //
            // Copy contents of BusMasterInterface.Context to safe place and
            // substitute the pointer. Bm* functions change its contents
            //
            ASSERT(bmInterface->ContextSize > 0);
            ASSERT(bmInterface->ContextSize < sizeof(Locals->BmContextBuffer));

            //
            // make sure we can copy the context to the local buffer
            //
            if ((bmInterface->ContextSize <=0) ||
                (bmInterface->ContextSize > sizeof(Locals->BmContextBuffer))) {

                return STATUS_UNSUCCESSFUL;

            }

            //
            // Save BM context in modifyable memory: 
            // Bm* functions change its contents
            //
            Locals->BmContext = bmInterface->Context;
            RtlCopyMemory (&Locals->BmContextBuffer, Locals->BmContext, bmInterface->ContextSize);


            //
            // Check version of PCIIDEX.SYS
            //
            ASSERT(bmInterface->BmSetupOnePage);


            //
            // OK, now we are ready to use DMA
            //
            Locals->Magic = DMA_MAGIC;
            Locals->State = STATE_READY;

            return STATUS_SUCCESS;

        case IO_DUMP_WRITE_START:
        case IO_DUMP_WRITE_FULFILL:

            //
            // Make sure it was properly initialized
            //
            if (Locals->Magic != DMA_MAGIC) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Do not call DMA if it failed once -- use PIO
            //
            if (Locals->State == STATE_BAD_DMA) {
                return AtapiCrashDumpIdeWrite (ArgDiskByteOffset, ArgMdl);
            }

            //
            // Caller did not complete prev IO
            //
            if (Locals->State != STATE_READY) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // Copy arguments into local variables
            //
            Locals->DiskByteOffset = *ArgDiskByteOffset;
            Locals->Mdl = ArgMdl;
            Locals->RetryCount = 0;

            srb = &Locals->Srb;
            mdl = Locals->Mdl;


            //
            // must be complete sectors
            //
            if (mdl->ByteCount % DumpData.BytesPerSector) {

                DebugPrint ((DBG_CRASHDUMP, 
                             "AtapiCrashDumpWriteDMA ERROR: not writing full sectors\n"
                             ));

                return STATUS_INVALID_PARAMETER;
            }

            //
            // need code to split request up
            //
            if ((mdl->ByteCount / DumpData.BytesPerSector) > 256) {

                DebugPrint ((DBG_CRASHDUMP, 
                             "AtapiCrashDumpWriteDMA ERROR: can't handle large write\n"
                             ));

                return STATUS_INVALID_PARAMETER;
            }

            //
            // use modifiable memory
            //
            bmInterface->Context = &Locals->BmContextBuffer;

            //
            // Zero SRB.
            //
            RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

            //
            // Initialize SRB.
            //
            srb->Length   = sizeof(SCSI_REQUEST_BLOCK);
            srb->PathId   = DumpData.CrashInitData->PathId;
            srb->TargetId = (UCHAR) targetId;
            srb->Lun      = DumpData.CrashInitData->Lun;
            srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
            srb->SrbFlags = SRB_FLAGS_DATA_OUT |
                            SRB_FLAGS_DISABLE_SYNCH_TRANSFER |
                            SRB_FLAGS_DISABLE_DISCONNECT |
                            SRB_FLAGS_DISABLE_AUTOSENSE;
            srb->SrbStatus = srb->ScsiStatus = 0;
            srb->NextSrb = 0;
            srb->TimeOutValue = 10;
            srb->CdbLength = 10;

            cdb = (PCDB)srb->Cdb;

            //
            // Initialize CDB for write command.
            //
            cdb->CDB10.OperationCode = SCSIOP_WRITE;

            //
            // Mark it for DMA
            //
            MARK_SRB_FOR_DMA (srb);

            hwExtension->CurrentSrb = srb;

            break;


        case IO_DUMP_WRITE_RESUME:
        case IO_DUMP_WRITE_FINISH:

            //
            // Make sure it was properly initialized
            //
            if (Locals->Magic != DMA_MAGIC) {
                return STATUS_INVALID_PARAMETER;
            }

            //
            // restore the local variables from scratch memory
            //
            srb = &Locals->Srb;
            mdl = Locals->Mdl;

            //
            // Resume/finish operation
            //

            if (Locals->State == STATE_READY) {

                //
                // we are done. return success
                //
                return(STATUS_SUCCESS);

            }

            if (Locals->State == STATE_WAIT_DMA) {

                //
                // Restore CurrentSrb 
                // (it should be reset back to NULL on return)
                //
                hwExtension->CurrentSrb = srb;
                bmInterface->Context = &Locals->BmContextBuffer;

                goto WaitDma;
            }

            //
            // if any of the DMA operations failed, we would have used
            // PIO. PIO would have completed the transfer, so just return
            // status success.
            //
            if (Locals->State == STATE_BAD_DMA) {

                return STATUS_SUCCESS;
            }

            //
            // wrong state
            //
            DebugPrint((DBG_ALWAYS,
                        "Wrong local state 0x%x\n",
                        Locals->State
                        ));

            ASSERT(FALSE);

            return(STATUS_INVALID_PARAMETER);

        default:

            DebugPrint ((DBG_CRASHDUMP, "AtapiCrashDumpIdeWriteDMA: Wrong Action = %d\n", Action));
            return STATUS_INVALID_PARAMETER;
    }


    DebugPrint((DBG_CRASHDUMP,
                "AtapiCrashDumpWriteDMA: Write memory at 0x%x for 0x%x bytes\n",
                mdl->MappedSystemVa,
                mdl->ByteCount));

    Locals->BytesWritten = 0;
    usePio = FALSE;

    do {

        ULONG blockSize;
        ULONG blockCount;
        ULONG blockOffset;
        ULONG bytesWritten = Locals->BytesWritten;

        //
        // determine the block size
        //

        //
        // cannot be greater than the max block size
        //
        if ((mdl->ByteCount - bytesWritten) > DumpData.MaxBlockSize) {

            blockSize = DumpData.MaxBlockSize;
            DebugPrint ((DBG_CRASHDUMP, "AtapiCrashDumpWriteDMA: can't do a single write...\n"));

        } else {

            blockSize = mdl->ByteCount - bytesWritten;
        }

        //
        // Write page by page in order to avoid extra memory allocations in HAL
        //
        {
            ULONG Size = PAGE_SIZE - (((ULONG) ((ULONG_PTR) mdl->MappedSystemVa + bytesWritten)) & (PAGE_SIZE - 1));
            if (blockSize > Size) {
                blockSize = Size;
            }
        }

        //
        // Don't do more than DMA can
        //
        if (blockSize > bmInterface->MaxTransferByteSize) {

            blockSize = bmInterface->MaxTransferByteSize;

        }

        blockCount =  blockSize / DumpData.BytesPerSector;

        //
        // initialize status
        //
        status = STATUS_UNSUCCESSFUL;

        //
        // fill in the fields in the srb
        //
        srb->SrbStatus = srb->ScsiStatus = 0;
        srb->DataTransferLength = blockSize;
        srb->DataBuffer = ((PUCHAR) mdl->MappedSystemVa) + bytesWritten;

        //
        // Convert disk byte offset to block offset.
        //
        blockOffset = (ULONG)((DumpData.PartitionOffset.QuadPart +
                                       (Locals->DiskByteOffset).QuadPart + 
                                       (ULONGLONG) bytesWritten) / DumpData.BytesPerSector);

        cdb = (PCDB)srb->Cdb;

        //
        // Fill in CDB block address.
        //
        cdb->CDB10.LogicalBlockByte0 = ((PFOUR_BYTE)&blockOffset)->Byte3;
        cdb->CDB10.LogicalBlockByte1 = ((PFOUR_BYTE)&blockOffset)->Byte2;
        cdb->CDB10.LogicalBlockByte2 = ((PFOUR_BYTE)&blockOffset)->Byte1;
        cdb->CDB10.LogicalBlockByte3 = ((PFOUR_BYTE)&blockOffset)->Byte0;

        cdb->CDB10.TransferBlocksMsb = ((PFOUR_BYTE)&blockCount)->Byte1;
        cdb->CDB10.TransferBlocksLsb = ((PFOUR_BYTE)&blockCount)->Byte0;


        //
        // make sure device is not busy
        //
        WaitOnBusy(&hwExtension->BaseIoAddress1, statusByte);

        //
        // HACK: do PIO. 
        // Complete this request with PIO. Further requests will not
        // use DMA.
        //
        if (usePio) {

            status = AtapiCrashDumpIdeWritePio(srb);

            goto CompleteIde;
        }

        //
        // Make sure DMA is not busy
        //
        bmStatus = bmInterface->BmStatus (bmInterface->Context);

        if (bmStatus & BMSTATUS_INTERRUPT) {

            //
            // Well, in absense of interrupts it means that DMA is ready
            // However extra disarming won't hurt
            //
            bmInterface->BmDisarm (bmInterface->Context);

        } else if (bmStatus != BMSTATUS_NO_ERROR) {

            ASSERT(bmStatus == BMSTATUS_NO_ERROR);

            status = STATUS_UNSUCCESSFUL;

            goto Return;
        }

        //
        // Flush cached data buffers
        //
        KeFlushIoBuffers(mdl, FALSE, TRUE);

        //
        // Start new DMA operation
        //
        if (bmInterface->BmSetupOnePage == NULL) {
            status = bmInterface->BmSetup (
                                          bmInterface->Context,
                                          srb->DataBuffer,
                                          srb->DataTransferLength,
                                          mdl,
                                          FALSE,
                                          AtapiCrashDumpBmCallback,
                                          NULL
                                          );
        } else {
            status = bmInterface->BmSetupOnePage (
                                                 bmInterface->Context,  
                                                 srb->DataBuffer,
                                                 srb->DataTransferLength,
                                                 mdl,
                                                 FALSE,
                                                 Locals
                                                 );
        }

        if (!NT_SUCCESS(status)) {

            ASSERT(NT_SUCCESS(status));

            goto Return;
        }

        //
        // make sure the device is not busy
        //
        WaitOnBusy(&DumpData.HwDeviceExtension.BaseIoAddress1, statusByte);

        //
        // srb should be marked for DMA
        //
        ASSERT(SRB_USES_DMA(srb));

        //
        // Start new IO
        //

#ifdef ENABLE_48BIT_LBA
        if (hwExtension->DeviceFlags[targetId] & DFLAGS_48BIT_LBA) {

            srbStatus = IdeReadWriteExt (hwExtension, srb);

        } else {
#endif

            srbStatus = IdeReadWrite (hwExtension, srb);

#ifdef ENABLE_48BIT_LBA
        }
#endif

        if (srbStatus != SRB_STATUS_PENDING) {

            DebugPrint ((DBG_CRASHDUMP, 
                         "AtapiCrashDumpWriteDMA: Wrong srbStatus = 0x%x\n", 
                         srbStatus
                         ));

            //
            // reset and retry
            //
            srb->SrbStatus = (UCHAR)srbStatus;

            goto CompleteIde;
        }

        WaitDma:

            //
            // wait for the dma to finish and the controller to
            // interrupt. we will keep polling the bus master status
            // register
            //
            bmStatus = bmInterface->BmStatus(bmInterface->Context);

            //
            // if we have an interrupt or there is an error 
            // we are done
            //
            if (!((bmStatus & BMSTATUS_INTERRUPT) ||
                  (bmStatus & BMSTATUS_ERROR_TRANSFER))) {

                //
                // if we don't have to fulfill the request, just
                // return pending. we will be called again.
                //
                if ((Action == IO_DUMP_WRITE_START) ||
                    (Action == IO_DUMP_WRITE_RESUME)) {

                    Locals->State = STATE_WAIT_DMA;

                    status = STATUS_PENDING;

                    goto Return;
                }

                //
                // we have to finish the request. wait until the interrupt
                // is set
                //
                i=0;

                while (i++ < 10000) {

                    bmStatus = bmInterface->BmStatus(bmInterface->Context);

                    if ((bmStatus & BMSTATUS_INTERRUPT) ||
                        (bmStatus & BMSTATUS_ERROR_TRANSFER)) {

                        break;
                    }

                    KeStallExecutionProcessor (100);
                }

                //
                // check if we received an interrupt.
                //
                if (i >= 10000) {

                    //
                    // reset and retry
                    //
                    ASSERT(FALSE);

                    //
                    // disarm the dma controller
                    //
                    bmInterface->BmDisarm (bmInterface->Context);

                    srb->SrbStatus = SRB_STATUS_ERROR;

                    goto CompleteIde;

                }
            }

            if (bmStatus & BMSTATUS_ERROR_TRANSFER){ 

                //
                // Transfer Error. fail the transfer.
                //
                status = STATUS_UNSUCCESSFUL;

                goto Return;

            } 

            //
            // wait for our ISR to finish its job
            //
            interruptCleared = AtapiCrashDumpInterrupt(hwExtension);
            
            //
            // it should be our interrupt
            //
            ASSERT(interruptCleared);

            if (!interruptCleared) {

                status = STATUS_DEVICE_BUSY;

                goto Return;
                
            }

            //
            // clear any spurious interrupts
            //
            i=0;
            while (AtapiCrashDumpInterrupt(hwExtension)) {

                i++;
                if (i>=100) {

                    DebugPrint((0,
                                "AtapiCrashDump: InterruptStorm\n"
                                ));

                    status = STATUS_DEVICE_BUSY;

                    goto Return;
                }

                KeStallExecutionProcessor (100);
            }


        CompleteIde:

            //
            // Flush the adapter buffers
            //
            if (usePio) {

                //
                // don't do anything
                //

            } else if (bmInterface->BmSetupOnePage == NULL) {

                bmInterface->BmFlush (bmInterface->Context);

            } else {
                status = bmInterface->BmFlushAdapterBuffers (
                                                     bmInterface->Context,  
                                                     srb->DataBuffer,
                                                     srb->DataTransferLength,
                                                     mdl,
                                                     FALSE
                                                     );
            }

            //
            // update the bytesWritten
            //
            if (srb->SrbStatus == SRB_STATUS_SUCCESS) {

                //
                // status success
                //
                status = STATUS_SUCCESS;

                //
                // update byteswritten
                //
                Locals->BytesWritten += srb->DataTransferLength;

                //
                // reset retry count
                //
                Locals->RetryCount = 0;

            } else {

                ASSERT(FALSE);

                //
                // reset the bus and retry the request
                //
                IdeHardReset (
                    &DumpData.HwDeviceExtension.BaseIoAddress1,
                    &DumpData.HwDeviceExtension.BaseIoAddress2,
                    TRUE,
                    TRUE
                    );

                //
                // we should probably look at the error code and
                // decide on the retry appropriately. However, to
                // minimize complexity, we would just blindly retry
                // 4 times and then use PIO
                //
                Locals->RetryCount++;

                //
                // retry with PIO (dma timeout)
                // Give dma a fair shot. Once we switch to PIO
                // we would not use DMA for the rest of hibernation.
                //
                if (Locals->RetryCount == 5) {
                    usePio = TRUE;
                }

                //
                // PIO failed. Return error.
                //
                if (Locals->RetryCount > 5) {

                    status = STATUS_IO_DEVICE_ERROR;
                    goto Return;
                }

            }

    } while (Locals->BytesWritten < mdl->ByteCount);

    Locals->State = STATE_READY;
    status = STATUS_SUCCESS;

    Return:

        //
        // if we used PIO this time, disable dma
        // for the rest of hibernation
        //
        if (usePio) {
            Locals->State = STATE_BAD_DMA;
        }

        if (!NT_SUCCESS(status)) {

            ASSERT(FALSE);
            Locals->State = STATE_IO_FAIL;

        }

        hwExtension->CurrentSrb = NULL;
        bmInterface->Context = Locals->BmContext;

        return status;

}

NTSTATUS
AtapiCrashDumpIdeWritePio (
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    NTSTATUS            status;
    ULONG               srbStatus;
    UCHAR               ideStatus;
    ULONG               i;

    MARK_SRB_FOR_PIO(Srb);

    //
    // make sure it is not busy
    //
    WaitOnBusy(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);

    //
    // Send the srb to the device
    //

#ifdef ENABLE_48BIT_LBA
        if (DumpData.HwDeviceExtension.DeviceFlags[Srb->TargetId] & DFLAGS_48BIT_LBA) {

            srbStatus = IdeReadWriteExt(&DumpData.HwDeviceExtension, Srb);

        } else {
#endif

            srbStatus = IdeReadWrite(&DumpData.HwDeviceExtension, Srb);

#ifdef ENABLE_48BIT_LBA
        }
#endif


    if (srbStatus == SRB_STATUS_PENDING) {

        while (DumpData.HwDeviceExtension.BytesLeft) {

            //
            // ATA-2 spec requires a minimum of 400 ns stall here
            //
            KeStallExecutionProcessor (1);

            //
            // a quick wait
            //
            for (i=0; i<100; i++) {

                GetStatus(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);
                if (!(ideStatus & IDE_STATUS_BUSY)) {
                    break;
                }
            }

            if (ideStatus & IDE_STATUS_BUSY) {

                //
                // go to a slower wait
                //
                WaitOnBusy(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);
            }

            if (ideStatus & (IDE_STATUS_BUSY | IDE_STATUS_ERROR)) {

                status = STATUS_UNSUCCESSFUL;
                DebugPrint ((DBG_ALWAYS, "AtapiCrashDumpIdeWrite: unexpected status 0x%x\n", ideStatus));
                break;

            } else {

                ULONG byteCount;

                //
                // a quick wait On DRQ
                //
                for (i=0; i<100; i++) {

                    GetStatus(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);
                    if (ideStatus & IDE_STATUS_DRQ) {
                        break;
                    }
                }

                if (!(ideStatus & IDE_STATUS_DRQ)) {

                    WaitForDrq(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);
                }

                if (!(ideStatus & IDE_STATUS_DRQ)) {

                    status = STATUS_UNSUCCESSFUL;
                    DebugPrint ((DBG_ALWAYS, "AtapiCrashDumpIdeWrite: drq fails to assert, 0x%x\n", ideStatus));
                    break;
                }

                if (DumpData.HwDeviceExtension.BytesLeft <
                    DumpData.HwDeviceExtension.DeviceParameters[Srb->TargetId].MaxBytePerPioInterrupt) {
                    byteCount = DumpData.HwDeviceExtension.BytesLeft;
                } else {
                    byteCount = DumpData.HwDeviceExtension.DeviceParameters[Srb->TargetId].MaxBytePerPioInterrupt;
                }

                WriteBuffer(&DumpData.HwDeviceExtension.BaseIoAddress1,
                            (PUSHORT)DumpData.HwDeviceExtension.DataBuffer,
                            byteCount / sizeof(USHORT));

                DumpData.HwDeviceExtension.BytesLeft -= byteCount;
                DumpData.HwDeviceExtension.DataBuffer += byteCount;
            }
        }

        if (!DumpData.HwDeviceExtension.BytesLeft) {

            //
            // ATA-2 spec requires a minimum of 400 ns stall here
            //
            KeStallExecutionProcessor (1);

            //
            // a quick wait
            //
            for (i=0; i<100; i++) {

                GetStatus(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);
                if (!(ideStatus & IDE_STATUS_BUSY)) {
                    break;
                }
            }

            if (ideStatus & IDE_STATUS_BUSY) {

                //
                // go to a slower wait
                //
                WaitOnBusy(&DumpData.HwDeviceExtension.BaseIoAddress1, ideStatus);
            }
        }

        if (DumpData.HwDeviceExtension.BytesLeft) {

            status = STATUS_UNSUCCESSFUL;
            DebugPrint ((DBG_ALWAYS, "AtapiCrashDumpIdeWrite: write failed. idestatus = 0x%x\n", ideStatus));

        } else {

            Srb->SrbStatus = SRB_STATUS_SUCCESS;
            status = STATUS_SUCCESS;
        }

    } else {

        DebugPrint ((DBG_ALWAYS,
                     "atapi crash dump: IdeReadWrite failed with stautus = 0x%x\n",
                     srbStatus
                     ));

        status = STATUS_UNSUCCESSFUL;
    }

    if (!NT_SUCCESS(status)) {

        Srb->SrbStatus = SRB_STATUS_ERROR;

    } else {

        ASSERT(Srb->SrbStatus == SRB_STATUS_SUCCESS);
    }

    DumpData.HwDeviceExtension.BytesLeft = 0;
    DumpData.HwDeviceExtension.DataBuffer = 0;

    return status;
}



NTSTATUS
AtapiDumpCallback(
    IN PKBUGCHECK_DATA BugcheckData,
    IN PVOID BugcheckBuffer,
    IN ULONG BugcheckBufferLength,
    IN PULONG BugcheckBufferUsed
    )
/*++

Routine Description:

    This routine fills in the ATAPI_INFO structure with all relevant details
    of the Paging disk which is marked DeadMeat. This should be called if
    we bugchecked with 0x7a/77 with STATUS_NO_SUCH_DEVICE

Arguments:

    PAtapiInfo - Pointer to the structure which would contain failure info
                 for the paging disk.

Return Value:

    NTSTATUS code.

--*/
{
    NTSTATUS status;
    ULONG i;
    ULONG j;                
    PPDO_EXTENSION pdoExtension;
    PFDO_EXTENSION fdoExtension;
    PATAPI_DUMP_PDO_INFO dumpInfo;
    PLIST_ENTRY nextEntry;
    LONG remainingBuffer;
    

    //
    // We only gather information for bugcheck 77s and 7As.
    //
    
    if (BugcheckData->BugCheckCode != KERNEL_STACK_INPAGE_ERROR &&
        BugcheckData->BugCheckCode != KERNEL_DATA_INPAGE_ERROR) {
        return STATUS_NOT_IMPLEMENTED;
    }

    dumpInfo = (PATAPI_DUMP_PDO_INFO)BugcheckBuffer;
    remainingBuffer = (LONG)BugcheckBufferLength;

    //
    // Iterate over FDOs on using ATAPI.
    //
        
    for (nextEntry = IdeGlobalFdoList.List.Flink;
         nextEntry != &IdeGlobalFdoList.List;
         nextEntry = nextEntry->Flink) {

        fdoExtension = CONTAINING_RECORD (nextEntry,
                                          FDO_EXTENSION,
                                          NextFdoLink);

        //
        // Iterate over the PDOs attached to the FDO.
        //
        
        for (j = 0; j < 8; j++) {

            if (remainingBuffer <= sizeof (ATAPI_DUMP_PDO_INFO)) {
                goto loop_break;
            }

            pdoExtension = fdoExtension->LogicalUnitList[j];

            if (pdoExtension) {

                status = AtapiDumpGetCrashInfo (pdoExtension, dumpInfo);

                if (NT_SUCCESS (status)) {
                    dumpInfo++;
                    remainingBuffer -= sizeof (ATAPI_DUMP_PDO_INFO);
                } 
            }
            
        }
    }
loop_break:

    //
    // Update the buffer size.
    //

    ASSERT (remainingBuffer >= 0);
    *BugcheckBufferUsed = BugcheckBufferLength - remainingBuffer;

    return STATUS_SUCCESS;
}

NTSTATUS
AtapiDumpGetCrashInfo(
    IN PPDO_EXTENSION PdoExtension,
    IN PATAPI_DUMP_PDO_INFO PdoDumpInfo
    )
/*++

Routine Description:

    This routine fills in the ATAPI_PDO_DUMP_INFO structure with all
    relevant details of the Paging disk which is marked DeadMeat. 

Arguments:

    PdoExtension - Points to the PDO extension. 

    PdoDumpInfo - Pointer to the structure which would contain failure info
                 for the paging disk.

Return Value:

    NTSTATUS code.

--*/

{
    UCHAR                       drive;
    UCHAR                       targetId;
    PFDO_EXTENSION              fdoExtension;
    PHW_DEVICE_EXTENSION        hwDeviceExtension;
    IDE_REGISTERS_1             baseIoAddress1;
    IDE_REGISTERS_2             baseIoAddress2;

    //
    // We're only interested in collecting information for the paging disk(s)
    // that have failed.
    //

    if (PdoExtension->PagingPathCount == 0 ) {
        return STATUS_NOT_IMPLEMENTED;
    }
    
    fdoExtension = PdoExtension->ParentDeviceExtension;
    hwDeviceExtension = fdoExtension->HwDeviceExtension;
    targetId = PdoExtension->TargetId;
    baseIoAddress1 = hwDeviceExtension->BaseIoAddress1;
    baseIoAddress2 = hwDeviceExtension->BaseIoAddress2;

    PdoDumpInfo->TransferModeSelected =
        hwDeviceExtension->DeviceParameters[targetId].TransferModeSelected;

    drive = (targetId == 0) ? 0xa0 : 0xb0;
    WRITE_PORT_UCHAR(baseIoAddress1.DriveSelect, drive);

    PdoDumpInfo->DriveRegisterStatus  = READ_PORT_UCHAR(baseIoAddress1.Command);

    //
    // Get all the interesting from Atapi PDO Extension
    //
    
    PdoDumpInfo->Reason = PdoExtension->DeadmeatRecord.Reason;
    PdoDumpInfo->TargetId = PdoExtension->TargetId;
    PdoDumpInfo->ConsecutiveTimeoutCount = PdoExtension->ConsecutiveTimeoutCount;
    PdoDumpInfo->DmaTransferTimeoutCount = PdoExtension->DmaTransferTimeoutCount;
    PdoDumpInfo->FlushCacheTimeoutCount = PdoExtension->FlushCacheTimeoutCount;
    PdoDumpInfo->WriteCacheEnable = PdoExtension->WriteCacheEnable;

    RtlCopyMemory(PdoDumpInfo->FullVendorProductId,
                  PdoExtension->FullVendorProductId,
                  41);
    RtlCopyMemory(PdoDumpInfo->FullProductRevisionId,
                  PdoExtension->FullProductRevisionId,
                  9);
    RtlCopyMemory(PdoDumpInfo->FullSerialNumber,
                  PdoExtension->FullSerialNumber,
                  41);

    if (PdoExtension->SrbData.IdeCommandLog != NULL) {
    
        RtlCopyMemory(PdoDumpInfo->CommandLog, 
                      PdoExtension->SrbData.IdeCommandLog,
                      MAX_COMMAND_LOG_ENTRIES * sizeof(COMMAND_LOG));

        PdoDumpInfo->IdeCommandLogIndex =
                                    PdoExtension->SrbData.IdeCommandLogIndex;

    } else {
        PdoDumpInfo->IdeCommandLogIndex = -1;
    }

    PdoDumpInfo->Version = ATAPI_DUMP_RECORD_VERSION;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\chanfdo.h ===
/*++

Copyright (C) 1993-99  Microsoft Corporation

Module Name:

    chanfdo.h

Abstract:

--*/

#if !defined (___chanfdo_h___)
#define ___chanfdo_h___

//
// work item
//
typedef struct _IDE_WORK_ITEM_CONTEXT {

    PIO_WORKITEM    WorkItem;
    PIRP            Irp;

} IDE_WORK_ITEM_CONTEXT, *PIDE_WORK_ITEM_CONTEXT;

             
NTSTATUS
ChannelAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
ChannelAddChannel(
    IN  PDRIVER_OBJECT DriverObject,
    IN  PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PFDO_EXTENSION *FdoExtension
    );

NTSTATUS
ChannelStartDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelStartChannel (
    PFDO_EXTENSION    FdoExtension,
    PCM_RESOURCE_LIST ResourceListToKeep
    );

NTSTATUS
ChannelStartDeviceCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP       Irp,
    IN OUT PVOID      Context
    );

NTSTATUS
ChannelCreateSymblicLinks (
    PFDO_EXTENSION FdoExtension
    );

NTSTATUS
ChannelDeleteSymblicLinks (
    PFDO_EXTENSION FdoExtension
    );

NTSTATUS
ChannelSurpriseRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelRemoveDeviceCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
ChannelStopDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelRemoveChannel (
    PFDO_EXTENSION    FdoExtension
    );

NTSTATUS
ChannelStartDeviceCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
ChannelQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelQueryBusRelation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIDE_WORK_ITEM_CONTEXT workItemContext
    );

PDEVICE_RELATIONS
ChannelBuildDeviceRelationList (
    PFDO_EXTENSION FdoExtension
    );

NTSTATUS
ChannelQueryId (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelQueryIdCompletionRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

NTSTATUS
ChannelUsageNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelUsageNotificationCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
ChannelDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
ChannelQueryBusMasterInterface (
    PFDO_EXTENSION    FdoExtension
    );

VOID
ChannelQueryTransferModeInterface (
    PFDO_EXTENSION    FdoExtension
    );

VOID
ChannelUnbindBusMasterParent (
    PFDO_EXTENSION    FdoExtension
    );

VOID
ChannelQuerySyncAccessInterface (
    PFDO_EXTENSION    FdoExtension
    );

VOID
ChannelQueryRequestProperResourceInterface (
    PFDO_EXTENSION    FdoExtension
    );

    
__inline
VOID
ChannelEnableInterrupt (
    IN PFDO_EXTENSION FdoExtension
    );

__inline
VOID
ChannelDisableInterrupt (
    IN PFDO_EXTENSION FdoExtension
	);

NTSTATUS
ChannelGetIdentifyData (
    PFDO_EXTENSION FdoExtension,
    ULONG DeviceNumber,
    PIDENTIFY_DATA IdentifyData
    );

NTSTATUS
ChannelAcpiTransferModeSelect (
    IN PVOID Context,
    PPCIIDE_TRANSFER_MODE_SELECT XferMode
    );

NTSTATUS
ChannelRestoreTiming (
    IN PFDO_EXTENSION FdoExtension,
    IN PSET_ACPI_TIMING_COMPLETION_ROUTINE CallerCompletionRoutine,
    IN PVOID CallerContext
    );

NTSTATUS
ChannelRestoreTimingCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PVOID Context
    );

NTSTATUS
ChannelFilterResourceRequirements (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
    
BOOLEAN
ChannelQueryPcmciaParent (
    PFDO_EXTENSION FdoExtension
    );
      
#ifdef IDE_FILTER_PROMISE_TECH_RESOURCES
NTSTATUS
ChannelFilterPromiseTechResourceRequirements (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
#endif // IDE_FILTER_PROMISE_TECH_RESOURCES

NTSTATUS
ChannelQueryPnPDeviceState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
                         
#ifdef ENABLE_NATIVE_MODE
VOID
ChannelQueryInterruptInterface (
    PFDO_EXTENSION    FdoExtension
    );
#endif
#endif // ___chanfdo_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\crashdmp.h ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    crashdmp.h

Abstract:

--*/

#if !defined (___crashdmp_h___)
#define ___crashdmp_h___

#include <idedump.h>

typedef
VOID
(*PSTALL_ROUTINE) (
    IN ULONG Delay
    );
     
typedef struct _CRASHDUMP_INIT_DATA {

    ULONG               CheckSum;

    UCHAR               PathId;
    UCHAR               TargetId;
    UCHAR               Lun;

    PHW_DEVICE_EXTENSION LiveHwDeviceExtension;

} CRASHDUMP_INIT_DATA, *PCRASHDUMP_INIT_DATA;
      
typedef struct _CRASHDUMP_DATA {

    PCRASHDUMP_INIT_DATA    CrashInitData;

    ULONG                   BytesPerSector;

    LARGE_INTEGER           PartitionOffset;

    PSTALL_ROUTINE          StallRoutine;

    SCSI_REQUEST_BLOCK      Srb;

    HW_DEVICE_EXTENSION     HwDeviceExtension;

    ULONG                   MaxBlockSize;

} CRASHDUMP_DATA, *PCRASHDUMP_DATA;

ULONG
AtapiCrashDumpDriverEntry (
    PVOID Context
    );

//
// crash dump privates
//
BOOLEAN
AtapiCrashDumpOpen (
    IN LARGE_INTEGER PartitionOffset
    );

NTSTATUS
AtapiCrashDumpIdeWrite (
    IN PLARGE_INTEGER DiskByteOffset,
    IN PMDL Mdl
    );

VOID
AtapiCrashDumpFinish (
    VOID
    );
                         
NTSTATUS
AtapiCrashDumpIdeWritePio (
    IN PSCSI_REQUEST_BLOCK Srb
    );

NTSTATUS
AtapiDumpCallback(
    IN PKBUGCHECK_DATA BugcheckData,
    IN PVOID BugcheckBuffer,
    IN ULONG BugcheckBufferLength,
    IN PULONG BugcheckBufferUsed
    );


//
// Validate that the duplicate definitions in IDEDUMP.H are the same as
// the ATAPI ones are.
//

C_ASSERT (sizeof (COMMAND_LOG) == sizeof (ATAPI_DUMP_COMMAND_LOG));
C_ASSERT (sizeof (ATAPI_DUMP_BMSTATUS) == sizeof (BMSTATUS));
C_ASSERT (ATAPI_DUMP_COMMAND_LOG_COUNT == MAX_COMMAND_LOG_ENTRIES);
C_ASSERT (ATAPI_DUMP_BMSTATUS_NO_ERROR == BMSTATUS_NO_ERROR);
C_ASSERT (ATAPI_DUMP_BMSTATUS_NOT_REACH_END_OF_TRANSFER == BMSTATUS_NOT_REACH_END_OF_TRANSFER);
C_ASSERT (ATAPI_DUMP_BMSTATUS_ERROR_TRANSFER == BMSTATUS_ERROR_TRANSFER);
C_ASSERT (ATAPI_DUMP_BMSTATUS_INTERRUPT == BMSTATUS_INTERRUPT);

#endif // ___crashdmp_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\chanfdo.c ===
/*++

Copyright (C) 1993-99  Microsoft Corporation

Module Name:

    chanfdo.c

Abstract:

--*/

#include "ideport.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ChannelAddDevice)
#pragma alloc_text(PAGE, ChannelAddChannel)
#pragma alloc_text(PAGE, ChannelStartDevice)
#pragma alloc_text(PAGE, ChannelStartChannel)
#pragma alloc_text(PAGE, ChannelCreateSymblicLinks)
#pragma alloc_text(PAGE, ChannelDeleteSymblicLinks)
#pragma alloc_text(PAGE, ChannelRemoveDevice)
#pragma alloc_text(PAGE, ChannelSurpriseRemoveDevice)
#pragma alloc_text(PAGE, ChannelStopDevice)
#pragma alloc_text(PAGE, ChannelRemoveChannel)
#pragma alloc_text(PAGE, ChannelQueryDeviceRelations)
#pragma alloc_text(PAGE, ChannelQueryBusRelation)
#pragma alloc_text(PAGE, ChannelQueryId)
#pragma alloc_text(PAGE, ChannelUsageNotification)
#pragma alloc_text(PAGE, DigestResourceList)
#pragma alloc_text(PAGE, ChannelQueryBusMasterInterface)
#pragma alloc_text(PAGE, ChannelQueryTransferModeInterface)
#pragma alloc_text(PAGE, ChannelUnbindBusMasterParent)
#pragma alloc_text(PAGE, ChannelQuerySyncAccessInterface)
#pragma alloc_text(PAGE, ChannelEnableInterrupt)
#pragma alloc_text(PAGE, ChannelDisableInterrupt)
#pragma alloc_text(PAGE, ChannelFilterResourceRequirements)
#pragma alloc_text(PAGE, ChannelQueryPnPDeviceState)
#pragma alloc_text(PAGE, ChannelQueryPcmciaParent)

#ifdef IDE_FILTER_PROMISE_TECH_RESOURCES
#pragma alloc_text(PAGE, ChannelFilterPromiseTechResourceRequirements)
#endif // IDE_FILTER_PROMISE_TECH_RESOURCES

#pragma alloc_text(NONPAGE, ChannelDeviceIoControl)
#pragma alloc_text(NONPAGE, ChannelRemoveDeviceCompletionRoutine)
#pragma alloc_text(NONPAGE, ChannelQueryIdCompletionRoutine)
#pragma alloc_text(NONPAGE, ChannelUsageNotificationCompletionRoutine)
#pragma alloc_text(NONPAGE, ChannelAcpiTransferModeSelect)
#pragma alloc_text(NONPAGE, ChannelRestoreTiming)
#pragma alloc_text(NONPAGE, ChannelStartDeviceCompletionRoutine)

#endif // ALLOC_PRAGMA


static ULONG AtapiNextIdePortNumber = 0;

NTSTATUS
ChannelAddDevice(
    IN  PDRIVER_OBJECT DriverObject,
    IN  PDEVICE_OBJECT PhysicalDeviceObject
    )
{
    PFDO_EXTENSION fdoExtension;

    return ChannelAddChannel(DriverObject,
                             PhysicalDeviceObject,
                             &fdoExtension);
}


NTSTATUS
ChannelAddChannel(
    IN  PDRIVER_OBJECT DriverObject,
    IN  PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PFDO_EXTENSION *FdoExtension
    )
{
    PDEVICE_OBJECT functionalDeviceObject;
    PFDO_EXTENSION fdoExtension;
    PPDO_EXTENSION pdoExtension;
    PDEVICE_OBJECT childDeviceObject;
    ULONG          deviceExtensionSize;
    NTSTATUS status;

    UNICODE_STRING  deviceName;
    WCHAR           deviceNameBuffer[64];

    PAGED_CODE();

    swprintf(deviceNameBuffer, DEVICE_OJBECT_BASE_NAME L"\\IdePort%d", AtapiNextIdePortNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);

    //
    // We've been given the PhysicalDeviceObject for a IDE controller.  Create the
    // FunctionalDeviceObject.  Our FDO will be nameless.
    //

    deviceExtensionSize = sizeof(FDO_EXTENSION) + sizeof(HW_DEVICE_EXTENSION);

    status = IoCreateDevice(
                 DriverObject,               // our driver object
                 deviceExtensionSize,        // size of our extension
                 &deviceName,                // our name
                 FILE_DEVICE_CONTROLLER,     // device type
                 FILE_DEVICE_SECURE_OPEN,    // device characteristics
                 FALSE,                      // not exclusive
                 &functionalDeviceObject     // store new device object here
                 );

    if( !NT_SUCCESS( status )){

        return status;
    }

    fdoExtension = (PFDO_EXTENSION)functionalDeviceObject->DeviceExtension;
    RtlZeroMemory (fdoExtension, deviceExtensionSize);


    fdoExtension->HwDeviceExtension = (PVOID)(fdoExtension + 1);

    //
    // We have our FunctionalDeviceObject, initialize it.
    //

    fdoExtension->AttacheePdo              = PhysicalDeviceObject;
    fdoExtension->DriverObject             = DriverObject;
    fdoExtension->DeviceObject             = functionalDeviceObject;

    // Dispatch Table
    fdoExtension->DefaultDispatch          = IdePortPassDownToNextDriver;
    fdoExtension->PnPDispatchTable         = FdoPnpDispatchTable;
    fdoExtension->PowerDispatchTable       = FdoPowerDispatchTable;
    fdoExtension->WmiDispatchTable         = FdoWmiDispatchTable;

    //
    // Now attach to the PDO we were given.
    //
    fdoExtension->AttacheeDeviceObject = IoAttachDeviceToDeviceStack (
                                              functionalDeviceObject,
                                              PhysicalDeviceObject
                                              );
    if (fdoExtension->AttacheeDeviceObject == NULL) {

        //
        // Couldn't attach.  Delete the FDO.
        //

        IoDeleteDevice (functionalDeviceObject);
        status = STATUS_UNSUCCESSFUL;

    } else {

        //
        // fix up alignment requirement
        //
        functionalDeviceObject->AlignmentRequirement = fdoExtension->AttacheeDeviceObject->AlignmentRequirement;
        if (functionalDeviceObject->AlignmentRequirement < 1) {
            functionalDeviceObject->AlignmentRequirement = 1;
        }

        fdoExtension->IdePortNumber = AtapiNextIdePortNumber;
        AtapiNextIdePortNumber++;

        *FdoExtension = fdoExtension;

        //
        // Add this to the global FDO list.
        //
        
        IdeAddToFdoList (&IdeGlobalFdoList, fdoExtension);

        CLRMASK (functionalDeviceObject->Flags, DO_DEVICE_INITIALIZING);
    }

    DebugPrint((DBG_PNP, "DeviceObject %x returnd status %x from Addevice\n", 
                PhysicalDeviceObject, status));

    return status;
}

NTSTATUS
ChannelStartDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION              thisIrpSp;
    NTSTATUS                        status;
    PFDO_EXTENSION                  fdoExtension;
    PCM_RESOURCE_LIST               resourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
    ULONG                           resourceListSize;
    ULONG                           i;
    PCM_RESOURCE_LIST               resourceListForKeep = NULL;
    PIRP                            newIrp;
    KEVENT                          event;
    IO_STATUS_BLOCK                 ioStatusBlock;

    ULONG                           parentResourceListSize;
    PCM_RESOURCE_LIST               parentResourceList = NULL;

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;

    ASSERT (!(fdoExtension->FdoState & FDOS_STARTED));

    resourceList     = thisIrpSp->Parameters.StartDevice.AllocatedResourcesTranslated;

    //
    // TEMP CODE for the time without a real PCI driver.
    //
    resourceListSize = 0;

    if (resourceList) {

        fullResourceList = resourceList->List;

        for (i=0; i<resourceList->Count; i++) {

            ULONG partialResourceListSize;

            partialResourceList = &(fullResourceList->PartialResourceList);
            partialDescriptors  = partialResourceList->PartialDescriptors;

            partialResourceListSize = 0;
            for (i=0; i<partialResourceList->Count; i++) {

                partialResourceListSize += sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

                if (partialDescriptors[i].Type == CmResourceTypeDeviceSpecific) {

                    partialResourceListSize += partialDescriptors[i].u.DeviceSpecificData.DataSize;
                }
            }

            resourceListSize += partialResourceListSize +
                                FIELD_OFFSET (CM_FULL_RESOURCE_DESCRIPTOR, PartialResourceList.PartialDescriptors);

            fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (((UCHAR *) fullResourceList) + resourceListSize);
        }
        resourceListSize += FIELD_OFFSET (CM_RESOURCE_LIST, List);
    }

    parentResourceListSize = sizeof (CM_RESOURCE_LIST) - sizeof (CM_FULL_RESOURCE_DESCRIPTOR) +
                             FULL_RESOURCE_LIST_SIZE(3);   // primary IO (2) + IRQ
    parentResourceList = ExAllocatePool (PagedPool, parentResourceListSize);

    if (!parentResourceList) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    RtlZeroMemory (parentResourceList, parentResourceListSize);

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    newIrp = IoBuildDeviceIoControlRequest (
                 IOCTL_IDE_GET_RESOURCES_ALLOCATED,
                 fdoExtension->AttacheeDeviceObject,
                 parentResourceList,
                 parentResourceListSize,
                 parentResourceList,
                 parentResourceListSize,
                 TRUE,
                 &event,
                 &ioStatusBlock);

    if (newIrp == NULL) {

        DebugPrint ((0, "Unable to allocate irp to bind with busmaster parent\n"));

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;

    } else {

        status = IoCallDriver(fdoExtension->AttacheeDeviceObject, newIrp);

        if (status == STATUS_PENDING) {

            status = KeWaitForSingleObject(&event,
                                           Executive,
                                           KernelMode,
                                           FALSE,
                                           NULL);

            status = ioStatusBlock.Status;
        }
    }

    if (!NT_SUCCESS(status)) {

        parentResourceListSize = 0;

    } else {

        parentResourceListSize = (ULONG)ioStatusBlock.Information;
    }

    if (resourceListSize + parentResourceListSize) {

        resourceListForKeep = ExAllocatePool (NonPagedPool, resourceListSize + parentResourceListSize);

    } else {

        resourceListForKeep = NULL;
    }

    if (resourceListForKeep) {

        PUCHAR d;

        resourceListForKeep->Count = 0;
        d = (PUCHAR) resourceListForKeep->List;

        if (resourceListSize) {

            RtlCopyMemory (
                d,
                resourceList->List,
                resourceListSize - FIELD_OFFSET (CM_RESOURCE_LIST, List)
                );

            resourceListForKeep->Count = resourceList->Count;
            d += resourceListSize - FIELD_OFFSET (CM_RESOURCE_LIST, List);
        }

        if (parentResourceListSize) {

            RtlCopyMemory (
                d,
                parentResourceList->List,
                parentResourceListSize - FIELD_OFFSET (CM_RESOURCE_LIST, List)
                );

            resourceListForKeep->Count += parentResourceList->Count;
        }
    } else {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    KeInitializeEvent(&event,
                      SynchronizationEvent,
                      FALSE);

    IoCopyCurrentIrpStackLocationToNext (Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS ;

    IoSetCompletionRoutine(
        Irp,
        ChannelStartDeviceCompletionRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Pass the irp along
    //
    status = IoCallDriver(fdoExtension->AttacheeDeviceObject, Irp);

    //
    // Wait for it to come back...
    //
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        //
        // Grab back the 'real' status
        //
        status = Irp->IoStatus.Status;
    }

    if (!NT_SUCCESS(status)) {

        ExFreePool (resourceListForKeep);
        goto GetOut;
    }


    status = ChannelStartChannel (fdoExtension,
                                  resourceListForKeep);

    if (!NT_SUCCESS(status)) {

        ExFreePool (resourceListForKeep);
        goto GetOut;
    }

GetOut:
    if (parentResourceList) {

        ExFreePool (parentResourceList);
        parentResourceList = NULL;
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;

}

NTSTATUS
ChannelStartDeviceCompletionRoutine(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN OUT PIRP            Irp,
    IN OUT PVOID           Context
    )
{
    PKEVENT event = (PKEVENT) Context;

    //
    // Signal the event
    //
    KeSetEvent( event, IO_NO_INCREMENT, FALSE );

    //
    // Always return MORE_PROCESSING_REQUIRED
    // will complete it later
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
ChannelStartChannel (
    PFDO_EXTENSION    FdoExtension,
    PCM_RESOURCE_LIST ResourceListToKeep
    )
{
    NTSTATUS                        status;
    PLOGICAL_UNIT_EXTENSION         logUnitExtension;
    IDE_PATH_ID                     pathId;
    POWER_STATE                     newState;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR irqPartialDescriptors;
    ULONG                           i;

#if DBG
    {
        PCM_RESOURCE_LIST               resourceList;
        PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
        PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
        ULONG                           resourceListSize;

        ULONG                           j;

        resourceList     = ResourceListToKeep;
        fullResourceList = resourceList->List;
        resourceListSize = 0;

        DebugPrint ((1, "IdePort: Starting device: FDOe\n", FdoExtension));

        for (i=0; i<resourceList->Count; i++) {
            partialResourceList = &(fullResourceList->PartialResourceList);
            partialDescriptors  = fullResourceList->PartialResourceList.PartialDescriptors;

            for (j=0; j<partialResourceList->Count; j++) {
                if (partialDescriptors[j].Type == CmResourceTypePort) {
                    DebugPrint ((1, "IdePort: IO Port = 0x%x. Lenght = 0x%x\n", partialDescriptors[j].u.Port.Start.LowPart, partialDescriptors[j].u.Port.Length));
                } else if (partialDescriptors[j].Type == CmResourceTypeInterrupt) {
                    DebugPrint ((1, "IdePort: Int Level = 0x%x. Int Vector = 0x%x\n", partialDescriptors[j].u.Interrupt.Level, partialDescriptors[j].u.Interrupt.Vector));
                } else {
                    DebugPrint ((1, "IdePort: Unknown resource\n"));
                }
            }
            fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + j);
        }

    }

#endif // DBG

    //
    // Analyze the resources we are getting
    //
    status = DigestResourceList (
                &FdoExtension->IdeResource,
                ResourceListToKeep,
                &irqPartialDescriptors
                );
    if (!NT_SUCCESS(status)) {

        goto GetOut;

    } else {

        PCONFIGURATION_INFORMATION configurationInformation;
        configurationInformation = IoGetConfigurationInformation();

        if (FdoExtension->IdeResource.AtdiskPrimaryClaimed) {
            FdoExtension->HwDeviceExtension->PrimaryAddress = TRUE;
            FdoExtension->HwDeviceExtension->SecondaryAddress = FALSE;
            configurationInformation->AtDiskPrimaryAddressClaimed = TRUE;
        }

        if (FdoExtension->IdeResource.AtdiskSecondaryClaimed) {
            FdoExtension->HwDeviceExtension->PrimaryAddress = FALSE;
            FdoExtension->HwDeviceExtension->SecondaryAddress = TRUE;
            configurationInformation->AtDiskSecondaryAddressClaimed = TRUE;
        }
    }

    //
    // Build io address structure.
    //
    AtapiBuildIoAddress(
            FdoExtension->IdeResource.TranslatedCommandBaseAddress,
            FdoExtension->IdeResource.TranslatedControlBaseAddress,
            &FdoExtension->HwDeviceExtension->BaseIoAddress1,
            &FdoExtension->HwDeviceExtension->BaseIoAddress2,
            &FdoExtension->HwDeviceExtension->BaseIoAddress1Length,
            &FdoExtension->HwDeviceExtension->BaseIoAddress2Length,
            &FdoExtension->HwDeviceExtension->MaxIdeDevice,
            &FdoExtension->HwDeviceExtension->MaxIdeTargetId);

    //
    // check for panasonic controller
    //
    FdoExtension->panasonicController = 
        IdePortIsThisAPanasonicPCMCIACard(FdoExtension);

    newState.DeviceState = PowerSystemWorking;
    status = IdePortIssueSetPowerState (
                 (PDEVICE_EXTENSION_HEADER) FdoExtension,
                 SystemPowerState,
                 newState,
                 TRUE                   // sync call
                 );
    if (status == STATUS_INVALID_DEVICE_REQUEST) {

        //
        // The DeviceObject Below us does not support power irp,
        // we will assume we are powered up
        //
        FdoExtension->SystemPowerState = PowerSystemWorking;

    } else if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

    newState.DeviceState = PowerDeviceD0;
    status = IdePortIssueSetPowerState (
                 (PDEVICE_EXTENSION_HEADER) FdoExtension,
                 DevicePowerState,
                 newState,
                 TRUE                   // sync call
                 );
    if (status == STATUS_INVALID_DEVICE_REQUEST) {

        //
        // The DeviceObject Below us does not support power irp,
        // we will assume we are powered up
        //
        FdoExtension->DevicePowerState = PowerDeviceD0;

    } else if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

    //
    // Initialize "miniport" data structure
    //
    FdoExtension->HwDeviceExtension->InterruptMode  = FdoExtension->IdeResource.InterruptMode;

#ifdef ENABLE_NATIVE_MODE
    //
    // Get parent's interrupt interface
    //
    ChannelQueryInterruptInterface (
        FdoExtension
        );

#endif
    //
    // Connect our interrupt
    //
    if (irqPartialDescriptors) {

        status = IoConnectInterrupt(&FdoExtension->InterruptObject,
                                    (PKSERVICE_ROUTINE) IdePortInterrupt,
                                    FdoExtension->DeviceObject,
                                    (PKSPIN_LOCK) NULL,
                                    irqPartialDescriptors->u.Interrupt.Vector,
                                    (KIRQL) irqPartialDescriptors->u.Interrupt.Level,
                                    (KIRQL) irqPartialDescriptors->u.Interrupt.Level,
                                    irqPartialDescriptors->Flags & CM_RESOURCE_INTERRUPT_LATCHED ? Latched : LevelSensitive,
                                    (BOOLEAN) (irqPartialDescriptors->ShareDisposition == CmResourceShareShared),
                                    irqPartialDescriptors->u.Interrupt.Affinity,
                                    FALSE);
    
        if (!NT_SUCCESS(status)) {
    
            DebugPrint((0, "IdePort: Can't connect interrupt %d\n", irqPartialDescriptors->u.Interrupt.Vector));
            FdoExtension->InterruptObject = NULL;
            goto GetOut;
        }
    

#ifdef ENABLE_NATIVE_MODE

        //
        // Disconnect the parent ISR stub
        //
        if ( FdoExtension->InterruptInterface.PciIdeInterruptControl) { 

            DebugPrint((1, "IdePort: %d fdoe 0x%x Invoking disconnect\n", 
                        irqPartialDescriptors->u.Interrupt.Vector, 
                        FdoExtension
                        ));

            status = FdoExtension->InterruptInterface.PciIdeInterruptControl (
                                                            FdoExtension->InterruptInterface.Context,
                                                            1
                                                            );
            ASSERT(NT_SUCCESS(status));
        }

#endif

        //
        // Enable Interrupt
        //
        ChannelEnableInterrupt (FdoExtension);
    }

    //
    // Get parent's access token to serialize access with siblings (broken pci-ide)
    //
    ChannelQuerySyncAccessInterface (
        FdoExtension
        );

    if (FdoExtension->FdoState & FDOS_STOPPED) {

        //
        // we are restarting, no need to do the rest of start code
        //
        status = STATUS_SUCCESS;
        goto GetOut;
    }
    
    //
    // Get parent's busmaster interface
    //
    ChannelQueryBusMasterInterface (
        FdoExtension
        );

    //
    // Maintain a default timing table
    //
    if (FdoExtension->DefaultTransferModeTimingTable == NULL) {

        ULONG length=0;
        PULONG transferModeTimingTable = ExAllocatePool(NonPagedPool, MAX_XFER_MODE*sizeof(ULONG));

        if (transferModeTimingTable != NULL) {
            SetDefaultTiming(transferModeTimingTable, length);
            FdoExtension->DefaultTransferModeTimingTable = transferModeTimingTable;
        } else {
            status = STATUS_INSUFFICIENT_RESOURCES;
            goto GetOut;
        }
    }
    ASSERT(FdoExtension->DefaultTransferModeTimingTable);

    //
    // get an interface that tells parent to invalidate out resource requirement
    //
    ChannelQueryRequestProperResourceInterface (
        FdoExtension
        );

    //
    // Create legacy object names
    //
    status = ChannelCreateSymblicLinks (
                 FdoExtension
                 );

    if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

    //
    // FDO Init Data
    //
    IdePortInitFdo (FdoExtension);

    //
    // Allocate reserve error log packets to log insufficient resource events
    //
    for (i=0;i<MAX_IDE_DEVICE;i++) {

        if (FdoExtension->ReserveAllocFailureLogEntry[i] == NULL) {
            FdoExtension->ReserveAllocFailureLogEntry[i] = IoAllocateErrorLogEntry(
                                                            FdoExtension->DeviceObject,
                                                            ALLOC_FAILURE_LOGSIZE
                                                            );
        }
    }

    //
    // Pre-allocate memory for enumeration
    //
    if (!IdePreAllocEnumStructs(FdoExtension)) {
        status=STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    
    //
    // Reserve pages to perform I/O under low memory conditions
    //
    if (FdoExtension->ReservedPages == NULL) {

        FdoExtension->ReservedPages = MmAllocateMappingAddress( IDE_NUM_RESERVED_PAGES * PAGE_SIZE,
                                                                'PedI'
                                                                );

        ASSERT(FdoExtension->ReservedPages);
            
    }

GetOut:
    if (NT_SUCCESS(status)) {

        //
        // End of Init.
        //
        CLRMASK (FdoExtension->FdoState, FDOS_STOPPED);
        SETMASK (FdoExtension->FdoState, FDOS_STARTED);

        if (FdoExtension->ResourceList) {
            ExFreePool(FdoExtension->ResourceList);
            FdoExtension->ResourceList = NULL;
        }
        FdoExtension->ResourceList = ResourceListToKeep;

    } else {

        ChannelRemoveChannel (FdoExtension);
    }

    return status;
}

NTSTATUS
ChannelCreateSymblicLinks (
    PFDO_EXTENSION FdoExtension
    )
{
    NTSTATUS            status;
    ULONG               i = 0;
    PULONG              scsiportNumber;

    UNICODE_STRING      deviceName;
    WCHAR               deviceNameBuffer[64];

    UNICODE_STRING      symbolicDeviceName;
    WCHAR               symbolicDeviceNameBuffer[64];

    swprintf(deviceNameBuffer, DEVICE_OJBECT_BASE_NAME L"\\IdePort%d", FdoExtension->IdePortNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);

    scsiportNumber = &IoGetConfigurationInformation()->ScsiPortCount;

    do {
        swprintf(symbolicDeviceNameBuffer, L"\\Device\\ScsiPort%d", i);
        RtlInitUnicodeString(&symbolicDeviceName, symbolicDeviceNameBuffer);

        status = IoCreateSymbolicLink(
                     &symbolicDeviceName,
                     &deviceName
                     );

        if (NT_SUCCESS (status)) {

            swprintf(symbolicDeviceNameBuffer, L"\\DosDevices\\Scsi%d:", i);
            RtlInitUnicodeString(&symbolicDeviceName, symbolicDeviceNameBuffer);

            IoAssignArcName (
                &symbolicDeviceName,
                &deviceName
                );

            break;
        }
        i += 1;
    } while(i <= *scsiportNumber);


    if (NT_SUCCESS(status)) {

        FdoExtension->SymbolicLinkCreated = TRUE;
        FdoExtension->ScsiPortNumber = i;
        (*scsiportNumber)++;
    }

    return status;
}

NTSTATUS
ChannelDeleteSymblicLinks (
    PFDO_EXTENSION FdoExtension
    )
{
    NTSTATUS            status;
    ULONG               i;

    UNICODE_STRING      deviceName;
    WCHAR               deviceNameBuffer[64];

    if (!FdoExtension->SymbolicLinkCreated) {

        return STATUS_SUCCESS;
    }

    swprintf(deviceNameBuffer, L"\\Device\\ScsiPort%d", FdoExtension->ScsiPortNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);

    IoDeleteSymbolicLink(
        &deviceName
        ); 

    swprintf(deviceNameBuffer, L"\\DosDevices\\Scsi%d:", FdoExtension->ScsiPortNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);

    IoDeassignArcName(&deviceName);

    FdoExtension->SymbolicLinkCreated = FALSE;

    IoGetConfigurationInformation()->ScsiPortCount--;

    return STATUS_SUCCESS;
}


NTSTATUS
ChannelSurpriseRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PFDO_EXTENSION fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;
    PPDO_EXTENSION pdoExtension;
    IDE_PATH_ID pathId;
    NTSTATUS status;

    //
    // all my childred should be surprise removed or removed
    //
    pathId.l = 0;
    while (pdoExtension = NextLogUnitExtensionWithTag (
                              fdoExtension, 
                              &pathId, 
                              TRUE,
                              ChannelSurpriseRemoveDevice
                              )) {

        //ASSERT (pdoExtension->PdoState & (PDOS_SURPRISE_REMOVED | PDOS_REMOVED));

        CLRMASK (pdoExtension->PdoState, PDOS_REPORTED_TO_PNP); 

        UnrefPdoWithTag(
            pdoExtension, 
            ChannelSurpriseRemoveDevice
            );
    }

    status = ChannelRemoveChannel (fdoExtension);
    ASSERT (NT_SUCCESS(status));

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoSkipCurrentIrpStackLocation (Irp);
    return IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
}


NTSTATUS
ChannelRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PFDO_EXTENSION  fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;
    PPDO_EXTENSION  pdoExtension;
    NTSTATUS        status;
    KEVENT          event;

    IDE_PATH_ID     pathId;

    DebugPrint ((
        DBG_PNP,
        "fdoe 0x%x 0x%x got a STOP device\n",
        fdoExtension,
        fdoExtension->IdeResource.TranslatedCommandBaseAddress
        ));


    //
    // Remove from the FDO list.
    //

    IdeRemoveFromFdoList (&IdeGlobalFdoList, fdoExtension);

    //
    // Kill all the children if any
    //
    pathId.l = 0;
    while (pdoExtension = NextLogUnitExtensionWithTag (
                              fdoExtension, 
                              &pathId, 
                              TRUE,
                              ChannelRemoveDevice
                              )) {

        if (pdoExtension->PdoState & PDOS_SURPRISE_REMOVED) {

            CLRMASK (pdoExtension->PdoState, PDOS_REPORTED_TO_PNP);
            continue;
        }

        FreePdoWithTag(
            pdoExtension, 
            TRUE,
            TRUE,
            ChannelRemoveDevice
            );
    }

    status = ChannelRemoveChannel (fdoExtension);
    ASSERT (NT_SUCCESS(status));

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext (Irp);

    IoSetCompletionRoutine(
        Irp,
        ChannelRemoveDeviceCompletionRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE
        );

    status = IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);

    KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);

    IoDetachDevice (fdoExtension->AttacheeDeviceObject);

    IoDeleteDevice (DeviceObject);

    //return STATUS_SUCCESS;
    return status;
}


NTSTATUS
ChannelRemoveDeviceCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
{
    PKEVENT event = Context;

    KeSetEvent(event, 0, FALSE);

    return STATUS_SUCCESS;
}

NTSTATUS
ChannelStopDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PFDO_EXTENSION fdoExtension;

    fdoExtension = DeviceObject->DeviceExtension;

    DebugPrint ((
        DBG_PNP,
        "fdoe 0x%x 0x%x got a STOP device\n",
        fdoExtension,
        fdoExtension->IdeResource.TranslatedCommandBaseAddress
        ));

    //
    // disable interrupt
    //
    ChannelDisableInterrupt (fdoExtension);

    if (fdoExtension->InterruptObject) {

#ifdef ENABLE_NATIVE_MODE

        //
        // Reconnect the parent ISR stub
        //
        if (fdoExtension->InterruptInterface.PciIdeInterruptControl) { 

            NTSTATUS status;

            DebugPrint((1, "fdoe 0x%x invoking reconnect\n", fdoExtension));

            status = fdoExtension->InterruptInterface.PciIdeInterruptControl (
                                                            fdoExtension->InterruptInterface.Context,
                                                            0
                                                            );
            ASSERT(NT_SUCCESS(status));
        }

#endif
        
        IoDisconnectInterrupt (
            fdoExtension->InterruptObject
            );

        fdoExtension->InterruptObject = 0;

    }

    if (fdoExtension->FdoState & FDOS_STARTED) {

        //
        // indicate we have been stopped only if we have started
        //
        CLRMASK (fdoExtension->FdoState, FDOS_STARTED);
        SETMASK (fdoExtension->FdoState, FDOS_STOPPED);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoSkipCurrentIrpStackLocation (Irp);
    return IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
}

NTSTATUS
ChannelRemoveChannel (
    PFDO_EXTENSION    FdoExtension
    )
{
    PCONFIGURATION_INFORMATION configurationInformation;
    ULONG i;

    configurationInformation = IoGetConfigurationInformation();
    
    DebugPrint((1, "ChannelRemoveChannel for FDOe %x\n", FdoExtension));

    if (FdoExtension->IdeResource.AtdiskPrimaryClaimed) {
        configurationInformation->AtDiskPrimaryAddressClaimed = FALSE;
    }

    if (FdoExtension->IdeResource.AtdiskSecondaryClaimed) {
        configurationInformation->AtDiskSecondaryAddressClaimed = FALSE;
    }
    FdoExtension->IdeResource.AtdiskPrimaryClaimed   = FALSE;
    FdoExtension->IdeResource.AtdiskSecondaryClaimed = FALSE;
    FdoExtension->HwDeviceExtension->PrimaryAddress  = FALSE;

    if ((FdoExtension->IdeResource.CommandBaseAddressSpace == MEMORY_SPACE) &&
        (FdoExtension->IdeResource.TranslatedCommandBaseAddress)) {

        MmUnmapIoSpace (
            FdoExtension->IdeResource.TranslatedCommandBaseAddress,
            FdoExtension->HwDeviceExtension->BaseIoAddress1Length
            );
    }
    FdoExtension->IdeResource.TranslatedCommandBaseAddress = 0;

    if ((FdoExtension->IdeResource.ControlBaseAddressSpace == MEMORY_SPACE) &&
        (FdoExtension->IdeResource.TranslatedControlBaseAddress)) {

        MmUnmapIoSpace (
            FdoExtension->IdeResource.TranslatedControlBaseAddress,
            1
            );
    }
    FdoExtension->IdeResource.TranslatedControlBaseAddress = 0;

    if (FdoExtension->InterruptObject) {

#ifdef ENABLE_NATIVE_MODE

        //
        // Reconnect the parent ISR stub
        //
        if (FdoExtension->InterruptInterface.PciIdeInterruptControl) { 

            NTSTATUS status;

            DebugPrint((1, "fdoe 0x%x invoking reconnect\n", FdoExtension));

            status = FdoExtension->InterruptInterface.PciIdeInterruptControl (
                                                            FdoExtension->InterruptInterface.Context,
                                                            0
                                                            );
            ASSERT(NT_SUCCESS(status));
        }

#endif

        IoDisconnectInterrupt (
            FdoExtension->InterruptObject
            );

        FdoExtension->InterruptObject = 0;
    }

    // unbind from the bm stuff if NECESSARY
    // release parent's access token to serialize access with siblings (broken pci-ide)

    if (FdoExtension->ResourceList) {

        ExFreePool (FdoExtension->ResourceList);
        FdoExtension->ResourceList = NULL;

    }
    else {
        DebugPrint((1, "ATAPI: Resource list for FDOe %x already freed\n",
                            FdoExtension));
    }

    //
    // Lock
    //
    ASSERT(InterlockedCompareExchange(&(FdoExtension->EnumStructLock), 1, 0) == 0);

    //
    // Free pre-allocated memory
    //
    IdeFreeEnumStructs(FdoExtension->PreAllocEnumStruct);

    FdoExtension->PreAllocEnumStruct = NULL;

    //
    // Unlock
    //
    ASSERT(InterlockedCompareExchange(&(FdoExtension->EnumStructLock), 0, 1) == 1);

    //
    // Free the reserve error log entries
    //
    for (i=0; i< MAX_IDE_DEVICE; i++) {
        PVOID entry;
        PVOID currentValue;

        entry = FdoExtension->ReserveAllocFailureLogEntry[i];

        if (entry == NULL) {
            continue;
        }
        //
        // We have to ensure that we are the only instance to use this
        // event.  To do so, we attempt to NULL the event in the driver
        // extension.  If somebody else beats us to it, they own the
        // event and we have to give up.
        //

        currentValue = InterlockedCompareExchangePointer(
                            &(FdoExtension->ReserveAllocFailureLogEntry[i]),
                            NULL,
                            entry
                            );

        if (entry != currentValue) {
            continue;
        }

        // Note that you cannot ExFreePool the entry
        // because Io returns an offset into the pool allocation, not the start.
        // Use the API provided by Iomanager
        IoFreeErrorLogEntry(entry);
    }

    //
    // Free the default timing table
    //
    if (FdoExtension->DefaultTransferModeTimingTable) {

        ExFreePool(FdoExtension->DefaultTransferModeTimingTable);

        FdoExtension->DefaultTransferModeTimingTable = NULL;
        FdoExtension->TransferModeInterface.TransferModeTimingTable = NULL;
        FdoExtension->TransferModeInterface.TransferModeTableLength =0;
    }

    //
    // Unmap the reserved mapping
    //
    if (FdoExtension->ReservedPages != NULL) {

        MmFreeMappingAddress(FdoExtension->ReservedPages,
                             'PedI'
                             );
        FdoExtension->ReservedPages = NULL;
    }

    ChannelDeleteSymblicLinks (
        FdoExtension
        );

    return STATUS_SUCCESS;
}

NTSTATUS
ChannelQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PFDO_EXTENSION      fdoExtension = DeviceObject->DeviceExtension;
    PIO_STACK_LOCATION  thisIrpSp;
    PIDE_WORK_ITEM_CONTEXT workItemContext;
    PENUMERATION_STRUCT enumStruct = fdoExtension->PreAllocEnumStruct;

    if (!(fdoExtension->FdoState & FDOS_STARTED)) {

        Irp->IoStatus.Status = STATUS_DEVICE_NOT_READY;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_DEVICE_NOT_READY;
    }

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

    switch (thisIrpSp->Parameters.QueryDeviceRelations.Type) {
    case BusRelations:

        DebugPrint ((DBG_BUSSCAN, "IdeQueryDeviceRelations: bus relations\n"));

        ASSERT(enumStruct);
        workItemContext = (PIDE_WORK_ITEM_CONTEXT) enumStruct->EnumWorkItemContext;
        ASSERT(workItemContext);
        ASSERT(workItemContext->WorkItem);

        workItemContext->Irp = Irp;

#ifdef SYNC_DEVICE_RELATIONS

        return ChannelQueryBusRelation (
                  DeviceObject,
                  workItemContext);

#else 
        Irp->IoStatus.Status = STATUS_PENDING;
        IoMarkIrpPending(Irp);

        IoQueueWorkItem(
             workItemContext->WorkItem,
             ChannelQueryBusRelation,
             DelayedWorkQueue,
             workItemContext
             );

        return STATUS_PENDING;
#endif //!SYNC_DEVICE_RELATIONS
        break;

        default:
        DebugPrint ((1, "IdeQueryDeviceRelations: Unsupported device relation\n"));

        //
        // Don't set the status if it is not success and is being passed 
        // down
        //

        //Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        break;
    }

    IoSkipCurrentIrpStackLocation (Irp);
    return IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
}

NTSTATUS
ChannelQueryBusRelation (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIDE_WORK_ITEM_CONTEXT WorkItemContext
    )
{

    PIRP irp;
    PFDO_EXTENSION      fdoExtension;
    PIO_STACK_LOCATION  thisIrpSp;
    PDEVICE_RELATIONS   deviceRelations;
    LARGE_INTEGER       tickCount;
    ULONG               timeDiff;

    irp = WorkItemContext->Irp;

    //
    // do not release resource for this worker item as they are pre-alloced
    //
   // IoFreeWorkItem(WorkItemContext->WorkItem);
    //ExFreePool (WorkItemContext);

    thisIrpSp = IoGetCurrentIrpStackLocation(irp);
    fdoExtension = thisIrpSp->DeviceObject->DeviceExtension;

    LogBusScanStartTimer(&tickCount);

    //
    // grab the acpi/bios timing settings if any
    // GTM should be called for every enumeration
    //
    DeviceQueryChannelTimingSettings (
        fdoExtension,
        &fdoExtension->AcpiTimingSettings
        );

    //
    // Get parent's xfer mode interface
    //
    ChannelQueryTransferModeInterface (
        fdoExtension
        );

    //
    // scan the bus
    //
    IdePortScanBus (fdoExtension);

    timeDiff = LogBusScanStopTimer(&tickCount);
    LogBusScanTimeDiff(fdoExtension, L"IdeTotalBusScanTime", timeDiff);

#ifdef IDE_MEASURE_BUSSCAN_SPEED
        if (timeDiff > 7000) {

            DebugPrint ((DBG_WARNING, "WARNING: **************************************\n"));
            DebugPrint ((DBG_WARNING, "WARNING: IdePortScanBus 0x%x took %u millisec\n", fdoExtension->IdeResource.TranslatedCommandBaseAddress, timeDiff));
            DebugPrint ((DBG_WARNING, "WARNING: **************************************\n"));

        } else {

            DebugPrint ((DBG_BUSSCAN, "IdePortScanBus 0x%x took %u millisec\n", fdoExtension->IdeResource.TranslatedCommandBaseAddress, timeDiff));
        }
#endif

    deviceRelations = ChannelBuildDeviceRelationList (
                          fdoExtension
                          );

    irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
    irp->IoStatus.Status = STATUS_SUCCESS;

    IoSkipCurrentIrpStackLocation (irp);
    return IoCallDriver (fdoExtension->AttacheeDeviceObject, irp);
}


PDEVICE_RELATIONS
ChannelBuildDeviceRelationList (
    PFDO_EXTENSION FdoExtension
    )
{
    IDE_PATH_ID         pathId;
    ULONG               numPdoChildren;
    NTSTATUS            status;
    PPDO_EXTENSION      pdoExtension;
    ULONG               deviceRelationsSize;
    PDEVICE_RELATIONS   deviceRelations;

    status = STATUS_SUCCESS;

    pathId.l = 0;
    numPdoChildren = 0;
    while (pdoExtension = NextLogUnitExtensionWithTag(
                              FdoExtension,
                              &pathId,
                              TRUE,
                              ChannelBuildDeviceRelationList
                              )) {

        UnrefLogicalUnitExtensionWithTag (
            FdoExtension, 
            pdoExtension,
            ChannelBuildDeviceRelationList
            );
        numPdoChildren++;
    }

    if (numPdoChildren) {
        deviceRelationsSize = FIELD_OFFSET (DEVICE_RELATIONS, Objects) +
                              numPdoChildren * sizeof(PDEVICE_OBJECT);
    } else {
        // Current build expect a DEVICE_RELATIONS with a Count of 0
        // if we don't have any PDO to return

        deviceRelationsSize = FIELD_OFFSET( DEVICE_RELATIONS, Objects ) +
                              1 * sizeof( PDEVICE_OBJECT );
    }

    deviceRelations = ExAllocatePool (NonPagedPool, deviceRelationsSize);

    if(!deviceRelations) {
        DebugPrint ((DBG_ALWAYS, "ChannelBuildDeviceRelationList: Unable to allocate DeviceRelations structures\n"));
        status = STATUS_NO_MEMORY;

    }

    if (NT_SUCCESS(status)) {

        (deviceRelations)->Count = 0;

        pathId.l = 0;
        while ((deviceRelations->Count < numPdoChildren) &&
               (pdoExtension = NextLogUnitExtensionWithTag(
                                   FdoExtension, 
                                   &pathId, 
                                   TRUE,
                                   ChannelBuildDeviceRelationList
                                   ))) {

            KIRQL currentIrql;
            BOOLEAN deadMeat;

            KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);
            deadMeat = pdoExtension->PdoState & PDOS_DEADMEAT ? TRUE : FALSE;
            KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

            if (!deadMeat) {

                KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);
                SETMASK (pdoExtension->PdoState, PDOS_REPORTED_TO_PNP);
                KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

                deviceRelations->Objects[deviceRelations->Count] = pdoExtension->DeviceObject;
                ObReferenceObjectByPointer(deviceRelations->Objects[deviceRelations->Count],
                                           0,
                                           0,
                                           KernelMode);
                deviceRelations->Count++;

            } else {

                KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);
                CLRMASK (pdoExtension->PdoState, PDOS_REPORTED_TO_PNP);
                KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

                DebugPrint ((DBG_BUSSCAN, "0x%x target 0x%x pdoExtension 0x%x is marked DEADMEAT\n",
                             pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                             pdoExtension->TargetId,
                             pdoExtension));
            }

            UnrefLogicalUnitExtensionWithTag (
                FdoExtension, 
                pdoExtension,
                ChannelBuildDeviceRelationList
                );
        }

        DebugPrint ((DBG_BUSSCAN, "ChannelBuildDeviceRelationList: returning %d children\n", deviceRelations->Count));
    }


    return deviceRelations;
}

NTSTATUS
ChannelQueryId (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  thisIrpSp;
    PFDO_EXTENSION      fdoExtension;
    NTSTATUS            status;
    PWCHAR              returnString;
    ANSI_STRING         ansiString;
    UNICODE_STRING      unicodeString;

    PAGED_CODE();

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;


    if (!(fdoExtension->FdoState & FDOS_STARTED)) {

        Irp->IoStatus.Status = STATUS_DEVICE_NOT_READY;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_DEVICE_NOT_READY;
    }

    unicodeString.Buffer = NULL;
    switch (thisIrpSp->Parameters.QueryId.IdType) {

        case BusQueryCompatibleIDs:
        case BusQueryHardwareIDs:

            unicodeString.Length        = 0;
            unicodeString.MaximumLength = 50 * sizeof(WCHAR);
            unicodeString.Buffer = ExAllocatePool(PagedPool, unicodeString.MaximumLength);

            //
            // Caller wants the unique id of the device
            //
            RtlInitAnsiString (
                &ansiString,
                "*PNP0600"
                );
            break;

        default:
            break;
    }

    if (unicodeString.Buffer) {

        RtlAnsiStringToUnicodeString(
            &unicodeString,
            &ansiString,
            FALSE
            );

        //
        // double null terminate it
        //
        unicodeString.Buffer[unicodeString.Length/sizeof(WCHAR) + 0] = L'\0';
        unicodeString.Buffer[unicodeString.Length/sizeof(WCHAR) + 1] = L'\0';

        IoMarkIrpPending(Irp);

        //
        // we need to check if the lower driver handles this irp
        // registry a completion routine.  we can check
        // when the irp comes back
        //
        IoCopyCurrentIrpStackLocationToNext (Irp);

        IoSetCompletionRoutine(
            Irp,
            ChannelQueryIdCompletionRoutine,
            unicodeString.Buffer,
            TRUE,
            TRUE,
            TRUE
            );

    } else {

        //
        // we don't care much about this irp
        //
        IoSkipCurrentIrpStackLocation (Irp);
    }

    status = IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);

    if (unicodeString.Buffer) {

        return STATUS_PENDING;

    } else {

        return status;
    }
}

NTSTATUS
ChannelQueryIdCompletionRoutine (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )
{
    if (Irp->IoStatus.Status == STATUS_NOT_SUPPORTED) {

        //
        // the lower level driver didn't handle the irp
        // return the device text string we created early
        //
        Irp->IoStatus.Information = (ULONG_PTR) Context;
        Irp->IoStatus.Status = STATUS_SUCCESS;
    } else {

        //
        // the lower driver handled the irp,
        // we don't need to return our device text string
        //
        ExFreePool (Context);
    }

    return Irp->IoStatus.Status;
}

NTSTATUS
ChannelUsageNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PFDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpSp;
    PULONG deviceUsageCount;

    ASSERT (DeviceObject);
    ASSERT (Irp);

    fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT (fdoExtension);

    if (!(fdoExtension->FdoState & FDOS_STARTED)) {

        Irp->IoStatus.Status = STATUS_DEVICE_NOT_READY;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return STATUS_DEVICE_NOT_READY;
    }

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging) {

        //
        // Adjust the paging path count for this device.
        //
        deviceUsageCount = &fdoExtension->PagingPathCount;

    } else if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeHibernation) {

        //
        // Adjust the paging path count for this device.
        //
        deviceUsageCount = &fdoExtension->HiberPathCount;

    } else if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeDumpFile) {

        //
        // Adjust the paging path count for this device.
        //
        deviceUsageCount = &fdoExtension->CrashDumpPathCount;

    } else {

        deviceUsageCount = NULL;
        DebugPrint ((DBG_ALWAYS,
                     "ATAPI: Unknown IRP_MN_DEVICE_USAGE_NOTIFICATION type: 0x%x\n",
                     irpSp->Parameters.UsageNotification.Type));
    }

    IoCopyCurrentIrpStackLocationToNext (Irp);

    IoSetCompletionRoutine (
        Irp,
        ChannelUsageNotificationCompletionRoutine,
        deviceUsageCount,
        TRUE,
        TRUE,
        TRUE);

    ASSERT(fdoExtension->AttacheeDeviceObject);
    return IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);

} // ChannelPagingNotification

NTSTATUS
ChannelUsageNotificationCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PFDO_EXTENSION fdoExtension;
    PULONG deviceUsageCount = Context;

    fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT (fdoExtension);

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        if (deviceUsageCount) {

            IoAdjustPagingPathCount (
                deviceUsageCount,
                IoGetCurrentIrpStackLocation(Irp)->Parameters.UsageNotification.InPath
                );
        }
    }

    return Irp->IoStatus.Status;
}



NTSTATUS
ChannelDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION thisIrpSp = IoGetCurrentIrpStackLocation(Irp);
    PFDO_EXTENSION fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;
    PSTORAGE_PROPERTY_QUERY storageQuery;
    STORAGE_ADAPTER_DESCRIPTOR adapterDescriptor;
    ULONG outBufferSize;
    NTSTATUS status;

    // pass it down if not supported and it is for the FDO stack

    switch (thisIrpSp->Parameters.DeviceIoControl.IoControlCode) {
        case IOCTL_STORAGE_QUERY_PROPERTY:

            storageQuery = Irp->AssociatedIrp.SystemBuffer;

            if (thisIrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(STORAGE_PROPERTY_QUERY)) {

                Irp->IoStatus.Status = STATUS_INVALID_PARAMETER;

            } else {

                if (storageQuery->PropertyId == StorageAdapterProperty) { // device property

                    switch (storageQuery->QueryType) {
                        case PropertyStandardQuery:
                            DebugPrint ((1, "IdePortPdoDispatch: IOCTL_STORAGE_QUERY_PROPERTY PropertyStandardQuery\n"));

                            RtlZeroMemory (&adapterDescriptor, sizeof(adapterDescriptor));

                            //
                            // BuildAtaDeviceDescriptor
                            //
                            adapterDescriptor.Version                = sizeof (STORAGE_ADAPTER_DESCRIPTOR);
                            adapterDescriptor.Size                   = sizeof (STORAGE_ADAPTER_DESCRIPTOR);
                            adapterDescriptor.MaximumTransferLength  = MAX_TRANSFER_SIZE_PER_SRB;
                            adapterDescriptor.MaximumPhysicalPages   = SP_UNINITIALIZED_VALUE;   
                            adapterDescriptor.AlignmentMask          = DeviceObject->AlignmentRequirement;
                            adapterDescriptor.AdapterUsesPio         = TRUE;         // We always support PIO
                            adapterDescriptor.AdapterScansDown       = FALSE;
                            adapterDescriptor.CommandQueueing        = FALSE;
                            adapterDescriptor.AcceleratedTransfer    = FALSE;
                            adapterDescriptor.BusType                = BusTypeAta;   // Bus type should be ATA
                            adapterDescriptor.BusMajorVersion        = 1;            // Major version
                            adapterDescriptor.BusMinorVersion        = 0;            // 

                            if (thisIrpSp->Parameters.DeviceIoControl.OutputBufferLength <
                                sizeof(STORAGE_ADAPTER_DESCRIPTOR)) {

                                outBufferSize = thisIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                            } else {

                                outBufferSize = sizeof(STORAGE_ADAPTER_DESCRIPTOR);
                            }

                            RtlCopyMemory (Irp->AssociatedIrp.SystemBuffer,
                                           &adapterDescriptor,
                                           outBufferSize);
                            Irp->IoStatus.Information = outBufferSize;
                            Irp->IoStatus.Status = STATUS_SUCCESS;
                            break;

                        case PropertyExistsQuery:
                            DebugPrint ((1, "IdePortPdoDispatch: IOCTL_STORAGE_QUERY_PROPERTY PropertyExistsQuery\n"));
                            Irp->IoStatus.Status = STATUS_SUCCESS;
                            break;

                        case PropertyMaskQuery:
                            DebugPrint ((1, "IdePortPdoDispatch: IOCTL_STORAGE_QUERY_PROPERTY PropertyMaskQuery\n"));
                            Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
                            break;

                        default:
                            DebugPrint ((1, "IdePortPdoDispatch: IOCTL_STORAGE_QUERY_PROPERTY unknown type\n"));
                            Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
                            break;
                    }
                }
            }
            break;

        default:

            //
            // we don't know what this deviceIoControl Irp is
            //
            if (thisIrpSp->DeviceObject == DeviceObject) {

                //
                // this irp could come from the PDO stack
                //
                // forward this unknown request if and only
                // if this irp is for the FDO stack
                //
                IoSkipCurrentIrpStackLocation (Irp);
                return IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
                break;
            }
            Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
            break;

    }

    status = Irp->IoStatus.Status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

VOID
ChannelQueryBusMasterInterface (
    PFDO_EXTENSION    FdoExtension
    )
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS          status;


    FdoExtension->BoundWithBmParent = FALSE;

    RtlZeroMemory (&irpSp, sizeof(irpSp));

    irpSp.Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_PCIIDE_BUSMASTER_INTERFACE;
    irpSp.Parameters.QueryInterface.Version = 1;
    irpSp.Parameters.QueryInterface.Size = sizeof (FdoExtension->HwDeviceExtension->BusMasterInterface);
    irpSp.Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->HwDeviceExtension->BusMasterInterface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;

    status = IdePortSyncSendIrp (FdoExtension->AttacheeDeviceObject, &irpSp, NULL);
    if (NT_SUCCESS(status)) {
        FdoExtension->BoundWithBmParent = TRUE;
    }
    return;
}

#ifdef ENABLE_NATIVE_MODE
VOID
ChannelQueryInterruptInterface (
    PFDO_EXTENSION    FdoExtension
    )
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS          status;


    RtlZeroMemory (&irpSp, sizeof(irpSp));

    irpSp.Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_PCIIDE_INTERRUPT_INTERFACE;
    irpSp.Parameters.QueryInterface.Version = 1;
    irpSp.Parameters.QueryInterface.Size = sizeof (FdoExtension->InterruptInterface);
    irpSp.Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->InterruptInterface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;

    DebugPrint((1, "Querying interrupt interface for Fdoe 0x%x\n", FdoExtension));

    status = IdePortSyncSendIrp (FdoExtension->AttacheeDeviceObject, &irpSp, NULL);

    return;
}
#endif

VOID
ChannelQueryTransferModeInterface (
    PFDO_EXTENSION    FdoExtension
    )
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS          status;
    ULONG i;

    PAGED_CODE();

    RtlZeroMemory (&irpSp, sizeof(irpSp));

    irpSp.Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_PCIIDE_XFER_MODE_INTERFACE;
    irpSp.Parameters.QueryInterface.Version = 1;
    irpSp.Parameters.QueryInterface.Size = sizeof (FdoExtension->TransferModeInterface);
    irpSp.Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->TransferModeInterface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;

    status = IdePortSyncSendIrp (FdoExtension->AttacheeDeviceObject, &irpSp, NULL);
    
    if (NT_SUCCESS(status)) {
    
        if (FdoExtension->TransferModeInterface.SupportLevel 
                != PciIdeFullXferModeSupport) {

            //
            // We got the sfer mode interface from our parent,
            // but it has only the basic functionality.  It
            // just relies on the BIOS to program its timing
            // registers during POST.  It doesn't really know 
            // how to program its timing registers.
            //      
            for (i=0; i<MAX_IDE_DEVICE; i++) {
    
                if (FdoExtension->AcpiTimingSettings.Speed[i].Pio != ACPI_XFER_MODE_NOT_SUPPORT) {
                
                    //
                    // looks like ACPI is present and it knows how to program
                    // ide timing registers.  Let's forget our parent xfer mode
                    // interface and go with the ACPI xfer mode interface
                    //
                    status = STATUS_UNSUCCESSFUL;                
                }
            }
        }

        ASSERT (FdoExtension->TransferModeInterface.TransferModeTimingTable);
    }
    
#ifdef ALWAYS_USE_APCI_IF_AVAILABLE
    for (i=0; i<MAX_IDE_DEVICE; i++) {

        if (FdoExtension->AcpiTimingSettings.Speed[i].Pio != ACPI_XFER_MODE_NOT_SUPPORT) {
        
            status = STATUS_UNSUCCESSFUL;                
        }
    }
#endif // ALWAYS_USE_APCI_IF_AVAILABLE

    if (!NT_SUCCESS(status)) {

        PULONG transferModeTimingTable = FdoExtension->TransferModeInterface.TransferModeTimingTable;
        //
        // if we can't get the TransferModeInterface,
        // we will default to the ACPI TransferModeInterface
        //
        if ((FdoExtension->AcpiTimingSettings.Speed[0].Pio != ACPI_XFER_MODE_NOT_SUPPORT) ||
            (FdoExtension->AcpiTimingSettings.Speed[1].Pio != ACPI_XFER_MODE_NOT_SUPPORT)) {

            FdoExtension->TransferModeInterface.SupportLevel = PciIdeFullXferModeSupport;

        } else {

            FdoExtension->TransferModeInterface.SupportLevel = PciIdeBasicXferModeSupport;
        }
        FdoExtension->TransferModeInterface.Context = FdoExtension;
        FdoExtension->TransferModeInterface.TransferModeSelect = ChannelAcpiTransferModeSelect;

        //
        // Fill up the timingTable with the default cycle times.
        //
        if (transferModeTimingTable == NULL) {
            FdoExtension->TransferModeInterface.TransferModeTimingTable = FdoExtension->
                                                                            DefaultTransferModeTimingTable;
            FdoExtension->TransferModeInterface.TransferModeTableLength = MAX_XFER_MODE;
        }
    }

    if (FdoExtension->TransferModeInterface.SupportLevel == 
        PciIdeBasicXferModeSupport) {

        //
        // we don't really have code to set the correct
        // xfer mode timing on the controller.  
        // our TransferModeInterface is really picking
        // whatever mode set by the bios.  and since there
        // is no way to figure what the current PIO mode
        // the drive is in, we are setting a flag in
        // the HwDeviceExtension so that we won't try
        // to change the pio transfer mode
        // 
        FdoExtension->HwDeviceExtension->NoPioSetTransferMode = TRUE;
    }

    ASSERT (FdoExtension->TransferModeInterface.TransferModeSelect);
    ASSERT (FdoExtension->TransferModeInterface.TransferModeTimingTable);

    return;
}

VOID
ChannelUnbindBusMasterParent (
    PFDO_EXTENSION    FdoExtension
    )
{
    // ISSUE: 08/30/2000 implement me!!!
    return;
}


VOID
ChannelQuerySyncAccessInterface (
    PFDO_EXTENSION    FdoExtension
    )
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS          status;

    RtlZeroMemory (&irpSp, sizeof(irpSp));
    RtlZeroMemory (
        &FdoExtension->SyncAccessInterface,
        sizeof (FdoExtension->SyncAccessInterface)
        );

    irpSp.Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_PCIIDE_SYNC_ACCESS_INTERFACE;
    irpSp.Parameters.QueryInterface.Version = 1;
    irpSp.Parameters.QueryInterface.Size = sizeof (FdoExtension->SyncAccessInterface);
    irpSp.Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->SyncAccessInterface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;

    status = IdePortSyncSendIrp (FdoExtension->AttacheeDeviceObject, &irpSp, NULL);

    //
    // parent doesn't support access token,
    //
    if (!NT_SUCCESS(status)) {

        FdoExtension->SyncAccessInterface.AllocateAccessToken = 0;
        FdoExtension->SyncAccessInterface.Token               = 0;
    }

    return;
}

VOID
ChannelQueryRequestProperResourceInterface (
    PFDO_EXTENSION    FdoExtension
    )
{
    IO_STACK_LOCATION irpSp;
    NTSTATUS          status;

    RtlZeroMemory (&irpSp, sizeof(irpSp));
    RtlZeroMemory (
        &FdoExtension->RequestProperResourceInterface,
        sizeof (FdoExtension->RequestProperResourceInterface)
        );

    irpSp.Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_PCIIDE_REQUEST_PROPER_RESOURCES;
    irpSp.Parameters.QueryInterface.Version = 1;
    irpSp.Parameters.QueryInterface.Size = sizeof (FdoExtension->RequestProperResourceInterface);
    irpSp.Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->RequestProperResourceInterface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;

    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;

    status = IdePortSyncSendIrp (FdoExtension->AttacheeDeviceObject, &irpSp, NULL);
    return;
}

__inline
VOID
ChannelEnableInterrupt (
    IN PFDO_EXTENSION FdoExtension
)
{
    ULONG i;

    for (i=0; i<(FdoExtension->HwDeviceExtension->MaxIdeDevice/MAX_IDE_DEVICE);i++) {

        SelectIdeLine(&FdoExtension->HwDeviceExtension->BaseIoAddress1,i);

        IdePortOutPortByte (
            FdoExtension->HwDeviceExtension->BaseIoAddress2.DeviceControl,
            IDE_DC_REENABLE_CONTROLLER
            );
    }
}

__inline
VOID
ChannelDisableInterrupt (
    IN PFDO_EXTENSION FdoExtension
)
{
    ULONG i;

    for (i=0; i<(FdoExtension->HwDeviceExtension->MaxIdeDevice/MAX_IDE_DEVICE);i++) {

        SelectIdeLine(&FdoExtension->HwDeviceExtension->BaseIoAddress1,i);

        IdePortOutPortByte (
            FdoExtension->HwDeviceExtension->BaseIoAddress2.DeviceControl,
            IDE_DC_DISABLE_INTERRUPTS
            );
    }
}



NTSTATUS
ChannelAcpiTransferModeSelect (
    IN PVOID Context,
    PPCIIDE_TRANSFER_MODE_SELECT XferMode
    )
{
    PFDO_EXTENSION fdoExtension = Context;
    ULONG i;
    BOOLEAN useUdmaMode[MAX_IDE_DEVICE];
    BOOLEAN dmaMode;
    PIDENTIFY_DATA ataIdentifyData[MAX_IDE_DEVICE];
    NTSTATUS status;
    ULONG numDevices;
    ULONG timingMode[MAX_IDE_DEVICE];
    ULONG cycleTime[MAX_IDE_DEVICE];
    ULONG dmaTiming;
    PACPI_IDE_TIMING acpiTimingSettings;
    ACPI_IDE_TIMING newAcpiTimingSettings;
    PULONG transferModeTimingTable=XferMode->TransferModeTimingTable;

    ASSERT(transferModeTimingTable);


    ASSERT (IsNEC_98 == FALSE);

    if (fdoExtension->DeviceChanged) {
        DebugPrint((DBG_XFERMODE, "Updating boot acpi timing settings\n"));
        RtlCopyMemory (&fdoExtension->BootAcpiTimingSettings, 
                       &fdoExtension->AcpiTimingSettings,
                       sizeof(newAcpiTimingSettings)
                       );
    }
    acpiTimingSettings = &fdoExtension->BootAcpiTimingSettings;

    RtlZeroMemory (&newAcpiTimingSettings, sizeof(newAcpiTimingSettings));
    newAcpiTimingSettings.Flags.b.IndependentTiming = 
        acpiTimingSettings->Flags.b.IndependentTiming;

    //
    // how many devices do we have?
    //
    for (i=numDevices=0; i<MAX_IDE_DEVICE; i++) {
        
        if (XferMode->DevicePresent[i]) {
            numDevices++;
        }
    }
    ASSERT (numDevices);

    //
    // pick the device pio timing
    //
    for (i=0; i<MAX_IDE_DEVICE; i++) {
        
        ULONG mode;

        if (!XferMode->DevicePresent[i]) {
            continue;
        }

        GetHighestPIOTransferMode(XferMode->DeviceTransferModeSupported[i], mode);

        timingMode[i] = 1<<mode;
        cycleTime[i] = XferMode->BestPioCycleTime[i];
    }

    if ((numDevices > 1) && !acpiTimingSettings->Flags.b.IndependentTiming) {

        //
        // pick the slower of the two timings
        // (the smaller timing mode value, the slower it is)
        //

        if (timingMode[0] < timingMode[1]) {

            cycleTime[1] = cycleTime[0];
            timingMode[1] = timingMode[0];

        } else {

            cycleTime[0] = cycleTime[1];
            timingMode[0] = timingMode[1];
        }
    }

    //
    // store the pio mode selected
    //
    for (i=0; i<MAX_IDE_DEVICE; i++) {

        if (XferMode->DevicePresent[i]) {
            XferMode->DeviceTransferModeSelected[i] = timingMode[i];
            newAcpiTimingSettings.Speed[i].Pio = cycleTime[i];

            if (i == 0) {
                newAcpiTimingSettings.Flags.b.IoChannelReady0 = XferMode->IoReadySupported[i];
            } else {
                newAcpiTimingSettings.Flags.b.IoChannelReady1 = XferMode->IoReadySupported[i];
            }

        } else {
            XferMode->DeviceTransferModeSelected[i] = 0;
        }
    }

    //
    // pick the device dma timing
    //
    for (i=0; i<MAX_IDE_DEVICE; i++) {

        ULONG mode;
        BOOLEAN useDma = TRUE;

        timingMode[i] = 0;
        cycleTime[i]= ACPI_XFER_MODE_NOT_SUPPORT;

        if (!XferMode->DevicePresent[i]) {
            continue;
        }

        //
        // check the acpi flag for ultra dma
        //
        if (i == 0) {

            useUdmaMode[i] = acpiTimingSettings->Flags.b.UltraDma0 ? TRUE: FALSE;

        } else {

            ASSERT (i==1);
            useUdmaMode[i] = acpiTimingSettings->Flags.b.UltraDma1 ? TRUE: FALSE;
        }

        //
        // get the dma timing specified in _GTM
        //
        dmaTiming = acpiTimingSettings->Speed[i].Dma;

        //
        // if dma is not supported, don't do anything, We have already set the PIO mode.
        //
        if (dmaTiming == ACPI_XFER_MODE_NOT_SUPPORT) {
            useUdmaMode[i]=0;
            useDma = FALSE;
            mode = PIO0;
        }


        // 
        // Find the highest UDMA mode
        //
        if (useUdmaMode[i]) {

            GetHighestDMATransferMode(XferMode->DeviceTransferModeSupported[i], mode);

            while (mode>= UDMA0) {
                if ((dmaTiming <= transferModeTimingTable[mode]) && 
                    (XferMode->DeviceTransferModeSupported[i] & (1<<mode))) {

                    timingMode[i] = 1<<mode;
                    cycleTime[i] = transferModeTimingTable[mode];
                    ASSERT(cycleTime[i]);

                    // we got a udma mode. so don't try to find a dma mode.
                    useDma = FALSE; 
                    break;
                } 
                mode--;
            }

        } 

        //
        // highest DMA mode
        // useDma is false only when either dma is not supported or an udma mode is
        // already selected.
        //
        if (useDma) {

            ULONG tempMode;

            // we shouldn't be using UDMA now.
            // this will set the flags for STM correctly.
            useUdmaMode[i]=FALSE;

            // mask out UDMA  and MWDMA0
            tempMode = XferMode->
                            DeviceTransferModeSupported[i] & (SWDMA_SUPPORT | MWDMA_SUPPORT);
            tempMode &= (~MWDMA_MODE0);

            GetHighestDMATransferMode(tempMode, mode);

            if (mode >= MWDMA1) {
                timingMode[i] = 1<<mode;
                cycleTime[i] = XferMode->BestMwDmaCycleTime[i];
                ASSERT(cycleTime[i]);
            } else if (mode == SWDMA2) {
                timingMode[i] = 1<<mode;
                cycleTime[i] = XferMode->BestSwDmaCycleTime[i];
                ASSERT(cycleTime[i]);
            } 
            // else don't do anything. PIO is already set

        }

    }

    if ((numDevices > 1) && !acpiTimingSettings->Flags.b.IndependentTiming) {

        //
        // pick the slower of the two timings
        // (the smaller timing mode value, the slower it is)
        //

        if (timingMode[0] < timingMode[1]) {

            cycleTime[1] = cycleTime[0];
            timingMode[1] = timingMode[0];

        } else {

            cycleTime[0] = cycleTime[1];
            timingMode[0] = timingMode[1];
        }

        //
        // both dma mode have to be the same
        // 
        if (useUdmaMode[0] != useUdmaMode[1]) {
            useUdmaMode[0] = 0;
            useUdmaMode[1] = 0;
        }
    }

    //
    // store the dma mode selected
    //
    for (i=0; i<MAX_IDE_DEVICE; i++) {

        if (XferMode->DevicePresent[i]) {

            XferMode->DeviceTransferModeSelected[i] |= timingMode[i];
            newAcpiTimingSettings.Speed[i].Dma = cycleTime[i];

            if (i==0) {
                newAcpiTimingSettings.Flags.b.UltraDma0 = useUdmaMode[i];
            } else {
                newAcpiTimingSettings.Flags.b.UltraDma1 = useUdmaMode[i];
            }
        }
    }

    if (fdoExtension->DmaDetectionLevel == DdlPioOnly) {

        //
        // remove all DMA modes
        //            
        for (i=0; i<MAX_IDE_DEVICE; i++) {

            XferMode->DeviceTransferModeSelected[i] &= PIO_SUPPORT;
        }
    }

    if ((acpiTimingSettings->Speed[0].Pio != ACPI_XFER_MODE_NOT_SUPPORT) ||
        (acpiTimingSettings->Speed[1].Pio != ACPI_XFER_MODE_NOT_SUPPORT)) {

        //
        // looks like we are on an ACPI machine and 
        // it supports IDE timing control method (_STM)
        //

        for (i=0; i<MAX_IDE_DEVICE; i++) {
    
            if (XferMode->DevicePresent[i]) {
    
                ataIdentifyData[i] = fdoExtension->HwDeviceExtension->IdentifyData + i;
            } else {
    
                ataIdentifyData[i] = NULL;
            }
        }        
    
        //
        // save the new timing settings
        //
        RtlCopyMemory (
            &fdoExtension->AcpiTimingSettings,
            &newAcpiTimingSettings, 
            sizeof(newAcpiTimingSettings));

        //
        // call ACPI to program the timing registers
        //
        status = ChannelSyncSetACPITimingSettings (
                     fdoExtension,
                     &newAcpiTimingSettings,
                     ataIdentifyData
                     );
    } else {

        //
        // legacy controller
        //
        for (i=0; i<MAX_IDE_DEVICE; i++) {
            XferMode->DeviceTransferModeSelected[i] &= PIO_SUPPORT;
        }

        status = STATUS_SUCCESS;
    }

    return status;
}


NTSTATUS
ChannelRestoreTiming (
    IN PFDO_EXTENSION FdoExtension,
    IN PSET_ACPI_TIMING_COMPLETION_ROUTINE CallerCompletionRoutine,
    IN PVOID CallerContext
    )
{
    ULONG i;
    PIDENTIFY_DATA ataIdentifyData[MAX_IDE_DEVICE];
    NTSTATUS status;

    PACPI_IDE_TIMING acpiTimingSettings;

    acpiTimingSettings = &FdoExtension->AcpiTimingSettings;

    if (FdoExtension->NumberOfLogicalUnits &&
        ((acpiTimingSettings->Speed[0].Pio != ACPI_XFER_MODE_NOT_SUPPORT) ||
         (acpiTimingSettings->Speed[1].Pio != ACPI_XFER_MODE_NOT_SUPPORT))) {

        //
        // looks like we are on an ACPI machine and 
        // it supports IDE timing control method (_STM)
        //

        for (i=0; i<MAX_IDE_DEVICE; i++) {
    
            if (FdoExtension->HwDeviceExtension->DeviceFlags[i] & 
                DFLAGS_DEVICE_PRESENT) {
    
                ataIdentifyData[i] = FdoExtension->HwDeviceExtension->IdentifyData + i;
            } else {
    
                ataIdentifyData[i] = NULL;
            }
        }        
    
        //
        // call ACPI to program the timing registers
        //
        status = ChannelSetACPITimingSettings (
                     FdoExtension,
                     acpiTimingSettings,
                     ataIdentifyData,
                     CallerCompletionRoutine,
                     CallerContext
                     );

    } else {

        //
        // non-acpi controller
        //
                                               
        if (FdoExtension->NumberOfLogicalUnits) {
            AtapiSyncSelectTransferMode (
                FdoExtension,
                FdoExtension->HwDeviceExtension,
                FdoExtension->TimingModeAllowed
                );
        }
        
        (*CallerCompletionRoutine) (
            FdoExtension->DeviceObject,
            STATUS_SUCCESS,
            CallerContext
        );
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
ChannelRestoreTimingCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN NTSTATUS Status,
    IN PVOID Context
    )
{
    PIO_STACK_LOCATION thisIrpSp;
    PFDO_POWER_CONTEXT context = Context;
    PIRP originalPowerIrp;

    context->TimingRestored = TRUE;

    originalPowerIrp = context->OriginalPowerIrp;
    originalPowerIrp->IoStatus.Status = Status;

    thisIrpSp = IoGetCurrentIrpStackLocation(originalPowerIrp);

    //
    // finish off the original power irp
    // 
    FdoPowerCompletionRoutine (
        thisIrpSp->DeviceObject,
        originalPowerIrp,
        Context
        );

    //
    // continue with the irp completion
    //
    IoCompleteRequest (originalPowerIrp, IO_NO_INCREMENT);

    return Status;
}

 
NTSTATUS
ChannelFilterResourceRequirements (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS          status;
    PFDO_EXTENSION    fdoExtension;
    ULONG             i, j, k;
    IO_STACK_LOCATION irpSp;
    PCIIDE_XFER_MODE_INTERFACE xferModeInterface;

    PIO_RESOURCE_REQUIREMENTS_LIST  requirementsListIn;
    PIO_RESOURCE_LIST               resourceListIn;
    PIO_RESOURCE_DESCRIPTOR         resourceDescriptorIn;

    PIO_RESOURCE_DESCRIPTOR         cmdRegResourceDescriptor;
    PIO_RESOURCE_DESCRIPTOR         ctrlRegResourceDescriptor;
    PIO_RESOURCE_DESCRIPTOR         intRegResourceDescriptor;
    
    PIO_RESOURCE_REQUIREMENTS_LIST  requirementsListOut;
    ULONG                           requirementsListSizeOut;
    PIO_RESOURCE_LIST               resourceListOut;
    PIO_RESOURCE_DESCRIPTOR         resourceDescriptorOut;

    PAGED_CODE();
    
    //
    // the value will stay NULL if no filtering required
    //
    requirementsListOut = NULL;

#ifdef IDE_FILTER_PROMISE_TECH_RESOURCES                                        
    if (NT_SUCCESS(ChannelFilterPromiseTechResourceRequirements (DeviceObject, Irp))) {
        goto getout;
    }
#endif // IDE_FILTER_PROMISE_TECH_RESOURCES
    
    //
    // do a simple test to check if we have a pciidex parent
    //
    RtlZeroMemory (&irpSp, sizeof(irpSp));

    irpSp.Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_PCIIDE_XFER_MODE_INTERFACE;
    irpSp.Parameters.QueryInterface.Version = 1;
    irpSp.Parameters.QueryInterface.Size = sizeof (xferModeInterface);
    irpSp.Parameters.QueryInterface.Interface = (PINTERFACE) &xferModeInterface;
    irpSp.Parameters.QueryInterface.InterfaceSpecificData = NULL;
    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_INTERFACE;

    fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;
    status = IdePortSyncSendIrp (fdoExtension->AttacheeDeviceObject, &irpSp, NULL);

    if (NT_SUCCESS(status)) {

        //
        // we have a pciidex as a parent.  it would
        // take care of the resource requirement
        // no need to filter
        //
        goto getout;
    }

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        ASSERT (Irp->IoStatus.Information);
        requirementsListIn = (PIO_RESOURCE_REQUIREMENTS_LIST) Irp->IoStatus.Information;

    } else {

        PIO_STACK_LOCATION thisIrpSp;

        thisIrpSp = IoGetCurrentIrpStackLocation(Irp);
        requirementsListIn = thisIrpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList;
    }

    if (requirementsListIn == NULL) {
        goto getout;
    }

    if (requirementsListIn->AlternativeLists == 0) {
        goto getout;
    }
                
    requirementsListSizeOut = requirementsListIn->ListSize + 
                              requirementsListIn->AlternativeLists *
                              sizeof(IO_RESOURCE_DESCRIPTOR);

    requirementsListOut = ExAllocatePool (PagedPool, requirementsListSizeOut);
    if (requirementsListOut == NULL) {
        goto getout;
    }

    *requirementsListOut = *requirementsListIn;
    requirementsListOut->ListSize = requirementsListSizeOut;

    //
    // some init.
    //
    resourceListIn = requirementsListIn->List;
    resourceListOut = requirementsListOut->List;
    for (j=0; j<requirementsListIn->AlternativeLists; j++) {

        resourceDescriptorIn = resourceListIn->Descriptors;
        
        //
        // analyze what resources we are getting
        //
        cmdRegResourceDescriptor  = NULL;
        ctrlRegResourceDescriptor = NULL;
        intRegResourceDescriptor  = NULL;
        for (i=0; i<resourceListIn->Count; i++) {
    
            switch (resourceDescriptorIn[i].Type) {
                case CmResourceTypePort: {
    
                    if ((resourceDescriptorIn[i].u.Port.Length == 8) &&
                        (cmdRegResourceDescriptor == NULL)) {
    
                        cmdRegResourceDescriptor = resourceDescriptorIn + i;
    
                    } else if (((resourceDescriptorIn[i].u.Port.Length == 1) ||
                                (resourceDescriptorIn[i].u.Port.Length == 2) ||
                                (resourceDescriptorIn[i].u.Port.Length == 4)) &&
                               (ctrlRegResourceDescriptor == NULL)) {
    
                        ctrlRegResourceDescriptor = resourceDescriptorIn + i;
    
                    } else if ((resourceDescriptorIn[i].u.Port.Length >= 0x10) &&
                               (cmdRegResourceDescriptor == NULL) &&
                               (ctrlRegResourceDescriptor == NULL)) {
        
                        //
                        // probably pcmcia device.  it likes to combine
                        // both io ranges into 1.
                        //
                        cmdRegResourceDescriptor = resourceDescriptorIn + i;
                        ctrlRegResourceDescriptor = resourceDescriptorIn + i;
                    }
                }
                break;
    
                case CmResourceTypeInterrupt: {
    
                    if (intRegResourceDescriptor == NULL) {
    
                        intRegResourceDescriptor = resourceDescriptorIn + i;
                    }
                }
                break;
    
                default:
                break;
            }
        }
    
        //
        // making a new copy
        //                                                                 
        *resourceListOut = *resourceListIn;
        
        //
        // figure out what is missing
        //
        if (cmdRegResourceDescriptor &&
            ((cmdRegResourceDescriptor->u.Port.MaximumAddress.QuadPart -
              cmdRegResourceDescriptor->u.Port.MinimumAddress.QuadPart + 1) == 8) &&
            (ctrlRegResourceDescriptor == NULL)) {
    
            //
            // missing controller register resource descriptor.
            //
    
            resourceDescriptorOut = resourceListOut->Descriptors;
            for (i=0; i<resourceListOut->Count; i++) {
    
                *resourceDescriptorOut = resourceDescriptorIn[i];
                resourceDescriptorOut++;
    
                if ((resourceDescriptorIn + i) == cmdRegResourceDescriptor) {
    
                    //
                    // add the control register resource
                    //
                    *resourceDescriptorOut = resourceDescriptorIn[i];
                    resourceDescriptorOut->u.Port.Length = 1;
                    resourceDescriptorOut->u.Port.Alignment = 1;
                    resourceDescriptorOut->u.Port.MinimumAddress.QuadPart = 
                        resourceDescriptorOut->u.Port.MaximumAddress.QuadPart = 
                            cmdRegResourceDescriptor->u.Port.MinimumAddress.QuadPart + 0x206;
    
                    resourceDescriptorOut++;
                }
            }
    
            //
            // account for the new control register resource
            //
            resourceListOut->Count++;
            
        } else {
        
            resourceDescriptorOut = resourceListOut->Descriptors;
            k = resourceListOut->Count;
            for (i = 0; i < k; i++) {

                if (IsNEC_98) {
                    //
                    // NEC98 DevNode includes the ide rom memory resource.
                    // But it should be gotten by NTDETECT.COM&HAL.DLL, so ignore it here.
                    //
                    if ((resourceDescriptorIn[i].Type == CmResourceTypeMemory) &&
                        (resourceDescriptorIn[i].u.Memory.MinimumAddress.QuadPart == 0xd8000) &&
                        (resourceDescriptorIn[i].u.Memory.Length == 0x4000)) {

                        resourceListOut->Count--;
                        continue;
                    }
                }
    
                *resourceDescriptorOut = resourceDescriptorIn[i];
                resourceDescriptorOut++;
            }
        }
        
        resourceListIn = (PIO_RESOURCE_LIST) (resourceDescriptorIn + resourceListIn->Count);
        resourceListOut = (PIO_RESOURCE_LIST) resourceDescriptorOut;
    }        


getout:
    if (requirementsListOut) {

        if (NT_SUCCESS(Irp->IoStatus.Status)) {

            ExFreePool ((PVOID) Irp->IoStatus.Information);

        } else {

            Irp->IoStatus.Status = STATUS_SUCCESS;
        }
        Irp->IoStatus.Information = (ULONG_PTR) requirementsListOut;
    }

    return IdePortPassDownToNextDriver (DeviceObject, Irp);
}

static PCWSTR PcmciaIdeChannelDeviceId = L"PCMCIA\\*PNP0600";
            
BOOLEAN
ChannelQueryPcmciaParent (
    PFDO_EXTENSION FdoExtension
    )
{
    BOOLEAN           foundIt = FALSE;                              
    NTSTATUS          status;
    IO_STATUS_BLOCK   ioStatus;
    IO_STACK_LOCATION irpSp;

    PAGED_CODE();

    //
    // do a simple test to check if we have a pciidex parent
    //
    RtlZeroMemory (&irpSp, sizeof(irpSp));

    irpSp.Parameters.QueryId.IdType = BusQueryHardwareIDs;
    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_ID;

    ioStatus.Status = STATUS_NOT_SUPPORTED;
    status = IdePortSyncSendIrp (FdoExtension->AttacheeDeviceObject, &irpSp, &ioStatus);

    if (NT_SUCCESS(status)) {

        PWSTR wstr;
        UNICODE_STRING hwId;
        UNICODE_STRING targetId;
    
        RtlInitUnicodeString(
            &targetId,
            PcmciaIdeChannelDeviceId);
            
        wstr = (PWSTR) ioStatus.Information;
        while (*wstr) {
        
            RtlInitUnicodeString(&hwId, wstr);
                     
            if (!RtlCompareUnicodeString(
                    &hwId,
                    &targetId,
                    FALSE)) {
                    
                ExFreePool ((PVOID) ioStatus.Information);
                DebugPrint ((DBG_PNP, "ATAPI: pcmcia parent\n"));
                return TRUE;                
            }                
            
            wstr += hwId.Length / sizeof(WCHAR);
            wstr++; // NULL character
        }
        ExFreePool ((PVOID) ioStatus.Information);
    }
    
    return FALSE;
}                                            

#ifdef IDE_FILTER_PROMISE_TECH_RESOURCES

static PCWSTR PromiseTechDeviceId[] = {
    L"ISAPNP\\BJB1000"
};
#define NUM_PROMISE_TECH_ID     (sizeof(PromiseTechDeviceId)/sizeof(PCWSTR))
            
NTSTATUS
ChannelFilterPromiseTechResourceRequirements (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    BOOLEAN           foundIt = FALSE;                              
    BOOLEAN           firstIrq = FALSE;                              
    ULONG             numExtraIoResDescriptor = 0;
    NTSTATUS          status;
    IO_STATUS_BLOCK   ioStatus;
    PFDO_EXTENSION    fdoExtension;
    ULONG             i, j, k;
    IO_STACK_LOCATION irpSp;
    PCIIDE_XFER_MODE_INTERFACE xferModeInterface;

    PIO_RESOURCE_REQUIREMENTS_LIST  requirementsListIn;
    PIO_RESOURCE_LIST               resourceListIn;
    PIO_RESOURCE_DESCRIPTOR         resourceDescriptorIn;
    PIO_RESOURCE_DESCRIPTOR         brokenResourceDescriptor;

    PIO_RESOURCE_DESCRIPTOR         cmdRegResourceDescriptor;
    PIO_RESOURCE_DESCRIPTOR         ctrlRegResourceDescriptor;
    PIO_RESOURCE_DESCRIPTOR         intRegResourceDescriptor;
    
    PIO_RESOURCE_REQUIREMENTS_LIST  requirementsListOut;
    ULONG                           requirementsListSizeOut;
    PIO_RESOURCE_LIST               resourceListOut;
    PIO_RESOURCE_DESCRIPTOR         resourceDescriptorOut;

    PAGED_CODE();

    //
    // the value will stay NULL if no filtering required
    //
    requirementsListOut = NULL;

    //
    // do a simple test to check if we have a pciidex parent
    //
    RtlZeroMemory (&irpSp, sizeof(irpSp));

    irpSp.Parameters.QueryId.IdType = BusQueryDeviceID;
    irpSp.MajorFunction = IRP_MJ_PNP;
    irpSp.MinorFunction = IRP_MN_QUERY_ID;

    fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;
    ioStatus.Status = STATUS_NOT_SUPPORTED;
    status = IdePortSyncSendIrp (fdoExtension->AttacheeDeviceObject, &irpSp, &ioStatus);

    if (NT_SUCCESS(status)) {

        UNICODE_STRING deviceId;
        UNICODE_STRING promiseTechDeviceId;
        
        RtlInitUnicodeString(
            &deviceId,
            (PCWSTR) ioStatus.Information);
            
        for (i=0; i<NUM_PROMISE_TECH_ID && !foundIt; i++) {
        
            RtlInitUnicodeString(
                &promiseTechDeviceId,
                PromiseTechDeviceId[i]);
                
            if (deviceId.Length >= promiseTechDeviceId.Length) {
                deviceId.Length = promiseTechDeviceId.Length;
                if (!RtlCompareUnicodeString(
                        &promiseTechDeviceId,
                        &deviceId,
                        FALSE)) {
                        
                    foundIt = TRUE;                    
                }                    
            }                
        }
        
        ExFreePool ((PVOID) ioStatus.Information);
    }
    
    if (!foundIt) {
        goto getout;
    }

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        ASSERT (Irp->IoStatus.Information);
        requirementsListIn = (PIO_RESOURCE_REQUIREMENTS_LIST) Irp->IoStatus.Information;

    } else {

        PIO_STACK_LOCATION thisIrpSp;

        thisIrpSp = IoGetCurrentIrpStackLocation(Irp);
        requirementsListIn = thisIrpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList;
    }

    if (requirementsListIn == NULL) {
        goto getout;
    }

    if (requirementsListIn->AlternativeLists == 0) {
        goto getout;
    }
                
    //
    // look for the bad resource descriptior
    //
    resourceListIn = requirementsListIn->List;
    brokenResourceDescriptor  = NULL;
    for (j=0; j<requirementsListIn->AlternativeLists; j++) {

        resourceDescriptorIn = resourceListIn->Descriptors;
        
        //
        // analyze what resources we are getting
        //
        for (i=0; i<resourceListIn->Count; i++) {
    
            switch (resourceDescriptorIn[i].Type) {
                case CmResourceTypePort: {
    
                    ULONG alignmentMask;
                    
                    alignmentMask = resourceDescriptorIn[i].u.Port.Alignment - 1;
                         
                    if (resourceDescriptorIn[i].u.Port.MinimumAddress.LowPart & alignmentMask) {
                    
                        //                                    
                        // broken resource requirement;
                        //
                        brokenResourceDescriptor = resourceDescriptorIn + i;
                    }                        
                }
                break;
    
                default:
                break;
            }
        }
    }
    
    if (brokenResourceDescriptor) {
    
        ULONG alignmentMask;
        PHYSICAL_ADDRESS minAddress;
        PHYSICAL_ADDRESS addressRange;
        
        alignmentMask = brokenResourceDescriptor->u.Port.Alignment - 1;
        alignmentMask = ~alignmentMask;
        
        minAddress = brokenResourceDescriptor->u.Port.MinimumAddress;
        minAddress.LowPart &= alignmentMask;
        
        addressRange.QuadPart = (brokenResourceDescriptor->u.Port.MaximumAddress.QuadPart - minAddress.QuadPart);
        numExtraIoResDescriptor = (ULONG) (addressRange.QuadPart / brokenResourceDescriptor->u.Port.Alignment);
    }
                                 
    requirementsListSizeOut = requirementsListIn->ListSize + 
                              numExtraIoResDescriptor *
                              sizeof(IO_RESOURCE_DESCRIPTOR);

    requirementsListOut = ExAllocatePool (PagedPool, requirementsListSizeOut);
    if (requirementsListOut == NULL) {
        goto getout;
    }

    *requirementsListOut = *requirementsListIn;
    requirementsListOut->ListSize = requirementsListSizeOut;

    //
    // some init.
    //
    resourceListIn = requirementsListIn->List;
    resourceListOut = requirementsListOut->List;
    for (j=0; j<requirementsListIn->AlternativeLists; j++) {

        resourceDescriptorIn = resourceListIn->Descriptors;
        
        //
        // making a new copy
        //                                                                 
        *resourceListOut = *resourceListIn;
        resourceListOut->Count = 0;
        
        //
        // analyze what resources we are getting
        //
        resourceDescriptorOut = resourceListOut->Descriptors;
        firstIrq = TRUE;
        for (i=0; i<resourceListIn->Count; i++) {
    
            switch (resourceDescriptorIn[i].Type) {
                case CmResourceTypePort: {
                
                    if ((resourceDescriptorIn + i == brokenResourceDescriptor) &&
                        (numExtraIoResDescriptor)) {
                        
                        for (k=0; k<numExtraIoResDescriptor; k++) {
                        
                            *resourceDescriptorOut = resourceDescriptorIn[i];
                            
                            if (k != 0) {
                            
                                resourceDescriptorOut->Option = IO_RESOURCE_ALTERNATIVE;
                            
                            }
                                                     
                            resourceDescriptorOut->u.Port.Alignment = 1;
                            resourceDescriptorOut->u.Port.MinimumAddress.QuadPart = 
                                brokenResourceDescriptor->u.Port.MinimumAddress.QuadPart + 
                                k * brokenResourceDescriptor->u.Port.Alignment;
                            resourceDescriptorOut->u.Port.MaximumAddress.QuadPart = 
                                resourceDescriptorOut->u.Port.MinimumAddress.QuadPart + 
                                resourceDescriptorOut->u.Port.Length - 1;
                                
                            resourceDescriptorOut++;                                
                            resourceListOut->Count++;
                        }
                        
                    } else {
                    
                        *resourceDescriptorOut = resourceDescriptorIn[i];
                        resourceDescriptorOut++;                                
                        resourceListOut->Count++;
                    }                        
                }
                break;
    
                case CmResourceTypeInterrupt: {
        
                    //
                    // keep all irqs except 9 which doesn't really work
                    //        
                    if (!((resourceDescriptorIn[i].u.Interrupt.MinimumVector == 0x9) &&
                         (resourceDescriptorIn[i].u.Interrupt.MaximumVector == 0x9))) {
                        
                        *resourceDescriptorOut = resourceDescriptorIn[i];
                        
                        if (firstIrq) {
                            resourceDescriptorOut->Option = 0;
                            firstIrq = FALSE;
                        } else {
                            resourceDescriptorOut->Option = IO_RESOURCE_ALTERNATIVE;
                        }
                        
                        resourceDescriptorOut++;                                
                        resourceListOut->Count++;
                    }
                }
                break;
                        
                default:
                *resourceDescriptorOut = resourceDescriptorIn[i];
                resourceDescriptorOut++;                                
                resourceListOut->Count++;
                break;
            }
        }
        resourceListIn = (PIO_RESOURCE_LIST) (resourceDescriptorIn + resourceListIn->Count);
        resourceListOut = (PIO_RESOURCE_LIST) resourceDescriptorOut;
    }        


getout:
    if (requirementsListOut) {

        if (NT_SUCCESS(Irp->IoStatus.Status)) {

            ExFreePool ((PVOID) Irp->IoStatus.Information);

        } else {

            Irp->IoStatus.Status = STATUS_SUCCESS;
        }
        Irp->IoStatus.Information = (ULONG_PTR) requirementsListOut;
        
        return STATUS_SUCCESS;
        
    } else {
    
        return STATUS_INVALID_PARAMETER;
    }
}
#endif // IDE_FILTER_PROMISE_TECH_RESOURCES

NTSTATUS
ChannelQueryPnPDeviceState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PFDO_EXTENSION fdoExtension;
    PPNP_DEVICE_STATE deviceState;

    fdoExtension = (PFDO_EXTENSION) DeviceObject->DeviceExtension;
 
    DebugPrint((DBG_PNP, "QUERY_DEVICE_STATE for FDOE 0x%x\n", fdoExtension));

    if(fdoExtension->PagingPathCount != 0) {
        deviceState = (PPNP_DEVICE_STATE) &(Irp->IoStatus.Information);
        SETMASK((*deviceState), PNP_DEVICE_NOT_DISABLEABLE);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoSkipCurrentIrpStackLocation (Irp);
    return IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\devpdo.c ===
/*++

Copyright (C) 1993-99  Microsoft Corporation

Module Name:

    devpdo.c

Abstract:

--*/

#include "ideport.h"

#ifdef ALLOC_PRAGMA

#pragma alloc_text(PAGE, IdeSendIdePassThrough)
#pragma alloc_text(PAGE, DeviceInitIdStrings)
#pragma alloc_text(PAGE, DeviceInitDeviceType)
#pragma alloc_text(PAGE, DeviceQueryDeviceRelations)
#pragma alloc_text(PAGE, DeviceUsageNotification)
#pragma alloc_text(PAGE, DeviceBuildStorageDeviceDescriptor)
#pragma alloc_text(PAGE, DeviceQueryPnPDeviceState)
#pragma alloc_text(PAGE, DeviceQueryCapabilities)
#pragma alloc_text(PAGE, DeviceBuildBusId)
#pragma alloc_text(PAGE, DeviceBuildCompatibleId)
#pragma alloc_text(PAGE, DeviceBuildHardwareId)
#pragma alloc_text(PAGE, DeviceBuildInstanceId)
#pragma alloc_text(PAGE, DeviceQueryId)
#pragma alloc_text(PAGE, DeviceQueryText)
#pragma alloc_text(PAGE, DeviceIdeTestUnitReady)
#pragma alloc_text(PAGE, DeviceQueryInitData)
#pragma alloc_text(PAGE, DeviceQueryStopRemoveDevice)
#pragma alloc_text(PAGE, DeviceStopDevice)
#pragma alloc_text(PAGE, DeviceScsiGetAddress)
#pragma alloc_text(PAGE, DeviceStorageQueryProperty)
#pragma alloc_text(PAGE, CopyField)

#pragma alloc_text(NONPAGE, DeviceIdeModeSelect)
#pragma alloc_text(NONPAGE, DeviceInitDeviceState)
#pragma alloc_text(NONPAGE, DeviceStartDeviceQueue)

#endif // ALLOC_PRAGMA

PDEVICE_OBJECT
DeviceCreatePhysicalDeviceObject (
    IN PDRIVER_OBJECT  DriverObject,
    IN PFDO_EXTENSION  FdoExtension,
    IN PUNICODE_STRING DeviceObjectName
    )
{
    PDEVICE_OBJECT  physicalDeviceObject;
    PPDO_EXTENSION  pdoExtension;
    NTSTATUS        status;

    physicalDeviceObject = NULL;

    status = IoCreateDevice(
                DriverObject,               // our driver object
                sizeof(PDO_EXTENSION),      // size of our extension
                DeviceObjectName,           // our name
                FILE_DEVICE_MASS_STORAGE,   // device type
                FILE_DEVICE_SECURE_OPEN,    // device characteristics
                FALSE,                      // not exclusive
                &physicalDeviceObject       // store new device object here
                );

    if (NT_SUCCESS(status)) {

        //
        // spinning up could take a lot of current;
        //
        physicalDeviceObject->Flags |= DO_POWER_INRUSH | DO_DIRECT_IO;

        //
        // fix up alignment requirement
        //
        physicalDeviceObject->AlignmentRequirement = FdoExtension->DeviceObject->AlignmentRequirement;
        if (physicalDeviceObject->AlignmentRequirement < 1) {
            physicalDeviceObject->AlignmentRequirement = 1;
        }

        pdoExtension = physicalDeviceObject->DeviceExtension;
        RtlZeroMemory (pdoExtension, sizeof(PDO_EXTENSION));

        //
        // Keeping track of those device objects
        //
        pdoExtension->DriverObject           = DriverObject;
        pdoExtension->DeviceObject           = physicalDeviceObject;

        //
        // keep track of our parent
        //
        pdoExtension->ParentDeviceExtension  = FdoExtension;

        //
        // Dispatch Table
        //
        pdoExtension->DefaultDispatch        = IdePortNoSupportIrp;
        pdoExtension->PnPDispatchTable       = PdoPnpDispatchTable;
        pdoExtension->PowerDispatchTable     = PdoPowerDispatchTable;
        pdoExtension->WmiDispatchTable       = PdoWmiDispatchTable;

        //
        // We have to be in this D0 state before we can be enumurated
        // 
        pdoExtension->SystemPowerState = PowerSystemWorking;
        pdoExtension->DevicePowerState = PowerDeviceD0;
    }

    return physicalDeviceObject;
}

NTSTATUS
DeviceStartDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PPDO_EXTENSION pdoExtension;
    KEVENT event;

    pdoExtension = RefPdoWithTag(
                       DeviceObject,
                       TRUE,
                       DeviceStartDevice
                       );

    if (pdoExtension) {

        KIRQL       currentIrql;

        // ISSUE: if we are not lun0, we really should wait for lun0 to start first


#if defined (IDEPORT_WMI_SUPPORT)
        //
        // register with WMI
        //
        if (!(pdoExtension->PdoState & PDOS_STARTED)) {
            IdePortWmiRegister ((PDEVICE_EXTENSION_HEADER)pdoExtension);
        }
        else {
            DebugPrint((1, "ATAPI: PDOe %x Didn't register for WMI\n", pdoExtension));
        }
#endif // IDEPORT_WMI_SUPPORT

        KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

        SETMASK (pdoExtension->PdoState, PDOS_STARTED);
        CLRMASK (pdoExtension->PdoState, PDOS_STOPPED | PDOS_REMOVED | PDOS_SURPRISE_REMOVED | PDOS_DISABLED_BY_USER);

        KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

        //
        // need to init device with acpi GTF before processing
        // the first request
        //
        // the assert could fire if the device is not powered up
        // ignore the assert for the time being. Everything should
        // work fine as the first request would power up the device
        //
        //ASSERT(pdoExtension->InitDeviceWithAcpiGtf == 0);
        InterlockedIncrement (&pdoExtension->InitDeviceWithAcpiGtf);

        //
        // keep the device queue block until we can go through some
        // init code
        //
        DeviceStopDeviceQueueSafe (pdoExtension, PDOS_QUEUE_FROZEN_BY_START, FALSE);

        //
        // clear the stop_device block
        //
        status = DeviceStartDeviceQueue (pdoExtension, PDOS_QUEUE_FROZEN_BY_STOP_DEVICE);

        //
        // init pdo with acpi bios _GTF data
        //
        KeInitializeEvent(&event,
                          NotificationEvent,
                          FALSE);

        DeviceQueryInitData(
            pdoExtension
            );

        //
        // can't really tell if it is enabled or not
        // assume it is.
        //
        pdoExtension->WriteCacheEnable = TRUE;

        status = DeviceInitDeviceState(
                     pdoExtension,
                     DeviceInitCompletionRoutine,
                     &event
                     );

        if (!NT_SUCCESS(status)) {

            ASSERT(NT_SUCCESS(status));
            DeviceInitCompletionRoutine (
                &event,
                status
                );

        } else {

            KeWaitForSingleObject(&event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }

        //
        // open the queue
        //
        DeviceStartDeviceQueue (pdoExtension, PDOS_QUEUE_FROZEN_BY_START);


        UnrefPdoWithTag(
            pdoExtension,
            DeviceStartDevice
            );

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_DEVICE_DOES_NOT_EXIST;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

NTSTATUS
DeviceStartDeviceQueue (
    IN PPDO_EXTENSION PdoExtension,
    IN ULONG          StopFlagToClear
    )
{
    NTSTATUS    status;
    KIRQL       currentIrql;
    BOOLEAN     restartQueue;
    ULONG       oldPdoState;

    restartQueue = FALSE;

    KeAcquireSpinLock(&PdoExtension->PdoSpinLock, &currentIrql);

    oldPdoState = PdoExtension->PdoState;

    CLRMASK (PdoExtension->PdoState, StopFlagToClear);

    if (PdoExtension->PdoState & PDOS_DEADMEAT) {

        restartQueue = FALSE;

    } else if ((oldPdoState & PDOS_MUST_QUEUE) !=
        (PdoExtension->PdoState & PDOS_MUST_QUEUE)) {

        //
        // make sure we have actually cleared some
        // PDOS_MUST_QUEUE bits.
        //
        if (!(PdoExtension->PdoState & PDOS_MUST_QUEUE)) {

            restartQueue = TRUE;
        }
    }

    KeReleaseSpinLock(&PdoExtension->PdoSpinLock, currentIrql);

    //
    // Restart queue
    //
    if (restartQueue) {

        KeAcquireSpinLock(&PdoExtension->ParentDeviceExtension->SpinLock, &currentIrql);

        GetNextLuPendingRequest(PdoExtension->ParentDeviceExtension, PdoExtension);

        KeLowerIrql(currentIrql);

        DebugPrint ((DBG_PNP, "IdePort: pdo 0x%x is pnp started with 0x%x items queued\n", PdoExtension->DeviceObject, PdoExtension->NumberOfIrpQueued));
    }

    return STATUS_SUCCESS;
}


NTSTATUS
DeviceStopDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PPDO_EXTENSION pdoExtension;

	PAGED_CODE();

    pdoExtension = RefPdoWithTag(
                       DeviceObject,
                       TRUE,
                       DeviceStopDevice
                       );

    if (pdoExtension) {

        DebugPrint ((
            DBG_PNP,
            "pdoe 0x%x 0x%x (%d, %d, %d) got a STOP device\n",
            pdoExtension,
            pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
            pdoExtension->PathId,
            pdoExtension->TargetId,
            pdoExtension->Lun
            ));

        status = DeviceStopDeviceQueueSafe (pdoExtension, PDOS_QUEUE_FROZEN_BY_STOP_DEVICE, FALSE);
        UnrefPdoWithTag (
            pdoExtension,
            DeviceStopDevice
            );

    } else {

        status = STATUS_DEVICE_DOES_NOT_EXIST;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
}

NTSTATUS
DeviceStopDeviceQueueSafe (
    IN PPDO_EXTENSION PdoExtension,
    IN ULONG          QueueStopFlag,
    IN BOOLEAN        LowMem
    )
{
    NTSTATUS                status;
    PPDO_STOP_QUEUE_CONTEXT context;
    KIRQL                   currentIrql;
    BOOLEAN                 queueAlreadyBlocked = FALSE;
    PENUMERATION_STRUCT     enumStruct;
    ULONG                   retryCount = 1;
    ULONG                   locked;

    ASSERT (PDOS_MUST_QUEUE & QueueStopFlag);

    //
    // make sure the queue is not already blocked for the same reason
    //
    ASSERT (!(PdoExtension->PdoState & QueueStopFlag));

    if (LowMem) {

        //
        //Lock
        //
        ASSERT(InterlockedCompareExchange(&(PdoExtension->ParentDeviceExtension->EnumStructLock),
                                              1, 0) == 0);

        enumStruct=PdoExtension->ParentDeviceExtension->PreAllocEnumStruct;
        if (enumStruct) {
            context=enumStruct->StopQContext;
            retryCount=5;
        } else {
            ASSERT(enumStruct);
            LowMem=FALSE;
            retryCount=1;
        }
    }

    if (!LowMem) {
        context = ExAllocatePool (NonPagedPool, sizeof(*context));
    }

    if (context) {

        //
        // check to see if queue is already blocked
        //
        KeAcquireSpinLock(&PdoExtension->PdoSpinLock, &currentIrql);
        if (PdoExtension->PdoState & (PDOS_MUST_QUEUE | PDOS_DEADMEAT)) {

            SETMASK (PdoExtension->PdoState, QueueStopFlag);
            queueAlreadyBlocked = TRUE;
        }
        KeReleaseSpinLock(&PdoExtension->PdoSpinLock, currentIrql);

        RtlZeroMemory (context, sizeof (*context));
        KeInitializeEvent(&context->Event,
                           NotificationEvent,
                           FALSE);

        context->PdoExtension  = PdoExtension;
        context->QueueStopFlag = QueueStopFlag;
        context->AtaPassThroughData.IdeReg.bReserved = ATA_PTFLAGS_NO_OP;

        if (queueAlreadyBlocked) {

            IdeStopQueueCompletionRoutine (
                PdoExtension->DeviceObject,
                context,
                STATUS_SUCCESS
                );

            status = STATUS_SUCCESS;

        } else {

            //
            // send a no-op request to block the queue
            //


            status = STATUS_INSUFFICIENT_RESOURCES;

            //
            // if lowMem=0, this loop will execute only once
            //
            while (status == STATUS_INSUFFICIENT_RESOURCES && retryCount--) {
                status = IssueAsyncAtaPassThroughSafe (
                             PdoExtension->ParentDeviceExtension,
                             PdoExtension,
                             &context->AtaPassThroughData,
                             FALSE,
                             IdeStopQueueCompletionRoutine,
                             context,
                             TRUE,          // TRUE really means complete this irp before starting a new one
                             DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                             LowMem
                             );
                ASSERT (NT_SUCCESS(status));

                if (status == STATUS_PENDING) {

                    KeWaitForSingleObject(&context->Event,
                                          Executive,
                                          KernelMode,
                                          FALSE,
                                          NULL);
                }

                status = context->Status;
            }
        }

        //
        // Don't free the context if it was Pre-alloced.
        //
        if (!LowMem) {
            ExFreePool (context);
        } else {

            // Unlock
            ASSERT(InterlockedCompareExchange(&(PdoExtension->ParentDeviceExtension->EnumStructLock),
                                        0, 1) == 1);
        }

    } else {

        status = STATUS_NO_MEMORY;
    }

    return status;
}

VOID
IdeStopQueueCompletionRoutine (
    IN PDEVICE_OBJECT           DeviceObject,
    IN PPDO_STOP_QUEUE_CONTEXT  Context,
    IN NTSTATUS                 Status
    )
{
    PPDO_EXTENSION pdoExtension;
    KIRQL          currentIrql;

    pdoExtension = Context->PdoExtension;
    Context->Status = Status;

    if (NT_SUCCESS(Status)) {

        KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

        if (Context->QueueStopFlag == PDOS_QUEUE_FROZEN_BY_STOP_DEVICE) {

            SETMASK (pdoExtension->PdoState, PDOS_STOPPED);
        }

        SETMASK (pdoExtension->PdoState, Context->QueueStopFlag);

        DebugPrint ((DBG_PNP, "IdePort: pdo 0x%x is pnp stopped with 0x%x items queued\n", DeviceObject, pdoExtension->NumberOfIrpQueued));

        KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

    } else {

        DebugPrint ((0, "IdePort: unable to stop pdo 0x%x\n", pdoExtension));
    }

    KeSetEvent (&Context->Event, 0, FALSE);

    return;
}

NTSTATUS
DeviceRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS       status;
    PPDO_EXTENSION pdoExtension;
    KIRQL          currentIrql;
    PDEVICE_OBJECT parentAttacheePdo;
    BOOLEAN        freePdo;
    BOOLEAN        callIoDeleteDevice;
    BOOLEAN        deregWmi = FALSE;

    pdoExtension = RefPdoWithTag(
                       DeviceObject,
                       TRUE,
                       DeviceRemoveDevice
                       );

    if (pdoExtension) {

        PIO_STACK_LOCATION thisIrpSp;

        thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

        if (thisIrpSp->MinorFunction == IRP_MN_SURPRISE_REMOVAL) {

            //
            // freeze the queue if it is a surprise remove. This is
            // necessary since a surprise remove on the fdo would 
            // clear the interrupt object. Any request that gets
            // sent down after the surprise remove will cause an access
            // violation if it makes into startio.
            //
            DeviceStopDeviceQueueSafe(pdoExtension, 
                                      PDOS_QUEUE_FROZEN_BY_STOP_DEVICE, 
                                      TRUE 
                                      );
        }

        KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

        if (pdoExtension->PdoState & PDOS_NEED_RESCAN) {

            CLRMASK (pdoExtension->PdoState, PDOS_NEED_RESCAN);

            //
            // get ready for IoInvalidateDeviceRelations
            //
            parentAttacheePdo = pdoExtension->ParentDeviceExtension->AttacheePdo;

        } else {

            parentAttacheePdo = NULL;
        }

        if (thisIrpSp->MinorFunction == IRP_MN_REMOVE_DEVICE) {

            DebugPrint ((
                DBG_PNP,
                "pdoe 0x%x 0x%x (%d, %d, %d) got a REMOVE device\n",
                pdoExtension,
                pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                pdoExtension->PathId,
                pdoExtension->TargetId,
                pdoExtension->Lun
                ));

            if (pdoExtension->PdoState & (PDOS_DEADMEAT | PDOS_SURPRISE_REMOVED)) {

                SETMASK (pdoExtension->PdoState, PDOS_REMOVED);

                if (pdoExtension->PdoState & PDOS_REPORTED_TO_PNP) {

                    freePdo = FALSE;

                } else {

                    freePdo = TRUE;
                }

            } else {

                SETMASK (pdoExtension->PdoState, PDOS_DISABLED_BY_USER);
                freePdo = FALSE;
            }

            if ((pdoExtension->PdoState & PDOS_STARTED) &&
                 !(pdoExtension->PdoState & PDOS_SURPRISE_REMOVED)) {
                deregWmi = TRUE;
            }
            CLRMASK (pdoExtension->PdoState, PDOS_STARTED);

            //
            // not claimed anymore
            //
            CLRMASK (pdoExtension->PdoState, PDOS_DEVICE_CLIAMED);

            callIoDeleteDevice = TRUE;

        } else {

            DebugPrint ((
                DBG_PNP,
                "pdoe 0x%x 0x%x (%d, %d, %d) got a SURPRISE_REMOVE device\n",
                pdoExtension,
                pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                pdoExtension->PathId,
                pdoExtension->TargetId,
                pdoExtension->Lun
                ));

            SETMASK (pdoExtension->PdoState, PDOS_SURPRISE_REMOVED | PDOS_DEADMEAT);

            if (pdoExtension->PdoState & PDOS_STARTED) {
                deregWmi = TRUE;
            }

            freePdo = TRUE;
            freePdo = FALSE;
            callIoDeleteDevice = FALSE;
        }

        KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

#if defined (IDEPORT_WMI_SUPPORT)
        //
        // deregister with WMI
        //
        if (deregWmi) {

            IdePortWmiDeregister ((PDEVICE_EXTENSION_HEADER)pdoExtension);
        }
#endif // IDEPORT_WMI_SUPPORT

        if (freePdo) {

            status = FreePdoWithTag(
                         pdoExtension,
                         TRUE,
                         callIoDeleteDevice,
                         DeviceRemoveDevice
                         );

        } else {

            //
            // release the pdo
            //
            UnrefPdoWithTag (
                pdoExtension,
                DeviceRemoveDevice
                );
        }

        if (parentAttacheePdo) {

            IoInvalidateDeviceRelations (
                parentAttacheePdo,
                BusRelations
                );
        }
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;

} // DeviceRemoveDevice

NTSTATUS
DeviceUsageNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PPDO_EXTENSION pdoExtension;
    NTSTATUS       status;

	PAGED_CODE();

    pdoExtension = RefPdoWithTag(
                       DeviceObject,
                       FALSE,
                       DeviceUsageNotification
                       );
    status = Irp->IoStatus.Status;

    if (pdoExtension) {

        PIO_STACK_LOCATION irpSp;
        PDEVICE_OBJECT targetDeviceObject;
        IO_STATUS_BLOCK ioStatus;
        PULONG deviceUsageCount;

        irpSp = IoGetCurrentIrpStackLocation(Irp);

        if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging) {

            //
            // Adjust the paging path count for this device.
            //
            deviceUsageCount = &pdoExtension->PagingPathCount;

            //
            // changing device state
            //
            IoInvalidateDeviceState(pdoExtension->DeviceObject);

        } else if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeHibernation) {

            //
            // Adjust the paging path count for this device.
            //
            deviceUsageCount = &pdoExtension->HiberPathCount;

        } else if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeDumpFile) {

            //
            // Adjust the paging path count for this device.
            //
            deviceUsageCount = &pdoExtension->CrashDumpPathCount;

        } else {

            deviceUsageCount = NULL;
            DebugPrint ((DBG_ALWAYS,
                         "ATAPI: Unknown IRP_MN_DEVICE_USAGE_NOTIFICATION type: 0x%x\n",
                         irpSp->Parameters.UsageNotification.Type));
        }

        //
        // get the top of parent's device stack
        //
        targetDeviceObject = IoGetAttachedDeviceReference(
                                 pdoExtension->
                                     ParentDeviceExtension->
                                         DeviceObject);


        ioStatus.Status = STATUS_NOT_SUPPORTED;
        status = IdePortSyncSendIrp (targetDeviceObject, irpSp, &ioStatus);

        ObDereferenceObject (targetDeviceObject);

        if (NT_SUCCESS(status)) {

            POWER_STATE powerState;

            if (deviceUsageCount) {

                IoAdjustPagingPathCount (
                    deviceUsageCount,
                    irpSp->Parameters.UsageNotification.InPath
                    );
            }

            if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeDumpFile) {

                //
                // reset the idle timeout to "forever"
                //
                DeviceRegisterIdleDetection (
                    pdoExtension,
                    DEVICE_VERY_LONG_IDLE_TIMEOUT,
                    DEVICE_VERY_LONG_IDLE_TIMEOUT
                    );

                if (pdoExtension->IdleCounter) {

                    PoSetDeviceBusy (pdoExtension->IdleCounter);
                }

                //
                // spin up the crash dump drive
                //
                powerState.DeviceState = PowerDeviceD0;
                PoRequestPowerIrp (
                    pdoExtension->DeviceObject,
                    IRP_MN_SET_POWER,
                    powerState,
                    NULL,
                    NULL,
                    NULL
                    );
            }
        }

        //
        // release the pdo
        //
        UnrefPdoWithTag (
            pdoExtension,
            DeviceUsageNotification
            );

    } else {

        status = STATUS_NO_SUCH_DEVICE;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;

} // DeviceUsageNotification

NTSTATUS
DeviceQueryStopRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS       status;
    PPDO_EXTENSION pdoExtension;
    PIO_STACK_LOCATION  thisIrpSp;

	PAGED_CODE();

    thisIrpSp = IoGetCurrentIrpStackLocation(Irp);

    pdoExtension = RefPdoWithTag(
                       DeviceObject,
                       TRUE,
                       DeviceQueryStopRemoveDevice
                       );

    if (pdoExtension) {

        if ((pdoExtension->PdoState & PDOS_LEGACY_ATTACHER) &&
            (thisIrpSp->MinorFunction == IRP_MN_QUERY_REMOVE_DEVICE)) {

            status = STATUS_UNSUCCESSFUL;

        } else if (pdoExtension->PagingPathCount ||
                   pdoExtension->CrashDumpPathCount) {

            //
            // Check the paging path count for this device.
            //

            status = STATUS_UNSUCCESSFUL;

        } else {

            status = STATUS_SUCCESS;
        }

        UnrefPdoWithTag (
            pdoExtension,
            DeviceQueryStopRemoveDevice
            );


    } else {

        status = STATUS_NO_SUCH_DEVICE;
        DebugPrint((1, "Query remove failed\n"));
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;

} // DeviceQueryStopRemoveDevice

NTSTATUS
DeviceQueryId (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  thisIrpSp;
    PPDO_EXTENSION      pdoExtension;
    NTSTATUS status;
    PWSTR idString;

	PAGED_CODE();

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

    idString = NULL;
    status = STATUS_DEVICE_DOES_NOT_EXIST;

    pdoExtension = RefPdoWithTag (
                       DeviceObject,
                       TRUE,
                       DeviceQueryId
                       );
    if (pdoExtension) {

        switch (thisIrpSp->Parameters.QueryId.IdType) {

            case BusQueryDeviceID:

                //
                // Caller wants the bus ID of this device.
                //

                idString = DeviceBuildBusId(pdoExtension);
                break;

            case BusQueryInstanceID:

                //
                // Caller wants the unique id of the device
                //

                idString = DeviceBuildInstanceId(pdoExtension);
                break;

            case BusQueryCompatibleIDs:

                //
                // Caller wants the compatible id of the device
                //

                idString = DeviceBuildCompatibleId(pdoExtension);
                break;

            case BusQueryHardwareIDs:

                //
                // Caller wants the hardware id of the device
                //

                idString = DeviceBuildHardwareId(pdoExtension);
                break;

            default:
                DebugPrint ((1, "ideport: QueryID type %d not supported\n", thisIrpSp->Parameters.QueryId.IdType));
                status = STATUS_NOT_SUPPORTED;
                break;
        }

        UnrefPdoWithTag(
            pdoExtension,
            DeviceQueryId
            );
    }

    if( idString != NULL ){
        Irp->IoStatus.Information = (ULONG_PTR) idString;
        status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;

} // DeviceQueryId


PWSTR
DeviceBuildBusId(
    IN PPDO_EXTENSION pdoExtension
    )
{
#define IDE_BUS_ID_PREFIX   "IDE\\"

    PUCHAR      deviceTypeIdString;
    ULONG       deviceTypeIdLen;
    UCHAR       compatibleId[10];


    USHORT      idStringBufLen;

    PUCHAR          idString;
    ANSI_STRING     ansiBusIdString;
    PWCHAR          idWString;
    UNICODE_STRING  unicodeIdString;

	PAGED_CODE();

    //
    // get the device type
    //
    deviceTypeIdString = (PUCHAR)IdePortGetDeviceTypeString (
                                    pdoExtension->ScsiDeviceType
                                    );

    if (deviceTypeIdString == NULL) {

        sprintf (compatibleId,
                 "Type%d",
                 pdoExtension->ScsiDeviceType);

        deviceTypeIdString = compatibleId;
    }
    deviceTypeIdLen = strlen(deviceTypeIdString);

    idStringBufLen = (USHORT)(strlen( IDE_BUS_ID_PREFIX ) +
                     deviceTypeIdLen +
                     sizeof (pdoExtension->FullVendorProductId) +
                     sizeof (pdoExtension->FullProductRevisionId) +
                     sizeof (pdoExtension->FullSerialNumber) +
                     1);

    //
    // get the string buffers
    //
    idWString = ExAllocatePool( PagedPool, idStringBufLen * sizeof(WCHAR));
    idString  = ExAllocatePool( PagedPool, idStringBufLen);

    if (idString && idWString) {

        //
        // build the ansi string
        //
        sprintf(idString, IDE_BUS_ID_PREFIX);

        CopyField(idString + strlen(idString),
                  deviceTypeIdString,
                  deviceTypeIdLen,
                  '_');

        CopyField(idString + strlen(idString),
                  pdoExtension->FullVendorProductId,
                  sizeof (pdoExtension->FullVendorProductId) - sizeof(CHAR),
                  '_');
        CopyField(idString + strlen(idString),
                  pdoExtension->FullProductRevisionId,
                  sizeof (pdoExtension->FullProductRevisionId) - sizeof(CHAR),
                  '_');

        RtlInitAnsiString (
            &ansiBusIdString,
            idString
            );

        //
        // build the unicode string
        //
        unicodeIdString.Length        = 0;
        unicodeIdString.MaximumLength = idStringBufLen * sizeof(WCHAR);
        unicodeIdString.Buffer        = (PWSTR) idWString;

        RtlAnsiStringToUnicodeString(
            &unicodeIdString,
            &ansiBusIdString,
            FALSE
            );

        unicodeIdString.Buffer[unicodeIdString.Length/sizeof(WCHAR)] = L'\0';

    } else {

        if (idWString) {
            ExFreePool (idWString);
        }
    }

    if (idString) {
        ExFreePool (idString);
    }
    return idWString;
}

PWSTR
DeviceBuildInstanceId(
    IN PPDO_EXTENSION pdoExtension
    )
{
    PWSTR       idString;
    USHORT      idStringBufLen;
    NTSTATUS    status;
    WCHAR       ideNonUniqueIdFormat[] = L"%x.%x.%x";

    PAGED_CODE();

    idStringBufLen = (sizeof(pdoExtension->FullSerialNumber) + 1) * sizeof(WCHAR);
    idString = ExAllocatePool (PagedPool, idStringBufLen);
    if( idString == NULL ){

        return NULL;
    }

    //
    // Form the string and return it.
    //
    if (pdoExtension->FullSerialNumber[0]) {

        ANSI_STRING     ansiCompatibleIdString;
        UNICODE_STRING  unicodeIdString;

        //
        // unique id
        //
        RtlInitAnsiString (
            &ansiCompatibleIdString,
            pdoExtension->FullSerialNumber
            );

        unicodeIdString.Length        = 0;
        unicodeIdString.MaximumLength = idStringBufLen;
        unicodeIdString.Buffer        = idString;

        RtlAnsiStringToUnicodeString(
            &unicodeIdString,
            &ansiCompatibleIdString,
            FALSE
            );

        idString[unicodeIdString.Length / 2] = L'\0';

    } else {

        //
        // non-unique id
        //
        swprintf( idString,
                  ideNonUniqueIdFormat,
                  pdoExtension->PathId,
                  pdoExtension->TargetId,
                  pdoExtension->Lun);
    }

    return idString;
}

PWSTR
DeviceBuildCompatibleId(
    IN PPDO_EXTENSION pdoExtension
    )
{
    NTSTATUS        status;

    PCSTR           compatibleIdString;

    ANSI_STRING     ansiCompatibleIdString;
    UNICODE_STRING  unicodeIdString;

    PWCHAR          compIdStrings;
    ULONG           totalBufferLen;

	PAGED_CODE();

	if (pdoExtension->ParentDeviceExtension->HwDeviceExtension->
			DeviceFlags[pdoExtension->TargetId] & DFLAGS_LS120_FORMAT) {

			//
			// ls-120 drive detected
			// return the special ls-120 compatible ID
			//
			compatibleIdString = SuperFloppyCompatibleIdString;

		} else {

			compatibleIdString = IdePortGetCompatibleIdString (pdoExtension->ScsiDeviceType);

		}


    RtlInitAnsiString (
        &ansiCompatibleIdString,
        compatibleIdString
        );

    totalBufferLen = RtlAnsiStringToUnicodeSize (
                         &ansiCompatibleIdString
                         );

    unicodeIdString.Length = 0;
    unicodeIdString.MaximumLength = (USHORT) totalBufferLen;

    //
    // null terminator
    //
    totalBufferLen += sizeof(WCHAR);

    //
    // multi-string null terminator
    //
    totalBufferLen += sizeof(WCHAR);

    compIdStrings = ExAllocatePool (PagedPool, totalBufferLen);

    if (compIdStrings) {

        unicodeIdString.Buffer = compIdStrings;
    } else {

        unicodeIdString.Buffer = NULL;
    }

    if (unicodeIdString.Buffer) {

            RtlAnsiStringToUnicodeString(
            &unicodeIdString,
            &ansiCompatibleIdString,
            FALSE
            );

        unicodeIdString.Buffer[unicodeIdString.Length/2 + 0] = L'\0';
        unicodeIdString.Buffer[unicodeIdString.Length/2 + 1] = L'\0';
    }

    return compIdStrings;
}

PWSTR
DeviceBuildHardwareId(
    IN PPDO_EXTENSION pdoExtension
    )
{
#define NUMBER_HARDWARE_STRINGS 5

    ULONG           i;
    PWSTR           idMultiString;
    PWSTR           idString;
    UCHAR           scratch[64];
    ULONG           idStringLen;
    NTSTATUS        status;
    ANSI_STRING     ansiCompatibleIdString;
    UNICODE_STRING  unicodeIdString;

    PCSTR           deviceTypeCompIdString;
    UCHAR           deviceTypeCompId[20];
    PCSTR           deviceTypeIdString;
    UCHAR           deviceTypeId[20];

    UCHAR           ScsiDeviceType;

	PAGED_CODE();

    ScsiDeviceType = pdoExtension->ScsiDeviceType;

    idStringLen = (64 * NUMBER_HARDWARE_STRINGS + sizeof (UCHAR)) * sizeof (WCHAR);
    idMultiString = ExAllocatePool (PagedPool, idStringLen);
    if (idMultiString == NULL) {

        return NULL;
    }

    deviceTypeIdString = IdePortGetDeviceTypeString(ScsiDeviceType);
    if (deviceTypeIdString == NULL) {

        sprintf (deviceTypeId,
                 "Type%d",
                 ScsiDeviceType);

        deviceTypeIdString = deviceTypeId;
    }

    if (pdoExtension->ParentDeviceExtension->HwDeviceExtension->
        DeviceFlags[pdoExtension->TargetId] & DFLAGS_LS120_FORMAT) {

        //
        // ls-120 drive detected
        // return the special ls-120 compatible ID
        //
        deviceTypeCompIdString = SuperFloppyCompatibleIdString;

    } else {

        deviceTypeCompIdString = IdePortGetCompatibleIdString (ScsiDeviceType);
        if (deviceTypeCompIdString == NULL) {

            sprintf (deviceTypeCompId,
                     "GenType%d",
                     ScsiDeviceType);

            deviceTypeCompIdString = deviceTypeCompId;
        }
    }

    //
    // Zero out the string buffer
    //

    RtlZeroMemory(idMultiString, idStringLen);
    idString = idMultiString;

    for(i = 0; i < NUMBER_HARDWARE_STRINGS; i++) {

        //
        // Build each of the hardware id's
        //

        switch(i) {

            //
            // Bus + Dev Type + Vendor + Product + Revision
            //

            case 0: {

                sprintf(scratch, "IDE\\%s", deviceTypeIdString);

                CopyField(scratch + strlen(scratch),
                          pdoExtension->FullVendorProductId,
                          sizeof (pdoExtension->FullVendorProductId) - sizeof(CHAR),
                          '_');
                CopyField(scratch + strlen(scratch),
                          pdoExtension->FullProductRevisionId,
                          sizeof (pdoExtension->FullProductRevisionId) - sizeof(CHAR),
                          '_');
                break;
            }

            //
            // bus + vendor + product + revision[0]
            case 1: {

                sprintf(scratch, "IDE\\");

                CopyField(scratch + strlen(scratch),
                          pdoExtension->FullVendorProductId,
                          sizeof (pdoExtension->FullVendorProductId) - sizeof(CHAR),
                          '_');
                CopyField(scratch + strlen(scratch),
                          pdoExtension->FullProductRevisionId,
                          sizeof (pdoExtension->FullProductRevisionId) - sizeof(CHAR),
                          '_');
                break;
            }

            //
            // bus + device + vendor + product
            case 2: {

                sprintf(scratch, "IDE\\%s", deviceTypeIdString);

                CopyField(scratch + strlen(scratch),
                          pdoExtension->FullVendorProductId,
                          sizeof (pdoExtension->FullVendorProductId) - sizeof(CHAR),
                          '_');
                break;
            }

            //
            // vendor + product + revision[0] (win9x)
            case 3: {

                CopyField(scratch,
                          pdoExtension->FullVendorProductId,
                          sizeof (pdoExtension->FullVendorProductId) - sizeof(CHAR),
                          '_');
                CopyField(scratch + strlen(scratch),
                          pdoExtension->FullProductRevisionId,
                          sizeof (pdoExtension->FullProductRevisionId) - sizeof(CHAR),
                          '_');

                break;
            }

            case 4: {

                strcpy(scratch, deviceTypeCompIdString);
                break;
            }

            default: {

                break;
            }
        }

        RtlInitAnsiString (
            &ansiCompatibleIdString,
            scratch
            );

        unicodeIdString.Length        = 0;
        unicodeIdString.MaximumLength = (USHORT) RtlAnsiStringToUnicodeSize(
                                                     &ansiCompatibleIdString
                                                     );
        unicodeIdString.Buffer        = idString;

        RtlAnsiStringToUnicodeString(
            &unicodeIdString,
            &ansiCompatibleIdString,
            FALSE
            );

        idString[unicodeIdString.Length / 2] = L'\0';
        idString += unicodeIdString.Length / 2+ 1;
    }
    idString[0] = L'\0';

    return idMultiString;

#undef NUMBER_HARDWARE_STRINGS
}


VOID
CopyField(
    IN PUCHAR Destination,
    IN PUCHAR Source,
    IN ULONG Count,
    IN UCHAR Change
    )

/*++

Routine Description:

    This routine will copy Count string bytes from Source to Destination.  If
    it finds a nul byte in the Source it will translate that and any subsequent
    bytes into Change.  It will also replace non-printable characters with the
    specified character.

Arguments:

    Destination - the location to copy bytes

    Source - the location to copy bytes from

    Count - the number of bytes to be copied

Return Value:

    none

--*/

{
    ULONG i = 0;
    BOOLEAN pastEnd = FALSE;

	PAGED_CODE();

    for(i = 0; i < Count; i++) {

        if(!pastEnd) {

            if(Source[i] == 0) {

                pastEnd = TRUE;

                Destination[i] = Change;

            } else if ((Source[i] <= L' ') ||
                       (Source[i] > ((WCHAR)0x7f)) ||
                       (Source[i] == L',')) {

                Destination[i] = Change;

            } else {

                Destination[i] = Source[i];

            }
        } else {
            Destination[i] = Change;
        }
    }

    Destination[i] = L'\0';
    return;
}



NTSTATUS
DeviceDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION thisIrpSp = IoGetCurrentIrpStackLocation(Irp);
    PPDO_EXTENSION pdoExtension;
    BOOLEAN passItToFdo;
    PDEVICE_OBJECT parentDeviceObject;
    NTSTATUS status;
    ULONG controlCode;


    controlCode = thisIrpSp->Parameters.DeviceIoControl.IoControlCode;

    if ((DEVICE_TYPE_FROM_CTL_CODE(controlCode) != IOCTL_STORAGE_BASE) &&
        (DEVICE_TYPE_FROM_CTL_CODE(controlCode) != IOCTL_SCSI_BASE)) {

        status = Irp->IoStatus.Status = STATUS_NOT_IMPLEMENTED;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }

    //
    // RefPdo makes sure that the pdo is not removed.
    //
    pdoExtension = RefPdoWithTag(
                       DeviceObject,
                       FALSE,
                       Irp
                       );

    if (pdoExtension) {

        passItToFdo = TRUE;
        parentDeviceObject = pdoExtension->ParentDeviceExtension->DeviceObject;

        switch (controlCode) {

            case IOCTL_SCSI_PASS_THROUGH_DIRECT:
            case IOCTL_SCSI_PASS_THROUGH: 

                status = PortSetPassThroughAddress(Irp,
                                                   pdoExtension->PathId,
                                                   pdoExtension->TargetId,
                                                   pdoExtension->Lun
                                                   );

                if (NT_SUCCESS(status)) {

                    //
                    // pass it to fdo
                    //
                    passItToFdo = TRUE;

                } else {

                    //
                    // Error - complete it
                    //
                    passItToFdo = FALSE;
                    Irp->IoStatus.Status = status;
                }
                
                break;

            case IOCTL_ATA_PASS_THROUGH:

                status = IdeAtaPassThroughSetPortAddress(Irp, 
                                                         pdoExtension->PathId, 
                                                         pdoExtension->TargetId, 
                                                         pdoExtension->Lun 
                                                         );
                if (NT_SUCCESS(status)) {

                    //
                    // This was originally designed to handle the request 
                    // at the FDO. It was later decided to restrict this 
                    // to the PDO. The routine should be slightly re-designed
                    // for this case by removing set and get address and passing
                    // in the PDO to it. This will be done later
                    //
                    status = IdeHandleAtaPassThroughIoctl(
                                    pdoExtension->ParentDeviceExtension, 
                                    Irp, 
                                    FALSE
                                    );

                } else {

                    //
                    // Error - complete it
                    //
                }

                Irp->IoStatus.Status = status;

                //
                // don't pass it to the fdo.
                //
                passItToFdo = FALSE;
                break;

            case IOCTL_ATA_PASS_THROUGH_DIRECT:

                status = IdeAtaPassThroughSetPortAddress(Irp, 
                                                         pdoExtension->PathId, 
                                                         pdoExtension->TargetId, 
                                                         pdoExtension->Lun 
                                                         );
                if (NT_SUCCESS(status)) {

                    status = IdeHandleAtaPassThroughIoctl(
                                    pdoExtension->ParentDeviceExtension, 
                                    Irp, 
                                    TRUE
                                    );

                } else {

                    //
                    // Error - complete it
                    //
                }

                Irp->IoStatus.Status = status;

                //
                // don't pass it to the fdo.
                //
                passItToFdo = FALSE;
                break;

            case IOCTL_IDE_PASS_THROUGH:

                //
                // Do not support this ioclt
                //

                //Irp->IoStatus.Status = IdeSendIdePassThrough(pdoExtension, Irp);
                passItToFdo = FALSE;
                Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;

                break;

            case IOCTL_SCSI_GET_ADDRESS: 

                passItToFdo = FALSE;
                Irp->IoStatus.Status = DeviceScsiGetAddress(pdoExtension, Irp);

                break;

            case IOCTL_SCSI_GET_DUMP_POINTERS:

                passItToFdo = FALSE;
                Irp->IoStatus.Status = DeviceGetDumpPointers(pdoExtension, Irp);

                break;


            case IOCTL_STORAGE_QUERY_PROPERTY:
            
                status = DeviceStorageQueryProperty(pdoExtension, Irp);

                if (status == STATUS_NOT_SUPPORTED) {

                    //
                    // not supported - pass it to fdo
                    //
                    passItToFdo = TRUE;

                } else {

                    //
                    // handled here. complete it
                    //
                    passItToFdo = FALSE;
                    Irp->IoStatus.Status = status;
                }

                break;

            case IOCTL_SCSI_MINIPORT:
            case IOCTL_SCSI_GET_INQUIRY_DATA:
            case IOCTL_SCSI_GET_CAPABILITIES:

                //
                // these need to be handled by the fdo
                //
                passItToFdo = TRUE;
                break;

            case IOCTL_SCSI_RESCAN_BUS:
            default:


                //
                // do not pass down unknown ioctls to the fdo
                // these ioctls should be sent directly to the fdo
                //
                passItToFdo = FALSE;
                Irp->IoStatus.Status = STATUS_INVALID_DEVICE_REQUEST;
                break;
                


        }

        UnrefPdoWithTag( pdoExtension, Irp );

    } else {

        passItToFdo = FALSE;
        Irp->IoStatus.Status = STATUS_INVALID_DEVICE_STATE;
    }

    if (passItToFdo) {

        return IdePortDeviceControl (parentDeviceObject, Irp);

    } else {

        status = Irp->IoStatus.Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }
}

NTSTATUS
DeviceScsiGetAddress (
    PPDO_EXTENSION PdoExtension,
    PIRP Irp
    )
{
    PIO_STACK_LOCATION thisIrpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;

    PAGED_CODE();

    if(thisIrpSp->Parameters.DeviceIoControl.OutputBufferLength <
       sizeof(SCSI_ADDRESS)) {

        status = STATUS_BUFFER_TOO_SMALL;

    } else {

        PSCSI_ADDRESS scsiAddress = Irp->AssociatedIrp.SystemBuffer;

        scsiAddress->Length = sizeof(SCSI_ADDRESS);
        scsiAddress->PortNumber = (UCHAR) PdoExtension->
                                    ParentDeviceExtension->ScsiPortNumber;
        scsiAddress->PathId = PdoExtension->PathId;
        scsiAddress->TargetId = PdoExtension->TargetId;
        scsiAddress->Lun = PdoExtension->Lun;

        Irp->IoStatus.Information = sizeof(SCSI_ADDRESS);

        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
DeviceGetDumpPointers(
    PPDO_EXTENSION  PdoExtension,
    PIRP Irp
    )
{
    PIO_STACK_LOCATION thisIrpSp = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;

    //
    // Get parameters for crash dump driver.
    //
    if (Irp->RequestorMode != KernelMode) {

        status = STATUS_INVALID_DEVICE_REQUEST;

    } else if (thisIrpSp->Parameters.DeviceIoControl.OutputBufferLength < 
               sizeof(DUMP_POINTERS)) {

        status = STATUS_BUFFER_TOO_SMALL;

    } else {

        PCRASHDUMP_INIT_DATA dumpInitData;

        //
        // caller needs to free this
        //
        // ISSUE: make sure we tell the parent to power up
        //
        dumpInitData = ExAllocatePool (NonPagedPool, 
                                       sizeof (CRASHDUMP_INIT_DATA)
                                       );

        if (dumpInitData) {

            PDUMP_POINTERS dumpPointers;
            dumpPointers = (PDUMP_POINTERS)Irp->AssociatedIrp.SystemBuffer;

            RtlZeroMemory (dumpInitData, sizeof (CRASHDUMP_INIT_DATA));
            dumpInitData->PathId    = PdoExtension->PathId;
            dumpInitData->TargetId  = PdoExtension->TargetId;
            dumpInitData->Lun       = PdoExtension->Lun;

            dumpInitData->LiveHwDeviceExtension = 
                PdoExtension->ParentDeviceExtension->HwDeviceExtension;

            dumpPointers->AdapterObject      = NULL;
            dumpPointers->MappedRegisterBase = NULL;
            dumpPointers->DumpData           = dumpInitData;
            dumpPointers->CommonBufferVa     = NULL;
            dumpPointers->CommonBufferPa.QuadPart = 0;
            dumpPointers->CommonBufferSize      = 0;
            dumpPointers->DeviceObject          = PdoExtension->DeviceObject;
            dumpPointers->AllocateCommonBuffers = FALSE;

            Irp->IoStatus.Information = sizeof(DUMP_POINTERS);

            status = STATUS_SUCCESS;

        } else {

            IdeLogNoMemoryError(PdoExtension->ParentDeviceExtension,
                                PdoExtension->TargetId,
                                NonPagedPool,
                                sizeof(CRASHDUMP_INIT_DATA),
                                IDEPORT_TAG_DUMP_POINTER
                                );

            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    return status;
}

NTSTATUS
DeviceStorageQueryProperty (
    PPDO_EXTENSION PdoExtension,
    PIRP Irp
    )
{
    PIO_STACK_LOCATION thisIrpSp = IoGetCurrentIrpStackLocation(Irp);
    PSTORAGE_PROPERTY_QUERY storageQuery;
    NTSTATUS status;

    PAGED_CODE();

    storageQuery = Irp->AssociatedIrp.SystemBuffer;
    status = STATUS_NOT_SUPPORTED;

    if (thisIrpSp->Parameters.DeviceIoControl.InputBufferLength < 
        sizeof(STORAGE_PROPERTY_QUERY)) {

        status = STATUS_INVALID_PARAMETER;

    } else {

        if (storageQuery->PropertyId == StorageDeviceProperty) { // device property

            ULONG bufferSize;

            switch (storageQuery->QueryType) {
                case PropertyStandardQuery:
                    DebugPrint ((2, 
                                 "IdePortPdoDispatch: IOCTL_STORAGE_QUERY_PROPERTY PropertyStandardQuery\n"
                                 ));

                    bufferSize = thisIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
                    status = DeviceBuildStorageDeviceDescriptor(
                                               PdoExtension,
                                               (PSTORAGE_DEVICE_DESCRIPTOR) Irp->AssociatedIrp.SystemBuffer,
                                               &bufferSize
                                               );
                    if (NT_SUCCESS(status)) {

                        Irp->IoStatus.Information = bufferSize;
                    }

                    break;

                case PropertyExistsQuery:
                    DebugPrint ((2, "IdePortPdoDispatch: IOCTL_STORAGE_QUERY_PROPERTY PropertyExistsQuery\n"));
                    // ISSUE: Will be implemented when required
                    status = STATUS_SUCCESS;
                    break;

                case PropertyMaskQuery:
                    DebugPrint ((2, "IdePortPdoDispatch: IOCTL_STORAGE_QUERY_PROPERTY PropertyMaskQuery\n"));
                    //ISSUE:  Will implement when required
                    status = STATUS_NOT_IMPLEMENTED;
                    break;

                default:
                    DebugPrint ((2, "IdePortPdoDispatch: IOCTL_STORAGE_QUERY_PROPERTY unknown type\n"));
                    // ISSUE: Will implement when required
                    status = STATUS_NOT_IMPLEMENTED;
                    break;
            }
        }
    }

    return status;
}

NTSTATUS
DeviceBuildStorageDeviceDescriptor(
    PPDO_EXTENSION pdoExtension,
    IN OUT PSTORAGE_DEVICE_DESCRIPTOR StorageDeviceDescriptor,
    IN OUT PULONG BufferSize
    )
{

    STORAGE_DEVICE_DESCRIPTOR localStorageDeviceDescriptor;
    ULONG productIdLength;
    ULONG revisionIdLength;
    ULONG serialNumberLength;
    PUCHAR bytebuffer;
    ULONG byteLeft;
    ULONG byteToCopy;

    INQUIRYDATA InquiryData;
    NTSTATUS status;

    ASSERT (pdoExtension);
    ASSERT (StorageDeviceDescriptor);

    productIdLength    = strlen(pdoExtension->FullVendorProductId) + sizeof(UCHAR);
    revisionIdLength   = strlen(pdoExtension->FullProductRevisionId) + sizeof(UCHAR);
    serialNumberLength = strlen(pdoExtension->FullSerialNumber) + sizeof(UCHAR);

    RtlZeroMemory (&localStorageDeviceDescriptor, sizeof (STORAGE_DEVICE_DESCRIPTOR));
    localStorageDeviceDescriptor.Version = sizeof (STORAGE_DEVICE_DESCRIPTOR);
    localStorageDeviceDescriptor.Size = sizeof (STORAGE_DEVICE_DESCRIPTOR) +
                                        INQUIRYDATABUFFERSIZE +
                                        productIdLength +
                                        revisionIdLength +
                                        serialNumberLength;

    localStorageDeviceDescriptor.DeviceType = pdoExtension->ScsiDeviceType;

    if (pdoExtension->
            ParentDeviceExtension->
            HwDeviceExtension->
            DeviceFlags[pdoExtension->TargetId] &
            DFLAGS_REMOVABLE_DRIVE) {

        localStorageDeviceDescriptor.RemovableMedia = TRUE;
    }

    if (pdoExtension->
            ParentDeviceExtension->
            HwDeviceExtension->
            DeviceFlags[pdoExtension->TargetId] &
            DFLAGS_ATAPI_DEVICE) {

        localStorageDeviceDescriptor.BusType = BusTypeAtapi;
    } else {

        localStorageDeviceDescriptor.BusType = BusTypeAta;
    }

    bytebuffer = (PUCHAR) StorageDeviceDescriptor;
    byteLeft = *BufferSize;

    //
    // copy the basic STORAGE_DEVICE_DESCRIPTOR
    //
    if (byteLeft) {

        byteToCopy = min(sizeof (STORAGE_DEVICE_DESCRIPTOR), byteLeft);

        RtlCopyMemory (StorageDeviceDescriptor,
                       &localStorageDeviceDescriptor,
                       byteToCopy);

        bytebuffer += byteToCopy;
        byteLeft -= byteToCopy;
    }

    //
    // copy raw device properties (Inquiry Data)
    //
    if (byteLeft) {

        status = IssueInquirySafe(
                     pdoExtension->ParentDeviceExtension,
                     pdoExtension,
                     &InquiryData,
                     FALSE
                     );

        if (NT_SUCCESS(status) || (status == STATUS_DATA_OVERRUN)) {

            byteToCopy = min(INQUIRYDATABUFFERSIZE, byteLeft);

            RtlCopyMemory (bytebuffer,
                           &InquiryData,
                           byteToCopy);

            StorageDeviceDescriptor->RawPropertiesLength = byteToCopy;

            bytebuffer += byteToCopy;
            byteLeft -= byteToCopy;
        }
    }

    //
    // copy product ID
    //
    if (byteLeft) {

        byteToCopy = min(productIdLength, byteLeft);

        RtlCopyMemory (bytebuffer,
                       pdoExtension->FullVendorProductId,
                       byteToCopy);
        bytebuffer[byteToCopy - 1] = '\0';

        StorageDeviceDescriptor->ProductIdOffset = *BufferSize - byteLeft;

        bytebuffer += byteToCopy;
        byteLeft -= byteToCopy;
    }

    //
    // copy revision ID
    //
    if (byteLeft) {

        byteToCopy = min(productIdLength, byteLeft);

        RtlCopyMemory (bytebuffer,
                       pdoExtension->FullProductRevisionId,
                       byteToCopy);
        bytebuffer[byteToCopy - 1] = '\0';

        StorageDeviceDescriptor->ProductRevisionOffset = *BufferSize - byteLeft;

        bytebuffer += byteToCopy;
        byteLeft -= byteToCopy;
    }

    //
    // copy serial #
    //
    if (byteLeft) {

        byteToCopy = min(serialNumberLength, byteLeft);

        RtlCopyMemory (bytebuffer,
                       pdoExtension->FullSerialNumber,
                       byteToCopy);
        bytebuffer[byteToCopy - 1] = '\0';

        StorageDeviceDescriptor->SerialNumberOffset = *BufferSize - byteLeft;

        bytebuffer += byteToCopy;
        byteLeft -= byteToCopy;
    }

    *BufferSize -= byteLeft;

    return STATUS_SUCCESS;

} // DeviceBuildStorageDeviceDescriptor


NTSTATUS
DeviceQueryCapabilities (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION      thisIrpSp;
    PPDO_EXTENSION          pdoExtension;
    PDEVICE_CAPABILITIES    capabilities;
    NTSTATUS                status;

	PAGED_CODE();

    thisIrpSp    = IoGetCurrentIrpStackLocation( Irp );
    capabilities = thisIrpSp->Parameters.DeviceCapabilities.Capabilities;

    pdoExtension = RefPdoWithTag (
                       DeviceObject,
                       TRUE,
                       DeviceQueryCapabilities
                       );

    if (pdoExtension == NULL) {

        status = STATUS_DEVICE_DOES_NOT_EXIST;

    } else {

        DEVICE_CAPABILITIES parentDeviceCapabilities;

        status = IdeGetDeviceCapabilities(
                     pdoExtension->ParentDeviceExtension->AttacheePdo,
                     &parentDeviceCapabilities);

        if (NT_SUCCESS(status)) {

            RtlMoveMemory (
                capabilities,
                &parentDeviceCapabilities,
                sizeof(DEVICE_CAPABILITIES));

            if (pdoExtension->FullSerialNumber[0]) {

                capabilities->UniqueID          = TRUE;
            } else {

                capabilities->UniqueID          = FALSE;
            }

            //
            // never!
            //
            capabilities->Removable         = FALSE;
            capabilities->SurpriseRemovalOK = FALSE;

            capabilities->Address           = PNP_ADDRESS(pdoExtension->TargetId, pdoExtension->Lun);
            capabilities->UINumber          = pdoExtension->TargetId;

            capabilities->D1Latency         = 31 * (1000 * 10);     // 31s
            capabilities->D2Latency         = 31 * (1000 * 10);     // 31s
            capabilities->D3Latency         = 31 * (1000 * 10);     // 31s
        }

        UnrefPdoWithTag (
            pdoExtension,
            DeviceQueryCapabilities
            );

    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return status;
} // DeviceQueryCapabitilies

NTSTATUS
IdePortInsertByKeyDeviceQueue (
    IN PPDO_EXTENSION PdoExtension,
    IN PIRP Irp,
    IN ULONG SortKey,
    OUT PBOOLEAN Inserted
    )
{
    KIRQL currentIrql;
    NTSTATUS status;
    POWER_STATE powerState;

    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;
    BOOLEAN urgentSrb;

    status = STATUS_SUCCESS;
    *Inserted = FALSE;

    KeRaiseIrql(DISPATCH_LEVEL, &currentIrql);

    if (PdoExtension->LuFlags & PD_QUEUE_FROZEN) {

        DebugPrint((1,"IdePortDispatch:  Request put in frozen queue!\n"));
    }

    *Inserted = KeInsertByKeyDeviceQueue(
                    &PdoExtension->DeviceObject->DeviceQueue,
                    &Irp->Tail.Overlay.DeviceQueueEntry,
                    SortKey);

    if (*Inserted == FALSE) {

        //
        // we need this check here because in the remove irp codepath
        // setting the PDOS_REMOVED flag and flushing the queue are not
        // atomic. If the queue is already flushed and there are no active
        // requests, no one will pick this one up. If there is one active the
        // flush would have cleared the queue busy and we could end up with
        // two active requests simultaneously. If the PDOS_REMOVED flag is
        // set then flush the queue to clear up any requests that got queued
        // due to busy being set by this request. Note that if the flush in the
        // remove happens after this it will just be an extra flush. No harm there
        //
        if (PdoExtension->PdoState & PDOS_REMOVED) {

            //
            // lower the irql 
            //
            KeLowerIrql(currentIrql);

            //
            // The pdo has been removed. We have to flush any requests in
            // the queue since the remove irp could be done with the flush
            // already. Note that this will also clear the queue busy.
            //
            IdePortFlushLogicalUnit(PdoExtension->ParentDeviceExtension, 
                                    PdoExtension, 
                                    TRUE
                                    );

            //
            // complete the request in hand
            //
            srb->SrbStatus = SRB_STATUS_REQUEST_FLUSHED;
            Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;

            
            UnrefLogicalUnitExtensionWithTag(
                PdoExtension->ParentDeviceExtension,
                PdoExtension,
                Irp
                );

            IoCompleteRequest(Irp, IO_NO_INCREMENT);

            //
            // return true so that the dispatch routine doesn't attempt
            // to send it down
            //
            *Inserted = TRUE;

            return status;
        }

        if (PdoExtension->PdoState & PDOS_QUEUE_BLOCKED) {

            ASSERT (PdoExtension->PendingRequest == NULL);
            PdoExtension->PendingRequest = Irp;
            *Inserted = TRUE;

            if (!(PdoExtension->PdoState & PDOS_MUST_QUEUE)) {



                //
                // device is powered down
                // use a large time in case it spins up slowly
                //
                if (srb->TimeOutValue < DEFAULT_SPINUP_TIME) {

                    srb->TimeOutValue = DEFAULT_SPINUP_TIME;
                }

                //
                // We are not powered up.
                // issue an power up
                //
                powerState.DeviceState = PowerDeviceD0;
                status = PoRequestPowerIrp (
                             PdoExtension->DeviceObject,
                             IRP_MN_SET_POWER,
                             powerState,
                             NULL,
                             NULL,
                             NULL
                             );
                ASSERT (NT_SUCCESS(status));

                DebugPrint ((2, "IdePort GetNextLuRequest: 0x%x 0x%x need to spin up device, requeue irp 0x%x\n",
                             PdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                             PdoExtension->TargetId,
                             Irp));
            }

        } else if (srb->Function != SRB_FUNCTION_ATA_POWER_PASS_THROUGH) {

            //
            // If this irp is not for changing power state, we may have
            // to queue it
            //
            if (PdoExtension->DevicePowerState != PowerDeviceD0) {

                if (PdoExtension->DevicePowerState != PowerDeviceD3) {

                    //
                    // we are in D1 or D2.
                    // We can never be sure that we are in D0 when
                    // we tell the device to go from D1/D2 to D0.
                    // Some device lies and won't spin up until it sees
                    // a media access command.  This causes longer time
                    // to execute the command
                    //
                    // to prevent the next command from timing out, we
                    // will increment its timeout
                    //

                    if (srb->TimeOutValue < 30) {

                        srb->TimeOutValue = 30;
                    }
                }

                //
                // We are not powered up.
                // issue an power up
                //
                powerState.DeviceState = PowerDeviceD0;
                status = PoRequestPowerIrp (
                             PdoExtension->DeviceObject,
                             IRP_MN_SET_POWER,
                             powerState,
                             NULL,
                             NULL,
                             NULL
                             );

                ASSERT (NT_SUCCESS(status));
                status = STATUS_SUCCESS;

                ASSERT (PdoExtension->PendingRequest == NULL);
                PdoExtension->PendingRequest = Irp;

                DebugPrint ((1, "IdePort IdePortInsertByKeyDeviceQueue: 0x%x 0x%x need to spin up device, requeue irp 0x%x\n",
                             PdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                             PdoExtension->TargetId,
                             Irp));

                *Inserted = TRUE;
            }
        }

    } else {

#if DBG
        InterlockedIncrement (
            &PdoExtension->NumberOfIrpQueued
            );
#endif // DBG

    }

    KeLowerIrql(currentIrql);
    return status;
}

VOID
DeviceInitCompletionRoutine (
    PVOID Context,
    NTSTATUS Status
    )
{
    PKEVENT event = Context;

    if (!NT_SUCCESS(Status)) {

        //ASSERT (!"DeviceInitDeviceState Failed\n");
        DebugPrint((DBG_ALWAYS, "ATAPI: ERROR: DeviceInitDeviceStateFailed with Status %x\n",
                        Status));
    }

    KeSetEvent (event, 0, FALSE);
}

NTSTATUS
DeviceQueryText (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  thisIrpSp;
    PPDO_EXTENSION      pdoExtension;
    PWCHAR              returnString;
    LONG                i;
    UNICODE_STRING      unicodeString;
    ANSI_STRING         ansiString;
    ULONG               stringLen;
    NTSTATUS            status;

	PAGED_CODE();
    thisIrpSp    = IoGetCurrentIrpStackLocation (Irp);

    returnString = NULL;
    Irp->IoStatus.Information = 0;

    pdoExtension = RefPdoWithTag (
                       DeviceObject,
                       TRUE,
                       DeviceQueryText
                       );

    if (pdoExtension == NULL) {

        status = STATUS_DEVICE_DOES_NOT_EXIST;

    } else {

        status = STATUS_NO_MEMORY;

        if (thisIrpSp->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription) {

            stringLen = sizeof (pdoExtension->FullVendorProductId);
            stringLen *= sizeof(WCHAR);
            returnString = ExAllocatePool (
                               PagedPool,
                               stringLen
                               );
            if (returnString) {

                unicodeString.Length        = 0;
                unicodeString.MaximumLength = (USHORT) stringLen;
                unicodeString.Buffer        = returnString;

                //
                // vendor ID
                //
                RtlInitAnsiString (
                    &ansiString,
                    pdoExtension->FullVendorProductId
                    );

                RtlAnsiStringToUnicodeString(
                    &unicodeString,
                    &ansiString,
                    FALSE
                    );

                ASSERT(unicodeString.Length < unicodeString.MaximumLength);
                //
                // get rid of trailing spaces and nulls
                //
                for (i=(unicodeString.Length/2)-1; i >= 0; i--) {

                    if ((returnString[i] == ' ') || (returnString[i] == 0)) {

                        continue;

                    } else {

                        break;
                    }
                }

                //
                // null terminate it
                //
                returnString[i + 1] = 0;

                status = STATUS_SUCCESS;
            }
        } else if (thisIrpSp->Parameters.QueryDeviceText.DeviceTextType == DeviceTextLocationInformation) {

            stringLen = 100;

            returnString = ExAllocatePool (
                               PagedPool,
                               stringLen
                               );

            if (returnString) {

                wcscpy(returnString, 
                         (((pdoExtension->TargetId & 0x1) == 0) ? L"0" :
                                                                  L"1"));

                RtlInitUnicodeString(&unicodeString, returnString);

                //
                // null terminate it
                //
                unicodeString.Buffer[unicodeString.Length/sizeof(WCHAR) + 0] = L'\0';

                status = STATUS_SUCCESS;
            }

        } else {

            status = STATUS_NOT_SUPPORTED;
        }

        UnrefPdoWithTag (
            pdoExtension,
            DeviceQueryText
            );
    }

    Irp->IoStatus.Information = (ULONG_PTR) returnString;
    Irp->IoStatus.Status = status;

    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // DeviceQueryText

NTSTATUS
IdeSendIdePassThrough (
    IN PPDO_EXTENSION PdoExtension,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function sends a user specified IDE task registers
    It creates an srb which is processed normally by the port driver.
    This call is synchornous.

Arguments:

    DeviceExtension - Supplies a pointer the SCSI adapter device extension.

    RequestIrp - Supplies a pointe to the Irp which made the original request.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/

{
    PIO_STACK_LOCATION      irpStack;
    PATA_PASS_THROUGH       ataPassThroughData;
    ULONG                   dataBufferSize;
    BOOLEAN                 dataIn;
    NTSTATUS                status;
    ULONG                   outputBufferSize;

    PAGED_CODE();

    DebugPrint((3,"IdePortSendPassThrough: Enter routine\n"));

    //
    // validate target device
    //
    if (PdoExtension->Lun != 0) {

        return STATUS_INVALID_DEVICE_REQUEST;
    }

    //
    // Get a pointer to the control block.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    ataPassThroughData = Irp->AssociatedIrp.SystemBuffer;

    //
    // Validiate the user buffer.
    //
    if (irpStack->Parameters.DeviceIoControl.InputBufferLength < 
        FIELD_OFFSET(ATA_PASS_THROUGH, DataBuffer)) {

        return STATUS_INVALID_PARAMETER;
    }

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength < 
        FIELD_OFFSET(ATA_PASS_THROUGH, DataBuffer)) {

        return STATUS_INVALID_PARAMETER;
    }

    ASSERT(ataPassThroughData != NULL);

    dataBufferSize = ataPassThroughData->DataBufferSize;

    outputBufferSize = FIELD_OFFSET(ATA_PASS_THROUGH, DataBuffer) + dataBufferSize;

    if (outputBufferSize < dataBufferSize) {

        //
        // outputBufferSize overflows a ULONG
        //
        outputBufferSize = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    }

    //
    // SECURITY: This should be fixed. If the output buffer size is larger
    // than the output buffer length, we could potentially bugcheck.
    //
    if ((irpStack->Parameters.DeviceIoControl.OutputBufferLength) >=
        outputBufferSize) {

        dataIn = TRUE;

    } else {

        dataIn = FALSE;
    }

    status = IssueSyncAtaPassThroughSafe (
                 PdoExtension->ParentDeviceExtension,
                 PdoExtension,
                 ataPassThroughData,
                 dataIn,
                 FALSE,
                 DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                 FALSE
                 );

    if (NT_SUCCESS(status)) {

        //
        // SECURITY: verify that we always copy outpubuffersize
        // data in the SUCCESS case
        //
        Irp->IoStatus.Information = outputBufferSize;

    } else {

        //
        // ignore all errors
        // let the caller figure out the error
        // from the task file registers
        //
        status = STATUS_SUCCESS;
        Irp->IoStatus.Information = FIELD_OFFSET(ATA_PASS_THROUGH, DataBuffer);
    }

    Irp->IoStatus.Status = status;
    return status;

} // IdeSendIdePassThrough

VOID
DeviceRegisterIdleDetection (
    IN PPDO_EXTENSION PdoExtension,
    IN ULONG ConservationIdleTime,
    IN ULONG PerformanceIdleTime
)
{
    NTSTATUS          status;
    ATA_PASS_THROUGH  ataPassThroughData;

    //
    // Many ATAPI device (Acer and Panasonice Changer) doesn't like ATA
    // power down command.  Since they auto-spin-down anyway, we are not
    // go to power manage it
    //
    if (!(PdoExtension->PdoState & PDOS_NO_POWER_DOWN)) {

        if (!PdoExtension->CrashDumpPathCount) {

            RtlZeroMemory (&ataPassThroughData, sizeof(ataPassThroughData));
            ataPassThroughData.IdeReg.bCommandReg = IDE_COMMAND_IDLE_IMMEDIATE;
            ataPassThroughData.IdeReg.bReserved = ATA_PTFLAGS_STATUS_DRDY_REQUIRED;

            status = IssueSyncAtaPassThroughSafe (
                         PdoExtension->ParentDeviceExtension,
                         PdoExtension,
                         &ataPassThroughData,
                         FALSE,
                         FALSE,
                         DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                         FALSE
                         );

            if (NT_SUCCESS(status)) {

                DEVICE_POWER_STATE devicePowerState;

                //
                // ISSUE
                // should check the registry/device property whether
                // idle detection has been disabled for this device
                //
                devicePowerState = PowerDeviceD3;
                PdoExtension->IdleCounter = PoRegisterDeviceForIdleDetection (
                                                PdoExtension->DeviceObject,
                                                ConservationIdleTime,            // seconds
                                                PerformanceIdleTime,             // seconds
                                                devicePowerState
                                                );

                DebugPrint ((1, "IdePort: pdoExtension 0x%x support power managerment command\n", PdoExtension));

            } else {

                KIRQL             currentIrql;

                KeAcquireSpinLock(&PdoExtension->PdoSpinLock, &currentIrql);

                SETMASK (PdoExtension->PdoState, PDOS_NO_POWER_DOWN);

                KeReleaseSpinLock(&PdoExtension->PdoSpinLock, currentIrql);

                DebugPrint ((1, "IdePort: pdoExtension 0x%x DOES NOT support power managerment command\n", PdoExtension));
            }
        }
    }

    return;
}

VOID
DeviceUnregisterIdleDetection (
    IN PPDO_EXTENSION PdoExtension
)
{
    DEVICE_POWER_STATE devicePowerState;
    devicePowerState = PowerDeviceD3;

    if (PdoExtension->IdleCounter) {

        PoRegisterDeviceForIdleDetection (
            PdoExtension->DeviceObject,
            0,
            0,
            devicePowerState
            );

        PdoExtension->IdleCounter = NULL;
    }
    return;
}

VOID
DeviceInitIdStrings (
    IN PPDO_EXTENSION PdoExtension,
    IN IDE_DEVICETYPE DeviceType,
    IN PINQUIRYDATA   InquiryData,
    IN PIDENTIFY_DATA IdentifyData
)
{
    LONG i;
    UCHAR c;

    SPECIAL_ACTION_FLAG specialFlags;

	PAGED_CODE();

    ASSERT (PdoExtension);
    ASSERT (IdentifyData);

    if (DeviceType == DeviceIsAta) {

        CopyField(
            PdoExtension->FullVendorProductId,
            IdentifyData->ModelNumber,
            sizeof(PdoExtension->FullVendorProductId)-1,
            ' '
            );

        CopyField(
            PdoExtension->FullProductRevisionId,
            IdentifyData->FirmwareRevision,
            sizeof(PdoExtension->FullProductRevisionId)-1,
            ' '
            );

        //
        // byte swap
        //
        for (i=0; i<sizeof(PdoExtension->FullVendorProductId)-1; i+=2) {
            c = PdoExtension->FullVendorProductId[i];
            PdoExtension->FullVendorProductId[i] = PdoExtension->FullVendorProductId[i + 1];
            PdoExtension->FullVendorProductId[i + 1] = c;
        }
        for (i=0; i<sizeof(PdoExtension->FullProductRevisionId)-1; i+=2) {
            c = PdoExtension->FullProductRevisionId[i];
            PdoExtension->FullProductRevisionId[i] = PdoExtension->FullProductRevisionId[i + 1];
            PdoExtension->FullProductRevisionId[i + 1] = c;
        }

    } else if (DeviceType == DeviceIsAtapi) {

        PUCHAR fullVendorProductId;

        fullVendorProductId = PdoExtension->FullVendorProductId;

        CopyField(
            fullVendorProductId,
            InquiryData->VendorId,
            8,
            ' '
            );

        for (i=7; i >= 0; i--) {

            if (fullVendorProductId[i] != ' ') {

                fullVendorProductId[i + 1] = ' ';
                fullVendorProductId += i + 2;
                break;
            }
        }

        CopyField(
            fullVendorProductId,
            InquiryData->ProductId,
            16,
            ' '
            );

        fullVendorProductId += 16;

        for (i=0; fullVendorProductId+i < PdoExtension->FullVendorProductId+40; i++) {
            fullVendorProductId[i] = ' ';
        }

        CopyField(
            PdoExtension->FullProductRevisionId,
            InquiryData->ProductRevisionLevel,
            4,
            ' '
            );

        for (i=4; i<8; i++) {
            PdoExtension->FullProductRevisionId[i] = ' ';
        }

    } else {

        ASSERT (FALSE);
    }

    //
    // take out trailing spaces
    //
    for (i=sizeof(PdoExtension->FullVendorProductId)-2; i >= 0; i--) {

        if (PdoExtension->FullVendorProductId[i] != ' ') {

            PdoExtension->FullVendorProductId[i+1] = '\0';
            break;
        }
    }

    for (i=sizeof(PdoExtension->FullProductRevisionId)-2; i >= 0; i--) {

        if (PdoExtension->FullProductRevisionId[i] != ' ') {

            PdoExtension->FullProductRevisionId[i+1] = '\0';
            break;
        }
    }

    //
    // Check the vendor & product id to see if we should disable the serial
    // number for this device.
    //

    specialFlags = IdeFindSpecialDevice(PdoExtension->FullVendorProductId,
                                        PdoExtension->FullProductRevisionId);

    //
    // look for serial number
    //
    // some device returns non-printable characters as part of its
    // serial number.  to get around this, we will turn all raw numbers
    // into a string.
    //
    if ((specialFlags != disableSerialNumber) &&
        (IdentifyData->SerialNumber[0] != ' ') &&
        (IdentifyData->SerialNumber[0] != '\0')) {

        for (i=0; i<sizeof(IdentifyData->SerialNumber); i++) {

            sprintf (PdoExtension->FullSerialNumber+i*2, "%2x", IdentifyData->SerialNumber[i]);
        }

        PdoExtension->FullSerialNumber[sizeof(PdoExtension->FullSerialNumber) - 1] = '\0';

    } else {

        PdoExtension->FullSerialNumber[0] = '\0';
    }

    DebugPrint ((
        DBG_BUSSCAN,
        "PDOE 0x%x: Full IDs \n\t%s\n\t%s\n\t%s\n",
        PdoExtension,
        PdoExtension->FullVendorProductId,
        PdoExtension->FullProductRevisionId,
        PdoExtension->FullSerialNumber
        ));

    return;
}

VOID
DeviceInitDeviceType (
    IN PPDO_EXTENSION PdoExtension,
    IN PINQUIRYDATA   InquiryData
)
{
    PdoExtension->ScsiDeviceType = InquiryData->DeviceType;

    if(InquiryData->RemovableMedia) {

        SETMASK (PdoExtension->DeviceObject->Characteristics, FILE_REMOVABLE_MEDIA);
    }

    return;
}

NTSTATUS
DeviceQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  thisIrpSp;
    PDEVICE_RELATIONS   deviceRelations;
    NTSTATUS            status;

    IDE_PATH_ID         pathId;
    PPDO_EXTENSION      pdoExtension;
    PPDO_EXTENSION      otherPdoExtension;
    ULONG               numPdos;

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

    switch (thisIrpSp->Parameters.QueryDeviceRelations.Type) {

        case TargetDeviceRelation:

            deviceRelations = ExAllocatePool (
                                  NonPagedPool,
                                  sizeof(*deviceRelations) +
                                    sizeof(deviceRelations->Objects[0]) * 1
                                  );

            if (deviceRelations != NULL) {

                deviceRelations->Count = 1;
                deviceRelations->Objects[0] = DeviceObject;

                ObReferenceObjectByPointer(DeviceObject,
                                           0,
                                           0,
                                           KernelMode);

                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
            } else {

                Irp->IoStatus.Status = STATUS_NO_MEMORY;
                Irp->IoStatus.Information = 0;
            }
            break;
    }

    status = Irp->IoStatus.Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // DeviceQueryDeviceRelations

NTSTATUS
DeviceQueryInitData (
    IN PPDO_EXTENSION PdoExtension
    )
{
    PDEVICE_SETTINGS deviceSettings;
    PDEVICE_SETTINGS tempDeviceSettings;
    NTSTATUS status;
    ATA_PASS_THROUGH ataPassThroughData;

    PPDO_EXTENSION   lun0PdoExtension;
    ULONG totalDeviceSettingEntries;
    ULONG firstNewEntryOffset;

	PAGED_CODE();

    DebugPrint ((
        DBG_PNP,
        "DeviceQueryInitData: Init. pdoe 0x%x (%d,%d,%d)\n",
        PdoExtension,
        PdoExtension->PathId,
        PdoExtension->TargetId,
        PdoExtension->Lun
        ));

    deviceSettings = PdoExtension->AcpiDeviceSettings;
    if (deviceSettings == NULL) {

        //
        // ISSUE: we can't be sure acpi is always attached on lun0
        //
        // get the lun0 pdo
        //
        lun0PdoExtension = RefLogicalUnitExtensionWithTag(
                               PdoExtension->ParentDeviceExtension,
                               PdoExtension->PathId,
                               PdoExtension->TargetId,
                               0,
                               TRUE,
                               DeviceQueryInitData
                               );

        if (lun0PdoExtension) {

            ASSERT (lun0PdoExtension->TargetId == PdoExtension->TargetId);

            status = DeviceQueryFirmwareBootSettings (
                         lun0PdoExtension,
                         &deviceSettings
                         );

            //
            // let go Lun0
            //
            UnrefPdoWithTag(
                lun0PdoExtension,
                DeviceQueryInitData
                );
        }

        if (deviceSettings) {

            ULONG i;
            ULONG j;

            for (i=0; i<deviceSettings->NumEntries; i++) {

                //
                // Ignore SET_DRIVE_PARAMETERS, SET_MULTIPLE and set transfermode commands
                // in GTF
                //
                if (((deviceSettings->FirmwareSettings[i].bCommandReg == IDE_COMMAND_SET_FEATURE) &&
                     (deviceSettings->FirmwareSettings[i].bFeaturesReg == IDE_SET_FEATURE_SET_TRANSFER_MODE)) ||
                    (deviceSettings->FirmwareSettings[i].bCommandReg == IDE_COMMAND_SET_DRIVE_PARAMETERS) ||
                    (deviceSettings->FirmwareSettings[i].bCommandReg == IDE_COMMAND_SET_MULTIPLE)) {

                    DebugPrint((DBG_ACPI,
                                "Ignoring Command %xin GTF\n",
                                deviceSettings->FirmwareSettings[i].bCommandReg
                                ));

                    deviceSettings->NumEntries--;

                    //
                    // remove this command by shifting the rest up one entry
                    //
                    for (j=i; j<deviceSettings->NumEntries; j++) {

                        deviceSettings->FirmwareSettings[j] = deviceSettings->FirmwareSettings[j+1];
                    }

                    //
                    // we move something new into the current i entry
                    // better adjust i so that we will check this entry
                    // again
                    //
                    if (i < deviceSettings->NumEntries) {
                        i--;
                    }
                }


            }
        }

        //
        // we need to add a new setting
        //
        if (PdoExtension->ScsiDeviceType == DIRECT_ACCESS_DEVICE) {
            totalDeviceSettingEntries = 2;
        } else {
            totalDeviceSettingEntries = 1;
        }

        if (deviceSettings) {
            totalDeviceSettingEntries += deviceSettings->NumEntries;
            firstNewEntryOffset = deviceSettings->NumEntries;
        } else {
            firstNewEntryOffset = 0;
        }

        tempDeviceSettings = ExAllocatePool (
                                  NonPagedPool,
                                  sizeof(DEVICE_SETTINGS) +
                                    (totalDeviceSettingEntries) * sizeof(IDEREGS)
                                  );

        if (tempDeviceSettings) {

            tempDeviceSettings->NumEntries = totalDeviceSettingEntries;

            //
            // copy the settings from acpi query
            //
            if (deviceSettings) {
                RtlCopyMemory (&tempDeviceSettings->FirmwareSettings,
                    &deviceSettings->FirmwareSettings,
                    sizeof(IDEREGS) * deviceSettings->NumEntries);

                //
                // don't need the old structure anymore
                //
                ExFreePool (deviceSettings);
                deviceSettings = NULL;
            }

            //
            // add the new settings
            //
            RtlZeroMemory (
                &tempDeviceSettings->FirmwareSettings[firstNewEntryOffset],
                sizeof (IDEREGS));
            tempDeviceSettings->FirmwareSettings[firstNewEntryOffset].bFeaturesReg =
                IDE_SET_FEATURE_DISABLE_REVERT_TO_POWER_ON;
            tempDeviceSettings->FirmwareSettings[firstNewEntryOffset].bCommandReg =
                IDE_COMMAND_SET_FEATURE;
            tempDeviceSettings->FirmwareSettings[firstNewEntryOffset].bReserved =
                ATA_PTFLAGS_STATUS_DRDY_REQUIRED | ATA_PTFLAGS_OK_TO_FAIL;

            if (PdoExtension->ScsiDeviceType == DIRECT_ACCESS_DEVICE) {

                RtlZeroMemory (
                    &tempDeviceSettings->FirmwareSettings[firstNewEntryOffset + 1],
                    sizeof (IDEREGS));
                tempDeviceSettings->FirmwareSettings[firstNewEntryOffset + 1].bFeaturesReg =
                    IDE_SET_FEATURE_ENABLE_WRITE_CACHE;
                tempDeviceSettings->FirmwareSettings[firstNewEntryOffset + 1].bCommandReg =
                    IDE_COMMAND_SET_FEATURE;
                tempDeviceSettings->FirmwareSettings[firstNewEntryOffset + 1].bReserved =
                    ATA_PTFLAGS_STATUS_DRDY_REQUIRED | ATA_PTFLAGS_OK_TO_FAIL;
            }

            //
            // throw away the old and keep the new
            //
            deviceSettings = tempDeviceSettings;

        } else {

            //
            // someone took all the memory.
            // we can't build a new device setting structure
            // will have to use the old one
            //
        }

        //
        // keep it around
        //
        PdoExtension->AcpiDeviceSettings = deviceSettings;

    }

    return STATUS_SUCCESS;
}

NTSTATUS
DeviceInitDeviceState (
    IN PPDO_EXTENSION PdoExtension,
    DEVICE_INIT_COMPLETION DeviceInitCompletionRoutine,
    PVOID DeviceInitCompletionContext
    )
{
    PDEVICE_SETTINGS deviceSettings;
    NTSTATUS status;
    PDEVICE_INIT_DEVICE_STATE_CONTEXT deviceStateContext;
    ULONG deviceStateContextSize;
    ULONG numState;
    ULONG numRequestSent;
    DEVICE_INIT_STATE deviceInitState[deviceInitState_done];

    if (!InterlockedExchange (&PdoExtension->InitDeviceWithAcpiGtf, 0)) {

        //
        // make sure we only do this once per start
        //
        return STATUS_SUCCESS;
    }

    if (!(PdoExtension->PdoState & PDOS_STARTED)) {

        DebugPrint ((DBG_PNP, "DeviceInitDeviceState: device not started...skipping acpi init\n"));

        (DeviceInitCompletionRoutine) (
            DeviceInitCompletionContext,
            STATUS_SUCCESS
            );

        return STATUS_SUCCESS;
    }

    deviceStateContextSize = sizeof (DEVICE_INIT_DEVICE_STATE_CONTEXT);

    deviceStateContext = ExAllocatePool (NonPagedPool, deviceStateContextSize);
    if (deviceStateContext == NULL) {

        return STATUS_NO_MEMORY;
    }

    if (!RefPdoWithTag(PdoExtension->DeviceObject, FALSE, DeviceInitDeviceState)) {
        ExFreePool (deviceStateContext);
        return STATUS_NO_SUCH_DEVICE;
    }

    RtlZeroMemory(
        deviceStateContext,
        deviceStateContextSize
        );

    deviceSettings = PdoExtension->AcpiDeviceSettings;

    //
    // compute the total number of inti state we are going to have
    //
    numState = 0;
    if (deviceSettings) {

        deviceStateContext->DeviceInitState[numState] = deviceInitState_acpi;
        numState++;
    }
    deviceStateContext->DeviceInitState[numState] = deviceInitState_done;
    numState++;

    ASSERT(numState <= deviceInitState_max);

    deviceStateContext->PdoExtension = PdoExtension;
    deviceStateContext->NumInitState = numState;
    deviceStateContext->DeviceInitCompletionRoutine = DeviceInitCompletionRoutine;
    deviceStateContext->DeviceInitCompletionContext = DeviceInitCompletionContext;

    DeviceInitDeviceStateCompletionRoutine (
        PdoExtension->DeviceObject,
        deviceStateContext,
        STATUS_SUCCESS
        );

    return STATUS_PENDING;
} // DeviceInitDeviceState

VOID
DeviceInitDeviceStateCompletionRoutine (
    PDEVICE_OBJECT DeviceObject,
    PVOID Context,
    NTSTATUS Status
    )
{
    ULONG numRequestCompleted;
    PDEVICE_INIT_DEVICE_STATE_CONTEXT deviceStateContext = Context;
    PDEVICE_SETTINGS deviceSettings;
    PPDO_EXTENSION PdoExtension;
    NTSTATUS status;

    if (!NT_SUCCESS(Status)) {

        InterlockedIncrement (&deviceStateContext->NumRequestFailed);
        DebugPrint ((DBG_ALWAYS, "DeviceInitDeviceStateCompletionRoutine: Last init. command failed with status %x\n",
                        Status));
    }

    PdoExtension = deviceStateContext->PdoExtension;
    switch (deviceStateContext->DeviceInitState[deviceStateContext->CurrentState]) {

        case deviceInitState_acpi:

        deviceSettings = PdoExtension->AcpiDeviceSettings;
        ASSERT (deviceSettings);

        RtlZeroMemory (
            &deviceStateContext->AtaPassThroughData,
            sizeof(deviceStateContext->AtaPassThroughData)
            );

        deviceStateContext->AtaPassThroughData.IdeReg =
            deviceSettings->FirmwareSettings[deviceStateContext->NumAcpiRequestSent];

        deviceStateContext->AtaPassThroughData.IdeReg.bReserved |=
            ATA_PTFLAGS_STATUS_DRDY_REQUIRED | ATA_PTFLAGS_URGENT;

        deviceStateContext->NumAcpiRequestSent++;
        if (deviceStateContext->NumAcpiRequestSent >= deviceSettings->NumEntries) {
            //
            // sent all acpi init state.  go to the next state
            //
            deviceStateContext->CurrentState++;
        }

        if ((deviceStateContext->AtaPassThroughData.IdeReg.bFeaturesReg ==
             IDE_SET_FEATURE_ENABLE_WRITE_CACHE) &&
            (deviceStateContext->AtaPassThroughData.IdeReg.bCommandReg ==
             IDE_COMMAND_SET_FEATURE)) {

            //
            // only ata harddisk should have this entry
            //
            ASSERT (PdoExtension->ScsiDeviceType == DIRECT_ACCESS_DEVICE);

            if (PdoExtension->WriteCacheEnable == FALSE) {

                deviceStateContext->AtaPassThroughData.IdeReg.bFeaturesReg =
                    IDE_SET_FEATURE_DISABLE_WRITE_CACHE;
            }
        }


        DebugPrint ((
            DBG_PNP,
            "IdePort: restore firmware settings from ACPI BIOS. ide command = 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x 0x%x\n",
            deviceStateContext->AtaPassThroughData.IdeReg.bFeaturesReg,
            deviceStateContext->AtaPassThroughData.IdeReg.bSectorCountReg,
            deviceStateContext->AtaPassThroughData.IdeReg.bSectorNumberReg,
            deviceStateContext->AtaPassThroughData.IdeReg.bCylLowReg,
            deviceStateContext->AtaPassThroughData.IdeReg.bCylHighReg,
            deviceStateContext->AtaPassThroughData.IdeReg.bDriveHeadReg,
            deviceStateContext->AtaPassThroughData.IdeReg.bCommandReg
            ));

        status = IssueAsyncAtaPassThroughSafe (
                    PdoExtension->ParentDeviceExtension,
                    PdoExtension,
                    &deviceStateContext->AtaPassThroughData,
                    TRUE,
                    DeviceInitDeviceStateCompletionRoutine,
                    deviceStateContext,
                    FALSE,
                    DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                    FALSE
                    );
        if (!NT_SUCCESS(status)) {

            //
            // can't send the request
            // notify the completion routine that we fail
            //
            DeviceInitDeviceStateCompletionRoutine (
                PdoExtension->DeviceObject,
                deviceStateContext,
                status
                );
        }
        break;

        case deviceInitState_done:

        //
        // notify the original caller w/ error if any
        //
        (*deviceStateContext->DeviceInitCompletionRoutine) (
            deviceStateContext->DeviceInitCompletionContext,
            deviceStateContext->NumRequestFailed ?
                STATUS_UNSUCCESSFUL :
                STATUS_SUCCESS
            );

        UnrefPdoWithTag(
            deviceStateContext->PdoExtension,
            DeviceInitDeviceState
            );

        ExFreePool (deviceStateContext);
        break;

        default:
        ASSERT(FALSE);
    }

    return;
}

NTSTATUS
DeviceIdeReadCapacity (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PIRP Irp
)
{
    NTSTATUS status;
    PIDE_READ_CAPACITY_CONTEXT context;
    PATA_PASS_THROUGH ataPassThroughData;
    ULONG dataSize;
    PUCHAR dataOffset;
    PHW_DEVICE_EXTENSION hwDeviceExtension=PdoExtension->ParentDeviceExtension->HwDeviceExtension;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;

    //
    // Check for device present flag
    //
    if (!(hwDeviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_DEVICE_PRESENT)) {

        srb->SrbStatus = SRB_STATUS_NO_DEVICE;

        UnrefLogicalUnitExtensionWithTag(
            PdoExtension->ParentDeviceExtension,
            PdoExtension,
            Irp
            );

        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
    }

    context = ExAllocatePool (
                 NonPagedPool,
                 sizeof(IDE_READ_CAPACITY_CONTEXT)
                 );
    if ((context == NULL) || (Irp->MdlAddress == NULL)) {

        if (context) {
            ExFreePool(context);
        }

        UnrefLogicalUnitExtensionWithTag(
            PdoExtension->ParentDeviceExtension,
            PdoExtension,
            Irp
            );

        srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        srb->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;

        IdeLogNoMemoryError(PdoExtension->ParentDeviceExtension,
                            PdoExtension->TargetId,
                            NonPagedPool,
                            sizeof(IDE_READ_CAPACITY_CONTEXT),
                            IDEPORT_TAG_READCAP_CONTEXT
                            );

        Irp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // save the old data buffer for restoring later
    //
    context->OldDataBuffer = srb->DataBuffer;
    context->GeometryIoctl=FALSE;

    //
    // map the buffer in
    //
    dataOffset = MmGetSystemAddressForMdlSafe(Irp->MdlAddress, HighPagePriority);
    srb->DataBuffer = dataOffset +
        (ULONG)((PUCHAR)srb->DataBuffer -
        (PCCHAR)MmGetMdlVirtualAddress(Irp->MdlAddress));

    context->PdoExtension = PdoExtension;
    context->OriginalIrp = Irp;

    // MdlSafe failed

    if (dataOffset == NULL) {

        IdeLogNoMemoryError(PdoExtension->ParentDeviceExtension,
                            PdoExtension->TargetId,
                            NonPagedPool,
                            sizeof(MDL),
                            IDEPORT_TAG_READCAP_MDL
                            );

        DeviceIdeReadCapacityCompletionRoutine (
            PdoExtension->DeviceObject,
            context,
            STATUS_INSUFFICIENT_RESOURCES
            );
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    IoMarkIrpPending(Irp);

    ataPassThroughData = &context->AtaPassThroughData;

    RtlZeroMemory (
        ataPassThroughData,
        sizeof (*ataPassThroughData)
        );

    ataPassThroughData->DataBufferSize = sizeof(IDENTIFY_DATA);

        ataPassThroughData->IdeReg.bCommandReg = IDE_COMMAND_IDENTIFY;
        ataPassThroughData->IdeReg.bReserved = ATA_PTFLAGS_STATUS_DRDY_REQUIRED;

    status = IssueAsyncAtaPassThroughSafe (
                 PdoExtension->ParentDeviceExtension,
                 PdoExtension,
                 ataPassThroughData,
                 TRUE,
                 DeviceIdeReadCapacityCompletionRoutine,
                 context,
                 FALSE,
                 DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                 FALSE
                 );

    if (status != STATUS_PENDING) {

        DeviceIdeReadCapacityCompletionRoutine (
            PdoExtension->DeviceObject,
            context,
            status
            );
    }

    //
    // the irp was marked pending. return status_pending
    //
    return STATUS_PENDING;
}

VOID
DeviceIdeReadCapacityCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    PVOID Context,
    NTSTATUS Status
    )
{
    PIDE_READ_CAPACITY_CONTEXT context = Context;
    PIRP irp = context->OriginalIrp;
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(irp);
    PSCSI_REQUEST_BLOCK srb;
    KIRQL currentIrql;
    PKSPIN_LOCK spinLock;
    ULONG numberOfCylinders;
    ULONG numberOfHeads;
    ULONG sectorsPerTrack;
    PHW_DEVICE_EXTENSION hwDeviceExtension;
    ULONG i;
    ULONG totalCHSSize;
    ULONG targetId;
    PIDENTIFY_DATA identifyData;

    srb = irpStack->Parameters.Scsi.Srb;
    targetId=srb->TargetId;
    hwDeviceExtension = context->PdoExtension->ParentDeviceExtension->HwDeviceExtension;
    spinLock = &context->PdoExtension->ParentDeviceExtension->SpinLock;

    if (NT_SUCCESS(Status)) {

        identifyData = (PIDENTIFY_DATA) context->AtaPassThroughData.DataBuffer;

        IdePortFudgeAtaIdentifyData(
            identifyData
            );

        if ( ((identifyData->MajorRevision == 0) ||
              ((identifyData->NumberOfCurrentCylinders == 0) ||
               (identifyData->NumberOfCurrentHeads == 0) ||
               (identifyData->CurrentSectorsPerTrack == 0))) ) {

            numberOfCylinders = identifyData->NumCylinders;
            numberOfHeads     = identifyData->NumHeads;
            sectorsPerTrack   = identifyData->NumSectorsPerTrack;

        } else {

            numberOfCylinders = identifyData->NumberOfCurrentCylinders;
            numberOfHeads     = identifyData->NumberOfCurrentHeads;
            sectorsPerTrack   = identifyData->CurrentSectorsPerTrack;

            if (identifyData->UserAddressableSectors >
                (numberOfCylinders * numberOfHeads * sectorsPerTrack)) {

                //
                // some ide driver has a 2G jumer to get around bios
                // problem.  make sure we are not tricked the samw way.
                //
                if ((numberOfCylinders <= 0xfff) &&
                    (numberOfHeads == 0x10) &&
                    (sectorsPerTrack == 0x3f)) {

                    numberOfCylinders = identifyData->UserAddressableSectors / (0x10 * 0x3f);
                }
            }

        }

        //
        // Workaround for devices that return 0 in the geometry fields.
        //
        if ((numberOfCylinders == 0) ||
            (numberOfHeads == 0) ||
            (sectorsPerTrack == 0)) {

            //
            // round up chs to 1
            //
            numberOfCylinders = 1;
            numberOfHeads = 1;
            sectorsPerTrack =1;
            totalCHSSize = 0;

        } else {

            totalCHSSize = (numberOfHeads * numberOfCylinders * sectorsPerTrack);

        }

        //
        // update the HW Device Extension Data
        //
        KeAcquireSpinLock(spinLock, &currentIrql);

        InitDeviceGeometry(
            hwDeviceExtension,
            targetId,
            numberOfCylinders,
            numberOfHeads,
            sectorsPerTrack
            );

        if (hwDeviceExtension->DeviceFlags[targetId] & DFLAGS_IDENTIFY_INVALID) {

                RtlMoveMemory (
                    hwDeviceExtension->IdentifyData + targetId,
                    identifyData,
                    sizeof (IDENTIFY_DATA)
                    );
             
                ASSERT(!(hwDeviceExtension->DeviceFlags[targetId] & DFLAGS_REMOVABLE_DRIVE));

                SETMASK(hwDeviceExtension->DeviceFlags[targetId], DFLAGS_IDENTIFY_VALID);
                CLRMASK(hwDeviceExtension->DeviceFlags[targetId], DFLAGS_IDENTIFY_INVALID);
        }

        if (srb) {
            //
            // Claim 512 byte blocks (big-endian).
            //
            ((READ_CAPACITY_DATA UNALIGNED *)srb->DataBuffer)->BytesPerBlock = 0x20000;

            //
            // Calculate last sector.
            //
            if (context->PdoExtension->ParentDeviceExtension->
                HwDeviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_LBA) {
                // LBA device
                i = identifyData->UserAddressableSectors - 1;

				//
				// LBAs can only be 28 bits wide
				//
				if (i >= MAX_28BIT_LBA) {
					i = MAX_28BIT_LBA - 1;
				}

#ifdef ENABLE_48BIT_LBA
				if (context->PdoExtension->ParentDeviceExtension->
					HwDeviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_48BIT_LBA) {

					i = identifyData->Max48BitLBA[0] - 1;

					//
					// currently we support only upto 32 bits.
					//
					ASSERT(identifyData->Max48BitLBA[1] == 0);
				}
#endif
                DebugPrint((1,
                        "IDE LBA disk %x - total # of sectors = 0x%x\n",
                        srb->TargetId,
                        identifyData->UserAddressableSectors));

            } else {

                // CHS device
                //i = (numberOfHeads * numberOfCylinders * sectorsPerTrack) - 1;
                i=totalCHSSize - 1;

                DebugPrint((1,
                        "IDE CHS disk %x - #sectors %x, #heads %x, #cylinders %x\n",
                        srb->TargetId,
                        sectorsPerTrack,
                        numberOfHeads,
                        numberOfCylinders));
                DebugPrint((1,
                        "IDE CHS disk Identify data%x - #sectors %x, #heads %x, #cylinders %x\n",
                        srb->TargetId,
                        identifyData->NumSectorsPerTrack,
                        identifyData->NumHeads,
                        identifyData->NumCylinders));
                DebugPrint((1,
                        "IDE CHS disk Identify currentdata%x - #sectors %x, #heads %x, #cylinders %x\n",
                        srb->TargetId,
                        identifyData->CurrentSectorsPerTrack,
                        identifyData->NumberOfCurrentHeads,
                        identifyData->NumberOfCurrentCylinders));
            }

            ((READ_CAPACITY_DATA UNALIGNED *)srb->DataBuffer)->LogicalBlockAddress =
            (((PUCHAR)&i)[0] << 24) |  (((PUCHAR)&i)[1] << 16) |
            (((PUCHAR)&i)[2] << 8) | ((PUCHAR)&i)[3];

            srb->SrbStatus = SRB_STATUS_SUCCESS;

			irp->IoStatus.Information = sizeof(READ_CAPACITY_DATA);

        }

        KeReleaseSpinLock(spinLock, currentIrql);

    } else {

        if (srb) {
            if (Status==STATUS_INSUFFICIENT_RESOURCES) {
                srb->SrbStatus=SRB_STATUS_INTERNAL_ERROR;
                srb->InternalStatus=STATUS_INSUFFICIENT_RESOURCES;
            }
            else {
                srb->SrbStatus = SRB_STATUS_ERROR;
            }
        }
    }


    if (srb) {

        //
        // restoring DataBuffer
        //
        srb->DataBuffer = context->OldDataBuffer;
    }

    UnrefLogicalUnitExtensionWithTag(
        context->PdoExtension->ParentDeviceExtension,
        context->PdoExtension,
        irp
        );

    IDEPORT_PUT_LUNEXT_IN_IRP (irpStack, NULL);

    ExFreePool (context);

    irp->IoStatus.Status = Status;
    IoCompleteRequest(irp, IO_NO_INCREMENT);
    return;
}


NTSTATUS
DeviceIdeModeSense (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PIRP Irp
)
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;
    PCDB cdb;
    ULONG modeDataBufferSize;
    ULONG dataBufferSize;
    ULONG dataBufferByteLeft;
    PMODE_PARAMETER_HEADER modePageHeader;
    PUCHAR pageData;
    PHW_DEVICE_EXTENSION hwDeviceExtension;

    PAGED_CODE();

    hwDeviceExtension = PdoExtension->ParentDeviceExtension->HwDeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    srb      = irpStack->Parameters.Scsi.Srb;
    cdb      = (PCDB) srb->Cdb;

    //
    // Check for device present flag
    //
    if (!(hwDeviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_DEVICE_PRESENT)) {

        srb->SrbStatus = SRB_STATUS_NO_DEVICE;

        UnrefLogicalUnitExtensionWithTag(
            PdoExtension->ParentDeviceExtension,
            PdoExtension,
            Irp
            );

        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
    }

    ASSERT(cdb->MODE_SENSE.OperationCode == SCSIOP_MODE_SENSE);

    //
    // make sure this is for the right lun
    //
    if (cdb->MODE_SENSE.LogicalUnitNumber != PdoExtension->Lun) {

        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto getout;
    }

    //
    // only support page control for current values
    //
    if (cdb->MODE_SENSE.Pc != 0) {

        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto getout;
    }

    //
    // save the data buffer size for later use
    //
    modeDataBufferSize = srb->DataTransferLength;

    //
    // make sure the output buffer is at least the size of the header
    //
    if (modeDataBufferSize < sizeof(MODE_PARAMETER_HEADER)) {

        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        status = STATUS_BUFFER_TOO_SMALL;
        goto getout;
    }

    //
    // some basic init.
    //
    modePageHeader = srb->DataBuffer;
    pageData = (PUCHAR) (modePageHeader + 1);
    RtlZeroMemory (modePageHeader, modeDataBufferSize);
    ASSERT (modeDataBufferSize);
    ASSERT (modePageHeader);

    modePageHeader->ModeDataLength = sizeof(MODE_PARAMETER_HEADER) -
        FIELD_OFFSET(MODE_PARAMETER_HEADER, MediumType);

    //
    // get write protect bit from smart data
    //
    if (hwDeviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED) {

        ATA_PASS_THROUGH ataPassThroughData;
        NTSTATUS localStatus;

        RtlZeroMemory (
            &ataPassThroughData,
            sizeof (ataPassThroughData)
            );

        ataPassThroughData.IdeReg.bCommandReg = IDE_COMMAND_GET_MEDIA_STATUS;
        ataPassThroughData.IdeReg.bReserved = ATA_PTFLAGS_STATUS_DRDY_REQUIRED;
    
        localStatus = IssueSyncAtaPassThroughSafe (
                         PdoExtension->ParentDeviceExtension,
                         PdoExtension,
                         &ataPassThroughData,
                         FALSE,
                         FALSE,
                         DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                         FALSE);
    
        if (ataPassThroughData.IdeReg.bCommandReg & IDE_STATUS_ERROR) {

            if (ataPassThroughData.IdeReg.bFeaturesReg & IDE_ERROR_DATA_ERROR){

               modePageHeader->DeviceSpecificParameter |= MODE_DSP_WRITE_PROTECT;
            }
        }
    }

    dataBufferByteLeft = modeDataBufferSize - sizeof(MODE_PARAMETER_HEADER);

    if ((cdb->MODE_SENSE.PageCode == MODE_SENSE_RETURN_ALL) ||
        (cdb->MODE_SENSE.PageCode == MODE_PAGE_CACHING)) {

        if (dataBufferByteLeft >= sizeof(MODE_CACHING_PAGE)) {

            //
            // cache settings page
            //

            PMODE_CACHING_PAGE cachePage;

            cachePage = (PMODE_CACHING_PAGE) pageData;

            cachePage->PageCode = MODE_PAGE_CACHING;
            cachePage->PageSavable = 0;
            cachePage->PageLength = 0xa;
            cachePage->ReadDisableCache = 0;
            cachePage->WriteCacheEnable = PdoExtension->WriteCacheEnable;

            //
            // update out data buffer pointer
            //
            pageData += sizeof (MODE_CACHING_PAGE);
            dataBufferByteLeft -= sizeof (MODE_CACHING_PAGE);
            modePageHeader->ModeDataLength += sizeof (MODE_CACHING_PAGE);

        } else {

            srb->SrbStatus = SRB_STATUS_DATA_OVERRUN;
            srb->DataTransferLength -= dataBufferByteLeft;
            Irp->IoStatus.Information = srb->DataTransferLength;
            status = STATUS_BUFFER_TOO_SMALL;
            goto getout;
        }
    }

    //
    // update the number of bytes we are returning
    //
    srb->DataTransferLength -= dataBufferByteLeft;
    Irp->IoStatus.Information = srb->DataTransferLength;
    status = STATUS_SUCCESS;
    srb->SrbStatus = SRB_STATUS_SUCCESS;

getout:

    UnrefPdoWithTag(
        PdoExtension,
        Irp
        );

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}

NTSTATUS
DeviceIdeModeSelect (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PIRP Irp
)
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;
    PCDB cdb;

    ULONG modeDataBufferSize;
    PMODE_PARAMETER_HEADER modePageHeader;
    PUCHAR modePage;
    ULONG pageOffset;
    PMODE_CACHING_PAGE cachePage;
    PHW_DEVICE_EXTENSION hwDeviceExtension;

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    srb      = irpStack->Parameters.Scsi.Srb;
    cdb      = (PCDB) srb->Cdb;

    hwDeviceExtension = PdoExtension->ParentDeviceExtension->HwDeviceExtension;

    //
    // Check for device present flag
    //
    if (!(hwDeviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_DEVICE_PRESENT)) {

        srb->SrbStatus = SRB_STATUS_NO_DEVICE;

        UnrefLogicalUnitExtensionWithTag(
            PdoExtension->ParentDeviceExtension,
            PdoExtension,
            Irp
            );

        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;

        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return STATUS_NO_SUCH_DEVICE;
    }

    ASSERT(cdb->MODE_SELECT.OperationCode == SCSIOP_MODE_SELECT);

    //
    // make sure this is for the right lun
    //
    if (cdb->MODE_SELECT.LogicalUnitNumber != PdoExtension->Lun) {

        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto getout;
    }

    //
    // only support scsi-2 mode select format
    //
    if (cdb->MODE_SELECT.PFBit != 1) {

        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto getout;
    }

    modeDataBufferSize = cdb->MODE_SELECT.ParameterListLength;
    modePageHeader = srb->DataBuffer;

    if (modeDataBufferSize < sizeof(MODE_PARAMETER_HEADER)) {
        srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto getout;
    }

    pageOffset = sizeof(MODE_PARAMETER_HEADER) + modePageHeader->BlockDescriptorLength;

    while (modeDataBufferSize > pageOffset) {

        modePage = ((PUCHAR) modePageHeader) + pageOffset;
        cachePage = (PMODE_CACHING_PAGE) modePage;

        if ((cachePage->PageCode == MODE_PAGE_CACHING) &&
            ((modePageHeader->ModeDataLength - pageOffset) >= sizeof(MODE_CACHING_PAGE)) &&
            (cachePage->PageLength == 0xa)) {

            if (cachePage->WriteCacheEnable != PdoExtension->WriteCacheEnable) {

                ATA_PASS_THROUGH ataPassThroughData;
                NTSTATUS localStatus;

                RtlZeroMemory (
                    &ataPassThroughData,
                    sizeof (ataPassThroughData)
                    );

                if (cachePage->WriteCacheEnable) {
                    ataPassThroughData.IdeReg.bFeaturesReg = IDE_SET_FEATURE_ENABLE_WRITE_CACHE;
                } else {
                    ataPassThroughData.IdeReg.bFeaturesReg = IDE_SET_FEATURE_DISABLE_WRITE_CACHE;
                }
                ataPassThroughData.IdeReg.bCommandReg = IDE_COMMAND_SET_FEATURE;
                ataPassThroughData.IdeReg.bReserved = ATA_PTFLAGS_STATUS_DRDY_REQUIRED;
                
                localStatus = IssueSyncAtaPassThroughSafe (
                                 PdoExtension->ParentDeviceExtension,
                                 PdoExtension,
                                 &ataPassThroughData,
                                 FALSE,
                                 FALSE,
                                 DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                                 FALSE);
                
                if (NT_SUCCESS(localStatus) &&
                    !(ataPassThroughData.IdeReg.bCommandReg & IDE_STATUS_ERROR)) {

                    PdoExtension->WriteCacheEnable = cachePage->WriteCacheEnable;
                } else {
                    status = STATUS_IO_DEVICE_ERROR;
                    srb->SrbStatus = SRB_STATUS_ERROR;
                    goto getout;
                }

            }

            pageOffset += sizeof(MODE_CACHING_PAGE);

        } else {
            status = STATUS_INVALID_PARAMETER;
            srb->SrbStatus = SRB_STATUS_ERROR;
            goto getout;
        }
    }

    status = STATUS_SUCCESS;
    srb->SrbStatus = SRB_STATUS_SUCCESS;

getout:

    UnrefPdoWithTag(
        PdoExtension,
        Irp
        );

    Irp->IoStatus.Information = 0;
    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}


NTSTATUS
DeviceQueryPnPDeviceState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PPDO_EXTENSION pdoExtension;

    pdoExtension = RefPdoWithTag(
                       DeviceObject,
                       TRUE,
                       DeviceQueryPnPDeviceState
                       );

    if (pdoExtension) {

        PPNP_DEVICE_STATE deviceState;

        DebugPrint((DBG_PNP, "QUERY_DEVICE_STATE for PDOE 0x%x\n", pdoExtension));

        if(pdoExtension->PagingPathCount != 0) {
            deviceState = (PPNP_DEVICE_STATE) &(Irp->IoStatus.Information);
            SETMASK((*deviceState), PNP_DEVICE_NOT_DISABLEABLE);
        }

        status = STATUS_SUCCESS;

        UnrefPdoWithTag(
            pdoExtension,
            DeviceQueryPnPDeviceState
            );

    } else {

        status = STATUS_DEVICE_DOES_NOT_EXIST;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
}

NTSTATUS
DeviceAtapiModeCommandCompletion (
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
/*++

Description

    Completes the original irp after copying the data from the current srb
    
Arguments:

    DeviceObject  Not used
    Irp           The irp - Not used
    Context       Srb
    
Return value:

    STATUS_MORE_PROCESSING_REQUIRED
            
--*/
{
    PIO_STACK_LOCATION irpStack;
    PIDE_MODE_COMMAND_CONTEXT context = Context;
    PSCSI_REQUEST_BLOCK srb = context->Srb;
    PSCSI_REQUEST_BLOCK originalSrb;
    PIRP originalIrp;
    UCHAR bytesAdjust = sizeof(MODE_PARAMETER_HEADER_10) -
                            sizeof(MODE_PARAMETER_HEADER);
    ULONG transferLength;

    //
    // retrieve the original srb and the irp
    //
    originalSrb  = *((PVOID *) (srb+1));
    ASSERT(originalSrb);

    originalIrp = originalSrb->OriginalRequest;
    ASSERT(originalIrp);

    transferLength = srb->DataTransferLength;

    if (srb->Cdb[0] == ATAPI_MODE_SENSE) {

        PMODE_PARAMETER_HEADER_10 header_10 = (PMODE_PARAMETER_HEADER_10)(srb->DataBuffer);
        PMODE_PARAMETER_HEADER header = (PMODE_PARAMETER_HEADER)(originalSrb->DataBuffer);

        header->ModeDataLength = header_10->ModeDataLengthLsb;
        header->MediumType = header_10->MediumType;

        //
        // ATAPI Mode Parameter Header doesn't have these fields.
        //

        header->DeviceSpecificParameter = header_10->Reserved[0];

        //
        // ISSUE: 
        //
        header->BlockDescriptorLength = header_10->Reserved[4];
        
        //
        // copy the rest of the data
        //

        if (transferLength > sizeof(MODE_PARAMETER_HEADER_10)) {

            RtlMoveMemory((PUCHAR)originalSrb->DataBuffer+sizeof(MODE_PARAMETER_HEADER),
                          (PUCHAR)srb->DataBuffer+sizeof(MODE_PARAMETER_HEADER_10),
                          transferLength - sizeof(MODE_PARAMETER_HEADER_10));
        }

        DebugPrint((1,
                    "Mode Sense completed - status 0x%x, length 0x%x\n",
                    srb->SrbStatus,
                    srb->DataTransferLength
                    ));


    } else if (srb->Cdb[0] == ATAPI_MODE_SELECT) {

        DebugPrint((1,
                    "Mode Select completed - status 0x%x, length 0x%x\n",
                    srb->SrbStatus,
                    srb->DataTransferLength
                    ));
    } else {

        ASSERT (FALSE);
    }

    //
    // update the original srb
    //
    originalSrb->DataBuffer = context->OriginalDataBuffer;
    originalSrb->SrbStatus = srb->SrbStatus;
    originalSrb->ScsiStatus = srb->ScsiStatus;

    if (transferLength > bytesAdjust) {
        originalSrb->DataTransferLength = transferLength - bytesAdjust;
    } else {

        //
        // error. transfer length should be zero.
        // if it is less than the header, we will just pass it up.
        //
        originalSrb->DataTransferLength = transferLength;
    }

    //
    // Decrement the logUnitExtension reference count
    //
    irpStack = IoGetCurrentIrpStackLocation(originalIrp);

    UnrefLogicalUnitExtensionWithTag(
        IDEPORT_GET_LUNEXT_IN_IRP(irpStack)->ParentDeviceExtension,
        IDEPORT_GET_LUNEXT_IN_IRP(irpStack),
        originalIrp
        );

    //
    // we will follow the same logic as we did for srb data transfer length.
    //
    if (Irp->IoStatus.Information > bytesAdjust) {
        originalIrp->IoStatus.Information = Irp->IoStatus.Information - bytesAdjust;
    } else {
        originalIrp->IoStatus.Information = Irp->IoStatus.Information;
    }
    originalIrp->IoStatus.Status = Irp->IoStatus.Status;

    DebugPrint((1,
                "Original Mode command completed - status 0x%x, length 0x%x, irpstatus 0x%x\n",
                originalSrb->SrbStatus,
                originalSrb->DataTransferLength,
                originalIrp->IoStatus.Status
                ));

    IoCompleteRequest(originalIrp, IO_NO_INCREMENT);

    //
    // Free the srb, buffer and the irp
    //
    ASSERT(srb->DataBuffer);
    ExFreePool(srb->DataBuffer);

    ExFreePool(srb);

    ExFreePool(context);

    IdeFreeIrpAndMdl(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
DeviceAtapiModeSense (
    IN PPDO_EXTENSION PdoExtension,
    IN PIRP Irp
    )
/*++
--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK originalSrb = irpStack->Parameters.Scsi.Srb;
    PSCSI_REQUEST_BLOCK srb = NULL;
    NTSTATUS status;
    PVOID *pointer;
    PCDB cdb;
    PVOID modeSenseBuffer;
    PUCHAR dataOffset;
    PIDE_MODE_COMMAND_CONTEXT context;
    PMODE_PARAMETER_HEADER_10 header_10; 
    PMODE_PARAMETER_HEADER header;
    UCHAR bytesAdjust = sizeof(MODE_PARAMETER_HEADER_10) -
                            sizeof(MODE_PARAMETER_HEADER);
    USHORT allocationLength;

    IoMarkIrpPending(Irp);

    context = NULL;
    srb = NULL;

    //
    // databuffer should be as big as the header
    //
    if (originalSrb->DataTransferLength < sizeof(MODE_PARAMETER_HEADER)) {

        originalSrb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto GetOut;
    }

    //
    // allocate the context
    //
    context = ExAllocatePool (
                 NonPagedPool,
                 sizeof(IDE_MODE_COMMAND_CONTEXT)
                 );

    if (context == NULL) {

        IdeLogNoMemoryError(PdoExtension->ParentDeviceExtension,
                            PdoExtension->TargetId,
                            NonPagedPool,
                            sizeof(IDE_MODE_COMMAND_CONTEXT),
                            IDEPORT_TAG_ATAPI_MODE_SENSE
                            );

        originalSrb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        originalSrb->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    ASSERT(context);

    context->OriginalDataBuffer = originalSrb->DataBuffer;

    if (Irp->MdlAddress == NULL) {

        originalSrb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        originalSrb->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    //
    // map the buffer in
    //
    dataOffset = MmGetSystemAddressForMdlSafe(Irp->MdlAddress, HighPagePriority);
    originalSrb->DataBuffer = dataOffset +
                                (ULONG)((PUCHAR)originalSrb->DataBuffer -
                                (PCCHAR)MmGetMdlVirtualAddress(Irp->MdlAddress));
    //
    // allocate a new srb
    //
    srb = ExAllocatePool (NonPagedPool, 
                          sizeof (SCSI_REQUEST_BLOCK)+ sizeof(PVOID));

    if (srb == NULL) {

        IdeLogNoMemoryError(PdoExtension->ParentDeviceExtension,
                            PdoExtension->TargetId,
                            NonPagedPool,
                            sizeof(SCSI_REQUEST_BLOCK),
                            IDEPORT_TAG_ATAPI_MODE_SENSE
                            );

        originalSrb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        originalSrb->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    //
    // Save the original SRB after the Srb.
    //
    pointer = (PVOID *) (srb+1);
    *pointer = originalSrb;

    //
    // Fill in SRB fields.
    //
    RtlCopyMemory(srb, originalSrb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Allocate a new buffer
    //
    modeSenseBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                      originalSrb->DataTransferLength + bytesAdjust
                                      );

    RtlZeroMemory(modeSenseBuffer,originalSrb->DataTransferLength+bytesAdjust);
    header_10 = (PMODE_PARAMETER_HEADER_10)modeSenseBuffer;
    header = (PMODE_PARAMETER_HEADER)(originalSrb->DataBuffer);

    header_10->ModeDataLengthLsb = header->ModeDataLength;
    header_10->MediumType = header->MediumType;

    header_10->Reserved[4] = header->BlockDescriptorLength;

    srb->DataBuffer = modeSenseBuffer;
    srb->DataTransferLength = originalSrb->DataTransferLength + bytesAdjust;

    srb->CdbLength = 12;

    allocationLength = ((PCDB)originalSrb->Cdb)->MODE_SENSE.AllocationLength;
    allocationLength += bytesAdjust;

    cdb = (PCDB) srb->Cdb;

    RtlZeroMemory(cdb, sizeof(CDB));

    cdb->MODE_SENSE10.OperationCode          = ATAPI_MODE_SENSE;
    cdb->MODE_SENSE10.LogicalUnitNumber      = ((PCDB)originalSrb->Cdb)->MODE_SENSE.LogicalUnitNumber; 
    cdb->MODE_SENSE10.PageCode               = ((PCDB)originalSrb->Cdb)->MODE_SENSE.PageCode; 
    cdb->MODE_SENSE10.AllocationLength[0]    = (UCHAR) (allocationLength >> 8);
    cdb->MODE_SENSE10.AllocationLength[1]    = (UCHAR) (allocationLength & 0xFF);

    context->Srb = srb;

    //
    // send the srb
    //
    status = IdeBuildAndSendIrp (PdoExtension,
                                 srb,
                                 DeviceAtapiModeCommandCompletion,
                                 context
                                 );

    if (NT_SUCCESS(status)) {

        ASSERT(status == STATUS_PENDING);

        return STATUS_PENDING;
    }

GetOut:

    if (srb) {
        ExFreePool(srb);
    }

    if (context) {

        originalSrb->DataBuffer = context->OriginalDataBuffer;
        ExFreePool(context);
    }

    UnrefLogicalUnitExtensionWithTag(
        PdoExtension->ParentDeviceExtension,
        PdoExtension,
        Irp
        );

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_PENDING;
}

NTSTATUS
DeviceAtapiModeSelect (
    IN PPDO_EXTENSION PdoExtension,
    IN PIRP Irp
    )
/*++
--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK originalSrb = irpStack->Parameters.Scsi.Srb;
    PSCSI_REQUEST_BLOCK srb = NULL;
    NTSTATUS status;
    PVOID *pointer;
    PCDB cdb;
    PVOID modeSelectBuffer;
    PUCHAR dataOffset;
    PIDE_MODE_COMMAND_CONTEXT context;
    PMODE_PARAMETER_HEADER_10 header_10; 
    PMODE_PARAMETER_HEADER header;
    UCHAR bytesToSkip;
    UCHAR bytesAdjust = sizeof(MODE_PARAMETER_HEADER_10) -
                            sizeof(MODE_PARAMETER_HEADER);
    USHORT paramListLength;

    IoMarkIrpPending(Irp);

    context = NULL;
    srb = NULL;

    //
    // the databuffer should be big enough to hold the header
    //
    if (originalSrb->DataTransferLength < sizeof(MODE_PARAMETER_HEADER)) {

        originalSrb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto GetOut;
    }

    header = (PMODE_PARAMETER_HEADER)(originalSrb->DataBuffer);

    //
    // do not copy the block descriptor. Atapi devices don't use
    // the block descriptor.
    //
    bytesToSkip = sizeof(MODE_PARAMETER_HEADER) +
                    header->BlockDescriptorLength;

    //
    // the databuffer should be big enough to hold the header
    // and the block descriptor (specified in the header)
    //
    if (originalSrb->DataTransferLength < bytesToSkip) {

        originalSrb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
        status = STATUS_INVALID_DEVICE_REQUEST;
        goto GetOut;
    }

    //
    // allocate the context
    //
    context = ExAllocatePool (
                 NonPagedPool,
                 sizeof(IDE_MODE_COMMAND_CONTEXT)
                 );

    if (context == NULL) {

        IdeLogNoMemoryError(PdoExtension->ParentDeviceExtension,
                            PdoExtension->TargetId,
                            NonPagedPool,
                            sizeof(IDE_MODE_COMMAND_CONTEXT),
                            IDEPORT_TAG_ATAPI_MODE_SENSE
                            );

        originalSrb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        originalSrb->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    ASSERT(context);

    context->OriginalDataBuffer = originalSrb->DataBuffer;

    if (Irp->MdlAddress == NULL) {

        originalSrb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        originalSrb->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    //
    // map the buffer in
    //
    dataOffset = MmGetSystemAddressForMdlSafe(Irp->MdlAddress, HighPagePriority);
    originalSrb->DataBuffer = dataOffset +
                                (ULONG)((PUCHAR)originalSrb->DataBuffer -
                                (PCCHAR)MmGetMdlVirtualAddress(Irp->MdlAddress));

    //
    // allocate a new srb
    //
    srb = ExAllocatePool (NonPagedPool, 
                          sizeof (SCSI_REQUEST_BLOCK)+ sizeof(PVOID));

    if (srb == NULL) {

        IdeLogNoMemoryError(PdoExtension->ParentDeviceExtension,
                            PdoExtension->TargetId,
                            NonPagedPool,
                            sizeof(SCSI_REQUEST_BLOCK),
                            IDEPORT_TAG_ATAPI_MODE_SENSE
                            );

        originalSrb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
        originalSrb->InternalStatus = STATUS_INSUFFICIENT_RESOURCES;

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    //
    // Save the original SRB after the Srb.
    //
    pointer = (PVOID *) (srb+1);
    *pointer = originalSrb;

    //
    // Fill in SRB fields.
    //
    RtlCopyMemory(srb, originalSrb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Allocate a new buffer (we should subtract the block descriptor length
    // leave it like this for the time being)
    //
    modeSelectBuffer = ExAllocatePool(NonPagedPoolCacheAligned,
                                      originalSrb->DataTransferLength + bytesAdjust
                                      );

    RtlZeroMemory(modeSelectBuffer, sizeof(MODE_PARAMETER_HEADER_10));
    header_10 = (PMODE_PARAMETER_HEADER_10)modeSelectBuffer;

    header_10->ModeDataLengthLsb = header->ModeDataLength;
    header_10->MediumType = header->MediumType;

    //
    // block descriptor length in header_10 should be 0 for ATAPI devices
    //
    //header_10->Reserved[4] = header->BlockDescriptorLength;

    //
    // copy the rest of the buffer, if any
    //
    if (originalSrb->DataTransferLength > bytesToSkip) {

        RtlCopyMemory(((PUCHAR)modeSelectBuffer+sizeof(MODE_PARAMETER_HEADER_10)),
                      ((PUCHAR)originalSrb->DataBuffer + bytesToSkip),
                      (originalSrb->DataTransferLength - bytesToSkip)
                      );
    }

    /*
    RtlCopyMemory(((PUCHAR)modeSelectBuffer+sizeof(MODE_PARAMETER_HEADER_10)),
                  ((PUCHAR)originalSrb->DataBuffer + sizeof(MODE_PARAMETER_HEADER)),
                  (originalSrb->DataTransferLength - sizeof(MODE_PARAMETER_HEADER))
                  );
                  */

    srb->DataBuffer = modeSelectBuffer;
    srb->DataTransferLength = originalSrb->DataTransferLength + 
                                sizeof(MODE_PARAMETER_HEADER_10) - 
                                    bytesToSkip; 

    srb->CdbLength = 12;
    
    paramListLength = ((PCDB)originalSrb->Cdb)->MODE_SELECT.ParameterListLength;
    paramListLength += sizeof(MODE_PARAMETER_HEADER_10);
    paramListLength -= bytesToSkip;

    //
    // fill in the cdb
    //
    cdb = (PCDB) srb->Cdb;

    RtlZeroMemory(cdb, sizeof(CDB));

    cdb->MODE_SELECT10.OperationCode     = ATAPI_MODE_SELECT;
    cdb->MODE_SELECT10.LogicalUnitNumber = ((PCDB)originalSrb->Cdb)->MODE_SELECT.LogicalUnitNumber; 
    cdb->MODE_SELECT10.SPBit = ((PCDB)originalSrb->Cdb)->MODE_SELECT.SPBit; 
    cdb->MODE_SELECT10.PFBit                  = 1;
    cdb->MODE_SELECT10.ParameterListLength[0] = (UCHAR) (paramListLength >> 8);
    cdb->MODE_SELECT10.ParameterListLength[1] = (UCHAR) (paramListLength & 0xFF);

    context->Srb = srb;

    //
    // send the srb
    //
    status = IdeBuildAndSendIrp (PdoExtension,
                                 srb,
                                 DeviceAtapiModeCommandCompletion,
                                 context
                                 );

    if (NT_SUCCESS(status)) {

        ASSERT(status == STATUS_PENDING);
        return STATUS_PENDING;
    }

GetOut:

    if (srb) {
        ExFreePool(srb);
    }

    if (context) {

        originalSrb->DataBuffer = context->OriginalDataBuffer;

        ExFreePool(context);
    }

    UnrefLogicalUnitExtensionWithTag(
        PdoExtension->ParentDeviceExtension,
        PdoExtension,
        Irp
        );

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    return STATUS_PENDING;
                            
}

#if 0
NTSTATUS
DeviceIdeTestUnitReady (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PIRP Irp
)
{
    NTSTATUS status;
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;
    PHW_DEVICE_EXTENSION hwDeviceExtension;

    PAGED_CODE();

    hwDeviceExtension = PdoExtension->ParentDeviceExtension->HwDeviceExtension;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    srb      = irpStack->Parameters.Scsi.Srb;

    //
    // get write protect bit from smart data
    //
    if (hwDeviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_MEDIA_STATUS_ENABLED) {

        ATA_PASS_THROUGH ataPassThroughData;
        NTSTATUS localStatus;

        RtlZeroMemory (
            &ataPassThroughData,
            sizeof (ataPassThroughData)
            );

        ataPassThroughData.IdeReg.bCommandReg = IDE_COMMAND_GET_MEDIA_STATUS;
        ataPassThroughData.IdeReg.bReserved = ATA_PTFLAGS_STATUS_DRDY_REQUIRED;
    
        localStatus = IssueSyncAtaPassThroughSafe (
                         PdoExtension->ParentDeviceExtension,
                         PdoExtension,
                         &ataPassThroughData,
                         FALSE,
                         FALSE,
                         DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                         FALSE);
    
        if (NT_SUCCESS(localStatus)) {

            if (ataPassThroughData.IdeReg.bCommandReg & IDE_STATUS_ERROR){
                if (ataPassThroughData.IdeReg.bFeaturesReg & IDE_ERROR_DATA_ERROR){
                    //
                    // Special case: If current media is write-protected,
                    // the 0xDA command will always fail since the write-protect bit
                    // is sticky,so we can ignore this error
                    //
                   status = SRB_STATUS_SUCCESS;
                }
            }
        }
    }

    dataBufferByteLeft = modeDataBufferSize - sizeof(MODE_PARAMETER_HEADER);

    if (IsNEC_98) {

        HANDLE pageHandle;
        ULONG numberOfCylinders;
        ULONG numberOfHeads;
        ULONG sectorsPerTrack;
        KIRQL currentIrql;
        PKSPIN_LOCK spinLock;

        //
        // take a snap shot of the CHS values
        //
        spinLock = &PdoExtension->ParentDeviceExtension->SpinLock;

        //
        // lock the code before grabbing a lock
        //
        pageHandle = MmLockPagableCodeSection(DeviceIdeModeSense);
        KeAcquireSpinLock(spinLock, &currentIrql);

        numberOfCylinders = hwDeviceExtension->NumberOfCylinders[srb->TargetId];
        numberOfHeads     = hwDeviceExtension->NumberOfHeads[srb->TargetId];
        sectorsPerTrack   = hwDeviceExtension->SectorsPerTrack[srb->TargetId];

        KeReleaseSpinLock(spinLock, currentIrql);
        MmUnlockPagableImageSection(pageHandle);

        //
        // Set pages which are formated as nec-scsi.
        //
        if ((cdb->MODE_SENSE.PageCode == MODE_SENSE_RETURN_ALL) ||
            (cdb->MODE_SENSE.PageCode == MODE_PAGE_ERROR_RECOVERY)) {

            //
            // error recovery page
            //

            if (dataBufferByteLeft >= 0x6 + 2) {

                PMODE_DISCONNECT_PAGE  recoveryPage;

                recoveryPage = (PMODE_DISCONNECT_PAGE) pageData;

                recoveryPage->PageCode    = MODE_PAGE_ERROR_RECOVERY;
                recoveryPage->PageLength  = 0x6;

                //
                // update out data buffer pointer
                //
                pageData += recoveryPage->PageLength + 2;
                dataBufferByteLeft -= (recoveryPage->PageLength + 2);
                modePageHeader->ModeDataLength += recoveryPage->PageLength + 2;

            } else {

                status = STATUS_BUFFER_TOO_SMALL;
                goto getout;
            }
        }

        if ((cdb->MODE_SENSE.PageCode == MODE_SENSE_RETURN_ALL) ||
            (cdb->MODE_SENSE.PageCode == MODE_PAGE_FORMAT_DEVICE)) {

            //
            // format device page
            //

            if (dataBufferByteLeft >= 0x16 + 2) {

                PMODE_FORMAT_PAGE formatPage;

                formatPage = (PMODE_FORMAT_PAGE) pageData;

                formatPage->PageCode    = MODE_PAGE_FORMAT_DEVICE;
                formatPage->PageLength  = 0x16;

                //
                // SectorsPerTrack
                //
                ((PFOUR_BYTE)&formatPage->SectorsPerTrack[0])->Byte1 =
                    ((PFOUR_BYTE)&sectorsPerTrack)->Byte0;

                ((PFOUR_BYTE)&formatPage->SectorsPerTrack[0])->Byte0 =
                    ((PFOUR_BYTE)&sectorsPerTrack)->Byte1;

                //
                // update out data buffer pointer
                //
                pageData += formatPage->PageLength + 2;
                dataBufferByteLeft -= (formatPage->PageLength + 2);
                modePageHeader->ModeDataLength += formatPage->PageLength + 2;

            } else {

                status = STATUS_BUFFER_TOO_SMALL;
                goto getout;
            }
        }

        if ((cdb->MODE_SENSE.PageCode == MODE_SENSE_RETURN_ALL) ||
            (cdb->MODE_SENSE.PageCode == MODE_PAGE_RIGID_GEOMETRY)) {

            //
            // rigid geometry page
            //

            if (dataBufferByteLeft >= 0x12 + 2) {

                PMODE_RIGID_GEOMETRY_PAGE geometryPage;

                geometryPage = (PMODE_RIGID_GEOMETRY_PAGE) pageData;

                geometryPage->PageCode    = MODE_PAGE_RIGID_GEOMETRY;
                geometryPage->PageLength  = 0x12;

                //
                // NumberOfHeads
                //
                geometryPage->NumberOfHeads = (UCHAR) numberOfHeads;

                //
                // NumberOfCylinders
                //
                ((PFOUR_BYTE)&geometryPage->NumberOfCylinders)->Byte2
                    = ((PFOUR_BYTE)&numberOfCylinders)->Byte0;
                ((PFOUR_BYTE)&geometryPage->NumberOfCylinders)->Byte1
                    = ((PFOUR_BYTE)&numberOfCylinders)->Byte1;
                ((PFOUR_BYTE)&geometryPage->NumberOfCylinders)->Byte0
                    = 0;

                //
                // update out data buffer pointer
                //
                pageData += geometryPage->PageLength + 2;
                dataBufferByteLeft -= (geometryPage->PageLength + 2);
                modePageHeader->ModeDataLength += geometryPage->PageLength + 2;

            } else {

                status = STATUS_BUFFER_TOO_SMALL;
                goto getout;
            }
        }
    }

    if ((cdb->MODE_SENSE.PageCode == MODE_SENSE_RETURN_ALL) ||
        (cdb->MODE_SENSE.PageCode == MODE_PAGE_CACHING)) {

        if (dataBufferByteLeft >= sizeof(MODE_CACHING_PAGE)) {

            //
            // cache settings page
            //

            PMODE_CACHING_PAGE cachePage;

            cachePage = (PMODE_CACHING_PAGE) pageData;

            cachePage->PageCode = MODE_PAGE_CACHING;
            cachePage->PageSavable = 0;
            cachePage->PageLength = 0xa;
            cachePage->ReadDisableCache = 0;
            cachePage->WriteCacheEnable = PdoExtension->WriteCacheEnable;

            //
            // update out data buffer pointer
            //
            pageData += sizeof (MODE_CACHING_PAGE);
            dataBufferByteLeft -= sizeof (MODE_CACHING_PAGE);
            modePageHeader->ModeDataLength += sizeof (MODE_CACHING_PAGE);

        } else {

            status = STATUS_BUFFER_TOO_SMALL;
            goto getout;
        }
    }

    //
    // update the number of bytes we are returning
    //
    srb->DataTransferLength -= dataBufferByteLeft;
    Irp->IoStatus.Information = srb->DataTransferLength;
    status = STATUS_SUCCESS;
    srb->SrbStatus = SRB_STATUS_SUCCESS;

getout:

    UnrefPdoWithTag(
        PdoExtension,
        Irp
        );

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\devpdo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       devpdo.h
//
//--------------------------------------------------------------------------

#if !defined (___devpdo_h___)
#define ___devpdo_h___

#define PNP_ADDRESS(target, lun)    ((target & 0xf) | (lun << 4))

typedef struct _PDO_STOP_QUEUE_CONTEXT {

    PPDO_EXTENSION    PdoExtension;
    KEVENT            Event;
    ULONG             QueueStopFlag;
    NTSTATUS          Status;
    ATA_PASS_THROUGH  AtaPassThroughData;

} PDO_STOP_QUEUE_CONTEXT, *PPDO_STOP_QUEUE_CONTEXT;

           
//
// PDO State
//                         
#define PDOS_DEVICE_CLIAMED        (1 << 0)
#define PDOS_LEGACY_ATTACHER       (1 << 1)
#define PDOS_STARTED               (1 << 2)
#define PDOS_STOPPED               (1 << 3)

#define PDOS_SURPRISE_REMOVED      (1 << 4)
#define PDOS_REMOVED               (1 << 5)
#define PDOS_DEADMEAT              (1 << 6)
#define PDOS_NO_POWER_DOWN         (1 << 7)

#define PDOS_QUEUE_FROZEN_BY_POWER_DOWN       (1 << 8)
#define PDOS_QUEUE_FROZEN_BY_SLEEPING_SYSTEM  (1 << 9)
#define PDOS_QUEUE_FROZEN_BY_STOP_DEVICE      (1 << 10)
#define PDOS_QUEUE_FROZEN_BY_PARENT           (1 << 11)
#define PDOS_QUEUE_FROZEN_BY_START            (1 << 12)

#define PDOS_DISABLED_BY_USER                 (1 << 13)

#define PDOS_NEED_RESCAN                      (1 << 14)

#define PDOS_REPORTED_TO_PNP                  (1 << 15)

#define PDOS_INITIALIZED                     (1 << 31)

#define PDOS_MUST_QUEUE            (PDOS_QUEUE_FROZEN_BY_SLEEPING_SYSTEM |\
                                    PDOS_QUEUE_FROZEN_BY_STOP_DEVICE |\
                                    PDOS_QUEUE_FROZEN_BY_PARENT |\
                                    PDOS_QUEUE_FROZEN_BY_START)

#define PDOS_QUEUE_BLOCKED        (PDOS_MUST_QUEUE | PDOS_QUEUE_FROZEN_BY_POWER_DOWN)


#define PDO_CONSECUTIVE_PAGING_TIMEOUT_LIMIT 20
#define PDO_CONSECUTIVE_TIMEOUT_LIMIT       6
#define PDO_CONSECUTIVE_TIMEOUT_WARNING_LIMIT       (PDO_CONSECUTIVE_TIMEOUT_LIMIT/2)
#define PDO_DMA_TIMEOUT_LIMIT               6
#define PDO_FLUSH_TIMEOUT_LIMIT             3
#define PDO_UDMA_CRC_ERROR_LIMIT            6
#define PDO_PAGING_DEVICE_RETRY_COUNT       6

typedef enum {
    enumFailed = 1,
    reportedMissing,
    tooManyTimeout,
    byKilledPdo,
    replacedByUser
} DEADMEAT_REASON;

//
// Ide Power Context (pre-alloced)
//
typedef struct _IDE_POWER_CONTEXT {

    PPDO_EXTENSION    PdoExtension;
    PIRP              PowerIrp;
    ATA_PASS_THROUGH  AtaPassThroughData;

} IDE_POWER_CONTEXT, *PIDE_POWER_CONTEXT;

//
// Device Extension
//
typedef struct _PDO_EXTENSION {

    EXTENSION_COMMON_HEADER;

    PFDO_EXTENSION ParentDeviceExtension;

    PULONG         IdleCounter;

    KEVENT RemoveEvent;

    ULONG          ConsecutiveTimeoutCount;

    ULONG          DmaTransferTimeoutCount;

    ULONG          FlushCacheTimeoutCount;

    ULONG          CrcErrorCount;

    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    UCHAR RetryCount;
    ULONG LuFlags;
    ULONG CurrentKey;
    struct _PDO_EXTENSION *NextLogicalUnit;
    PSCSI_REQUEST_BLOCK AbortSrb;
    struct _PDO_EXTENSION *CompletedAbort;
    LONG RequestTimeoutCounter;
    PIRP PendingRequest;
    PIRP BusyRequest;
    //UCHAR MaxQueueDepth;
    //UCHAR QueueCount;
    SRB_DATA SrbData;

    UCHAR ScsiDeviceType;

    UCHAR FullVendorProductId[40 + 1];
    UCHAR FullProductRevisionId[8 + 1];
    UCHAR FullSerialNumber[20 * 2 + 1];

    //
    // (ata device only) indicate whether the write cache is enabled
    //
    BOOLEAN WriteCacheEnable;

    //
    // SpinLock to protect Pdo Extension
    //
    KSPIN_LOCK PdoSpinLock;

    //
    // If the logical is attached, this field contains
    // the device object of the attacher.  Otherwise,
    // it is same as PhysicalDeviceObject
    //
    PVOID AttacherDeviceObject;

    //
    // Number of references made to this logical unit extension
    //
    // Protected by Pdo SpinLock
    //
    // should be LONG: ASSERT when we try to decrement 0.
    ULONG ReferenceCount;

    //
    // keeping track of Pdo State
    //
    ULONG PdoState;

    PIRP PendingPowerDownSystemIrp;

    //
    // indicate we need to call DeviceQueryInitData()
    // protected by interlock
    //
    ULONG InitDeviceWithAcpiGtf;

    //
    // iddata checksum
    //
    ULONG IdentifyDataCheckSum;

    //
    // firmware settings from acpi
    //
    // must get it before we power down
    PDEVICE_SETTINGS AcpiDeviceSettings;

    IDE_POWER_CONTEXT   PdoPowerContext;

#if DBG
    ULONG   PowerContextLock;
#endif

#ifdef LOG_DEADMEAT_EVENT

    struct {

        DEADMEAT_REASON Reason;

        PUCHAR FileName;
        ULONG LineNumber;
        IDEREGS IdeReg;

    } DeadmeatRecord;

#endif // LOG_DEADMEAT_EVENT

#if DBG
    //
    // Number of Items queued up in Device Queue
    //
    ULONG NumberOfIrpQueued;

    #define TAG_TABLE_SIZE  0x1000
    KSPIN_LOCK RefCountSpinLock;
    ULONG NumTagUsed;
    PVOID TagTable[TAG_TABLE_SIZE];

#endif

} PDO_EXTENSION, *PPDO_EXTENSION;

typedef PDO_EXTENSION  LOGICAL_UNIT_EXTENSION;
typedef PPDO_EXTENSION PLOGICAL_UNIT_EXTENSION;

typedef VOID (*DEVICE_INIT_COMPLETION) (
    PVOID Context,
    NTSTATUS Status
    );

typedef enum _DEVICE_INIT_STATE {
    deviceInitState_acpi = 0,
    deviceInitState_done,
    deviceInitState_max
} DEVICE_INIT_STATE;

typedef struct _DEVICE_INIT_DEVICE_STATE_CONTEXT {

    PPDO_EXTENSION PdoExtension;

    DEVICE_INIT_STATE DeviceInitState[deviceInitState_max];
    ULONG CurrentState;

    ULONG NumInitState;

    ULONG NumAcpiRequestSent;

    ULONG NumRequestFailed;

    DEVICE_INIT_COMPLETION DeviceInitCompletionRoutine;
    PVOID DeviceInitCompletionContext;

    ATA_PASS_THROUGH AtaPassThroughData;

} DEVICE_INIT_DEVICE_STATE_CONTEXT, *PDEVICE_INIT_DEVICE_STATE_CONTEXT;


#define DEVICE_DEFAULT_IDLE_TIMEOUT        0xffffffff
#define DEVICE_VERY_LONG_IDLE_TIMEOUT      0xfffffffe

typedef struct _IDE_READ_CAPACITY_CONTEXT {

    PPDO_EXTENSION PdoExtension;
    PIRP OriginalIrp;
    PVOID OldDataBuffer;

    ATA_PASS_THROUGH AtaPassThroughData;
    UCHAR DataBuffer[sizeof(IDENTIFY_DATA)];

    BOOLEAN GeometryIoctl;

} IDE_READ_CAPACITY_CONTEXT, *PIDE_READ_CAPACITY_CONTEXT;

typedef struct _IDE_MODE_COMMAND_CONTEXT {

    PSCSI_REQUEST_BLOCK Srb;
    PVOID OriginalDataBuffer;
} IDE_MODE_COMMAND_CONTEXT, *PIDE_MODE_COMMAND_CONTEXT;


PDEVICE_OBJECT
DeviceCreatePhysicalDeviceObject (
    IN PDRIVER_OBJECT  DriverObject,
    IN PFDO_EXTENSION  FdoExtension,
    IN PUNICODE_STRING DeviceObjectName
    );

NTSTATUS
DeviceStartDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DeviceStartDeviceQueue (
    IN PPDO_EXTENSION PdoExtension,
    IN ULONG          StopFlagToClear
    );

NTSTATUS
DeviceStopDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DeviceStopDeviceQueueSafe (
    IN PPDO_EXTENSION PdoExtension,
    IN ULONG          QueueStopFlag,
    IN BOOLEAN          lowMem
    );

VOID
IdeStopQueueCompletionRoutine (
    IN PDEVICE_OBJECT           DeviceObject,
    IN PPDO_STOP_QUEUE_CONTEXT  Context,
    IN NTSTATUS                 Status
    );

NTSTATUS
DeviceRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DeviceUsageNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DeviceQueryStopRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DeviceQueryId (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

PWSTR
DeviceBuildBusId (
    IN PPDO_EXTENSION pdoExtension
    );

PWSTR
DeviceBuildInstanceId (
    IN PPDO_EXTENSION pdoExtension
    );

PWSTR
DeviceBuildCompatibleId(
    IN PPDO_EXTENSION pdoExtension
    );

PWSTR
DeviceBuildHardwareId(
    IN PPDO_EXTENSION pdoExtension
    );

VOID
CopyField(
    IN PUCHAR Destination,
    IN PUCHAR Source,
    IN ULONG Count,
    IN UCHAR Change
    );

NTSTATUS
DeviceDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
    
NTSTATUS
DeviceBuildStorageDeviceDescriptor(
    PPDO_EXTENSION pdoExtension,
    IN OUT PSTORAGE_DEVICE_DESCRIPTOR StorageDeviceDescriptor,
    IN OUT PULONG BufferSize
    );

NTSTATUS
DeviceQueryCapabilities (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
    
NTSTATUS
IdePortInsertByKeyDeviceQueue (
    IN PPDO_EXTENSION PdoExtension,
    IN PIRP Irp,
    IN ULONG SortKey,
    OUT PBOOLEAN Inserted
    );
                        
VOID
DeviceInitCompletionRoutine (
    PVOID Context,
    NTSTATUS Status
    );

NTSTATUS
DeviceQueryText (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
                        
NTSTATUS
IdeSendIdePassThrough (
    IN PPDO_EXTENSION PdoExtension,
    IN PIRP Irp
    );

VOID
DeviceRegisterIdleDetection (
    IN PPDO_EXTENSION PdoExtension,
    IN ULONG ConservationIdleTime,
    IN ULONG PerformanceIdleTime
);
                        
VOID
DeviceUnregisterIdleDetection (
    IN PPDO_EXTENSION PdoExtension
);

VOID
DeviceInitIdStrings (
    IN PPDO_EXTENSION PdoExtension,
    IN IDE_DEVICETYPE DeviceType,
    IN PINQUIRYDATA   InquiryData,
    IN PIDENTIFY_DATA IdentifyData
);
                        
VOID
DeviceInitDeviceType (
    IN PPDO_EXTENSION PdoExtension,
    IN PINQUIRYDATA   InquiryData
);
                        
NTSTATUS
DeviceQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
DeviceInitDeviceState (
    IN PPDO_EXTENSION PdoExtension,
    DEVICE_INIT_COMPLETION DeviceInitCompletionRoutine,
    PVOID DeviceInitCompletionContext
    );
                        
NTSTATUS
DeviceQueryInitData (
    IN PPDO_EXTENSION PdoExtension
    );

VOID
DeviceInitDeviceStateCompletionRoutine (
    PDEVICE_OBJECT DeviceObject,
    PVOID Context,
    NTSTATUS Status
    );

VOID
DeviceInitCHS (
    IN PPDO_EXTENSION PdoExtension,
    PDEVICE_INIT_DEVICE_STATE_CONTEXT DeviceStateContext,
    PATA_PASS_THROUGH AtaPassThroughData
    );
                        
NTSTATUS
DeviceIdeReadCapacity (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PIRP Irp
);

VOID
DeviceIdeReadCapacityCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    PVOID Context,
    NTSTATUS Status
    );

NTSTATUS
DeviceIdeModeSense (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PIRP Irp
    );

NTSTATUS
DeviceIdeModeSelect (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PIRP Irp
);
                        
NTSTATUS
DeviceQueryPnPDeviceState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
                        
NTSTATUS
DeviceIdeTestUnitReady (
    IN PPDO_EXTENSION PdoExtension,
    IN OUT PIRP Irp
);
                        
NTSTATUS
DeviceAtapiModeSelect (
    IN PPDO_EXTENSION PdoExtension,
    IN PIRP Irp
    );

NTSTATUS
DeviceAtapiModeSense (
    IN PPDO_EXTENSION PdoExtension,
    IN PIRP Irp
    );

NTSTATUS
DeviceAtapiModeCommandCompletion (
    IN PDEVICE_OBJECT  DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
DeviceScsiGetAddress (
    PPDO_EXTENSION PdoExtension,
    PIRP Irp
    );


NTSTATUS
DeviceGetDumpPointers(
    PPDO_EXTENSION  PdoExtension,
    PIRP Irp
    );


NTSTATUS
DeviceStorageQueryProperty (
    PPDO_EXTENSION PdoExtension,
    PIRP Irp
    );

#endif // ___devpdo_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\detect.h ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    detect.h

Abstract:

--*/

#if !defined (___detect_h___)
#define ___detect_h___

typedef struct _DETECTION_PORT {

    ULONG   CommandRegisterBase;
    ULONG   ControlRegisterBase;
    ULONG   IrqLevel;

} DETECTION_PORT, *PDETECTION_PORT;


NTSTATUS
IdePortDetectLegacyController (
    IN PDRIVER_OBJECT  DriverObject,
    IN PUNICODE_STRING RegistryPath
);

NTSTATUS
IdePortCreateDetectionList (
    IN  PDRIVER_OBJECT  DriverObject,
    OUT PDETECTION_PORT *DetectionPort,
    OUT PULONG          NumPort
);

NTSTATUS
IdePortTranslateAddress (
    IN INTERFACE_TYPE      InterfaceType,
    IN ULONG               BusNumber,
    IN PHYSICAL_ADDRESS    StartAddress,
    IN LONG                Length,
    IN OUT PULONG          AddressSpace,
    OUT PVOID              *TranslatedAddress,
    OUT PPHYSICAL_ADDRESS  TranslatedMemoryAddress
    );

VOID
IdePortFreeTranslatedAddress (
    IN PVOID               TranslatedAddress,
    IN LONG                Length,
    IN ULONG               AddressSpace
    );

BOOLEAN
IdePortDetectAlias (
    PIDE_REGISTERS_1 CmdRegBase
    );

#endif // ___detect_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\fdopower.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       fdopower.h
//
//--------------------------------------------------------------------------

#if !defined (___fdopower_h___)
#define ___fdopower_h___

typedef struct  _FDO_POWER_CONTEXT *PFDO_POWER_CONTEXT;
           
//POWER_STATE                   
NTSTATUS
IdePortIssueSetPowerState (
    IN PDEVICE_EXTENSION_HEADER DoExtension,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE      State,
    IN BOOLEAN          Sync
    );

NTSTATUS
IdePortPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
IdePortSetFdoPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
FdoContingentPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
FdoPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );
    
VOID
FdoChildReportPowerDown (
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension
    );

NTSTATUS
FdoChildRequestPowerUp (
    IN PFDO_EXTENSION            FdoExtension,
    IN PPDO_EXTENSION            PdoExtension,
    IN PVOID                     Context
    );
    
NTSTATUS
FdoChildRequestPowerUpCompletionRoutine (
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    );
                          
                          
NTSTATUS
ChannelQueryPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
                                    
NTSTATUS
FdoSystemPowerUpCompletionRoutine (
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    );

#endif // ___fdopower_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\fdopower.c ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    fdopower.c

Abstract:

--*/

#include "ideport.h"

//POWER_STATE                   
NTSTATUS
IdePortIssueSetPowerState (
    IN PDEVICE_EXTENSION_HEADER DoExtension,
    IN POWER_STATE_TYPE   Type,
    IN POWER_STATE        State,
    IN BOOLEAN            Sync
    )
{
    PIRP                      irp = NULL;
    PIO_STACK_LOCATION        irpStack;
    NTSTATUS                  status;
    CCHAR                     stackSize;

    SET_POWER_STATE_CONTEXT   context;

    if (Sync) {

        KeInitializeEvent(
            &context.Event,
            NotificationEvent,
            FALSE
            );
    }

    stackSize = (CCHAR) (DoExtension->DeviceObject->StackSize);

    irp = IoAllocateIrp(
            stackSize,
            FALSE
            );

    if (irp == NULL) {

        status = STATUS_NO_MEMORY;
        goto GetOut;
    }

    irpStack = IoGetNextIrpStackLocation(irp);

    irpStack->MajorFunction = IRP_MJ_POWER;
    irpStack->MinorFunction = IRP_MN_SET_POWER;

    irpStack->Parameters.Power.SystemContext = 0;
    irpStack->Parameters.Power.Type          = Type;
    irpStack->Parameters.Power.State         = State;

    IoSetCompletionRoutine(irp,
                           IdePortPowerCompletionRoutine,
                           Sync ? &context : NULL,
                           TRUE,
                           TRUE,
                           TRUE);

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    status = PoCallDriver(
                 DoExtension->DeviceObject, 
                 irp
                 );

    //
    // Wait for the completion routine. It will be called anyway
    //
    //if ((status == STATUS_PENDING) && (Sync)) {
    if (Sync) {

        KeWaitForSingleObject(&context.Event,
                              Executive,
                              KernelMode,
                              FALSE,
                              NULL);

        status = context.Status;
    }

GetOut:

    return status;
}

NTSTATUS
IdePortPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PSET_POWER_STATE_CONTEXT context = Context;

    if (context) {

        context->Status = Irp->IoStatus.Status;

        KeSetEvent(
            &context->Event,
            EVENT_INCREMENT,
            FALSE
            );
    }

    IoFreeIrp (Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
IdePortSetFdoPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PFDO_EXTENSION     fdoExtension;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS           status = STATUS_SUCCESS;
    PFDO_POWER_CONTEXT context;
    BOOLEAN            powerStateChange;
    BOOLEAN            systemPowerContext = FALSE;
    BOOLEAN            devicePowerContext = FALSE;

    DebugPrint ((DBG_POWER, 
                 "FDO devobj 0x%x got power irp 0x%x\n", 
                 DeviceObject,
                 Irp
                 ));

    fdoExtension = DeviceObject->DeviceExtension;
    irpStack = IoGetCurrentIrpStackLocation (Irp);

    //context = ExAllocatePool (NonPagedPool, sizeof(FDO_POWER_CONTEXT));

    //
    // We need two pre-alloced context structures. This is because a system power irp
    // would result in a device power irp to be issued before the former is completed.
    // 
    if (irpStack->Parameters.Power.Type == SystemPowerState) {

        ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 1, 0) == 0);
        context = &(fdoExtension->FdoPowerContext[0]);
        systemPowerContext = TRUE;

    } else {

        ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[1]), 1, 0) == 0);
        context = &(fdoExtension->FdoPowerContext[1]);
        devicePowerContext = TRUE;

    }

    if (context == NULL) {

        ASSERT(context);
        status = STATUS_NO_MEMORY;
    } else {

        RtlZeroMemory (context, sizeof(FDO_POWER_CONTEXT));

        powerStateChange = TRUE;

        context->OriginalPowerIrp = Irp;
        context->newPowerType     = irpStack->Parameters.Power.Type;
        context->newPowerState    = irpStack->Parameters.Power.State;
    
        if (irpStack->Parameters.Power.Type == SystemPowerState) {

            if (fdoExtension->SystemPowerState != irpStack->Parameters.Power.State.SystemState) {

#if DBG
                ASSERT (fdoExtension->PendingSystemPowerIrp == NULL);
                fdoExtension->PendingSystemPowerIrp = Irp;
                ASSERT (fdoExtension->PendingSystemPowerIrp);
#endif

                if (fdoExtension->SystemPowerState == PowerSystemWorking) {
    
                    POWER_STATE        powerState;

                    //
                    // Getting out of working state.  
                    //
                    if ((irpStack->Parameters.Power.State.SystemState == PowerSystemShutdown) &&
                        (irpStack->Parameters.Power.ShutdownType == PowerActionShutdownReset)) {

                        //
                        // spin up for BIOS POST
                        //
                        powerState.DeviceState = PowerDeviceD0;

                    } else {
        
                        //
                        // power down for sleep
                        //
                        powerState.DeviceState = PowerDeviceD3;
                    }

                    IoMarkIrpPending(Irp);

                    PoRequestPowerIrp (
                        fdoExtension->DeviceObject,
                        IRP_MN_SET_POWER,
                        powerState,
                        FdoContingentPowerCompletionRoutine,
                        context,
                        NULL
                        );

                    return STATUS_PENDING;
                }       

            } else {

                //
                // We are already in the given state
                //
                powerStateChange = FALSE;
            }

        } else if (irpStack->Parameters.Power.Type == DevicePowerState) {
    
            if (fdoExtension->DevicePowerState != irpStack->Parameters.Power.State.DeviceState) {
    
                DebugPrint ((
                    DBG_POWER, 
                    "IdePort: New Fdo 0x%x device power state 0x%x\n", 
                    fdoExtension->IdeResource.TranslatedCommandBaseAddress, 
                    irpStack->Parameters.Power.State.DeviceState
                    ));
        
                ASSERT (fdoExtension->PendingDevicePowerIrp == NULL);
#if DBG
                fdoExtension->PendingDevicePowerIrp = Irp;
                ASSERT (fdoExtension->PendingDevicePowerIrp);
#endif //DBG

                if (fdoExtension->DevicePowerState == PowerDeviceD0) {
    
                    //
                    // getting out of D0 state, better call PoSetPowerState now
                    //
                    PoSetPowerState (
                        DeviceObject,
                        DevicePowerState,
                        irpStack->Parameters.Power.State
                        );
                }
                                                  
            } else {

                //
                // We are already in the given state
                //
                powerStateChange = FALSE;
            }
        } else {
    
            ASSERT (FALSE);
            status = STATUS_NOT_IMPLEMENTED;
        }
    }


    if (NT_SUCCESS(status)) {
    
		IoMarkIrpPending(Irp);

        IoCopyCurrentIrpStackLocationToNext (Irp);

        if (powerStateChange) {
        
            IoSetCompletionRoutine(Irp,
                                   FdoPowerCompletionRoutine,
                                   context,
                                   TRUE,
                                   TRUE,
                                   TRUE);
        } else {

            if (systemPowerContext) {
                ASSERT(devicePowerContext == FALSE);
                ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);
            }

            if (devicePowerContext) {
                ASSERT(systemPowerContext == FALSE);
                ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[1]), 0, 1) == 1);
            }
            //ExFreePool (context);
            PoStartNextPowerIrp (Irp);

        }
    
        PoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
        return STATUS_PENDING;

    } else {

        Irp->IoStatus.Information = 0;
        Irp->IoStatus.Status = status;

        if (context) {
            if (systemPowerContext) {
                ASSERT(devicePowerContext == FALSE);
                ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);
            }

            if (devicePowerContext) {
                ASSERT(systemPowerContext == FALSE);
                ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[1]), 0, 1) == 1);
            }
            //ExFreePool (context);
        }

        PoStartNextPowerIrp (Irp);
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        return status;
    }
}

NTSTATUS
FdoContingentPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PFDO_POWER_CONTEXT context = Context;
    PFDO_EXTENSION fdoExtension;
    PIRP irp;

    irp = context->OriginalPowerIrp;
    fdoExtension = DeviceObject->DeviceExtension;

    if (NT_SUCCESS(IoStatus->Status)) {

        IoCopyCurrentIrpStackLocationToNext (irp);
    
        IoSetCompletionRoutine(irp,
                               FdoPowerCompletionRoutine,
                               context,
                               TRUE,
                               TRUE,
                               TRUE);
    
        PoCallDriver (fdoExtension->AttacheeDeviceObject, irp);

    } else {

        irp->IoStatus.Information = 0;
        irp->IoStatus.Status = IoStatus->Status;

        //
        // This should happen only for system power irps
        //
        ASSERT(context->newPowerType == SystemPowerState);
        ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);
        //ExFreePool (context);
        PoStartNextPowerIrp (irp);
        IoCompleteRequest(irp, IO_NO_INCREMENT);
    }

    return IoStatus->Status;
}


NTSTATUS
FdoPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PFDO_POWER_CONTEXT context = Context;
    BOOLEAN            callPoSetPowerState;
    PFDO_EXTENSION     fdoExtension;
    POWER_STATE        newPowerState;
    POWER_STATE_TYPE   newPowerType;
    BOOLEAN            unlocked = FALSE;
	BOOLEAN			   moreProcessingRequired = FALSE;
	NTSTATUS		   status;

    fdoExtension = DeviceObject->DeviceExtension;

    newPowerType = context->newPowerType;
    newPowerState = context->newPowerState;

    if ((NT_SUCCESS(Irp->IoStatus.Status))) {

        callPoSetPowerState = TRUE;

        if (context->newPowerType == SystemPowerState) { 

            fdoExtension->SystemPowerState = context->newPowerState.SystemState;

            if (fdoExtension->SystemPowerState == PowerSystemWorking) {
                
                POWER_STATE powerState;

                //
                // I don't need the context any more
                //
                ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);
                unlocked = TRUE;
				moreProcessingRequired = TRUE;

				ASSERT(fdoExtension->PendingSystemPowerIrp == Irp);

                //
                // initiate a D0 here to cause a re-enumuration
                //
                powerState.DeviceState = PowerDeviceD0;
                status = PoRequestPowerIrp (
									fdoExtension->DeviceObject,
									IRP_MN_SET_POWER,
									powerState,
									FdoSystemPowerUpCompletionRoutine,
									Irp,
									NULL
									);

				ASSERT(status == STATUS_PENDING);
            }

            DebugPrint ((
                DBG_POWER, "IdePort: New Fdo 0x%x system power state 0x%x\n", 
                fdoExtension->IdeResource.TranslatedCommandBaseAddress, 
                fdoExtension->SystemPowerState));

#if DBG
			if (moreProcessingRequired == FALSE) {
				fdoExtension->PendingSystemPowerIrp = NULL;
			}
#endif

        } else if (context->newPowerType == DevicePowerState) { 

            if (context->newPowerState.DeviceState == PowerDeviceD0) {

                if (fdoExtension->panasonicController) {

                    //
                    // this will loop 20000 * 100 us (2000ms) the most.
                    //                                                      
                    ULONG i = 20000;
                    while (i) {                       
                                  
                        //
                        // the panasonic controller needs a special way to kick start
                        //
                        WRITE_PORT_UCHAR (fdoExtension->HwDeviceExtension->BaseIoAddress1.RegistersBaseAddress + 0x207, 0x81);
                        WRITE_PORT_UCHAR (fdoExtension->HwDeviceExtension->BaseIoAddress1.RegistersBaseAddress, 0xa0);
                        
                        WRITE_PORT_UCHAR (fdoExtension->HwDeviceExtension->BaseIoAddress1.DriveSelect, 0xa0);
                        if (0xa0 == READ_PORT_UCHAR (fdoExtension->HwDeviceExtension->BaseIoAddress1.DriveSelect)) {
                        
                            DebugPrint ((0, "panasonicController wait start count = %u\n", i));
                            //
                            // done
                            //
                            i = 0;
                            
                        } else {
                        
                            KeStallExecutionProcessor(100);
                            i--;
                        }
                    }
                }
            }

            if ((context->newPowerState.DeviceState == PowerDeviceD0) &&
                (!context->TimingRestored)) {



                status = ChannelRestoreTiming (
                             fdoExtension,
                             ChannelRestoreTimingCompletionRoutine,
                             context
                             );

                if (!NT_SUCCESS(status)) {

                    ChannelRestoreTimingCompletionRoutine(
                        fdoExtension->DeviceObject,
                        status, 
                        context
                        );
                }

                return STATUS_MORE_PROCESSING_REQUIRED;
            }

            ASSERT (fdoExtension->PendingDevicePowerIrp == Irp);
            fdoExtension->PendingDevicePowerIrp = NULL;

            if (fdoExtension->DevicePowerState == PowerDeviceD0) {

                //
                // PoSetPowerState is called before we get out of D0
                //
                callPoSetPowerState = FALSE;
            }

            fdoExtension->DevicePowerState = context->newPowerState.DeviceState;

            if ((fdoExtension->DevicePowerState == PowerDeviceD0) &&
				(fdoExtension->FdoState & FDOS_STARTED)) {

                IoInvalidateDeviceRelations (
                    fdoExtension->AttacheePdo,
                    BusRelations
                    );
            }
        }

        if (callPoSetPowerState) {

            PoSetPowerState (
                DeviceObject,
                newPowerType,
                newPowerState                
                );
        }

    } else {

        DebugPrint ((DBG_ALWAYS, "ATAPI: devobj 0x%x failed power irp 0x%x\n", fdoExtension->AttacheeDeviceObject, Irp));

        if (context->newPowerType == SystemPowerState) { 

            ASSERT (fdoExtension->PendingSystemPowerIrp == Irp);
            fdoExtension->PendingSystemPowerIrp = NULL;

        } else if (context->newPowerType == DevicePowerState) { 

            ASSERT (fdoExtension->PendingDevicePowerIrp == Irp);
            fdoExtension->PendingDevicePowerIrp = NULL;
        }

    }

    //
    // Done with context
    //
    if (!unlocked) {
        if (context->newPowerType == SystemPowerState) {
            ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[0]), 0, 1) == 1);
        } else {
            ASSERT(InterlockedCompareExchange(&(fdoExtension->PowerContextLock[1]), 0, 1) == 1);
        }
    }
    //ExFreePool (Context);

	//
	// wait for the device irp to complete
	//
	if (moreProcessingRequired) {
		return STATUS_MORE_PROCESSING_REQUIRED;
	}

    //
    // If pending has be returned for this irp then mark the current stack as
    // pending.
    //
    //if (Irp->PendingReturned) {
     //   IoMarkIrpPending(Irp);
    //}

	PoStartNextPowerIrp (Irp);

    return Irp->IoStatus.Status;
}



VOID
FdoChildReportPowerDown (
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension
    )
{
    KIRQL       currentIrql;
    POWER_STATE powerState;

    KeAcquireSpinLock(&FdoExtension->LogicalUnitListSpinLock, &currentIrql);


    FdoExtension->NumberOfLogicalUnitsPowerUp--;

    if (FdoExtension->NumberOfLogicalUnitsPowerUp == 0) {

        DebugPrint ((DBG_POWER, "FdoChildReportPowerDown: sleep fdo 0x%x\n", FdoExtension));

        //
        // All the children are powered down, we can now power down 
        // the parent (the controller)
        //
        powerState.DeviceState = PowerDeviceD3;
        PoRequestPowerIrp (
            FdoExtension->DeviceObject,
            IRP_MN_SET_POWER,
            powerState,
            NULL,
            NULL,
            NULL
            );

    } else if (FdoExtension->NumberOfLogicalUnitsPowerUp < 0) {

        //
        // should never happen. If it did, pretend it didn't
        //
        ASSERT (FALSE);
        FdoExtension->NumberOfLogicalUnitsPowerUp = 0;
    }

    KeReleaseSpinLock(&FdoExtension->LogicalUnitListSpinLock, currentIrql);

    return;
}

NTSTATUS
FdoChildRequestPowerUp (
    IN PFDO_EXTENSION            FdoExtension,
    IN PPDO_EXTENSION            PdoExtension,
    IN PVOID                     Context
    )
{
    KIRQL       currentIrql;
    NTSTATUS    status;
    POWER_STATE powerState;

    KeAcquireSpinLock(&FdoExtension->LogicalUnitListSpinLock, &currentIrql);

    status = STATUS_SUCCESS;

    if (FdoExtension->NumberOfLogicalUnitsPowerUp == 0) {

        DebugPrint ((DBG_POWER, "FdoChildRequestPowerUp: wake up fdo 0x%x\n", FdoExtension));

        KeReleaseSpinLock(&FdoExtension->LogicalUnitListSpinLock, currentIrql);

        //
        // One of the children is coming out of sleep, 
        // we need to power up the parent (the controller)
        //
        powerState.DeviceState = PowerDeviceD0;
        status = PoRequestPowerIrp (
                     FdoExtension->DeviceObject,
                     IRP_MN_SET_POWER,
                     powerState,
                     FdoChildRequestPowerUpCompletionRoutine,
                     Context,
                     NULL
                     );
        ASSERT (NT_SUCCESS(status));
        status = STATUS_PENDING;

    } else {

        FdoExtension->NumberOfLogicalUnitsPowerUp++;

        if (FdoExtension->NumberOfLogicalUnitsPowerUp > FdoExtension->NumberOfLogicalUnits) {

            //
            // should never happen. If it did, pretend it didn't
            //
            ASSERT (FALSE);
            FdoExtension->NumberOfLogicalUnitsPowerUp = FdoExtension->NumberOfLogicalUnits;
        }

        KeReleaseSpinLock(&FdoExtension->LogicalUnitListSpinLock, currentIrql);

        PdoRequestParentPowerUpCompletionRoutine (
            Context,
            STATUS_SUCCESS
            );
    }

    return status;
}

NTSTATUS
FdoChildRequestPowerUpCompletionRoutine (
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
{
    PFDO_EXTENSION     fdoExtension;

    fdoExtension = DeviceObject->DeviceExtension;

    if (NT_SUCCESS(IoStatus->Status)) {

        KIRQL currentIrql;
    
        KeAcquireSpinLock(&fdoExtension->LogicalUnitListSpinLock, &currentIrql);

        fdoExtension->NumberOfLogicalUnitsPowerUp++;

        KeReleaseSpinLock(&fdoExtension->LogicalUnitListSpinLock, currentIrql);
    }

    PdoRequestParentPowerUpCompletionRoutine (
        Context,
        IoStatus->Status
        );

    return IoStatus->Status;
}

NTSTATUS
ChannelQueryPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack;
    PFDO_EXTENSION     fdoExtension;

    fdoExtension = DeviceObject->DeviceExtension;

#if defined (DONT_POWER_DOWN_PAGING_DEVICE)

    irpStack = IoGetCurrentIrpStackLocation (Irp);

    if (!fdoExtension->CrashDumpPathCount ||
        ((irpStack->Parameters.Power.Type == SystemPowerState) &&
         (irpStack->Parameters.Power.State.SystemState == PowerSystemWorking)) ||
        ((irpStack->Parameters.Power.Type == DevicePowerState) &&
         (irpStack->Parameters.Power.State.SystemState == PowerDeviceD0))) {

        Irp->IoStatus.Status = STATUS_SUCCESS;

    } else {

        Irp->IoStatus.Status = STATUS_DEVICE_POWER_FAILURE;
    }
#else

    Irp->IoStatus.Status = STATUS_SUCCESS;

#endif // DONT_POWER_DOWN_PAGING_DEVICE

    IoCopyCurrentIrpStackLocationToNext (Irp);
    PoStartNextPowerIrp (Irp);
    return PoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
}


NTSTATUS
FdoSystemPowerUpCompletionRoutine (
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    )
{
	PFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
	PIRP irp = Context;

#if DBG
	fdoExtension->PendingSystemPowerIrp = NULL;
#endif


	//
	// start the next system power irp
	//
    PoStartNextPowerIrp (irp);

	if (!NT_SUCCESS(IoStatus->Status)) {
	irp->IoStatus.Status = IoStatus->Status;
	}

	IoCompleteRequest(irp, IO_NO_INCREMENT);

    return STATUS_SUCCESS;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\hack.c ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    hack.c

Abstract:

--*/

#include "ideport.h"
#include "hack.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IdePortSlaveIsGhost)
#pragma alloc_text(PAGE, IdePortGetFlushCommand)
#pragma alloc_text(PAGE, IdePortMustBePio)
#pragma alloc_text(PAGE, IdePortPioByDefaultDevice)
#pragma alloc_text(PAGE, IdePortDeviceHasNonRemovableMedia)
#pragma alloc_text(PAGE, IdePortDeviceIsLs120)
#pragma alloc_text(PAGE, IdePortNoPowerDown)
#pragma alloc_text(PAGE, IdePortVerifyDma)
#pragma alloc_text(NONPAGE, IdePortFudgeAtaIdentifyData)
#pragma alloc_text(PAGE, IdePortIsThisAPanasonicPCMCIACard)
#pragma alloc_text(PAGE, IdeFindSpecialDevice)
/*
#pragma alloc_text(PAGE, IdePortIsThisASonyMemorystickPCMCIACard)
#pragma alloc_text(PAGE, IdePortSonyMemoryStick)
#pragma alloc_text(PAGE, IdePortReuseIdent)
#pragma alloc_text(PAGE, IdePortBadCdrom)
*/
#endif // ALLOC_PRAGMA

#if defined (FAKE_BMSETUP_FAILURE)
ULONG FailBmSetupCount = 0;
#endif // FAKE_BMSETUP_FAILURE  

#if DBG

ULONG IdeDebugRescanBusFreq = 0;
ULONG IdeDebugRescanBusCounter = 0;

ULONG IdeDebugHungControllerFreq = 0;
ULONG IdeDebugHungControllerCounter = 0;

ULONG IdeDebugTimeoutAllCacheFlush = 0;

ULONG IdeDebugForceSmallCrashDumpBlockSize = 0;

PDEVICE_OBJECT IdeDebugDevObjTimeoutAllDmaSrb = 0;

ULONG IdeDebug = 0;
ULONG IdeDebugPrintControl = DBG_ALWAYS;
UCHAR IdeBuffer[0x1000];


VOID
IdeDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all SCSI drivers

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    BOOLEAN print = FALSE;
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel & DBG_BIT_CONTROL) {

        if (DebugPrintLevel == DBG_ALWAYS) {

            print = TRUE;

        } else if ((DebugPrintLevel & ~DBG_BIT_CONTROL) & IdeDebugPrintControl) {

            print = TRUE;
        }

    } else {

        if (DebugPrintLevel <= IdeDebug) {

            print = TRUE;
        }
    }

    if (print) {

        vsprintf(IdeBuffer, DebugMessage, ap);

#ifdef ENABLE_DBG_PRINT
        DbgPrint(IdeBuffer);
#else
        DbgPrintEx(DPFLTR_IDEP_ID, 
                   DPFLTR_INFO_LEVEL,
                   IdeBuffer
                   );
#endif
    }

    va_end(ap);

} // end IdeDebugPrint()
#endif

//
// if we see one of these slave device that looks like
// the master device, we will ignore the slave device
//
BOOLEAN
IdePortSlaveIsGhost (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA MasterIdentifyData,
    IN PIDENTIFY_DATA SlaveIdentifyData
)
{
    ULONG length;
    ULONG i;

    PAGED_CODE();

    length = sizeof (MasterIdentifyData->ModelNumber);
    if (length == RtlCompareMemory (
                      MasterIdentifyData->ModelNumber,
                      SlaveIdentifyData->ModelNumber,
                      length)) {

        if (IdePortSearchDeviceInRegMultiSzList (
                FdoExtension,
                MasterIdentifyData, 
                GHOST_SLAVE_DEVICE)) {

            DebugPrint ((DBG_WARNING, "ATAPI: Found a ghost slave\n"));
            return TRUE;
        }
    }
    return FALSE;
}

UCHAR
IdePortGetFlushCommand (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN OUT PPDO_EXTENSION PdoExtension,
    IN PIDENTIFY_DATA     IdentifyData
)
{
    ULONG i;
    UCHAR flushCommand;
    BOOLEAN done;

    PAGED_CODE();

    ASSERT (FdoExtension);
    ASSERT (PdoExtension);
    ASSERT (IdentifyData);

    done = FALSE;

    //
    // in hall of shame list?
    //
    if (IdePortSearchDeviceInRegMultiSzList (
            FdoExtension,
            IdentifyData, 
            NO_FLUSH_DEVICE)) {

        DebugPrint ((DBG_WARNING, "ATAPI: found a device that couldn't handle any flush command\n"));

        flushCommand = IDE_COMMAND_NO_FLUSH;
        done = TRUE;

    } else  if (IdePortSearchDeviceInRegMultiSzList (
                 FdoExtension,
                 IdentifyData, 
                 CHECK_POWER_FLUSH_DEVICE)) {
    
        DebugPrint ((DBG_WARNING, "ATAPI: found a device that has to use check power mode command to flush\n"));

        flushCommand = IDE_COMMAND_CHECK_POWER;
        done = TRUE;
    } 

    if (!done) { 

        //
        // real ATA-4 drive?
        //

        if ((IdentifyData->MajorRevision != 0x0000) &&
            (IdentifyData->MajorRevision != 0xffff)) {
    
            USHORT version;
    
            version = IdentifyData->MajorRevision & ATA_VERSION_MASK;
            if (version & ~(ATA1_COMPLIANCE | ATA2_COMPLIANCE | ATA3_COMPLIANCE)) {
    
                //
                // ATA-4 Flush Command
                //
                flushCommand = IDE_COMMAND_FLUSH_CACHE;
                done = TRUE;
            }
        } 
    }

    if (!done) { 
            
        ATA_PASS_THROUGH ataPassThroughData;
        NTSTATUS status;
    
        //
        // try the ATA-4 flush command.  maybe it will work.
        //
        RtlZeroMemory (&ataPassThroughData, sizeof (ataPassThroughData));
    
        ataPassThroughData.IdeReg.bCommandReg = IDE_COMMAND_FLUSH_CACHE;
        ataPassThroughData.IdeReg.bReserved = ATA_PTFLAGS_STATUS_DRDY_REQUIRED | ATA_PTFLAGS_ENUM_PROBING;
    
        status = IssueSyncAtaPassThroughSafe (
                     FdoExtension,
                     PdoExtension,
                     &ataPassThroughData,
                     FALSE,
                     FALSE,
                     15,
                     FALSE
                     );
        if (NT_SUCCESS(status)) {
    
            if (!(ataPassThroughData.IdeReg.bCommandReg & IDE_STATUS_ERROR)) {
    
                flushCommand = IDE_COMMAND_FLUSH_CACHE;
                done = TRUE;
            }
        }
    }

    if (!done) {

        // out of idea!
        // choose the default 

        flushCommand = IDE_COMMAND_CHECK_POWER;
    }

    return flushCommand;
}
                
#if 0
BOOLEAN
IdePortReuseIdent(
    IN PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA IdentifyData
    )
{
    PAGED_CODE();
    //
    // Determine if we can re-use the identify data
    //
    if (IdePortSearchDeviceInRegMultiSzList (
            FdoExtension, 
            IdentifyData, 
            NEED_IDENT_DEVICE)) {
        return TRUE;
    }
    return FALSE;
}
#endif
                
BOOLEAN
IdePortMustBePio (
    IN PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA IdentifyData
    )
{
    PAGED_CODE();

    //
    // query pio only device from the registry
    //
    if (IdePortSearchDeviceInRegMultiSzList (
            FdoExtension, 
            IdentifyData, 
            PIO_ONLY_DEVICE)) {

        return TRUE;
    }

    return FALSE;
} // IdePortMustBePio
                
                
BOOLEAN
IdePortPioByDefaultDevice (
    IN PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA IdentifyData
    )
{
    PAGED_CODE();

    //
    // query pio only device from the registry
    //
    if (IdePortSearchDeviceInRegMultiSzList (
            FdoExtension, 
            IdentifyData, 
            DEFAULT_PIO_DEVICE)) {

        return TRUE;
    }

    return FALSE;
} // IdePortMustBePio

BOOLEAN
IdePortDeviceHasNonRemovableMedia (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA     IdentifyData
)
{
    BOOLEAN removableMediaOverride;
    PAGED_CODE();

    if (IsNEC_98) {
        return ((IdentifyData->GeneralConfiguration & (1 << 7))? TRUE :
                    (!Is98LegacyIde(&FdoExtension->HwDeviceExtension->BaseIoAddress1)? TRUE : FALSE));
    }

    return (IdentifyData->GeneralConfiguration & (1 << 7)) ? TRUE : FALSE; 

    /*
    removableMediaOverride = FALSE;
    if (IdePortSearchDeviceInRegMultiSzList (
            FdoExtension, 
            IdentifyData, 
            NONREMOVABLE_MEDIA_OVERRIDE)) {

        removableMediaOverride = TRUE;
    }

    if (removableMediaOverride) {

        return FALSE;

    } else {

        return (IdentifyData->GeneralConfiguration & (1 << 7)) ? TRUE : FALSE; 
    }
    */
}
                
                
BOOLEAN
IdePortDeviceIsLs120 (
    IN PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA IdentifyData
    )
{
    UCHAR modelNumber[41];
    ULONG i;
    UCHAR ls120NameString[] = "LS-120";

    PAGED_CODE();

    //
    // byte swap model number
    //
    for (i=0; i<40; i+=2) {
        modelNumber[i + 0] = IdentifyData->ModelNumber[i + 1];
        modelNumber[i + 1] = IdentifyData->ModelNumber[i + 0];
    }
    modelNumber[i] = 0;

    return strstr(_strupr(modelNumber), ls120NameString) ? TRUE : FALSE;
} // IdePortDeviceIsLs120
                
                
BOOLEAN
IdePortNoPowerDown (
    IN PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA IdentifyData
    )
{
    PAGED_CODE();

    //
    // query no power down device from the registry
    //
    if (IdePortSearchDeviceInRegMultiSzList (
            FdoExtension, 
            IdentifyData, 
            NO_POWER_DOWN_DEVICE)) {

        return TRUE;
    }

    return FALSE;
} // IdePortNoPowerDown

BOOLEAN
IdePortVerifyDma (
    IN PPDO_EXTENSION pdoExtension,
    IN IDE_DEVICETYPE ideDeviceType
    )
{
    NTSTATUS status;
    ULONG oldDmaTransferTimeoutCount;
    BOOLEAN dmaOk;


    dmaOk = TRUE;
    
    if (pdoExtension->DmaTransferTimeoutCount >= PDO_DMA_TIMEOUT_LIMIT) {

        dmaOk = FALSE;

    } else if (ideDeviceType == DeviceIsAtapi) {

        INQUIRYDATA DmaInquiryData;
        INQUIRYDATA PioInquiryData;

        status = IssueInquirySafe(
                    pdoExtension->ParentDeviceExtension, 
                    pdoExtension, 
                    &DmaInquiryData,
                    FALSE);

        if (NT_SUCCESS(status)) {

            //
            // force a pio transfer
            //
            oldDmaTransferTimeoutCount = InterlockedExchange(
                                             &pdoExtension->DmaTransferTimeoutCount,
                                             PDO_DMA_TIMEOUT_LIMIT
                                             );
            status = IssueInquirySafe(
                        pdoExtension->ParentDeviceExtension, 
                        pdoExtension, 
                        &PioInquiryData,
                        FALSE);

            if (NT_SUCCESS(status) && 
                (RtlCompareMemory (&DmaInquiryData, &PioInquiryData,
                 sizeof(DmaInquiryData)) != sizeof(DmaInquiryData))) {


                dmaOk = FALSE;

                //
                // dma is not ok, leave the dma error count as PDO_DMA_TIMEOUT_LIMIT
                // so that we are not going to use dma with this device
                //
            } else {

                InterlockedExchange(
                    &pdoExtension->DmaTransferTimeoutCount,
                    oldDmaTransferTimeoutCount
                    ); 
            }
        }

    } else if (ideDeviceType == DeviceIsAta) {

        PUCHAR dmaDataBuffer;
        PUCHAR pioDataBuffer;
        CDB  cdb;

        //
        // the only non-desctrutive way to test dma on a 
        // ata device is to perform a pio read and a dma read and
        // compare the data.
        //
        // this technique does not work if the device has a removable
        // media and it is removed.
        //

        dmaDataBuffer = ExAllocatePool (
                           NonPagedPool,
                           512 * 2
                           );
        if (dmaDataBuffer) {

            pioDataBuffer = dmaDataBuffer + 512;

            //
            // setup dma pass through
            //
            RtlZeroMemory(&cdb, sizeof(CDB));
            cdb.CDB10.OperationCode = SCSIOP_READ;
            cdb.CDB10.TransferBlocksLsb = 1;

            status = IssueSyncAtapiCommandSafe (
                         pdoExtension->ParentDeviceExtension, 
                         pdoExtension,
                         &cdb,
                         dmaDataBuffer,
                         512,
                         TRUE,
                         2,
                         FALSE
                         );

            if (NT_SUCCESS(status)) {

                //
                // setup pio pass through
                //
                RtlZeroMemory(&cdb, sizeof(CDB));
                cdb.CDB10.OperationCode = SCSIOP_READ;
                cdb.CDB10.TransferBlocksLsb = 1;

                //
                // force a pio transfer
                //
                oldDmaTransferTimeoutCount = InterlockedExchange(
                                                 &pdoExtension->DmaTransferTimeoutCount,
                                                 PDO_DMA_TIMEOUT_LIMIT
                                                 );

                status = IssueSyncAtapiCommand (
                             pdoExtension->ParentDeviceExtension, 
                             pdoExtension,
                             &cdb,
                             pioDataBuffer,
                             512,
                             TRUE,
                             2,
                             FALSE
                             );

                if (NT_SUCCESS(status) &&
                    (RtlCompareMemory (
                        dmaDataBuffer,
                        pioDataBuffer,
                        512) != 512)) {

                    dmaOk = FALSE;

                    //
                    // dma is not ok, leave the dma error count as PDO_DMA_TIMEOUT_LIMIT
                    // so that we are not going to use dma with this device
                    //
                } else {

                    InterlockedExchange(
                        &pdoExtension->DmaTransferTimeoutCount,
                        oldDmaTransferTimeoutCount
                        ); 
                }
            }
        }

        if (dmaDataBuffer) {
            ExFreePool (dmaDataBuffer);
        }
    }

#if DBG
#if defined (FAKE_BROKEN_DMA_DEVICE)
    InterlockedExchange(
        &pdoExtension->DmaTransferTimeoutCount,
        PDO_DMA_TIMEOUT_LIMIT
        ); 
    dmaOk = FALSE;
#endif // FAKE_BROKEN_DMA_DEVICE
#endif // DBG

    if (!dmaOk) {

        ERROR_LOG_ENTRY errorLogEntry;

        errorLogEntry.ErrorCode             = SP_BAD_FW_ERROR;
        errorLogEntry.MajorFunctionCode     = IRP_MJ_SCSI;
        errorLogEntry.PathId                = pdoExtension->PathId;
        errorLogEntry.TargetId              = pdoExtension->TargetId;
        errorLogEntry.Lun                   = pdoExtension->Lun;
        errorLogEntry.UniqueId              = ERRLOGID_LYING_DMA_SYSTEM;
        errorLogEntry.ErrorLogRetryCount    = 0;
        errorLogEntry.SequenceNumber        = 0;

        LogErrorEntry(
            pdoExtension->ParentDeviceExtension,
            &errorLogEntry
            );

        DebugPrint ((
            DBG_ALWAYS,
            "ATAPI: system and/or device lies about its dma capability. pdoe = 0x%x\n",
            pdoExtension
            ));
    }

    return dmaOk;
}

VOID
IdePortFudgeAtaIdentifyData(
    IN OUT PIDENTIFY_DATA IdentifyData
    )
{
    if (IdentifyData->GeneralConfiguration == 0xffff) {

        //
        // guessing we have a really old ATA drive
        // fake the GeneralConfiguration value
        //
        CLRMASK (
            IdentifyData->GeneralConfiguration, 
            (IDE_IDDATA_REMOVABLE | (1 << 15))
            );
    }

}

#define PANASONIC_PCMCIA_IDE_DEVICE L"PCMCIA\\KME-KXLC005-A99E"

BOOLEAN
IdePortIsThisAPanasonicPCMCIACard(
    IN PFDO_EXTENSION FdoExtension
    )
{
    IO_STATUS_BLOCK     ioStatus;
    KEVENT              pnpEvent;
    NTSTATUS            status;
    PDEVICE_OBJECT      targetObject;
    PIO_STACK_LOCATION  irpStack;
    PIRP                pnpIrp;
    BOOLEAN             result = FALSE;

    PAGED_CODE();

    targetObject = FdoExtension->AttacheeDeviceObject;

    //
    // Initialize the event
    //
    KeInitializeEvent( &pnpEvent, SynchronizationEvent, FALSE );

    //
    // Build an Irp
    //
    pnpIrp = IoBuildSynchronousFsdRequest(
        IRP_MJ_PNP,
        FdoExtension->AttacheeDeviceObject,
        NULL,
        0,
        NULL,
        &pnpEvent,
        &ioStatus
        );
    if (pnpIrp == NULL) {

        return FALSE;
    }

    //
    // Pnp Irps all begin life as STATUS_NOT_SUPPORTED;
    //
    pnpIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    pnpIrp->IoStatus.Information = 0;

    //
    // Set the top of stack
    //
    irpStack = IoGetNextIrpStackLocation( pnpIrp );
    RtlZeroMemory( irpStack, sizeof(IO_STACK_LOCATION ) );
    irpStack->MajorFunction = IRP_MJ_PNP;
    irpStack->MinorFunction = IRP_MN_QUERY_ID;
    irpStack->Parameters.QueryId.IdType = BusQueryDeviceID;

    //
    // Make sure that there are no completion routines set
    //
    IoSetCompletionRoutine(
        pnpIrp,
        NULL,
        NULL,
        FALSE,
        FALSE,
        FALSE
        );

    //
    // Call the driver
    //
    status = IoCallDriver( targetObject, pnpIrp );
    if (status == STATUS_PENDING) {

        //
        // Block until the irp comes back
        //
        KeWaitForSingleObject(
            &pnpEvent,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );
        status = ioStatus.Status;

    }

    if (NT_SUCCESS(status)) {

        UNICODE_STRING panasonicDeviceId;
        UNICODE_STRING deviceId;

        RtlInitUnicodeString (&panasonicDeviceId, PANASONIC_PCMCIA_IDE_DEVICE);
        RtlInitUnicodeString (&deviceId, (PWCHAR) ioStatus.Information);

        if (!RtlCompareUnicodeString(
            &deviceId, 
            &panasonicDeviceId,
            TRUE)) {

            result = TRUE;
        }

        ExFreePool ((PVOID) ioStatus.Information);
    }

    return result;
}


//
// Timing Code
//
#if defined (ENABLE_TIME_LOG)

TIME_LOG TimeLog[TimeMax] = {0};
VOID
LogStartTime(
    TIME_ID id,
    PLARGE_INTEGER timer
    ) 
{
    *timer = KeQueryPerformanceCounter(NULL);
}

VOID
LogStopTime(
    TIME_ID id,
    PLARGE_INTEGER timer,
    ULONG waterMark
    ) 
{
    LARGE_INTEGER freq;
    LARGE_INTEGER stopTime;
    LARGE_INTEGER diffTime;
    LARGE_INTEGER diffTimeInMicroSec;

    stopTime = KeQueryPerformanceCounter(&freq);
    diffTime.QuadPart = stopTime.QuadPart - timer->QuadPart;
    diffTimeInMicroSec.QuadPart = (diffTime.QuadPart * 1000000) / freq.QuadPart;

    // need a spinlock

    if (TimeLog[id].min.QuadPart == 0) {

        TimeLog[id].min.QuadPart = 0x7fffffffffffffffL;
    }

    if (diffTime.QuadPart < TimeLog[id].min.QuadPart) {
        TimeLog[id].min = diffTime;
    }

    if (diffTime.QuadPart > TimeLog[id].max.QuadPart) {
        TimeLog[id].max = diffTime;
    }

    TimeLog[id].totalTimeInMicroSec.QuadPart += diffTimeInMicroSec.QuadPart;
    TimeLog[id].numLog.QuadPart++;

    if (waterMark) {
        if (diffTimeInMicroSec.LowPart > waterMark) {
    
            DebugPrint ((DBG_ALWAYS, "IdePort: timerID 0x%d took %d us\n", id, (ULONG) diffTimeInMicroSec.LowPart));
        }
    }
}

#endif // ENABLE_TIME_LOG


#if defined (IDE_BUS_TRACE)

ULONG IdePortBusTraceTableMaxEntries = 0x20000;
BUS_TRACE_LOG IdePortBusTaceLog = {0, 0, 0, FALSE};

VOID InitBusTraceLogTable (
    VOID
    )
{
    ASSERT (IdePortBusTaceLog.LogTable == NULL);

    //           
    // make sure MAX_ULONG + 1 is a multiple of total log entries
    // so that when the index wraps, we don't skin any log entry
    //
    ASSERT(!((((ULONGLONG) 0xffffffff) + 1) % IdePortBusTraceTableMaxEntries));

    IdePortBusTaceLog.LogTable = 
        ExAllocatePool (NonPagedPool, IdePortBusTraceTableMaxEntries * sizeof(BUS_TRACE_RECORD));

    if (IdePortBusTaceLog.LogTable) {
        IdePortBusTaceLog.NumLogTableEntries = IdePortBusTraceTableMaxEntries;
        IdePortBusTaceLog.LastLogTableEntry = -1;
        IdePortBusTaceLog.TableWrapped = FALSE;

        KeInitializeSpinLock(&IdePortBusTaceLog.SpinLock);
    }
}

VOID FreeBusTraceLogTable (
    VOID
    )
{
    if (IdePortBusTaceLog.LogTable) {

        ExFreePool (IdePortBusTaceLog.LogTable);
        RtlZeroMemory(&IdePortBusTaceLog, sizeof(IdePortBusTaceLog));
    }
}


VOID
IdepUpdateTraceLog (
    IO_TYPE IoType,
    PVOID PortAddress,
    ULONG Data
    )
{
    KIRQL currentIrql;
    ULONG lastEntry;

    if (IdePortBusTaceLog.LogTable) {

        lastEntry = InterlockedIncrement(&IdePortBusTaceLog.LastLogTableEntry);
        lastEntry--;
        lastEntry %= IdePortBusTaceLog.NumLogTableEntries;
        IdePortBusTaceLog.LogTable[lastEntry].IoType = IoType;
        IdePortBusTaceLog.LogTable[lastEntry].Address = PortAddress;
        IdePortBusTaceLog.LogTable[lastEntry].Data = Data;
        IdePortBusTaceLog.LogTable[lastEntry].Count = 1;
    }
}

UCHAR
IdepPortInPortByte (
    PUCHAR PortAddress
    )
{
    KIRQL currentIrql;
    UCHAR data;

    data = READ_PORT_UCHAR(PortAddress);
    IdepUpdateTraceLog (InPortByte, PortAddress, (ULONG) data);
    return data;
}

VOID
IdepPortOutPortByte (
    PUCHAR PortAddress,
    UCHAR Data
    )
{
    WRITE_PORT_UCHAR(PortAddress, Data);
    IdepUpdateTraceLog (OutPortByte, PortAddress, (ULONG) Data);
    return;
}

USHORT
IdepPortInPortWord (
    PUSHORT PortAddress
    )
{
    KIRQL currentIrql;
    USHORT data;

    data = READ_PORT_USHORT(PortAddress);
    IdepUpdateTraceLog (InPortWord, PortAddress, (ULONG) data);
    return data;
}

VOID
IdepPortOutPortWord (
    PUSHORT PortAddress,
    USHORT Data
    )
{
    WRITE_PORT_USHORT(PortAddress, Data);
    IdepUpdateTraceLog (OutPortWord, PortAddress, (ULONG) Data);
    return;
}

VOID
IdepPortInPortWordBuffer (
    PUSHORT PortAddress,
    PUSHORT Buffer,
    ULONG Count
    )
{
    ULONG i;
    for (i=0; i<Count; i++) {
        Buffer[i] = IdepPortInPortWord (PortAddress);
    }
    return;
}


VOID
IdepPortOutPortWordBuffer (
    PUSHORT PortAddress,
    PUSHORT Buffer,
    ULONG Count
    )
{
    ULONG i;
    for (i=0; i<Count; i++) {
        IdepPortOutPortWord (PortAddress, Buffer[i]);
    }
    return;
}

#endif // IDE_BUS_TRACE



SPECIAL_ACTION_FLAG
IdeFindSpecialDevice(
    IN PUCHAR VendorProductId,
    IN PUCHAR ProductRevisionId
)
/*++

Routine Description:

    This routine will search the IDE special device table to determine whether 
    any special behavior should be enabled for this device. The match is made upto 
    the strlen of VendorProductId in the table.
    
Arguments:

    VendorProductId - the full vendor & product ID of the device in question.    
    ProductRevisionId - the full product revision ID of the device in question.    

ReturnValue:

    an ulong which describes the limitations of the device 
    in question.
    
--*/

{
    IDE_SPECIAL_DEVICE IdeSpecialDeviceTable[] = {
        {"TOSHIBA CD-ROM XM-1702B", NULL, disableSerialNumber},
        {"TOSHIBA CD-ROM XM-6202B", NULL, disableSerialNumber},
        {"COMPAQ DVD-ROM DRD-U424", NULL, disableSerialNumber},
        {"           "            , NULL, disableSerialNumber},
        {"KENWOOD CD-ROM",          NULL, skipModeSense},
        {"MEMORYSTICK",             NULL, setFlagSonyMemoryStick},
        {NULL,                      NULL, noSpecialAction}
        };
    
    ULONG i;
    ULONG length;

    PAGED_CODE();

    //
    // if both the arguments are null, then just return no special action
    //
    if (VendorProductId == NULL &&
        ProductRevisionId == NULL) {
        return noSpecialAction;
    }

    for(i = 0; IdeSpecialDeviceTable[i].VendorProductId != NULL; i++) {

        //
        // Match only upto the strlen of the productID in the table
        // This will allow special action for all the models from a particular vendor.
        //
        length=strlen(IdeSpecialDeviceTable[i].VendorProductId);

        if (length != RtlCompareMemory(IdeSpecialDeviceTable[i].VendorProductId, 
                                                VendorProductId, length)) {

            continue;
        }

        //
        // Partial matches are not acceptable for revision Ids.
        //
        if((IdeSpecialDeviceTable[i].Revision != NULL) &&
           (strcmp(IdeSpecialDeviceTable[i].Revision,
                    ProductRevisionId) != 0)) {
            continue;
        }

        //
        // We've got a match.  Break out.
        //

        break;
    }

    //
    // Return whatever entry we're pointing at.  If we matched based on the
    // id's then this will be the matching entry.  If we broke out of the 
    // loop then this will be the last entry in the list which is the 
    // benign, "nothing special about this device" entry that we return 
    // for a failed match.
    //

    return (IdeSpecialDeviceTable[i].RequiredAction);
}

#ifdef ENABLE_COMMAND_LOG

VOID
IdeLogOpenCommandLog(
    PSRB_DATA SrbData
)
{
    if (SrbData->IdeCommandLog == NULL) {
        SrbData->IdeCommandLog = ExAllocatePool(
                                            NonPagedPool, 
                                            MAX_COMMAND_LOG_ENTRIES*sizeof(COMMAND_LOG)
                                            );
        if (SrbData->IdeCommandLog != NULL) {
            RtlZeroMemory(SrbData->IdeCommandLog, MAX_COMMAND_LOG_ENTRIES*sizeof(COMMAND_LOG));
        }

        SrbData->IdeCommandLogIndex = 0;
    }
    return;
}

VOID
IdeLogStartCommandLog(
    PSRB_DATA SrbData
)
{
    PCOMMAND_LOG cmdLog = &(SrbData->IdeCommandLog[SrbData->IdeCommandLogIndex]);
    PSCSI_REQUEST_BLOCK srb = SrbData->CurrentSrb;

    ASSERT(srb);

    if (cmdLog == NULL) {
        return;
    }

    UpdateStartTimeStamp(cmdLog);

    if (srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH ||
        srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH) {

        PATA_PASS_THROUGH ataPassThroughData = srb->DataBuffer;
        cmdLog->Cdb[0]= srb->Function;
        RtlCopyMemory(&(cmdLog->Cdb[1]), &(ataPassThroughData->IdeReg), sizeof(IDEREGS));

    } else {

        RtlCopyMemory(&(cmdLog->Cdb), &(srb->Cdb), sizeof(CDB));
    }
    return;
}

VOID
IdeLogStopCommandLog(
    PSRB_DATA SrbData
)
{
    PCOMMAND_LOG cmdLog = &(SrbData->IdeCommandLog[SrbData->IdeCommandLogIndex]);
    PSCSI_REQUEST_BLOCK srb = SrbData->CurrentSrb;
	PSENSE_DATA senseBuffer = NULL;
    ULONG senseInfoBufferLength;

    ASSERT(srb);

    if (cmdLog == NULL) {
        return;
    }

    UpdateStopTimeStamp(cmdLog);

    if (srb->Cdb[0] == SCSIOP_REQUEST_SENSE) {
        senseBuffer = srb->DataBuffer;
        senseInfoBufferLength = srb->DataTransferLength;
    } else if (srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) {
        senseBuffer = srb->SenseInfoBuffer;
        senseInfoBufferLength = (ULONG) srb->SenseInfoBufferLength;
	}

	if (senseBuffer && (senseInfoBufferLength > FIELD_OFFSET(SENSE_DATA, AdditionalSenseCodeQualifier))) {
		cmdLog->SenseData[0] = senseBuffer->SenseKey;
		cmdLog->SenseData[1] = senseBuffer->AdditionalSenseCode;
		cmdLog->SenseData[2] = senseBuffer->AdditionalSenseCodeQualifier;
	}else {
		cmdLog->SenseData[0] = 0;
		cmdLog->SenseData[1] = 0;
		cmdLog->SenseData[2] = 0;
	}

    cmdLog->SrbStatus = srb->SrbStatus;

    SrbData->IdeCommandLogIndex = ( SrbData->IdeCommandLogIndex + 1) % MAX_COMMAND_LOG_ENTRIES;
    return;
}

VOID
IdeLogSaveTaskFile(
    PSRB_DATA SrbData,
    PIDE_REGISTERS_1 BaseIoAddress
)
{
    PCOMMAND_LOG cmdLog = &(SrbData->IdeCommandLog[SrbData->IdeCommandLogIndex]);

    if (cmdLog == NULL) {
        return;
    }

    AtapiTaskRegisterSnapshot(BaseIoAddress, &(cmdLog->FinalTaskFile));
    return;
}

VOID
IdeLogBmStatus(
    PSCSI_REQUEST_BLOCK Srb,
    BMSTATUS   BmStatus
)
{
    PSRB_DATA srbData = IdeGetSrbData(NULL, Srb);
    PCOMMAND_LOG cmdLog;

    if (srbData == NULL) {
        return;
    }

    cmdLog = &(srbData->IdeCommandLog[srbData->IdeCommandLogIndex]);
    if (cmdLog == NULL) {
        return;
    }

    cmdLog->BmStatus = BmStatus;
    return;
}

VOID
IdeLogFreeCommandLog(
    PSRB_DATA   SrbData
)
{
    PCOMMAND_LOG cmdLog = SrbData->IdeCommandLog;

    if (cmdLog) {
        ExFreePool(cmdLog);
    }
    SrbData->IdeCommandLog = NULL;      
    SrbData->IdeCommandLogIndex = 0;      
}
#endif

#ifdef ENABLE_ATAPI_VERIFIER

PVOID ViIdeExtensionTable[2];

#define VFLAGS_FORCE_TIMEOUT    (1<<0)
#define VFLAGS_DMA_TIMEOUT      (1<<1)
#define VFLAGS_CFLUSH_TIMEOUT   (1<<2)
#define VFLAGS_DEVICE_CHANGE    (1<<3)
#define VFLAGS_MISSING_DEVICE   (1<<4)
#define VFLAGS_ACTUAL_ERROR     (1<<5)
#define VFLAGS_CRC_ERROR        (1<<6)
#define VFLAGS_BUSY_ERROR       (1<<7)
#define VFLAGS_RW_ERROR         (1<<8)

VOID
ViIdeInitVerifierSettings(
    IN PFDO_EXTENSION   FdoExtension
)
{
}

BOOLEAN
ViIdeGenerateDmaTimeout(
    IN PVOID HwDeviceExtension, 
    IN BOOLEAN DmaInProgress
) 
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = HwDeviceExtension;
    PFDO_EXTENSION fdoExtension = ((PFDO_EXTENSION)HwDeviceExtension - 1); 
    PSCSI_REQUEST_BLOCK srb = hwDeviceExtension->CurrentSrb;
    ULONG ideInternalVerifierFlags ;

    ASSERT(srb);

    ideInternalVerifierFlags = fdoExtension->IdeInternalVerifierFlags[srb->TargetId];

    if (ideInternalVerifierFlags & VFLAGS_FORCE_TIMEOUT) {
        return TRUE;
    }

    if (DmaInProgress && (ideInternalVerifierFlags & VFLAGS_DMA_TIMEOUT)) { 
        return TRUE;
    }

    if ((srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH) ||
        (srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH)) {

        PATA_PASS_THROUGH    ataPassThroughData;
        PIDEREGS             pIdeReg;

        ataPassThroughData = srb->DataBuffer;
        pIdeReg            = &ataPassThroughData->IdeReg;

        if ((ideInternalVerifierFlags & VFLAGS_CFLUSH_TIMEOUT) &&
            (pIdeReg->bCommandReg == hwDeviceExtension->DeviceParameters[srb->TargetId].IdeFlushCommand )) {
            return TRUE;
        }
    }

    return FALSE;
}

ULONG
ViIdeFakeDeviceChange(
    IN PFDO_EXTENSION FdoExtension,
    ULONG   Target
)
{
    ULONG ideInternalVerifierFlags = FdoExtension->IdeDebugVerifierFlags[Target];

    if (ideInternalVerifierFlags & VFLAGS_DEVICE_CHANGE) {
        return 1;
    }

    return 0;
}

BOOLEAN
ViIdeFakeMissingDevice(
    IN PFDO_EXTENSION FdoExtension,
    ULONG Target
)
{
    ULONG ideInternalVerifierFlags = FdoExtension->IdeDebugVerifierFlags[Target];

    if (ideInternalVerifierFlags & VFLAGS_MISSING_DEVICE) {
        return TRUE;
    }

    return FALSE;
}
VOID
ViAtapiInterrupt(
    IN PFDO_EXTENSION FdoExtension
    )
{
    PHW_DEVICE_EXTENSION hwDeviceExtension = FdoExtension->HwDeviceExtension;
    PIDE_REGISTERS_1 baseIoAddress = &(hwDeviceExtension->BaseIoAddress1);
    PSCSI_REQUEST_BLOCK srb = hwDeviceExtension->CurrentSrb;
    ULONG target;

    //DebugPrint((0, "verifier interrupt fdoe = %x, b=%x\n", FdoExtension, baseIoAddress->RegistersBaseAddress));

    if ((ULONG)(baseIoAddress->RegistersBaseAddress) == 0x1f0) {
        ViIdeExtensionTable[0]=FdoExtension;
    } else {
        ViIdeExtensionTable[1]=FdoExtension;
    }

    if (srb == NULL) {
        return ;
    }

    target = srb->TargetId;

    //
    // Generate timeouts
    //
    if (FdoExtension->IdeDebugVerifierFlags[target] & VFLAGS_DMA_TIMEOUT) {
        FdoExtension->IdeInternalVerifierFlags[target] |= VFLAGS_DMA_TIMEOUT;
        return;
    }

    //
    // Generate CRC errors
    //
    if (FdoExtension->IdeDebugVerifierFlags[target] & VFLAGS_CRC_ERROR) {
        if (FdoExtension->IdeVerifierEventCount[target][CrcEvent] >= FdoExtension->IdeVerifierEventFrequency[target][CrcEvent]) {
            FdoExtension->IdeInternalVerifierFlags[target] |= VFLAGS_CRC_ERROR;
            FdoExtension->IdeVerifierEventCount[target][CrcEvent]=0;
            return;
        } else {
            FdoExtension->IdeVerifierEventCount[target][RwEvent]++;
        }
    }

    //
    // Generate Busy errors
    //
    if (FdoExtension->IdeDebugVerifierFlags[target] & VFLAGS_BUSY_ERROR) {
        if (FdoExtension->IdeVerifierEventCount[target][BusyEvent] >= FdoExtension->IdeVerifierEventFrequency[target][BusyEvent]) {
            FdoExtension->IdeInternalVerifierFlags[target] |= VFLAGS_BUSY_ERROR;
            FdoExtension->IdeVerifierEventCount[target][BusyEvent]=0;
            return;
        } else {
            FdoExtension->IdeVerifierEventCount[target][BusyEvent]++;
        }
    }

    //
    // Generate Read write errors
    //
    if (FdoExtension->IdeDebugVerifierFlags[target] & VFLAGS_RW_ERROR) {
        if (FdoExtension->IdeVerifierEventCount[target][RwEvent] >= FdoExtension->IdeVerifierEventFrequency[target][RwEvent]) {
            FdoExtension->IdeInternalVerifierFlags[target] |= VFLAGS_RW_ERROR;
            FdoExtension->IdeVerifierEventCount[target][RwEvent]=0;
            return;
        } else {
            FdoExtension->IdeVerifierEventCount[target][RwEvent]++;
        }
    }
//    ViIdeGenerateReadWriteErrors(FdoExtension);

 //   ViIdeGenerateDmaErrors(FdoExtension);
//    ViIdeFakeHungController(FdoExtension);
    return ;
}

UCHAR
ViIdeGetBaseStatus(
    PIDE_REGISTERS_1 BaseIoAddress
)
{
    UCHAR status = IdePortInPortByte((BaseIoAddress)->Command);
    /*
    UCHAR deviceSelect = IdePortInPortByte(BaseIoAddress->DriveSelect);
    UCHAR channel = ((ULONG)(BaseIoAddress->RegistersBaseAddress) == 0x1f0) ? 0: 1;
    PFDO_EXTENSION fdoExtension = ViIdeExtensionTable[channel];
    ULONG target = (deviceSelect == 0xA0)? 0: 1;
    ULONG ideInternalVerifierFlags; 
    ULONG dFlags;

    if (fdoExtension == NULL) {
        return status;
    }

    ideInternalVerifierFlags = fdoExtension->IdeInternalVerifierFlags[target];
    dFlags = fdoExtension->HwDeviceExtension->DeviceFlags[target];

    if (status & IDE_STATUS_ERROR) {
        SETMASK(fdoExtension->IdeInternalVerifierFlags[target], VFLAGS_ACTUAL_ERROR);
        return status;
    }

    if (ideInternalVerifierFlags & VFLAGS_CRC_ERROR) {
        return IDE_STATUS_ERROR;
    }

    if (ideInternalVerifierFlags & VFLAGS_BUSY_ERROR) {
        return IDE_STATUS_BUSY;
    }

    if (ideInternalVerifierFlags & VFLAGS_RW_ERROR) {
        return IDE_STATUS_ERROR;
    }
    */
    return status;
}

UCHAR
ViIdeGetErrorByte(
    PIDE_REGISTERS_1 BaseIoAddress
)
/**++
Description:
    Depending on the internalVerifier flag (set by the other verifier routines),
    this function will return the appropriate error value. However, if the device
    reports an actual error (as indicated by the internalverifier flag), 
    it is returned unchanged.
    
Arguments:
    BaseIoAddress : Task file registers
    
Return Value:    
    The error byte.
--**/
{
    UCHAR error = IdePortInPortByte(BaseIoAddress->Error);
    /*
    UCHAR deviceSelect = IdePortInPortByte(BaseIoAddress->DriveSelect);
    UCHAR channel = ((ULONG)(BaseIoAddress->RegistersBaseAddress) == 0x1f0) ? 0: 1;
    PFDO_EXTENSION fdoExtension = ViIdeExtensionTable[channel];
    ULONG target = (deviceSelect == 0xA0)? 0: 1;
    ULONG ideInternalVerifierFlags;
    ULONG dFlags;

    if (fdoExtension == NULL ) {
        return error;
    }
    
    ideInternalVerifierFlags = fdoExtension->IdeInternalVerifierFlags[target];
    dFlags = fdoExtension->HwDeviceExtension->DeviceFlags[target];

    //
    // return error if an actual error was reproted
    //
    if (ideInternalVerifierFlags & VFLAGS_ACTUAL_ERROR) {
        CLRMASK(fdoExtension->IdeInternalVerifierFlags[target], VFLAGS_ACTUAL_ERROR);
        return error;
    }

    if (ideInternalVerifierFlags & VFLAGS_CRC_ERROR) {

        if (dFlags & DFLAGS_ATAPI_DEVICE) {
            error = SCSI_SENSE_HARDWARE_ERROR << 4;
        } else {
            error = IDE_ERROR_CRC_ERROR | IDE_ERROR_COMMAND_ABORTED;
        }
        return error;
    }
    */
    return error;
}

#endif

#ifdef IDE_MEASURE_BUSSCAN_SPEED
VOID
LogBusScanStartTimer(
    PLARGE_INTEGER TickCount
)
{
    KeQueryTickCount(TickCount);
    return;
}

ULONG
LogBusScanStopTimer(
    PLARGE_INTEGER TickCount
)
{
    LARGE_INTEGER tickCount2;
    LARGE_INTEGER numMs;
    KeQueryTickCount(&tickCount2);
    numMs.QuadPart = ((tickCount2.QuadPart - TickCount->QuadPart) * KeQueryTimeIncrement()) / (10 * 1000);

    return(numMs.u.LowPart);
}

#endif

VOID
FASTCALL
IdePortLogNoMemoryErrorFn(
    IN PVOID DeviceExtension,
    IN ULONG TargetId,
    IN POOL_TYPE PoolType,
    IN SIZE_T Size,
    IN ULONG FailureLocationId,
    IN ULONG Tag
    )

/*++

Routine Description:

    This routine writes a message to the event log indicating that an
    allocation failure has occurred.

Arguments:

    DeviceExtension - Fdo Extension

    TargetId     - The target Id of the device that the request was to be sent to
    
    PoolType     - identifies the pool the failed allocation attempt was from.

    Size         - indicates the number of bytes that the failed allocation 
                   attempt tried to obtain.

    Tag          - identifies the pool tag associated with the failed 
                   allocation.
    
    LocationId   - identifies the location in the source code where it failed

Return Value:

    VOID

--*/

{
    NTSTATUS status;
    PFDO_EXTENSION deviceExtension = (PFDO_EXTENSION) (DeviceExtension);
    PIO_ERROR_LOG_PACKET errorLogEntry;
    PIO_ERROR_LOG_PACKET currentValue;

	InterlockedIncrement(&deviceExtension->NumMemoryFailure);

    //
    // Try to allocate a new error log event.
    //
    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
                        deviceExtension->DeviceObject,
                        ALLOC_FAILURE_LOGSIZE
                        );


    //
    // If we could not allocate a log event, we check the device extension to
    // see if it has a reserve event we can use.  If we cannot get the device
    // extension or if it does not contain a reserve event, we return
    // without logging the allocation failure.
    //

    if (errorLogEntry == NULL) {

        //
        // Get the reserve event in the device extension.  The reserve event
        // may have already been used, so it's possible that it is NULL.  If
        // this is the case, we give up and return.
        //
        errorLogEntry = (PIO_ERROR_LOG_PACKET)
                deviceExtension->ReserveAllocFailureLogEntry[TargetId];


        if (errorLogEntry == NULL) {
            DebugPrint((1, "IdePortLogAllocationFailureFn: no reserve packet\n"));
            return;
        }

        //
        // We have to ensure that we are the only instance to use this
        // event.  To do so, we attempt to NULL the event in the driver
        // extension.  If somebody else beats us to it, they own the
        // event and we have to give up.
        //

        currentValue = InterlockedCompareExchangePointer(
                            &(deviceExtension->ReserveAllocFailureLogEntry[TargetId]),
                            NULL,
                            errorLogEntry
                            );

        if (errorLogEntry != currentValue) {
            DebugPrint((1, "IdePortLogAllocationFailureFn: someone already owns packet\n"));
            return;
        }
    }

    //
    // Log the error
    //
    errorLogEntry->ErrorCode = IO_WARNING_ALLOCATION_FAILED;
    errorLogEntry->SequenceNumber = 0;
    errorLogEntry->MajorFunctionCode = 0;
    errorLogEntry->RetryCount = 0;
    errorLogEntry->UniqueErrorValue = 0x10;
    errorLogEntry->FinalStatus = STATUS_INSUFFICIENT_RESOURCES;
    errorLogEntry->DumpDataSize = 4 * sizeof(ULONG);
    errorLogEntry->DumpData[0] = TargetId;
    errorLogEntry->DumpData[1] = FailureLocationId;
    errorLogEntry->DumpData[2] = PtrToUlong((PVOID)Size);
    errorLogEntry->DumpData[3] = Tag;
    IoWriteErrorLogEntry(errorLogEntry);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\hack.h ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    hack.h

Abstract:

--*/

#if !defined (___hack_h___)
#define ___hack_h___

extern ULONG IdeDebug;

extern ULONG IdeDebugRescanBusFreq;
extern ULONG IdeDebugRescanBusCounter;

extern ULONG IdeDebugHungControllerFreq;
extern ULONG IdeDebugHungControllerCounter;

extern ULONG IdeDebugTimeoutAllCacheFlush;

extern ULONG IdeDebugForceSmallCrashDumpBlockSize;

extern PDEVICE_OBJECT IdeDebugDevObjTimeoutAllDmaSrb;

extern ULONG FailBmSetupCount;

extern ULONG IdeDebugFakeCrcError;

VOID
IdeDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#ifdef DebugPrint
#undef DebugPrint
#endif

#if DBG
#define DebugPrint(x) IdeDebugPrint x

#define DBG_BIT_CONTROL 0x80000000
#define DBG_ALWAYS      DBG_BIT_CONTROL
#define DBG_BUSSCAN           (DBG_BIT_CONTROL | 0x00000001)
#define DBG_PNP               (DBG_BIT_CONTROL | 0x00000002)
#define DBG_POWER             (DBG_BIT_CONTROL | 0x00000004)
#define DBG_READ_WRITE        (DBG_BIT_CONTROL | 0x00000008)
#define DBG_CRASHDUMP         (DBG_BIT_CONTROL | 0x00000010)
#define DBG_ACPI              (DBG_BIT_CONTROL | 0x00000020)
#define DBG_RESET             (DBG_BIT_CONTROL | 0x00000040)
#define DBG_PDO_LOCKTAG       (DBG_BIT_CONTROL | 0x00000080)
#define DBG_WMI               (DBG_BIT_CONTROL | 0x00000100)
#define DBG_IDEREADCAP        (DBG_BIT_CONTROL | 0x00000200)
#define DBG_WARNING           (DBG_BIT_CONTROL | 0x00000400)
#define DBG_REG_SEARCH        (DBG_BIT_CONTROL | 0x00000800)
#define DBG_IDE_DEVICE_ERROR  (DBG_BIT_CONTROL | 0x00001000)
#define DBG_ATAPI_DEVICES     (DBG_BIT_CONTROL | 0x00002000)
#define DBG_XFERMODE          (DBG_BIT_CONTROL | 0x00004000)

#ifdef IDE_MEASURE_BUSSCAN_SPEED
#define DBG_SPECIAL           DBG_ALWAYS
#else
#define DBG_SPECIAL           (DBG_BIT_CONTROL | 0x00008000)
#endif


#else
#define DebugPrint(x)
#endif
          
BOOLEAN
IdePortSlaveIsGhost (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA MasterIdentifyData,
    IN PIDENTIFY_DATA SlaveIdentifyData
    );
                      
UCHAR
IdePortGetFlushCommand (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN OUT PPDO_EXTENSION PdoExtension,
    IN PIDENTIFY_DATA     IdentifyData
    );
          

BOOLEAN
IdePortMustBePio (
    IN PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA IdentifyData
    );
                     
BOOLEAN
IdePortPioByDefaultDevice (
    IN PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA IdentifyData
    );

BOOLEAN
IdePortDeviceHasNonRemovableMedia (
    IN OUT PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA     IdentifyData
    );
                      
BOOLEAN
IdePortDeviceIsLs120 (
    IN PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA IdentifyData
    );
                      
BOOLEAN
IdePortNoPowerDown (
    IN PFDO_EXTENSION FdoExtension,
    IN PIDENTIFY_DATA IdentifyData
    );
                      
BOOLEAN
IdePortVerifyDma (
    IN PPDO_EXTENSION pdoExtension,
    IN IDE_DEVICETYPE ideDeviceType
    );

VOID
IdePortFudgeAtaIdentifyData(
    IN OUT PIDENTIFY_DATA IdentifyData
    );

BOOLEAN
IdePortIsThisAPanasonicPCMCIACard(
    IN PFDO_EXTENSION FdoExtension
    );


VOID
FASTCALL
IdePortLogNoMemoryErrorFn(
    IN PVOID DeviceExtension,
    IN ULONG TargetId,
    IN POOL_TYPE PoolType,
    IN SIZE_T Size,
    IN ULONG LocationIdentifier,
    IN ULONG Tag
    );

typedef enum {
    noSpecialAction=0,
    disableSerialNumber,
    setFlagSonyMemoryStick,
    skipModeSense
}SPECIAL_ACTION_FLAG;

typedef struct _IDE_SPECIAL_DEVICE {
    PUCHAR VendorProductId;
    PUCHAR Revision;
    SPECIAL_ACTION_FLAG RequiredAction;
} IDE_SPECIAL_DEVICE, *PIDE_SPECIAL_DEVICE;

SPECIAL_ACTION_FLAG
IdeFindSpecialDevice(
    IN PUCHAR VendorProductId,
    IN PUCHAR ProductRevisionId
    );

// Model number can be atmost 40 ascii characters
#define MAX_MODELNUM_SIZE   40
#define MEMSTICKID   "MEMORYSTICK"

//procure the model number from the identify data
#define GetTargetModelId(IdentifyData, targetModelNum) {\
    ULONG i; \
    ASSERT(MAX_MODELNUM_SIZE <= sizeof(IdentifyData->ModelNumber)); \
    for (i=0; i<sizeof(IdentifyData->ModelNumber); i+=2) { \
        targetModelNum[i + 0] = IdentifyData->ModelNumber[i + 1]; \
        targetModelNum[i + 1] = IdentifyData->ModelNumber[i + 0]; \
        if (targetModelNum[i + 0] == '\0') { \
            targetModelNum[i + 0] = ' '; \
        }\
        if (targetModelNum[i + 1] == '\0') { \
            targetModelNum[i + 1] = ' '; \
        } \
    } \
    for (i = sizeof(IdentifyData->ModelNumber)-1;i>0; i--) { \
        if (targetModelNum[i] != ' ') { \
            ASSERT(i < MAX_MODELNUM_SIZE); \
            targetModelNum[i+1]='\0'; \
            break; \
        } \
    } \
    if (i == 0) { \
        if (targetModelNum[i] != ' ') { \
            ASSERT(i < MAX_MODELNUM_SIZE); \
            targetModelNum[i+1]='\0'; \
        } else { \
            targetModelNum[i]='\0'; \
        } \
    } \
}

#define ALLOC_FAILURE_LOGSIZE  (sizeof(IO_ERROR_LOG_PACKET) + 4 * sizeof(ULONG))
#define IdeLogNoMemoryError(a, b, c, d, e) IdePortLogNoMemoryErrorFn(a, b, c, d, e, 'PedI')
//
// Log dead meat info.
//
#ifdef LOG_DEADMEAT_EVENT

#define IdeLogDeadMeatEvent(filName, lineNum) { \
    filName = __FILE__;\
    lineNum = __LINE__; \
}
#define IdeLogDeadMeatTaskFile(dst, src) dst = src
#define IdeLogDeadMeatReason(dst, src) dst=src 

#else

#define IdeLogDeadMeatEvent(filName, lineNum) 
#define IdeLogDeadMeatTaskFile(dst, src) 
#define IdeLogDeadMeatReason(dst, src)

#endif //LOG_DEADMEAT_EVENT

//
// Timing Code
//
typedef enum _TIME_ID {

    TimeIsr = 0,
    TimeDpc,
    TimeStartIo,
    TimeMax

} TIME_ID;

#ifdef IDE_MEASURE_BUSSCAN_SPEED
VOID
LogBusScanStartTimer (
    PLARGE_INTEGER  TickCount
);

ULONG
LogBusScanStopTimer (
    PLARGE_INTEGER  TickCount
);

#define LogBusScanTimeDiff(FdoExtension, ParameterName, ParameterValue)  \
                IdePortSaveDeviceParameter(FdoExtension, ParameterName, ParameterValue)

#else
#define LogBusScanStartTimer(TickCount) 
#define LogBusScanStopTimer(TickCount) 0
#define LogBusScanTimeDiff(FdoExtension, ParameterName, ParameterValue)  
#endif

#if defined (ENABLE_TIME_LOG)

typedef struct _TIME_LOG {

    LARGE_INTEGER min;
    LARGE_INTEGER max;
    LARGE_INTEGER totalTimeInMicroSec;
    LARGE_INTEGER numLog;

} TIME_LOG, *PTIME_LOG;

VOID
LogStartTime(
    TIME_ID id,
    PLARGE_INTEGER timer
    );
VOID
LogStopTime(
    TIME_ID id,
    PLARGE_INTEGER timer,
    ULONG waterMarkInMicroSec
    );

#else 

#define LogStartTime(x,y)
#define LogStopTime(x,y,z)

#endif // ENABLE_TIME_LOG

#if defined (IDE_BUS_TRACE)

typedef enum _IO_TYPE {

    InPortByte = 0,
    OutPortByte,
    InPortWord,
    OutPortWord
} IO_TYPE;


typedef struct _BUS_TRACE_RECORD {

    IO_TYPE IoType;
    PVOID   Address;
    ULONG   Data;
    ULONG   Count;

} BUS_TRACE_RECORD, *PBUS_TRACE_RECORD;

typedef struct _BUS_TRACE_LOG {

    PBUS_TRACE_RECORD LogTable;
    ULONG NumLogTableEntries;
    ULONG LastLogTableEntry;
    BOOLEAN TableWrapped;

    KSPIN_LOCK SpinLock;

} BUS_TRACE_LOG, *PBUS_TRACE_LOG;

VOID InitBusTraceLogTable (
    VOID
    );

VOID FreeBusTraceLogTable (
    VOID
    );

VOID
IdepUpdateTraceLog (
    IO_TYPE IoType,
    PVOID PortAddress,
    ULONG Data
    );

UCHAR
IdepPortInPortByte (
    PUCHAR PortAddress
    );

VOID
IdepPortOutPortByte (
    PUCHAR PortAddress,
    UCHAR Data
    );

USHORT
IdepPortInPortWord (
    PUSHORT PortAddress
    );

VOID
IdepPortOutPortWord (
    PUSHORT PortAddress,
    USHORT Data
    );

VOID
IdepPortInPortWordBuffer (
    PUSHORT PortAddress,
    PUSHORT Buffer,
    ULONG Count
    );

VOID
IdepPortOutPortWordBuffer (
    PUSHORT PortAddress,
    PUSHORT Buffer,
    ULONG Count
    );

#endif // IDE_BUS_TRACE

#if defined (IDE_BUS_TRACE)

#define IdePortInPortByte(addr)        IdepPortInPortByte(addr)
#define IdePortOutPortByte(addr, data) IdepPortOutPortByte(addr, data)  

#define IdePortInPortWord(addr)        IdepPortInPortWord(addr)
#define IdePortOutPortWord(addr, data) IdepPortOutPortWord(addr, data)  

#define IdePortInPortWordBuffer(addr, buf, count)  IdepPortInPortWordBuffer(addr, buf, count)
#define IdePortOutPortWordBuffer(addr, buf, count) IdepPortOutPortWordBuffer(addr, buf, count)

#else

#define IdePortInPortByte(addr)        READ_PORT_UCHAR(addr)
#define IdePortOutPortByte(addr, data) WRITE_PORT_UCHAR(addr, data)  

#define IdePortInPortWord(addr)        READ_PORT_USHORT(addr)
#define IdePortOutPortWord(addr, data) WRITE_PORT_USHORT(addr, data)  

#define IdePortInPortWordBuffer(addr, buf, count)  READ_PORT_BUFFER_USHORT(addr, buf, count)
#define IdePortOutPortWordBuffer(addr, buf, count) WRITE_PORT_BUFFER_USHORT(addr, buf, count)

#endif // IDE_BUS_TRACE


typedef struct _COMMAND_LOG {
    UCHAR               Cdb[16];
    IDEREGS             InitialTaskFile;
    IDEREGS             FinalTaskFile;
    LARGE_INTEGER       StartTime;
    LARGE_INTEGER       EndTime;
    BMSTATUS            BmStatus;
    UCHAR               SenseData[3];
    UCHAR               SrbStatus;
}COMMAND_LOG, *PCOMMAND_LOG;

#ifdef ENABLE_COMMAND_LOG

#define MAX_COMMAND_LOG_ENTRIES    40
#define UpdateStartTimeStamp(cmdLog) KeQuerySystemTime(&(cmdLog->StartTime));
#define UpdateStopTimeStamp(cmdLog) KeQuerySystemTime(&(cmdLog->EndTime));

typedef struct _SRB_DATA *PSRB_DATA;

VOID
IdeLogBmStatus (
    PSCSI_REQUEST_BLOCK Srb,
    BMSTATUS   BmStatus
);

VOID
IdeLogOpenCommandLog(
    PSRB_DATA SrbData
);

VOID
IdeLogStartCommandLog(
    PSRB_DATA SrbData
);

VOID
IdeLogStopCommandLog(
    PSRB_DATA SrbData
);

VOID
IdeLogSaveTaskFile(
    PSRB_DATA SrbData,
    PIDE_REGISTERS_1 BaseIoAddress
);

VOID
IdeLogFreeCommandLog(
    PSRB_DATA SrbData
);


#else

#define IdeLogOpenCommandLog(a)
#define IdeLogStartCommandLog(a)
#define IdeLogStopCommandLog(a)
#define IdeLogSaveTaskFile(a,b)
#define IdeLogBmStatus(a,b)
#define IdeLogFreeCommandLog(a)

#endif  // command log

#ifdef ENABLE_ATAPI_VERIFIER

VOID
ViAtapiInterrupt(
    IN PFDO_EXTENSION FdoExtension
);

UCHAR
ViIdeGetBaseStatus(
    PIDE_REGISTERS_1 BaseIoAddress
);

UCHAR
ViIdeGetErrorByte(
    PIDE_REGISTERS_1 BaseIoAddress
);

ULONG
ViIdeFakeDeviceChange(
    IN PFDO_EXTENSION FdoExtension,
    ULONG   Target
);

BOOLEAN
ViIdeFakeMissingDevice(
    IN PFDO_EXTENSION FdoExtension,
    IN ULONG Target
);

BOOLEAN
ViIdeGenerateDmaTimeout (
    IN PVOID HwDeviceExtension,
    IN BOOLEAN  DmaInProgress
);

VOID
ViIdeInitVerifierSettings(
    IN PFDO_EXTENSION   FdoExtension
);
/*
BOOLEAN
ViIdeGenerateDmaTimeout(
    IN PHW_DEVICE_EXTENSION HwDeviceExtension, 
    IN BOOLEAN DmaInProgress
); 
*/
#endif //verifier

#endif // ___hack_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\ide.c ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    ide.c

Abstract:

    This contain DriverEntry and utilities routines

Author:

    Joe Dai (joedai)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "ideport.h"
#include <initguid.h>
#include <idedump.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(PAGE, IdePortNoSupportIrp)
#pragma alloc_text(PAGE, IdePortPassDownToNextDriver)
#pragma alloc_text(PAGE, IdePortStatusSuccessAndPassDownToNextDriver)
#pragma alloc_text(PAGE, IdePortDispatchPnp)
#pragma alloc_text(PAGE, IdePortDispatchSystemControl)
#pragma alloc_text(PAGE, IdePortOkToDetectLegacy)
#pragma alloc_text(PAGE, IdePortOpenServiceSubKey)
#pragma alloc_text(PAGE, IdePortCloseServiceSubKey)
#pragma alloc_text(PAGE, IdePortParseDeviceParameters)
#pragma alloc_text(PAGE, IdePortGetDeviceTypeString)
#pragma alloc_text(PAGE, IdePortGetCompatibleIdString)
#pragma alloc_text(PAGE, IdePortGetPeripheralIdString)
#pragma alloc_text(PAGE, IdePortUnload)
#pragma alloc_text(PAGE, IdePortSearchDeviceInRegMultiSzList)
#pragma alloc_text(PAGE, IdePortSyncSendIrp)
#pragma alloc_text(PAGE, IdePortInSetup)

#pragma alloc_text(NONPAGE, IdePortDispatchDeviceControl)
#pragma alloc_text(NONPAGE, IdePortAlwaysStatusSuccessIrp)
#pragma alloc_text(NONPAGE, IdePortDispatchPower)
#pragma alloc_text(NONPAGE, IdePortGenericCompletionRoutine)
#endif // ALLOC_PRAGMA

//
// get the share code
//
#include "..\share\util.c"

#if DBG

//
// for performance tuning
//
void _DebugPrintResetTickCount (LARGE_INTEGER * lastTickCount) {
    KeQueryTickCount(lastTickCount);
}

void _DebugPrintTickCount (LARGE_INTEGER * lastTickCount, ULONG limit, PUCHAR filename, ULONG lineNumber)
{
    LARGE_INTEGER tickCount;

    KeQueryTickCount(&tickCount);
    if ((tickCount.QuadPart - lastTickCount->QuadPart) >= limit) {
        DebugPrint ((1, "File: %s Line %u: CurrentTick = %u (%u ticks since last check)\n", filename, lineNumber, (ULONG) tickCount.QuadPart, (ULONG) (tickCount.QuadPart - lastTickCount->QuadPart)));
    }
    *lastTickCount = tickCount;
}

#endif //DBG

//
// Globals
//

//
// Po Dispatch Table
//

PDRIVER_DISPATCH FdoPowerDispatchTable[NUM_POWER_MINOR_FUNCTION];
PDRIVER_DISPATCH PdoPowerDispatchTable[NUM_POWER_MINOR_FUNCTION];


IDE_FDO_LIST IdeGlobalFdoList = {-1};


NTSTATUS
IdePortNoSupportIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Generic routine to fail unsupported irp

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP to fail.

Return Value:

    NT status.

--*/
{
    NTSTATUS status = Irp->IoStatus.Status;
    PIO_STACK_LOCATION       thisIrpSp;

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

    //
    // You should call PoStartNextPowerIrp before completing a power irp
    //
    if (thisIrpSp->MajorFunction == IRP_MJ_POWER) {

        PoStartNextPowerIrp (Irp);

    }

    DebugPrint ((
        DBG_WARNING,
        "IdePort: devobj 0x%x failing unsupported Irp (0x%x, 0x%x) with status = %x\n",
        DeviceObject,
        thisIrpSp->MajorFunction,
        thisIrpSp->MinorFunction,
        status
        ));

    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // IdePortNoSupportIrp

NTSTATUS
IdePortAlwaysStatusSuccessIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
/*++

Routine Description:

    Generic routine to STATUS_SUCCESS an irp

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    NT status.

--*/
    )
{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
} // IdePortAlwaysStatusSuccessIrp

NTSTATUS
IdePortPassDownToNextDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Generic routine to pass an irp down to the lower driver

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    NT status.

--*/
{
    PDEVICE_EXTENSION_HEADER doExtension;
    PIO_STACK_LOCATION       thisIrpSp;
    NTSTATUS status;

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

    doExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    ASSERT (doExtension->AttacheeDeviceObject);

    if (thisIrpSp->MajorFunction == IRP_MJ_POWER) {

        //
        // call PoStartNextPowerIrp before completing a power irp
        //
        PoStartNextPowerIrp (Irp);
        IoSkipCurrentIrpStackLocation (Irp);
        status = PoCallDriver (doExtension->AttacheeDeviceObject, Irp);

    } else {

        //
        // Not a power irp
        //
        IoSkipCurrentIrpStackLocation (Irp);
        status = IoCallDriver (doExtension->AttacheeDeviceObject, Irp);
    }

    return status;

} // IdePortPassDownToNextDriver

NTSTATUS
IdePortStatusSuccessAndPassDownToNextDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PAGED_CODE();
    Irp->IoStatus.Status = STATUS_SUCCESS;
    return IdePortPassDownToNextDriver(DeviceObject, Irp);
} // IdePortStatusSuccessAndPassDownToNextDriver

NTSTATUS
IdePortDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_DEVICE_CONTROL

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    NT status.

--*/
{
    PDEVICE_EXTENSION_HEADER DoExtensionHeader;
    NTSTATUS status;

    DoExtensionHeader = DeviceObject->DeviceExtension;

    if (IS_PDO(DoExtensionHeader)) {

        //
        // PDO
        //
        status = DeviceDeviceIoControl (
            DeviceObject,
            Irp
            );

    } else {

        //
        // FDO
        //
        status = IdePortDeviceControl (
            DeviceObject,
            Irp
            );
    }

    return status;
} // IdePortDispatchDeviceControl

NTSTATUS
IdePortDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_POWER

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION       thisIrpSp;
    NTSTATUS                 status;
    PDEVICE_EXTENSION_HEADER doExtension;
    BOOLEAN                  pendingIrp;

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //
    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    doExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    DebugPrint ((DBG_POWER,
                 "IdePort: 0x%x %s %d got %s[%d, %d]\n",
                 doExtension->AttacheeDeviceObject ?
                     ((PFDO_EXTENSION) doExtension)->IdeResource.TranslatedCommandBaseAddress :
                     ((PPDO_EXTENSION) doExtension)->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                 doExtension->AttacheeDeviceObject ? "FDO" : "PDO",
                 doExtension->AttacheeDeviceObject ? 0 :
                    ((PPDO_EXTENSION) doExtension)->TargetId,
                 IdeDebugPowerIrpName[thisIrpSp->MinorFunction],
                 thisIrpSp->Parameters.Power.Type,
                 thisIrpSp->Parameters.Power.State
                 ));

    if (thisIrpSp->MinorFunction < NUM_POWER_MINOR_FUNCTION) {

        status = doExtension->PowerDispatchTable[thisIrpSp->MinorFunction] (DeviceObject, Irp);
    } else {

        DebugPrint ((DBG_WARNING,
                     "ATAPI: Power Dispatch Table too small\n"
                     ));

        status = doExtension->DefaultDispatch(DeviceObject, Irp);
    }

    return status;
} // IdePortDispatchPower


NTSTATUS
IdePortDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_PNP_POWER IRPs

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION thisIrpSp;
    NTSTATUS status;
    PDEVICE_EXTENSION_HEADER doExtension;

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //
    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    doExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    DebugPrint ((DBG_PNP,
                 "IdePort: 0x%x %s %d got %s\n",
                 doExtension->AttacheeDeviceObject ?
                     ((PFDO_EXTENSION) doExtension)->IdeResource.TranslatedCommandBaseAddress :
                     ((PPDO_EXTENSION) doExtension)->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                 doExtension->AttacheeDeviceObject ? "FDO" : "PDO",
                 doExtension->AttacheeDeviceObject ? 0 :
                    ((PPDO_EXTENSION) doExtension)->TargetId,
                 IdeDebugPnpIrpName[thisIrpSp->MinorFunction]));

    if (thisIrpSp->MinorFunction < NUM_PNP_MINOR_FUNCTION) {

        status = doExtension->PnPDispatchTable[thisIrpSp->MinorFunction] (DeviceObject, Irp);

    } else {

        if (thisIrpSp->MinorFunction != 0xff) {

            ASSERT (!"ATAPI: PnP Dispatch Table too small\n");
        }

        status = doExtension->DefaultDispatch (DeviceObject, Irp);
    }

    return status;
} // IdePortDispatchPnp

NTSTATUS
IdePortDispatchSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    Dispatch routine for IRP_MJ_SYSTEM_CONTROL (WMI) IRPs

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION thisIrpSp;
    NTSTATUS status;
    PDEVICE_EXTENSION_HEADER doExtension;

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    doExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    DebugPrint ((DBG_WMI,
                 "IdePort: 0x%x %s %d got %s\n",
                 doExtension->AttacheeDeviceObject ?
                     ((PFDO_EXTENSION) doExtension)->IdeResource.TranslatedCommandBaseAddress :
                     ((PPDO_EXTENSION) doExtension)->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                 doExtension->AttacheeDeviceObject ? "FDO" : "PDO",
                 doExtension->AttacheeDeviceObject ? 0 :
                    ((PPDO_EXTENSION) doExtension)->TargetId,
                 IdeDebugWmiIrpName[thisIrpSp->MinorFunction]));

    if (thisIrpSp->MinorFunction < NUM_WMI_MINOR_FUNCTION) {

        status = doExtension->WmiDispatchTable[thisIrpSp->MinorFunction] (DeviceObject, Irp);

    } else {

        DebugPrint((DBG_WARNING,
                    "ATAPI: WMI Dispatch Table too small\n"
                    ));

        status = doExtension->DefaultDispatch (DeviceObject, Irp);
    }

    return status;
} // IdePortDispatchSystemControl

ULONG
DriverEntry(
    IN OUT PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
/*++

Routine Description:

    Entry point to this driver

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    NT status.

--*/
{
    NTSTATUS                status;
    PIDEDRIVER_EXTENSION    ideDriverExtension;
    ULONG                   i;

#if DBG
    //
    // checking IDE_COMMAND_BLOCK_WRITE_REGISTERS structure and its macros
    //

    {
        IDE_COMMAND_BLOCK_WRITE_REGISTERS baseIoAddress1;
        IDE_REGISTERS_2 baseIoAddress2;
        ULONG           baseIoAddress1Length;
        ULONG           baseIoAddress2Length;
        ULONG           maxIdeDevice;
        ULONG           maxIdeTargetId;

        AtapiBuildIoAddress (0,
                             0,
                             (PIDE_REGISTERS_1)&baseIoAddress1,
                             &baseIoAddress2,
                             &baseIoAddress1Length,
                             &baseIoAddress2Length,
                             &maxIdeDevice,
                             &maxIdeTargetId);

        ASSERT (ATA_DATA16_REG       (&baseIoAddress1) == 0);
        ASSERT (ATA_ERROR_REG        (&baseIoAddress1) == (PUCHAR)1);
        ASSERT (ATA_SECTOR_COUNT_REG (&baseIoAddress1) == (PUCHAR)2);
        ASSERT (ATA_SECTOR_NUMBER_REG(&baseIoAddress1) == (PUCHAR)3);
        ASSERT (ATA_CYLINDER_LOW_REG (&baseIoAddress1) == (PUCHAR)4);
        ASSERT (ATA_CYLINDER_HIGH_REG(&baseIoAddress1) == (PUCHAR)5);
        ASSERT (ATA_DRIVE_SELECT_REG (&baseIoAddress1) == (PUCHAR)6);
        ASSERT (ATA_STATUS_REG       (&baseIoAddress1) == (PUCHAR)7);

        ASSERT (ATA_FEATURE_REG      (&baseIoAddress1) == (PUCHAR)1);
        ASSERT (ATA_COMMAND_REG      (&baseIoAddress1) == (PUCHAR)7);

        ASSERT (ATAPI_DATA16_REG            (&baseIoAddress1) == 0);
        ASSERT (ATAPI_ERROR_REG             (&baseIoAddress1) == (PUCHAR)1);
        ASSERT (ATAPI_INTERRUPT_REASON_REG  (&baseIoAddress1) == (PUCHAR)2);
        ASSERT (ATAPI_BYTECOUNT_LOW_REG     (&baseIoAddress1) == (PUCHAR)4);
        ASSERT (ATAPI_BYTECOUNT_HIGH_REG    (&baseIoAddress1) == (PUCHAR)5);
        ASSERT (ATAPI_DRIVE_SELECT_REG      (&baseIoAddress1) == (PUCHAR)6);
        ASSERT (ATAPI_STATUS_REG            (&baseIoAddress1) == (PUCHAR)7);

        ASSERT (ATAPI_FEATURE_REG           (&baseIoAddress1) == (PUCHAR)1);
        ASSERT (ATAPI_COMMAND_REG           (&baseIoAddress1) == (PUCHAR)7);

        ASSERT (baseIoAddress1Length == 8);
        ASSERT (baseIoAddress2Length == 1);
        ASSERT (maxIdeDevice        == 2);

    }
#endif //DBG

    if (!DriverObject) {

        //
        // We are called by crashdump or po
        //

        return AtapiCrashDumpDriverEntry (RegistryPath);
    }

    //
    // Allocate Driver Object Extension for storing
    // the RegistryPath
    //
    status = IoAllocateDriverObjectExtension(
                 DriverObject,
                 DRIVER_OBJECT_EXTENSION_ID,
                 sizeof (DRIVER_EXTENSION),
                 &ideDriverExtension
                 );

    if (!NT_SUCCESS(status)) {

        DebugPrint ((0, "IdePort: Unable to create driver extension\n"));
        return status;
    }

    ASSERT(ideDriverExtension);

    RtlZeroMemory (
        ideDriverExtension,
        sizeof (DRIVER_EXTENSION)
        );

    //
    // make copy of the RegistryPath
    //
    ideDriverExtension->RegistryPath.Buffer = ExAllocatePool (NonPagedPool, RegistryPath->Length * sizeof(WCHAR));
    if (ideDriverExtension->RegistryPath.Buffer == NULL) {

        DebugPrint ((0, "IdePort: Unable to allocate memory for registry path\n"));

        return (ULONG) STATUS_INSUFFICIENT_RESOURCES;
    }

    ideDriverExtension->RegistryPath.Length = 0;
    ideDriverExtension->RegistryPath.MaximumLength = RegistryPath->Length;
    RtlCopyUnicodeString (&ideDriverExtension->RegistryPath, RegistryPath);

    //
    // The PnP thing to do
    //
    DriverObject->DriverExtension->AddDevice    = ChannelAddDevice;

    //
    // Set up the device driver entry points.
    //
    DriverObject->DriverStartIo = IdePortStartIo;
    DriverObject->DriverUnload  = IdePortUnload;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = IdePortDispatch;
    DriverObject->MajorFunction[IRP_MJ_SCSI]                    = IdePortDispatch;
    DriverObject->MajorFunction[IRP_MJ_CREATE]                  = IdePortAlwaysStatusSuccessIrp;
    DriverObject->MajorFunction[IRP_MJ_CLOSE]                   = IdePortAlwaysStatusSuccessIrp;
    DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL]          = IdePortDispatchDeviceControl;
    DriverObject->MajorFunction[IRP_MJ_POWER]                   = IdePortDispatchPower;
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = IdePortDispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]          = IdePortDispatchSystemControl;

    //
    // FDO PnP Dispatch Table
    //
    for (i=0; i<NUM_PNP_MINOR_FUNCTION; i++) {

        FdoPnpDispatchTable[i] = IdePortPassDownToNextDriver;
    }
    FdoPnpDispatchTable[IRP_MN_START_DEVICE               ] = ChannelStartDevice;
    FdoPnpDispatchTable[IRP_MN_QUERY_REMOVE_DEVICE        ] = IdePortStatusSuccessAndPassDownToNextDriver;
    FdoPnpDispatchTable[IRP_MN_CANCEL_REMOVE_DEVICE       ] = IdePortStatusSuccessAndPassDownToNextDriver;
    FdoPnpDispatchTable[IRP_MN_REMOVE_DEVICE              ] = ChannelRemoveDevice;
    FdoPnpDispatchTable[IRP_MN_QUERY_STOP_DEVICE          ] = IdePortStatusSuccessAndPassDownToNextDriver;
    FdoPnpDispatchTable[IRP_MN_CANCEL_STOP_DEVICE         ] = IdePortStatusSuccessAndPassDownToNextDriver;
    FdoPnpDispatchTable[IRP_MN_STOP_DEVICE                ] = ChannelStopDevice;
    FdoPnpDispatchTable[IRP_MN_QUERY_DEVICE_RELATIONS     ] = ChannelQueryDeviceRelations;
    FdoPnpDispatchTable[IRP_MN_QUERY_ID                   ] = ChannelQueryId;
    FdoPnpDispatchTable[IRP_MN_DEVICE_USAGE_NOTIFICATION  ] = ChannelUsageNotification;
    FdoPnpDispatchTable[IRP_MN_FILTER_RESOURCE_REQUIREMENTS] = ChannelFilterResourceRequirements;
    FdoPnpDispatchTable[IRP_MN_QUERY_PNP_DEVICE_STATE     ] = ChannelQueryPnPDeviceState;
    FdoPnpDispatchTable[IRP_MN_SURPRISE_REMOVAL           ] = ChannelSurpriseRemoveDevice;

    //
    // PDO PnP Dispatch Table
    //
    for (i=0; i<NUM_PNP_MINOR_FUNCTION; i++) {

        PdoPnpDispatchTable[i] = IdePortNoSupportIrp;
    }
    PdoPnpDispatchTable[IRP_MN_START_DEVICE               ] = DeviceStartDevice;
    PdoPnpDispatchTable[IRP_MN_QUERY_DEVICE_RELATIONS     ] = DeviceQueryDeviceRelations;
    PdoPnpDispatchTable[IRP_MN_QUERY_REMOVE_DEVICE        ] = DeviceQueryStopRemoveDevice;
    PdoPnpDispatchTable[IRP_MN_REMOVE_DEVICE              ] = DeviceRemoveDevice;
    PdoPnpDispatchTable[IRP_MN_CANCEL_REMOVE_DEVICE       ] = IdePortAlwaysStatusSuccessIrp;
    PdoPnpDispatchTable[IRP_MN_STOP_DEVICE                ] = DeviceStopDevice;
    PdoPnpDispatchTable[IRP_MN_QUERY_STOP_DEVICE          ] = DeviceQueryStopRemoveDevice;
    PdoPnpDispatchTable[IRP_MN_CANCEL_STOP_DEVICE         ] = IdePortAlwaysStatusSuccessIrp;
    PdoPnpDispatchTable[IRP_MN_QUERY_ID                   ] = DeviceQueryId;
    PdoPnpDispatchTable[IRP_MN_QUERY_CAPABILITIES         ] = DeviceQueryCapabilities;
    PdoPnpDispatchTable[IRP_MN_QUERY_DEVICE_TEXT          ] = DeviceQueryText;
    PdoPnpDispatchTable[IRP_MN_DEVICE_USAGE_NOTIFICATION  ] = DeviceUsageNotification;
    PdoPnpDispatchTable[IRP_MN_QUERY_PNP_DEVICE_STATE     ] = DeviceQueryPnPDeviceState;
    PdoPnpDispatchTable[IRP_MN_SURPRISE_REMOVAL           ] = DeviceRemoveDevice;

    //
    // FDO Power Dispatch Table
    //
    for (i=0; i<NUM_POWER_MINOR_FUNCTION; i++) {

        FdoPowerDispatchTable[i] = IdePortPassDownToNextDriver;
    }
    FdoPowerDispatchTable[IRP_MN_SET_POWER]   = IdePortSetFdoPowerState;
    FdoPowerDispatchTable[IRP_MN_QUERY_POWER] = ChannelQueryPowerState;


    //
    // PDO Power Dispatch Table
    //
    for (i=0; i<NUM_POWER_MINOR_FUNCTION; i++) {

        PdoPowerDispatchTable[i] = IdePortNoSupportIrp;
    }
    PdoPowerDispatchTable[IRP_MN_SET_POWER]   = IdePortSetPdoPowerState;
    PdoPowerDispatchTable[IRP_MN_QUERY_POWER] = DeviceQueryPowerState;

    //
    // FDO WMI Dispatch Table
    //
    for (i=0; i<NUM_WMI_MINOR_FUNCTION; i++) {

        FdoWmiDispatchTable[i] = IdePortPassDownToNextDriver;
    }

    //
    // PDO WMI Dispatch Table
    //
    for (i=0; i<NUM_WMI_MINOR_FUNCTION; i++) {

#if defined (IDEPORT_WMI_SUPPORT)
        PdoWmiDispatchTable[i] = IdePortWmiSystemControl;
#else
        PdoWmiDispatchTable[i] = IdePortNoSupportIrp;
#endif // IDEPORT_WMI_SUPPORT
    }

#if defined (IDEPORT_WMI_SUPPORT)
    //
    // Init WMI related stuff
    //
    IdePortWmiInit ();
#endif // IDEPORT_WMI_SUPPORT

    //
    // Create device object name directory
    //
    IdeCreateIdeDirectory();

    IdeInitializeFdoList (&IdeGlobalFdoList);

    //
    // Detect legacy (non-enumerable) IDE devices
    //
#if !defined(NO_LEGACY_DRIVERS)
    IdePortDetectLegacyController (
        DriverObject,
        RegistryPath
        );
#endif // NO_LEGACY_DRIVERS

    //
    // Register a bugcheck handler for ATAPI.
    //

    PortRegisterBugcheckCallback (&ATAPI_DUMP_ID, AtapiDumpCallback);

    return STATUS_SUCCESS;
} // DriverEntry


#ifdef DRIVER_PARAMETER_REGISTRY_SUPPORT

HANDLE
IdePortOpenServiceSubKey (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  SubKeyPath
)
/*++

Routine Description:

    Open a registry key

Arguments:

    DriverObject - this driver driver object

    SubKeyPath - registry key to open

Return Value:

    handle to the registry key

--*/
{
    PIDEDRIVER_EXTENSION ideDriverExtension;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE serviceKey;
    HANDLE subServiceKey;
    NTSTATUS status;

    ideDriverExtension = IoGetDriverObjectExtension(
                             DriverObject,
                             DRIVER_OBJECT_EXTENSION_ID
                             );

    if (!ideDriverExtension) {

        return NULL;
    }

    InitializeObjectAttributes(&objectAttributes,
                               &ideDriverExtension->RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey(&serviceKey,
                       KEY_READ,
                       &objectAttributes);

    if (!NT_SUCCESS(status)) {

        return NULL;
    }

    InitializeObjectAttributes(&objectAttributes,
                               SubKeyPath,
                               OBJ_CASE_INSENSITIVE,
                               serviceKey,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey(&subServiceKey,
                       KEY_READ,
                       &objectAttributes);


    ZwClose(serviceKey);

    if (NT_SUCCESS(status)) {

        return subServiceKey;
    } else {

        return NULL;
    }
} // IdePortOpenServiceSubKey

VOID
IdePortCloseServiceSubKey (
    IN HANDLE  SubServiceKey
)
/*++

Routine Description:

    close a registry key handle

Arguments:

    SubServiceKey - registry key to close

Return Value:

    None

--*/
{
    ZwClose(SubServiceKey);
} // IdePortCloseServiceSubKey

VOID
IdePortParseDeviceParameters(
    IN     HANDLE                   SubServiceKey,
    IN OUT PCUSTOM_DEVICE_PARAMETER CustomDeviceParameter
    )
/*++

Routine Description:

    This routine parses a device key node and updates the CustomDeviceParameter

Arguments:

    SubServiceKey - Supplies an open key to the device node.

    CustomDeviceParameter - Supplies the configuration information to be initialized.

Return Value:

    None

--*/

{
    UCHAR                           keyValueInformationBuffer[SP_REG_BUFFER_SIZE];
    PKEY_VALUE_FULL_INFORMATION     keyValueInformation;
    ULONG                           length;
    ULONG                           index;
    UNICODE_STRING                  unicodeString;
    ANSI_STRING                     ansiString;
    NTSTATUS                        status;

    //
    // Look at each of the values in the device node.
    //
    index = 0;

    keyValueInformation = (PKEY_VALUE_FULL_INFORMATION) keyValueInformationBuffer;

    while (NT_SUCCESS (ZwEnumerateValueKey(
                           SubServiceKey,
                           index,
                           KeyValueFullInformation,
                           keyValueInformation,
                           SP_REG_BUFFER_SIZE,
                           &length))) {

        //
        // Update the index for the next time around the loop.
        //

        index++;

        //
        // Check that the length is reasonable.
        //

        if (keyValueInformation->Type == REG_DWORD &&
            keyValueInformation->DataLength != sizeof(ULONG)) {

            continue;
        }

        //
        // Check for a maximum lu number.
        //
        if (_wcsnicmp(keyValueInformation->Name, L"ScsiDebug",
            keyValueInformation->NameLength/2) == 0) {

            if (keyValueInformation->Type != REG_DWORD) {

                DebugPrint((1, "IdeParseDevice:  Bad data type for ScsiDebug.\n"));
                continue;
            }
#if DBG
            ScsiDebug = *((PULONG) (keyValueInformationBuffer + keyValueInformation->DataOffset));
#endif
        }

        //
        // Check for driver parameters tranfers.
        //

        if (_wcsnicmp(keyValueInformation->Name, L"DriverParameters",
            keyValueInformation->NameLength/2) == 0) {

            if (keyValueInformation->DataLength == 0) {
                continue;
            }

            if (keyValueInformation->Type == REG_SZ) {

                //
                // This is a unicode string. Convert it to a ANSI string.
                // Initialize the strings.
                //

                unicodeString.Buffer = (PWSTR) ((PCCHAR) keyValueInformation +
                    keyValueInformation->DataOffset);
                unicodeString.Length = (USHORT) keyValueInformation->DataLength;
                unicodeString.MaximumLength = (USHORT) keyValueInformation->DataLength;

                status = RtlUnicodeStringToAnsiString(
                    &ansiString,
                    &unicodeString,
                    TRUE
                    );

                if (NT_SUCCESS(status)) {

                    CustomDeviceParameter->CommandRegisterBase =
                        AtapiParseArgumentString(ansiString.Buffer, "BaseAddress");

                    if (CustomDeviceParameter->CommandRegisterBase) {

                        CustomDeviceParameter->IrqLevel =
                            AtapiParseArgumentString(ansiString.Buffer, "Interrupt");
                    }

                    RtlFreeAnsiString (&ansiString);
                }
            }

            DebugPrint((2, "IdeParseDeviceParameters: Found driver parameter.\n"));
        }
    }

    return;

} // IdePortParseDeviceParameters

#endif // DRIVER_PARAMETER_REGISTRY_SUPPORT

#pragma data_seg ("PAGEDATA")
//
// device description table
// index by SCSI device type
//
const static IDE_DEVICE_TYPE IdeDeviceType[] = {
    {"Disk",       "GenDisk",       "DiskPeripheral"            },
    {"Sequential", "GenSequential", "TapePeripheral"            },
    {"Printer",    "GenPrinter",    "PrinterPeripheral"         },
    {"Processor",  "GenProcessor",  "ProcessorPeripheral"       },
    {"Worm",       "GenWorm",       "WormPeripheral"            },
    {"CdRom",      "GenCdRom",      "CdRomPeripheral"           },
    {"Scanner",    "GenScanner",    "ScannerPeripheral"         },
    {"Optical",    "GenOptical",    "OpticalDiskPeripheral"     },
    {"Changer",    "GenChanger",    "MediumChangerPeripheral"   },
    {"Net",        "GenNet",        "CommunicationPeripheral"   }
};
#pragma data_seg ()

PCSTR
IdePortGetDeviceTypeString (
    IN ULONG DeviceType
    )
/*++

Routine Description:

    look up SCSI device type string

Arguments:

    DeviceType - SCSI device type

Return Value:

    device type string

--*/
{
    if (DeviceType < (sizeof (IdeDeviceType) / sizeof (IDE_DEVICE_TYPE))) {

        return IdeDeviceType[DeviceType].DeviceTypeString;

    } else {

        return NULL;
    }

} // IdePortGetDeviceTypeString

PCSTR
IdePortGetCompatibleIdString (
    IN ULONG DeviceType
    )
/*++

Routine Description:

    look up compatible ID string

Arguments:

    DeviceType - SCSI device type

Return Value:

    compatible ID string

--*/
{
    if (DeviceType < (sizeof (IdeDeviceType) / sizeof (IDE_DEVICE_TYPE))) {

        return IdeDeviceType[DeviceType].CompatibleIdString;

    } else {

        return NULL;
    }
} // IdePortGetCompatibleIdString

PCSTR
IdePortGetPeripheralIdString (
    IN ULONG DeviceType
    )
/*++

Routine Description:

    look up peripheral ID string

Arguments:

    DeviceType - SCSI device type

Return Value:

    Peripheral ID string

--*/
{
    if (DeviceType < (sizeof (IdeDeviceType) / sizeof (IDE_DEVICE_TYPE))) {

        return IdeDeviceType[DeviceType].PeripheralIdString;

    } else {

        return NULL;
    }
} // IdePortGetPeripheralIdString


VOID
IdePortUnload(
    IN PDRIVER_OBJECT DriverObject
    )

/*++

Routine Description:

    get ready to be unloaded

Arguments:

    DriverObject - the driver being unloaded

Return Value:

    none

--*/

{
    PIDEDRIVER_EXTENSION ideDriverExtension;

    DebugPrint ((1, "IdePort: unloading...\n"));

    ASSERT (DriverObject->DeviceObject == NULL);

    ideDriverExtension = IoGetDriverObjectExtension(
                             DriverObject,
                             DRIVER_OBJECT_EXTENSION_ID
                             );
    if ((ideDriverExtension != NULL) &&
        (ideDriverExtension->RegistryPath.Buffer != NULL)) {

        ExFreePool (ideDriverExtension->RegistryPath.Buffer);
    }

    //
    // Deregister the ATAPI bugcheck callback. NOTE: The function will
    // sliently fail if the callback has not yet been registered.
    //
    
    PortDeregisterBugcheckCallback (&ATAPI_DUMP_ID);

    return;
} // IdePortUnload

BOOLEAN
IdePortOkToDetectLegacy (
    IN PDRIVER_OBJECT DriverObject
)
{
    NTSTATUS          status;
    OBJECT_ATTRIBUTES attributes;
    HANDLE            regHandle;
    UNICODE_STRING    pathRoot;
    ULONG             legacyDetection;
    RTL_QUERY_REGISTRY_TABLE queryTable[2];

    RtlInitUnicodeString (&pathRoot, L"\\Registry\\Machine\\System\\CurrentControlSet\\Control\\Pnp");
    InitializeObjectAttributes(&attributes,
                               &pathRoot,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR)NULL
                               );
    status = ZwOpenKey(&regHandle,
                       KEY_READ,
                       &attributes
                       );
    if (NT_SUCCESS(status)) {

        ULONG parameterValue = 0;

        RtlZeroMemory(queryTable, sizeof(queryTable));

        queryTable->QueryRoutine  = NULL;
        queryTable->Flags         = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND | RTL_QUERY_REGISTRY_DIRECT;
        queryTable->Name          = L"DisableFirmwareMapper";
        queryTable->EntryContext  = &parameterValue;
        queryTable->DefaultType   = REG_DWORD;
        queryTable->DefaultData   = &parameterValue;
        queryTable->DefaultLength = sizeof (parameterValue);

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        (PWSTR) regHandle,
                                        queryTable,
                                        NULL,
                                        NULL);
        ZwClose (regHandle);

        if (parameterValue) {

            //
            // Cool.  no need to detect legacy controller
            //
            return FALSE;
        }
    }

    status = IdePortGetParameterFromServiceSubKey (
                 DriverObject,
                 LEGACY_DETECTION,
                 REG_DWORD,
                 TRUE,
                 (PVOID) &legacyDetection,
                 0
                 );
    if (NT_SUCCESS(status)) {

        if (legacyDetection) {

            legacyDetection = 0;

            //
            // disable legacy detection for next boot
            //
            IdePortGetParameterFromServiceSubKey (
                DriverObject,
                LEGACY_DETECTION,
                REG_DWORD,
                FALSE,
                (PVOID) &legacyDetection,
                sizeof (legacyDetection)
                );

            return TRUE;

        } else {

            return FALSE;
        }
    }

    return TRUE;
}

BOOLEAN
IdePortSearchDeviceInRegMultiSzList (
    IN PFDO_EXTENSION  FdoExtension,
    IN PIDENTIFY_DATA  IdentifyData,
    IN PWSTR           RegKeyValue
)
{
    PWSTR           string;
    UNICODE_STRING  unicodeString;

    BOOLEAN         foundIt;

    NTSTATUS        status;

    PWSTR           regDeviceList;

    ANSI_STRING     ansiTargetDeviceId;
    UNICODE_STRING  unicodeTargetDeviceId;
    PUCHAR          targetDeviceId;
    ULONG           i;
    ULONG           j;

    PAGED_CODE();

    ASSERT (IdentifyData);
    ASSERT (RegKeyValue);

    foundIt = FALSE;

    status = IdePortGetParameterFromServiceSubKey (
                        FdoExtension->DriverObject,
                        RegKeyValue,
                        REG_MULTI_SZ,
                        TRUE,
                        &regDeviceList,
                        0
                        );

    if (NT_SUCCESS(status) && regDeviceList) {

        targetDeviceId = ExAllocatePool (
                             PagedPool,
                             sizeof(IdentifyData->ModelNumber) +
                             sizeof(IdentifyData->FirmwareRevision) +
                             sizeof('\0')
                             );

        if (targetDeviceId) {

            for (i=0; i<sizeof(IdentifyData->ModelNumber); i+=2) {

                targetDeviceId[i + 0] = IdentifyData->ModelNumber[i + 1];
                targetDeviceId[i + 1] = IdentifyData->ModelNumber[i + 0];

                if (targetDeviceId[i + 0] == '\0') {

                    targetDeviceId[i + 0] = ' ';
                }
                if (targetDeviceId[i + 1] == '\0') {

                    targetDeviceId[i + 1] = ' ';
                }
            }
            for (j=0; j<sizeof(IdentifyData->FirmwareRevision); j+=2) {

                targetDeviceId[i + j + 0] = IdentifyData->FirmwareRevision[j + 1];
                targetDeviceId[i + j + 1] = IdentifyData->FirmwareRevision[j + 0];

                if (targetDeviceId[i + j + 0] == '\0') {

                    targetDeviceId[i + j + 0] = ' ';
                }
                if (targetDeviceId[i + j + 1] == '\0') {

                    targetDeviceId[i + j + 1] = ' ';
                }
            }
            targetDeviceId[i + j] = 0;

            RtlInitAnsiString(
                &ansiTargetDeviceId,
                targetDeviceId
                );

            status = RtlAnsiStringToUnicodeString(
                         &unicodeTargetDeviceId,
                         &ansiTargetDeviceId,
                         TRUE
                         );

            if (NT_SUCCESS(status)) {

                string = regDeviceList;

                DebugPrint ((DBG_REG_SEARCH, "IdePort: searching for %s in list\n", targetDeviceId));

                while (string[0]) {

                    ULONG length;

                    DebugPrint ((DBG_REG_SEARCH, "IdePort: device list: %ws\n", string));

                    RtlInitUnicodeString(
                        &unicodeString,
                        string
                        );

                    //
                    // compare up to the length of the shorter string
                    //
                    if (unicodeTargetDeviceId.Length < unicodeString.Length) {

                        length = unicodeTargetDeviceId.Length;
                    } else {

                        length = unicodeString.Length;
                    }

                    if (length == RtlCompareMemory(unicodeTargetDeviceId.Buffer, unicodeString.Buffer, length)) {

                        DebugPrint ((DBG_REG_SEARCH, "IdePort: Found a target device on the device list. %ws\n", string));
                        foundIt = TRUE;
                        break;

                    } else {

                        string += (unicodeString.Length / sizeof(WCHAR)) + 1;
                    }
                }

                RtlFreeUnicodeString (
                    &unicodeTargetDeviceId
                    );

            } else {

                ASSERT (FALSE);
            }

            ExFreePool(targetDeviceId);
        }

        ExFreePool(regDeviceList);
    }

    return foundIt;
}

NTSTATUS
IdePortSyncSendIrp (
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT OPTIONAL PIO_STATUS_BLOCK IoStatus
    )
{
    PIO_STACK_LOCATION  newIrpSp;
    PIRP                newIrp;
    KEVENT              event;
    NTSTATUS            status;

    ASSERT (TargetDeviceObject);
    ASSERT (IrpSp);

    //
    // Allocate an IRP for below
    //
    newIrp = IoAllocateIrp (TargetDeviceObject->StackSize, FALSE);      // Get stack size from PDO
    if (newIrp == NULL) {

        DebugPrint ((DBG_ALWAYS, "IdePortSyncSendIrp: Unable to get allocate an irp"));
        return STATUS_NO_MEMORY;
    }

    newIrpSp = IoGetNextIrpStackLocation(newIrp);
    RtlMoveMemory (newIrpSp, IrpSp, sizeof (*IrpSp));

    if (IoStatus) {

        newIrp->IoStatus.Status = IoStatus->Status;
    } else {

        newIrp->IoStatus.Status = STATUS_NOT_SUPPORTED;
    }

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    IoSetCompletionRoutine (
        newIrp,
        IdePortGenericCompletionRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE);
    status = IoCallDriver (TargetDeviceObject, newIrp);

    if (status == STATUS_PENDING) {

        status = KeWaitForSingleObject(&event,
                                       Executive,
                                       KernelMode,
                                       FALSE,
                                       NULL);
    }
    status = newIrp->IoStatus.Status;

    if (IoStatus) {

        *IoStatus = newIrp->IoStatus;
    }

    IoFreeIrp (newIrp);
    return status;
}

NTSTATUS
IdePortGenericCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PKEVENT event = Context;

    KeSetEvent(
        event,
        EVENT_INCREMENT,
        FALSE
        );

    return STATUS_MORE_PROCESSING_REQUIRED;
} // IdePortSyncSendIrpCompletionRoutine


ULONG
IdePortSimpleCheckSum (
    IN ULONG                PartialSum,
    IN PVOID                SourceVa,
    IN ULONG                Length
    )
/*++

Routine Description:

    Computes a checksum for the supplied virtual address and length

    This function comes from Dr. Dobbs Journal, May 1992

Arguments:

    PartialSum  - The previous partial checksum

    SourceVa    - Starting address

    Length      - Length, in bytes, of the range

Return Value:

    The checksum value

--*/
{
    PUSHORT     Source;

    Source = (PUSHORT) SourceVa;
    Length = Length / 2;

    while (Length--) {
        PartialSum += *Source++;
        PartialSum = (PartialSum >> 16) + (PartialSum & 0xFFFF);
    }

    return PartialSum;
}


BOOLEAN
IdePortInSetup(
    IN PFDO_EXTENSION FdoExtension
    )
/*++
--*/
{
    OBJECT_ATTRIBUTES objectAttributes;
    UNICODE_STRING keyName;
    HANDLE hKey;
    ULONG systemSetupInProgress = 0;
    NTSTATUS status;
    BOOLEAN textmodeSetup = TRUE;

    PAGED_CODE();

    RtlInitUnicodeString(&keyName, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\setupdd");

    InitializeObjectAttributes(&objectAttributes,
                               &keyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey(&hKey,
                       KEY_READ,
                       &objectAttributes);

    if (!NT_SUCCESS(status)) {

        textmodeSetup = FALSE;

    } else {

        ZwClose(hKey);
    }

    RtlInitUnicodeString(&keyName,L"\\Registry\\Machine\\System\\setup");

    InitializeObjectAttributes(&objectAttributes,
                               &keyName,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey(&hKey,
                       KEY_READ,
                       &objectAttributes);

    if (NT_SUCCESS(status)) {

        //
        // Query the data for the key value.
        //

        RTL_QUERY_REGISTRY_TABLE queryTable[2];

        systemSetupInProgress = 0;

        RtlZeroMemory(queryTable, sizeof(queryTable));

        queryTable->QueryRoutine  = NULL;
        queryTable->Flags         = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND | RTL_QUERY_REGISTRY_DIRECT;
        queryTable->Name          = L"SystemSetupInProgress";
        queryTable->EntryContext  = &systemSetupInProgress;
        queryTable->DefaultType   = REG_DWORD;
        queryTable->DefaultData   = &systemSetupInProgress;
        queryTable->DefaultLength = sizeof (systemSetupInProgress);

        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        (PWSTR) hKey,
                                        queryTable,
                                        NULL,
                                        NULL);

        ZwClose (hKey);

    }

    return (textmodeSetup || systemSetupInProgress);
}


VOID
IdeInitializeFdoList(
    IN PIDE_FDO_LIST FdoList
    )
/*++

Routine Description:

    Initialize IDE's FDO list.

Arguments:

    FdoList - Fdo list to initialize.

Return Value:

    None.

--*/
{
    ASSERT (FdoList != NULL);

    //
    // This allows this function to be called multiple times. NB: This will
    // NOT work correctly if we do not synchronize entries to ATAPI's
    // DriverEntry routine. This is done for us by IO manager.
    //
    
    if (FdoList->Count == -1) {
        InitializeListHead (&FdoList->List);
        FdoList->Count = 0;
        KeInitializeSpinLock (&FdoList->SpinLock);
    }
}
        

VOID
IdeAddToFdoList (
    PIDE_FDO_LIST FdoList,
    PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description

    Adds the FDO to the global list. A new list is allocated (and the 
    old one is freed) every time an Fdo is inserted into the list.
    
Arguments:

    FdoList -

    FdoExtension -
    
Return Value:

    None.
    
--*/
{
    KIRQL oldIrql;

    KeAcquireSpinLock(&FdoList->SpinLock, &oldIrql);
    InsertTailList(&FdoList->List, &FdoExtension->NextFdoLink);
    FdoList->Count++;
    KeReleaseSpinLock(&FdoList->SpinLock, oldIrql);
}


VOID
IdeRemoveFromFdoList (
    PIDE_FDO_LIST FdoList,
    PFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    Remove from the IDE FDO list.

Arguments:

    FdoList - Supplies the FDO list to remove from.

    FdoExtension - Supplies the FDO extension to remove.

Return Value:

    None.

--*/
{
    KIRQL oldIrql;


    KeAcquireSpinLock(&FdoList->SpinLock, &oldIrql);

#if DBG

    //
    // In CHK builds, we verify that the entry is actually in the list
    // before removing it.
    //
    
    {
        PLIST_ENTRY nextEntry;
        PFDO_EXTENSION fdoExtension = NULL;

        for ( nextEntry = FdoList->List.Flink;
              nextEntry != &FdoList->List;
              nextEntry = nextEntry->Flink ) {

            fdoExtension = CONTAINING_RECORD (nextEntry,
                                              FDO_EXTENSION,
                                              NextFdoLink);
            if (fdoExtension == FdoExtension) {
                break;
            }
        }

        //
        // Verify that we are trying to remove from a list that we're
        // actually on.
        //

        ASSERT(fdoExtension == FdoExtension);
    }
#endif // DBG
        
    FdoList->Count--;
    RemoveEntryList(&FdoExtension->NextFdoLink);
    KeReleaseSpinLock(&FdoList->SpinLock, oldIrql);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\idedata.c ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    idedata.c

Abstract:

--*/

#include "ideport.h"

//
// Beginning of Init Data 
//
#pragma data_seg ("INIT")

//
// global data for crashdump or hibernate
//
CRASHDUMP_DATA DumpData;


#pragma data_seg ()
//
// End of Pagable Data 
//

//////////////////////////////////////

//
// Beginning of Pagable Data 
//
#pragma data_seg ("PAGE")

const CHAR SuperFloppyCompatibleIdString[12] = "GenSFloppy";

//
// PnP Dispatch Table
//
PDRIVER_DISPATCH FdoPnpDispatchTable[NUM_PNP_MINOR_FUNCTION];
PDRIVER_DISPATCH PdoPnpDispatchTable[NUM_PNP_MINOR_FUNCTION];

//
// Wmi Dispatch Table
//
PDRIVER_DISPATCH FdoWmiDispatchTable[NUM_WMI_MINOR_FUNCTION];
PDRIVER_DISPATCH PdoWmiDispatchTable[NUM_WMI_MINOR_FUNCTION];

#pragma data_seg ()
//
// End of Pagable Data 
//

//////////////////////////////////////

//
// Beginning of Nonpagable Data
//              
#pragma data_seg ("NONPAGE")

#pragma data_seg ()
//
// End of Nonpagable Data
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\luext.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       luext.c
//
//--------------------------------------------------------------------------

#include "ideport.h"

static ULONG IdeDeviceUniqueId = 0;

PPDO_EXTENSION
RefPdo(
    PDEVICE_OBJECT PhysicalDeviceObject,
    BOOLEAN RemovedOk
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    )
{
    PPDO_EXTENSION  pdoExtension;
    PPDO_EXTENSION  pdoExtension2Return;
    KIRQL           currentIrql;

    pdoExtension = PhysicalDeviceObject->DeviceExtension;

    KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

    pdoExtension2Return = RefPdoWithSpinLockHeldWithTag(
                              PhysicalDeviceObject, 
                              RemovedOk,
                              Tag
                              );

    if (pdoExtension2Return) {
        ASSERT(pdoExtension2Return == pdoExtension);
    }

    KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

    return pdoExtension2Return;

} // RefPdo()

PPDO_EXTENSION
RefPdoWithSpinLockHeld(
    PDEVICE_OBJECT PhysicalDeviceObject,
    BOOLEAN RemovedOk
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    )
{
    PPDO_EXTENSION  pdoExtension;
    KIRQL           currentIrql;

    pdoExtension = PhysicalDeviceObject->DeviceExtension;

    if (!(pdoExtension->PdoState & (PDOS_REMOVED | PDOS_DEADMEAT | PDOS_SURPRISE_REMOVED)) ||
        RemovedOk) {

        IdeInterlockedIncrement (
            pdoExtension,
            &pdoExtension->ReferenceCount,
            Tag
            );

    } else {

        pdoExtension = NULL;
    }

    return pdoExtension;

} // RefPdoWithSpinLockHeld()


VOID
UnrefPdo(
    PPDO_EXTENSION PdoExtension
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    )
{
    UnrefLogicalUnitExtensionWithTag(
        PdoExtension->ParentDeviceExtension,
        PdoExtension,
        Tag
        );
}


PPDO_EXTENSION
RefLogicalUnitExtension(
    PFDO_EXTENSION DeviceExtension,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun,
    BOOLEAN RemovedOk
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    )

/*++

Routine Description:

    Walk logical unit extension list looking for
    extension with matching target id.

Arguments:

    deviceExtension
    TargetId

Return Value:

    Requested logical unit extension if found,
    else NULL.

--*/

{
    PPDO_EXTENSION  pdoExtension;
    PPDO_EXTENSION  pdoExtension2Return = NULL;
    KIRQL           currentIrql;

    if (TargetId >= DeviceExtension->HwDeviceExtension->MaxIdeTargetId) {
        return NULL;
    }

    KeAcquireSpinLock(&DeviceExtension->LogicalUnitListSpinLock, &currentIrql);

    pdoExtension = DeviceExtension->LogicalUnitList[(TargetId + Lun) % NUMBER_LOGICAL_UNIT_BINS];
    while (pdoExtension && !(pdoExtension->TargetId == TargetId &&
                             pdoExtension->Lun == Lun &&
                             pdoExtension->PathId == PathId)) {

        pdoExtension = pdoExtension->NextLogicalUnit;
    }

    if (pdoExtension) {

        pdoExtension2Return = RefPdoWithTag(
                                  pdoExtension->DeviceObject, 
                                  RemovedOk,
                                  Tag
                                  );
    }

    KeReleaseSpinLock(&DeviceExtension->LogicalUnitListSpinLock, currentIrql);

    return pdoExtension2Return;

} // end RefLogicalUnitExtension()

VOID
UnrefLogicalUnitExtension(
    PFDO_EXTENSION FdoExtension,
    PPDO_EXTENSION PdoExtension
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    )
{
    KIRQL   currentIrql;
    LONG    refCount;
    BOOLEAN deletePdo = FALSE;
    ULONG   lockCount;

    ASSERT (PdoExtension);

    if (PdoExtension) {

        KeAcquireSpinLock(&PdoExtension->PdoSpinLock, &currentIrql);

        ASSERT(PdoExtension->ReferenceCount > 0);

        lockCount = IdeInterlockedDecrement (
                        PdoExtension,
                        &PdoExtension->ReferenceCount,
                        Tag
                        );

//        ASSERT(lockCount >= 0);

        if (lockCount <= 0) {

            if ((PdoExtension->PdoState & PDOS_DEADMEAT) &&
                (PdoExtension->PdoState & PDOS_REMOVED)) {

                deletePdo = TRUE;
            }
        }

        KeReleaseSpinLock(&PdoExtension->PdoSpinLock, currentIrql);

        if (deletePdo) {

//            IoDeleteDevice (PdoExtension->DeviceObject);
            KeSetEvent (&PdoExtension->RemoveEvent, 0, FALSE);
        }
    }

} // UnrefLogicalUnitExtension();

PPDO_EXTENSION
AllocatePdo(
    IN PFDO_EXTENSION   FdoExtension,
    IN IDE_PATH_ID      PathId
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    )
/*++

Routine Description:

    Create logical unit extension.

Arguments:

    DeviceExtension
    PathId

Return Value:

    Logical unit extension


--*/
{
    PDEVICE_OBJECT    physicalDeviceObject;
    KIRQL             currentIrql;
    PPDO_EXTENSION    pdoExtension;
    ULONG size;
    ULONG bin;
    ULONG uniqueId;

    NTSTATUS          status;
    UNICODE_STRING    deviceName;
    WCHAR             deviceNameBuffer[64];

    PAGED_CODE();

    uniqueId = InterlockedIncrement (&IdeDeviceUniqueId) - 1;

    swprintf(deviceNameBuffer, DEVICE_OJBECT_BASE_NAME L"\\IdeDeviceP%dT%dL%d-%x", 
            FdoExtension->IdePortNumber,
            PathId.b.TargetId,
            PathId.b.Lun,
            uniqueId
            );
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);

    physicalDeviceObject = DeviceCreatePhysicalDeviceObject (
                               FdoExtension->DriverObject,
                               FdoExtension,
                               &deviceName
                               );

    if (physicalDeviceObject == NULL) {

        DebugPrint ((DBG_ALWAYS, "ATAPI: Unable to create device object\n", deviceNameBuffer));
        return NULL;
    }

    pdoExtension = physicalDeviceObject->DeviceExtension;

    pdoExtension->AttacherDeviceObject = physicalDeviceObject;

    pdoExtension->PathId    = (UCHAR) PathId.b.Path;
    pdoExtension->TargetId  = (UCHAR) PathId.b.TargetId;
    pdoExtension->Lun       = (UCHAR) PathId.b.Lun;

    //
    // Set timer counters in LogicalUnits to -1 to indicate no
    // outstanding requests.
    //

    pdoExtension->RequestTimeoutCounter = -1;

    //
    // This logical unit is be initialized
    //
    pdoExtension->LuFlags |= PD_RESCAN_ACTIVE;

    //
    // Allocate spin lock for critical sections.
    //
    KeInitializeSpinLock(&pdoExtension->PdoSpinLock);

    //
    // Initialize the request list.
    //

    InitializeListHead(&pdoExtension->SrbData.RequestList);

    //
    // Initialize a event
    //
    KeInitializeEvent (
        &pdoExtension->RemoveEvent,
        NotificationEvent,
        FALSE
        );

    //
    // Link logical unit extension on list.
    //

    bin = (PathId.b.TargetId + PathId.b.Lun) % NUMBER_LOGICAL_UNIT_BINS;

    //
    // get spinlock for accessing the logical unit extension bin
    //
    KeAcquireSpinLock(&FdoExtension->LogicalUnitListSpinLock, &currentIrql);

    pdoExtension->NextLogicalUnit =
        FdoExtension->LogicalUnitList[bin];

    //
    // Open the Command Log
    //
    IdeLogOpenCommandLog(&pdoExtension->SrbData);

    FdoExtension->LogicalUnitList[bin] = pdoExtension;

    FdoExtension->NumberOfLogicalUnits++;

    FdoExtension->NumberOfLogicalUnitsPowerUp++;

    IdeInterlockedIncrement (
        pdoExtension,
        &pdoExtension->ReferenceCount,
        Tag
        );

    KeReleaseSpinLock(&FdoExtension->LogicalUnitListSpinLock, currentIrql);

    return pdoExtension;

} // end CreateLogicalUnitExtension()


NTSTATUS
FreePdo(
    IN PPDO_EXTENSION   PdoExtension,
    IN BOOLEAN          Sync,
    IN BOOLEAN          CallIoDeleteDevice
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    )
{
    PFDO_EXTENSION          fdoExtension;
    PPDO_EXTENSION          pdoExtension;
    KIRQL                   currentIrql;
    PLOGICAL_UNIT_EXTENSION lastPdoExtension;
    ULONG                   targetId;
    ULONG                   lun;
    LONG                    refCount;
    NTSTATUS                status;

    targetId     = PdoExtension->TargetId;
    lun          = PdoExtension->Lun;
    fdoExtension = PdoExtension->ParentDeviceExtension;

    lastPdoExtension = NULL;

    //
    // get spinlock for accessing the logical unit extension bin
    //
    KeAcquireSpinLock(&fdoExtension->LogicalUnitListSpinLock, &currentIrql);

    pdoExtension = fdoExtension->LogicalUnitList[(targetId + lun) % NUMBER_LOGICAL_UNIT_BINS];
    while (pdoExtension != NULL) {

        if (pdoExtension == PdoExtension) {

            if (lastPdoExtension == NULL) {
    
                //
                // Remove from head of list.
                //
                fdoExtension->LogicalUnitList[(targetId + lun) % NUMBER_LOGICAL_UNIT_BINS] =
                    pdoExtension->NextLogicalUnit;
    
            } else {
    
                lastPdoExtension->NextLogicalUnit = pdoExtension->NextLogicalUnit;
            }

            ASSERT (!(pdoExtension->PdoState & PDOS_LEGACY_ATTACHER));

            if (pdoExtension->ReferenceCount > 1) {

                DebugPrint ((0, 
                            "IdePort FreePdo: pdoe 0x%x ReferenceCount is 0x%x\n", 
                            pdoExtension, 
                            pdoExtension->ReferenceCount));
            }

            fdoExtension->NumberOfLogicalUnits--;

            //
            // only if pdo is freed while it is powered up
            //
            if (pdoExtension->DevicePowerState <= PowerDeviceD0) {
            
                fdoExtension->NumberOfLogicalUnitsPowerUp--;
            }                

            KeReleaseSpinLock(&fdoExtension->LogicalUnitListSpinLock, currentIrql);

            break;
        }

        lastPdoExtension = pdoExtension;
        pdoExtension     = pdoExtension->NextLogicalUnit;
    }

    if (pdoExtension) {

        ASSERT (pdoExtension == PdoExtension);

        KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

        //
        // better not attached by a legacy device
        //
        ASSERT (!(pdoExtension->PdoState & PDOS_LEGACY_ATTACHER));

        //
        // lower the refer count for the caller
        // and save the new refCount
        //
        ASSERT(pdoExtension->ReferenceCount > 0);
        refCount = IdeInterlockedDecrement (
                       pdoExtension,
                       &pdoExtension->ReferenceCount,
                       Tag
                       );

        //
        // no more new request
        //
        pdoExtension->PdoState |= PDOS_DEADMEAT | PDOS_REMOVED;

        KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

        //
        // remove idle detection timer if any
        //
        DeviceUnregisterIdleDetection (PdoExtension);
        
        //
        // free acpi data
        //
        if (PdoExtension->AcpiDeviceSettings) {
        
            ExFreePool(PdoExtension->AcpiDeviceSettings);
            PdoExtension->AcpiDeviceSettings = NULL;
        }

        //
        // flush the requests in the queue
        //
        IdePortFlushLogicalUnit (
            fdoExtension,
            PdoExtension,
            TRUE
            ); 

        if (refCount) {

            if (Sync) {

                status = KeWaitForSingleObject(&pdoExtension->RemoveEvent,
                                               Executive,
                                               KernelMode,
                                               FALSE,
                                               NULL);
            }
        }

        if (CallIoDeleteDevice) {

			//
			// Free command log if it was allocated
			//
			IdeLogFreeCommandLog(&PdoExtension->SrbData);

            IoDeleteDevice (pdoExtension->DeviceObject);
        }

        return STATUS_SUCCESS;

    } else {

        KeReleaseSpinLock(&fdoExtension->LogicalUnitListSpinLock, currentIrql);
    
        if (CallIoDeleteDevice) {

            DebugPrint ((
                DBG_PNP,
                "ideport: deleting device 0x%x that was PROBABLY surprise removed\n",
                PdoExtension->DeviceObject
                ));
    
            //ASSERT (PdoExtension->PdoState & PDOS_SURPRISE_REMOVED);
            //
            // delete the device if it wasn't removed before.
            // PDOS_REMOVED could be set, if the device was surprise
            // removed. In that case remove the device
            //
            if (!(PdoExtension->PdoState & PDOS_REMOVED) || 
                        PdoExtension->PdoState & PDOS_SURPRISE_REMOVED) {
				//
				// Free command log if it was allocated
				//
				IdeLogFreeCommandLog(&PdoExtension->SrbData);

                IoDeleteDevice (PdoExtension->DeviceObject);
            }
    
        }

        return STATUS_SUCCESS;
    }

} // end FreeLogicalUnitExtension()


PLOGICAL_UNIT_EXTENSION
NextLogUnitExtension(
    IN     PFDO_EXTENSION FdoExtension,
    IN OUT PIDE_PATH_ID   PathId,
    IN     BOOLEAN        RemovedOk
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    )
{
    PLOGICAL_UNIT_EXTENSION logUnitExtension;


    logUnitExtension = NULL;

    for (; 
         !logUnitExtension && (PathId->b.Path < MAX_IDE_PATH); 
         PathId->b.Path++, PathId->b.TargetId = 0) {

        for (; 
             !logUnitExtension && (PathId->b.TargetId < FdoExtension->HwDeviceExtension->MaxIdeTargetId); 
             PathId->b.TargetId++, PathId->b.Lun = 0) {

            logUnitExtension = RefLogicalUnitExtensionWithTag (
                                   FdoExtension,
                                   (UCHAR) PathId->b.Path,
                                   (UCHAR) PathId->b.TargetId,
                                   (UCHAR) PathId->b.Lun,
                                   RemovedOk,
                                   Tag
                                   );

            if (logUnitExtension) {

                //
                // increment lun for the next time around
                //
                PathId->b.Lun++;
                return logUnitExtension;
            }

            //
            // Assume Lun number never skips.
            // If we can't find the logical unit extension for a lun,
            // will go to the next target ID with lun 0
            //
        }
    }

    return NULL;

} // end NextLogicalUnitExtension()

VOID
KillPdo(
    IN PPDO_EXTENSION PdoExtension
    )
{
    KIRQL currentIrql;

    ASSERT (PdoExtension);

    KeAcquireSpinLock(&PdoExtension->PdoSpinLock, &currentIrql);

    ASSERT (!(PdoExtension->PdoState & PDOS_DEADMEAT));

    SETMASK (PdoExtension->PdoState, PDOS_DEADMEAT);

    IdeLogDeadMeatReason( PdoExtension->DeadmeatRecord.Reason, 
                          byKilledPdo
                          );

    KeReleaseSpinLock(&PdoExtension->PdoSpinLock, currentIrql);
}


#if DBG

PVOID IdePortInterestedLockTag=NULL;

LONG 
IdeInterlockedIncrement (
   IN PPDO_EXTENSION PdoExtension,
   IN PLONG Addend,
   IN PVOID Tag
   )
{
    ULONG i;
    KIRQL currentIrql;

    DebugPrint ((
        DBG_PDO_LOCKTAG,
        ">>>>>>>>>>>>>>>>>>>> Acquire PdoLock with tag = 0x%x\n", 
        Tag
        ));

    if (IdePortInterestedLockTag == Tag) {

        DebugPrint ((DBG_ALWAYS, "Found the interested lock tag 0x%x\n", Tag));
        DbgBreakPoint();
    }

    KeAcquireSpinLock(&PdoExtension->RefCountSpinLock, &currentIrql);

    if (PdoExtension->NumTagUsed >= TAG_TABLE_SIZE) {

        DebugPrint ((DBG_ALWAYS, "Used up all %d tag\n", TAG_TABLE_SIZE));
        DbgBreakPoint();
    }

    for (i=0; i<PdoExtension->NumTagUsed; i++) {

        if (PdoExtension->TagTable[i] == Tag) {

            DebugPrint ((DBG_ALWAYS, "Tag 0x%x already in used\n", Tag));
            DbgBreakPoint();
        }
    }

    PdoExtension->TagTable[PdoExtension->NumTagUsed] = Tag;
    PdoExtension->NumTagUsed++;

    KeReleaseSpinLock(&PdoExtension->RefCountSpinLock, currentIrql);

    return InterlockedIncrement (Addend);
}

LONG 
IdeInterlockedDecrement (
   IN PPDO_EXTENSION PdoExtension,
   IN PLONG Addend,
   IN PVOID Tag
   )
{
    ULONG i;
    KIRQL currentIrql;
    BOOLEAN foundTag;

    DebugPrint ((
        DBG_PDO_LOCKTAG,
        ">>>>>>>>>>>>>>>>>>>> Release PdoLock with tag = 0x%x\n", 
        Tag
        ));

    KeAcquireSpinLock(&PdoExtension->RefCountSpinLock, &currentIrql);

    for (i=0, foundTag=FALSE; i<PdoExtension->NumTagUsed; i++) {

        if (PdoExtension->TagTable[i] == Tag) {

            if (PdoExtension->NumTagUsed > 1) {

                PdoExtension->TagTable[i] = 
                    PdoExtension->TagTable[PdoExtension->NumTagUsed - 1];
            }
            PdoExtension->NumTagUsed--;
            foundTag = TRUE;
            break;
        }
    }

    if (!foundTag) {

        DebugPrint ((DBG_ALWAYS, "Unable to find tag 0x%x\n", Tag));
        DbgBreakPoint();
    }

    KeReleaseSpinLock(&PdoExtension->RefCountSpinLock, currentIrql);

    return InterlockedDecrement (Addend);
}


#endif //DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\idedata.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       idedata.h
//
//--------------------------------------------------------------------------

extern CRASHDUMP_DATA DumpData;

extern const CHAR SuperFloppyCompatibleIdString[12];

extern PDRIVER_DISPATCH FdoPnpDispatchTable[NUM_PNP_MINOR_FUNCTION];
extern PDRIVER_DISPATCH PdoPnpDispatchTable[NUM_PNP_MINOR_FUNCTION];

extern PDRIVER_DISPATCH FdoWmiDispatchTable[NUM_WMI_MINOR_FUNCTION];
extern PDRIVER_DISPATCH PdoWmiDispatchTable[NUM_WMI_MINOR_FUNCTION];
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\internal.c ===
/*++

Copyright (C) Microsoft Corporation, 1990 - 1999

Module Name:

    internal.c

Abstract:

    This is the NT SCSI port driver.  This file contains the internal
    code.

Authors:

    Mike Glass
    Jeff Havens

Environment:

    kernel mode only

Notes:

    This module is a driver dll for scsi miniports.

Revision History:

--*/

#include "ideport.h"


NTSTATUS
IdeSendMiniPortIoctl(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP RequestIrp
    );

NTSTATUS
IdeSendScsiPassThrough (
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP RequestIrp,
    IN BOOLEAN Direct
    );

NTSTATUS
IdeGetInquiryData(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

NTSTATUS
IdeClaimLogicalUnit(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

NTSTATUS
IdeRemoveDevice(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

VOID
IdeLogResetError(
    IN PFDO_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK  Srb,
    IN ULONG UniqueId
    );

#ifdef LOG_GET_NEXT_CALLER

VOID
IdeLogCompletedCommand(
    PFDO_EXTENSION FdoExtension,
    PSCSI_REQUEST_BLOCK Srb
    );

VOID
IdeLogGetNextLuCaller (
    PFDO_EXTENSION FdoExtension,
    PPDO_EXTENSION PdoExtension,
    PUCHAR FileName,
    ULONG LineNumber
    );

#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(NONPAGE, IdePortDeviceControl)
#pragma alloc_text(PAGE, IdeSendMiniPortIoctl)
#pragma alloc_text(PAGE, IdeGetInquiryData)
#pragma alloc_text(PAGE, IdeSendScsiPassThrough)
#pragma alloc_text(PAGE, IdeClaimLogicalUnit)
#pragma alloc_text(PAGE, IdeRemoveDevice)
#endif

#if DBG
#define CheckIrql() {\
    if (saveIrql != KeGetCurrentIrql()){\
        DebugPrint((1, "saveIrql=%x, current=%x\n", saveIrql, KeGetCurrentIrql()));\
        ASSERT(FALSE);}\
}
#else
#define CheckIrql()
#endif

//
// Routines start
//

NTSTATUS
IdePortDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

    DeviceObject - Address of device object.
    Irp - Address of I/O request packet.

Return Value:

    Status.

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PDEVICE_EXTENSION_HEADER doExtension;
    PFDO_EXTENSION deviceExtension;
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    NTSTATUS status;
    RESET_CONTEXT resetContext;
    KIRQL currentIrql;
    KIRQL saveIrql=KeGetCurrentIrql();

#if DBG
    UCHAR savedCdb[16];
    ULONG ki;
#endif


    doExtension = DeviceObject->DeviceExtension;
    if (doExtension->AttacheeDeviceObject == NULL) {

        //
        // This is a PDO
        //
        PPDO_EXTENSION pdoExtension = (PPDO_EXTENSION) doExtension;

        srb->PathId     = (UCHAR) pdoExtension->PathId;
        srb->TargetId   = (UCHAR) pdoExtension->TargetId;
        srb->Lun        = (UCHAR) pdoExtension->Lun;

        ((PCDB) (srb->Cdb))->CDB6GENERIC.LogicalUnitNumber = srb->Lun;

        CheckIrql();
        return IdePortDispatch(
                   pdoExtension->ParentDeviceExtension->DeviceObject,
                   Irp
                   );

    } else {

        //
        // This is a FDO;
        //
        deviceExtension = (PFDO_EXTENSION) doExtension;
    }

    //
    // Init SRB Flags for IDE
    //
    INIT_IDE_SRB_FLAGS (srb);

    //
    // get the target device object extension
    //
    logicalUnit = RefLogicalUnitExtensionWithTag(
                      deviceExtension,
                      srb->PathId,
                      srb->TargetId,
                      srb->Lun,
                      TRUE,
                      Irp
                      );

    if (logicalUnit == NULL) {

        DebugPrint((1, "IdePortDispatch: Bad logical unit address.\n"));

        //
        // Fail the request. Set status in Irp and complete it.
        //

        srb->SrbStatus = SRB_STATUS_NO_DEVICE;
        Irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;
        CheckIrql();
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
        CheckIrql();
        return STATUS_NO_SUCH_DEVICE;
    }
    //
    // special flag for tape device
    //
    TEST_AND_SET_SRB_FOR_RDP(logicalUnit->ScsiDeviceType, srb);

    //
    // hang the logUnitExtension off the Irp
    //
    IDEPORT_PUT_LUNEXT_IN_IRP (irpStack, logicalUnit);

    //
    // check for DMA candidate
    // default (0) is DMA candidate
    //
    if (SRB_IS_DMA_CANDIDATE(srb)) {

        if (srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) {

            ULONG deviceFlags = deviceExtension->HwDeviceExtension->DeviceFlags[srb->TargetId];

            if (deviceFlags & DFLAGS_ATAPI_DEVICE) {

                if (srb->Cdb[0] == SCSIOP_MODE_SENSE) {

                    if (!(deviceFlags & DFLAGS_TAPE_DEVICE)) {

                        CheckIrql();
                        return DeviceAtapiModeSense(logicalUnit, Irp);

                    }

                    //
                    // we should do PIO for mode sense/select
                    //
                    MARK_SRB_AS_PIO_CANDIDATE(srb);


                } else if (srb->Cdb[0] == SCSIOP_MODE_SELECT) {
                    
                    if (!(deviceFlags & DFLAGS_TAPE_DEVICE)) {

                        CheckIrql();
                        return DeviceAtapiModeSelect(logicalUnit, Irp);

                    }

                    MARK_SRB_AS_PIO_CANDIDATE(srb);

                } else if (srb->Cdb[0] == SCSIOP_REQUEST_SENSE) {

                    //
                    // SCSIOP_REQUEST_SENSE
                    // ALi can't handle odd word udma xfer
                    // safest thing to do is do pio
                    //
                    MARK_SRB_AS_PIO_CANDIDATE(srb);

                } else if ((srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH) ||
                           (srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH_EX) ||
                           (srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH)) {

                    MARK_SRB_AS_PIO_CANDIDATE(srb);

                } else if ((srb->Cdb[0] == ATAPI_MODE_SENSE) ||
                           (srb->Cdb[0] == ATAPI_MODE_SELECT) ||
                           (srb->Cdb[0] == SCSIOP_INQUIRY) ||
                           (srb->Cdb[0] == SCSIOP_GET_EVENT_STATUS) ||
                           (srb->Cdb[0] == SCSIOP_GET_CONFIGURATION)) {

                    //
                    // ISSUE: use a pio only commands table
                    //
                    MARK_SRB_AS_PIO_CANDIDATE(srb);

                }

            } else { // ATA deivce

                if ((srb->Cdb[0] != SCSIOP_READ) && (srb->Cdb[0] != SCSIOP_WRITE)) {

                    //
                    // for ATA device, we can only DMA with SCSIOP_READ and SCSIOP_WRITE
                    //
                    MARK_SRB_AS_PIO_CANDIDATE(srb);

                    if (srb->Cdb[0] == SCSIOP_READ_CAPACITY) {

                        CheckIrql();
                        return DeviceIdeReadCapacity (logicalUnit, Irp);

                    } else if (srb->Cdb[0] == SCSIOP_MODE_SENSE) {

                        CheckIrql();
                        return DeviceIdeModeSense (logicalUnit, Irp);

                    } else if (srb->Cdb[0] == SCSIOP_MODE_SELECT) {

                        CheckIrql();
                        return DeviceIdeModeSelect (logicalUnit, Irp);
                    }
                } 

            }


            //
            //Check with the miniport (Special cases)
            //


            ASSERT (doExtension->AttacheeDeviceObject);
            ASSERT (srb->TargetId >=0);

#if DBG
                for (ki=0;ki<srb->CdbLength;ki++) {
                    savedCdb[ki]=srb->Cdb[ki];
                }
#endif

            //Check for NULL.
            if (deviceExtension->TransferModeInterface.UseDma){
                if (!((deviceExtension->TransferModeInterface.UseDma)
                      (deviceExtension->TransferModeInterface.VendorSpecificDeviceExtension,
                                                  (PVOID)(srb->Cdb), srb->TargetId))) {
                     MARK_SRB_AS_PIO_CANDIDATE(srb);
                }
            }

#if DBG
            for (ki=0;ki<srb->CdbLength;ki++) {
                if (savedCdb[ki] != srb->Cdb[ki]) {
                    DebugPrint((DBG_ALWAYS,
                               "Miniport modified the Cdb\n"));
                    ASSERT(FALSE);
                }
            }
#endif

            if ((logicalUnit->DmaTransferTimeoutCount >= PDO_DMA_TIMEOUT_LIMIT) ||
                (logicalUnit->CrcErrorCount >= PDO_UDMA_CRC_ERROR_LIMIT)) {

                //
                // broken hardware
                //
                MARK_SRB_AS_PIO_CANDIDATE(srb);
            }

        } else {

            MARK_SRB_AS_PIO_CANDIDATE(srb);
        }
    }

    switch (srb->Function) {

        case SRB_FUNCTION_SHUTDOWN:

            DebugPrint((1, "IdePortDispatch: SRB_FUNCTION_SHUTDOWN...\n"));

        // ISSUE: 08/30/2000: disable/restore MSN settings

		case SRB_FUNCTION_FLUSH:
			{
            ULONG dFlags = deviceExtension->HwDeviceExtension->DeviceFlags[srb->TargetId];

			//
			// for IDE devices, complete the request with status success if
			// the device doesn't support the flush cache command
			//
			if (!(dFlags & DFLAGS_ATAPI_DEVICE) &&
				((logicalUnit->FlushCacheTimeoutCount >= PDO_FLUSH_TIMEOUT_LIMIT) ||
				(logicalUnit->
					ParentDeviceExtension->
					HwDeviceExtension->
					DeviceParameters[logicalUnit->TargetId].IdeFlushCommand
				 == IDE_COMMAND_NO_FLUSH))) {

				srb->SrbStatus = SRB_STATUS_SUCCESS;
				status = STATUS_SUCCESS;
                CheckIrql();
                break;
			}

			DebugPrint((1, 
						"IdePortDispatch: SRB_FUNCTION_%x to target %x\n", 
						srb->Function,
						srb->TargetId
						));

#if 1
            //
            // we don't really handle these srb functions (shutdown
            // and flush). They just get translated to a flush cache
            // command on ata drives (since we don't know how to flush
            // the adapter cache). We will ignore them, since the
            // upper drivers should use SCSIOP_SYNCHRONIZE_CACHE to 
            // flush the device cache. 
            //
            if (!(dFlags & DFLAGS_ATAPI_DEVICE)) {
                srb->SrbStatus = SRB_STATUS_SUCCESS;
                status = STATUS_SUCCESS;
                CheckIrql();
                break;
            }
#endif
			//
			// Fall thru to  execute_scsi
			//

			}

        case SRB_FUNCTION_ATA_POWER_PASS_THROUGH:
        case SRB_FUNCTION_ATA_PASS_THROUGH:
        case SRB_FUNCTION_ATA_PASS_THROUGH_EX:
        case SRB_FUNCTION_IO_CONTROL:
        case SRB_FUNCTION_EXECUTE_SCSI:

            if (logicalUnit->PdoState & PDOS_DEADMEAT) {

                //
                // Fail the request. Set status in Irp and complete it.
                //
                srb->SrbStatus = SRB_STATUS_NO_DEVICE;
                status = STATUS_NO_SUCH_DEVICE;
                CheckIrql();
                break;
            }

            if (srb->SrbFlags & SRB_FLAGS_NO_KEEP_AWAKE) {

                if (logicalUnit->DevicePowerState != PowerDeviceD0) {

                    DebugPrint ((DBG_POWER, "0x%x powered down.  failing SRB_FLAGS_NO_KEEP_AWAKE srb 0x%x\n", logicalUnit, srb));

                    srb->SrbStatus = SRB_STATUS_NOT_POWERED;
                    status = STATUS_NO_SUCH_DEVICE;
                    CheckIrql();
                    break;
                }
            }

            //
            // Mark Irp status pending.
            //
            IoMarkIrpPending(Irp);

            if (srb->SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE) {

                //
                // Call start io directly.  This will by-pass the
                // frozen queue.
                //

                DebugPrint((DBG_READ_WRITE,
                    "IdePortDispatch: Bypass frozen queue, IRP %lx\n",
                    Irp));

                IoStartPacket(DeviceObject, Irp, (PULONG)NULL, NULL);

                CheckIrql();
                return STATUS_PENDING;

            } else {

                BOOLEAN inserted;

                //
                // Queue the packet normally.
                //
                status = IdePortInsertByKeyDeviceQueue (
                             logicalUnit,
                             Irp,
                             srb->QueueSortKey,
                             &inserted
                             );

                if (NT_SUCCESS(status) && inserted) {

                    //
                    // irp is queued
                    //
                } else {

                    //
                    // irp is ready to go
                    //

                    //
                    // Clear the active flag.  If there is another request, the flag will be
                    // set again when the request is passed to the miniport.
                    //
                    CLRMASK (logicalUnit->LuFlags, PD_LOGICAL_UNIT_IS_ACTIVE);

                    //
                    // Clear the retry count.
                    //

                    logicalUnit->RetryCount = 0;

                    //
                    // Queue is empty; start request.
                    //
                    IoStartPacket(DeviceObject, Irp, (PULONG)NULL, NULL);
                }

                CheckIrql();
                return STATUS_PENDING;
            }

        case SRB_FUNCTION_RELEASE_QUEUE:

            DebugPrint((2,"IdePortDispatch: SCSI unfreeze queue TID %d\n",
                srb->TargetId));

            //
            // Acquire the spinlock to protect the flags structure and the saved
            // interrupt context.
            //

            KeRaiseIrql(DISPATCH_LEVEL, &currentIrql);
            KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

            //
            // Make sure the queue is frozen.
            //

            if (!(logicalUnit->LuFlags & PD_QUEUE_FROZEN)) {

                DebugPrint((DBG_WARNING,
                            "IdePortDispatch:  Request to unfreeze an unfrozen queue!\n"
                            ));

                KeReleaseSpinLock(&deviceExtension->SpinLock, currentIrql);
                srb->SrbStatus = SRB_STATUS_SUCCESS;
                status = STATUS_SUCCESS;
                CheckIrql();
                break;

            }

            CLRMASK (logicalUnit->LuFlags, PD_QUEUE_FROZEN);

            //
            // If there is not an untagged request running then start the
            // next request for this logical unit.  Otherwise free the
            // spin lock.
            //

            if (logicalUnit->SrbData.CurrentSrb == NULL) {

                //
                // GetNextLuRequest frees the spinlock.
                //

                GetNextLuRequest(deviceExtension, logicalUnit);
                KeLowerIrql(currentIrql);

            } else {

                DebugPrint((DBG_WARNING,
                            "IdePortDispatch: Request to unfreeze queue with active request\n"
                            ));
                KeReleaseSpinLock(&deviceExtension->SpinLock, currentIrql);

            }


            srb->SrbStatus = SRB_STATUS_SUCCESS;
            status = STATUS_SUCCESS;

            CheckIrql();
            break;

        case SRB_FUNCTION_RESET_BUS: {

            PATA_PASS_THROUGH  ataPassThroughData;

            ataPassThroughData = ExAllocatePool(NonPagedPool, sizeof(ATA_PASS_THROUGH));

            if (ataPassThroughData == NULL) {
                srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
                srb->InternalStatus=STATUS_INSUFFICIENT_RESOURCES;
                status=STATUS_INSUFFICIENT_RESOURCES;
                IdeLogNoMemoryError(deviceExtension,
                                    logicalUnit->TargetId,
                                    NonPagedPool,
                                    sizeof(ATA_PASS_THROUGH),
                                    IDEPORT_TAG_DISPATCH_RESET
                                    );
                CheckIrql();
                break;
            }

            RtlZeroMemory (ataPassThroughData, sizeof (*ataPassThroughData));
            ataPassThroughData->IdeReg.bReserved   = ATA_PTFLAGS_BUS_RESET;

            status = IssueSyncAtaPassThroughSafe (
                         logicalUnit->ParentDeviceExtension,
                         logicalUnit,
                         ataPassThroughData,
                         FALSE,
                         FALSE,
                         30,
                         FALSE
                         );

            if (NT_SUCCESS(status)) {

                IdeLogResetError(deviceExtension,
                                srb,
                                ('R'<<24) | 256);

                srb->SrbStatus = SRB_STATUS_SUCCESS;

            } else {

                //
                // fail to send ata pass through
                //
                srb->SrbStatus = SRB_STATUS_ERROR;
                if (status==STATUS_INSUFFICIENT_RESOURCES) {
                    srb->SrbStatus = SRB_STATUS_INTERNAL_ERROR;
                    srb->InternalStatus=STATUS_INSUFFICIENT_RESOURCES;
                }
            }

            CheckIrql();
            break;

        }

            //
            // Acquire the spinlock to protect the flags structure and the saved
            // interrupt context.
            //
            /*++
            KeAcquireSpinLock(&deviceExtension->SpinLock, &currentIrql);

            resetContext.DeviceExtension = deviceExtension;
            resetContext.PathId = srb->PathId;
            resetContext.NewResetSequence = TRUE;
            resetContext.ResetSrb = NULL;

            if (!KeSynchronizeExecution(deviceExtension->InterruptObject,
                                        IdeResetBusSynchronized,
                                        &resetContext)) {

                DebugPrint((1,"IdePortDispatch: Reset failed\n"));
                srb->SrbStatus = SRB_STATUS_PHASE_SEQUENCE_FAILURE;
                status = STATUS_IO_DEVICE_ERROR;

            } else {

                IdeLogResetError(deviceExtension,
                                srb,
                                ('R'<<24) | 256);

                srb->SrbStatus = SRB_STATUS_SUCCESS;
                status = STATUS_SUCCESS;
            }

            KeReleaseSpinLock(&deviceExtension->SpinLock, currentIrql);
            CheckIrql();
            break;
            --*/


        case SRB_FUNCTION_ABORT_COMMAND:

            DebugPrint((1, "IdePortDispatch: SCSI Abort or Reset command\n"));

            //
            // Mark Irp status pending.
            //

            IoMarkIrpPending(Irp);

            //
            // Don't queue these requests in the logical unit
            // queue, rather queue them to the adapter queue.
            //

            KeRaiseIrql(DISPATCH_LEVEL, &currentIrql);

            IoStartPacket(DeviceObject, Irp, (PULONG)NULL, NULL);

            KeLowerIrql(currentIrql);

            CheckIrql();
            return STATUS_PENDING;

            break;

        case SRB_FUNCTION_FLUSH_QUEUE:

            DebugPrint((1, "IdePortDispatch: SCSI flush queue command\n"));

            status = IdePortFlushLogicalUnit (
                         deviceExtension,
                         logicalUnit,
                         FALSE
                         );

            if (NT_SUCCESS(status)) {

                srb->SrbStatus = SRB_STATUS_SUCCESS;

            } else {

                srb->SrbStatus = SRB_STATUS_ERROR;
            }

            CheckIrql();
            break;

        case SRB_FUNCTION_ATTACH_DEVICE:
        case SRB_FUNCTION_CLAIM_DEVICE:
        case SRB_FUNCTION_RELEASE_DEVICE:

            status = IdeClaimLogicalUnit(deviceExtension, Irp);
            CheckIrql();
            break;

        case SRB_FUNCTION_REMOVE_DEVICE:

            //
            // decrement the refcount before remove the device
            //
            UnrefLogicalUnitExtensionWithTag(
                deviceExtension,
                logicalUnit,
                Irp
                );

            status = IdeRemoveDevice(deviceExtension, Irp);
            Irp->IoStatus.Status = status;
            CheckIrql();
            IoCompleteRequest(Irp, IO_NO_INCREMENT);
            CheckIrql();
            return status;

        default:

            //
            // Found unsupported SRB function.
            //

            DebugPrint((1,"IdePortDispatch: Unsupported function, SRB %lx\n",
                srb));

            srb->SrbStatus = SRB_STATUS_INVALID_REQUEST;
            status = STATUS_INVALID_DEVICE_REQUEST;
            CheckIrql();
            break;
    }


    //
    // Set status in Irp.
    //

    Irp->IoStatus.Status = status;

    //
    // Decrement the logUnitExtension reference count
    //
    CheckIrql();
    UnrefLogicalUnitExtensionWithTag(
        deviceExtension,
        logicalUnit,
        Irp
        );

    IDEPORT_PUT_LUNEXT_IN_IRP (irpStack, NULL);

    //
    // Complete request at raised IRQ.
    //
    CheckIrql();
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    CheckIrql();

    return status;

} // end IdePortDispatch()



VOID
IdePortStartIo (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

Arguments:

    DeviceObject - Supplies pointer to Adapter device object.
    Irp - Supplies a pointer to an IRP.

Return Value:

    Nothing.

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;
    PFDO_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    PSRB_DATA srbData;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    LONG interlockResult;
    NTSTATUS status;

    ULONG deviceFlags = deviceExtension->HwDeviceExtension->DeviceFlags[srb->TargetId];
    PCDB cdb;

    LARGE_INTEGER timer;

    LogStartTime(TimeStartIo, &timer);

    DebugPrint((3,"IdePortStartIo: Enter routine\n"));

    //
    // Set the default flags in the SRB.
    //

    srb->SrbFlags |= deviceExtension->SrbFlags;

    //
    // Get logical unit extension.
    //

    logicalUnit = IDEPORT_GET_LUNEXT_IN_IRP (irpStack);

    if (!(srb->SrbFlags & SRB_FLAGS_NO_KEEP_AWAKE) &&
        (srb->Function != SRB_FUNCTION_ATA_POWER_PASS_THROUGH) &&
        (logicalUnit->IdleCounter)) {

        //
        // Tell Po that we are busy
        //
        PoSetDeviceBusy (logicalUnit->IdleCounter);
    }

    DebugPrint((2,"IdePortStartIo:  Irp 0x%8x Srb 0x%8x DataBuf 0x%8x Len 0x%8x\n", Irp, srb, srb->DataBuffer, srb->DataTransferLength));

    //
    // No special resources are required.  Set the SRB data to the
    // structure in the logical unit extension, set the queue tag value
    // to the untagged value, and clear the SRB extension.
    //

    srbData = &logicalUnit->SrbData;

    //
    // Update the sequence number for this request if there is not already one
    // assigned.
    //

    if (!srbData->SequenceNumber) {

        //
        // Assign a sequence number to the request and store it in the logical
        // unit.
        //

        srbData->SequenceNumber = deviceExtension->SequenceNumber++;

    }

    //
    // If this is not an ABORT request the set the current srb.
    // NOTE: Lock should be held here!
    //

    if (srb->Function != SRB_FUNCTION_ABORT_COMMAND) {

        ASSERT(srbData->CurrentSrb == NULL);
        srbData->CurrentSrb = srb;
        ASSERT(srbData->CurrentSrb);

        if ((deviceExtension->HwDeviceExtension->DeviceFlags[srb->TargetId] & DFLAGS_USE_DMA) &&
            SRB_IS_DMA_CANDIDATE(srb)) {

            MARK_SRB_FOR_DMA(srb);

        } else {

            MARK_SRB_FOR_PIO(srb);
        }

     } else {

        //
        // Only abort requests can be started when there is a current request
        // active.
        //

        ASSERT(logicalUnit->AbortSrb == NULL);
        logicalUnit->AbortSrb = srb;
    }
    
    //
    // Log the command
    //
    IdeLogStartCommandLog(srbData);

    //
    // Flush the data buffer if necessary.
    //

    if (srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) {

        //
        // Save the MDL virtual address.
        //

        srbData->SrbDataOffset = MmGetMdlVirtualAddress(Irp->MdlAddress);

        do {

            //
            // Determine if the adapter needs mapped memory.
            //
            if (!SRB_USES_DMA(srb)) { // PIO

                if (Irp->MdlAddress) {

                    //
                    // Get the mapped system address and
                    // calculate offset into MDL.
                    //
                    srbData->SrbDataOffset = MmGetSystemAddressForMdlSafe(Irp->MdlAddress, HighPagePriority);

					if ((srbData->SrbDataOffset == NULL) &&
						(deviceExtension->ReservedPages != NULL)) {

                        KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

						//
						// this would set the appropriate flags in the device extension
						// and srbData only when the call succeeds.
						//
						srbData->SrbDataOffset = IdeMapLockedPagesWithReservedMapping(deviceExtension,
																					  srbData,
																					  Irp->MdlAddress
																					  );

						//
						// if there is another active request using the reserved pages
						// mark this one pending. When the active request completes this
						// one will be picked up
						//
						if (srbData->SrbDataOffset == (PVOID)-1) {

							DebugPrint ((1,
										 "Irp 0x%x marked pending\n",
										 Irp
										 ));

							//
							// remove the current Srb
							//
							srbData->CurrentSrb = NULL;

							ASSERT(DeviceObject->CurrentIrp == Irp);
							SETMASK(deviceExtension->Flags, PD_PENDING_DEVICE_REQUEST);

							KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
							return;
						}

						KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
                        
					}

                    if (srbData->SrbDataOffset == NULL) {

						deviceExtension->LastMemoryFailure += IDEPORT_TAG_STARTIO_MDL;

                        srbData->CurrentSrb = NULL;

                        //
                        // This is the correct status for insufficient resources
                        //
                        srb->SrbStatus=SRB_STATUS_INTERNAL_ERROR;
                        srb->InternalStatus=STATUS_INSUFFICIENT_RESOURCES;
                        Irp->IoStatus.Status=STATUS_INSUFFICIENT_RESOURCES;

                        IdeLogNoMemoryError(deviceExtension,
                                            logicalUnit->TargetId,
                                            NonPagedPool,
                                            sizeof(MDL),
                                            IDEPORT_TAG_STARTIO_MDL
                                            );
                        //
                        // Clear the device busy flag
                        //
                        IoStartNextPacket(DeviceObject, FALSE);

                        //
                        // Acquire spin lock to protect the flags
                        //
                        KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

                        //
                        // Get the next request, if this request does not
                        // bypass frozen queue. We don't want to start the
                        // next request, if the queue is frozen.
                        //
                        if (!(srb->SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE)) {

                            //
                            // This flag needs to be set for getnextlu to work
                            //
                            logicalUnit->LuFlags |= PD_LOGICAL_UNIT_IS_ACTIVE;

                            //
                            // Retrieve the next request and give it to the fdo
                            // This releases the spinlock
                            //
                            GetNextLuRequest(deviceExtension, logicalUnit);
                        }
                        else {

                            KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);
                        }

                        //
                        // Decrement the logUnitExtension reference count
                        //
                        UnrefLogicalUnitExtensionWithTag(
                            deviceExtension,
                            logicalUnit,
                            Irp
                            );

                        //
                        // Complete the request
                        //
                        IoCompleteRequest(Irp, IO_NO_INCREMENT);

                        return;
                    }

                    srb->DataBuffer = srbData->SrbDataOffset +
                        (ULONG)((PUCHAR)srb->DataBuffer -
                        (PCCHAR)MmGetMdlVirtualAddress(Irp->MdlAddress));
                }

                IdePortAllocateAccessToken (DeviceObject);

                status = STATUS_SUCCESS;

            } else { // DMA

                //
                // If the buffer is not mapped then the I/O buffer must be flushed.
                //

                KeFlushIoBuffers(Irp->MdlAddress,
                                 (BOOLEAN) (srb->SrbFlags & SRB_FLAGS_DATA_IN ? TRUE : FALSE),
                                 TRUE);

#if defined (FAKE_BMSETUP_FAILURE)

                if (!(FailBmSetupCount++ % FAKE_BMSETUP_FAILURE)) {

                    status = STATUS_UNSUCCESSFUL;

                } else {

#endif // FAKE_BMSETUP_FAILURE
                    status = deviceExtension->HwDeviceExtension->BusMasterInterface.BmSetup (
                                    deviceExtension->HwDeviceExtension->BusMasterInterface.Context,
                                    srb->DataBuffer,
                                    srb->DataTransferLength,
                                    Irp->MdlAddress,
                                    (BOOLEAN) (srb->SrbFlags & SRB_FLAGS_DATA_IN),
                                    IdePortAllocateAccessToken,
                                    DeviceObject
                                    );

#if defined (FAKE_BMSETUP_FAILURE)
                }
#endif // FAKE_BMSETUP_FAILURE

                if (!NT_SUCCESS(status)) {

                    DebugPrint((1,
                                "IdePortStartIo: IoAllocateAdapterChannel failed(%x). try pio for srb %x\n",
                                status, srb));

                    //
                    // out of resource for DMA, try PIO
                    //
                    MARK_SRB_FOR_PIO(srb);
                }
            }

        } while (!NT_SUCCESS(status));

    } else {

        IdePortAllocateAccessToken (DeviceObject);
    }

    LogStopTime(TimeStartIo, &timer, 0);
    return;

} // end IdePortStartIO()




BOOLEAN
IdePortInterrupt(
    IN PKINTERRUPT Interrupt,
    IN PDEVICE_OBJECT DeviceObject
    )

/*++

Routine Description:


Arguments:

    Interrupt

    Device Object

Return Value:

    Returns TRUE if interrupt expected.

--*/

{
    PFDO_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    BOOLEAN returnValue;
    LARGE_INTEGER timer;

    UNREFERENCED_PARAMETER(Interrupt);

#ifdef ENABLE_ATAPI_VERIFIER
    ViAtapiInterrupt(deviceExtension);
#endif

    LogStartTime(TimeIsr, &timer);
    returnValue = AtapiInterrupt(deviceExtension->HwDeviceExtension);
    LogStopTime(TimeIsr, &timer, 100);

    //
    // Check to see if a DPC needs to be queued.
    //
    if (deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

        IoRequestDpc(deviceExtension->DeviceObject, NULL, NULL);

    }
    return(returnValue);

} // end IdePortInterrupt()

VOID
IdePortCompletionDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

    Dpc
    DeviceObject
    Irp - not used
//    Context - not used

Return Value:

    None.

--*/

{
    PFDO_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    INTERRUPT_CONTEXT interruptContext;
    INTERRUPT_DATA savedInterruptData;
    BOOLEAN callStartIo;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSRB_DATA srbData;
    LONG interlockResult;
    LARGE_INTEGER timeValue;
    PMDL mdl;

    LARGE_INTEGER timer;
    LogStartTime(TimeDpc, &timer);


    UNREFERENCED_PARAMETER(Dpc);


    //
    // Acquire the spinlock to protect flush adapter buffers information.
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

    //
    // Get the interrupt state.  This copies the interrupt state to the
    // saved state where it can be processed.  It also clears the interrupt
    // flags.
    //


    interruptContext.DeviceExtension = deviceExtension;
    interruptContext.SavedInterruptData = &savedInterruptData;

    if (!KeSynchronizeExecution(deviceExtension->InterruptObject,
                                IdeGetInterruptState,
                                &interruptContext)) {

        //
        // There is no work to do so just return.
        //
        KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

        LogStopTime(TimeDpc, &timer, 0);
        return;
    }


    //
    // We only support one request at a time, so we can just check
    // the first completed request to determine whether we use DMA
    // and whether we need to flush DMA
    //
    if (savedInterruptData.CompletedRequests != NULL) {

        PSCSI_REQUEST_BLOCK srb;

        srbData = savedInterruptData.CompletedRequests;
        ASSERT(srbData->CurrentSrb);


        srb     = srbData->CurrentSrb;

        if (srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) {

            if (SRB_USES_DMA(srb)) {

                deviceExtension->HwDeviceExtension->BusMasterInterface.BmFlush (
                    deviceExtension->HwDeviceExtension->BusMasterInterface.Context
                    );
            }
        }
    }

    //
    // check for empty channels
    //
    if (savedInterruptData.InterruptFlags & PD_ALL_DEVICE_MISSING) {

        PPDO_EXTENSION pdoExtension;
        IDE_PATH_ID pathId;
        ULONG errorCount;
		BOOLEAN rescanActive = FALSE;


        pathId.l = 0;
        while (pdoExtension = NextLogUnitExtensionWithTag (
                                  deviceExtension,
                                  &pathId,
                                  TRUE,
                                  IdePortCompletionDpc
                                  )) {

            KeAcquireSpinLockAtDpcLevel(&pdoExtension->PdoSpinLock);

            SETMASK (pdoExtension->PdoState, PDOS_DEADMEAT);

            IdeLogDeadMeatReason( pdoExtension->DeadmeatRecord.Reason, 
                                  reportedMissing
                                  );
			if (pdoExtension->LuFlags & PD_RESCAN_ACTIVE) {
				rescanActive = TRUE; 
			}

            KeReleaseSpinLockFromDpcLevel(&pdoExtension->PdoSpinLock);

            UnrefPdoWithTag(
                pdoExtension,
                IdePortCompletionDpc
                );
        }

		//
		// Don't ask for a rescan if you are in the middle of one.
		//
		if (!rescanActive) {

			IoInvalidateDeviceRelations (
				deviceExtension->AttacheePdo,
				BusRelations
				);
		} else {

			DebugPrint((1, 
						"The device marked deadmeat during enumeration\n"
						));

		}

    }

    //
    // Check for timer requests.
    //

    if (savedInterruptData.InterruptFlags & PD_TIMER_CALL_REQUEST) {

        //
        // The miniport wants a timer request. Save the timer parameters.
        //

        deviceExtension->HwTimerRequest = savedInterruptData.HwTimerRequest;

        //
        // If the requested timer value is zero, then cancel the timer.
        //

        if (savedInterruptData.MiniportTimerValue == 0) {

            KeCancelTimer(&deviceExtension->MiniPortTimer);

        } else {

            //
            // Convert the timer value from mircoseconds to a negative 100
            // nanoseconds.
            //

            timeValue.QuadPart = Int32x32To64(
                  savedInterruptData.MiniportTimerValue,
                  -10);

            //
            // Set the timer.
            //

            KeSetTimer(&deviceExtension->MiniPortTimer,
                       timeValue,
                       &deviceExtension->MiniPortTimerDpc);
        }
    }

    if (savedInterruptData.InterruptFlags & PD_RESET_REQUEST) {

        RESET_CONTEXT resetContext;

        //
        // clear the reset request
        //
        CLRMASK (savedInterruptData.InterruptFlags, PD_RESET_REQUEST);

        //
        // Request timed out.
        //
        resetContext.DeviceExtension = deviceExtension;
        resetContext.PathId = 0;
        resetContext.NewResetSequence = TRUE;
        resetContext.ResetSrb = NULL;

        if (!KeSynchronizeExecution(deviceExtension->InterruptObject,
                                    IdeResetBusSynchronized,
                                    &resetContext)) {

            DebugPrint((DBG_WARNING,"IdePortCompletionDpc: Reset failed\n"));
        }
    }

    //
    // Verify that the ready for next request is ok.
    //

    if (savedInterruptData.InterruptFlags & PD_READY_FOR_NEXT_REQUEST) {

        //
        // If the device busy bit is not set, then this is a duplicate request.
        // If a no disconnect request is executing, then don't call start I/O.
        // This can occur when the miniport does a NextRequest followed by
        // a NextLuRequest.
        //

        if ((deviceExtension->Flags & (PD_DEVICE_IS_BUSY | PD_DISCONNECT_RUNNING))
            == (PD_DEVICE_IS_BUSY | PD_DISCONNECT_RUNNING)) {

            //
            // Clear the device busy flag.  This flag is set by
            // IdeStartIoSynchonized.
            //

            CLRMASK (deviceExtension->Flags, PD_DEVICE_IS_BUSY);

            if (!(savedInterruptData.InterruptFlags & PD_RESET_HOLD)) {

                //
                // The miniport is ready for the next request and there is
                // not a pending reset hold, so clear the port timer.
                //

                deviceExtension->PortTimeoutCounter = PD_TIMER_STOPPED;
            }

        } else {

            //
            // If a no disconnect request is executing, then clear the
            // busy flag.  When the disconnect request completes an
            // IoStartNextPacket will be done.
            //

            CLRMASK (deviceExtension->Flags, PD_DEVICE_IS_BUSY);

            //
            // Clear the ready for next request flag.
            //

            CLRMASK (savedInterruptData.InterruptFlags, PD_READY_FOR_NEXT_REQUEST);
        }
    }

    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

    //
    // Free Access Token
    //
    if ((savedInterruptData.CompletedRequests != NULL) &&
        (deviceExtension->SyncAccessInterface.FreeAccessToken)) {

        (*deviceExtension->SyncAccessInterface.FreeAccessToken) (
            deviceExtension->SyncAccessInterface.Token
            );
    }

    //
    // Check for a ready for next packet.
    //

    if (savedInterruptData.InterruptFlags & PD_READY_FOR_NEXT_REQUEST) {

        //
        // Start the next request.
        //

        IoStartNextPacket(deviceExtension->DeviceObject, FALSE);
    }

    //
    // Check for an error log requests.
    //

    if (savedInterruptData.InterruptFlags & PD_LOG_ERROR) {

        //
        // Process the request.
        //

        LogErrorEntry(deviceExtension,
                      &savedInterruptData.LogEntry);
    }

    //
    // Process any completed requests.
    //

    callStartIo = FALSE;

    while (savedInterruptData.CompletedRequests != NULL) {

        //
        // Remove the request from the linked-list.
        //

        srbData = savedInterruptData.CompletedRequests;

        savedInterruptData.CompletedRequests = srbData->CompletedRequests;
        srbData->CompletedRequests = NULL;

        //
        // We only supports one request at a time
        //
        ASSERT (savedInterruptData.CompletedRequests == NULL);

        //
        // Stop the command log. The request sense will be logged as the next request.
        //
        IdeLogStopCommandLog(srbData);

        IdeProcessCompletedRequest(deviceExtension,
                                   srbData,
                                   &callStartIo);
    }

    //
    // Process any completed abort requests.
    //

    while (savedInterruptData.CompletedAbort != NULL) {

        logicalUnit = savedInterruptData.CompletedAbort;

        //
        // Remove request from the completed abort list.
        //

        savedInterruptData.CompletedAbort = logicalUnit->CompletedAbort;

        //
        // Acquire the spinlock to protect the flags structure,
        // and the free of the srb extension.
        //

        KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

        //
        // Note the timer which was started for the abort request is not
        // stopped by the get interrupt routine.  Rather the timer is stopped.
        // when the aborted request completes.
        //

        Irp = logicalUnit->AbortSrb->OriginalRequest;


        //
        // Set IRP status. Class drivers will reset IRP status based
        // on request sense if error.
        //

        if (SRB_STATUS(logicalUnit->AbortSrb->SrbStatus) == SRB_STATUS_SUCCESS) {
            Irp->IoStatus.Status = STATUS_SUCCESS;
        } else {
            Irp->IoStatus.Status = IdeTranslateSrbStatus(logicalUnit->AbortSrb);
        }

        Irp->IoStatus.Information = 0;

        //
        // Clear the abort request pointer.
        //

        logicalUnit->AbortSrb = NULL;

        KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

        UnrefLogicalUnitExtensionWithTag(
            deviceExtension,
            IDEPORT_GET_LUNEXT_IN_IRP(IoGetCurrentIrpStackLocation(Irp)),
            Irp
            );

        IoCompleteRequest(Irp, IO_DISK_INCREMENT);
    }

    //
    // Call the start I/O routine if necessary.
    //

    if (callStartIo) {

        ASSERT(DeviceObject->CurrentIrp != NULL);
        IdePortStartIo(DeviceObject, DeviceObject->CurrentIrp);
    }

    //
    // Check for reset
    //
    if (savedInterruptData.InterruptFlags & PD_RESET_REPORTED) {

        //
        // we had a bus reset.  everyone on the bus should be in PowerDeviceD0
        //
        IDE_PATH_ID             pathId;
        PPDO_EXTENSION          pdoExtension;
        POWER_STATE             powerState;

        pathId.l = 0;
        powerState.DeviceState = PowerDeviceD0;

        while (pdoExtension = NextLogUnitExtensionWithTag (
                                  deviceExtension,
                                  &pathId,
                                  FALSE,
                                  IdePortCompletionDpc
                                  )) {

            //
            // If rescan is active, the pdo might go away
            //
            if (pdoExtension != savedInterruptData.PdoExtensionResetBus &&
                !(pdoExtension->LuFlags & PD_RESCAN_ACTIVE)) {

                PoRequestPowerIrp (
                    pdoExtension->DeviceObject,
                    IRP_MN_SET_POWER,
                    powerState,
                    NULL,
                    NULL,
                    NULL
                    );
            }

            UnrefLogicalUnitExtensionWithTag (
                deviceExtension,
                pdoExtension,
                IdePortCompletionDpc
                );
        }
    }

    LogStopTime(TimeDpc, &timer, 0);
    return;

} // end IdePortCompletionDpc()

#ifdef IDEDEBUG_TEST_START_STOP_DEVICE

typedef enum {

    IdeDebugStartStop_Idle=0,
    IdeDebugStartStop_StopPending,
    IdeDebugStartStop_Stopped,
    IdeDebugStartStop_StartPending,
    IdeDebugStartStop_Started,
    IdeDebugStartStop_LastState
} IDEDEBUG_STARTSTOP_STATE;


PDEVICE_OBJECT IdeDebugStartStopDeviceObject=NULL;
IDEDEBUG_STARTSTOP_STATE IdeDebugStartStopState = IdeDebugStartStop_Idle;
IDEDEBUG_STARTSTOP_STATE IdeDebugStartStopTimer = 0;

PDEVICE_OBJECT
IoGetAttachedDevice(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
IdeDebugSynchronousCallCompletionRoutine(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN OUT PIRP            Irp,
    IN OUT PVOID           Context
    )
{
    PKEVENT event = Context;

    *(Irp->UserIosb) = Irp->IoStatus;

    KeSetEvent( event, IO_NO_INCREMENT, FALSE );

    IoFreeIrp (Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
IdeDebugSynchronousCall(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_STACK_LOCATION TopStackLocation
    )

/*++

Routine Description:

    This function sends a synchronous irp to the top level device
    object which roots on DeviceObject.

Parameters:

    DeviceObject - Supplies the device object of the device being removed.

    TopStackLocation - Supplies a pointer to the parameter block for the irp.

Return Value:

    NTSTATUS code.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpSp;
    IO_STATUS_BLOCK statusBlock;
    KEVENT event;
    NTSTATUS status;
    PDEVICE_OBJECT deviceObject;

    PAGED_CODE();

    //
    // Get a pointer to the topmost device object in the stack of devices,
    // beginning with the deviceObject.
    //

    deviceObject = IoGetAttachedDevice(DeviceObject);

    //
    // Begin by allocating the IRP for this request.  Do not charge quota to
    // the current process for this IRP.
    //

    irp = IoAllocateIrp(deviceObject->StackSize, FALSE);
    if (irp == NULL){

        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize it to failure.
    //

    irp->IoStatus.Status = statusBlock.Status = STATUS_NOT_SUPPORTED;
    irp->IoStatus.Information = statusBlock.Information = 0;

    irp->UserIosb = &statusBlock;

    //
    // Set the pointer to the status block and initialized event.
    //

    KeInitializeEvent( &event,
                       SynchronizationEvent,
                       FALSE );

    //
    // Set the address of the current thread
    //

    irp->Tail.Overlay.Thread = PsGetCurrentThread();

    //
    // Get a pointer to the stack location of the first driver which will be
    // invoked.  This is where the function codes and parameters are set.
    //

    irpSp = IoGetNextIrpStackLocation(irp);


    //
    // Copy in the caller-supplied stack location contents
    //

    *irpSp = *TopStackLocation;

    IoSetCompletionRoutine(
        irp,
        IdeDebugSynchronousCallCompletionRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Call the driver
    //

    status = IoCallDriver(DeviceObject, irp);

    //
    // If a driver returns STATUS_PENDING, we will wait for it to complete
    //

    if (status == STATUS_PENDING) {
        (VOID) KeWaitForSingleObject( &event,
                                      Executive,
                                      KernelMode,
                                      FALSE,
                                      (PLARGE_INTEGER) NULL );
        status = statusBlock.Status;
    }

    return status;
}

NTSTATUS
IdeDebugStartStopWorkRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIO_WORKITEM WorkItem
    )
{
    NTSTATUS status;
    IO_STACK_LOCATION irpSp;
    PVOID dummy;

    RtlZeroMemory(&irpSp, sizeof(IO_STACK_LOCATION));
    irpSp.MajorFunction = IRP_MJ_PNP;

    //
    // release resource for this worker item
    //
    IoFreeWorkItem(WorkItem);

    if (IdeDebugStartStopDeviceObject) {

        if (IdeDebugStartStopState == IdeDebugStartStop_StopPending) {

            irpSp.MinorFunction = IRP_MN_STOP_DEVICE;

            status = IdeDebugSynchronousCall(DeviceObject, &irpSp);
            if (!NT_SUCCESS(status)) {
                DbgBreakPoint();
            }

            IdeDebugStartStopTimer = 0;
            IdeDebugStartStopState = IdeDebugStartStop_Stopped;

        } else if (IdeDebugStartStopState == IdeDebugStartStop_StartPending) {

            // this will only work with legacy ide channels enmerated by pciidex.sys

            irpSp.MinorFunction = IRP_MN_START_DEVICE;

            status =IdeDebugSynchronousCall(DeviceObject, &irpSp);
            if (!NT_SUCCESS(status)) {
                DbgBreakPoint();
            }

            IdeDebugStartStopTimer = 0;
            IdeDebugStartStopState = IdeDebugStartStop_Started;

        } else {

            DbgBreakPoint();
        }
    }

    return STATUS_SUCCESS;
}

#endif //IDEDEBUG_TEST_START_STOP_DEVICE


#ifdef DPC_FOR_EMPTY_CHANNEL
BOOLEAN
IdeCheckEmptyChannel(
    IN PVOID ServiceContext
    )
{
    ULONG status;
    PSCSI_REQUEST_BLOCK Srb;
    PDEVICE_OBJECT deviceObject = ServiceContext;
    PFDO_EXTENSION deviceExtension =  deviceObject->DeviceExtension;
    PHW_DEVICE_EXTENSION hwDeviceExtension = deviceExtension->HwDeviceExtension;

    if ((status=IdePortChannelEmptyQuick(&hwDeviceExtension->BaseIoAddress1, &hwDeviceExtension->BaseIoAddress2,
                   hwDeviceExtension->MaxIdeDevice, &hwDeviceExtension->CurrentIdeDevice,
                        &hwDeviceExtension->MoreWait, &hwDeviceExtension->NoRetry))!= STATUS_RETRY) {

        //
        // Clear current SRB.
        //
        Srb=hwDeviceExtension->CurrentSrb;

        hwDeviceExtension->CurrentSrb = NULL;

        //
        // Set status in SRB.
        //
        if (status == 1) {
            Srb->SrbStatus = (UCHAR) SRB_STATUS_SUCCESS;
        } else {
            Srb->SrbStatus = (UCHAR) SRB_STATUS_ERROR;
        }


        //
        // Clear all the variables
        //
        hwDeviceExtension->MoreWait=0;
        hwDeviceExtension->CurrentIdeDevice=0;
        hwDeviceExtension->NoRetry=0;

        //
        // Indicate command complete.
        //

        IdePortNotification(IdeRequestComplete,
                            hwDeviceExtension,
                            Srb);

        //
        // Indicate ready for next request.
        //

        IdePortNotification(IdeNextRequest,
                            hwDeviceExtension,
                            NULL);

        IoRequestDpc(deviceObject, NULL, NULL);
        return TRUE;
    }
    return FALSE;

}
#endif

VOID
IdePortTickHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    )

/*++

Routine Description:

Arguments:

Return Value:

    None.

--*/

{
    PFDO_EXTENSION deviceExtension =
        (PFDO_EXTENSION) DeviceObject->DeviceExtension;
    PLOGICAL_UNIT_EXTENSION logicalUnit;

    ULONG target;
    IDE_PATH_ID pathId;


    UNREFERENCED_PARAMETER(Context);

#if DBG
    if (IdeDebugRescanBusFreq) {

        IdeDebugRescanBusCounter++;

        if (IdeDebugRescanBusCounter == IdeDebugRescanBusFreq) {

            IoInvalidateDeviceRelations (
                deviceExtension->AttacheePdo,
                BusRelations
                );

            IdeDebugRescanBusCounter = 0;
        }
    }
#endif //DBG

#ifdef IDEDEBUG_TEST_START_STOP_DEVICE

    if (deviceExtension->LogicalUnitList[0] &&
        (IdeDebugStartStopDeviceObject == deviceExtension->LogicalUnitList[0]->DeviceObject)) {

        PIO_WORKITEM workItem;

        if (IdeDebugStartStopState == IdeDebugStartStop_Idle) {

            IdeDebugStartStopState = IdeDebugStartStop_StopPending;

            workItem = IoAllocateWorkItem(IdeDebugStartStopDeviceObject);

            IoQueueWorkItem(
                workItem,
                IdeDebugStartStopWorkRoutine,
                DelayedWorkQueue,
                workItem
                );

        } else if (IdeDebugStartStopState == IdeDebugStartStop_Stopped) {

            if (IdeDebugStartStopTimer > 5) {

                IdeDebugStartStopState = IdeDebugStartStop_StartPending;

                workItem = IoAllocateWorkItem(IdeDebugStartStopDeviceObject);

                IoQueueWorkItem(
                    workItem,
                    IdeDebugStartStopWorkRoutine,
                    HyperCriticalWorkQueue,
                    workItem
                    );
            } else {

                IdeDebugStartStopTimer++;
            }

        } else if (IdeDebugStartStopState == IdeDebugStartStop_Started) {

            if (IdeDebugStartStopTimer > 10) {

                IdeDebugStartStopState = IdeDebugStartStop_Idle;

            } else {

                IdeDebugStartStopTimer++;
            }
        }
    }

#endif // IDEDEBUG_TEST_START_STOP_DEVICE

    //
    // Acquire the spinlock to protect the flags structure.
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

#ifdef DPC_FOR_EMPTY_CHANNEL

    //
    //Holding the lock is OK.
    //The empty channel check is quick
    //
    if (deviceExtension->HwDeviceExtension->MoreWait) {
        if (!KeSynchronizeExecution (
            deviceExtension->InterruptObject,
            IdeCheckEmptyChannel,
            DeviceObject
            )) {
            DebugPrint((0,"ATAPI: ChannelEmpty check- device busy after 1sec\n"));
        }

        KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

        return;
    }
#endif
    //
    // Check for port timeouts.
    //

    if (deviceExtension->ResetCallAgain) {

        RESET_CONTEXT resetContext;

        //
        // Request timed out.
        //
        resetContext.DeviceExtension = deviceExtension;
        resetContext.PathId = 0;
        resetContext.NewResetSequence = FALSE;
        resetContext.ResetSrb = NULL;

        if (!KeSynchronizeExecution(deviceExtension->InterruptObject,
                                    IdeResetBusSynchronized,
                                    &resetContext)) {

            DebugPrint((0,"IdePortTickHanlder: Reset failed\n"));
        }

        KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

        return;

    } 

    if (deviceExtension->PortTimeoutCounter > 0) {

        if (--deviceExtension->PortTimeoutCounter == 0) {

            //
            // Process the port timeout.
            //
            if (deviceExtension->InterruptObject) {

                if (KeSynchronizeExecution(deviceExtension->InterruptObject,
                                           IdeTimeoutSynchronized,
                                           deviceExtension->DeviceObject)){

                    //
                    // Log error if IdeTimeoutSynchonized indicates this was an error
                    // timeout.
                    //

                    if (deviceExtension->DeviceObject->CurrentIrp) {
                        IdeLogTimeoutError(deviceExtension,
                                           deviceExtension->DeviceObject->CurrentIrp,
                                           256);
                    }
                }

            } else {

                PIRP irp = deviceExtension->DeviceObject->CurrentIrp;

                DebugPrint((0,
                            "The device was suprise removed with an active request\n"
                            ));

                //
                // the device was probably surprise removed. Complete
                // the request with status_no_such_device
                //
                if (irp) {

                    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(irp);
                    PSCSI_REQUEST_BLOCK srb = irpStack->Parameters.Scsi.Srb;

                    srb->SrbStatus = SRB_STATUS_NO_DEVICE;
                    irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;

                    UnrefLogicalUnitExtensionWithTag (
                        deviceExtension,
                        IDEPORT_GET_LUNEXT_IN_IRP(irpStack),
                        irp
                        );

                    IoCompleteRequest(irp, IO_NO_INCREMENT);
                   
                }
            }

        }

        //
        // check for busy Luns and restart its request
        //
        pathId.l = 0;
        while (logicalUnit = NextLogUnitExtensionWithTag(
                                 deviceExtension,
                                 &pathId,
                                 TRUE,
                                 IdePortTickHandler
                                 )) {

                AtapiRestartBusyRequest(deviceExtension, logicalUnit);

                UnrefLogicalUnitExtensionWithTag (
                    deviceExtension,
                    logicalUnit,
                    IdePortTickHandler
                    );
            }


        KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

        //
        // Since a port timeout has been done.  Skip the rest of the
        // processing.
        //

        return;
    }

    //
    // Scan each of the logical units.  If it has an active request then
    // decrement the timeout value and process a timeout if it is zero.
    //

    pathId.l = 0;
    while (logicalUnit = NextLogUnitExtensionWithTag(
                             deviceExtension,
                             &pathId,
                             TRUE,
                             IdePortTickHandler
                             )) {

        //
        // Check for busy requests.
        //

        if (AtapiRestartBusyRequest (deviceExtension, logicalUnit)) {

            //
            // this lun was marked busy
            // skip all other checks
            //

        } else if (logicalUnit->RequestTimeoutCounter == 0) {

            RESET_CONTEXT resetContext;

            //
            // Request timed out.
            //
            logicalUnit->RequestTimeoutCounter = PD_TIMER_STOPPED;

            DebugPrint((1,"IdePortTickHandler: Request timed out\n"));

            resetContext.DeviceExtension = deviceExtension;
            resetContext.PathId = logicalUnit->PathId;
            resetContext.NewResetSequence = TRUE;
            resetContext.ResetSrb = NULL;

            if (deviceExtension->InterruptObject) {

                if (!KeSynchronizeExecution(deviceExtension->InterruptObject,
                                            IdeResetBusSynchronized,
                                            &resetContext)) {

                    DebugPrint((1,"IdePortTickHanlder: Reset failed\n"));
                } else {

                    //
                    // Log the reset.
                    //
                    IdeLogResetError( deviceExtension,
                                     logicalUnit->SrbData.CurrentSrb,
                                     ('P'<<24) | 257);
                }
            }

        } else if (logicalUnit->RequestTimeoutCounter > 0) {

            //
            // Decrement timeout count.
            //

            logicalUnit->RequestTimeoutCounter--;

        }

        UnrefLogicalUnitExtensionWithTag (
            deviceExtension,
            logicalUnit,
            IdePortTickHandler
            );
    }

    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

    return;

} // end IdePortTickHandler()


BOOLEAN
AtapiRestartBusyRequest (
    PFDO_EXTENSION DeviceExtension,
    PPDO_EXTENSION LogicalUnit
    )
{
    PIRP irp;
    PIO_STACK_LOCATION irpStack; 
    PSCSI_REQUEST_BLOCK srb;


    //
    // Check for busy requests.
    //

    if (LogicalUnit->LuFlags & PD_LOGICAL_UNIT_IS_BUSY) {

        //
        // If a request sense is needed or the queue is
        // frozen, defer processing this busy request until
        // that special processing has completed. This prevents
        // a random busy request from being started when a REQUEST
        // SENSE needs to be sent.
        //

        if (!(LogicalUnit->LuFlags &
            (PD_NEED_REQUEST_SENSE | PD_QUEUE_FROZEN))) {

            DebugPrint((1,"IdePortTickHandler: Retrying busy status request\n"));

            //
            // Clear the busy flag and retry the request. Release the
            // spinlock while the call to IoStartPacket is made.
            //

            CLRMASK (LogicalUnit->LuFlags, PD_LOGICAL_UNIT_IS_BUSY | PD_QUEUE_IS_FULL);
            irp = LogicalUnit->BusyRequest;

            //
            // Clear the busy request.
            //

            LogicalUnit->BusyRequest = NULL;

            //
            // check if the device is gone
            //
            if (LogicalUnit->PdoState & (PDOS_SURPRISE_REMOVED | PDOS_REMOVED)) {

                irpStack = IoGetCurrentIrpStackLocation(irp);

                srb = irpStack->Parameters.Scsi.Srb;

                srb->SrbStatus = SRB_STATUS_NO_DEVICE;
                irp->IoStatus.Status = STATUS_NO_SUCH_DEVICE;

                //
                // Decrement the logUnitExtension reference count
                //
                UnrefLogicalUnitExtensionWithTag(
                    DeviceExtension,
                    LogicalUnit,
                    irp
                    );

                IoCompleteRequest(irp, IO_NO_INCREMENT);

                return TRUE;

            } 

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            IoStartPacket(DeviceExtension->DeviceObject, irp, (PULONG)NULL, NULL);

            KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);
        }

        return TRUE;

    }  else {

        return FALSE;
    }
}




NTSTATUS
IdePortDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )

/*++

Routine Description:

    This routine is the device control dispatcher.

Arguments:

    DeviceObject
    Irp

Return Value:


    NTSTATUS

--*/

{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    PFDO_EXTENSION deviceExtension = DeviceObject->DeviceExtension;
    UCHAR scsiBus;
    NTSTATUS status;
    ULONG j;


    //
    // Initialize the information field.
    //

    Irp->IoStatus.Information = 0;

    switch (irpStack->Parameters.DeviceIoControl.IoControlCode) {

    //
    // Get adapter capabilities.
    //

    case IOCTL_SCSI_GET_CAPABILITIES:


        if (irpStack->Parameters.DeviceIoControl.OutputBufferLength
            < sizeof(IO_SCSI_CAPABILITIES)) {

            status = STATUS_BUFFER_TOO_SMALL;
            break;
        }

        //
        // this is dynamic
        //
        deviceExtension->Capabilities.AdapterUsesPio = FALSE;
        for (j=0; j<deviceExtension->HwDeviceExtension->MaxIdeDevice; j++) {

            deviceExtension->Capabilities.AdapterUsesPio |=
                !(deviceExtension->HwDeviceExtension->DeviceFlags[j] & DFLAGS_USE_DMA);
        }

        RtlCopyMemory(Irp->AssociatedIrp.SystemBuffer,
                      &deviceExtension->Capabilities,
                      sizeof(IO_SCSI_CAPABILITIES));

        Irp->IoStatus.Information = sizeof(IO_SCSI_CAPABILITIES);
        status = STATUS_SUCCESS;
        break;

    case IOCTL_SCSI_PASS_THROUGH:

        status = IdeSendScsiPassThrough(deviceExtension, Irp, FALSE);
        break;

    case IOCTL_SCSI_PASS_THROUGH_DIRECT:

        status = IdeSendScsiPassThrough(deviceExtension, Irp, TRUE);
        break;

    case IOCTL_SCSI_MINIPORT:

        status = IdeSendMiniPortIoctl( deviceExtension, Irp);
        break;

    case IOCTL_SCSI_GET_INQUIRY_DATA:

        status = IdeGetInquiryData(deviceExtension, Irp);
        break;

    case IOCTL_SCSI_RESCAN_BUS:

        //
        // should return only after we get the device relation irp
        // this will be fixed if needed.
        //
        IoInvalidateDeviceRelations (
            deviceExtension->AttacheePdo,
            BusRelations
            );

        status = STATUS_SUCCESS;
        break;

    default:
        return ChannelDeviceIoControl (DeviceObject, Irp);
        break;

    } // end switch

    //
    // Set status in Irp.
    //
    Irp->IoStatus.Status = status;

    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;

} // end IdePortDeviceControl()


BOOLEAN
IdeStartIoSynchronized (
    PVOID ServiceContext
    )

/*++

Routine Description:

    This routine calls the dependent driver start io routine.
    It also starts the request timer for the logical unit if necesary and
    inserts the SRB data structure in to the requset list.

Arguments:

    ServiceContext - Supplies the pointer to the device object.

Return Value:

    Returns the value returned by the dependent start I/O routine.

Notes:

    The port driver spinlock must be held when this routine is called.

--*/

{
    PDEVICE_OBJECT deviceObject = ServiceContext;
    PFDO_EXTENSION deviceExtension =  deviceObject->DeviceExtension;
    PIO_STACK_LOCATION irpStack;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSCSI_REQUEST_BLOCK srb;
    PSRB_DATA srbData;
    BOOLEAN timerStarted;
    BOOLEAN returnValue;
    BOOLEAN resetRequest;

    DebugPrint((3, "IdePortStartIoSynchronized: Enter routine\n"));

    irpStack = IoGetCurrentIrpStackLocation(deviceObject->CurrentIrp);
    srb = irpStack->Parameters.Scsi.Srb;


    //
    // Get the logical unit extension.
    //

    logicalUnit = IDEPORT_GET_LUNEXT_IN_IRP (irpStack);

    //
    // Check for a reset hold.  If one is in progress then flag it and return.
    // The timer will reset the current request.  This check should be made
    // before anything else is done.
    //

    if (deviceExtension->InterruptData.InterruptFlags & PD_RESET_HOLD) {

        DebugPrint ((1, "IdeStartIoSynchronized: PD_RESET_HOLD set...request is held for later..\n"));

        deviceExtension->InterruptData.InterruptFlags |= PD_HELD_REQUEST;
        return(TRUE);
    }

    if ((((srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH) ||
          (srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH)) &&
         (((PATA_PASS_THROUGH) (srb->DataBuffer))->IdeReg.bReserved & ATA_PTFLAGS_BUS_RESET))) {

        resetRequest = TRUE;

    } else {

        resetRequest = FALSE;
    }

    //
    // Start the port timer.  This ensures that the miniport asks for
    // the next request in a resonable amount of time.  Set the device
    // busy flag to indicate it is ok to start the next request.
    //

    deviceExtension->PortTimeoutCounter = srb->TimeOutValue;
    deviceExtension->Flags |= PD_DEVICE_IS_BUSY;

    //
    // Start the logical unit timer if it is not currently running.
    //

    if (logicalUnit->RequestTimeoutCounter == PD_TIMER_STOPPED) {

        //
        // Set request timeout value from Srb SCSI extension in Irp.
        //

        logicalUnit->RequestTimeoutCounter = srb->TimeOutValue;
        timerStarted = TRUE;

    } else {
        timerStarted = FALSE;
    }

    //
    // Indicate that there maybe more requests queued, if this is not a bypass
    // request.
    //

    if (!(srb->SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE)) {

        if (srb->SrbFlags & SRB_FLAGS_DISABLE_DISCONNECT) {

            //
            // This request does not allow disconnects. Remember that so
            // no more requests are started until this one completes.
            //

            CLRMASK (deviceExtension->Flags, PD_DISCONNECT_RUNNING);
        }

        logicalUnit->LuFlags |= PD_LOGICAL_UNIT_IS_ACTIVE;

    } else {

        //
        // If this is an abort request make sure that it still looks valid.
        //

        if (srb->Function == SRB_FUNCTION_ABORT_COMMAND) {

            srbData = IdeGetSrbData(deviceExtension, srb);

            //
            // Make sure the srb request is still active.
            //

            if (srbData == NULL || srbData->CurrentSrb == NULL
                || !(srbData->CurrentSrb->SrbFlags & SRB_FLAGS_IS_ACTIVE)) {

                //
                // Mark the Srb as active.
                //

                srb->SrbFlags |= SRB_FLAGS_IS_ACTIVE;

                if (timerStarted) {
                    logicalUnit->RequestTimeoutCounter = PD_TIMER_STOPPED;
                }

                //
                // The request is gone.
                //

                DebugPrint((1, "IdePortStartIO: Request completed be for it was aborted.\n"));
                srb->SrbStatus = SRB_STATUS_ABORT_FAILED;
                IdePortNotification(IdeRequestComplete,
                                    deviceExtension + 1,
                                    srb);

                IdePortNotification(IdeNextRequest,
                                    deviceExtension + 1);

                //
                // Queue a DPC to process the work that was just indicated.
                //

                IoRequestDpc(deviceExtension->DeviceObject, NULL, NULL);

                return(TRUE);
            }

        } 

        //
        // Any untagged request that bypasses the queue
        // clears the need request sense flag.
        //

        CLRMASK (logicalUnit->LuFlags, PD_NEED_REQUEST_SENSE);

        if (srb->SrbFlags & SRB_FLAGS_DISABLE_DISCONNECT) {

            //
            // This request does not allow disconnects. Remember that so
            // no more requests are started until this one completes.
            //

            CLRMASK (deviceExtension->Flags, PD_DISCONNECT_RUNNING);
        }

        //
        // Set the timeout value in the logical unit.
        //

        logicalUnit->RequestTimeoutCounter = srb->TimeOutValue;
    }

    //
    // Mark the Srb as active.
    //

    srb->SrbFlags |= SRB_FLAGS_IS_ACTIVE;


#if 0
    //joedai
    {
        ULONG c;
        PUCHAR s;
        PUCHAR d;

        s = (PUCHAR) deviceObject->CurrentIrp;
        d = (PUCHAR) &deviceExtension->debugData[deviceExtension->nextEntry].irp;
        deviceExtension->debugDataPtr[deviceExtension->nextEntry].irp = (PIRP) d;
        for (c=0; c<sizeof(IRP); c++) {
            d[c] = s[c];
        }

        if (deviceObject->CurrentIrp->MdlAddress) {
            s = (PUCHAR) deviceObject->CurrentIrp->MdlAddress;
            d = (PUCHAR) &deviceExtension->debugData[deviceExtension->nextEntry].mdl;
            deviceExtension->debugDataPtr[deviceExtension->nextEntry].mdl = (PMDL) d;
            for (c=0; c<sizeof(MDL); c++) {
                d[c] = s[c];
            }
        } else {
            d = (PUCHAR) &deviceExtension->debugData[deviceExtension->nextEntry].mdl;
            deviceExtension->debugDataPtr[deviceExtension->nextEntry].mdl = (PMDL) d;
            for (c=0; c<sizeof(MDL); c++) {
                d[c] = 0;
            }
        }
        s = (PUCHAR) srb;
        d = (PUCHAR) &deviceExtension->debugData[deviceExtension->nextEntry].srb;
        deviceExtension->debugDataPtr[deviceExtension->nextEntry].srb = (PSCSI_REQUEST_BLOCK) d;
        for (c=0; c<sizeof(SCSI_REQUEST_BLOCK); c++) {
            d[c] = s[c];
        }
        ASSERT((((ULONG)srb->DataBuffer) & 0x80000000));

        deviceExtension->nextEntry = (deviceExtension->nextEntry + 1) % NUM_DEBUG_ENTRY;
    }
#endif

    //
    // maybe the device is gone
    //
    if (logicalUnit->PdoState & PDOS_DEADMEAT) {

        srb->SrbStatus = SRB_STATUS_NO_DEVICE;
        IdePortNotification(IdeRequestComplete,
                            deviceExtension + 1,
                            srb);

        IdePortNotification(IdeNextRequest,
                            deviceExtension + 1);

        IoRequestDpc(deviceExtension->DeviceObject, NULL, NULL);

        return TRUE;
    }

    if (resetRequest) {

        RESET_CONTEXT resetContext;

        resetContext.DeviceExtension = deviceExtension;
        resetContext.PathId = 0;
        resetContext.NewResetSequence = TRUE;
        resetContext.ResetSrb = srb;

        srb->SrbStatus = SRB_STATUS_PENDING;

        returnValue = IdeResetBusSynchronized (&resetContext);

    } else {

       returnValue = AtapiStartIo (deviceExtension->HwDeviceExtension,
                                   srb);
    }

    //
    // Check for miniport work requests.
    //

    if (deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

        IoRequestDpc(deviceExtension->DeviceObject, NULL, NULL);
    }

    return returnValue;

} // end IdeStartIoSynchronized()

BOOLEAN
IdeTimeoutSynchronized (
    PVOID ServiceContext
    )

/*++

Routine Description:

    This routine handles a port timeout.  There are two reason these can occur
    either because of a reset hold or a time out waiting for a read for next
    request notification.  If a reset hold completes, then any held request
    must be started.  If a timeout occurs, then the bus must be reset.

Arguments:

    ServiceContext - Supplies the pointer to the device object.

Return Value:

    TRUE - If a timeout error should be logged.

Notes:

    The port driver spinlock must be held when this routine is called.

--*/

{
    PDEVICE_OBJECT deviceObject = ServiceContext;
    PFDO_EXTENSION deviceExtension =  deviceObject->DeviceExtension;
    ULONG i;
    BOOLEAN enumProbing = FALSE;
    BOOLEAN noErrorLog = FALSE;

    DebugPrint((3, "IdeTimeoutSynchronized: Enter routine\n"));

    //
    // Make sure the timer is stopped.
    //

    deviceExtension->PortTimeoutCounter = PD_TIMER_STOPPED;

    //
    // Check for a reset hold.  If one is in progress then clear it and check
    // for a pending held request
    //

    if (deviceExtension->InterruptData.InterruptFlags & PD_RESET_HOLD) {

        CLRMASK (deviceExtension->InterruptData.InterruptFlags, PD_RESET_HOLD);

        if (deviceExtension->InterruptData.InterruptFlags & PD_HELD_REQUEST) {

            //
            // Clear the held request flag and restart the request.
            //

            CLRMASK (deviceExtension->InterruptData.InterruptFlags, PD_HELD_REQUEST);
            IdeStartIoSynchronized(ServiceContext);

        }

        return(FALSE);

    } else {

        //
        // Miniport is hung and not accepting new requests. So reset the
        // bus to clear things up.
        //

        if (deviceExtension->HwDeviceExtension->CurrentSrb) {

            deviceExtension->HwDeviceExtension->TimeoutCount[
                        deviceExtension->HwDeviceExtension->CurrentSrb->TargetId
                        ]++;

            //
            // Many harddrives fail to respond to the first DMA operation
            // We then reset the device and subsequently everything works fine
            // The hack is to mask this error from being logged in the system logs
            //

            if (deviceExtension->HwDeviceExtension->TimeoutCount[
                        deviceExtension->HwDeviceExtension->CurrentSrb->TargetId
                        ] == 1) {
                noErrorLog=TRUE;
            }

            enumProbing = TestForEnumProbing (deviceExtension->HwDeviceExtension->CurrentSrb);
        }

        if (!enumProbing) {

            DebugPrint((0,
                        "IdeTimeoutSynchronized: DevObj 0x%x Next request timed out. Resetting bus..currentSrb=0x%x\n",
                        deviceObject,
                        deviceExtension->HwDeviceExtension->CurrentSrb));
        }

        ASSERT (deviceExtension->ResetSrb == 0);
        deviceExtension->ResetSrb = NULL;
        deviceExtension->ResetCallAgain = 0;
        AtapiResetController (deviceExtension->HwDeviceExtension,
                              0,
                              &deviceExtension->ResetCallAgain);

        //
        // Set the reset hold flag and start the counter.
        // if we are doing enumertion, don't set the flag
        //  we shouldn't set the flag if ResetCallAgain is not set
        //
        if (!enumProbing &&
			(deviceExtension->ResetCallAgain))  {

            ASSERT(deviceExtension->ResetCallAgain);

            deviceExtension->InterruptData.InterruptFlags |= PD_RESET_HOLD;
            deviceExtension->PortTimeoutCounter = PD_TIMER_RESET_HOLD_TIME;

        } else {

            ASSERT(deviceExtension->ResetCallAgain == 0);

        }

        //
        // Check for miniport work requests.
        //

        if (deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

            IoRequestDpc(deviceExtension->DeviceObject, NULL, NULL);
        }
    }

    if (enumProbing || noErrorLog) {

        return(FALSE);
    } else {

        return(TRUE);
    }

} // end IdeTimeoutSynchronized()

NTSTATUS
FASTCALL
IdeBuildAndSendIrp (
    IN PPDO_EXTENSION PdoExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID CompletionContext
    )
{

    LARGE_INTEGER largeInt;
    NTSTATUS status = STATUS_PENDING;
    PIRP irp;
    PIO_STACK_LOCATION  irpStack;

    //
    // why?
    //
    largeInt.QuadPart = (LONGLONG) 1;

    //
    // Build IRP for this request.
    //
    irp = IoBuildAsynchronousFsdRequest(IRP_MJ_READ,
                                       PdoExtension->DeviceObject,
                                       Srb->DataBuffer,
                                       Srb->DataTransferLength,
                                       &largeInt,
                                       NULL);

    if (irp == NULL) {

        IdeLogNoMemoryError(PdoExtension->ParentDeviceExtension,
                            PdoExtension->TargetId, 
                            NonPagedPool,
                            IoSizeOfIrp(PdoExtension->DeviceObject->StackSize),
                            IDEPORT_TAG_SEND_IRP
                            );

        status = STATUS_INSUFFICIENT_RESOURCES;

        goto GetOut;
    }

    IoSetCompletionRoutine(irp,
                           (PIO_COMPLETION_ROUTINE)CompletionRoutine,
                           CompletionContext,
                           TRUE,
                           TRUE,
                           TRUE);

    irpStack = IoGetNextIrpStackLocation(irp);

    irpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Save SRB address in next stack for port driver.
    //
    irpStack->Parameters.Scsi.Srb = Srb;

    //
    // put the irp in the original request field
    //
    Srb->OriginalRequest = irp;

    (VOID)IoCallDriver(PdoExtension->DeviceObject, irp);

    status = STATUS_PENDING;
    
GetOut:
    
    return status;

}

VOID
FASTCALL
IdeFreeIrpAndMdl(
    IN PIRP Irp
    )
{
    ASSERT(Irp);

    if (Irp->MdlAddress != NULL) {
        MmUnlockPages(Irp->MdlAddress);
        IoFreeMdl(Irp->MdlAddress);

        Irp->MdlAddress = NULL;
    }

    IoFreeIrp(Irp);

    return;
}


VOID
IssueRequestSense(
    IN PPDO_EXTENSION PdoExtension,
    IN PSCSI_REQUEST_BLOCK FailingSrb
    )

/*++

Routine Description:

    This routine creates a REQUEST SENSE request and uses IoCallDriver to
    renter the driver.  The completion routine cleans up the data structures
    and processes the logical unit queue according to the flags.

    A pointer to failing SRB is stored at the end of the request sense
    Srb, so that the completion routine can find it.

Arguments:

    DeviceExension - Supplies a pointer to the pdo device extension

    FailingSrb - Supplies a pointer to the request that the request sense
        is being done for.

Return Value:

    None.

--*/

{
    PIO_STACK_LOCATION irpStack;
    PIRP irp;
    PSCSI_REQUEST_BLOCK srb;
    PCDB                cdb;
    PVOID              *pointer;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    KIRQL currentIrql;
    NTSTATUS status;

#if DBG
    PIO_STACK_LOCATION  failingIrpStack;
    PIRP                failingIrp;
    PLOGICAL_UNIT_EXTENSION failingLogicalUnit;
#endif

    DebugPrint((3,"IssueRequestSense: Enter routine\n"));

    //
    // Build the asynchronous request
    // to be sent to the port driver.
    //
    // Allocate Srb from non-paged pool
    // plus room for a pointer to the failing IRP.
    // Note this routine is in an error-handling
    // path and is a shortterm allocation.
    //

    srb = ExAllocatePool(NonPagedPool,
                         sizeof(SCSI_REQUEST_BLOCK) + sizeof(PVOID));

    if (srb == NULL) {
        DebugPrint((1, "IssueRequest sense - pool allocation failed\n"));
        goto Getout;
    }

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    //
    // Save the Failing SRB after the request sense Srb.
    //

    pointer = (PVOID *) (srb+1);
    *pointer = FailingSrb;

    //
    // Build the REQUEST SENSE CDB.
    //

    srb->CdbLength = 6;
    cdb = (PCDB)srb->Cdb;

    cdb->CDB6INQUIRY.OperationCode = SCSIOP_REQUEST_SENSE;
    cdb->CDB6INQUIRY.LogicalUnitNumber = 0;
    cdb->CDB6INQUIRY.Reserved1 = 0;
    cdb->CDB6INQUIRY.PageCode = 0;
    cdb->CDB6INQUIRY.IReserved = 0;
    cdb->CDB6INQUIRY.AllocationLength =
        (UCHAR)FailingSrb->SenseInfoBufferLength;
    cdb->CDB6INQUIRY.Control = 0;



    //
    // Set up SCSI bus address.
    //

    srb->TargetId = FailingSrb->TargetId;
    srb->Lun = FailingSrb->Lun;
    srb->PathId = FailingSrb->PathId;

    srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
    srb->Length = sizeof(SCSI_REQUEST_BLOCK);

    //
    // Set timeout value to 16 seconds.
    //

    srb->TimeOutValue = 0x10;

    //
    // Disable auto request sense.
    //

    srb->SenseInfoBufferLength = 0;

    //
    // Sense buffer is in stack.
    //

    srb->SenseInfoBuffer = NULL;

    //
    // Set read and bypass frozen queue bits in flags.
    //

    //
    // Set SRB flags to indicate the logical unit queue should be by
    // passed and that no queue processing should be done when the request
    // completes.  Also disable disconnect and synchronous data
    // transfer if necessary.
    //

    srb->SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_BYPASS_FROZEN_QUEUE |
                    SRB_FLAGS_DISABLE_DISCONNECT;

    if (FailingSrb->SrbFlags & SRB_FLAGS_DISABLE_SYNCH_TRANSFER) {
        srb->SrbFlags |= SRB_FLAGS_DISABLE_SYNCH_TRANSFER;
    }

    srb->DataBuffer = FailingSrb->SenseInfoBuffer;

    //
    // Set the transfer length.
    //

    srb->DataTransferLength = FailingSrb->SenseInfoBufferLength;

    //
    // Zero out status.
    //

    srb->ScsiStatus = srb->SrbStatus = 0;

    srb->NextSrb = 0;

#if DBG
    //
    // This was added to catch a bug where the original request
    // was pointing to a pnp irp
    //
    ASSERT(FailingSrb->OriginalRequest);
    failingIrp  = FailingSrb->OriginalRequest;
    failingIrpStack    = IoGetCurrentIrpStackLocation(failingIrp);
    failingLogicalUnit = IDEPORT_GET_LUNEXT_IN_IRP (failingIrpStack);
    ASSERT(failingLogicalUnit);
#endif

    status = IdeBuildAndSendIrp(PdoExtension, 
                                srb, 
                                IdePortInternalCompletion, 
                                srb
                                );

    if (NT_SUCCESS(status)) {
        return;
    }

    ASSERT(status == STATUS_INSUFFICIENT_RESOURCES);

Getout:
        if (srb) {
            ExFreePool(srb);
        }

        irp  = FailingSrb->OriginalRequest;
        irpStack    = IoGetCurrentIrpStackLocation(irp);
        logicalUnit = IDEPORT_GET_LUNEXT_IN_IRP (irpStack);

        //
        // Clear the request sense flag. Since IdeStartIoSync will never get called, this
        // flag won't be cleared.
        //
        KeAcquireSpinLock(&logicalUnit->ParentDeviceExtension->SpinLock, &currentIrql);
        CLRMASK (logicalUnit->LuFlags, PD_NEED_REQUEST_SENSE);
        KeReleaseSpinLock(&logicalUnit->ParentDeviceExtension->SpinLock, currentIrql);

        //
        // unfreeze the queue if necessary
        //
        ASSERT(FailingSrb->SrbStatus & SRB_STATUS_QUEUE_FROZEN);
        if ((FailingSrb->SrbFlags & SRB_FLAGS_NO_QUEUE_FREEZE) &&
            (FailingSrb->SrbStatus & SRB_STATUS_QUEUE_FROZEN)) {


            CLRMASK (logicalUnit->LuFlags, PD_QUEUE_FROZEN);

            KeAcquireSpinLock(&logicalUnit->ParentDeviceExtension->SpinLock, &currentIrql);
            GetNextLuRequest(logicalUnit->ParentDeviceExtension, logicalUnit);
            KeLowerIrql(currentIrql);

            CLRMASK (FailingSrb->SrbStatus, SRB_STATUS_QUEUE_FROZEN);
        }

        //
        // Decrement the logUnitExtension reference count
        //
        UnrefLogicalUnitExtensionWithTag(
            IDEPORT_GET_LUNEXT_IN_IRP(irpStack)->ParentDeviceExtension,
            IDEPORT_GET_LUNEXT_IN_IRP(irpStack),
            irp
            );

        //
        // Complete the original request
        //
        IoCompleteRequest(irp, IO_DISK_INCREMENT);

        return;

} // end IssueRequestSense()


NTSTATUS
IdePortInternalCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )

/*++

Routine Description:

Arguments:

    Device object
    IRP
    Context - pointer to SRB

Return Value:

    NTSTATUS

--*/

{
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb = Context;
    PSCSI_REQUEST_BLOCK failingSrb;
    PIRP failingIrp;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSENSE_DATA     senseBuffer;
    PHW_DEVICE_EXTENSION hwDeviceExtension;
    KIRQL currentIrql;

    UNREFERENCED_PARAMETER(DeviceObject);

    DebugPrint((3,"IdePortInternalCompletion: Enter routine\n"));

    //
    // If RESET_BUS or ABORT_COMMAND request
    // then free pool and return.
    //

    if ((srb->Function == SRB_FUNCTION_ABORT_COMMAND) ||
        (srb->Function == SRB_FUNCTION_RESET_BUS)) {

        //
        // Deallocate internal SRB and IRP.
        //

        ExFreePool(srb);

        IoFreeIrp(Irp);

        return STATUS_MORE_PROCESSING_REQUIRED;

    }

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    //
    // Request sense completed. If successful or data over/underrun
    // get the failing SRB and indicate that the sense information
    // is valid. The class driver will check for underrun and determine
    // if there is enough sense information to be useful.
    //

    //
    // Get a pointer to failing Irp and Srb.
    //

    failingSrb  = *((PVOID *) (srb+1));
    failingIrp  = failingSrb->OriginalRequest;
    irpStack    = IoGetCurrentIrpStackLocation(failingIrp);
    logicalUnit = IDEPORT_GET_LUNEXT_IN_IRP (irpStack);


    if ((SRB_STATUS(srb->SrbStatus) == SRB_STATUS_SUCCESS) ||
        (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN)) {

        //
        // Report sense buffer is valid.
        //

        failingSrb->SrbStatus |= SRB_STATUS_AUTOSENSE_VALID;

        //
        // Copy bytes transferred to failing SRB
        // request sense length field to communicate
        // to the class drivers the number of valid
        // sense bytes.
        //

        failingSrb->SenseInfoBufferLength = (UCHAR) srb->DataTransferLength;

#if 0
        //
        // enable for debugging only
        // if sense buffer is smaller than 13 bytes, then the debugprint
        // below could bugchecl the system
        //

        //
        // Print the sense buffer for debugging purposes.
        //
        senseBuffer = failingSrb->SenseInfoBuffer;
        DebugPrint((DBG_ATAPI_DEVICES, "CDB=%x, SenseKey=%x, ASC=%x, ASQ=%x\n", 
                    failingSrb->Cdb[0],
                    senseBuffer->SenseKey, senseBuffer->AdditionalSenseCode,
                    senseBuffer->AdditionalSenseCodeQualifier));
#endif

    }

    // 
    // Clear the request sense flag. If we fail due to fault injection
    // IdeStartIo won't get called and this flag never gets cleared.
    //
    KeAcquireSpinLock(&logicalUnit->ParentDeviceExtension->SpinLock, &currentIrql);
    CLRMASK (logicalUnit->LuFlags, PD_NEED_REQUEST_SENSE);
    KeReleaseSpinLock(&logicalUnit->ParentDeviceExtension->SpinLock, currentIrql);

    //
    // unfreeze the queue if necessary
    //
    ASSERT(failingSrb->SrbStatus & SRB_STATUS_QUEUE_FROZEN);
    if ((failingSrb->SrbFlags & SRB_FLAGS_NO_QUEUE_FREEZE) &&
        (failingSrb->SrbStatus & SRB_STATUS_QUEUE_FROZEN)) {


        CLRMASK (logicalUnit->LuFlags, PD_QUEUE_FROZEN);

        KeAcquireSpinLock(&logicalUnit->ParentDeviceExtension->SpinLock, &currentIrql);
        GetNextLuRequest(logicalUnit->ParentDeviceExtension, logicalUnit);
        KeLowerIrql(currentIrql);

        CLRMASK (failingSrb->SrbStatus, SRB_STATUS_QUEUE_FROZEN);
    }

    //
    // Decrement the logUnitExtension reference count
    //
    UnrefLogicalUnitExtensionWithTag(
        IDEPORT_GET_LUNEXT_IN_IRP(irpStack)->ParentDeviceExtension,
        IDEPORT_GET_LUNEXT_IN_IRP(irpStack),
        failingIrp
        );

    //
    // Complete the failing request.
    //


    IoCompleteRequest(failingIrp, IO_DISK_INCREMENT);

    //
    // Deallocate internal SRB, MDL and IRP.
    //

    ExFreePool(srb);

    IdeFreeIrpAndMdl(Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;

} // IdePortInternalCompletion()


BOOLEAN
IdeGetInterruptState(
    IN PVOID ServiceContext
    )

/*++

Routine Description:

    This routine saves the InterruptFlags, MapTransferParameters and
    CompletedRequests fields and clears the InterruptFlags.

    This routine also removes the request from the logical unit queue if it is
    tag.  Finally the request time is updated.

Arguments:

    ServiceContext - Supplies a pointer to the interrupt context which contains
        pointers to the interrupt data and where to save it.

Return Value:

    Returns TURE if there is new work and FALSE otherwise.

Notes:

    Called via KeSynchronizeExecution with the port device extension spinlock
    held.

--*/
{
    PINTERRUPT_CONTEXT      interruptContext = ServiceContext;
    ULONG                   limit = 0;
    PFDO_EXTENSION       deviceExtension;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSCSI_REQUEST_BLOCK     srb;
    PSRB_DATA               srbData;
    PSRB_DATA               nextSrbData;
    BOOLEAN                 isTimed;

    deviceExtension = interruptContext->DeviceExtension;

    //
    // Check for pending work.
    //

    if (!(deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED)) {
        return(FALSE);
    }

    //
    // Move the interrupt state to save area.
    //

    *interruptContext->SavedInterruptData = deviceExtension->InterruptData;

    //
    // Clear the interrupt state.
    //

    deviceExtension->InterruptData.InterruptFlags &= PD_INTERRUPT_FLAG_MASK;
    deviceExtension->InterruptData.CompletedRequests = NULL;
    deviceExtension->InterruptData.ReadyLogicalUnit = NULL;
    deviceExtension->InterruptData.CompletedAbort = NULL;
    deviceExtension->InterruptData.PdoExtensionResetBus = NULL;

    srbData = interruptContext->SavedInterruptData->CompletedRequests;

    while (srbData != NULL) {

        PIRP                irp;
        PIO_STACK_LOCATION  irpStack;

        ASSERT(limit++ < 100);

        //
        // Get a pointer to the SRB and the logical unit extension.
        //

        ASSERT(srbData->CurrentSrb != NULL);
        srb = srbData->CurrentSrb;

        irp = srb->OriginalRequest;
        irpStack = IoGetCurrentIrpStackLocation(irp);
        logicalUnit = IDEPORT_GET_LUNEXT_IN_IRP (irpStack);

        //
        // If the request did not succeed, then check for the special cases.
        //

        if (srb->SrbStatus != SRB_STATUS_SUCCESS) {

            //
            // If this request failed and a REQUEST SENSE command needs to
            // be done, then set a flag to indicate this and prevent other
            // commands from being started.
            //

            if (NEED_REQUEST_SENSE(srb)) {

                if (logicalUnit->LuFlags & PD_NEED_REQUEST_SENSE) {

                    //
                    // This implies that requests have completed with a
                    // status of check condition before a REQUEST SENSE
                    // command could be preformed.  This should never occur.
                    // Convert the request to another code so that only one
                    // auto request sense is issued.
                    //

                    srb->ScsiStatus = 0;
                    srb->SrbStatus = SRB_STATUS_REQUEST_SENSE_FAILED;

                } else {

                    //
                    // Indicate that an auto request sense needs to be done.
                    //

                    logicalUnit->LuFlags |= PD_NEED_REQUEST_SENSE;
                }

            }

        }

        logicalUnit->RequestTimeoutCounter = PD_TIMER_STOPPED;
        srbData = srbData->CompletedRequests;
    }

    return(TRUE);
}

VOID
IdePortAllocateAccessToken (
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PFDO_EXTENSION   fdoExtension = DeviceObject->DeviceExtension;

    if (!fdoExtension->SyncAccessInterface.AllocateAccessToken) {

        CallIdeStartIoSynchronized (
            NULL,
            NULL,
            NULL,
            DeviceObject
            );

    } else {

        (*fdoExtension->SyncAccessInterface.AllocateAccessToken) (
            fdoExtension->SyncAccessInterface.Token,
            CallIdeStartIoSynchronized,
            DeviceObject
            );
    }
}


IO_ALLOCATION_ACTION
CallIdeStartIoSynchronized (
    IN PVOID Reserved1,
    IN PVOID Reserved2,
    IN PVOID Reserved3,
    IN PVOID DeviceObject
    )
{
    PFDO_EXTENSION   deviceExtension = ((PDEVICE_OBJECT) DeviceObject)->DeviceExtension;
    KIRQL               currentIrql;

    KeAcquireSpinLock(&deviceExtension->SpinLock, &currentIrql);

    KeSynchronizeExecution (
        deviceExtension->InterruptObject,
        IdeStartIoSynchronized,
        DeviceObject
        );

    KeReleaseSpinLock(&deviceExtension->SpinLock, currentIrql);

    return KeepObject;
}


VOID
LogErrorEntry(
    IN PFDO_EXTENSION DeviceExtension,
    IN PERROR_LOG_ENTRY LogEntry
    )
/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.

Arguments:

    DeviceExtension - Supplies a pointer to the port device extension.

    LogEntry - Supplies a pointer to the scsi port log entry.

Return Value:

    None.

--*/
{
    PIO_ERROR_LOG_PACKET errorLogEntry;

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(
        DeviceExtension->DeviceObject,
        sizeof(IO_ERROR_LOG_PACKET) + 4 * sizeof(ULONG)
        );

    if (errorLogEntry != NULL) {

        //
        // Translate the miniport error code into the NT I\O driver.
        //

        switch (LogEntry->ErrorCode) {
        case SP_BUS_PARITY_ERROR:
            errorLogEntry->ErrorCode = IO_ERR_PARITY;
            break;

        case SP_UNEXPECTED_DISCONNECT:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        case SP_INVALID_RESELECTION:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        case SP_BUS_TIME_OUT:
            errorLogEntry->ErrorCode = IO_ERR_TIMEOUT;
            break;

        case SP_PROTOCOL_ERROR:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        case SP_INTERNAL_ADAPTER_ERROR:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        case SP_IRQ_NOT_RESPONDING:
            errorLogEntry->ErrorCode = IO_ERR_INCORRECT_IRQL;
            break;

        case SP_BAD_FW_ERROR:
            errorLogEntry->ErrorCode = IO_ERR_BAD_FIRMWARE;
            break;

        case SP_BAD_FW_WARNING:
            errorLogEntry->ErrorCode = IO_WRN_BAD_FIRMWARE;
            break;

        default:
            errorLogEntry->ErrorCode = IO_ERR_CONTROLLER_ERROR;
            break;

        }

        errorLogEntry->SequenceNumber = LogEntry->SequenceNumber;
        errorLogEntry->MajorFunctionCode = IRP_MJ_SCSI;
        errorLogEntry->RetryCount = (UCHAR) LogEntry->ErrorLogRetryCount;
        errorLogEntry->UniqueErrorValue = LogEntry->UniqueId;
        errorLogEntry->FinalStatus = STATUS_SUCCESS;
        errorLogEntry->DumpDataSize = 4 * sizeof(ULONG);
        errorLogEntry->DumpData[0] = LogEntry->PathId;
        errorLogEntry->DumpData[1] = LogEntry->TargetId;
        errorLogEntry->DumpData[2] = LogEntry->Lun;
        errorLogEntry->DumpData[3] = LogEntry->ErrorCode;
        IoWriteErrorLogEntry(errorLogEntry);
    }

#if DBG
        {
        PCHAR errorCodeString;

        switch (LogEntry->ErrorCode) {
        case SP_BUS_PARITY_ERROR:
            errorCodeString = "SCSI bus partity error";
            break;

        case SP_UNEXPECTED_DISCONNECT:
            errorCodeString = "Unexpected disconnect";
            break;

        case SP_INVALID_RESELECTION:
            errorCodeString = "Invalid reselection";
            break;

        case SP_BUS_TIME_OUT:
            errorCodeString = "SCSI bus time out";
            break;

        case SP_PROTOCOL_ERROR:
            errorCodeString = "SCSI protocol error";
            break;

        case SP_INTERNAL_ADAPTER_ERROR:
            errorCodeString = "Internal adapter error";
            break;

        default:
            errorCodeString = "Unknown error code";
            break;

        }

        DebugPrint((DBG_ALWAYS,"LogErrorEntry: Logging SCSI error packet. ErrorCode = %s.\n",
            errorCodeString
            ));
        DebugPrint((DBG_ALWAYS,
            "PathId = %2x, TargetId = %2x, Lun = %2x, UniqueId = %x.\n",
            LogEntry->PathId,
            LogEntry->TargetId,
            LogEntry->Lun,
            LogEntry->UniqueId
            ));
        }
#endif

}

VOID
GetNextLuPendingRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
{
    if (LogicalUnit->PendingRequest) {

        GetNextLuRequest(
            DeviceExtension,
            LogicalUnit
            );

    } else {

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
    }

    return;
}

#ifdef LOG_GET_NEXT_CALLER

VOID
GetNextLuRequest2(
    IN PFDO_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PUCHAR FileName,
    IN ULONG  LineNumber
    )
#else

VOID
GetNextLuRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    )
#endif
/*++

Routine Description:

    This routine get the next request for the specified logical unit.  It does
    the necessary initialization to the logical unit structure and submitts the
    request to the device queue.  The DeviceExtension SpinLock must be held
    when this function called.  It is released by this function.

Arguments:

    DeviceExtension - Supplies a pointer to the port device extension.

    LogicalUnit - Supplies a pointer to the logical unit extension to get the
        next request from.

Return Value:

     None.

--*/

{
    PKDEVICE_QUEUE_ENTRY packet;
    PIO_STACK_LOCATION   irpStack;
    PSCSI_REQUEST_BLOCK  srb;
    POWER_STATE          powerState;
    PIRP                 nextIrp;
    BOOLEAN              powerUpDevice = FALSE;

#ifdef LOG_GET_NEXT_CALLER

    IdeLogGetNextLuCaller(DeviceExtension, 
                          LogicalUnit,
                          FileName,
                          LineNumber
                          );


#endif 


    //
    // If the active flag is not set, then the queue is not busy or there is
    // a request being processed and the next request should not be started..
    //

    if ((!(LogicalUnit->LuFlags & PD_LOGICAL_UNIT_IS_ACTIVE) &&
          (LogicalUnit->PendingRequest == NULL))
        || (LogicalUnit->SrbData.CurrentSrb)) {

        DebugPrint ((2, "IdePort GetNextLuRequest: 0x%x 0x%x NOT PD_LOGICAL_UNIT_IS_ACTIVE\n",
                     DeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                     LogicalUnit->TargetId
                     ));
        //
        // Release the spinlock.
        //

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        return;
    }

    //
    // Check for pending requests, queue full or busy requests.  Pending
    // requests occur when untagged request is started and there are active
    // queued requests. Busy requests occur when the target returns a BUSY
    // or QUEUE FULL status. Busy requests are started by the timer code.
    // Also if the need request sense flag is set, it indicates that
    // an error status was detected on the logical unit.  No new requests
    // should be started until this flag is cleared.  This flag is cleared
    // by an untagged command that by-passes the LU queue i.e.
    //
    // The busy flag and the need request sense flag have the effect of
    // forcing the queue of outstanding requests to drain after an error or
    // until a busy request gets started.
    //

    if (LogicalUnit->LuFlags & (PD_LOGICAL_UNIT_IS_BUSY
        | PD_QUEUE_IS_FULL | PD_NEED_REQUEST_SENSE | PD_QUEUE_FROZEN) ||
        (LogicalUnit->PdoState & (PDOS_REMOVED | PDOS_SURPRISE_REMOVED))) {

        //
        // If the request queue is now empty, then the pending request can
        // be started.
        //

        DebugPrint((2, "IdePort: GetNextLuRequest: 0x%x 0x%x Ignoring a get next lu call.\n",
                    DeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                    LogicalUnit->TargetId
                    ));

        //
        // Note the active flag is not cleared. So the next request
        // will be processed when the other requests have completed.
        // Release the spinlock.
        //

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
        return;
    }

    //
    // Clear the active flag.  If there is another request, the flag will be
    // set again when the request is passed to the miniport.
    //
    CLRMASK (LogicalUnit->LuFlags, PD_LOGICAL_UNIT_IS_ACTIVE);

    LogicalUnit->RetryCount = 0;
    nextIrp = NULL;

    if (LogicalUnit->PendingRequest) {

        nextIrp = LogicalUnit->PendingRequest;

        LogicalUnit->PendingRequest = NULL;

    } else {

        //
        // Remove the packet from the logical unit device queue.
        //
        packet = KeRemoveByKeyDeviceQueue(&LogicalUnit->DeviceObject->DeviceQueue,
                                          LogicalUnit->CurrentKey);

        if (packet != NULL) {

            nextIrp = CONTAINING_RECORD(packet, IRP, Tail.Overlay.DeviceQueueEntry);

#if DBG
            InterlockedDecrement (
                &LogicalUnit->NumberOfIrpQueued
                );
#endif // DBG

        }
    }

    if (!nextIrp) {

        DebugPrint ((2, "IdePort GetNextLuRequest: 0x%x 0x%x no irp to processing\n",
                     DeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                     LogicalUnit->TargetId
                     ));
    }

    if (nextIrp) {

        BOOLEAN pendingRequest;

        irpStack = IoGetCurrentIrpStackLocation(nextIrp);
        srb = (PSCSI_REQUEST_BLOCK)irpStack->Parameters.Others.Argument1;

        if (LogicalUnit->PdoState & PDOS_QUEUE_BLOCKED) {

            DebugPrint ((2, "IdePort GetNextLuRequest: 0x%x 0x%x Lu must queue\n",
                         DeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                         LogicalUnit->TargetId
                         ));

            pendingRequest = TRUE;

            if (!(LogicalUnit->PdoState & PDOS_MUST_QUEUE)) {

                //
                // device is powered down
                // use a large time in case it spins up slowly
                //
                if (srb->TimeOutValue < DEFAULT_SPINUP_TIME) {

                    srb->TimeOutValue = DEFAULT_SPINUP_TIME;
                }

                //
                // We are not powered up.
                // issue an power up
                //
                powerUpDevice = TRUE;

                DebugPrint ((2, "IdePort GetNextLuRequest: 0x%x 0x%x need to spin up device, requeue irp 0x%x\n",
                             DeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                             LogicalUnit->TargetId,
                             nextIrp));
            }

        } else {

            pendingRequest = FALSE;
        }

        if (pendingRequest) {

            ASSERT (LogicalUnit->PendingRequest == NULL);
            LogicalUnit->PendingRequest = nextIrp;

            nextIrp = NULL;
        }
    }

    if (nextIrp) {

        //
        // Set the new current key.
        //
        LogicalUnit->CurrentKey = srb->QueueSortKey;

        //
        // Hack to work-around the starvation led to by numerous requests touching the same sector.
        //

        LogicalUnit->CurrentKey++;

        //
        // Release the spinlock.
        //

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        DebugPrint ((2, "GetNextLuRequest: IoStartPacket 0x%x\n", nextIrp));

        IoStartPacket(DeviceExtension->DeviceObject, nextIrp, (PULONG)NULL, NULL);

    } else {

        NTSTATUS status;

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        if (powerUpDevice) {

            powerState.DeviceState = PowerDeviceD0;
            status = PoRequestPowerIrp (
                         LogicalUnit->DeviceObject,
                         IRP_MN_SET_POWER,
                         powerState,
                         NULL,
                         NULL,
                         NULL
                         );
            ASSERT (NT_SUCCESS(status));
        }
    }

} // end GetNextLuRequest()

VOID
IdeLogTimeoutError(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp,
    IN ULONG UniqueId
    )
/*++

Routine Description:

    This function logs an error when a request times out.

Arguments:

    DeviceExtension - Supplies a pointer to the port device extension.

    Irp - Supplies a pointer to the request which timedout.

    UniqueId - Supplies the UniqueId for this error.

Return Value:

    None.

Notes:

    The port device extension spinlock should be held when this routine is
    called.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    PIO_STACK_LOCATION   irpStack;
    PSRB_DATA            srbData;
    PSCSI_REQUEST_BLOCK  srb;

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    srb = (PSCSI_REQUEST_BLOCK)irpStack->Parameters.Others.Argument1;
    srbData = IdeGetSrbData(DeviceExtension, srb);

    if (!srbData) {
        return;
    }

    errorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry(DeviceExtension->DeviceObject,
                                                                   sizeof(IO_ERROR_LOG_PACKET) + 4 * sizeof(ULONG));

    if (errorLogEntry != NULL) {
        errorLogEntry->ErrorCode = IO_ERR_TIMEOUT;
        errorLogEntry->SequenceNumber = srbData->SequenceNumber;
        errorLogEntry->MajorFunctionCode = irpStack->MajorFunction;
        errorLogEntry->RetryCount = (UCHAR) srbData->ErrorLogRetryCount;
        errorLogEntry->UniqueErrorValue = UniqueId;
        errorLogEntry->FinalStatus = STATUS_SUCCESS;
        errorLogEntry->DumpDataSize = 4 * sizeof(ULONG);
        errorLogEntry->DumpData[0] = srb->PathId;
        errorLogEntry->DumpData[1] = srb->TargetId;
        errorLogEntry->DumpData[2] = srb->Lun;
        errorLogEntry->DumpData[3] = SP_REQUEST_TIMEOUT;

        IoWriteErrorLogEntry(errorLogEntry);
    }
}

VOID
IdeLogResetError(
    IN PFDO_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK  Srb,
    IN ULONG UniqueId
    )
/*++

Routine Description:

    This function logs an error when the bus is reset.

Arguments:

    DeviceExtension - Supplies a pointer to the port device extension.

    Srb - Supplies a pointer to the request which timed-out.

    UniqueId - Supplies the UniqueId for this error.

Return Value:

    None.

Notes:

    The port device extension spinlock should be held when this routine is
    called.

--*/

{
    PIO_ERROR_LOG_PACKET errorLogEntry;
    PIO_STACK_LOCATION   irpStack;
    PIRP                 irp;
    PSRB_DATA            srbData;
    ULONG                sequenceNumber = 0;
    UCHAR                function       = 0,
                         pathId         = 0,
                         targetId       = 0,
                         lun            = 0,
                         retryCount     = 0;

    if (Srb) {

        irp = Srb->OriginalRequest;

        if (irp) {
            irpStack = IoGetCurrentIrpStackLocation(irp);
            function = irpStack->MajorFunction;
        }

        srbData = IdeGetSrbData(DeviceExtension, Srb);

        if (!srbData) {
            return;
        }

        pathId         = Srb->PathId;
        targetId       = Srb->TargetId;
        lun            = Srb->Lun;
        retryCount     = (UCHAR) srbData->ErrorLogRetryCount;
        sequenceNumber = srbData->SequenceNumber;


    }

    errorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry( DeviceExtension->DeviceObject,
                                                                    sizeof(IO_ERROR_LOG_PACKET)
                                                                        + 4 * sizeof(ULONG) );

    if (errorLogEntry != NULL) {
        errorLogEntry->ErrorCode         = IO_ERR_TIMEOUT;
        errorLogEntry->SequenceNumber    = sequenceNumber;
        errorLogEntry->MajorFunctionCode = function;
        errorLogEntry->RetryCount        = retryCount;
        errorLogEntry->UniqueErrorValue  = UniqueId;
        errorLogEntry->FinalStatus       = STATUS_SUCCESS;
        errorLogEntry->DumpDataSize      = 4 * sizeof(ULONG);
        errorLogEntry->DumpData[0]       = pathId;
        errorLogEntry->DumpData[1]       = targetId;
        errorLogEntry->DumpData[2]       = lun;
        errorLogEntry->DumpData[3]       = SP_REQUEST_TIMEOUT;

        IoWriteErrorLogEntry(errorLogEntry);
    }
}

NTSTATUS
IdeTranslateSrbStatus(
    IN PSCSI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    This routine translates an srb status into an ntstatus.

Arguments:

    Srb - Supplies a pointer to the failing Srb.

Return Value:

    An nt status approprate for the error.

--*/

{
    switch (SRB_STATUS(Srb->SrbStatus)) {
    case SRB_STATUS_INVALID_LUN:
    case SRB_STATUS_INVALID_TARGET_ID:
    case SRB_STATUS_NO_DEVICE:
    case SRB_STATUS_NO_HBA:
        return(STATUS_DEVICE_DOES_NOT_EXIST);
    case SRB_STATUS_COMMAND_TIMEOUT:
    case SRB_STATUS_BUS_RESET:
    case SRB_STATUS_TIMEOUT:
        return(STATUS_IO_TIMEOUT);
    case SRB_STATUS_SELECTION_TIMEOUT:
        return(STATUS_DEVICE_NOT_CONNECTED);
    case SRB_STATUS_BAD_FUNCTION:
    case SRB_STATUS_BAD_SRB_BLOCK_LENGTH:
        return(STATUS_INVALID_DEVICE_REQUEST);
    case SRB_STATUS_DATA_OVERRUN:
        return(STATUS_BUFFER_OVERFLOW);
    default:
        return(STATUS_IO_DEVICE_ERROR);
    }

    return(STATUS_IO_DEVICE_ERROR);
}


BOOLEAN
IdeResetBusSynchronized (
    PVOID ServiceContext
    )
/*++

Routine Description:

    This function resets the bus and sets up the port timer so the reset hold
    flag is clean when necessary.

Arguments:

    ServiceContext - Supplies a pointer to the reset context which includes a
        pointer to the device extension and the pathid to be reset.

Return Value:

    TRUE - if the reset succeeds.

--*/

{
    PRESET_CONTEXT resetContext = ServiceContext;
    PFDO_EXTENSION deviceExtension;
    PSCSI_REQUEST_BLOCK  resetSrbToComplete;
    BOOLEAN goodReset;

    resetSrbToComplete  = NULL;
    deviceExtension     = resetContext->DeviceExtension;

    //
    // Should never get a reset srb while one is in progress
    //
    if (resetContext->ResetSrb && deviceExtension->ResetSrb) {

        ASSERT (resetContext->ResetSrb == deviceExtension->ResetSrb);
    }

    if (resetContext->NewResetSequence) {
        //
        // a new reset sequence to kill the reset in progress if any
        //

        if (deviceExtension->ResetCallAgain) {

            DebugPrint ((0, "ATAPI: WARNING: Resetting a reset\n"));

            deviceExtension->ResetCallAgain = 0;

            if (deviceExtension->ResetSrb) {

                resetSrbToComplete = deviceExtension->ResetSrb;
                resetSrbToComplete->SrbStatus = SRB_STATUS_ERROR;

                deviceExtension->ResetSrb = NULL;
            }

        }
        deviceExtension->ResetSrb = resetContext->ResetSrb;
    }

    goodReset = AtapiResetController (
                    deviceExtension->HwDeviceExtension,
                    resetContext->PathId,
                    &deviceExtension->ResetCallAgain);

    //
    // Set the reset hold flag and start the counter if the reset is not done
    //
    if ((goodReset) && (deviceExtension->ResetCallAgain)) {

        deviceExtension->InterruptData.InterruptFlags |= PD_RESET_HOLD;
        deviceExtension->PortTimeoutCounter = PD_TIMER_RESET_HOLD_TIME;

    } else {

        CLRMASK (deviceExtension->InterruptData.InterruptFlags, PD_RESET_HOLD);
        deviceExtension->PortTimeoutCounter = PD_TIMER_STOPPED;

        if (deviceExtension->ResetSrb) {

            resetSrbToComplete = deviceExtension->ResetSrb;
            deviceExtension->ResetSrb = NULL;
        }

        if (resetSrbToComplete) {

            if (goodReset) {

                resetSrbToComplete->SrbStatus = SRB_STATUS_SUCCESS;

            } else {

                resetSrbToComplete->SrbStatus = SRB_STATUS_ERROR;
            }
        }

        if (goodReset) {

            IdePortNotification(IdeResetDetected,
                                deviceExtension->HwDeviceExtension,
                                resetSrbToComplete);
        }

        if (deviceExtension->InterruptData.InterruptFlags & PD_HELD_REQUEST) {

            //
            // Clear the held request flag and restart the request.
            //

            CLRMASK (deviceExtension->InterruptData.InterruptFlags, PD_HELD_REQUEST);
            IdeStartIoSynchronized(deviceExtension->DeviceObject);
        }
    }

    if (resetSrbToComplete) {

        IdePortNotification(IdeRequestComplete,
                            deviceExtension->HwDeviceExtension,
                            resetSrbToComplete);

        IdePortNotification(IdeNextRequest,
                            deviceExtension->HwDeviceExtension,
                            NULL);
    }

    //
    // Check for miniport work requests.
    //

    if (deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

        //
        // Queue a DPC.
        //
        IoRequestDpc(deviceExtension->DeviceObject, NULL, NULL);
    }

    return(TRUE);
}


VOID
IdeProcessCompletedRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PSRB_DATA SrbData,
    OUT PBOOLEAN CallStartIo
    )
/*++
Routine Description:

    This routine processes a request which has completed.  It completes any
    pending transfers, releases the adapter objects and map registers when
    necessary.  It deallocates any resources allocated for the request.
    It processes the return status, by requeueing busy request, requesting
    sense information or logging an error.

Arguments:

    DeviceExtension - Supplies a pointer to the device extension for the
        adapter data.

    SrbData - Supplies a pointer to the SRB data block to be completed.

    CallStartIo - This value is set if the start I/O routine needs to be
        called.

Return Value:

    None.

--*/

{

    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSCSI_REQUEST_BLOCK     srb;
    PIO_ERROR_LOG_PACKET    errorLogPacket;
    ULONG                   sequenceNumber;
    LONG                    interlockResult;
    PIRP                    irp;
    PIO_STACK_LOCATION      irpStack;
    PHW_DEVICE_EXTENSION     hwDeviceExtension = DeviceExtension->HwDeviceExtension;

    ASSERT(SrbData->CurrentSrb);
    srb = SrbData->CurrentSrb;
    irp = srb->OriginalRequest;

    DebugPrint((2,"CompletedRequest: Irp 0x%8x Srb 0x%8x DataBuf 0x%8x Len 0x%8x\n", irp, srb, srb->DataBuffer, srb->DataTransferLength));

#ifdef IDE_MULTIPLE_IRP_COMPLETE_REQUESTS_CHECK
    if (irp->CurrentLocation > (CCHAR) (irp->StackCount + 1)) {
        KeBugCheckEx( MULTIPLE_IRP_COMPLETE_REQUESTS, (ULONG_PTR) irp, (ULONG_PTR) srb, 0, 0 );
    }
#endif // IDE_MULTIPLE_IRP_COMPLETE_REQUESTS_CHECK


    irpStack = IoGetCurrentIrpStackLocation(irp);


    //
    // Get logical unit extension for this request.
    //

    logicalUnit = IDEPORT_GET_LUNEXT_IN_IRP (irpStack);

    //
    // If miniport needs mapped system addresses, the the
    // data buffer address in the SRB must be restored to
    // original unmapped virtual address. Ensure that this request requires
    // a data transfer.
    //

    if (srb->SrbFlags & SRB_FLAGS_UNSPECIFIED_DIRECTION) {
        if (!SRB_USES_DMA(srb)) {
            if (irp->MdlAddress) {

                //
                // If an IRP is for a transfer larger than a miniport driver
                // can handle, the request is broken up into multiple smaller
                // requests. Each request uses the same MDL and the data
                // buffer address field in the SRB may not be at the
                // beginning of the memory described by the MDL.
                //

                srb->DataBuffer = (PCCHAR)MmGetMdlVirtualAddress(irp->MdlAddress) +
                    ((PCCHAR)srb->DataBuffer - SrbData->SrbDataOffset);

                //
                // Since this driver driver did programmaged I/O then the buffer
                // needs to flushed if this an data-in transfer.
                //

                if (srb->SrbFlags & SRB_FLAGS_DATA_IN) {

                    KeFlushIoBuffers(irp->MdlAddress,
                                     TRUE,
                                     FALSE);
                }

				if (SrbData->Flags & SRB_DATA_RESERVED_PAGES) {

					KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);
					IdeUnmapReservedMapping(DeviceExtension, SrbData, irp->MdlAddress);
					KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);


				}
            }
        }
    }

#ifdef LOG_GET_NEXT_CALLER
    IdeLogCompletedCommand(DeviceExtension, srb);
#endif

    //
    // Clear the current request.
    //

    SrbData->CurrentSrb = NULL;

    //
    // If the no diconnect flag was set for this SRB, then check to see
    // if IoStartNextPacket must be called.
    //

    if (srb->SrbFlags & SRB_FLAGS_DISABLE_DISCONNECT) {

        //
        // Acquire the spinlock to protect the flags strcuture.
        //

        KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

        //
        // Set the disconnect running flag and check the busy flag.
        //

        DeviceExtension->Flags |= PD_DISCONNECT_RUNNING;

        //
        // The interrupt flags are checked unsynchonized.  This works because
        // the RESET_HOLD flag is cleared with the spinlock held and the
        // counter is only set with the spinlock held.  So the only case where
        // there is a problem is is a reset occurs before this code get run,
        // but this code runs before the timer is set for a reset hold;
        // the timer will soon set for the new value.
        //

        if (!(DeviceExtension->InterruptData.InterruptFlags & PD_RESET_HOLD)) {

            //
            // The miniport is ready for the next request and there is not a
            // pending reset hold, so clear the port timer.
            //

            DeviceExtension->PortTimeoutCounter = PD_TIMER_STOPPED;
        }

        //
        // Release the spinlock.
        //

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        if (!(DeviceExtension->Flags & PD_DEVICE_IS_BUSY) &&
            !*CallStartIo &&
            !(DeviceExtension->Flags & PD_PENDING_DEVICE_REQUEST)) {

            //
            // The busy flag is clear so the miniport has requested the
            // next request. Call IoStartNextPacket.
            //

            IoStartNextPacket(DeviceExtension->DeviceObject, FALSE);
        }
    }

    //
    // Check if scatter/gather list came from pool.
    //

    if (srb->SrbFlags & SRB_FLAGS_SGLIST_FROM_POOL) {

        CLRMASK (srb->SrbFlags, SRB_FLAGS_SGLIST_FROM_POOL);
    }

    //
    // Acquire the spinlock to protect the flags structure,
    // and the free of the srb extension.
    //

    KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);

    //
    // Move bytes transfered to IRP.
    //
    irp->IoStatus.Information = srb->DataTransferLength;

    //
    // Save the sequence number in case an error needs to be logged later.
    //
    sequenceNumber = SrbData->SequenceNumber;
    SrbData->SequenceNumber = 0;
    SrbData->ErrorLogRetryCount = 0;

#if DBG
    SrbData = NULL;
#endif

    if (DeviceExtension->Flags & PD_PENDING_DEVICE_REQUEST) {

        //
        // The start I/O routine needs to be called because it could not
        // allocate an srb extension.  Clear the pending flag and note
        // that it needs to be called later.
        //

        CLRMASK (DeviceExtension->Flags, PD_PENDING_DEVICE_REQUEST);
        *CallStartIo = TRUE;
    }

    //
    // If success then start next packet.
    // Not starting packet effectively
    // freezes the queue.
    //


    if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_SUCCESS) {

        ULONG srbFlags;
#if DBG
        PVOID tag = irp;
#endif

        irp->IoStatus.Status = STATUS_SUCCESS;

        //
        // save the srbFlags for later user
        //
        srbFlags = srb->SrbFlags;


        if (srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH) {

            //
            // must complete power irp before starting a new request
            //
            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            //
            // Decrement the logUnitExtension reference count
            //
            UnrefLogicalUnitExtensionWithTag(
                DeviceExtension,
                logicalUnit,
                tag
                );

            IoCompleteRequest(irp, IO_DISK_INCREMENT);
            irp = NULL;


            //
            // we had a device state transition...restart the lu queue
            //
            KeAcquireSpinLockAtDpcLevel(&DeviceExtension->SpinLock);
            GetNextLuRequest(DeviceExtension, logicalUnit);

        } else {

            //
            // If the queue is being bypassed then keep the queue frozen.
            // If there are outstanding requests as indicated by the timer
            // being active then don't start the then next request.
            //
            if (!(srbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE) &&
                logicalUnit->RequestTimeoutCounter == PD_TIMER_STOPPED) {

                //
                // This is a normal request start the next packet.
                //

                GetNextLuRequest(DeviceExtension, logicalUnit);

            } else {

                //
                // Release the spinlock.
                //

                KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
            }
        }

        DebugPrint((2,
                    "IdeProcessCompletedRequests: Iocompletion IRP %lx\n",
                    irp));

        //
        // Note that the retry count and sequence number are not cleared
        // for completed packets which were generated by the port driver.
        //
        if (irp) {

            //
            // Decrement the logUnitExtension reference count
            //
            UnrefLogicalUnitExtensionWithTag(
                DeviceExtension,
                logicalUnit,
                tag
                );


            IoCompleteRequest(irp, IO_DISK_INCREMENT);
        }

        return;

    }

    //
    // Set IRP status. Class drivers will reset IRP status based
    // on request sense if error.
    //

    irp->IoStatus.Status = IdeTranslateSrbStatus(srb);

    DebugPrint((2, "IdeProcessCompletedRequests: Queue frozen TID %d\n",
        srb->TargetId));

    if ((srb->SrbStatus == SRB_STATUS_TIMEOUT) ||
        (srb->SrbStatus == SRB_STATUS_BUS_RESET)) {

        if (SRB_USES_DMA(srb)) {

            ULONG errorCount;

            //
            // retry with PIO
            //
            DebugPrint ((DBG_ALWAYS, "ATAPI: retrying dma srb 0x%x with pio\n", srb));

            MARK_SRB_AS_PIO_CANDIDATE(srb);

            srb->SrbStatus = SRB_STATUS_PENDING;
            srb->ScsiStatus = 0;

            if (srb->SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE) {

                KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                //
                // iostart the fdo
                //
                IoStartPacket(DeviceExtension->DeviceObject, irp, (PULONG)NULL, NULL);

            } else {

                KeInsertByKeyDeviceQueue(&logicalUnit->DeviceObject->DeviceQueue,
                                         &irp->Tail.Overlay.DeviceQueueEntry,
                                         srb->QueueSortKey);

                GetNextLuRequest(DeviceExtension, logicalUnit);
            }

            //
            // spinlock is released.
            //

            //
            // we got an error using DMA
            //
            errorCount = InterlockedIncrement(&logicalUnit->DmaTransferTimeoutCount);

            if (errorCount == PDO_DMA_TIMEOUT_LIMIT) {

                ERROR_LOG_ENTRY errorLogEntry;
                ULONG i;

                //
                // Timeout errors need not be device specific. So no need to
                // update the hall of shame
                //
                errorLogEntry.ErrorCode             = SP_PROTOCOL_ERROR;
                errorLogEntry.MajorFunctionCode     = IRP_MJ_SCSI;
                errorLogEntry.PathId                = srb->PathId;
                errorLogEntry.TargetId              = srb->TargetId;
                errorLogEntry.Lun                   = srb->Lun;
                errorLogEntry.UniqueId              = ERRLOGID_TOO_MANY_DMA_TIMEOUT;
                errorLogEntry.ErrorLogRetryCount    = errorCount;
                errorLogEntry.SequenceNumber        = 0;

                LogErrorEntry(
                    DeviceExtension,
                    &errorLogEntry
                    );

                //
                // disable DMA
                //
                hwDeviceExtension->DeviceParameters[srb->TargetId].TransferModeMask |= DMA_SUPPORT;

                DebugPrint ((DBG_ALWAYS,
                             "ATAPI ERROR: 0x%x target %d has too many DMA timeout, falling back to PIO\n",
                             DeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                             srb->TargetId
                             ));

                //
                // rescan the bus to update transfer mode
                //
#if defined (BUS_CHECK_ON_DMA_ERROR)

                if (!(logicalUnit->LuFlags & PD_RESCAN_ACTIVE)) {
                    IoInvalidateDeviceRelations (
                        DeviceExtension->AttacheePdo,
                        BusRelations
                        );
                }
#endif // BUS_CHECK_ON_DMA_ERROR
            }

            return;

        } else {

            if ((!TestForEnumProbing(srb)) &&
                (srb->Function != SRB_FUNCTION_ATA_POWER_PASS_THROUGH) &&
                (srb->Function != SRB_FUNCTION_ATA_PASS_THROUGH_EX) &&
                (srb->Function != SRB_FUNCTION_ATA_PASS_THROUGH)) {

                ULONG errorCount;
                ULONG errorCountLimit;

				//
				// Check if were trying the flush the device cache
				//
				if ((srb->Function == SRB_FUNCTION_FLUSH) ||
					(srb->Function == SRB_FUNCTION_SHUTDOWN) ||
					(srb->Cdb[0] == SCSIOP_SYNCHRONIZE_CACHE)) {

					errorCount = InterlockedIncrement(&logicalUnit->FlushCacheTimeoutCount);

					DebugPrint((1,
								"FlushCacheTimeout incremented to 0x%x\n",
								errorCount
								));

					//
					// Disable flush on IDE devices
					//
					if (errorCount >= PDO_FLUSH_TIMEOUT_LIMIT ) {
						hwDeviceExtension->
							DeviceParameters[srb->TargetId].IdeFlushCommand = IDE_COMMAND_NO_FLUSH;
#ifdef ENABLE_48BIT_LBA
						hwDeviceExtension->
							DeviceParameters[srb->TargetId].IdeFlushCommandExt = IDE_COMMAND_NO_FLUSH;
#endif
					}

					ASSERT (errorCount <= PDO_FLUSH_TIMEOUT_LIMIT);

					//
					// looks like the device doesn't support flush cache
					//
					srb->SrbStatus = SRB_STATUS_SUCCESS;
					irp->IoStatus.Status = STATUS_SUCCESS;

				} else {

					errorCount = InterlockedIncrement(&logicalUnit->ConsecutiveTimeoutCount);

					DebugPrint ((DBG_ALWAYS, "0x%x target %d has 0x%x timeout errors so far\n",
								logicalUnit->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
								logicalUnit->TargetId,
								errorCount));

					if ((errorCount == PDO_CONSECUTIVE_TIMEOUT_WARNING_LIMIT) &&
                        !(logicalUnit->LuFlags & PD_RESCAN_ACTIVE)) {

						//
						// the device not looking good
						// make sure it is still there
						//
						IoInvalidateDeviceRelations (
							DeviceExtension->AttacheePdo,
							BusRelations
							);
					}

					if (logicalUnit->PagingPathCount) {

						errorCountLimit = PDO_CONSECUTIVE_PAGING_TIMEOUT_LIMIT;

					} else {

						errorCountLimit = PDO_CONSECUTIVE_TIMEOUT_LIMIT;
					}

					if (errorCount >= errorCountLimit) {

						DebugPrint ((DBG_ALWAYS, "0x%x target %d has too many timeout.  it is a goner...\n",
									 logicalUnit->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
									 logicalUnit->TargetId));


						//
						// looks like the device is dead.
						//
						KeAcquireSpinLockAtDpcLevel(&logicalUnit->PdoSpinLock);

						SETMASK (logicalUnit->PdoState, PDOS_DEADMEAT);

						IdeLogDeadMeatReason( logicalUnit->DeadmeatRecord.Reason, 
											  tooManyTimeout
											  );

						KeReleaseSpinLockFromDpcLevel(&logicalUnit->PdoSpinLock);

                        if (!(logicalUnit->LuFlags & PD_RESCAN_ACTIVE)) {
                            IoInvalidateDeviceRelations (
                                DeviceExtension->AttacheePdo,
                                BusRelations
                                );
                        }
					}
				}

            }

        }

    } else {

        //
        // reset error count
        //
        InterlockedExchange(&logicalUnit->ConsecutiveTimeoutCount, 0);
    }


    if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_PARITY_ERROR) {

        ULONG errorCount;
        errorCount = InterlockedIncrement(&logicalUnit->CrcErrorCount);
        if (errorCount == PDO_UDMA_CRC_ERROR_LIMIT) {

            ERROR_LOG_ENTRY errorLogEntry;
            ULONG xferMode;

            errorLogEntry.ErrorCode             = SP_BUS_PARITY_ERROR;
            errorLogEntry.MajorFunctionCode     = IRP_MJ_SCSI;
            errorLogEntry.PathId                = srb->PathId;
            errorLogEntry.TargetId              = srb->TargetId;
            errorLogEntry.Lun                   = srb->Lun;
            errorLogEntry.UniqueId              = ERRLOGID_TOO_MANY_CRC_ERROR;
            errorLogEntry.ErrorLogRetryCount    = errorCount;
            errorLogEntry.SequenceNumber        = 0;

            LogErrorEntry(
                DeviceExtension,
                &errorLogEntry
                );

            //
            //Procure the selected transfer mode again.
            //
            GetHighestDMATransferMode(hwDeviceExtension->DeviceParameters[srb->TargetId].TransferModeSelected,
                                      xferMode);

            //
            //Gradual degradation.
            //
            if (xferMode > UDMA0) {

                hwDeviceExtension->DeviceParameters[srb->TargetId].TransferModeMask |= (1 << xferMode);

            } else if (xferMode == UDMA0) {

                // Don't use MWDMA and SWDMA
                hwDeviceExtension->DeviceParameters[srb->TargetId].TransferModeMask |= DMA_SUPPORT;

            }

            DebugPrint ((DBG_ALWAYS,
                         "ATAPI ERROR: 0x%x target %d has too many crc error, degrading to a lower DMA mode\n",
                         DeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                         srb->TargetId
                         ));

            //
            // rescan the bus to update transfer mode
            //
            if (!(logicalUnit->LuFlags & PD_RESCAN_ACTIVE)) {
                IoInvalidateDeviceRelations (
                    DeviceExtension->AttacheePdo,
                    BusRelations
                    );
            }
        }
    }


    if ((srb->ScsiStatus == SCSISTAT_BUSY ||
         srb->SrbStatus == SRB_STATUS_BUSY ||
         srb->ScsiStatus == SCSISTAT_QUEUE_FULL) &&
         !(srb->SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE)) {

        //
        // Perform busy processing if a busy type status was returned and this
        // is not a by-pass request.
        //

        DebugPrint((1,
                   "SCSIPORT: Busy SRB status %x, SCSI status %x)\n",
                   srb->SrbStatus,
                   srb->ScsiStatus));

        //
        // If there is already a pending busy request or the queue is frozen
        // then just requeue this request.
        //

        if (logicalUnit->LuFlags & (PD_LOGICAL_UNIT_IS_BUSY | PD_QUEUE_FROZEN)) {

            DebugPrint((1,
                       "IdeProcessCompletedRequest: Requeuing busy request\n"));

            srb->SrbStatus = SRB_STATUS_PENDING;
            srb->ScsiStatus = 0;

            if (!KeInsertByKeyDeviceQueue(&logicalUnit->DeviceObject->DeviceQueue,
                                          &irp->Tail.Overlay.DeviceQueueEntry,
                                          srb->QueueSortKey)) {

                //
                // This should never occur since there is a busy request.
                //

                srb->SrbStatus = SRB_STATUS_ERROR;
                srb->ScsiStatus = SCSISTAT_BUSY;

                ASSERT(FALSE);
                goto BusyError;

            }

            //
            // Release the spinlock.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        } else if (logicalUnit->RetryCount++ < BUSY_RETRY_COUNT) {

            //
            // If busy status is returned, then indicate that the logical
            // unit is busy.  The timeout code will restart the request
            // when it fires. Reset the status to pending.
            //

            srb->SrbStatus = SRB_STATUS_PENDING;
            srb->ScsiStatus = 0;

            logicalUnit->LuFlags |= PD_LOGICAL_UNIT_IS_BUSY;
            logicalUnit->BusyRequest = irp;

            if (logicalUnit->RetryCount == (BUSY_RETRY_COUNT/2) ) {

                RESET_CONTEXT resetContext;

                DebugPrint ((0,
                             "ATAPI: PDO 0x%x 0x%x seems to be DEAD.  try a reset to bring it back.\n",
                             logicalUnit, logicalUnit->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress
                            ));

                resetContext.DeviceExtension = DeviceExtension;
                resetContext.PathId = srb->PathId;
                resetContext.NewResetSequence = TRUE;
                resetContext.ResetSrb = NULL;

                KeSynchronizeExecution(DeviceExtension->InterruptObject,
                                       IdeResetBusSynchronized,
                                       &resetContext);

#if DBG
                IdeDebugHungControllerCounter = 0;
#endif // DBG
            }

            //
            // Release the spinlock.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        } else {

BusyError:
            //
            // Indicate the queue is frozen.
            //

			if (!(srb->SrbFlags & SRB_FLAGS_NO_QUEUE_FREEZE)) {
				srb->SrbStatus |= SRB_STATUS_QUEUE_FROZEN;
				logicalUnit->LuFlags |= PD_QUEUE_FROZEN;
			}

//#if DBG
//            if (logicalUnit->PdoState & PDOS_DEADMEAT) {
//                DbgBreakPoint();
//            }
//#endif

            //
            // Release the spinlock.  Start the next request.
            //
            if (!(srb->SrbFlags & SRB_FLAGS_BYPASS_FROZEN_QUEUE) &&
                logicalUnit->RequestTimeoutCounter == PD_TIMER_STOPPED) {

                //
                // This is a normal request start the next packet.
                //
                GetNextLuRequest(DeviceExtension, logicalUnit);

            } else {

                //
                // Release the spinlock.
                //
                KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
            }

            if (!TestForEnumProbing(srb)) {

                //
                // Log an a timeout erorr if we are not probing during bus-renum.
                //

                errorLogPacket = (PIO_ERROR_LOG_PACKET)
                    IoAllocateErrorLogEntry(DeviceExtension->DeviceObject,
                                            sizeof(IO_ERROR_LOG_PACKET) + 4 * sizeof(ULONG));

                if (errorLogPacket != NULL) {
                    errorLogPacket->ErrorCode = IO_ERR_NOT_READY;
                    errorLogPacket->SequenceNumber = sequenceNumber;
                    errorLogPacket->MajorFunctionCode =
                       IoGetCurrentIrpStackLocation(irp)->MajorFunction;
                    errorLogPacket->RetryCount = logicalUnit->RetryCount;
                    errorLogPacket->UniqueErrorValue = 259;
                    errorLogPacket->FinalStatus = STATUS_DEVICE_NOT_READY;
                    errorLogPacket->DumpDataSize = 5 * sizeof(ULONG);
                    errorLogPacket->DumpData[0] = srb->PathId;
                    errorLogPacket->DumpData[1] = srb->TargetId;
                    errorLogPacket->DumpData[2] = srb->Lun;
                    errorLogPacket->DumpData[3] = srb->ScsiStatus;
                    errorLogPacket->DumpData[4] = SP_REQUEST_TIMEOUT;


                    IoWriteErrorLogEntry(errorLogPacket);
                }
            }

            irp->IoStatus.Status = STATUS_DEVICE_NOT_READY;

            //
            // Decrement the logUnitExtension reference count
            //
            UnrefLogicalUnitExtensionWithTag(
                DeviceExtension,
                logicalUnit,
                irp
                );

            IoCompleteRequest(irp, IO_DISK_INCREMENT);
        }

        return;
    }

    //
    // If the request sense data is valid, or none is needed and this request
    // is not going to freeze the queue, then start the next request for this
    // logical unit if it is idle.
    //

    if (!NEED_REQUEST_SENSE(srb) && srb->SrbFlags & SRB_FLAGS_NO_QUEUE_FREEZE) {

        if (logicalUnit->RequestTimeoutCounter == PD_TIMER_STOPPED) {

            GetNextLuRequest(DeviceExtension, logicalUnit);

            //
            // The spinlock is released by GetNextLuRequest.
            //

        } else {

            //
            // Release the spinlock.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

        }

    } else {

        //
        // NOTE:  This will also freeze the queue.  For a case where there
        // is no request sense.
        //

//        if (srb->SrbFlags & SRB_FLAGS_NO_QUEUE_FREEZE) {
//            DebugPrint ((DBG_ALWAYS, "BAD BAD BAD: Freezing queue even with a no_queue_freeze request srb = 0x%x\n", srb));
//        }

        if (!(srb->SrbFlags & SRB_FLAGS_NO_QUEUE_FREEZE)) {
            srb->SrbStatus |= SRB_STATUS_QUEUE_FROZEN;
            logicalUnit->LuFlags |= PD_QUEUE_FROZEN;
        }

//#if DBG
//        if (logicalUnit->PdoState & PDOS_DEADMEAT) {
//            DbgBreakPoint();
//        }
//#endif

        //
        // Determine if a REQUEST SENSE command needs to be done.
        // Check that a CHECK_CONDITION was received, an autosense has not
        // been done already, and that autosense has been requested.
        //

        if (NEED_REQUEST_SENSE(srb)) {

            srb->SrbStatus |= SRB_STATUS_QUEUE_FROZEN;
            logicalUnit->LuFlags |= PD_QUEUE_FROZEN;

            //
            // If a request sense is going to be issued then any busy
            // requests must be requeue so that the time out routine does
            // not restart them while the request sense is being executed.
            //

            if (logicalUnit->LuFlags & PD_LOGICAL_UNIT_IS_BUSY) {

                DebugPrint((1, "IdeProcessCompletedRequest: Requeueing busy request to allow request sense.\n"));

                if (!KeInsertByKeyDeviceQueue(
                    &logicalUnit->DeviceObject->DeviceQueue,
                    &logicalUnit->BusyRequest->Tail.Overlay.DeviceQueueEntry,
                    srb->QueueSortKey)) {

                    //
                    // This should never occur since there is a busy request.
                    // Complete the current request without request sense
                    // informaiton.
                    //

                    ASSERT(FALSE);
                    DebugPrint((3, "IdeProcessCompletedRequests: Iocompletion IRP %lx\n", irp ));

                    //
                    // Release the spinlock.
                    //

                    KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

                    //
                    // Decrement the logUnitExtension reference count
                    //
                    UnrefLogicalUnitExtensionWithTag(
                        DeviceExtension,
                        logicalUnit,
                        irp
                        );

                    IoCompleteRequest(irp, IO_DISK_INCREMENT);
                    return;

                }

                //
                // Clear the busy flag.
                //

                CLRMASK (logicalUnit->LuFlags, PD_LOGICAL_UNIT_IS_BUSY | PD_QUEUE_IS_FULL);

            }

            //
            // Release the spinlock.
            //

            KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);

            //
            // Call IssueRequestSense and it will complete the request
            // after the REQUEST SENSE completes.
            //

            IssueRequestSense(logicalUnit, srb);

            return;
        }

        //
        // Release the spinlock.
        //

        KeReleaseSpinLockFromDpcLevel(&DeviceExtension->SpinLock);
    }

    //
    // Decrement the logUnitExtension reference count
    //
    UnrefLogicalUnitExtensionWithTag(
        DeviceExtension,
        logicalUnit,
        irp
        );


    IoCompleteRequest(irp, IO_DISK_INCREMENT);
}

PSRB_DATA
IdeGetSrbData(
    IN PFDO_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    )

/*++

Routine Description:

    This function returns the SRB data for the addressed unit.

Arguments:

    DeviceExtension - Supplies a pointer to the device extension.

    Srb - Supplies the scsi request block 

Return Value:

    Returns a pointer to the SRB data.  NULL is returned if the address is not
    valid.

--*/

{
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    PLOGICAL_UNIT_EXTENSION logicalUnit;


    irp = Srb->OriginalRequest;
    if (irp == NULL) {
        return NULL;
    }
    irpStack = IoGetCurrentIrpStackLocation(irp);
    logicalUnit = IDEPORT_GET_LUNEXT_IN_IRP (irpStack);

    if (logicalUnit == NULL) {
        return NULL;
    }

    return &logicalUnit->SrbData;
}

VOID
IdeCompleteRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PSRB_DATA SrbData,
    IN UCHAR SrbStatus
    )
/*++

Routine Description:

    The routine completes the specified request.

Arguments:

    DeviceExtension - Supplies a pointer to the device extension.

    SrbData - Supplies a pointer to the SrbData for the request to be
        completed.

Return Value:

    None.

--*/

{
    PSCSI_REQUEST_BLOCK srb;

    //
    // Make sure there is a current request.
    //

    ASSERT(SrbData->CurrentSrb);
    srb = SrbData->CurrentSrb;

    if (srb == NULL || !(srb->SrbFlags & SRB_FLAGS_IS_ACTIVE)) {
        return;
    }

    //
    // Update SRB status.
    //

    srb->SrbStatus = SrbStatus;

    //
    // Indicate no bytes transferred.
    //
    if (!SRB_USES_DMA(srb)) {

        srb->DataTransferLength = 0;

    } else {

        // if we are doing DMA, preserve DataTransferLength.
        // so retry will know how many bytes to transfer
    }

    //
    // Call notification routine.
    //

    IdePortNotification(IdeRequestComplete,
                (PVOID)(DeviceExtension + 1),
                srb);

}

NTSTATUS
IdeSendMiniPortIoctl(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP RequestIrp
    )

/*++

Routine Description:

    This function sends a miniport ioctl to the miniport driver.
    It creates an srb which is processed normally by the port driver.
    This call is synchronous.

Arguments:

    DeviceExtension - Supplies a pointer the SCSI adapter device extension.

    RequestIrp - Supplies a pointe to the Irp which made the original request.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/

{
    PIRP                    irp;
    PIO_STACK_LOCATION      irpStack;
    PSRB_IO_CONTROL         srbControl;
    SCSI_REQUEST_BLOCK      srb;
    KEVENT                  event;
    LARGE_INTEGER           startingOffset;
    IO_STATUS_BLOCK         ioStatusBlock;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    ULONG                   outputLength;
    ULONG                   length;
    ULONG                   target;
    IDE_PATH_ID             pathId;

    PAGED_CODE();
    startingOffset.QuadPart = (LONGLONG) 1;

    
    DebugPrint((3,"IdeSendMiniPortIoctl: Enter routine\n"));

    //
    // Get a pointer to the control block.
    //

    irpStack = IoGetCurrentIrpStackLocation(RequestIrp);
    srbControl = RequestIrp->AssociatedIrp.SystemBuffer;
    RequestIrp->IoStatus.Information = 0;

    //
    // check for kernel mode
    //
    if (RequestIrp->RequestorMode != KernelMode) {
        RequestIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        return(STATUS_INVALID_PARAMETER);
    }

    //
    // Validiate the user buffer.
    //

    if (irpStack->Parameters.DeviceIoControl.InputBufferLength < 
        sizeof(SRB_IO_CONTROL)) {

        RequestIrp->IoStatus.Status = STATUS_INVALID_PARAMETER;
        return(STATUS_INVALID_PARAMETER);
    }

    if (srbControl->HeaderLength != sizeof(SRB_IO_CONTROL)) {
        RequestIrp->IoStatus.Status = STATUS_REVISION_MISMATCH;
        return(STATUS_REVISION_MISMATCH);
    }

    length = srbControl->HeaderLength + srbControl->Length;
    if ((length < srbControl->HeaderLength) ||
        (length < srbControl->Length)) {

        //
        // total length overflows a ULONG
        //
        return(STATUS_INVALID_PARAMETER);
    }

    outputLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength < length &&
        irpStack->Parameters.DeviceIoControl.InputBufferLength < length ) {

        RequestIrp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
        return(STATUS_BUFFER_TOO_SMALL);
    }

    //
    // Set the logical unit addressing to the first logical unit.  This is
    // merely used for addressing purposes.
    //
    pathId.l = 0;
    while (logicalUnit = NextLogUnitExtensionWithTag(
                             DeviceExtension,
                             &pathId,
                             FALSE,
                             RequestIrp
                             )) {

        //
        // Walk the logical unit list to the end, looking for a safe one.
        // If it was created for a rescan, it might be freed before this request is
        // complete.
        //

        if (!(logicalUnit->LuFlags & PD_RESCAN_ACTIVE)) {

            //
            // Found a good one!
            //
            break;
        }

        UnrefLogicalUnitExtensionWithTag (
            DeviceExtension,
            logicalUnit,
            RequestIrp
            );
    }

    if (logicalUnit == NULL) {
        RequestIrp->IoStatus.Status = STATUS_DEVICE_DOES_NOT_EXIST;
        return(STATUS_DEVICE_DOES_NOT_EXIST);
    }

    //
    // Initialize the notification event.
    //

    KeInitializeEvent(&event,
                        NotificationEvent,
                        FALSE);

    //
    // Build IRP for this request.
    // Note we do this synchronously for two reasons.  If it was done
    // asynchonously then the completion code would have to make a special
    // check to deallocate the buffer.  Second if a completion routine were
    // used then an additional IRP stack location would be needed.
    //

    irp = IoBuildSynchronousFsdRequest(
                IRP_MJ_SCSI,
                logicalUnit->DeviceObject,
                srbControl,
                length,
                &startingOffset,
                &event,
                &ioStatusBlock);

    if (irp==NULL) {

        IdeLogNoMemoryError(DeviceExtension,
                            logicalUnit->TargetId, 
                            NonPagedPool,
                            IoSizeOfIrp(logicalUnit->DeviceObject->StackSize),
                            IDEPORT_TAG_MPIOCTL_IRP
                            );

        UnrefLogicalUnitExtensionWithTag (
            DeviceExtension,
            logicalUnit,
            RequestIrp
            );

        RequestIrp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;
        return RequestIrp->IoStatus.Status;
    }

    irpStack = IoGetNextIrpStackLocation(irp);

    //
    // Set major and minor codes.
    //

    irpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Fill in SRB fields.
    //

    irpStack->Parameters.Others.Argument1 = &srb;

    //
    // Zero out the srb.
    //

    RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

    srb.PathId = logicalUnit->PathId;
    srb.TargetId = logicalUnit->TargetId;
    srb.Lun = logicalUnit->Lun;

    srb.Function = SRB_FUNCTION_IO_CONTROL;
    srb.Length = sizeof(SCSI_REQUEST_BLOCK);

    srb.SrbFlags = SRB_FLAGS_DATA_IN | SRB_FLAGS_NO_QUEUE_FREEZE;

    srb.OriginalRequest = irp;

    //
    // Set timeout to requested value.
    //

    srb.TimeOutValue = srbControl->Timeout;

    //
    // Set the data buffer.
    //

    srb.DataBuffer = srbControl;
    srb.DataTransferLength = length;

    //
    // Flush the data buffer for output. This will insure that the data is
    // written back to memory.  Since the data-in flag is the the port driver
    // will flush the data again for input which will ensure the data is not
    // in the cache.
    //

    KeFlushIoBuffers(irp->MdlAddress, FALSE, TRUE);

    //
    // Call port driver to handle this request.
    //

    IoCallDriver(logicalUnit->DeviceObject, irp);

    //
    // Wait for request to complete.
    //

    KeWaitForSingleObject(&event,
                          Executive,
                          KernelMode,
                          FALSE,
                          NULL);

    //
    // Set the information length to the smaller of the output buffer length
    // and the length returned in the srb.
    //

    RequestIrp->IoStatus.Information = srb.DataTransferLength > outputLength ?
        outputLength : srb.DataTransferLength;

    RequestIrp->IoStatus.Status = ioStatusBlock.Status;

    UnrefLogicalUnitExtensionWithTag (
        DeviceExtension,
        logicalUnit,
        RequestIrp
        );

    return RequestIrp->IoStatus.Status;
}

NTSTATUS
IdeGetInquiryData(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp
    )

/*++

Routine Description:

    This functions copies the inquiry data to the system buffer.  The data
    is translate from the port driver's internal format to the user mode
    format.

Arguments:

    DeviceExtension - Supplies a pointer the SCSI adapter device extension.

    Irp - Supplies a pointer to the Irp which made the original request.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/

{
    PUCHAR bufferStart;
    PIO_STACK_LOCATION irpStack;
    PSCSI_ADAPTER_BUS_INFO  adapterInfo;
    PSCSI_BUS_DATA busData;
    PSCSI_INQUIRY_DATA inquiryData;
    ULONG inquiryDataSize;
    ULONG length;
    ULONG numberOfBuses;
    ULONG numberOfLus;
    ULONG j;
    PLOGICAL_UNIT_EXTENSION logUnitExtension;
    IDE_PATH_ID pathId;

    PAGED_CODE();

    DebugPrint((3,"IdeGetInquiryData: Enter routine\n"));

    //
    // Get a pointer to the control block.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    bufferStart = Irp->AssociatedIrp.SystemBuffer;

    numberOfBuses = MAX_IDE_BUS;

    // this number could be changing...
	// but we would always fill in the right info for the numLus.
    numberOfLus = DeviceExtension->NumberOfLogicalUnits;

    //
    // Caculate the size of the logical unit structure and round it to a word
    // alignment.
    //

    inquiryDataSize = ((sizeof(SCSI_INQUIRY_DATA) - 1 + INQUIRYDATABUFFERSIZE +
        sizeof(ULONG) - 1) & ~(sizeof(ULONG) - 1));

    // Based on the number of buses and logical unit, determine the minimum
    // buffer length to hold all of the data.
    //

    length = sizeof(SCSI_ADAPTER_BUS_INFO) +
        (numberOfBuses - 1) * sizeof(SCSI_BUS_DATA);
    length += inquiryDataSize * numberOfLus;

    if (irpStack->Parameters.DeviceIoControl.OutputBufferLength < length) {

        Irp->IoStatus.Status = STATUS_BUFFER_TOO_SMALL;
        return(STATUS_BUFFER_TOO_SMALL);
    }

    //
    // zero out the buffer so that we don't return uninitialized
    // memory
    //
    RtlZeroMemory(bufferStart, length);

    //
    // Set the information field.
    //

    Irp->IoStatus.Information = length;

    //
    // Fill in the bus information.
    //

    adapterInfo = (PSCSI_ADAPTER_BUS_INFO) bufferStart;

    adapterInfo->NumberOfBuses = (UCHAR) numberOfBuses;
    inquiryData = (PSCSI_INQUIRY_DATA)(bufferStart + sizeof(SCSI_ADAPTER_BUS_INFO) +
        (numberOfBuses - 1) * sizeof(SCSI_BUS_DATA));

    for (j = 0; j < numberOfBuses; j++) {

        busData = &adapterInfo->BusData[j];
        busData->NumberOfLogicalUnits = 0;
        busData->InitiatorBusId = IDE_PSUEDO_INITIATOR_ID;

        //
        // Copy the data for the logical units.
        //
        busData->InquiryDataOffset = (ULONG)((PUCHAR) inquiryData - bufferStart);

        pathId.l = 0;
        pathId.b.Path = j;
        while (logUnitExtension = NextLogUnitExtensionWithTag (
                                      DeviceExtension,
                                      &pathId,
                                      TRUE,
                                      Irp
                                      )) {

            INQUIRYDATA InquiryData;
            NTSTATUS status;

            if (pathId.b.Path != j) {

                UnrefLogicalUnitExtensionWithTag (
                    DeviceExtension,
                    logUnitExtension,
                    Irp
                    );
                break;
            }

            inquiryData->PathId                 = logUnitExtension->PathId;
            inquiryData->TargetId               = logUnitExtension->TargetId;
            inquiryData->Lun                    = logUnitExtension->Lun;
            inquiryData->DeviceClaimed          = (BOOLEAN) (logUnitExtension->PdoState & PDOS_DEVICE_CLIAMED);
            inquiryData->InquiryDataLength      = INQUIRYDATABUFFERSIZE;
            inquiryData->NextInquiryDataOffset  = (ULONG)((PUCHAR) inquiryData +
                                                      inquiryDataSize - bufferStart);

            status = IssueInquirySafe(logUnitExtension->ParentDeviceExtension, logUnitExtension, &InquiryData, FALSE);

            if (NT_SUCCESS(status) || (status == STATUS_DATA_OVERRUN)) {

                RtlCopyMemory(
                    inquiryData->InquiryData,
                    &InquiryData,
                    INQUIRYDATABUFFERSIZE
                    );
            }

            inquiryData = (PSCSI_INQUIRY_DATA) ((PCHAR) inquiryData + inquiryDataSize);

            UnrefLogicalUnitExtensionWithTag (
                DeviceExtension,
                logUnitExtension,
                Irp
                );

            busData->NumberOfLogicalUnits++;

            if (busData->NumberOfLogicalUnits >= (UCHAR) numberOfLus) {
                break;
            }
        }

        //
        // Fix up the last entry of the list.
        //

        if (busData->NumberOfLogicalUnits == 0) {

            busData->InquiryDataOffset = 0;

        } else {

            ((PSCSI_INQUIRY_DATA) ((PCHAR) inquiryData - inquiryDataSize))->
                NextInquiryDataOffset = 0;
        }
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return(STATUS_SUCCESS);
}

NTSTATUS
IdeSendScsiPassThrough (
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP RequestIrp,
    IN BOOLEAN Direct
    )
/*++

Routine Description;

    Validates the scsi pass through structure and invokes 
    IdeSendValidScsiPassThru to service the request.
    
Arguments:

    DeviceExtension : Fdo Extension.
    RequestIrp      : The irp containing the scsi pass through request
    
Return Value:

    The irp's io status
            
--*/
{
    PIO_STACK_LOCATION     irpStack;
    NTSTATUS               status;
    UCHAR pathId;
    UCHAR targetId;
    UCHAR lun;

    PAGED_CODE();

    status = PortGetPassThroughAddress (RequestIrp,
                                        &pathId,
                                        &targetId,
                                        &lun
                                        );

    if (NT_SUCCESS(status)) {

        PLOGICAL_UNIT_EXTENSION logicalUnit;

        //
        // If this request came through a normal device control rather than from
        // class driver then the device must exist and be unclaimed. Class drivers
        // will set the minor function code for the device control.  It is always
        // zero for a user request.
        //
        logicalUnit = RefLogicalUnitExtensionWithTag(DeviceExtension,
                                              pathId,
                                              targetId,
                                              lun,
                                              FALSE,
                                              RequestIrp
                                              );

        if (logicalUnit) {

            irpStack = IoGetCurrentIrpStackLocation(RequestIrp);

            if (irpStack->MinorFunction == 0) {

                if (logicalUnit->PdoState & PDOS_DEVICE_CLIAMED) {

                    UnrefLogicalUnitExtensionWithTag(
                        DeviceExtension,
                        logicalUnit,
                        RequestIrp
                        );

                    logicalUnit = NULL;
                }
            }
        }

        if (logicalUnit != NULL) {

            status = PortSendPassThrough( logicalUnit->DeviceObject,
                                          RequestIrp, 
                                          Direct, 
                                          0, 
                                          &DeviceExtension->Capabilities 
                                          );

            UnrefLogicalUnitExtensionWithTag(
                DeviceExtension,
                logicalUnit,
                RequestIrp
                );

        } else {

            status = STATUS_INVALID_PARAMETER;
        }
    }

    return status;
}

VOID
SyncAtaPassThroughCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context,
    IN NTSTATUS       Status
    )
{
    PSYNC_ATA_PASSTHROUGH_CONTEXT context = Context;

    context->Status = Status;

    KeSetEvent (&context->Event, 0, FALSE);

}

//
// <= DISPATCH_LEVEL
//
NTSTATUS
IssueAsyncAtaPassThroughSafe (
    IN PFDO_EXTENSION        DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION  LogUnitExtension,
    IN OUT PATA_PASS_THROUGH    AtaPassThroughData,
    IN BOOLEAN                  DataIn,
    IN ASYNC_PASS_THROUGH_COMPLETION Completion,
    IN PVOID                         CallerContext,
    IN BOOLEAN                  PowerRelated,
    IN ULONG                    TimeOut,
    IN BOOLEAN                    MustSucceed
)
{
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    IO_STATUS_BLOCK ioStatusBlock;
    KIRQL currentIrql;
    NTSTATUS status;
    PSCSI_REQUEST_BLOCK srb;
    PSENSE_DATA senseInfoBuffer;
    ULONG             totalBufferSize;

    PATA_PASSTHROUGH_CONTEXT context;
    PENUMERATION_STRUCT enumStruct;

    status = STATUS_UNSUCCESSFUL;

    senseInfoBuffer = NULL;
    srb = NULL;
    irp = NULL;

    if (MustSucceed) {

        enumStruct = DeviceExtension->PreAllocEnumStruct;

        if (enumStruct == NULL) {
            ASSERT (DeviceExtension->PreAllocEnumStruct);

            //
            // Fall back to the usual course of action
            //
            MustSucceed=FALSE;
        } else {

            context = enumStruct->Context;

            ASSERT (context);

            senseInfoBuffer = enumStruct->SenseInfoBuffer;

            ASSERT (senseInfoBuffer);

            srb = enumStruct->Srb;

            ASSERT (srb);

            totalBufferSize = FIELD_OFFSET(ATA_PASS_THROUGH, DataBuffer) + AtaPassThroughData->DataBufferSize;

            irp = enumStruct->Irp1;

            ASSERT (irp);

            //
            // this irp has always a stack size of 1. Use the same
            // stack size when initializing the irp.
            //
            IoInitializeIrp(irp, 
                            IoSizeOfIrp(PREALLOC_STACK_LOCATIONS),
                            PREALLOC_STACK_LOCATIONS);

            irp->MdlAddress = enumStruct->MdlAddress;

            ASSERT (enumStruct->DataBufferSize >= totalBufferSize);
            RtlCopyMemory(enumStruct->DataBuffer, AtaPassThroughData, totalBufferSize);
        }
    } 

    if (!MustSucceed) {

        context = ExAllocatePool(NonPagedPool, sizeof (ATA_PASSTHROUGH_CONTEXT));

        if (context == NULL) {
            DebugPrint((1,"IssueAsyncAtaPassThrough: Can't allocate context buffer\n"));

            IdeLogNoMemoryError(DeviceExtension,
                                LogUnitExtension->TargetId,
                                NonPagedPool,
                                sizeof(ATA_PASSTHROUGH_CONTEXT),
                                (IDEPORT_TAG_ATAPASS_CONTEXT+AtaPassThroughData->IdeReg.bCommandReg)
                                );

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto GetOut;
        }

        senseInfoBuffer = ExAllocatePool( NonPagedPoolCacheAligned, SENSE_BUFFER_SIZE);

        if (senseInfoBuffer == NULL) {
            DebugPrint((1,"IssueAsyncAtaPassThrough: Can't allocate request sense buffer\n"));

            IdeLogNoMemoryError(DeviceExtension,
                                LogUnitExtension->TargetId,
                                NonPagedPoolCacheAligned,
                                SENSE_BUFFER_SIZE,
                                (IDEPORT_TAG_ATAPASS_SENSE+AtaPassThroughData->IdeReg.bCommandReg)
                                );

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto GetOut;
        }

        srb = ExAllocatePool (NonPagedPool, sizeof (SCSI_REQUEST_BLOCK));
        if (srb == NULL) {
            DebugPrint((1,"IssueAsyncAtaPassThrough: Can't SRB\n"));

            IdeLogNoMemoryError(DeviceExtension,
                                LogUnitExtension->TargetId,
                                NonPagedPool,
                                sizeof(SCSI_REQUEST_BLOCK),
                                (IDEPORT_TAG_ATAPASS_SRB+AtaPassThroughData->IdeReg.bCommandReg)
                                );

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto GetOut;
        }

        totalBufferSize = FIELD_OFFSET(ATA_PASS_THROUGH, DataBuffer) + AtaPassThroughData->DataBufferSize;

        //
        // Build IRP for this request.
        //
        irp = IoAllocateIrp (
                  (CCHAR) (LogUnitExtension->DeviceObject->StackSize),
                  FALSE
                  );
        if (irp == NULL) {

            IdeLogNoMemoryError(DeviceExtension,
                                LogUnitExtension->TargetId, 
                                NonPagedPool,
                                IoSizeOfIrp(LogUnitExtension->DeviceObject->StackSize),
                                (IDEPORT_TAG_ATAPASS_IRP+AtaPassThroughData->IdeReg.bCommandReg)
                                );

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto GetOut;
        }

        irp->MdlAddress = IoAllocateMdl( AtaPassThroughData,
                                         totalBufferSize,
                                         FALSE,
                                         FALSE,
                                         (PIRP) NULL );
        if (irp->MdlAddress == NULL) {

            IdeLogNoMemoryError(DeviceExtension,
                                LogUnitExtension->TargetId,
                                NonPagedPool,
                                totalBufferSize,
                                (IDEPORT_TAG_ATAPASS_MDL+AtaPassThroughData->IdeReg.bCommandReg)
                                );

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto GetOut;
        }

        MmBuildMdlForNonPagedPool(irp->MdlAddress);

    }


    irpStack = IoGetNextIrpStackLocation(irp);
    irpStack->MajorFunction = IRP_MJ_SCSI;

    //
    // Fill in SRB fields.
    //

    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    irpStack->Parameters.Scsi.Srb = srb;

    srb->PathId      = LogUnitExtension->PathId;
    srb->TargetId    = LogUnitExtension->TargetId;
    srb->Lun         = LogUnitExtension->Lun;

    if (PowerRelated) {

        srb->Function = SRB_FUNCTION_ATA_POWER_PASS_THROUGH;
        srb->QueueSortKey = MAXULONG;
    } else {

        srb->Function = SRB_FUNCTION_ATA_PASS_THROUGH;
        srb->QueueSortKey = 0;
    }
    srb->Length = sizeof(SCSI_REQUEST_BLOCK);

    //
    // Set flags to disable synchronous negociation.
    //
    srb->SrbFlags  = SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;
    srb->SrbFlags |= DataIn ? 0 : SRB_FLAGS_DATA_OUT;

    if (AtaPassThroughData->IdeReg.bReserved & ATA_PTFLAGS_URGENT) {

        srb->SrbFlags |= SRB_FLAGS_BYPASS_FROZEN_QUEUE;
    }

    srb->SrbStatus = srb->ScsiStatus = 0;

    srb->NextSrb = 0;

    srb->OriginalRequest = irp;

    //
    // Set timeout to 15 seconds.
    //
    srb->TimeOutValue = TimeOut;

    srb->CdbLength = 6;

    //
    // Enable auto request sense.
    //

    srb->SenseInfoBuffer = senseInfoBuffer;
    srb->SenseInfoBufferLength = SENSE_BUFFER_SIZE;

    srb->DataBuffer = MmGetMdlVirtualAddress(irp->MdlAddress);
    srb->DataTransferLength = totalBufferSize;

    IoSetCompletionRoutine(
        irp,
        AtaPassThroughCompletionRoutine,
        context,
        TRUE,
        TRUE,
        TRUE
        );


    context->DeviceObject     = LogUnitExtension->DeviceObject;
    context->CallerCompletion = Completion;
    context->CallerContext    = CallerContext;
    context->SenseInfoBuffer  = senseInfoBuffer;
    context->Srb              = srb;
    context->MustSucceed      = MustSucceed? 1 : 0;
    context->DataBuffer       = AtaPassThroughData;

    //
    // send the pass through irp
    //
    status = IoCallDriver(LogUnitExtension->DeviceObject, irp);

    //
    // always return STATUS_PENDING when we actually send out the irp
    //
    return STATUS_PENDING;

GetOut:

    ASSERT (!MustSucceed);

    if (context) {

        ExFreePool (context);
    }

    if (senseInfoBuffer) {

        ExFreePool (senseInfoBuffer);
    }

    if (srb) {

        ExFreePool (srb);
    }

    if (irp && irp->MdlAddress) {

        IoFreeMdl (irp->MdlAddress);
    }

    if (irp) {

        IoFreeIrp( irp );
    }

    return status;

} // IssueAtaPassThrough

NTSTATUS
IssueSyncAtaPassThroughSafe (
    IN PFDO_EXTENSION        DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION  LogUnitExtension,
    IN OUT PATA_PASS_THROUGH    AtaPassThroughData,
    IN BOOLEAN                  DataIn,
    IN BOOLEAN                  PowerRelated,
    IN ULONG                    TimeOut,
    IN BOOLEAN                    MustSucceed
)
{
    NTSTATUS                     status;
    SYNC_ATA_PASSTHROUGH_CONTEXT context;
    ULONG retryCount=10;
    ULONG locked;


    status=STATUS_INSUFFICIENT_RESOURCES;

    if (MustSucceed) {

        //Lock
        ASSERT(InterlockedCompareExchange(&(DeviceExtension->EnumStructLock), 1, 0) == 0);

    }


    while ((status == STATUS_UNSUCCESSFUL || status == STATUS_INSUFFICIENT_RESOURCES) && retryCount--) {

        //
        // Initialize the notification event.
        //

        KeInitializeEvent(&context.Event,
                          NotificationEvent,
                          FALSE);

        status = IssueAsyncAtaPassThroughSafe (
                        DeviceExtension,
                        LogUnitExtension,
                        AtaPassThroughData,
                        DataIn,
                        SyncAtaPassThroughCompletionRoutine,
                        &context,
                        PowerRelated,
                        TimeOut,
                        MustSucceed
                        );


        if (status == STATUS_PENDING) {

            KeWaitForSingleObject(&context.Event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
            status=context.Status;
        }

        if (status == STATUS_UNSUCCESSFUL) {
            DebugPrint((1, "Retrying flushed request\n"));
        }
    }

    if (MustSucceed) {
        //Unlock
        ASSERT(InterlockedCompareExchange(&(DeviceExtension->EnumStructLock), 0, 1) == 1);
    }

    if (NT_SUCCESS(status)) {

        return context.Status;

    } else {

        return status;
    }
}

NTSTATUS
AtaPassThroughCompletionRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )
{
    PATA_PASSTHROUGH_CONTEXT context = Context;
    PATA_PASS_THROUGH ataPassThroughData;



    DebugPrint((1, "AtaPassThroughCompletionRoutine: Irp = 0x%x status=%x\n", 
                    Irp, Irp->IoStatus.Status));

    if (context->Srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {

        PLOGICAL_UNIT_EXTENSION logicalUnit;
        KIRQL currentIrql;

        DebugPrint((1, "AtaPassThroughCompletionRoutine: Unfreeze Queue TID %d\n",
            context->Srb->TargetId));

        logicalUnit = context->DeviceObject->DeviceExtension;

        ASSERT (logicalUnit);
        CLRMASK (logicalUnit->LuFlags, PD_QUEUE_FROZEN);

        KeAcquireSpinLock(&logicalUnit->ParentDeviceExtension->SpinLock, &currentIrql);
        GetNextLuRequest(logicalUnit->ParentDeviceExtension, logicalUnit);
        KeLowerIrql(currentIrql);
    }

    ataPassThroughData = (PATA_PASS_THROUGH) context->Srb->DataBuffer;
    if (ataPassThroughData->IdeReg.bReserved & ATA_PTFLAGS_OK_TO_FAIL) {
        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    if (context->MustSucceed) {
        RtlCopyMemory(context->DataBuffer, 
                      context->Srb->DataBuffer, context->Srb->DataTransferLength);
        DebugPrint((1, "AtaCompletionSafe: Device =%x, Status= %x, SrbStatus=%x\n",
                        context->Srb->TargetId,  Irp->IoStatus.Status, context->Srb->SrbStatus));
    }

    if (context->CallerCompletion) {

        context->CallerCompletion (context->DeviceObject, context->CallerContext, Irp->IoStatus.Status);
    }

    if (context->MustSucceed) {
        return STATUS_MORE_PROCESSING_REQUIRED;
    }

    ExFreePool (context->SenseInfoBuffer);
    ExFreePool (context->Srb);
    ExFreePool (context);

    if (Irp->MdlAddress) {

        IoFreeMdl (Irp->MdlAddress);
    }

    IoFreeIrp (Irp);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
IdeClaimLogicalUnit(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function finds the specified device in the logical unit information
    and either updates the device object point or claims the device.  If the
    device is already claimed, then the request fails.  If the request succeeds,
    then the current device object is returned in the data buffer pointer
    of the SRB.

Arguments:

    DeviceExtension - Supplies a pointer the SCSI adapter device extension.

    Irp - Supplies a pointer to the Irp which made the original request.

Return Value:

    Returns the status of the operation.  Either success, no device or busy.

--*/

{
    KIRQL currentIrql;
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;
    PDEVICE_OBJECT saveDevice;
    PPDO_EXTENSION pdoExtension;
	PVOID	sectionHandle;
    PAGED_CODE();

    //
    // Get SRB address from current IRP stack.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);

    srb = (PSCSI_REQUEST_BLOCK) irpStack->Parameters.Others.Argument1;

    pdoExtension = IDEPORT_GET_LUNEXT_IN_IRP (irpStack);
    ASSERT (pdoExtension);

#ifdef ALLOC_PRAGMA
    sectionHandle = MmLockPagableCodeSection(IdeClaimLogicalUnit);
#endif

    //
    // Lock the data.
    //
    KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

    if (srb->Function == SRB_FUNCTION_RELEASE_DEVICE) {

        CLRMASK (pdoExtension->PdoState, PDOS_DEVICE_CLIAMED | PDOS_LEGACY_ATTACHER);

        KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);
        srb->SrbStatus = SRB_STATUS_SUCCESS;

#ifdef ALLOC_PRAGMA
    MmUnlockPagableImageSection(sectionHandle);
#endif
        return(STATUS_SUCCESS);
    }

    //
    // Check for a claimed device.
    //

    if (pdoExtension->PdoState & PDOS_DEVICE_CLIAMED) {

        KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);
        srb->SrbStatus = SRB_STATUS_BUSY;

#ifdef ALLOC_PRAGMA
    MmUnlockPagableImageSection(sectionHandle);
#endif
        return(STATUS_DEVICE_BUSY);
    }

    //
    // Save the current device object.
    //

    saveDevice = pdoExtension->AttacherDeviceObject;

    //
    // Update the lun information based on the operation type.
    //

    if (srb->Function == SRB_FUNCTION_CLAIM_DEVICE) {

        pdoExtension->PdoState |= PDOS_DEVICE_CLIAMED;
    }

    if (srb->Function == SRB_FUNCTION_ATTACH_DEVICE) {
        pdoExtension->AttacherDeviceObject = srb->DataBuffer;
    }

    srb->DataBuffer = saveDevice;

    if (irpStack->DeviceObject == pdoExtension->ParentDeviceExtension->DeviceObject) {

        //
        // The original irp is sent to the parent.  The attacher must
        // be legacy class driver.  We can never do pnp remove safely.
        //
        pdoExtension->PdoState |= PDOS_LEGACY_ATTACHER;
    }

    KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);
    srb->SrbStatus = SRB_STATUS_SUCCESS;

#ifdef ALLOC_PRAGMA
    MmUnlockPagableImageSection(sectionHandle);
#endif

    return(STATUS_SUCCESS);
}

NTSTATUS
IdeRemoveDevice(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp
    )

/*++

Routine Description:

    This function finds the specified device in the logical unit information
    and deletes it. This is done in preparation for a failing device to be
    physically removed from a SCSI bus. An assumption is that the system
    utility controlling the device removal has locked the volumes so there
    is no outstanding IO to this device.

Arguments:

    DeviceExtension - Supplies a pointer the SCSI adapter device extension.

    Irp - Supplies a pointer to the Irp which made the original request.

Return Value:

    Returns the status of the operation.  Either success or no device.

--*/

{
    KIRQL currentIrql;
    PPDO_EXTENSION pdoExtension;
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;
    NTSTATUS status;

    PAGED_CODE();

    // ISSUE:2000/02/11 : need to test this

    //
    // Get SRB address from current IRP stack.
    //

    irpStack = IoGetCurrentIrpStackLocation(Irp);


    srb = (PSCSI_REQUEST_BLOCK) irpStack->Parameters.Others.Argument1;

    srb->SrbStatus = SRB_STATUS_NO_DEVICE;
    status = STATUS_DEVICE_DOES_NOT_EXIST;

    pdoExtension = RefLogicalUnitExtensionWithTag(
                       DeviceExtension,
                       srb->PathId,
                       srb->TargetId,
                       srb->Lun,
                       FALSE,
                       IdeRemoveDevice
                       );
    if (pdoExtension) {

        DebugPrint((1, "IdeRemove device removing Pdo %x\n", pdoExtension));
        status = FreePdoWithTag (pdoExtension, TRUE, TRUE, IdeRemoveDevice);

        if (NT_SUCCESS(status)) {

            srb->SrbStatus = SRB_STATUS_SUCCESS;
        }
    }
    return status;
}

VOID
IdeMiniPortTimerDpc(
    IN struct _KDPC *Dpc,
    IN PVOID DeviceObject,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    )
/*++

Routine Description:

    This routine calls the miniport when its requested timer fires.
    It interlocks either with the port spinlock and the interrupt object.

Arguments:

    Dpc - Unsed.

    DeviceObject - Supplies a pointer to the device object for this adapter.

    SystemArgument1 - Unused.

    SystemArgument2 - Unused.

Return Value:

    None.

--*/

{
    PFDO_EXTENSION deviceExtension = ((PDEVICE_OBJECT) DeviceObject)->DeviceExtension;

    //
    // Acquire the port spinlock.
    //

    KeAcquireSpinLockAtDpcLevel(&deviceExtension->SpinLock);

    //
    // Make sure the timer routine is still desired.
    //

    if (deviceExtension->HwTimerRequest != NULL) {

        KeSynchronizeExecution (
            deviceExtension->InterruptObject,
            (PKSYNCHRONIZE_ROUTINE) deviceExtension->HwTimerRequest,
            deviceExtension->HwDeviceExtension
            );

    }

    //
    // Release the spinlock.
    //

    KeReleaseSpinLockFromDpcLevel(&deviceExtension->SpinLock);

    //
    // Check for miniport work requests. Note this is an unsynchonized
    // test on a bit that can be set by the interrupt routine; however,
    // the worst that can happen is that the completion DPC checks for work
    // twice.
    //

    if (deviceExtension->InterruptData.InterruptFlags & PD_NOTIFICATION_REQUIRED) {

        //
        // Call the completion DPC directly.
        //

        IdePortCompletionDpc( NULL,
                               deviceExtension->DeviceObject,
                               NULL,
                               NULL);

    }
}

NTSTATUS
IdePortFlushLogicalUnit (
    PFDO_EXTENSION          FdoExtension,
    PLOGICAL_UNIT_EXTENSION LogUnitExtension,
    BOOLEAN                 Forced
)
{
    NTSTATUS             status;
    PIO_STACK_LOCATION   irpStack;
    PSCSI_REQUEST_BLOCK  srb;
    PKDEVICE_QUEUE_ENTRY packet;
    KIRQL                currentIrql;
    PIRP                 nextIrp;
    PIRP                 listIrp;
    PIRP                 powerRelatedIrp;

    //
    // Acquire the spinlock to protect the flags structure and the saved
    // interrupt context.
    //

    KeAcquireSpinLock(&FdoExtension->SpinLock, &currentIrql);

    //
    // Make sure the queue is frozen.
    //

    if ((!(LogUnitExtension->LuFlags & PD_QUEUE_FROZEN)) && (!Forced)) {

        DebugPrint((1,"IdePortFlushLogicalUnit:  Request to flush an unfrozen queue!\n"));

        KeReleaseSpinLock(&FdoExtension->SpinLock, currentIrql);
        status = STATUS_INVALID_DEVICE_REQUEST;

    } else {

        listIrp = NULL;
        powerRelatedIrp = NULL;

        //
        // The queue may not be busy so we have to use the IfBusy variant.  
        // Use a zero key to pull items from the head of it (if any are there)
        //
        while ((packet =
                KeRemoveByKeyDeviceQueueIfBusy(
                    &(LogUnitExtension->DeviceObject->DeviceQueue),
                    0))
            != NULL) {

            nextIrp = CONTAINING_RECORD(packet, IRP, Tail.Overlay.DeviceQueueEntry);

            //
            // Get the srb.
            //

            irpStack = IoGetCurrentIrpStackLocation(nextIrp);
            srb = irpStack->Parameters.Scsi.Srb;

            if (srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH) {

                ASSERT (!powerRelatedIrp);
                powerRelatedIrp = nextIrp;
                continue;
            }

            //
            // Set the status code.
            //

            srb->SrbStatus = SRB_STATUS_REQUEST_FLUSHED;
            nextIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

            //
            // Link the requests. They will be completed after the
            // spinlock is released.
            //

            nextIrp->Tail.Overlay.ListEntry.Flink = (PLIST_ENTRY)
                listIrp;
            listIrp = nextIrp;
        }


        //
        // clear the pending reuqest blocked by busy device
        //
        if ((LogUnitExtension->LuFlags & PD_LOGICAL_UNIT_IS_BUSY) &&
            (LogUnitExtension->BusyRequest)) {

            nextIrp = LogUnitExtension->BusyRequest;
            irpStack = IoGetCurrentIrpStackLocation(nextIrp);
            srb = irpStack->Parameters.Scsi.Srb;

            LogUnitExtension->BusyRequest = NULL;
            CLRMASK (LogUnitExtension->LuFlags, PD_LOGICAL_UNIT_IS_BUSY);

            if (srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH) {

                ASSERT (!powerRelatedIrp);
                powerRelatedIrp = nextIrp;

            } else {

                srb->SrbStatus = SRB_STATUS_REQUEST_FLUSHED;
                nextIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

                nextIrp->Tail.Overlay.ListEntry.Flink = (PLIST_ENTRY)
                    listIrp;
                listIrp = nextIrp;
            }
        }

        if (LogUnitExtension->PendingRequest) {

            nextIrp = LogUnitExtension->PendingRequest;
            LogUnitExtension->PendingRequest = NULL;

            irpStack = IoGetCurrentIrpStackLocation(nextIrp);
            srb = irpStack->Parameters.Scsi.Srb;

            if (srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH) {

                ASSERT (!powerRelatedIrp);
                powerRelatedIrp = nextIrp;

            } else {

                srb->SrbStatus = SRB_STATUS_REQUEST_FLUSHED;
                nextIrp->IoStatus.Status = STATUS_UNSUCCESSFUL;

                nextIrp->Tail.Overlay.ListEntry.Flink = (PLIST_ENTRY)
                    listIrp;
                listIrp = nextIrp;
            }
        }

        //
        // Mark the queue as unfrozen.  Since all the requests have
        // been removed and the device queue is no longer busy, it
        // is effectively unfrozen.
        //

        CLRMASK (LogUnitExtension->LuFlags, PD_QUEUE_FROZEN);

        //
        // Release the spinlock.
        //

        KeReleaseSpinLock(&FdoExtension->SpinLock, currentIrql);

        if (powerRelatedIrp) {

            PDEVICE_OBJECT deviceObject = LogUnitExtension->DeviceObject;

            DebugPrint ((DBG_POWER, "Resending power related pass through reuqest 0x%x\n", powerRelatedIrp));

            UnrefPdoWithTag(
                LogUnitExtension,
                powerRelatedIrp
                );

            IdePortDispatch(
                deviceObject,
                powerRelatedIrp
                );
        }

        //
        // Complete the flushed requests.
        //

        while (listIrp != NULL) {

            nextIrp = listIrp;
            listIrp = (PIRP) nextIrp->Tail.Overlay.ListEntry.Flink;

            UnrefLogicalUnitExtensionWithTag(
                FdoExtension,
                LogUnitExtension,
                nextIrp
                );

            IoCompleteRequest(nextIrp, 0);
        }

        status = STATUS_SUCCESS;
    }

    return status;
}


PVOID
IdeMapLockedPagesWithReservedMapping (
	IN PFDO_EXTENSION 	DeviceExtension,
	IN PSRB_DATA		SrbData,
	IN PMDL	    	  	Mdl
	)
/*++

Routine Description:

    This routine attempts to map the physical pages represented by the supplied
    MDL using the adapter's reserved page range.

Arguments:

    DeviceExtension - Points to the FDO extension

	SrbData - Points to SrbData structure for this request

    Mdl     - Points to an MDL that describes the physical range we
              are tring to map.

Return Value:

    Kernel VA of the mapped pages if mapped successfully.

    NULL if the reserved page range is too small or if the pages are 
    not successfully mapped.

    -1 if the reserved pages are already in use.

Notes:

    This routine is called with the spinlock held.

--*/
{
	ULONG_PTR	numberOfPages;
	PVOID		startingVa;
	PVOID		systemAddress;

	//
	// Check if the reserve pages are already in use
	//
	if (DeviceExtension->Flags & PD_RESERVED_PAGES_IN_USE) {

		DebugPrint((1,
					"Reserve pages in use...\n"
					));

		return (PVOID)-1;
	}

	startingVa = (PVOID)((PCHAR)Mdl->StartVa + Mdl->ByteOffset);
	numberOfPages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(startingVa, Mdl->ByteCount);

	if (numberOfPages > IDE_NUM_RESERVED_PAGES) {

		systemAddress = NULL;

	} else {

		//
		// The reserved range is large enough to map all the pages.  Go ahead
		// and try to map them.  Since we are specifying MmCached as cache 
		// type and we've ensured that we have enough reserved pages to
		// cover the request, this should never fail.
		//
		systemAddress = MmMapLockedPagesWithReservedMapping (DeviceExtension->ReservedPages, 
															 'PedI', 
															 Mdl, 
															 MmCached );

		if (systemAddress == NULL) {

			DebugPrint((1,
						"mapping failed....\n"
						));

			ASSERT(systemAddress);

		} else {

			DebugPrint((1,
						"mapping....\n"
						));

			//
			// We need this flag to verify if the reserved pages are already
			// in use. The per request srbData flag is not available to make 
			// this check
			//
			ASSERT(!(DeviceExtension->Flags & PD_RESERVED_PAGES_IN_USE));
			SETMASK(DeviceExtension->Flags, PD_RESERVED_PAGES_IN_USE);


			//
			// we need this flag to unmap the pages. The flag in the
			// device extension cannot be relied upon as it might indicate
			// the flags for the next request
			//
			ASSERT(!(SrbData->Flags & SRB_DATA_RESERVED_PAGES));
			SETMASK(SrbData->Flags, SRB_DATA_RESERVED_PAGES);

		}
	}

	return systemAddress;

}

VOID
IdeUnmapReservedMapping (
	IN PFDO_EXTENSION 	DeviceExtension,
	IN PSRB_DATA		SrbData,
	IN PMDL	  			Mdl
	)
/*++

Routine Description :

	Unmap the physical pages represented by the Mdl
	
Arguments:

	DeviceExtension: The Fdo extension
	
	Mdl:	Mdl for the request
	
Return Value:

	No return value
	
Notes:

	This routine is called with the spinlock held			

--*/
{
	DebugPrint((1,
				"Unmapping....\n"
				));

	ASSERT(DeviceExtension->Flags & PD_RESERVED_PAGES_IN_USE);
	CLRMASK(DeviceExtension->Flags, PD_RESERVED_PAGES_IN_USE);

	ASSERT(SrbData->Flags & SRB_DATA_RESERVED_PAGES);
	CLRMASK(SrbData->Flags, SRB_DATA_RESERVED_PAGES);

	MmUnmapReservedMapping (
		DeviceExtension->ReservedPages,
		'PedI',
		Mdl
		);
}

#ifdef LOG_GET_NEXT_CALLER

VOID
IdeLogCompletedCommand(
    PFDO_EXTENSION FdoExtension,
    PSCSI_REQUEST_BLOCK Srb
    )
{
    ULONG index = FdoExtension->CompletedCommandIndex;

    RtlCopyMemory(&(FdoExtension->CompletedCommandQueue[index].Srb),
                  Srb,
                  sizeof(SCSI_REQUEST_BLOCK)
                  );

    FdoExtension->CompletedCommandIndex = 
        (FdoExtension->CompletedCommandIndex + 1) % GET_NEXT_LOG_LENGTH;

    return;

}

VOID
IdeLogGetNextLuCaller (
    PFDO_EXTENSION FdoExtension,
    PPDO_EXTENSION PdoExtension,
    PUCHAR FileName,
    ULONG LineNumber
    )
/*++

Routine Description:

    Temporary routine to log the last few GetNextLuRequest caller. This
    routine was added to catch a bug where we fail to process further
    requests on an LU
    
Arguments:

Return Value:

    None.

--*/    
{
    ULONG index = FdoExtension->GetNextLuIndex;

    FdoExtension->GetNextLuCallerLineNumber[index] = LineNumber;

    strncpy (FdoExtension->GetNextLuCallerFileName[index], FileName, 255);

    FdoExtension->GetNextLuCallerFlags[index] = PdoExtension->LuFlags;

    FdoExtension->GetNextLuIndex = 
        (FdoExtension->GetNextLuIndex + 1) % GET_NEXT_LOG_LENGTH;

    return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\init.h ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    init.h

Abstract:

--*/

#if !defined (___INIT_H___)
#define ___INIT_H___

NTSTATUS
IdePortInitFdo(
    IN OUT PFDO_EXTENSION  FdoExtension
);


NTSTATUS
IssueSyncAtapiCommandSafe (
    IN PFDO_EXTENSION   FdoExtension,
    IN PPDO_EXTENSION   PdoExtension,
    IN PCDB             Cdb,
    IN PVOID            DataBuffer,
    IN ULONG            DataBufferSize,
    IN BOOLEAN          DataIn,
    IN ULONG            RetryCount,
    IN BOOLEAN          ByPassBlockedQueue
);

NTSTATUS
SyncAtapiSafeCompletion (
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp,
    PVOID          Context
);

BOOLEAN
IdePortDmaCdromDrive(
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension,
    IN BOOLEAN       LowMem
);

NTSTATUS
IssueInquirySafe(
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension,
    OUT PINQUIRYDATA InquiryData,
    IN BOOLEAN          LowMem
);

NTSTATUS
IssueSyncAtapiCommand (
    IN PFDO_EXTENSION   FdoExtension,
    IN PPDO_EXTENSION   PdoExtension,
    IN PCDB             Cdb,
    IN PVOID            DataBuffer,
    IN ULONG            DataBufferSize,
    IN BOOLEAN          DataIn,
    IN ULONG            RetryCount,
    IN BOOLEAN          ByPassBlockedQueue
);
  
ULONG
IdePortQueryNonCdNumLun (
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension,
    IN BOOLEAN ByPassBlockedQueue
);

VOID
IdeBusScan(
    IN PFDO_EXTENSION FdoExtension
);

VOID
IdeBuildDeviceMap(
    IN PFDO_EXTENSION FdoExtension,
    IN PUNICODE_STRING ServiceKey
);

NTSTATUS
IdeCreateNumericKey(
    IN  HANDLE  Root,
    IN  ULONG   Name,
    IN  PWSTR   Prefix,
    OUT PHANDLE NewKey
);
                       
#endif // ___INIT_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\ideport.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ideport.h
//
//--------------------------------------------------------------------------

#if !defined (___IDEPORT_H___)
#define ___IDEPORT_H___

#include "stddef.h"
#include "stdarg.h"
#include "stdio.h"
#include "string.h"
#include "ntddk.h"
#include "scsi.h"
#include <ntddscsi.h>
#include <ntdddisk.h>
#include <string.h>
#include "stdio.h"
#include "safeboot.h"
#include "portlib.h"

#ifdef ACPI_CONTROL_METHOD_SUPPORT
//
// for ACPI
//
#include "acpiioct.h"
#endif // ACPI_CONTROL_METHOD_SUPPORT

#include "idep.h"

//
// predefine structure pointer type to prevent 
// constant re-ordering of include files
//              
typedef struct _FDO_EXTENSION * PFDO_EXTENSION;
typedef struct _PDO_EXTENSION * PPDO_EXTENSION;
typedef struct _DEVICE_SETTINGS * PDEVICE_SETTINGS;
typedef struct _IDENTIFY_DATA * PIDENTIFY_DATA;
typedef struct _IDE_DEVICE_TYPE IDE_DEVICE_TYPE;

#include "acpiutil.h"
#include "hack.h"
#include "port.h"
#include "init.h"
#include "chanfdo.h"
#include "detect.h"
#include "atapi.h"
#include "devpdo.h"
#include "regutils.h"
#include "atapinit.h"
#include "luext.h"
#include "fdopower.h"
#include "pdopower.h"
#include "crashdmp.h"
#include "idedata.h"
#include "wmi.h"
#include "passthru.h"

//
// Location Identifiers used to log allocation failures
//
#define IDEPORT_TAG_DISPATCH_FLUSH          0x10
#define IDEPORT_TAG_DISPATCH_RESET          0x20
#define IDEPORT_TAG_STARTIO_MDL             0x30
#define IDEPORT_TAG_MPIOCTL_IRP             0x40
#define IDEPORT_TAG_PASSTHRU_SENSE          0x50
#define IDEPORT_TAG_PASSTHRU_IRP            0x60
#define IDEPORT_TAG_DUMP_POINTER            0x70
#define IDEPORT_TAG_READCAP_CONTEXT         0x80
#define IDEPORT_TAG_READCAP_MDL             0x90
#define IDEPORT_TAG_SYNCATAPI_IRP           0x100 //+0xff - IDE commands
#define IDEPORT_TAG_SYNCATAPI_SENSE         0x110
#define IDEPORT_TAG_ATAPASS_IRP             0x200
#define IDEPORT_TAG_ATAPASS_MDL             0x300
#define IDEPORT_TAG_ATAPASS_SRB             0x400
#define IDEPORT_TAG_ATAPASS_SENSE           0x500
#define IDEPORT_TAG_ATAPASS_CONTEXT         0x600
#define IDEPORT_TAG_ATAPI_MODE_SENSE        0x700
#define IDEPORT_TAG_SEND_IRP                0x800

#ifdef POOL_TAGGING
#ifdef ExAllocatePool
#undef ExAllocatePool
#endif
#define ExAllocatePool(a,b) ExAllocatePoolWithTag(a,b,'PedI')
#endif

#define INLINE __inline

#if DBG

void _DebugPrintTickCount (LARGE_INTEGER * lastTickCount, ULONG limit, PUCHAR filename, ULONG lineNumber);
void _DebugPrintResetTickCount(LARGE_INTEGER * lastTickCount);


static LARGE_INTEGER FindDeviceTimer = {0, 0};

#define DebugPrintTickCount(lastTickCount, limit)     _DebugPrintTickCount (&lastTickCount, limit, __FILE__, __LINE__)
#define DebugPrintResetTickCount(lastTickCount)       { lastTickCount.QuadPart = 0; _DebugPrintResetTickCount(&lastTickCount); }

#else

#define DebugPrintTickCount(lastTickCount, limit)
#define DebugPrintResetTickCount(lastTickCount)

#endif

#if 0
extern PVOID GlobalPdoPtr;

#if DBG

#ifdef IoCompleteRequest
#undef IoCompleteRequest
#endif

#define IoCompleteRequest(irp, boost) {\
                ULONG i; \
                PPDO_EXTENSION globalPdoExtension=(PPDO_EXTENSION)GlobalPdoPtr;\
                if (globalPdoExtension) {\
                    for (i=0;i<globalPdoExtension->NumTagUsed;i++) {\
                        if (globalPdoExtension->TagTable[i]==irp) {\
                            DebugPrint((0, "Irp %x failed\n", irp));\
                            ASSERT(FALSE);\
                        }\
                    }\
                }\
                IofCompleteRequest(irp, boost);}
#endif

#endif

extern PDRIVER_DISPATCH FdoPowerDispatchTable[NUM_POWER_MINOR_FUNCTION];
extern PDRIVER_DISPATCH PdoPowerDispatchTable[NUM_POWER_MINOR_FUNCTION];

typedef struct _IDEDRIVER_EXTENSION {

    UNICODE_STRING RegistryPath;

} IDEDRIVER_EXTENSION, *PIDEDRIVER_EXTENSION;

typedef struct _CUSTOM_DEVICE_PARAMETER {

    ULONG   CommandRegisterBase;
    ULONG   IrqLevel;

}CUSTOM_DEVICE_PARAMETER, *PCUSTOM_DEVICE_PARAMETER;



#define FULL_RESOURCE_LIST_SIZE(n) (sizeof (CM_FULL_RESOURCE_DESCRIPTOR) + (sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR) * (n - 1)))

#define IDE_PSUEDO_INITIATOR_ID     (0xff)

ULONG
DriverEntry(
    IN OUT PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS
IdePortDispatchDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortDispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortDispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortDispatchSystemControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortNoSupportIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortNoSupportPnpIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortAlwaysStatusSuccessIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortPassDownToNextDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortStatusSuccessAndPassDownToNextDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

VOID
IdePortParseDeviceParameters(
    IN     HANDLE                   SubServiceKey,
    IN OUT PCUSTOM_DEVICE_PARAMETER CustomDeviceParameter
    );

PCSTR
IdePortGetDeviceTypeString (
    IN ULONG DeviceType
    );

PCSTR
IdePortGetCompatibleIdString (
    IN ULONG DeviceType
    );

PCSTR
IdePortGetPeripheralIdString (
    IN ULONG DeviceType
    );

BOOLEAN
IdePortChannelEmpty (
    PIDE_REGISTERS_1 CmdRegBase,
    PIDE_REGISTERS_2 CtrlRegBase,
    ULONG            MaxIdeDevice
);

VOID
IdePortUnload(
    IN PDRIVER_OBJECT DriverObject
    );

NTSTATUS
IdePortQueryInterface (
    PFDO_EXTENSION      FdoExtension,
    PIO_STACK_LOCATION  IrpSp
    );

NTSTATUS
IdePortQueryInterfaceCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

BOOLEAN
IdePortOkToDetectLegacy (
    IN PDRIVER_OBJECT DriverObject
);

BOOLEAN 
IdePortSearchDeviceInRegMultiSzList (
    IN PFDO_EXTENSION  FdoExtension,
    IN PIDENTIFY_DATA  IdentifyData,
    IN PWSTR           RegKeyValue
);

NTSTATUS
IdePortSyncSendIrp (
    IN PDEVICE_OBJECT TargetDeviceObject,
    IN PIO_STACK_LOCATION IrpSp,
    IN OUT OPTIONAL PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
IdePortGenericCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

ULONG
IdePortSimpleCheckSum (
    IN ULONG                PartialSum,
    IN PVOID                SourceVa,
    IN ULONG                Length
    );

VOID
FASTCALL
IdeFreeIrpAndMdl(
    IN PIRP Irp
    );

NTSTATUS
FASTCALL
IdeBuildAndSendIrp (
    IN PPDO_EXTENSION PdoExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PIO_COMPLETION_ROUTINE CompletionRoutine,
    IN PVOID CompletionContext
    );

BOOLEAN
IdePortInSetup(
    IN PFDO_EXTENSION FdoExtension
    );

typedef struct _IDE_DEVICE_TYPE {

    PCSTR DeviceTypeString;

    PCSTR CompatibleIdString;

    PCSTR PeripheralIdString;

} IDE_DEVICE_TYPE, * PIDE_DEVICE_TYPE;

#define DRIVER_OBJECT_EXTENSION_ID  DriverEntry

typedef struct _COMPLETION_ROUTINE_CONTEXT {

    KEVENT Event;
    IO_STATUS_BLOCK IoStatus;

} COMPLETION_ROUTINE_CONTEXT, *PCOMPLETION_ROUTINE_CONTEXT;



typedef struct _ENUMERATION_STRUCT {
    PIRP Irp1;
    PSCSI_REQUEST_BLOCK Srb;
    PSENSE_DATA SenseInfoBuffer;
    PMDL        MdlAddress;

    //
    // DataBuffer to hold the input/output
    // buffers
    //
    PULONG DataBuffer;
    ULONG DataBufferSize;

    PPDO_STOP_QUEUE_CONTEXT StopQContext;

    //
    // Pre-Alloced Enum work item
    //
    PVOID EnumWorkItemContext;

    PATA_PASSTHROUGH_CONTEXT Context;

}ENUMERATION_STRUCT, *PENUMERATION_STRUCT;

#define PREALLOC_STACK_LOCATIONS    1

BOOLEAN
IdePreAllocEnumStructs (
    IN PFDO_EXTENSION FdoExtension
);

VOID
IdeFreeEnumStructs(
    PENUMERATION_STRUCT enumStruct
);


//
// FDO list structure and support functions.
//

typedef struct _IDE_FDO_LIST {
    ULONG Count;
    LIST_ENTRY List;
    KSPIN_LOCK SpinLock;
} IDE_FDO_LIST, *PIDE_FDO_LIST;

extern IDE_FDO_LIST IdeGlobalFdoList;

VOID
IdeInitializeFdoList(
    IN PIDE_FDO_LIST FdoList
    );

VOID
IdeAddToFdoList (
    PIDE_FDO_LIST FdoList,
    PFDO_EXTENSION FdoExtension
    );

VOID
IdeRemoveFromFdoList (
    PIDE_FDO_LIST FdoList,
    PFDO_EXTENSION FdoExtension
    );

//
// test code on/off switch
//       
// always comment this define out before check in
//#define PRIVATE_BUILD

#ifdef PRIVATE_BUILD

#define HUNG_CONTROLLER_CHECK       1

#else 

#undef HUNG_CONTROLLER_CHECK

#endif // PRIVATE_BUILD

//#if DBG
//#define PoStartNextPowerIrp(x) {\
//    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation (x);\
//    DebugPrint ((0, "PoStartNextPowerIrp(0x%x) for devobj 0x%x\n", x, irpStack->DeviceObject));\
//    PoStartNextPowerIrp(x);\
//    }
//#endif //DBG

//
// define this if we want NT4 scsiport DriverParameter support in the registry
// default is "not defined"
//#define DRIVER_PARAMETER_REGISTRY_SUPPORT


#endif // ___IDEPORT_H___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\init.c ===
/*++

Copyright (C) 1990 - 99  Microsoft Corporation

Module Name:

    port.c

Abstract:

    Ide bus enumeration

Authors:

    Mike Glass
    Jeff Havens
    Joe Dai

Environment:

    kernel mode only

Revision History:

--*/

#include "ideport.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(NONPAGE, IssueSyncAtapiCommand)
#pragma alloc_text(NONPAGE, IssueSyncAtapiCommandSafe)
#pragma alloc_text(NONPAGE, IdePortDmaCdromDrive)
//#pragma alloc_text(PAGESCAN, IdePortDmaCdromDrive)

#pragma alloc_text(PAGE, IdePortInitFdo)
#pragma alloc_text(PAGE, IssueInquirySafe)
#pragma alloc_text(PAGE, IdePortQueryNonCdNumLun)
#pragma alloc_text(PAGE, IdeBuildDeviceMap)
#pragma alloc_text(PAGE, IdeCreateNumericKey)

extern LONG IdePAGESCANLockCount;
#endif

static PWCHAR IdePortUserRegistryDeviceTypeName[MAX_IDE_DEVICE * MAX_IDE_LINE] = {
    USER_MASTER_DEVICE_TYPE_REG_KEY,
    USER_SLAVE_DEVICE_TYPE_REG_KEY,
    USER_MASTER_DEVICE_TYPE2_REG_KEY,
    USER_SLAVE_DEVICE_TYPE2_REG_KEY
};

static PWCHAR IdePortRegistryUserDeviceTimingModeAllowedName[MAX_IDE_DEVICE * MAX_IDE_LINE] = {
    USER_MASTER_DEVICE_TIMING_MODE_ALLOWED,
    USER_SLAVE_DEVICE_TIMING_MODE_ALLOWED,
    USER_MASTER_DEVICE_TIMING_MODE_ALLOWED2,
    USER_SLAVE_DEVICE_TIMING_MODE_ALLOWED2
};

//
// Idle Timeout
//
//ULONG PdoConservationIdleTime = -1;
//ULONG PdoPerformanceIdleTime = -1;

NTSTATUS
IdePortInitFdo(
    IN OUT PFDO_EXTENSION  FdoExtension
    )
/*++

Routine Description:

    This routine enumerates the IDE bus and initialize the fdo extension

Arguments:

    FdoExtension - FDO extension

    RegistryPath - registry path passed in via DriverEntry

Return Value:

--*/

{
    PFDO_EXTENSION        fdoExtension = FdoExtension;
    NTSTATUS              status;
    PDEVICE_OBJECT        deviceObject;
    ULONG                 uniqueId;
    KIRQL                 irql;
    PIO_SCSI_CAPABILITIES capabilities;
    PIO_ERROR_LOG_PACKET  errorLogEntry;
    ULONG                 i;
    ULONG                 j;
    BOOLEAN               ideDeviceFound;


    status = STATUS_SUCCESS;
    deviceObject = fdoExtension->DeviceObject;

    //
    // Save the dependent driver routines in the device extension.
    //

    fdoExtension->HwDeviceExtension = (PVOID)(fdoExtension + 1);

    //
    // Mark this object as supporting direct I/O so that I/O system
    // will supply mdls in irps.
    //

    deviceObject->Flags |= DO_DIRECT_IO;

    //
    // Initialize the maximum lu count variable.
    //

    fdoExtension->MaxLuCount = SCSI_MAXIMUM_LOGICAL_UNITS;

    //
    // Allocate spin lock for critical sections.
    //

    KeInitializeSpinLock(&fdoExtension->SpinLock);


    //
    // Spinlock that protects LogicalUnitList manipulation
    //
    KeInitializeSpinLock(&fdoExtension->LogicalUnitListSpinLock);

    //
    // Initialize DPC routine.
    //

    IoInitializeDpcRequest(deviceObject, IdePortCompletionDpc);

    //
    // Initialize the port timeout counter.
    //

    fdoExtension->PortTimeoutCounter = PD_TIMER_STOPPED;

    //
    // Initialize timer.
    //

    IoInitializeTimer(deviceObject, IdePortTickHandler, NULL);

    //
    // Initialize miniport timer and timer DPC.
    //

    KeInitializeTimer(&fdoExtension->MiniPortTimer);
    KeInitializeDpc(&fdoExtension->MiniPortTimerDpc,
                    IdeMiniPortTimerDpc,
                    deviceObject );

    //
    // Start timer. Request timeout counters
    // in the logical units have already been
    // initialized.
    //
    IoStartTimer(deviceObject);
    fdoExtension->Flags |= PD_DISCONNECT_RUNNING;

    //
    // Check to see if an error was logged.
    //

    if (fdoExtension->InterruptData.InterruptFlags & PD_LOG_ERROR) {

        CLRMASK (fdoExtension->InterruptData.InterruptFlags, PD_LOG_ERROR | PD_NOTIFICATION_REQUIRED);
        LogErrorEntry(fdoExtension,
                      &fdoExtension->InterruptData.LogEntry);
    }

    //
    // Initialize the capabilities pointer.
    //

    capabilities = &fdoExtension->Capabilities;

    //
    // Initailize the capabilities structure.
    //

    capabilities->Length = sizeof(IO_SCSI_CAPABILITIES);

    if (fdoExtension->BoundWithBmParent) {

        if (fdoExtension->HwDeviceExtension->BusMasterInterface.MaxTransferByteSize <
            MAX_TRANSFER_SIZE_PER_SRB) {

            capabilities->MaximumTransferLength =
                fdoExtension->HwDeviceExtension->BusMasterInterface.MaxTransferByteSize;

        } else {

            capabilities->MaximumTransferLength =
                MAX_TRANSFER_SIZE_PER_SRB;
        }
    } else {

        capabilities->MaximumTransferLength = MAX_TRANSFER_SIZE_PER_SRB;
    }

    capabilities->TaggedQueuing = FALSE;
    capabilities->AdapterScansDown = FALSE;
    capabilities->AlignmentMask = deviceObject->AlignmentRequirement;
    capabilities->MaximumPhysicalPages = BYTES_TO_PAGES(capabilities->MaximumTransferLength);

    if (fdoExtension->IdeResource.TranslatedCommandBaseAddress) {
        DebugPrint((1,
                   "IdePort: Initialize: Translated IO Base address %x\n",
                   fdoExtension->IdeResource.TranslatedCommandBaseAddress));
    }

    for (i=0; i< MAX_IDE_DEVICE * MAX_IDE_LINE; i++) {

        fdoExtension->UserChoiceDeviceType[i] = DeviceUnknown;
        IdePortGetDeviceParameter (
            fdoExtension,
            IdePortUserRegistryDeviceTypeName[i],
            (PULONG)(fdoExtension->UserChoiceDeviceType + i)
            );

    }

    //
    // the acpi _GTM buffer should be initialized with -1s
    //
    for (i=0; i<MAX_IDE_DEVICE; i++) {

        PACPI_IDE_TIMING timingSettings = &(FdoExtension->BootAcpiTimingSettings);
        timingSettings->Speed[i].Pio = ACPI_XFER_MODE_NOT_SUPPORT;
        timingSettings->Speed[i].Dma = ACPI_XFER_MODE_NOT_SUPPORT;
    }

    fdoExtension->DmaDetectionLevel = DdlFirmwareOk;
    IdePortGetDeviceParameter (
        fdoExtension,
        DMA_DETECTION_LEVEL_REG_KEY,
        (PULONG)&fdoExtension->DmaDetectionLevel
        );

    //
    // non-pcmcia controller, MayHaveSlaveDevice is always set
    // if pcmcia controller, it is not set unless 
    // registry flag PCMCIA_IDE_CONTROLLER_HAS_SLAVE
    // is non-zero
    //
    if (!ChannelQueryPcmciaParent (fdoExtension)) {
    
        fdoExtension->MayHaveSlaveDevice = 1;
        
    } else {
    
        fdoExtension->MayHaveSlaveDevice = 0;
        IdePortGetDeviceParameter (
            fdoExtension,
            PCMCIA_IDE_CONTROLLER_HAS_SLAVE,
            (PULONG)&fdoExtension->MayHaveSlaveDevice
            );
    }

#ifdef ENABLE_ATAPI_VERIFIER
    ViIdeInitVerifierSettings(fdoExtension);
#endif
                         
    return status;

} // IdePortInitFdo


NTSTATUS
SyncAtapiSafeCompletion (
    PDEVICE_OBJECT DeviceObject,
    PIRP           Irp,
    PVOID          Context
    )
{
    PSYNC_ATA_PASSTHROUGH_CONTEXT context = Context;

    context->Status = Irp->IoStatus.Status;

    KeSetEvent (&context->Event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
IssueSyncAtapiCommandSafe (
    IN PFDO_EXTENSION   FdoExtension,
    IN PPDO_EXTENSION   PdoExtension,
    IN PCDB             Cdb,
    IN PVOID            DataBuffer,
    IN ULONG            DataBufferSize,
    IN BOOLEAN          DataIn,
    IN ULONG            RetryCount,
    IN BOOLEAN          ByPassBlockedQueue

)
/*++

Routine Description:

    Build IRP, SRB and CDB for the given CDB

    Send and wait for the IRP to complete

Arguments:

    FdoExtension - FDO extension

    PdoExtension - device extension of the PDO to which the command is sent

    Cdb - Command Descriptor Block

    DataBuffer - data buffer for the command

    DataBufferSize - byte size of DataBuffer

    DataIn - TRUE is the command causes the device to return data

    RetryCount - number of times to retry the command if the command fails

Return Value:

    NTSTATUS

    If any of the pre-alloc related operation fails, it returns STATUS_INSUFFICIENT_RESOURCES
    The caller should take care of the condition

--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    PSCSI_REQUEST_BLOCK srb;
    KEVENT event;
    IO_STATUS_BLOCK ioStatusBlock;
    KIRQL currentIrql;
    NTSTATUS status;
    ULONG flushCount;

    PSENSE_DATA senseInfoBuffer;
    UCHAR senseInfoBufferSize;
    PENUMERATION_STRUCT enumStruct;
    SYNC_ATA_PASSTHROUGH_CONTEXT context;
    ULONG locked;

    ASSERT(InterlockedCompareExchange(&(FdoExtension->EnumStructLock), 1, 0) == 0);

    enumStruct=FdoExtension->PreAllocEnumStruct;

    if (enumStruct == NULL) {
        ASSERT(FdoExtension->PreAllocEnumStruct);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    senseInfoBufferSize = SENSE_BUFFER_SIZE;
    senseInfoBuffer = enumStruct->SenseInfoBuffer;

    ASSERT (senseInfoBuffer);

    DebugPrint((1, "Using Sync Atapi safe!\n"));

    srb= enumStruct->Srb;

    ASSERT(srb);

    status = STATUS_UNSUCCESSFUL;
    RetryCount = 5;
    flushCount = 100;
    irp = enumStruct->Irp1;


    ASSERT (irp);

    ASSERT (enumStruct->DataBufferSize >= DataBufferSize);

    while (!NT_SUCCESS(status) && RetryCount--) {

        //
        // Initialize the notification event.
        //

        KeInitializeEvent(&context.Event,
                          NotificationEvent,
                          FALSE);

        IoInitializeIrp(irp,
                        IoSizeOfIrp(PREALLOC_STACK_LOCATIONS),
                        PREALLOC_STACK_LOCATIONS);

        irp->MdlAddress = enumStruct->MdlAddress;

        irpStack = IoGetNextIrpStackLocation(irp);
        irpStack->MajorFunction = IRP_MJ_SCSI;

        if (DataBuffer) {
            RtlCopyMemory(enumStruct->DataBuffer, DataBuffer, DataBufferSize);
        }
        RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

        irpStack->Parameters.Scsi.Srb = srb;

        srb->PathId      = PdoExtension->PathId;
        srb->TargetId    = PdoExtension->TargetId;
        srb->Lun         = PdoExtension->Lun;

        srb->Function = SRB_FUNCTION_EXECUTE_SCSI;
        srb->Length = sizeof(SCSI_REQUEST_BLOCK);

        //
        // Set flags to disable synchronous negociation.
        //

        srb->SrbFlags = DataIn ? SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER :
                                SRB_FLAGS_DATA_OUT | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;


        if (ByPassBlockedQueue) {
            srb->SrbFlags |= SRB_FLAGS_BYPASS_FROZEN_QUEUE;
        }

        srb->SrbStatus = srb->ScsiStatus = 0;

        srb->NextSrb = 0;

        srb->OriginalRequest = irp;

        //
        // Set timeout to 4 seconds.
        //

        srb->TimeOutValue = 4;

        srb->CdbLength = 6;

        //
        // Enable auto request sense.
        //

        srb->SenseInfoBuffer = senseInfoBuffer;
        srb->SenseInfoBufferLength = senseInfoBufferSize;

        srb->DataBuffer = MmGetMdlVirtualAddress(irp->MdlAddress);
        srb->DataTransferLength = DataBufferSize;

        //
        // Set CDB operation code.
        //
        RtlCopyMemory(srb->Cdb, Cdb, sizeof(CDB));

        IoSetCompletionRoutine(
            irp,
            SyncAtapiSafeCompletion,
            &context,
            TRUE,
            TRUE,
            TRUE
            );

        //
        // Wait for request to complete.
        //
        if (IoCallDriver(PdoExtension->DeviceObject, irp) == STATUS_PENDING) {

            KeWaitForSingleObject(&context.Event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }

        RtlCopyMemory(DataBuffer, srb->DataBuffer, DataBufferSize);

        if (SRB_STATUS(srb->SrbStatus) != SRB_STATUS_SUCCESS) {

            DebugPrint((1,"IssueSyncAtapiCommand: atapi command failed SRB status %x\n",
                        srb->SrbStatus));

            if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_REQUEST_FLUSHED) {
            
                //
                // we will give it a few more retries if our request
                // got flushed.
                //                                 
                flushCount--;
                if (flushCount) {
                    RetryCount++;  
                }
            }
            
            if (SRB_STATUS(srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

                status = STATUS_DATA_OVERRUN;

            } else {

                status = STATUS_UNSUCCESSFUL;
                
            }

            //
            // Unfreeze queue if necessary
            //

            if (srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) {

                DebugPrint((3, "IssueSyncAtapiCommand: Unfreeze Queue TID %d\n",
                    srb->TargetId));

                //
                // unfreeze queue
                //
                CLRMASK (PdoExtension->LuFlags, PD_QUEUE_FROZEN);

                //
                // restart queue
                //
                KeAcquireSpinLock(&FdoExtension->SpinLock, &currentIrql);
                GetNextLuRequest(FdoExtension, PdoExtension);
                KeLowerIrql(currentIrql);
            }

            if ((srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&
                (senseInfoBuffer->SenseKey == SCSI_SENSE_ILLEGAL_REQUEST)) {

                 //
                 // A sense key of illegal request was recieved.  This indicates
                 // that the mech status command is illegal.
                 //

                 status = STATUS_INVALID_DEVICE_REQUEST;

                 //
                 // The command is illegal, no point to keep trying
                 //
                 RetryCount = 0;
            }

        } else {

            status = STATUS_SUCCESS;
        }
    }

    if (flushCount != 100) {
        DebugPrint ((DBG_ALWAYS, "IssueSyncAtapiCommand: flushCount is %u\n", flushCount));
    }

    //
    // Unlock
    //
    ASSERT(InterlockedCompareExchange(&(FdoExtension->EnumStructLock), 0, 1) == 1);

    return status;

} // IssueSyncAtapiCommandSafe

BOOLEAN
IdePortDmaCdromDrive(
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension,
    IN BOOLEAN       LowMem
    )
/*++

Routine Description:

    Build IRP, SRB and CDB for SCSI MODE_SENSE10 command.

Arguments:

    DeviceExtension - address of adapter's device object extension.
    LowMem - Low memory condition, use the safe (but not thread-safe) version
           - This should be one only when called during enumeration.

Return Value:

    NTSTATUS

--*/
{
    CDB  cdb;
    NTSTATUS status;
    BOOLEAN isDVD = FALSE;
    ULONG bufLength;
    ULONG capPageOffset;
    PMODE_PARAMETER_HEADER10 modePageHeader;
    PCDVD_CAPABILITIES_PAGE capPage;

/*
    //
    // Code is paged until locked down.
    //
	PAGED_CODE();

#ifdef ALLOC_PRAGMA
	ASSERT(IdePAGESCANLockCount > 0);
#endif
*/

    RtlZeroMemory(&cdb, sizeof(CDB));

    bufLength = sizeof(CDVD_CAPABILITIES_PAGE) +
                sizeof(MODE_PARAMETER_HEADER10);

    capPageOffset = sizeof(MODE_PARAMETER_HEADER10);

    cdb.MODE_SENSE10.OperationCode = SCSIOP_MODE_SENSE10;
    cdb.MODE_SENSE10.Dbd = 1;
    cdb.MODE_SENSE10.PageCode = MODE_PAGE_CAPABILITIES;
    cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR)(bufLength >> 8);
    cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR)(bufLength >> 0);

    modePageHeader = ExAllocatePool(NonPagedPoolCacheAligned,
                                           bufLength);

    if (modePageHeader) {

        RtlZeroMemory(modePageHeader, bufLength);

        if (LowMem) {
            status = IssueSyncAtapiCommandSafe (
                         FdoExtension,
                         PdoExtension,
                         &cdb,
                         modePageHeader,
                         bufLength,
                         TRUE,
                         INQUIRY_RETRY_COUNT,
                         TRUE
                         );
        } else {
            status = IssueSyncAtapiCommand (
                         FdoExtension,
                         PdoExtension,
                         &cdb,
                         modePageHeader,
                         bufLength,
                         TRUE,
                         INQUIRY_RETRY_COUNT,
                         TRUE
                         );
        }

        if (NT_SUCCESS(status) ||
			(status == STATUS_DATA_OVERRUN)) {

            capPage = (PCDVD_CAPABILITIES_PAGE) (((PUCHAR) modePageHeader) + capPageOffset);

            if ((capPage->PageCode == MODE_PAGE_CAPABILITIES) &&
                (capPage->CDRWrite || capPage->CDEWrite ||
                 capPage->DVDROMRead || capPage->DVDRRead ||
                 capPage->DVDRAMRead || capPage->DVDRWrite ||
                 capPage->DVDRAMWrite)) {

                isDVD=TRUE;
            }
        }
        ExFreePool (modePageHeader);
    }

    return isDVD;
} 


NTSTATUS
IssueInquirySafe(
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension,
    OUT PINQUIRYDATA InquiryData,
    IN BOOLEAN       LowMem
    )
/*++

Routine Description:

    Build IRP, SRB and CDB for SCSI INQUIRY command.

Arguments:

    DeviceExtension - address of adapter's device object extension.
    LunInfo - address of buffer for INQUIRY information.
    LowMem - Low memory condition, use the safe (but not thread-safe) version
           - This should be one only when called during enumeration.

Return Value:

    NTSTATUS

--*/
{
    CDB  cdb;
    NTSTATUS status;

    PAGED_CODE();

    RtlZeroMemory(InquiryData, sizeof(*InquiryData));

    RtlZeroMemory(&cdb, sizeof(CDB));

    cdb.CDB6INQUIRY.OperationCode = SCSIOP_INQUIRY;

    //
    // Set CDB LUN.
    //

    cdb.CDB6INQUIRY.LogicalUnitNumber = PdoExtension->Lun;
    cdb.CDB6INQUIRY.Reserved1 = 0;

    //
    // Set allocation length to inquiry data buffer size.
    //

    cdb.CDB6INQUIRY.AllocationLength = INQUIRYDATABUFFERSIZE;

    //
    // Zero reserve field and
    // Set EVPD Page Code to zero.
    // Set Control field to zero.
    // (See SCSI-II Specification.)
    //

    cdb.CDB6INQUIRY.PageCode = 0;
    cdb.CDB6INQUIRY.IReserved = 0;
    cdb.CDB6INQUIRY.Control = 0;

    if (LowMem ) {

        // Use the memory safe one
        status = IssueSyncAtapiCommandSafe (
                     FdoExtension,
                     PdoExtension,
                     &cdb,
                     InquiryData,
                     INQUIRYDATABUFFERSIZE,
                     TRUE,
                     INQUIRY_RETRY_COUNT,
                     FALSE
                     );
    } else {

        // Use the thread safe one
        status = IssueSyncAtapiCommand (
                     FdoExtension,
                     PdoExtension,
                     &cdb,
                     InquiryData,
                     INQUIRYDATABUFFERSIZE,
                     TRUE,
                     INQUIRY_RETRY_COUNT,
                     FALSE
                     );
    }

    return status;

} // IssueInquiry

NTSTATUS
IssueSyncAtapiCommand (
    IN PFDO_EXTENSION   FdoExtension,
    IN PPDO_EXTENSION   PdoExtension,
    IN PCDB             Cdb,
    IN PVOID            DataBuffer,
    IN ULONG            DataBufferSize,
    IN BOOLEAN          DataIn,
    IN ULONG            RetryCount,
    IN BOOLEAN          ByPassBlockedQueue

)
/*++

Routine Description:

    Build IRP, SRB and CDB for the given CDB

    Send and wait for the IRP to complete

Arguments:

    FdoExtension - FDO extension

    PdoExtension - device extension of the PDO to which the command is sent

    Cdb - Command Descriptor Block

    DataBuffer - data buffer for the command

    DataBufferSize - byte size of DataBuffer

    DataIn - TRUE is the command causes the device to return data

    RetryCount - number of times to retry the command if the command fails

Return Value:

    NTSTATUS

--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    SCSI_REQUEST_BLOCK srb;
    KEVENT event;
    IO_STATUS_BLOCK ioStatusBlock;
    KIRQL currentIrql;
    NTSTATUS status;
    ULONG flushCount;

    PSENSE_DATA senseInfoBuffer;
    UCHAR senseInfoBufferSize;


    //
    // Sense buffer is in non-paged pool.
    //

    senseInfoBufferSize = SENSE_BUFFER_SIZE;
    senseInfoBuffer = ExAllocatePool( NonPagedPoolCacheAligned, senseInfoBufferSize);

    if (senseInfoBuffer == NULL) {
        DebugPrint((1,"IssueSyncAtapiCommand: Can't allocate request sense buffer\n"));
        IdeLogNoMemoryError(FdoExtension,
                            PdoExtension->TargetId,
                            NonPagedPoolCacheAligned,
                            senseInfoBufferSize,
                            IDEPORT_TAG_SYNCATAPI_SENSE
                            );

        return(STATUS_INSUFFICIENT_RESOURCES);
    }

    status = STATUS_UNSUCCESSFUL;
    RetryCount = 5;
    flushCount = 100;
    while (!NT_SUCCESS(status) && RetryCount--) {

        //
        // Initialize the notification event.
        //

        KeInitializeEvent(&event,
                          NotificationEvent,
                          FALSE);

        //
        // Build IRP for this request.
        //
        irp = IoBuildDeviceIoControlRequest(
                    DataIn ? IOCTL_SCSI_EXECUTE_IN : IOCTL_SCSI_EXECUTE_OUT,
                    FdoExtension->DeviceObject,
                    DataBuffer,
                    DataBufferSize,
                    DataBuffer,
                    DataBufferSize,
                    TRUE,
                    &event,
                    &ioStatusBlock);

        if (!irp) {

            RetryCount = 0;
            IdeLogNoMemoryError(FdoExtension,
                                PdoExtension->TargetId, 
                                NonPagedPool,
                                IoSizeOfIrp(FdoExtension->DeviceObject->StackSize),
                                IDEPORT_TAG_SYNCATAPI_IRP
                                );

            status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        irpStack = IoGetNextIrpStackLocation(irp);

        //
        // Fill in SRB fields.
        //

        RtlZeroMemory(&srb, sizeof(SCSI_REQUEST_BLOCK));

        irpStack->Parameters.Scsi.Srb = &srb;

        srb.PathId      = PdoExtension->PathId;
        srb.TargetId    = PdoExtension->TargetId;
        srb.Lun         = PdoExtension->Lun;

        srb.Function = SRB_FUNCTION_EXECUTE_SCSI;
        srb.Length = sizeof(SCSI_REQUEST_BLOCK);

        //
        // Set flags to disable synchronous negociation.
        //

        srb.SrbFlags = DataIn ? SRB_FLAGS_DATA_IN | SRB_FLAGS_DISABLE_SYNCH_TRANSFER :
                                SRB_FLAGS_DATA_OUT | SRB_FLAGS_DISABLE_SYNCH_TRANSFER;

        if (ByPassBlockedQueue) {
            srb.SrbFlags |= SRB_FLAGS_BYPASS_FROZEN_QUEUE;
        }

        srb.SrbStatus = srb.ScsiStatus = 0;

        srb.NextSrb = 0;

        srb.OriginalRequest = irp;

        //
        // Set timeout to 4 seconds.
        //

        srb.TimeOutValue = 4;

        srb.CdbLength = 6;

        //
        // Enable auto request sense.
        //

        srb.SenseInfoBuffer = senseInfoBuffer;
        srb.SenseInfoBufferLength = senseInfoBufferSize;

        srb.DataBuffer = MmGetMdlVirtualAddress(irp->MdlAddress);
        srb.DataTransferLength = DataBufferSize;

        //
        // Set CDB operation code.
        //
        RtlCopyMemory(srb.Cdb, Cdb, sizeof(CDB));

        //
        // Wait for request to complete.
        //
        if (IoCallDriver(PdoExtension->DeviceObject, irp) == STATUS_PENDING) {

            KeWaitForSingleObject(&event,
                                  Executive,
                                  KernelMode,
                                  FALSE,
                                  NULL);
        }

        if (SRB_STATUS(srb.SrbStatus) != SRB_STATUS_SUCCESS) {

            DebugPrint((1,"IssueSyncAtapiCommand: atapi command failed SRB status %x\n",
                        srb.SrbStatus));

            if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_REQUEST_FLUSHED) {
            
                //
                // we will give it a few more retries if our request
                // got flushed.
                //                                 
                flushCount--;
                if (flushCount) {
                    RetryCount++;  
                }
            }
            
            if (SRB_STATUS(srb.SrbStatus) == SRB_STATUS_DATA_OVERRUN) {

                status = STATUS_DATA_OVERRUN;

            } else {

                status = STATUS_UNSUCCESSFUL;
                
//                if (SRB_STATUS(srb.SrbStatus) != SRB_STATUS_REQUEST_FLUSHED) {
//                    if (srb.Lun == 0 && Cdb->CDB6INQUIRY.OperationCode == SCSIOP_INQUIRY) {
//                        DebugPrint ((DBG_ALWAYS, "IssueSyncAtapiCommand: inquiry on lun 0 returned unexpected error: srb, status = 0x%x, 0x%x\n", &srb, srb.SrbStatus));
//                        DbgBreakPoint();
//                    }
//                }
            }

            //
            // Unfreeze queue if necessary
            //

            if (srb.SrbStatus & SRB_STATUS_QUEUE_FROZEN) {

                DebugPrint((3, "IssueSyncAtapiCommand: Unfreeze Queue TID %d\n",
                    srb.TargetId));

                //
                // unfreeze queue
                //
                CLRMASK (PdoExtension->LuFlags, PD_QUEUE_FROZEN);

                //
                // restart queue
                //
                KeAcquireSpinLock(&FdoExtension->SpinLock, &currentIrql);
                GetNextLuRequest(FdoExtension, PdoExtension);
                KeLowerIrql(currentIrql);
            }

            if ((srb.SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&
                (senseInfoBuffer->SenseKey == SCSI_SENSE_ILLEGAL_REQUEST)) {

                 //
                 // A sense key of illegal request was recieved.  This indicates
                 // that the mech status command is illegal.
                 //

                 status = STATUS_INVALID_DEVICE_REQUEST;

                 //
                 // The command is illegal, no point to keep trying
                 //
                 RetryCount = 0;
            }

        } else {

            status = STATUS_SUCCESS;
        }
    }

    //
    // Free buffers
    //

    ExFreePool(senseInfoBuffer);
    
    if (flushCount != 100) {
        DebugPrint ((DBG_ALWAYS, "IssueSyncAtapiCommand: flushCount is %u\n", flushCount));
    }

    return status;

} // IssueSyncAtapiCommand


ULONG
IdePortQueryNonCdNumLun (
    IN PFDO_EXTENSION FdoExtension,
    IN PPDO_EXTENSION PdoExtension,
    IN BOOLEAN ByPassBlockedQueue
)
/*++

Routine Description:

    query number of Luns a device has using the protocol
    defined in the ATAPI Removable Rewritable Spec (SFF-8070i)

Arguments:

    FdoExtension - FDO extension

    PdoExtension - device extension of the PDO to be queried

Return Value:

    Number of logical units

--*/
{
    PIRP irp;
    PIO_STACK_LOCATION irpStack;
    SCSI_REQUEST_BLOCK srb;
    CDB cdb;
    IO_STATUS_BLOCK ioStatusBlock;
    KIRQL currentIrql;
    NTSTATUS status;

    PMODE_PARAMETER_HEADER10 modeParameterHeader;
    PATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES accessCap;
    PATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE opMode;
    ULONG modePageSize;
    ULONG accessCapPageSize;
    ULONG opModePageSize;

	PAGED_CODE();

    if (IsNEC_98) {

        PIDENTIFY_DATA fullIdentifyData;

        fullIdentifyData = &FdoExtension->HwDeviceExtension->IdentifyData[PdoExtension->TargetId];

        if (fullIdentifyData->GeneralConfiguration & 0x80) {
            if (fullIdentifyData->ModelNumber[8]  == 0x44 &&
                fullIdentifyData->ModelNumber[9]  == 0x50 &&
                fullIdentifyData->ModelNumber[10] == 0x31 &&
                fullIdentifyData->ModelNumber[11] == 0x2D ) {

                //
                // Find ATAPI PD drive.
                //

                return 2;
            }
        }
    }

    //
    // compute the size of the mode page needed
    //
    accessCapPageSize =
        sizeof (MODE_PARAMETER_HEADER10) +
        sizeof (ATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES);

    opModePageSize =
        sizeof (MODE_PARAMETER_HEADER10) +
        sizeof (ATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE);

    if (sizeof(ATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES) >=
        sizeof(ATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE)) {

        modePageSize = accessCapPageSize;

    } else {

        modePageSize = opModePageSize;
    }

    modeParameterHeader = ExAllocatePool (
                              NonPagedPoolCacheAligned,
                              modePageSize
                              );

    if (modeParameterHeader == NULL) {

        DebugPrint((DBG_ALWAYS,"QueryNonCdNumLun: Can't allocate modeParameterHeader buffer\n"));
        return(0);

    }
    RtlZeroMemory(modeParameterHeader, accessCapPageSize);
    RtlZeroMemory(&cdb, sizeof(CDB));

    //
    // Set CDB operation code.
    //
    cdb.MODE_SENSE10.OperationCode    = SCSIOP_MODE_SENSE10;
    cdb.MODE_SENSE10.PageCode         = ATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES_PAGECODE;
    cdb.MODE_SENSE10.Pc               = MODE_SENSE_CURRENT_VALUES;
    cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR) ((accessCapPageSize & 0xff00) >> 8);
    cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR) ((accessCapPageSize & 0x00ff) >> 0);

    //
    // get the removable block access capabilities page
    //
    status = IssueSyncAtapiCommand (
                 FdoExtension,
                 PdoExtension,
                 &cdb,
                 modeParameterHeader,
                 accessCapPageSize,
                 TRUE,
                 3,
                 ByPassBlockedQueue
                 );

    accessCap = (PATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES) (modeParameterHeader + 1);

    if (NT_SUCCESS(status) &&
        (accessCap->PageCode == ATAPI_REMOVABLE_BLOCK_ACCESS_CAPABILITIES_PAGECODE)) {

        DebugPrint ((DBG_PNP,
                     "QueryNonCdNumLun: Removable Block Access Capabilities Page:\n"
                     "page save bit:                  0x%x\n"
                     "format progress report support: 0x%x\n"
                     "system floppy device:           0x%x\n"
                     "total LUNs:                     0x%x\n"
                     "in single-Lun mode:             0x%x\n"
                     "non-CD optical deivce:          0x%x\n",
                     accessCap->PSBit,
                     accessCap->SRFP,
                     accessCap->SFLP,
                     accessCap->TotalLun,
                     accessCap->SML,
                     accessCap->NCD
                     ));

        if (accessCap->NCD) {

            //
            // we have a non-CD optical deivce
            //

            RtlZeroMemory(modeParameterHeader, opModePageSize);
            RtlZeroMemory(&cdb, sizeof(CDB));

            //
            // Set CDB operation code.
            //
            cdb.MODE_SENSE10.OperationCode    = SCSIOP_MODE_SENSE10;
            cdb.MODE_SENSE10.PageCode         = ATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE_PAGECODE;
            cdb.MODE_SENSE10.Pc               = MODE_SENSE_CURRENT_VALUES;
            cdb.MODE_SENSE10.AllocationLength[0] = (UCHAR) ((opModePageSize & 0xff00) >> 8);
            cdb.MODE_SENSE10.AllocationLength[1] = (UCHAR) ((opModePageSize & 0x00ff) >> 0);

            //
            // get the non-cd drive operation mode page
            //
            status = IssueSyncAtapiCommand (
                         FdoExtension,
                         PdoExtension,
                         &cdb,
                         modeParameterHeader,
                         opModePageSize,
                         TRUE,
                         3,
                         ByPassBlockedQueue
                         );

            opMode = (PATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE) (modeParameterHeader + 1);

            if (NT_SUCCESS(status) &&
                (opMode->PageCode == ATAPI_NON_CD_DRIVE_OPERATION_MODE_PAGE_PAGECODE)) {

                DebugPrint ((DBG_PNP,
                             "QueryNonCdNumLun: Non-CD device Operation Mode Page:\n"
                             "page save bit:                  0x%x\n"
                             "disable verify for write:       0x%x\n"
                             "Lun for R/W device:             0x%x\n"
                             "multi-Lun mode:                 0x%x\n",
                             opMode->PSBit,
                             opMode->DVW,
                             opMode->SLR,
                             opMode->SLM
                             ));

                RtlZeroMemory(modeParameterHeader, sizeof (MODE_PARAMETER_HEADER10));


                //
                // With mode select, this is reserved and must be 0
                //
                opMode->PSBit = 0;

                //
                // Turn on multi-lun mode
                //
                opMode->SLM = 1;

                //
                // non-CD device shall be Lun 1
                //
                opMode->SLR = 1;

                RtlZeroMemory(&cdb, sizeof(CDB));

                //
                // Set CDB operation code.
                //
                cdb.MODE_SELECT10.OperationCode    = SCSIOP_MODE_SELECT10;
                cdb.MODE_SELECT10.SPBit            = 1; // save page
                cdb.MODE_SELECT10.PFBit            = 1;
                cdb.MODE_SELECT10.ParameterListLength[0] = (UCHAR) ((opModePageSize & 0xff00) >> 8);
                cdb.MODE_SELECT10.ParameterListLength[1] = (UCHAR) ((opModePageSize & 0x00ff) >> 0);

                status = IssueSyncAtapiCommand (
                             FdoExtension,
                             PdoExtension,
                             &cdb,
                             modeParameterHeader,
                             opModePageSize,
                             FALSE,
                             3,
                             ByPassBlockedQueue
                             );

                if (!NT_SUCCESS(status)) {

                    DebugPrint ((DBG_ALWAYS, "IdePortQueryNonCdNumLun: Unable to set non-CD device into dual Lun Mode\n"));
                }
            }
        }
    }

    //
    // Free buffers
    //

    ExFreePool(modeParameterHeader);

    if (!NT_SUCCESS(status)) {

        return 0;

    } else {

        return 2;
    }

} // IdePortQueryNonCdNumLun


VOID
IdeBuildDeviceMap(
    IN PFDO_EXTENSION FdoExtension,
    IN PUNICODE_STRING ServiceKey
    )
/*++

Routine Description:

    The routine takes the inquiry data which has been collected and creates
    a device map for it.

Arguments:

    FdoExtension - FDO extension

    ServiceKey - Suppiles the name of the service key.

Return Value:

    None.

--*/
{

    UNICODE_STRING name;
    UNICODE_STRING unicodeString;
    ANSI_STRING ansiString;
    HANDLE key;
    HANDLE busKey;
    HANDLE targetKey;
    HANDLE lunKey;
    OBJECT_ATTRIBUTES objectAttributes;
    NTSTATUS status;
    ULONG disposition;
    PWSTR start;
    WCHAR buffer[32];
    UCHAR lastTarget;
    ULONG i;
    ULONG dmaEnableMask;
    PCSTR peripheralType;

    UCHAR             lastBus;
    IDE_PATH_ID       pathId;
    IN PPDO_EXTENSION pdoExtension;

    PAGED_CODE();

    //
    // Create the SCSI key in the device map.
    //

    RtlInitUnicodeString(&name,
                         L"\\Registry\\Machine\\Hardware\\DeviceMap\\Scsi");

    //
    // Initialize the object for the key.
    //

    InitializeObjectAttributes(&objectAttributes,
                               &name,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    //
    // Create the key or open it.
    //

    status = ZwCreateKey(&lunKey,
                         KEY_READ | KEY_WRITE,
                         &objectAttributes,
                         0,
                         (PUNICODE_STRING) NULL,
                         REG_OPTION_VOLATILE,
                         &disposition );

    if (!NT_SUCCESS(status)) {
        return;
    }

    status = IdeCreateNumericKey(lunKey,
                                FdoExtension->ScsiPortNumber,
                                L"Scsi Port ",
                                &key);

    ZwClose(lunKey);

    if (!NT_SUCCESS(status)) {
        return;
    }

#ifdef IDE_MEASURE_BUSSCAN_SPEED

    RtlInitUnicodeString(&name, L"FirstBusScanTimeInMs");

    status = ZwSetValueKey(key,
                           &name,
                           0,
                           REG_DWORD,
                           &FdoExtension->BusScanTime,
                           sizeof(ULONG));

#endif // IDE_MEASURE_BUSSCAN_SPEED

    //
    // Add DMA enable mask value.
    //
    dmaEnableMask = 0;
    for (i=0; i<FdoExtension->HwDeviceExtension->MaxIdeDevice; i++) {

        if (FdoExtension->HwDeviceExtension->DeviceFlags[i] & DFLAGS_USE_DMA) {

            dmaEnableMask |= (1 << i);

        }
    }

    RtlInitUnicodeString(&name, L"DMAEnabled");

    status = ZwSetValueKey(key,
                           &name,
                           0,
                           REG_DWORD,
                           &dmaEnableMask,
                           4);

    //
    // Add Interrupt value.
    //

//    if (FdoExtension->InterruptLevel) {
//
//        RtlInitUnicodeString(&name, L"Interrupt");
//
//        status = ZwSetValueKey(key,
//                               &name,
//                               0,
//                               REG_DWORD,
//                               &FdoExtension->InterruptLevel,
//                               4);
//    }
//
//    //
//    // Add base IO address value.
//    //
//
//    if (FdoExtension->IdeResource.TranslatedCommandBaseAddress) {
//
//        RtlInitUnicodeString(&name, L"IOAddress");
//
//        status = ZwSetValueKey(key,
//                               &name,
//                               0,
//                               REG_DWORD,
//                               &FdoExtension->IdeResource.TranslatedCommandBaseAddress,
//                               4);
//    }

    if (ServiceKey != NULL) {

        //
        // Add identifier value. This value is equal to the name of the driver
        // in the from the service key. Note the service key name is not NULL
        // terminated.
        //

        RtlInitUnicodeString(&name, L"Driver");

        //
        // Get the name of the driver from the service key name.
        //

        start = (PWSTR) ((PCHAR) ServiceKey->Buffer + ServiceKey->Length);
        start--;
        while (*start != L'\\' && start > ServiceKey->Buffer) {
            start--;
        }

        if (*start != L'\\') {
            ZwClose(key);
            return;
        }

        start++;
        for (i = 0; i < 31; i++) {

            buffer[i] = *start++;

            if (start >= ServiceKey->Buffer + ServiceKey->Length / sizeof(wchar_t)) {
                break;
            }
        }

        i++;
        buffer[i] = L'\0';

        status = ZwSetValueKey(key,
                               &name,
                               0,
                               REG_SZ,
                               buffer,
                               (i + 1) * sizeof(wchar_t));

        if (!NT_SUCCESS(status)) {
            ZwClose(key);
            return;
        }
    }

    //
    // Cycle through each of the lun.
    //
    lastBus = 0xff;
    pathId.l = 0;
    busKey = 0;
    targetKey = 0;
    lunKey = 0;
    while (pdoExtension = NextLogUnitExtensionWithTag (
                              FdoExtension,
                              &pathId,
                              FALSE,
                              IdeBuildDeviceMap
                              )) {

        //
        // Create a key entry for the bus.
        //
        if (lastBus != pathId.b.Path) {

            if (busKey) {

                ZwClose(busKey);
                busKey = 0;
            }

            if (targetKey) {

                ZwClose(targetKey);
                targetKey = 0;
            }

            status = IdeCreateNumericKey(key, pathId.b.Path, L"Scsi Bus ", &busKey);

            if (!NT_SUCCESS(status)) {
                break;
            }

            lastBus = (UCHAR) pathId.b.Path;

            //
            // Create a key entry for the Scsi bus adapter.
            //

            status = IdeCreateNumericKey(busKey,
                                    IDE_PSUEDO_INITIATOR_ID,
                                    L"Initiator Id ",
                                    &targetKey);

            if (!NT_SUCCESS(status)) {
                break;
            }

            lastTarget = IDE_PSUEDO_INITIATOR_ID;
        }

        //
        // Process the data for the logical units.
        //

        //
        // If this is a new target Id then create a new target entry.
        //

        if (lastTarget != pdoExtension->TargetId) {

            ZwClose(targetKey);
            targetKey = 0;

            status = IdeCreateNumericKey(busKey,
                                        pdoExtension->TargetId,
                                        L"Target Id ",
                                        &targetKey);

            if (!NT_SUCCESS(status)) {
                break;
            }

            lastTarget = pdoExtension->TargetId;
        }

        //
        // Create the Lun entry.
        //

        status = IdeCreateNumericKey(targetKey,
                                    pdoExtension->Lun,
                                    L"Logical Unit Id ",
                                    &lunKey);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // Create identifier value.
        //

        RtlInitUnicodeString(&name, L"Identifier");

        //
        // Get the Identifier from the inquiry data.
        //
        RtlInitAnsiString(&ansiString, pdoExtension->FullVendorProductId);

        status = RtlAnsiStringToUnicodeString(&unicodeString,
                                              &ansiString,
                                              TRUE);

        if (!NT_SUCCESS(status)) {
            break;
        }

        status = ZwSetValueKey(lunKey,
                               &name,
                               0,
                               REG_SZ,
                               unicodeString.Buffer,
                               unicodeString.Length + sizeof(wchar_t));

        RtlFreeUnicodeString(&unicodeString);

        if (!NT_SUCCESS(status)) {
            break;
        }

        //
        // Determine the perpherial type.
        //
        peripheralType = IdePortGetPeripheralIdString (
                             pdoExtension->ScsiDeviceType
                             );
        if (!peripheralType) {

            peripheralType = "OtherPeripheral";
        }

        RtlInitAnsiString(&ansiString, peripheralType);

        unicodeString.MaximumLength = (USHORT) RtlAnsiStringToUnicodeSize(&ansiString) + sizeof(WCHAR);
        unicodeString.Length = 0;
        unicodeString.Buffer = ExAllocatePool (PagedPool, unicodeString.MaximumLength);

        if (unicodeString.Buffer) {

            status = RtlAnsiStringToUnicodeString(
                        &unicodeString,
                        &ansiString,
                        FALSE
                        );

            if (NT_SUCCESS(status)) {

                //
                // Set type value.
                //

                RtlInitUnicodeString(&name, L"Type");

                unicodeString.Buffer[unicodeString.Length / sizeof (WCHAR)] = L'\0';

                status = ZwSetValueKey(lunKey,
                                       &name,
                                       0,
                                       REG_SZ,
                                       unicodeString.Buffer,
                                       unicodeString.Length + sizeof (WCHAR));

                ExFreePool (unicodeString.Buffer);
            }

        } else {

            status = STATUS_NO_MEMORY;
        }

        ZwClose(lunKey);
        lunKey = 0;

        if (!NT_SUCCESS(status)) {
            break;
        }

        UnrefLogicalUnitExtensionWithTag (
            FdoExtension,
            pdoExtension,
            IdeBuildDeviceMap
            );
        pdoExtension = NULL;
    }

    if (lunKey) {

        ZwClose(lunKey);
    }

    if (busKey) {

        ZwClose(busKey);
    }

    if (targetKey) {

        ZwClose(targetKey);
    }

    if (pdoExtension) {

        UnrefLogicalUnitExtensionWithTag (
            FdoExtension,
            pdoExtension,
            IdeBuildDeviceMap
            );
    }

    ZwClose(key);
} // IdeBuildDeviceMap

NTSTATUS
IdeCreateNumericKey(
    IN  HANDLE  Root,
    IN  ULONG   Name,
    IN  PWSTR   Prefix,
    OUT PHANDLE NewKey
)
/*++

Routine Description:

    This function creates a registry key.  The name of the key is a string
    version of numeric value passed in.

Arguments:

    RootKey - Supplies a handle to the key where the new key should be inserted.

    Name - Supplies the numeric value to name the key.

    Prefix - Supplies a prefix name to add to name.

    NewKey - Returns the handle for the new key.

Return Value:

   Returns the status of the operation.

--*/

{

    UNICODE_STRING string;
    UNICODE_STRING stringNum;
    OBJECT_ATTRIBUTES objectAttributes;
    WCHAR bufferNum[16];
    WCHAR buffer[64];
    ULONG disposition;
    NTSTATUS status;

    PAGED_CODE();

    //
    // Copy the Prefix into a string.
    //

    string.Length = 0;
    string.MaximumLength=64;
    string.Buffer = buffer;

    RtlInitUnicodeString(&stringNum, Prefix);

    RtlCopyUnicodeString(&string, &stringNum);

    //
    // Create a port number key entry.
    //

    stringNum.Length = 0;
    stringNum.MaximumLength = 16;
    stringNum.Buffer = bufferNum;

    status = RtlIntegerToUnicodeString(Name, 10, &stringNum);

    if (!NT_SUCCESS(status)) {
        return status;
    }

    //
    // Append the prefix and the numeric name.
    //

    RtlAppendUnicodeStringToString(&string, &stringNum);

    InitializeObjectAttributes( &objectAttributes,
                                &string,
                                OBJ_CASE_INSENSITIVE,
                                Root,
                                (PSECURITY_DESCRIPTOR) NULL );

    status = ZwCreateKey(NewKey,
                        KEY_READ | KEY_WRITE,
                        &objectAttributes,
                        0,
                        (PUNICODE_STRING) NULL,
                        REG_OPTION_VOLATILE,
                        &disposition );

    return(status);
} // IdeCreateNumericKey
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\luext.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       luext.h
//
//--------------------------------------------------------------------------

#if !defined (___luext_h___)
#define ___luext_h___

#if !DBG

#define RefPdoWithTag(a,b,c)                        RefPdo(a,b)
#define RefPdoWithSpinLockHeldWithTag(a,b,c)        RefPdoWithSpinLockHeld(a,b)
#define RefLogicalUnitExtensionWithTag(a,b,c,d,e,f) RefLogicalUnitExtension(a,b,c,d,e)
#define UnrefPdoWithTag(a,b)                        UnrefPdo(a)
#define UnrefLogicalUnitExtensionWithTag(a,b,c)     UnrefLogicalUnitExtension(a,b)
#define AllocatePdoWithTag(a,b,c)                   AllocatePdo(a,b)
#define FreePdoWithTag(a,b,c,d)                     FreePdo(a,b,c)
#define NextLogUnitExtensionWithTag(a,b,c,d)        NextLogUnitExtension(a,b,c)

#else

#define RefPdoWithTag                    RefPdo
#define RefPdoWithSpinLockHeldWithTag    RefPdoWithSpinLockHeld
#define RefLogicalUnitExtensionWithTag   RefLogicalUnitExtension
#define UnrefPdoWithTag                  UnrefPdo
#define UnrefLogicalUnitExtensionWithTag UnrefLogicalUnitExtension
#define AllocatePdoWithTag               AllocatePdo
#define FreePdoWithTag                   FreePdo
#define NextLogUnitExtensionWithTag      NextLogUnitExtension

#endif // DBG

PPDO_EXTENSION
RefPdo(
    PDEVICE_OBJECT PhysicalDeviceObject,
    BOOLEAN RemovedOk
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    );

PPDO_EXTENSION
RefPdoWithSpinLockHeld(
    PDEVICE_OBJECT PhysicalDeviceObject,
    BOOLEAN RemovedOk
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    );

PPDO_EXTENSION
RefLogicalUnitExtension(
    PFDO_EXTENSION DeviceExtension,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun,
    BOOLEAN RemovedOk
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    );

VOID
UnrefPdo(
    PPDO_EXTENSION PdoExtension
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    );

VOID
UnrefLogicalUnitExtension(
    PFDO_EXTENSION FdoExtension,
    PPDO_EXTENSION PdoExtension
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    );
      
PPDO_EXTENSION
AllocatePdo(
    IN PFDO_EXTENSION   FdoExtension,
    IN IDE_PATH_ID      PathId
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    );

NTSTATUS
FreePdo(
    IN PPDO_EXTENSION   PdoExtension,
    IN BOOLEAN          Sync,
    IN BOOLEAN          IoDeleteDevice
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    );
    
PPDO_EXTENSION
NextLogUnitExtension(
    IN     PFDO_EXTENSION FdoExtension,
    IN OUT PIDE_PATH_ID   PathId,
    IN     BOOLEAN        RemovedOk
    DECLARE_EXTRA_DEBUG_PARAMETER(PVOID, Tag)
    );

VOID
KillPdo(
    IN PPDO_EXTENSION PdoExtension
    );
                       
#if !DBG

#define IdeInterlockedIncrement(pdoe, Addend, Tag) InterlockedIncrement(Addend)
#define IdeInterlockedDecrement(pdoe, Addend, Tag) InterlockedDecrement(Addend)

#else
LONG 
IdeInterlockedIncrement (
   IN PPDO_EXTENSION PdoExtension,
   IN PLONG Addend,
   IN PVOID Tag
   );

LONG 
IdeInterlockedDecrement (
   IN PPDO_EXTENSION PdoExtension,
   IN PLONG Addend,
   IN PVOID Tag
   );
#endif




#endif // ___luext_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\passthru.h ===
/*++

Copyright (C) 2002  Microsoft Corporation

Module Name:

    passthru.h

Abstract:

--*/

#ifndef __PASSTHRU_H__
#define __PASSTHRU_H__

#define SRB_FUNCTION_ATA_PASS_THROUGH_EX 0xC9


NTSTATUS
IdeAtaPassThroughSetPortAddress (
    PIRP Irp,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun
    );


NTSTATUS
IdeAtaPassThroughGetPortAddress(
    IN PIRP Irp,
    OUT PUCHAR PathId,
    OUT PUCHAR TargetId,
    OUT PUCHAR Lun
    );

NTSTATUS
IdeHandleAtaPassThroughIoctl (
    PFDO_EXTENSION FdoExtension,
    PIRP RequestIrp,
    BOOLEAN Direct
    );


PSCSI_REQUEST_BLOCK
IdeAtaPassThroughSetupSrb (
    PPDO_EXTENSION PdoExtension,
    PVOID DataBuffer,
    ULONG DataBufferLength,
    ULONG TimeOutValue,
    ULONG AtaFlags,
    PUCHAR CurrentTaskFile,
    PUCHAR PreviousTaskFile
    );

PIRP
IdeAtaPassThroughSetupIrp (
    PDEVICE_OBJECT DeviceObject,
    PVOID DataBuffer,
    ULONG DataBufferLength,
    KPROCESSOR_MODE AccessMode,
    BOOLEAN DataIn
    );


VOID
IdeAtaPassThroughFreeIrp (
    PIRP Irp
    );

VOID
IdeAtaPassThroughFreeSrb (
    PSCSI_REQUEST_BLOCK Srb
    );

NTSTATUS
IdeAtaPassThroughSendSynchronous (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    );

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\passthru.c ===
/*++

Copyright (C) Microsoft Corporation, 2002

Module Name:

    passthru.c

Abstract:

    This file contains routines to handle IOCTL_ATA_PASS_THROUGH

Authors:

    Krishnan Varadarajan (krishvar)

Environment:

    kernel mode only

Notes:

    This module implements ATA passthru. 

Revision History:

--*/

#include "ideport.h"

#define DataIn(ataPassThrough) \
    (ataPassThrough->AtaFlags & ATA_FLAGS_DATA_IN)

#define DataOut(ataPassThrough) \
    (ataPassThrough->AtaFlags & ATA_FLAGS_DATA_OUT)

NTSTATUS
IdeAtaPassThroughValidateInput (
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp,
    IN BOOLEAN Direct
    );

NTSTATUS
IdeAtaPassThroughSyncCompletion (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

VOID
IdeAtaPassThroughMarshalResults(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PATA_PASS_THROUGH_EX AtaPassThrough,
    IN BOOLEAN Direct,
    OUT PIO_STATUS_BLOCK IoStatus
    );

#if defined (_WIN64)
VOID
IdeTranslateAtaPassThrough32To64(
    IN PATA_PASS_THROUGH_EX32 AtaPassThrough32,
    IN OUT PATA_PASS_THROUGH_EX AtaPassThrough64
    );

VOID
IdeTranslateAtaPassThrough64To32(
    IN PATA_PASS_THROUGH_EX AtaPassThrough64,
    IN OUT PATA_PASS_THROUGH_EX32 AtaPassThrough32
    );
#endif

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IdeHandleAtaPassThroughIoctl)
#pragma alloc_text(PAGE, IdeAtaPassThroughSetPortAddress)
#pragma alloc_text(PAGE, IdeAtaPassThroughGetPortAddress)
#pragma alloc_text(PAGE, IdeAtaPassThroughValidateInput)
#pragma alloc_text(PAGE, IdeAtaPassThroughSendSynchronous)
#pragma alloc_text(PAGE, IdeAtaPassThroughMarshalResults)
#if defined (_WIN64)
#pragma alloc_text(PAGE, IdeTranslateAtaPassThrough32To64)
#pragma alloc_text(PAGE, IdeTranslateAtaPassThrough64To32)
#endif
#endif

NTSTATUS
IdeAtaPassThroughSetPortAddress (
    PIRP Irp,
    UCHAR PathId,
    UCHAR TargetId,
    UCHAR Lun
    )
/*++

Routine Description:

    Sets the address fields in the ataPassThrough structure embedded in
    the irp.
    
Arguments:

    Irp : The ata passthrough irp
    PathId : PathId of the pdo.
    TargetId : Pdo's targetId.
    Lun : Lun represented by the pdo.

Return Valud:

    STATUS_SUCCESS if the operation succeeded.
    STATUS_INVALID_PARAMETER otherwise.    

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;
    ULONG requiredSize;
    ULONG inputLength;

    PAGED_CODE();

    inputLength = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    requiredSize = sizeof(ATA_PASS_THROUGH_EX);

#if defined (_WIN64)
    if (IoIs32bitProcess(Irp)) {
        requiredSize = sizeof(ATA_PASS_THROUGH_EX32);
    }
#endif

    if (inputLength < requiredSize) {

        status = STATUS_INVALID_PARAMETER;

    } else {

        PATA_PASS_THROUGH_EX ataPassThrough;

        ataPassThrough = Irp->AssociatedIrp.SystemBuffer;
        ataPassThrough->PathId = PathId;
        ataPassThrough->TargetId = TargetId;
        ataPassThrough->Lun = Lun;

        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
IdeAtaPassThroughGetAddress(
    IN PIRP Irp,
    OUT PUCHAR PathId,
    OUT PUCHAR TargetId,
    OUT PUCHAR Lun
    )
/*++

Routine Description:

    This routine retrieves the address of the device to witch the passthrough
    request is to be sent.

Arguments:

    Irp      - Supplies a pointer to the IRP that contains the 
               SCSI_PASS_THROUGH structure.

    PathId   - Pointer to the PathId of the addressed device.

    TargetId - Pointer to the TargetId of the addressed device. 

    Lun      - Pointer to the logical unit number of the addressed device.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/
{
    PIO_STACK_LOCATION irpStack = IoGetCurrentIrpStackLocation(Irp);
    NTSTATUS status;
    ULONG requiredSize;
    ULONG inputLength;

    PAGED_CODE();

    inputLength = irpStack->Parameters.DeviceIoControl.InputBufferLength;
    requiredSize = sizeof(ATA_PASS_THROUGH_EX);

#if defined (_WIN64)
    if (IoIs32bitProcess(Irp)) {
        requiredSize = sizeof(ATA_PASS_THROUGH_EX32);
    }
#endif

    if (inputLength < requiredSize) {

        status = STATUS_INVALID_PARAMETER;

    } else {

        PATA_PASS_THROUGH_EX ataPassThrough;

        ataPassThrough = Irp->AssociatedIrp.SystemBuffer;

        *PathId = ataPassThrough->PathId;
        *TargetId = ataPassThrough->TargetId;
        *Lun = ataPassThrough->Lun;
        status = STATUS_SUCCESS;
    }

    return status;
}

NTSTATUS
IdeHandleAtaPassThroughIoctl (
    PFDO_EXTENSION FdoExtension,
    PIRP RequestIrp,
    BOOLEAN Direct
    )
/*++

Routine Description:

    This routine handles IOCTL_ATA_PASS_THROUGH and its DIRECT version.
    
Arguments:

    FdoExtension : 
    
    RequestIrp : The pass through ioctl request
    
    Direct : Indicates whether it is direct or not.
    
Return Value:

    Status of the operation.        

--*/
{
    BOOLEAN dataIn;
    NTSTATUS status;
    PATA_PASS_THROUGH_EX ataPassThrough;
    PUCHAR passThroughBuffer;
    PIO_STACK_LOCATION irpStack;
    PPDO_EXTENSION pdoExtension;
    UCHAR pathId, targetId, lun;
    PSCSI_REQUEST_BLOCK srb;
    PUCHAR buffer;
    ULONG bufferOffset;
    ULONG length;
    ULONG pages;
    PIRP irp;

#if defined (_WIN64)
    ATA_PASS_THROUGH_EX ataPassThrough64;
#endif

    PAGED_CODE();

    irp = NULL;
    srb = NULL;
    pdoExtension = NULL;

    //
    // get the device address
    //
    status = IdeAtaPassThroughGetAddress (RequestIrp,
                                          &pathId,
                                          &targetId,
                                          &lun
                                          );

    if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

    //
    // Get a reference to the pdo
    //
    pdoExtension = RefLogicalUnitExtensionWithTag(
                                          FdoExtension,
                                          pathId,
                                          targetId,
                                          lun,
                                          FALSE,
                                          RequestIrp
                                          );

    if (pdoExtension == NULL) {

        status = STATUS_INVALID_PARAMETER;
        goto GetOut;
    }

    //
    // validate the system buffer in the request irp. This comes
    // from user mode. So every parameter needs to be validated.
    //
    status = IdeAtaPassThroughValidateInput (pdoExtension->DeviceObject,
                                             RequestIrp, 
                                             Direct
                                             );

    if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

    //
    // the system buffer has been validated. Get a pointer to it
    //
    ataPassThrough = RequestIrp->AssociatedIrp.SystemBuffer;

    //
    // we need to keep the pointer to the system buffer since
    // ataPassThrough could be modified to point to a structure
    // allocated on the stack (in WIN64 case)
    //
    passThroughBuffer = (PUCHAR) ataPassThrough;

    //
    // If the irp is from a 32-bit app running on a 64 bit system
    // then we need to take into account the size difference in the
    // structure. Create a new 64 bit structure and copy over the 
    // fields.
    //

#if defined (_WIN64)
    if (IoIs32bitProcess(RequestIrp)) {

        PATA_PASS_THROUGH_EX32 ataPassThrough32;

        ataPassThrough32 = RequestIrp->AssociatedIrp.SystemBuffer;

        IdeTranslateAtaPassThrough32To64(
            ataPassThrough32,
            &ataPassThrough64
            );

        ataPassThrough = &ataPassThrough64;
    }
#endif

    //
    // determine the transfer length and the data buffer
    //
    if (ataPassThrough->DataTransferLength == 0) {

        length = 0;
        buffer = NULL;
        bufferOffset = 0;

    } else if (Direct == TRUE) {

        length = (ULONG) ataPassThrough->DataTransferLength;
        buffer = (PUCHAR) ataPassThrough->DataBufferOffset;
        bufferOffset = 0;

    } else {

        length = (ULONG) ataPassThrough->DataBufferOffset + 
                                          ataPassThrough->DataTransferLength;
        buffer = (PUCHAR) passThroughBuffer;
        bufferOffset = (ULONG)ataPassThrough->DataBufferOffset;
    }

    //
    // Check if the request is too big for the adapter.
    //
    pages = ADDRESS_AND_SIZE_TO_SPAN_PAGES(
                buffer + bufferOffset,
                ataPassThrough->DataTransferLength);

    if ((ataPassThrough->DataTransferLength != 0) &&
        ((pages > FdoExtension->Capabilities.MaximumPhysicalPages) || 
         (ataPassThrough->DataTransferLength > 
         FdoExtension->Capabilities.MaximumTransferLength))) {
        
        status = STATUS_INVALID_PARAMETER;
        goto GetOut;
    }

    //
    // setup the irp for ata pass through. The ioctl is method_buffered,
    // but the data buffer could be a user mode one if it is the direct ioctl.
    // determine the access mode accordingly
    //
    irp = IdeAtaPassThroughSetupIrp( pdoExtension->DeviceObject, 
                                     buffer, 
                                     length, 
                                     (Direct ? UserMode : KernelMode),
                                     DataIn(ataPassThrough) ? TRUE : FALSE
                                     );

    if (irp == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    //
    // setup the srb. Use the right data offset for the databuffer.
    // Note that the mdl is for the whole buffer (including the header)
    //
    srb = IdeAtaPassThroughSetupSrb (pdoExtension,
                                     (buffer+bufferOffset),
                                     ataPassThrough->DataTransferLength,
                                     ataPassThrough->TimeOutValue,
                                     ataPassThrough->AtaFlags,
                                     ataPassThrough->CurrentTaskFile,
                                     ataPassThrough->PreviousTaskFile
                                     );

    if (srb == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    //
    // initialize irpstack
    //
    irpStack = IoGetNextIrpStackLocation(irp);
    irpStack->MajorFunction = IRP_MJ_SCSI;
    irpStack->Parameters.Scsi.Srb = srb;

    srb->OriginalRequest = irp;

    //
    // send it to our pdo synchronously
    //
    status = IdeAtaPassThroughSendSynchronous (pdoExtension->DeviceObject, irp);

    //
    // set the status
    //
    RequestIrp->IoStatus.Status = status;

    //
    // marshal the results
    //
    IdeAtaPassThroughMarshalResults (srb, 
                                     ataPassThrough, 
                                     Direct,
                                     &(RequestIrp->IoStatus)
                                     );

    //
    // copy back the results to the original 32 bit
    // structure if necessary
    //
#if defined (_WIN64)
    if (IoIs32bitProcess(RequestIrp)) {

        PATA_PASS_THROUGH_EX32 ataPassThrough32;

        ataPassThrough32 = RequestIrp->AssociatedIrp.SystemBuffer;

        IdeTranslateAtaPassThrough64To32 (
            ataPassThrough,
            ataPassThrough32
            );
    }
#endif

    //
    // return the status of the operation
    //
    status = RequestIrp->IoStatus.Status;

GetOut:

    if (irp) {

        IdeAtaPassThroughFreeIrp(irp);
        irp = NULL;
    }

    if (srb) {

        IdeAtaPassThroughFreeSrb(srb);
        srb = NULL;
    }

    if (pdoExtension) {

        UnrefLogicalUnitExtensionWithTag(
            FdoExtension,
            pdoExtension,
            RequestIrp
            );
        pdoExtension = NULL;
    }

    return status;
}

NTSTATUS
IdeAtaPassThroughValidateInput (
    IN PDEVICE_OBJECT Pdo,
    IN PIRP Irp,
    IN BOOLEAN Direct
    )
/*++

Routine Description:

    This routine validates the caller-supplied data and initializes the
    PORT_PASSTHROUGH_INFO structure.

Arguments:

    PassThroughInfo - Supplies a pointer to a SCSI_PASSTHROUGH_INFO structure.
                      
    Irp             - Supplies a pointer to the IRP.

    Direct          - Supplies a boolean that indicates whether this is a 
                      SCSI_PASS_THROUGH_DIRECT request.

Return Value:

    Returns a status indicating the success or failure of the operation.

--*/
{
    NTSTATUS status;
    ULONG outputLength;
    ULONG inputLength;
    PIO_STACK_LOCATION irpStack;
    PATA_PASS_THROUGH_EX ataPassThroughEx;

#if defined (_WIN64)
    ATA_PASS_THROUGH_EX ataPassThrough64;
#endif

    PAGED_CODE();

    irpStack = IoGetCurrentIrpStackLocation(Irp);
    outputLength = irpStack->Parameters.DeviceIoControl.OutputBufferLength;
    inputLength = irpStack->Parameters.DeviceIoControl.InputBufferLength;

    //
    // For WIN64, a passthrough request from a 32-bit application requires
    // us to perform a translation on the supplied SCSI_PASS_THROUGH structure.
    // This is required because the layout of the 32-bit structure does not
    // match that of a 64-bit structure.  In this case, we translate the
    // supplied 32-bit structure into a stack-allocated 64-bit structure which
    // will be used to process the pass through request.
    //
#if defined (_WIN64)
    if (IoIs32bitProcess(Irp)) {

        PATA_PASS_THROUGH_EX32 ataPassThrough32;

        //
        // the struct should atleast be as big as ATA_PASS_THROUGH_EX32
        //
        if (inputLength < sizeof(ATA_PASS_THROUGH_EX32)){
            return STATUS_INVALID_PARAMETER;
        }

        ataPassThrough32 = Irp->AssociatedIrp.SystemBuffer;

        //
        // The length field should match the size 
        // of the structure
        //
        if (Direct == FALSE) {

            if (ataPassThrough32->Length != 
                sizeof(ATA_PASS_THROUGH_EX32)) {
                return STATUS_REVISION_MISMATCH;
            }

        } else {

            if (ataPassThrough32->Length !=
                sizeof(ATA_PASS_THROUGH_DIRECT32)) {
                return STATUS_REVISION_MISMATCH;
            }
        }

        //
        // translate the structure to the 64 bit version
        //
        IdeTranslateAtaPassThrough32To64(
            ataPassThrough32,
            &ataPassThrough64
            );

        ataPassThroughEx = &ataPassThrough64;

    } else {
#endif

        //
        // the struct should atleast be as big as ATA_PASS_THROUGH_EX32
        //
        if (inputLength < sizeof(ATA_PASS_THROUGH_EX)){
            return(STATUS_INVALID_PARAMETER);
        }

        ataPassThroughEx = Irp->AssociatedIrp.SystemBuffer;

        //
        // The length field should match the size 
        // of the structure
        //
        if (Direct == FALSE) {

            if (ataPassThroughEx->Length != 
                sizeof(ATA_PASS_THROUGH_EX)) {
                return STATUS_REVISION_MISMATCH;
            }

        } else {

            if (ataPassThroughEx->Length !=
                sizeof(ATA_PASS_THROUGH_DIRECT)) {
                return STATUS_REVISION_MISMATCH;
            }
        }
#if defined (_WIN64)
    }
#endif

    if (!Direct) {

        //
        // Data buffer offset should be greater than the size of the pass 
        // through structure.
        //

        if (ataPassThroughEx->Length > ataPassThroughEx->DataBufferOffset &&
            ataPassThroughEx->DataTransferLength != 0) {
            return STATUS_INVALID_PARAMETER;
        }

        //
        // If this command is sending data to the device.  Make sure the data 
        // buffer lies entirely within the supplied input buffer.
        //

        if (DataOut(ataPassThroughEx)) {

            if ((ataPassThroughEx->DataBufferOffset > inputLength) ||
                ((ataPassThroughEx->DataBufferOffset + 
                  ataPassThroughEx->DataTransferLength) >
                 inputLength)) {
                return STATUS_INVALID_PARAMETER;
            }
        }

        //
        // If this command is retrieving data from the device, make sure the 
        // data buffer lies entirely within the supplied output buffer.
        //

        if (DataIn(ataPassThroughEx)) {

            if ((ataPassThroughEx->DataBufferOffset > outputLength) ||
                ((ataPassThroughEx->DataBufferOffset + 
                  ataPassThroughEx->DataTransferLength) >
                 outputLength)) {
                return STATUS_INVALID_PARAMETER;
            }
        }

    } else {

        //
        // Make sure the databuffer is properly aligned.
        //
        if (ataPassThroughEx->DataBufferOffset &
            Pdo->AlignmentRequirement) {
            return STATUS_INVALID_PARAMETER;
        }
    }
    
    //
    // Validate the specified timeout value.
    //
    
    if (ataPassThroughEx->TimeOutValue == 0 || 
        ataPassThroughEx->TimeOutValue > 30 * 60 * 60) {
        return STATUS_INVALID_PARAMETER;
    }

    return STATUS_SUCCESS;
}

PSCSI_REQUEST_BLOCK
IdeAtaPassThroughSetupSrb (
    PPDO_EXTENSION PdoExtension,
    PVOID DataBuffer,
    ULONG DataBufferLength,
    ULONG TimeOutValue,
    ULONG AtaFlags,
    PUCHAR CurrentTaskFile,
    PUCHAR PreviousTaskFile
    )
/*++

Routine Description:

    Builds an SRB for ATA PASS THROUGH.
    
Arguments:

    PdoExtension : The pdo which the request is destined for
    DataBuffer : Pointer to the data buffer.
    DataBufferLength : The size of the data buffer
    TimeOutValue: The request timeout value
    AtaFlags : Specifies the flags for the request
    CurrentTaskFile : the current ata registers
    PreviousTaskFile: previous values for 48 bit LBA feature set

Return Value:

    Pointer to an SRB if one was allocated successfully, NULL otherwise.    
        
--*/
{
    PSCSI_REQUEST_BLOCK srb = NULL;
    PIDEREGS pIdeReg;

    //
    // allocate the srb
    //
    srb = ExAllocatePool (NonPagedPool, sizeof (SCSI_REQUEST_BLOCK));

    if (srb == NULL)  {

        return NULL;
    }

    //
    // Fill in the srb.
    //
    RtlZeroMemory(srb, sizeof(SCSI_REQUEST_BLOCK));

    srb->Length = SCSI_REQUEST_BLOCK_SIZE;
    srb->Function = SRB_FUNCTION_ATA_PASS_THROUGH_EX;
    srb->SrbStatus = SRB_STATUS_PENDING;
    srb->PathId = PdoExtension->PathId;
    srb->TargetId = PdoExtension->TargetId;
    srb->Lun = PdoExtension->Lun;
    srb->SenseInfoBufferLength = 0;
    srb->TimeOutValue = TimeOutValue;


    if (DataBufferLength != 0) {

        if (AtaFlags & ATA_FLAGS_DATA_IN) {
            srb->SrbFlags |= SRB_FLAGS_DATA_IN;
        }

        if (AtaFlags & ATA_FLAGS_DATA_OUT) {
            srb->SrbFlags |= SRB_FLAGS_DATA_OUT;
        }
    }

    srb->SrbFlags |= SRB_FLAGS_DISABLE_AUTOSENSE;
    srb->SrbFlags |= SRB_FLAGS_NO_QUEUE_FREEZE;
    srb->DataTransferLength = DataBufferLength;
    srb->DataBuffer = DataBuffer;
    srb->SenseInfoBuffer = NULL;

    MARK_SRB_AS_PIO_CANDIDATE(srb);

    RtlCopyMemory(srb->Cdb, 
                  CurrentTaskFile, 
                  8
                  );

    RtlCopyMemory((PUCHAR) (&srb->Cdb[8]), 
                  PreviousTaskFile,
                  8
                  );

    pIdeReg     = (PIDEREGS) (srb->Cdb);

    if (AtaFlags & ATA_FLAGS_DRDY_REQUIRED) {

        pIdeReg->bReserved |= ATA_PTFLAGS_STATUS_DRDY_REQUIRED;
    }

    return srb;
}

PIRP
IdeAtaPassThroughSetupIrp (
    PDEVICE_OBJECT DeviceObject,
    PVOID DataBuffer,
    ULONG DataBufferLength,
    KPROCESSOR_MODE AccessMode,
    BOOLEAN DataIn
    )
/*++

Routine Description:

    Builds an Irp to handle ata pass through.
    
Arguments:

    DeviceObject : The Pdo.
    DataBuffer : Pointer to the data buffer.
    DataBufferLength: its size
    Access Mode: KernelMode or UserMode
    DataIn: indicates the direction of transfer
    
Return Value:

    PIRP if one was allocated successfully, NULL otherwise.        

--*/
{
    PIRP irp = NULL;
    NTSTATUS status = STATUS_SUCCESS;


    //
    // allocate the irp
    //
    irp = IoAllocateIrp (
              (CCHAR) (DeviceObject->StackSize),
              FALSE
              );

    if (irp == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        goto GetOut;
    }

    //
    // allocate the mdl if needed
    //
    if (DataBufferLength != 0) {

        ASSERT(irp);

        irp->MdlAddress = IoAllocateMdl( DataBuffer,
                                         DataBufferLength,
                                         FALSE,
                                         FALSE,
                                         (PIRP) NULL 
                                         );

        if (irp->MdlAddress == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto GetOut;
        }

        //
        // lock the pages
        //
        try {

            MmProbeAndLockPages( irp->MdlAddress,
                                 AccessMode,
                                 (LOCK_OPERATION) (DataIn ? IoWriteAccess : IoReadAccess) 
                                 );

        } except(EXCEPTION_EXECUTE_HANDLER) {

              if (irp->MdlAddress != NULL) {

                  IoFreeMdl( irp->MdlAddress );
                  irp->MdlAddress = NULL;
              }
        }

        if (irp->MdlAddress == NULL) {

            status = STATUS_INSUFFICIENT_RESOURCES;
            goto GetOut;

        } else {

            //
            // Flush the data buffer for output. This will insure that 
            // the data is written back to memory.
            //
            KeFlushIoBuffers(irp->MdlAddress, FALSE, TRUE);
        }
    }


    status = STATUS_SUCCESS;

GetOut:

    if (!NT_SUCCESS(status)) {

        if (irp) {

            if (irp->MdlAddress) {

                //
                // if mdladdress is set then the probeandlock
                // succeeded. So unlock it now.
                //
                MmUnlockPages(irp->MdlAddress);

                IoFreeMdl( irp->MdlAddress );
                irp->MdlAddress = NULL;
            }

            IoFreeIrp(irp);
            irp = NULL;
        }
    }

    return irp;
}

VOID
IdeAtaPassThroughFreeIrp (
    PIRP Irp
    )
/*++

Routine Description:

    Free the irp and mdl allocated by IdeAtaPassThroughSetupIrp
    
Arguments:

    Irp: Irp to be freed.    

Return Value:

    None.
        
--*/
{
    ASSERT(Irp);

    if (Irp->MdlAddress) {
        MmUnlockPages(Irp->MdlAddress);
        IoFreeMdl(Irp->MdlAddress);
    }

    IoFreeIrp(Irp);

    return;
}

VOID
IdeAtaPassThroughFreeSrb (
    PSCSI_REQUEST_BLOCK Srb
    )
/*++

Routine Description:

    Free the srb allocated by IdeAtaPassThroughSetupSrb
    
Arguments:

    Srb: The srb to be freed.
    
Return Value:

    None
            
--*/
{
    ASSERT(Srb);

    ExFreePool(Srb);

    return;
}

NTSTATUS
IdeAtaPassThroughSyncCompletion (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )
/*++

Routine Description:

    The completion routine for IdeAtaPassThroughSendSynchronous. It
    just signals the event.
    
Arguments:
    
    DeviceObject : Not used.
    Irp : Not Used
    Context : Event to be signalled
        
Return Value:

    STATUS_MORE_PROCESSING_REQUIRED always.
    
--*/
{
    PKEVENT event = Context;

    KeSetEvent (event, 0, FALSE);

    return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS
IdeAtaPassThroughSendSynchronous (
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp
    )
/*++

Routine Description:

    Sends the irp synchronously to the PDO

Arguments:

    DeviceObject : The pdo
    
Return Value:    

    The irp's status
    
--*/
{
    KEVENT event;

    KeInitializeEvent(&event,
                      NotificationEvent,
                      FALSE);

    IoSetCompletionRoutine (Irp,
                            IdeAtaPassThroughSyncCompletion,
                            &event,
                            TRUE,
                            TRUE,
                            TRUE
                            );

    IoCallDriver(DeviceObject, Irp);

    KeWaitForSingleObject (&event,
                           Executive,
                           KernelMode,
                           FALSE,
                           NULL
                           );

    return Irp->IoStatus.Status;
}

VOID
IdeAtaPassThroughMarshalResults(
    IN PSCSI_REQUEST_BLOCK Srb,
    IN PATA_PASS_THROUGH_EX AtaPassThroughEx,
    IN BOOLEAN Direct,
    OUT PIO_STATUS_BLOCK IoStatus
    )
/*++

Routine Description:

    Fills in the IoStatus block with the appropriate status and information
    length. It also updates certain fields in the atapassthroughEx structure.
    
Arguments:

    Srb: The pass through srb.
    AtaPassThroughEx : the pass through structure.
    Direct : True if it is a direct ioctl.
    IoStatus : The Io status block that needs to be filled in.

Return Value:

    None
    
--*/        
{

    PAGED_CODE();

    //
    // copy over the task file registers
    //
    RtlCopyMemory(AtaPassThroughEx->CurrentTaskFile,
                 Srb->Cdb,
                 8
                 );

    RtlCopyMemory(AtaPassThroughEx->PreviousTaskFile,
                  (PUCHAR) (&Srb->Cdb[8]),
                  8
                  );

    //
    // zero out the reserved register as it is used by the
    // port driver
    //
    AtaPassThroughEx->CurrentTaskFile[7] = 0;
    AtaPassThroughEx->PreviousTaskFile[7] = 0;

    //
    // If the srb status is buffer underrun then set the status to success.
    // This insures that the data will be returned to the caller.
    //

    if (SRB_STATUS(Srb->SrbStatus) == SRB_STATUS_DATA_OVERRUN) {
        IoStatus->Status = STATUS_SUCCESS;
    }

    //
    // Set the information length
    //
    AtaPassThroughEx->DataTransferLength = Srb->DataTransferLength;

    if (Direct == TRUE) {

        //
        // the data is transferred directly to the supplied data buffer
        //
        IoStatus->Information = AtaPassThroughEx->Length;

    } else {

        //
        // actual data is returned
        //
        if (DataIn(AtaPassThroughEx) && 
            AtaPassThroughEx->DataBufferOffset != 0) {

            IoStatus->Information = 
                AtaPassThroughEx->DataBufferOffset + 
                AtaPassThroughEx->DataTransferLength;

        } else {

            IoStatus->Information = AtaPassThroughEx->Length;
        }
    }

    ASSERT((Srb->SrbStatus & SRB_STATUS_QUEUE_FROZEN) == 0);

    return;
}

#if defined (_WIN64)

VOID
IdeTranslateAtaPassThrough32To64(
    IN PATA_PASS_THROUGH_EX32 AtaPassThrough32,
    IN OUT PATA_PASS_THROUGH_EX AtaPassThrough64
    )
/*++

Routine Description:

    This function performs that marshaling.

Arguments:

    ataPassThrough32    - Supplies a pointer to a 32-bit ATA_PASS_THROUGH 
                          struct.

    ataPassThrough64    - Supplies a pointer to a 64-bit ATA_PASS_THROUGH 
                          structure, into which we'll copy the marshaled 
                          32-bit data.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    // Copy the first set of fields out of the 32-bit structure.  These 
    // fields all line up between the 32 & 64 bit versions.
    //
    // Note that we do NOT adjust the length in the srbControl.  This is to 
    // allow the calling routine to compare the length of the actual 
    // control area against the offsets embedded within.  
    //

    RtlCopyMemory(AtaPassThrough64, 
                  AtaPassThrough32, 
                  FIELD_OFFSET(ATA_PASS_THROUGH_EX, DataBufferOffset)
                  );

    //
    // Copy over the Taskfile.
    //

    RtlCopyMemory(AtaPassThrough64->CurrentTaskFile,
                  AtaPassThrough32->CurrentTaskFile,
                  8 * sizeof(UCHAR)
                  );

    RtlCopyMemory(AtaPassThrough64->PreviousTaskFile,
                  AtaPassThrough32->PreviousTaskFile,
                  8 * sizeof(UCHAR)
                  );

    //
    // Copy the fields that follow the ULONG_PTR.
    //

    AtaPassThrough64->DataBufferOffset = 
        (ULONG_PTR)AtaPassThrough32->DataBufferOffset;

    return;
}

VOID
IdeTranslateAtaPassThrough64To32(
    IN PATA_PASS_THROUGH_EX AtaPassThrough64,
    IN OUT PATA_PASS_THROUGH_EX32 AtaPassThrough32
    )
/*++

Routine Description:

    This function marshals a 64-bit version of the structure back into a 
    32-bit version.

Arguments:

    atapassthrough64 - Supplies a pointer to a 64-bit ATA_PASS_THROUGH
                       struct.

    ataPassThrough32 - Supplies the address of a pointer to a 32-bit
                      ATA_PASS_THROUGH structure, into which we'll copy the
                      marshaled 64-bit data.

Return Value:

    None.

--*/
{
    PAGED_CODE();

    //
    // Copy back the fields through the data offsets.
    //

    RtlCopyMemory(AtaPassThrough32, 
                  AtaPassThrough64,
                  FIELD_OFFSET(ATA_PASS_THROUGH_EX, DataBufferOffset));

    //
    // copy over the task file
    //
    RtlCopyMemory(AtaPassThrough32->CurrentTaskFile,
                  AtaPassThrough64->CurrentTaskFile,
                  8 * sizeof(UCHAR)
                  );

    RtlCopyMemory(AtaPassThrough32->PreviousTaskFile,
                  AtaPassThrough64->PreviousTaskFile,
                  8 * sizeof(UCHAR)
                  );

    return;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\pdopower.c ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    pdopower.c

Abstract:

--*/

#include "ideport.h"


VOID
IdePowerCheckBusyCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIDE_POWER_CONTEXT Context,
    IN NTSTATUS           Status
    );

NTSTATUS
DeviceQueryPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION irpStack;
    PPDO_EXTENSION pdoExtension;

    pdoExtension = RefPdoWithTag(
        DeviceObject,
        FALSE,
        Irp
        );

    if (pdoExtension) {

#if defined (DONT_POWER_DOWN_PAGING_DEVICE)
        irpStack = IoGetCurrentIrpStackLocation (Irp);

        if (!pdoExtension->CrashDumpPathCount ||
            ((irpStack->Parameters.Power.Type == SystemPowerState) &&
             (irpStack->Parameters.Power.State.SystemState == PowerSystemWorking)) ||
            ((irpStack->Parameters.Power.Type == DevicePowerState) &&
             (irpStack->Parameters.Power.State.SystemState == PowerDeviceD0))) {

            Irp->IoStatus.Status = STATUS_SUCCESS;

        } else {

            Irp->IoStatus.Status = STATUS_DEVICE_POWER_FAILURE;
        }
#else

        Irp->IoStatus.Status = STATUS_SUCCESS;

#endif // DONT_POWER_DOWN_PAGING_DEVICE

        UnrefPdoWithTag (pdoExtension, Irp);

    } else {

        Irp->IoStatus.Status = STATUS_SUCCESS;
    }

    PoStartNextPowerIrp (Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);

    //
    // Do not send this Irp down
    //

    return STATUS_SUCCESS;
}


NTSTATUS
IdePortSetPdoPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS           status;
    PIO_STACK_LOCATION irpStack;
    PPDO_EXTENSION     pdoExtension;


    irpStack     = IoGetCurrentIrpStackLocation (Irp);
    pdoExtension = DeviceObject->DeviceExtension;

    DebugPrint ((DBG_POWER,
                 "0x%x target %d got power irp 0x%x\n",
                 pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                 pdoExtension->TargetId,
                 Irp
                 ));


    DebugPrint ((DBG_POWER,
                 "IdePort: 0x%x device %d: current System Power State = 0x%x\n",
                 pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                 pdoExtension->TargetId,
                 pdoExtension->SystemPowerState));
    DebugPrint ((DBG_POWER,
                 "IdePort: 0x%x device %d: current Device Power State = 0x%x\n",
                 pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                 pdoExtension->TargetId,
                 pdoExtension->DevicePowerState));

    IoMarkIrpPending(Irp);

//    if (!(pdoExtension->LuFlags & PD_LOGICAL_UNIT_POWER_OK)) {
//
//        //
//        // The device does support power management commands
//        // just STATUS_SUCCESS everything.  If ACPI is around,
//        // it will power manage our device
//        //
//        status = STATUS_SUCCESS;
//
//    } else
    if (irpStack->Parameters.Power.Type == SystemPowerState) {

        DebugPrint ((DBG_POWER, "IdePortSetPdoPowerState: 0x%x target %d got a SYSTEM power irp 0x%x for system state 0x%x \n",
                    pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                    pdoExtension->TargetId,
                    Irp,
                    irpStack->Parameters.Power.State.SystemState));

        ASSERT (pdoExtension->PendingSystemPowerIrp == NULL);
#if DBG
        pdoExtension->PendingSystemPowerIrp = Irp;
        ASSERT (pdoExtension->PendingSystemPowerIrp);
#endif // DBG

        status = IdePortSetPdoSystemPowerState (DeviceObject, Irp);

    } else if (irpStack->Parameters.Power.Type == DevicePowerState) {

        DebugPrint ((DBG_POWER, "IdePortSetPdoPowerState: 0x%x target %d got a DEVICE power irp 0x%x for device state 0x%x \n",
                    pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                    pdoExtension->TargetId,
                    Irp,
                    irpStack->Parameters.Power.State.DeviceState));

        ASSERT (pdoExtension->PendingDevicePowerIrp == NULL);
#if DBG
        pdoExtension->PendingDevicePowerIrp = Irp;
        ASSERT (pdoExtension->PendingDevicePowerIrp);
#endif // DBG

        status = IdePortSetPdoDevicePowerState (DeviceObject, Irp);

    } else {

        status = STATUS_NOT_IMPLEMENTED;
    }


    if (status != STATUS_PENDING) {

        Irp->IoStatus.Status = status;

        IdePortPdoCompletePowerIrp (
            DeviceObject,
            Irp
            );
    }

    return STATUS_PENDING;
}


NTSTATUS
IdePortSetPdoSystemPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS           status;
    PIO_STACK_LOCATION irpStack;
    PPDO_EXTENSION     pdoExtension;
    SYSTEM_POWER_STATE newSystemState;
    POWER_STATE        powerState;
    POWER_ACTION       shutdownType;

    pdoExtension   = DeviceObject->DeviceExtension;
    status = STATUS_SUCCESS;

    irpStack        = IoGetCurrentIrpStackLocation (Irp);
    newSystemState  = irpStack->Parameters.Power.State.SystemState;
    shutdownType    = irpStack->Parameters.Power.ShutdownType;

    if (pdoExtension->SystemPowerState != newSystemState) {

        //
        // new system state request
        //

        if (pdoExtension->SystemPowerState == PowerSystemWorking) {

            //
            // Getting out of working state.
            //
            if ((newSystemState == PowerSystemShutdown) &&
                (shutdownType == PowerActionShutdownReset)) {

                //
                // spin up for BIOS POST
                //
                powerState.DeviceState = PowerDeviceD0;

            } else {

                //
                // put the device to D3 and freeze the device queue
                //

                //
                // Issue a D3 to top of my drive stack
                //
                powerState.DeviceState = PowerDeviceD3;

                pdoExtension->PendingPowerDownSystemIrp = Irp;
            }

            status = PoRequestPowerIrp (
                         pdoExtension->DeviceObject,
                         IRP_MN_SET_POWER,
                         powerState,
                         IdePortPdoRequestPowerCompletionRoutine,
                         Irp,
                         NULL
                         );

            if (NT_SUCCESS(status)) {

                status = STATUS_PENDING;
            }

        } else {

            if (newSystemState == PowerSystemHibernate) {

                //
                // we can't hibernate when we are in some sleep state
                //
                ASSERT (FALSE);
            }
        }
    }
    return status;
}



NTSTATUS
IdePortSetPdoDevicePowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PPDO_EXTENSION     pdoExtension;
    PIO_STACK_LOCATION irpStack;
    NTSTATUS           status;

    DEVICE_POWER_STATE newDeviceState;
    POWER_ACTION       shutdownType;

    BOOLEAN            issueIdeCommand;
    IDEREGS            ideReg;

    PIDE_POWER_CONTEXT context;
    BOOLEAN            powerUpParent;
    
    BOOLEAN            noopPassThrough;


    pdoExtension    = DeviceObject->DeviceExtension;
    status          = STATUS_SUCCESS;

    irpStack        = IoGetCurrentIrpStackLocation (Irp);
    newDeviceState  = irpStack->Parameters.Power.State.DeviceState;
    shutdownType    = irpStack->Parameters.Power.ShutdownType;

    powerUpParent   = FALSE;

    issueIdeCommand = FALSE;
    RtlZeroMemory (&ideReg, sizeof(ideReg));
      
    if (pdoExtension->DevicePowerState != newDeviceState) {

        if (pdoExtension->DevicePowerState == PowerDeviceD0) {

            POWER_STATE newPowerState;

            newPowerState.DeviceState = newDeviceState;

            //
            // getting out of D0 state, better call PoSetPowerState now
            // this gives the system a chance to flush before we
            // get out of D0
            //
            PoSetPowerState (
                pdoExtension->DeviceObject,
                DevicePowerState,
                newPowerState
                );
        }

        if (pdoExtension->DevicePowerState < newDeviceState) {

            KIRQL currentIrql;

            //
            // we are powering down, try to clean out the Lu device queue
            //
            KeAcquireSpinLock(&pdoExtension->ParentDeviceExtension->SpinLock, &currentIrql);

            pdoExtension->CurrentKey = 0;

            KeReleaseSpinLock(&pdoExtension->ParentDeviceExtension->SpinLock, currentIrql);
        }


        if ((newDeviceState == PowerDeviceD0) ||
            (newDeviceState == PowerDeviceD1)) {

            //
            // spinning up to D0 or D1...
            //
            DebugPrint ((DBG_POWER, "IdePort: Irp 0x%x to spin UP 0x%x %d...\n",
                        Irp,
                        pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                        pdoExtension->TargetId));

            if (pdoExtension->DevicePowerState == PowerDeviceD1) {

                //
                // D0-->D1
                // can't do much here

                DebugPrint ((DBG_POWER, "ATAPI: reqeust for PowerDeviceD1 to PowerDeviceD0\n"));

            } else if ((pdoExtension->DevicePowerState == PowerDeviceD0) ||
                       (pdoExtension->DevicePowerState == PowerDeviceD2)) {

                //
                // D1-->D0 or
                // D2-->D0 or D1
                //
                issueIdeCommand = TRUE;
                if (pdoExtension->ScsiDeviceType == READ_ONLY_DIRECT_ACCESS_DEVICE) {

                    ideReg.bCommandReg = IDE_COMMAND_ATAPI_RESET;
                    ideReg.bReserved = ATA_PTFLAGS_URGENT;

                } else {

                    ideReg.bCommandReg = IDE_COMMAND_IDLE_IMMEDIATE;
                    ideReg.bReserved = ATA_PTFLAGS_URGENT | ATA_PTFLAGS_STATUS_DRDY_REQUIRED;
                }

            } else {

                PFDO_EXTENSION fdoExtension = pdoExtension->ParentDeviceExtension;

                //
                // D3-->D0 or D1
                //
                issueIdeCommand = TRUE;
                ideReg.bReserved = ATA_PTFLAGS_BUS_RESET | ATA_PTFLAGS_URGENT;

                //
                // wait for busy to clear
                //
                if (fdoExtension->WaitOnPowerUp) {
                    ideReg.bSectorNumberReg = 3;
                }

                //
                // we are coming out of deeeeep sleep, make sure our parent
                // is awake (power up) before we can wake up
                //
                powerUpParent = TRUE;
            }

        } else if ((newDeviceState == PowerDeviceD2) ||
                   (newDeviceState == PowerDeviceD3)) {

            //
            // spinning down to D2 or D3...
            //
            DebugPrint ((DBG_POWER, "IdePort: Irp 0x%x to spin DOWN 0x%x %d...\n",
                         Irp,
                         pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                         pdoExtension->TargetId));

            if ((pdoExtension->DevicePowerState == PowerDeviceD0) ||
                (pdoExtension->DevicePowerState == PowerDeviceD1) ||
                (pdoExtension->DevicePowerState == PowerDeviceD2)) {

                //
                // going to D3
                //                                          
                if ((pdoExtension->PdoState & PDOS_NO_POWER_DOWN) ||
                    (shutdownType == PowerActionHibernate)) {
                    
                    //
                    // send an no-op command to block the queue
                    //
                    issueIdeCommand = TRUE;
                    ideReg.bReserved = ATA_PTFLAGS_NO_OP;
                    
                } else {
                    
                    //
                    // spin down
                    //
                    issueIdeCommand = TRUE;
                    ideReg.bCommandReg = IDE_COMMAND_STANDBY_IMMEDIATE;
                    ideReg.bReserved = ATA_PTFLAGS_STATUS_DRDY_REQUIRED;
                }

            } else if (pdoExtension->DevicePowerState == PowerDeviceD3) {

                //
                // PowerDeviceD3 -> PowerDeviceD2
                //
                // need to do a bus reset (spin up) and issue IDE_COMMAND_STANDBY_IMMEDIATE
                // (spin down).  this will cause uncessary INRUSH current.  bad
                // idea.  fail the request for now

                DebugPrint ((DBG_POWER, "ATAPI: reqeust for PowerDeviceD3 to PowerDeviceD2\n"));

                status = STATUS_INVALID_DEVICE_STATE;

            } else {

                status = STATUS_INVALID_DEVICE_STATE;
            }

        } else {

            status = STATUS_INVALID_DEVICE_STATE;
        }
    } 
    /*************
    else if ( pdoExtension->DevicePowerState == PowerDeviceD0) {

        //
        // Send a no-op so that it can drain the device queue
        //
        issueIdeCommand = TRUE;
        ideReg.bSectorCountReg = 1;
        ideReg.bReserved = ATA_PTFLAGS_NO_OP;
    }
    ***************/

    if (issueIdeCommand && NT_SUCCESS(status)) {

    
        if ((pdoExtension->PdoState & PDOS_DEADMEAT) ||
            (!(pdoExtension->PdoState & PDOS_STARTED))) {
            
            DebugPrint ((DBG_ALWAYS, 
                "ATAPI: power irp 0x%x for not-yet-started or deadmeat device 0x%x\n", 
                Irp, DeviceObject));
            
            //
            // even the device may not be ready to be
            // "power-managed", we still need to go 
            // through all the power code so that all
            // the flags/states will be consistent
            //                                 
            RtlZeroMemory (&ideReg, sizeof(ideReg));
            ideReg.bReserved = ATA_PTFLAGS_NO_OP | ATA_PTFLAGS_URGENT;
        }
                     
        //context = ExAllocatePool (NonPagedPool, sizeof(IDE_POWER_CONTEXT));
        ASSERT(InterlockedCompareExchange(&(pdoExtension->PowerContextLock), 1, 0) == 0);
        context = &(pdoExtension->PdoPowerContext);

        if (context) {

            context->PdoExtension       = pdoExtension;
            context->PowerIrp           = Irp;

            RtlZeroMemory (&context->AtaPassThroughData, sizeof(ATA_PASS_THROUGH));
            RtlMoveMemory (&context->AtaPassThroughData.IdeReg, &ideReg, sizeof(ideReg));

        } else {

            status = STATUS_NO_MEMORY;
            issueIdeCommand = FALSE;
        }
    }

    if (issueIdeCommand && NT_SUCCESS(status)) {

        if (powerUpParent) {

            status  = FdoChildRequestPowerUp (
                          pdoExtension->ParentDeviceExtension,
                          pdoExtension,
                          context
                          );
            ASSERT (NT_SUCCESS(status));

            //
            // the pass through will be issued by FdoChildRequestPowerUp() callback
            //
            issueIdeCommand = FALSE;
            status = STATUS_PENDING;
        }
    }

    if (issueIdeCommand && NT_SUCCESS(status)) {

        status = PdoRequestParentPowerUpCompletionRoutine (
                    context,
                    STATUS_SUCCESS
                    );

        //
        // this call will complete the power irp
        // always return STATUS_PENDING so that out callee
        // will not try to complete the same irp
        //
        status = STATUS_PENDING;
    }

    return status;
}

NTSTATUS
PdoRequestParentPowerUpCompletionRoutine (
    PVOID    Context,
    NTSTATUS ParentPowerUpStatus
)
{
    PIDE_POWER_CONTEXT context = Context;
    NTSTATUS status;

    if (NT_SUCCESS(ParentPowerUpStatus)) {

        PIDEREGS            ideReg;
        PATA_PASS_THROUGH   ataPassThrough;

        DebugPrint ((DBG_POWER, "PdoRequestParentPowerUpCompletionRoutine: calling IssueAsyncAtaPassThrough for pdo 0x%x\n", context->PdoExtension));

        //
        // hack. We need to check if the device is busy before we issue
        // the reset. Since there are no bits left in the bReserved 
        // register, we use the sectorCount register. It serves 2 purposes.
        // If it is non zero (and reserved has NO_OP set) then we would
        // perform a waitForBusy. It also indicates the time to wiat
        // in seconds.
        //
        ataPassThrough = &context->AtaPassThroughData;
        ideReg = &ataPassThrough->IdeReg;

        if ((ideReg->bReserved & ATA_PTFLAGS_BUS_RESET) &&
            (ideReg->bSectorNumberReg != 0)) {

            ideReg->bReserved = ATA_PTFLAGS_NO_OP | ATA_PTFLAGS_URGENT;

            status = IssueAsyncAtaPassThroughSafe (
                         context->PdoExtension->ParentDeviceExtension,
                         context->PdoExtension,
                         &context->AtaPassThroughData,
                         FALSE,
                         IdePowerCheckBusyCompletion,
                         context,
                         TRUE,
                         DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                         FALSE
                         );
        } else {

            //
            // parent woke up
            //
            status = IssueAsyncAtaPassThroughSafe (
                         context->PdoExtension->ParentDeviceExtension,
                         context->PdoExtension,
                         &context->AtaPassThroughData,
                         FALSE,
                         IdePowerPassThroughCompletion,
                         context,
                         TRUE,
                         DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                         FALSE
                         );
        }


    } else {

        status = ParentPowerUpStatus;
    }

    if (!NT_SUCCESS(status)) {

        context->PowerIrp->IoStatus.Status = status;

        IdePortPdoCompletePowerIrp (
                context->PdoExtension->DeviceObject,
                context->PowerIrp
                );

        ASSERT(InterlockedCompareExchange(&(context->PdoExtension->PowerContextLock), 0, 1) == 1);
        //ExFreePool (context);
    }

    return status;
}


VOID
IdePortPdoRequestPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    )
{
    PPDO_EXTENSION     pdoExtension;
    PIO_STACK_LOCATION irpStack;
    PIRP               irp = Context;

    pdoExtension         = (PPDO_EXTENSION) DeviceObject->DeviceExtension;
    irp->IoStatus.Status = IoStatus->Status;
    IdePortPdoCompletePowerIrp (
            pdoExtension->DeviceObject,
            irp
            );
    return;
}


VOID
IdePortPdoCompletePowerIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PPDO_EXTENSION          pdoExtension;
    PFDO_EXTENSION          fdoExtension;
    PIO_STACK_LOCATION      irpStack;
    BOOLEAN                 callPoSetPowerState;
    KIRQL                   currentIrql;
    NTSTATUS                status;
    POWER_ACTION            shutdownType;

    irpStack = IoGetCurrentIrpStackLocation (Irp);
    pdoExtension = DeviceObject->DeviceExtension;
    //shutdownType    = irpStack->Parameters.Power.ShutdownType;

    fdoExtension = pdoExtension->ParentDeviceExtension;

    status = Irp->IoStatus.Status;

    if (NT_SUCCESS(status)) {

        callPoSetPowerState = TRUE;

        Irp->IoStatus.Information = irpStack->Parameters.Power.State.DeviceState;

        if (irpStack->Parameters.Power.Type == SystemPowerState) {

            if (pdoExtension->SystemPowerState != irpStack->Parameters.Power.State.SystemState) {

                DebugPrint ((DBG_POWER,
                             "ATAPI: 0x%x target%d completing power Irp 0x%x with a new system state 0x%x\n",
                             pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                             pdoExtension->TargetId,
                             Irp,
                             irpStack->Parameters.Power.State.SystemState));

                if (pdoExtension->SystemPowerState == PowerSystemWorking) {

                    KeAcquireSpinLock(&fdoExtension->SpinLock, &currentIrql);

                    //
                    // got out of S0, block the device queue
                    //
                    pdoExtension->PdoState |= PDOS_QUEUE_FROZEN_BY_SLEEPING_SYSTEM;

                    DebugPrint ((DBG_POWER,
                                 "IdePort: 0x%x target %d is powered down with 0x%x items queued\n",
                                 pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                                 pdoExtension->TargetId,
                                 pdoExtension->NumberOfIrpQueued));

                    KeReleaseSpinLock(&fdoExtension->SpinLock, currentIrql);
                }

                if (irpStack->Parameters.Power.State.SystemState == PowerSystemWorking) {

                    KeAcquireSpinLock(&fdoExtension->SpinLock, &currentIrql);

                    //
                    // got into S0, unblock and restart the device queue
                    //
                    CLRMASK (pdoExtension->PdoState, PDOS_QUEUE_FROZEN_BY_SLEEPING_SYSTEM);

                    DebugPrint ((DBG_POWER,
                                 "IdePort: 0x%x target %d is power up with 0x%x items queued\n",
                                 pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                                 pdoExtension->TargetId,
                                 pdoExtension->NumberOfIrpQueued));

                    GetNextLuPendingRequest (fdoExtension, pdoExtension);

                    KeLowerIrql(currentIrql);
                }

                pdoExtension->SystemPowerState = (int)Irp->IoStatus.Information;
            }

            pdoExtension->PendingPowerDownSystemIrp = NULL;

        } else /* if (irpStack->Parameters.Power.Type == DevicePowerState) */ {

            if (pdoExtension->DevicePowerState == PowerDeviceD0) {

                //
                // PoSetPowerState is called before we power down
                //

                callPoSetPowerState = FALSE;
            }

            if (pdoExtension->DevicePowerState != irpStack->Parameters.Power.State.DeviceState) {

                DebugPrint ((DBG_POWER,
                             "ATAPI: 0x%x target %d completing power Irp 0x%x with a new device state 0x%x\n",
                             pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                             pdoExtension->TargetId,
                             Irp,
                             irpStack->Parameters.Power.State.DeviceState));

                if (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD3) {

#if 0
                    if (shutdownType == PowerActionHibernate) {
                        DebugPrint((0, "Don't power down the controller yet\n"));
                    } else {
#endif
                        //
						// should never do that if we are crashdump pointer
                        // tell parent that we just fell to sleep
                        //
                        FdoChildReportPowerDown (
                            fdoExtension,
                            pdoExtension
                            );
#if 0
                    }
#endif

                    KeAcquireSpinLock(&fdoExtension->SpinLock, &currentIrql);

                    //
                    // device is powered down.  block the device queue
                    //
                    SETMASK(pdoExtension->PdoState, PDOS_QUEUE_FROZEN_BY_POWER_DOWN);

                    DebugPrint ((DBG_POWER,
                                 "IdePort: 0x%x target %d is powered down with 0x%x items queued\n",
                                 pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                                 pdoExtension->TargetId,
                                 pdoExtension->NumberOfIrpQueued));

                    KeReleaseSpinLock(&fdoExtension->SpinLock, currentIrql);

                    if (pdoExtension->PendingPowerDownSystemIrp) {

                        //
                        // We get this power down irp
                        // because we are going to non-working state
                        // block the device queue
                        //

                        KeAcquireSpinLock(&fdoExtension->SpinLock, &currentIrql);

                        DebugPrint ((DBG_POWER,
                                     "ATAPI: blocking 0x%x target %d device queue\n",
                                     pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                                     pdoExtension->TargetId));

                        pdoExtension->PdoState |= PDOS_QUEUE_FROZEN_BY_SLEEPING_SYSTEM;

                        KeReleaseSpinLock(&fdoExtension->SpinLock, currentIrql);
                    }
                }

                if (irpStack->Parameters.Power.State.DeviceState == PowerDeviceD3) {

                    //
                    // get ready to reinit. the device via acpi data when
                    // we get out of D3
                    //
                    InterlockedIncrement (&pdoExtension->InitDeviceWithAcpiGtf);
                }

                if (pdoExtension->DevicePowerState == PowerDeviceD3) {

                    //
                    // just get out out D3, re-init. pdo
                    //
                    DebugPrint((DBG_POWER, "Calling DeviceInitDeviceState for irp 0x%x\n",
                                  Irp));
                    status = DeviceInitDeviceState (
                                 pdoExtension,
                                 DevicePowerUpInitCompletionRoutine,
                                 Irp
                                 );
                    if (!NT_SUCCESS(status)) {

                        DevicePowerUpInitCompletionRoutine (
                            Irp,
                            status
                            );
                    }

                    return;
                }

                pdoExtension->DevicePowerState = (int) Irp->IoStatus.Information;
            }
        }

        if ((callPoSetPowerState) && NT_SUCCESS(status)) {

            //
            // we didn't get out of device D0 state. calling PoSetPowerState now
            //

            PoSetPowerState (
                pdoExtension->DeviceObject,
                irpStack->Parameters.Power.Type,
                irpStack->Parameters.Power.State
                );
        }
    } else {

        if (irpStack->Parameters.Power.Type == SystemPowerState) {

            if (pdoExtension->SystemPowerState != irpStack->Parameters.Power.State.SystemState) {

                if (pdoExtension->SystemPowerState == PowerSystemWorking) {

                    //
                    // failed a system power down irp
                    //
                    KeAcquireSpinLock(&fdoExtension->SpinLock, &currentIrql);

                    //
                    // got into S0, unblock and restart the device queue
                    //
                    if (pdoExtension->PdoState & PDOS_QUEUE_FROZEN_BY_SLEEPING_SYSTEM) {

                        CLRMASK (pdoExtension->PdoState, PDOS_QUEUE_FROZEN_BY_SLEEPING_SYSTEM);

                        GetNextLuPendingRequest (fdoExtension, pdoExtension);

                        KeLowerIrql(currentIrql);

                    } else {

                        KeReleaseSpinLock(&fdoExtension->SpinLock, currentIrql);
                    }
                }
            }

            pdoExtension->PendingPowerDownSystemIrp = NULL;
        }
    }

    if (!NT_SUCCESS(status)) {

        DebugPrint ((DBG_ALWAYS,
                     "ATAPI: 0x%x target %d failed power Irp 0x%x. status = 0x%x\n",
                     pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                     pdoExtension->TargetId,
                     Irp,
                     Irp->IoStatus.Status));

        if (irpStack->Parameters.Power.Type == DevicePowerState) {

            //
            // ISSUE: 08/20/2000: Just failed a power D0 request...fail all pending irp
            //
            //ASSERT (irpStack->Parameters.Power.State.DeviceState != PowerDeviceD0);

            //
            // we will fail all the pending irps if we failed with status
            // no such device
            //
            if (status == STATUS_NO_SUCH_DEVICE) {

                DebugPrint ((0,
                             "Restarting the Lu queue after marking the device dead\n"
                             ));

                DebugPrint((0, 
                            "Device Power up irp failed with status 0x%x\n",
                            status
                            ));
                //
                // mark the pdo as dead
                // ISSUE: 12/19/2001. We should update deadmeat reason
                // for ease of debugging.
                //
                KeAcquireSpinLock(&pdoExtension->PdoSpinLock, &currentIrql);

                SETMASK (pdoExtension->PdoState, PDOS_DEADMEAT);

                KeReleaseSpinLock(&pdoExtension->PdoSpinLock, currentIrql);

                //
                // ISSUE: 12/19/2001: Should we call IoInvalidateDeviceRelations?
                // we should get a remove irp in this case anyway.
                //
                IoInvalidateDeviceRelations (
                    fdoExtension->AttacheePdo,
                    BusRelations
                    );

                //
                // start any pending requests
                // ISSUE: 12/19/2001: We should hold the pdospinlock at 
                // this time. But in the other routines we seem to be
                // holding just the fdospinlock before modifying the 
                // pdostate. We will leave it as such to minimise regressions.
                //
                KeAcquireSpinLock(&fdoExtension->SpinLock, &currentIrql);

                if (pdoExtension->PdoState & PDOS_QUEUE_FROZEN_BY_POWER_DOWN) {

                    //
                    // ISSUE: 12/19/2001: We are not updating the device power
                    // state to D0. This would cause all the further requests
                    // to ask for a new power up irp. The system would be slow
                    // if we get too many requests. The remove irp should arrive
                    // eventually and end the misery.
                    //
                    CLRMASK (pdoExtension->PdoState, PDOS_QUEUE_FROZEN_BY_POWER_DOWN);

                    //
                    // restart the lu queue (on an lu that is marked dead)
                    // we didn't run GTF or do any of the other initialization.
                    // Since we marked the device dead above, we can restart the
                    // queue.They will get completed with status 
                    // device_does_not_exist.
                    //
                    GetNextLuPendingRequest (fdoExtension, pdoExtension);

                    KeLowerIrql(currentIrql);

                } else {

                    KeReleaseSpinLock(&fdoExtension->SpinLock, currentIrql);
                }
            } else {

                //
                // ISSUE: 12/192001: we handle only status_no_such device
                //
                ASSERT (irpStack->Parameters.Power.State.DeviceState != PowerDeviceD0);
            }
        }
    }

#if DBG
    if (irpStack->Parameters.Power.Type == SystemPowerState) {

        DebugPrint ((DBG_POWER, "IdePortPdoCompletePowerIrp: 0x%x target %d completing a SYSTEM power irp 0x%x for system state 0x%x \n",
                     pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                     pdoExtension->TargetId,
                     Irp,
                     irpStack->Parameters.Power.State.SystemState));

        ASSERT (pdoExtension->PendingSystemPowerIrp == Irp);
        pdoExtension->PendingSystemPowerIrp = NULL;

    } else if (irpStack->Parameters.Power.Type == DevicePowerState) {

        DebugPrint ((DBG_POWER, "IdePortPdoCompletePowerIrp: 0x%x target %d completing a DEVICE power irp 0x%x for device state 0x%x \n",
                     pdoExtension->ParentDeviceExtension->IdeResource.TranslatedCommandBaseAddress,
                     pdoExtension->TargetId,
                     Irp,
                     irpStack->Parameters.Power.State.SystemState));

        ASSERT (pdoExtension->PendingDevicePowerIrp == Irp);
        pdoExtension->PendingDevicePowerIrp = NULL;
    }
#endif

    PoStartNextPowerIrp (Irp);
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
}

VOID
IdePowerCheckBusyCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIDE_POWER_CONTEXT Context,
    IN NTSTATUS           Status
    )
/*++

Routine Description

    Completion routine for ide pass through that would check if the
    device is busy. This is typically done before a reset to salvage
    drives that hang when a reset is issued while they are busy (due
    to a hardware reset)
    
Arguments:

    DeviceObject
    Context
    Status : Not used
    
Return Value

    None.
            
--*/
{
    PATA_PASS_THROUGH ataPassThrough;
    PIDEREGS ideReg;
    NTSTATUS status;

    ataPassThrough = &Context->AtaPassThroughData;
    ideReg = &ataPassThrough->IdeReg;

    //
    // send down the reset
    //

    RtlZeroMemory(ideReg, sizeof(IDEREGS));

    ideReg->bReserved = ATA_PTFLAGS_BUS_RESET | ATA_PTFLAGS_URGENT;

    status = IssueAsyncAtaPassThroughSafe (
                 Context->PdoExtension->ParentDeviceExtension,
                 Context->PdoExtension,
                 &Context->AtaPassThroughData,
                 FALSE,
                 IdePowerPassThroughCompletion,
                 Context,
                 TRUE,
                 DEFAULT_ATA_PASS_THROUGH_TIMEOUT,
                 FALSE
                 );

    return;
}

VOID
IdePowerPassThroughCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIDE_POWER_CONTEXT Context,
    IN NTSTATUS           Status
    )
{
    if (!NT_SUCCESS(Status)) {

        //
        // device failed power management command
        // will not try it anymore
        //
        KIRQL currentIrql;

        KeAcquireSpinLock(&Context->PdoExtension->PdoSpinLock, &currentIrql);

        SETMASK (Context->PdoExtension->PdoState, PDOS_NO_POWER_DOWN);

        KeReleaseSpinLock(&Context->PdoExtension->PdoSpinLock, currentIrql);

        Status = STATUS_SUCCESS;
    }

    Context->PowerIrp->IoStatus.Status = Status;

    IdePortPdoCompletePowerIrp (
        DeviceObject,
        Context->PowerIrp
        );

    ASSERT(InterlockedCompareExchange(&(Context->PdoExtension->PowerContextLock), 0, 1) == 1);
    //ExFreePool (Context);
}

VOID
DevicePowerUpInitCompletionRoutine (
    PVOID Context,
    NTSTATUS Status
    )
{
    PIRP irp = Context;
    PIO_STACK_LOCATION irpStack;
    PPDO_EXTENSION pdoExtension;
    KIRQL currentIrql;

    irpStack = IoGetCurrentIrpStackLocation (irp);
    pdoExtension = (PPDO_EXTENSION) irpStack->DeviceObject->DeviceExtension;

    if (!NT_SUCCESS(Status)) {

        //ASSERT (!"DevicePowerUpInitCompletionRoutine Failed\n");
        DebugPrint((DBG_ALWAYS, "ATAPI: ERROR: DevicePowerUpInitComplete failed with status %x\n",
                        Status));
    }

    ASSERT (pdoExtension->PendingDevicePowerIrp == irp);
    pdoExtension->PendingDevicePowerIrp = NULL;

    pdoExtension->DevicePowerState = (ULONG)irp->IoStatus.Information;

    PoSetPowerState (
        pdoExtension->DeviceObject,
        irpStack->Parameters.Power.Type,
        irpStack->Parameters.Power.State
        );

    KeAcquireSpinLock(&pdoExtension->ParentDeviceExtension->SpinLock, &currentIrql);

    //
    // got into D0, restart device queue
    //
    DebugPrint((DBG_POWER, "Clearing QUEUE_FROZEN_BY_POWER_DOWN flag\n"));
    CLRMASK(pdoExtension->PdoState, PDOS_QUEUE_FROZEN_BY_POWER_DOWN);

    GetNextLuPendingRequest (pdoExtension->ParentDeviceExtension, pdoExtension);

    KeLowerIrql(currentIrql);


    PoStartNextPowerIrp (irp);
    IoCompleteRequest(irp, IO_NO_INCREMENT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\pdopower.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1998
//
//  File:       pdopower.h
//
//--------------------------------------------------------------------------

#if !defined (___pdopower_h___)
#define ___pdopower_h___

typedef struct _SET_POWER_STATE_CONTEXT {

    KEVENT  Event;
    NTSTATUS  Status;

} SET_POWER_STATE_CONTEXT, *PSET_POWER_STATE_CONTEXT;

typedef struct _IDE_POWER_CONTEXT *PIDE_POWER_CONTEXT;

typedef struct _POWER_COMPLETION_CONTEXT {

    KEVENT       Event;
    NTSTATUS     Status;
    POWER_STATE  State;

} POWER_COMPLETION_CONTEXT, *PPOWER_COMPLETION_CONTEXT;
                          
NTSTATUS
DeviceQueryPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortSetPdoPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortSetPdoSystemPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
IdePortSetPdoDevicePowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

//
// private functions
//
                      
VOID
IdePortPdoPowerStartIo (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
                      
NTSTATUS
PdoRequestParentPowerUpCompletionRoutine (
    PVOID    Context,
    NTSTATUS ParentPowerUpStatus
);

VOID
IdePortPdoRequestPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

VOID
IdePortPdoCompletePowerIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
                      
                       
VOID
IdePowerPassThroughCompletion (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIDE_POWER_CONTEXT Context,
    IN NTSTATUS           Status
    );
                          
VOID
DevicePowerUpInitCompletionRoutine (
    PVOID Context,
    NTSTATUS Status
    );
                          
//NTSTATUS
//IdePortSetPowerDispatch(
//    IN PDEVICE_OBJECT DeviceObject,
//    IN PIRP Irp
//    );
                          
                                        
#endif // ___pdopower_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\port.h ===
/*++

Copyright (C) 1993-99  Microsoft Corporation

Module Name:

    port.h

Abstract:

--*/

#if !defined (___port_h___)
#define ___port_h___

//
// Notification Event Types
//

typedef enum _IDE_NOTIFICATION_TYPE {
    IdeRequestComplete,
    IdeNextRequest,
    IdeNextLuRequest,
    IdeResetDetected,
    IdeCallDisableInterrupts,
    IdeCallEnableInterrupts,
    IdeRequestTimerCall,
    IdeBusChangeDetected,     /* New */
    IdeWMIEvent,
    IdeWMIReregister,
    IdeAllDeviceMissing,
    IdeResetRequest
} IDE_NOTIFICATION_TYPE, *PIDE_NOTIFICATION_TYPE;

VOID
IdePortNotification(
    IN IDE_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    );

struct _SRB_DATA;

#define NUMBER_LOGICAL_UNIT_BINS 8
#define SP_NORMAL_PHYSICAL_BREAK_VALUE 17

#define IDE_NUM_RESERVED_PAGES  4

#ifdef LOG_GET_NEXT_CALLER
#define GET_NEXT_LOG_LENGTH     4
#endif

//
// Define a pointer to the synchonize execution routine.
//

typedef
BOOLEAN
(*PSYNCHRONIZE_ROUTINE) (
    IN PKINTERRUPT Interrupt,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext
    );

//
// Adapter object transfer information.
//

typedef struct _ADAPTER_TRANSFER {
    struct _SRB_DATA *SrbData;
    ULONG SrbFlags;
    PVOID LogicalAddress;
    ULONG Length;
}ADAPTER_TRANSFER, *PADAPTER_TRANSFER;

//
// Port driver error logging
//

typedef struct _ERROR_LOG_ENTRY {
    UCHAR MajorFunctionCode;
    UCHAR PathId;
    UCHAR TargetId;
    UCHAR Lun;
    ULONG ErrorCode;
    ULONG UniqueId;
    ULONG ErrorLogRetryCount;
    ULONG SequenceNumber;
} ERROR_LOG_ENTRY, *PERROR_LOG_ENTRY;

//
// SCSI request extension for port driver.
//

typedef struct _SRB_DATA {
    LIST_ENTRY RequestList;
    PSCSI_REQUEST_BLOCK CurrentSrb;
    struct _SRB_DATA *CompletedRequests;
    ULONG ErrorLogRetryCount;
    ULONG SequenceNumber;
    PCHAR SrbDataOffset;

#ifdef ENABLE_COMMAND_LOG
    PCOMMAND_LOG IdeCommandLog;
    ULONG IdeCommandLogIndex;
#endif

    ULONG Flags;

}SRB_DATA, *PSRB_DATA;

#define SRB_DATA_RESERVED_PAGES     0x100

//
// Define data storage for access at interrupt Irql.
//

typedef struct _PDO_EXTENSION * PPDO_EXTENSION;
typedef PPDO_EXTENSION PLOGICAL_UNIT_EXTENSION;

typedef struct _INTERRUPT_DATA {

    //
    // SCSI port interrupt flags
    //

    ULONG InterruptFlags;

    //
    // List head for singlely linked list of complete IRPs.
    //

    PSRB_DATA CompletedRequests;

    //
    // Adapter object transfer parameters.
    //

    ADAPTER_TRANSFER MapTransferParameters;

    //
    // Error log information.
    //

    ERROR_LOG_ENTRY  LogEntry;

    //
    // Logical unit to start next.
    //

    PLOGICAL_UNIT_EXTENSION ReadyLogicalUnit;

    //
    // List of completed abort reqeusts.
    //

    PLOGICAL_UNIT_EXTENSION CompletedAbort;

    //
    // Miniport timer request routine.
    //

    PHW_INTERRUPT HwTimerRequest;

    //
    // Mini port timer request time in micro seconds.
    //

    ULONG MiniportTimerValue;

    //
    // The PDO that causes a bus reset
    //
    PPDO_EXTENSION PdoExtensionResetBus;

} INTERRUPT_DATA, *PINTERRUPT_DATA;

//
// ACPI Firmware Settings
//
typedef struct _DEVICE_SETTINGS {

    ULONG   NumEntries;
    IDEREGS FirmwareSettings[0];

} DEVICE_SETTINGS, *PDEVICE_SETTINGS;

//
// Fdo Power Context (pre-alloced)
//
typedef struct _FDO_POWER_CONTEXT {

    BOOLEAN            TimingRestored;

    PIRP               OriginalPowerIrp;
    POWER_STATE_TYPE   newPowerType;
    POWER_STATE        newPowerState;

} FDO_POWER_CONTEXT, *PFDO_POWER_CONTEXT;

typedef enum _IDE_DEBUG_EVENT{
    CrcEvent =0,
    BusyEvent,
    RwEvent,
    MaxIdeEvent
}IDE_DEBUG_EVENT;

typedef struct _LAST_REQUEST {

    SCSI_REQUEST_BLOCK Srb;

} LAST_REQUEST, *PLAST_REQUEST;

typedef struct _PDO_EXTENSION * PPDO_EXTENSION;
typedef struct _HW_DEVICE_EXTENSION * PHW_DEVICE_EXTENSION;
typedef struct _CONTROLLER_PARAMETERS * PCONTROLLER_PARAMETERS;
typedef struct _IDE_REGISTERS_1 *PIDE_REGISTERS_1;
typedef struct _IDE_REGISTERS_2 *PIDE_REGISTERS_2;
typedef struct _ENUMERATION_STRUCT *PENUMERATION_STRUCT;

//
// Device extension
//
typedef struct _FDO_EXTENSION {

    EXTENSION_COMMON_HEADER;
    PCM_RESOURCE_LIST   ResourceList;

    IDE_RESOURCE IdeResource;

    PCIIDE_SYNC_ACCESS_INTERFACE SyncAccessInterface;

    PCIIDE_XFER_MODE_INTERFACE TransferModeInterface;

    PCIIDE_REQUEST_PROPER_RESOURCES RequestProperResourceInterface;

    //
    // Device extension for miniport routines.
    //
    PHW_DEVICE_EXTENSION HwDeviceExtension;

    //
    // We are a child of a busmaster parent
    //
    BOOLEAN                BoundWithBmParent;

    BOOLEAN SymbolicLinkCreated;
    ULONG IdePortNumber;               // offset 0x0C
    ULONG ScsiPortNumber;               // offset 0x0C

    //
    // Active requests count.  This count is biased by -1 so a value of -1
    // indicates there are no requests out standing.
    //

    //LONG ActiveRequestCount;        // offset 0x10

    //
    // SCSI port driver flags
    //

    ULONG Flags;                    // offset 0x14

    ULONG FdoState;

    //
    // Srb flags to OR into all SRB.
    //

    ULONG SrbFlags;                 // offset 0x18
    LONG PortTimeoutCounter;        // offset 0x1C
    ULONG ResetCallAgain;
    PSCSI_REQUEST_BLOCK  ResetSrb;

    //
    // Number of SCSI buses
    //

    UCHAR MaxLuCount;               // offset 0x22
    PKINTERRUPT InterruptObject;    // offset 0x24

    //
    // Global device sequence number.
    //

    ULONG SequenceNumber;           // offset 0x30
    KSPIN_LOCK SpinLock;            // offset 0x34

    PADAPTER_OBJECT DmaAdapterObject;
    ADAPTER_TRANSFER FlushAdapterParameters;

    //
    // Pointer to the per SRB data array.
    //
    //PSRB_DATA SrbData;

    //
    // Pointer to the per SRB free list.
    //
    //PSRB_DATA FreeSrbData;

    //
    // Miniport service routine pointers.
    //
    PHW_INTERRUPT HwTimerRequest;

    //
    // Spinlock that protects LogicalUnitList manipulation
    //
    KSPIN_LOCK LogicalUnitListSpinLock;

    //
    // Number of logical unit in LogicalUnitList[]
    // Protected by LogicalUnitListSpinLock
    //
    UCHAR NumberOfLogicalUnits;

    //
    //
    //
    CCHAR NumberOfLogicalUnitsPowerUp;

    BOOLEAN DeviceChanged;
    //
    // panasonic pcmcia ide controller
    //
    BOOLEAN panasonicController;

    //
    // non-pcmcia controller, this is always set
    // if pcmcia controller, it is not set unless
    // registry flag PCMCIA_IDE_CONTROLLER_HAS_SLAVE
    // is non-zero
    //
    ULONG MayHaveSlaveDevice;

    //
    // Array of logical unit extensions.
    // Protected by LogicalUnitListSpinLock
    //
    PLOGICAL_UNIT_EXTENSION LogicalUnitList[NUMBER_LOGICAL_UNIT_BINS];

    //
    // Interrupt level data storage.
    //

    INTERRUPT_DATA InterruptData;

    //
    // SCSI Capabilities structure
    //

    IO_SCSI_CAPABILITIES Capabilities;

    //
    // Miniport timer object.
    //

    KTIMER MiniPortTimer;

    //
    // Miniport DPC for timer object.
    //

    KDPC MiniPortTimerDpc;

    //
    // channel timing from ACPI/BIOS
    //
    ACPI_IDE_TIMING BootAcpiTimingSettings;
    ACPI_IDE_TIMING AcpiTimingSettings;

    //
    // Transfermode cycle time
    //
    PULONG DefaultTransferModeTimingTable;

    //
    // User choice
    //
    IDE_DEVICETYPE UserChoiceDeviceType[MAX_IDE_DEVICE * MAX_IDE_LINE];
    ULONG UserChoiceTransferMode[MAX_IDE_DEVICE * MAX_IDE_LINE];
    ULONG UserChoiceTransferModeForAtapiDevice[MAX_IDE_DEVICE * MAX_IDE_LINE];
    ULONG TimingModeAllowed[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Use aggressive DMA
    //
    DMADETECTIONLEVEL DmaDetectionLevel;

    //
    // Pre-alloced context structure for power routines
    //
    FDO_POWER_CONTEXT   FdoPowerContext[2];

#if DBG
    //
    // Locks to synchronize access to the pre-alloced power context
    //
    ULONG   PowerContextLock[2];
#endif

#ifdef IDE_MEASURE_BUSSCAN_SPEED
    //
    // keep track of the time spent on the first busscan
    //
    ULONG BusScanTime;
#endif

    //
    // Pre-alloced structs used during enumeration
    //
#if DBG
    ULONG EnumStructLock;
#endif

    PENUMERATION_STRUCT PreAllocEnumStruct;

    //
    // Reserved error log entry per device to be used to log 
    // insufficient resources error
    //
    PVOID ReserveAllocFailureLogEntry[MAX_IDE_DEVICE];

    //
    // Temporary: Should be removed once I check in the fix 
    // for low memory condition
    //
    ULONG NumMemoryFailure;
    ULONG LastMemoryFailure;

    //
    // Reserve pages for use during low memory conditions
    //
    PVOID   ReservedPages;

#ifdef ENABLE_NATIVE_MODE
    //
    // Parent's interrupt interface
    //
    PCIIDE_INTERRUPT_INTERFACE InterruptInterface;
#endif

#ifdef ENABLE_48BIT_LBA
    ULONG EnableBigLba;
#endif

    ULONG WaitOnPowerUp;

#ifdef LOG_GET_NEXT_CALLER
    ULONG GetNextLuIndex;
    ULONG GetNextLuCallerLineNumber[GET_NEXT_LOG_LENGTH];
    ULONG GetNextLuCallerFlags[GET_NEXT_LOG_LENGTH];
    UCHAR GetNextLuCallerFileName[GET_NEXT_LOG_LENGTH][256];
    ULONG CompletedCommandIndex;
    LAST_REQUEST CompletedCommandQueue[GET_NEXT_LOG_LENGTH];
#endif

#ifdef ENABLE_ATAPI_VERIFIER
    ULONG IdeVerifierFlags[MAX_IDE_DEVICE];
    ULONG IdeDebugVerifierFlags[MAX_IDE_DEVICE];
    ULONG IdeInternalVerifierFlags[MAX_IDE_DEVICE];
    ULONG IdeVerifierEventCount[MAX_IDE_DEVICE][MaxIdeEvent];
    ULONG IdeVerifierEventFrequency[MAX_IDE_DEVICE][MaxIdeEvent];
#endif

    //
    // List link for FDO list.
    //
    
    LIST_ENTRY NextFdoLink;

} FDO_EXTENSION, *PFDO_EXTENSION;

typedef struct _CONFIGURATION_CONTEXT {
    HANDLE BusKey;
    HANDLE ServiceKey;
    HANDLE DeviceKey;
    ULONG AdapterNumber;
    ULONG LastAdapterNumber;
    ULONG BusNumber;
    PVOID Parameter;
    PACCESS_RANGE AccessRanges;
    BOOLEAN DisableTaggedQueueing;
    BOOLEAN DisableMultipleLu;
}CONFIGURATION_CONTEXT, *PCONFIGURATION_CONTEXT;

typedef struct _INTERRUPT_CONTEXT {
    PFDO_EXTENSION DeviceExtension;
    PINTERRUPT_DATA SavedInterruptData;
}INTERRUPT_CONTEXT, *PINTERRUPT_CONTEXT;

typedef struct _RESET_CONTEXT {
    PFDO_EXTENSION DeviceExtension;
    UCHAR   PathId;
    BOOLEAN NewResetSequence;
    PSCSI_REQUEST_BLOCK  ResetSrb;
}RESET_CONTEXT, *PRESET_CONTEXT;

#define NEED_REQUEST_SENSE(Srb) (Srb->ScsiStatus == SCSISTAT_CHECK_CONDITION \
        && !(Srb->SrbStatus & SRB_STATUS_AUTOSENSE_VALID) &&                 \
        Srb->SenseInfoBuffer && Srb->SenseInfoBufferLength )

#define LONG_ALIGN (sizeof(LONG) - 1)

#define DEVICE_EXTENSION_SIZE sizeof(DEVICE_EXTENSION)


//
// Port driver extension flags.
//

//
// This flag indicates that a request has been passed to the miniport and the
// miniport has not indicated it is ready for another request.  It is set by
// IdeStartIoSynchronized. It is cleared by IdePortCompletionDpc when the
// miniport asks for another request.  Note the port driver will defer giving
// the miniport driver a new request if the current request disabled disconnects.
//

#define PD_DEVICE_IS_BUSY            0X00001

//
// Indicates that IdePortCompletionDpc needs to be run.  This is set when
// A miniport makes a request which must be done at DPC and is cleared when
// when the request information is gotten by IdeGetInterruptState.
//

#define PD_NOTIFICATION_REQUIRED     0X00004

//
// Indicates the miniport is ready for another request.  Set by
// ScsiPortNotification and cleared by IdeGetInterruptState.  This flag is
// stored in the interrupt data structure.
//

#define PD_READY_FOR_NEXT_REQUEST    0X00008

//
// Indicates the miniport wants the adapter channel flushed.  Set by
// IdePortFlushDma and cleared by IdeGetInterruptState.  This flag is
// stored in the data interrupt structure.  The flush adapter parameters
// are saved in the device object.
//

#define PD_FLUSH_ADAPTER_BUFFERS     0X00010

//
// Indicates the miniport wants the adapter channel programmed.  Set by
// IdePortIoMapTransfer and cleared by IdeGetInterruptState or
// IdePortFlushDma.  This flag is stored in the interrupt data structure.
// The I/O map transfer parameters are saved in the interrupt data structure.
//

#define PD_MAP_TRANSFER              0X00020

//
// Indicates the miniport wants to log an error.  Set by
// IdePortLogError and cleared by IdeGetInterruptState.  This flag is
// stored in the interrupt data structure.  The error log parameters
// are saved in the interrupt data structure.  Note at most one error per DPC
// can be logged.
//

#define PD_LOG_ERROR                 0X00040

//
// Indicates that no request should be sent to the miniport after
// a bus reset. Set when the miniport reports a reset or the port driver
// resets the bus. It is cleared by IdeTimeoutSynchronized.  The
// PortTimeoutCounter is used to time the length of the reset hold.  This flag
// is stored in the interrupt data structure.
//

#define PD_RESET_HOLD                0X00080

//
// Indicates a request was stopped due to a reset hold.  The held request is
// stored in the current request of the device object.  This flag is set by
// IdeStartIoSynchronized and cleared by IdeTimeoutSynchronized which also
// starts the held request when the reset hold has ended.  This flag is stored
// in the interrupt data structure.
//

#define PD_HELD_REQUEST              0X00100

//
// Indicates the miniport has reported a bus reset.  Set by
// IdePortNotification and cleared by IdeGetInterruptState.  This flag is
// stored in the interrupt data structure.
//

#define PD_RESET_REPORTED            0X00200

//
// Indicates there is a pending request for which resources
// could not be allocated.  This flag is set by IdeAllocateRequestStructures
// which is called from IdePortStartIo.  It is cleared by
// IdeProcessCompletedRequest when a request completes which then calls
// IdePortStartIo to try the request again.
//

#define PD_PENDING_DEVICE_REQUEST    0X00800

//
// This flag indicates that there are currently no requests executing with
// disconnects disabled.  This flag is normally on.  It is cleared by
// IdeStartIoSynchronized when a request with disconnect disabled is started
// and is set when that request completes.  IdeProcessCompletedRequest will
// start the next request for the miniport if PD_DEVICE_IS_BUSY is clear.
//

#define PD_DISCONNECT_RUNNING        0X01000

//
// Indicates the miniport wants the system interrupts disabled.  Set by
// IdePortNofitication and cleared by IdePortCompletionDpc.  This flag is
// NOT stored in the interrupt data structure.  The parameters are stored in
// the device extension.
//

#define PD_DISABLE_CALL_REQUEST      0X02000

//
// Indicates that system interrupts have been enabled and that the miniport
// has disabled its adapter from interruptint.  The miniport's interrupt
// routine is not called while this flag is set.  This flag is set by
// IdePortNotification when a CallEnableInterrupts request is made and
// cleared by IdeEnableInterruptSynchronized when the miniport requests that
// system interrupts be disabled.  This flag is stored in the interrupt data
// structure.
//

#define PD_DISABLE_INTERRUPTS        0X04000

//
// Indicates the miniport wants the system interrupt enabled.  Set by
// IdePortNotification and cleared by IdeGetInterruptState.  This flag is
// stored in the interrupt data structure.  The call enable interrupts
// parameters are saved in the device extension.
//

#define PD_ENABLE_CALL_REQUEST       0X08000

//
// Indicates the miniport is wants a timer request.  Set by
// IdePortNotification and cleared by IdeGetInterruptState.  This flag is
// stored in the interrupt data structure. The timer request parameters are
// stored in the interrupt data structure.
//

#define PD_TIMER_CALL_REQUEST        0X10000


//
// channel looks empty
//
#define PD_ALL_DEVICE_MISSING        0X20000

//
// Request a reset
//
#define PD_RESET_REQUEST             0x40000 

//
// Reserve pages are being used by another request
//
#define PD_RESERVED_PAGES_IN_USE     0x80000 

//
// The following flags should not be cleared from the interrupt data structure
// by IdeGetInterruptState.
//

#define PD_INTERRUPT_FLAG_MASK (PD_RESET_HOLD | PD_HELD_REQUEST | PD_DISABLE_INTERRUPTS)

//
// Logical unit extension flags.
//

//
// Indicates the logical unit queue is frozen.  Set by
// IdeProcessCompletedRequest when an error occurs and is cleared by the class
// driver.
//

#define PD_QUEUE_FROZEN              0X0001

//
// Indicates that the miniport has an active request for this logical unit.
// Set by IdeStartIoSynchronized when the request is started and cleared by
// GetNextLuRequest.  This flag is used to track when it is ok to start another
// request from the logical unit queue for this device.
//

#define PD_LOGICAL_UNIT_IS_ACTIVE    0X0002

//
// Indicates that a request for this logical unit has failed and a REQUEST
// SENSE command needs to be done. This flag prevents other requests from
// being started until an untagged, by-pass queue command is started.  This
// flag is cleared in IdeStartIoSynchronized.  It is set by
// IdeGetInterruptState.
//

#define PD_NEED_REQUEST_SENSE  0X0004

//
// Indicates that a request for this logical unit has completed with a status
// of BUSY or QUEUE FULL.  This flag is set by IdeProcessCompletedRequest and
// the busy request is saved in the logical unit structure.  This flag is
// cleared by IdePortTickHandler which also restarts the request.  Busy
// request may also be requeued to the logical unit queue if an error occurs
// on the device (This will only occur with command queueing.).  Not busy
// requests are nasty because they are restarted asynchronously by
// IdePortTickHandler rather than GetNextLuRequest. This makes error recovery
// more complex.
//

#define PD_LOGICAL_UNIT_IS_BUSY      0X0008

//
// This flag indicates a queue full has been returned by the device.  It is
// similar to PD_LOGICAL_UNIT_IS_BUSY but is set in IdeGetInterruptState when
// a QUEUE FULL status is returned.  This flag is used to prevent other
// requests from being started for the logical unit before
// IdeProcessCompletedRequest has a chance to set the busy flag.
//

#define PD_QUEUE_IS_FULL             0X0010


//
// Indicates that there is a request for this logical unit which cannot be
// executed for now.  This flag is set by IdeAllocateRequestStructures.  It is
// cleared by GetNextLuRequest when it detects that the pending request
// can now be executed. The pending request is stored in the logical unit
// structure.  A new single non-queued reqeust cannot be executed on a logical
// that is currently executing queued requests.  Non-queued requests must wait
// unit for all queued requests to complete.  A non-queued requests is one
// which is not tagged and does not have SRB_FLAGS_NO_QUEUE_FREEZE set.
// Normally only read and write commands can be queued.
//


//#define PD_LOGICAL_UNIT_MUST_SLEEP      0X0020
//#define PD_LOGICAL_UNIT_STOP_READY      0X0040
//#define PD_LOGICAL_UNIT_REMOVE_READY    0X0080
//#define PD_LOGICAL_UNIT_ALWAYS_QUEUE    (PD_LOGICAL_UNIT_STOP_READY | PD_LOGICAL_UNIT_REMOVE_READY)

//#define PD_LOGICAL_UNIT_POWER_OK        0X0100


//#define PD_LOGICAL_IN_PAGING_PATH       0X2000

//#define PD_LOGICAL_UNIT_LEGACY_ATTACHER 0X4000

//
// Indicates that the LogicalUnit has been allocated for a rescan request.
// This flag prevents IOCTL_SCSI_MINIPORT requests from attaching to this
// logical unit, since the possibility exists that it could be freed before
// the IOCTL request is complete.
//

#define PD_RESCAN_ACTIVE             0x8000



//
// FdoExtension FdoState
//
#define FDOS_DEADMEAT                (1 << 0)
#define FDOS_STARTED                 (1 << 1)
#define FDOS_STOPPED                 (1 << 2)


//
// Port Timeout Counter values.
//

#define PD_TIMER_STOPPED             -1
#define PD_TIMER_RESET_HOLD_TIME     1

//
// Define the mimimum and maximum number of srb extensions which will be allocated.
//

#define MINIMUM_SRB_EXTENSIONS        16
#define MAXIMUM_SRB_EXTENSIONS       512

//
// Size of the buffer used for registry operations.
//

#define SP_REG_BUFFER_SIZE 512

//
// Number of times to retry when a BUSY status is returned.
//

#define BUSY_RETRY_COUNT 20

//
// Number of times to retry an INQUIRY request.
//

#define INQUIRY_RETRY_COUNT 2

//
// Function declarations
//

IO_ALLOCATION_ACTION
CallIdeStartIoSynchronized (
    IN PVOID Reserved1,
    IN PVOID Reserved2,
    IN PVOID Reserved3,
    IN PVOID DeviceObject
    );

NTSTATUS
IdePortCreateClose (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
IdePortDispatch(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
IdePortAllocateAccessToken (
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
IdePortStartIo(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

BOOLEAN
IdePortInterrupt(
    IN PKINTERRUPT InterruptObject,
    IN PDEVICE_OBJECT DeviceObject
    );

VOID
IdePortCompletionDpc(
    IN PKDPC Dpc,
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
IdePortDeviceControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

VOID
IdePortTickHandler(
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID Context
    );

BOOLEAN
AtapiRestartBusyRequest (
    PFDO_EXTENSION DeviceExtension,
    PPDO_EXTENSION LogicalUnit
    );

VOID
IssueRequestSense(
    IN PPDO_EXTENSION PdoExtension,
    IN PSCSI_REQUEST_BLOCK FailingSrb
    );

VOID
IdePortLogError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb OPTIONAL,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    );

NTSTATUS
IdePortInternalCompletion(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

BOOLEAN
IdeStartIoSynchronized (
    PVOID ServiceContext
    );

BOOLEAN
IdeResetBusSynchronized (
    PVOID ServiceContext
    );

BOOLEAN
IdeTimeoutSynchronized (
    PVOID ServiceContext
    );

VOID
IssueAbortRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

BOOLEAN
IdeGetInterruptState(
    IN PVOID ServiceContext
    );

VOID
LogErrorEntry(
    IN PFDO_EXTENSION DeviceExtension,
    IN PERROR_LOG_ENTRY LogEntry
    );

VOID
GetNextLuPendingRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

#ifdef LOG_GET_NEXT_CALLER

#define GetNextLuRequest(x, y)      GetNextLuRequest2(x, y, __FILE__, __LINE__)

VOID
GetNextLuRequest2(
    IN PFDO_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit,
    IN PUCHAR FileName,
    IN ULONG  LineNumber
    );

#else

VOID
GetNextLuRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION LogicalUnit
    );

#endif


VOID
IdeLogTimeoutError(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp,
    IN ULONG UniqueId
    );

NTSTATUS
IdeTranslateSrbStatus(
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
IdeProcessCompletedRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PSRB_DATA SrbData,
    OUT PBOOLEAN CallStartIo
    );

PSRB_DATA
IdeGetSrbData(
    IN PFDO_EXTENSION DeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb
    );

VOID
IdeCompleteRequest(
    IN PFDO_EXTENSION DeviceExtension,
    IN PSRB_DATA SrbData,
    IN UCHAR SrbStatus
    );

NTSTATUS
IdeSendMiniPortIoctl(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP RequestIrp
    );

NTSTATUS
IdeGetInquiryData(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

NTSTATUS
IdeSendPassThrough(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

#if defined (_WIN64)
NTSTATUS
IdeTranslatePassThrough32To64(
    IN PSCSI_PASS_THROUGH32 SrbControl32,
    IN OUT PSCSI_PASS_THROUGH SrbControl64
    );

VOID
IdeTranslatePassThrough64To32(
    IN PSCSI_PASS_THROUGH SrbControl64,
    IN OUT PSCSI_PASS_THROUGH32 SrbControl32
    );
#endif

NTSTATUS
IdeClaimLogicalUnit(
    IN PFDO_EXTENSION DeviceExtension,
    IN PIRP Irp
    );

VOID
IdeMiniPortTimerDpc(
    IN struct _KDPC *Dpc,
    IN PVOID DeviceObject,
    IN PVOID SystemArgument1,
    IN PVOID SystemArgument2
    );

BOOLEAN
IdeSynchronizeExecution (
    IN PKINTERRUPT Interrupt,
    IN PKSYNCHRONIZE_ROUTINE SynchronizeRoutine,
    IN PVOID SynchronizeContext
    );

NTSTATUS
IdeGetCommonBuffer(
    PFDO_EXTENSION DeviceExtension,
    ULONG NonCachedExtensionSize
    );

VOID
IdeDeviceCleanup(
    PFDO_EXTENSION DeviceExtension
    );

NTSTATUS
IdeInitializeConfiguration(
    IN PFDO_EXTENSION DeviceExtension,
    IN PCONFIGURATION_CONTEXT Context
    );

#define IDEPORT_PUT_LUNEXT_IN_IRP(IrpStack, LogUnitExt) (IrpStack->Parameters.Others.Argument4 = LogUnitExt)
#define IDEPORT_GET_LUNEXT_IN_IRP(IrpStack)             ((PLOGICAL_UNIT_EXTENSION) (IrpStack->Parameters.Others.Argument4))

VOID
IdePortCompleteRequest(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN UCHAR SrbStatus
    );

NTSTATUS
IdePortFlushLogicalUnit (
    PFDO_EXTENSION          FdoExtension,
    PLOGICAL_UNIT_EXTENSION LogUnitExtension,
    BOOLEAN                 Forced
);

typedef VOID (*ASYNC_PASS_THROUGH_COMPLETION) (
    IN PDEVICE_OBJECT DeviceObject,
    PVOID Context,
    NTSTATUS Status
    );

NTSTATUS
IssueAsyncAtaPassThroughSafe (
    IN PFDO_EXTENSION                DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION       LogUnitExtension,
    IN OUT PATA_PASS_THROUGH         AtaPassThroughData,
    IN BOOLEAN                       DataIn,
    IN ASYNC_PASS_THROUGH_COMPLETION Completion,
    IN PVOID                         Context,
    IN BOOLEAN                       PowerRelated,
    IN ULONG                         TimeOut,
    IN BOOLEAN                         MustSucceed
);

typedef struct _ATA_PASSTHROUGH_CONTEXT {

    PDEVICE_OBJECT                DeviceObject;

    ASYNC_PASS_THROUGH_COMPLETION CallerCompletion;
    PVOID                         CallerContext;
    PSCSI_REQUEST_BLOCK           Srb;
    PSENSE_DATA                   SenseInfoBuffer;
    BOOLEAN                         MustSucceed;
    PATA_PASS_THROUGH             DataBuffer;

} ATA_PASSTHROUGH_CONTEXT, *PATA_PASSTHROUGH_CONTEXT;

NTSTATUS
AtaPassThroughCompletionRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    );

typedef struct _SYNC_ATA_PASSTHROUGH_CONTEXT {

    KEVENT      Event;
    NTSTATUS    Status;

} SYNC_ATA_PASSTHROUGH_CONTEXT, *PSYNC_ATA_PASSTHROUGH_CONTEXT;


typedef struct _FLUSH_ATA_PASSTHROUGH_CONTEXT {

    PIRP               FlushIrp;
    PATA_PASS_THROUGH  ataPassThroughData;

} FLUSH_ATA_PASSTHROUGH_CONTEXT, *PFLUSH_ATA_PASSTHROUGH_CONTEXT;

NTSTATUS
IssueSyncAtaPassThroughSafe (
    IN PFDO_EXTENSION           DeviceExtension,
    IN PLOGICAL_UNIT_EXTENSION  LogUnitExtension,
    IN OUT PATA_PASS_THROUGH    AtaPassThroughData,
    IN BOOLEAN                  DataIn,
    IN BOOLEAN                  PowerRelated,
    IN ULONG                    TimeOut,
    IN BOOLEAN                    MustSucceed
);

VOID
SyncAtaPassThroughCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PVOID          Context,
    IN NTSTATUS       Status
    );

VOID
IdeUnmapReservedMapping (
    IN PFDO_EXTENSION   DeviceExtension,
    IN PSRB_DATA        SrbData,
    IN PMDL             Mdl
    );

PVOID
IdeMapLockedPagesWithReservedMapping (
    IN PFDO_EXTENSION DeviceExtension,
    IN PSRB_DATA      SrbData,
    IN PMDL           Mdl
    );

BOOLEAN
TestForEnumProbing (
    IN PSCSI_REQUEST_BLOCK Srb
    );

#define DEFAULT_ATA_PASS_THROUGH_TIMEOUT        15

#define INIT_IDE_SRB_FLAGS(Srb)         (Srb->SrbExtension = NULL)
#define SANITY_CHECK_SRB(Srb)           {ASSERT(!(((ULONG_PTR)Srb->SrbExtension) & ~7));}
#define MARK_SRB_AS_PIO_CANDIDATE(Srb)  {SANITY_CHECK_SRB(Srb); ((ULONG_PTR)Srb->SrbExtension) |= 1;}
#define MARK_SRB_AS_DMA_CANDIDATE(Srb)  {SANITY_CHECK_SRB(Srb); ((ULONG_PTR)Srb->SrbExtension) &= ~1;}
#define MARK_SRB_FOR_DMA(Srb)           {SANITY_CHECK_SRB(Srb); ((ULONG_PTR)Srb->SrbExtension) |= 2;}
#define MARK_SRB_FOR_PIO(Srb)           {SANITY_CHECK_SRB(Srb); ((ULONG_PTR)Srb->SrbExtension) &= ~2;}
#define SRB_IS_DMA_CANDIDATE(Srb)       (!(((ULONG_PTR)Srb->SrbExtension) & 1))
#define SRB_USES_DMA(Srb)               (((ULONG_PTR)Srb->SrbExtension) & 2)
#define TEST_AND_SET_SRB_FOR_RDP(ScsiDeviceType, Srb)   \
                                        if ((ScsiDeviceType == SEQUENTIAL_ACCESS_DEVICE) &&\
                                            ((Srb->Cdb[0] == SCSIOP_ERASE)  || (Srb->Cdb[0] == SCSIOP_LOAD_UNLOAD)||\
                                             (Srb->Cdb[0] == SCSIOP_LOCATE) || (Srb->Cdb[0] == SCSIOP_REWIND) ||\
                                             (Srb->Cdb[0] == SCSIOP_SPACE)  || (Srb->Cdb[0] == SCSIOP_SEEK)||\
                                             (Srb->Cdb[0] == SCSIOP_WRITE_FILEMARKS))) {\
                                            SANITY_CHECK_SRB(Srb);\
                                            ((ULONG_PTR)Srb->SrbExtension) |= 4;\
                                        } else if ((ScsiDeviceType == READ_ONLY_DIRECT_ACCESS_DEVICE) && \
                                            (Srb->Cdb[0]==SCSIOP_SEEK) ) {\
                                            SANITY_CHECK_SRB(Srb);\
                                            ((ULONG_PTR)Srb->SrbExtension) |= 4;\
                                        } else {\
                                            SANITY_CHECK_SRB(Srb);\
                                            ((ULONG_PTR)Srb->SrbExtension) &= ~4;\
                                        }
#define SRB_IS_RDP(Srb)                 (((ULONG_PTR)Srb->SrbExtension) & 4)

#define ERRLOGID_TOO_MANY_DMA_TIMEOUT   0x80000001
#define ERRLOGID_LYING_DMA_SYSTEM       0x80000002
#define ERRLOGID_TOO_MANY_CRC_ERROR     0x80000003

#define DEFAULT_SPINUP_TIME             (30)

//#define PUT_IRP_TRACKER(irpStack, num) if ((irpStack)->Parameters.Others.Argument2) {\
 //               (ULONG_PTR)((irpStack)->Parameters.Others.Argument2) |= (1<<num);}
#define PUT_IRP_TRACKER(irpStack, num)

#define FREE_IRP_TRACKER(irpStack)

#endif // ___port_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\port.c ===
/*++

Copyright (C) 1990 - 99  Microsoft Corporation

Module Name:

    port.c

Abstract:

    This is the NT SCSI port driver.

Authors:

    Mike Glass
    Jeff Havens

Environment:

    kernel mode only

Notes:

    This module is a dll for the kernel.

Revision History:

--*/

#include "ideport.h"
//#include "port.h"




VOID
IdePortNotification(
    IN IDE_NOTIFICATION_TYPE NotificationType,
    IN PVOID HwDeviceExtension,
    ...
    )

/*++

Routine Description:

Arguments:

Return Value:

--*/

{
    PFDO_EXTENSION deviceExtension = (PFDO_EXTENSION) HwDeviceExtension - 1;
    PLOGICAL_UNIT_EXTENSION logicalUnit;
    PSRB_DATA               srbData;
    PSCSI_REQUEST_BLOCK     srb;
    UCHAR                   pathId;
    UCHAR                   targetId;
    UCHAR                   lun;
    va_list                 ap;

    va_start(ap, HwDeviceExtension);

    switch (NotificationType) {

        case IdeNextRequest:

            //
            // Start next packet on adapter's queue.
            //

            deviceExtension->InterruptData.InterruptFlags |= PD_READY_FOR_NEXT_REQUEST;
            break;

        case IdeRequestComplete:

            srb = va_arg(ap, PSCSI_REQUEST_BLOCK);

            ASSERT(srb->SrbStatus != SRB_STATUS_PENDING);

            ASSERT(srb->SrbStatus != SRB_STATUS_SUCCESS || srb->ScsiStatus == SCSISTAT_GOOD || srb->Function != SRB_FUNCTION_EXECUTE_SCSI);

            //
            // If this srb has already been completed then return.
            //

            if (!(srb->SrbFlags & SRB_FLAGS_IS_ACTIVE)) {

                va_end(ap);
                return;
            }

            //
            // Clear the active flag.
            //

            CLRMASK (srb->SrbFlags, SRB_FLAGS_IS_ACTIVE);

            //
            // Treat abort completions as a special case.
            //

            if (srb->Function == SRB_FUNCTION_ABORT_COMMAND) {

                PIRP irp;
                PIO_STACK_LOCATION irpStack;

                irp = srb->OriginalRequest;
                irpStack = IoGetCurrentIrpStackLocation(irp);
                logicalUnit = IDEPORT_GET_LUNEXT_IN_IRP(irpStack);

                logicalUnit->CompletedAbort =
                    deviceExtension->InterruptData.CompletedAbort;

                deviceExtension->InterruptData.CompletedAbort = logicalUnit;

            } else {

                PIDE_REGISTERS_1 baseIoAddress1 = &(deviceExtension->
                                                    HwDeviceExtension->BaseIoAddress1);

                //
                // Get the SRB data and link it into the completion list.
                //

                srbData = IdeGetSrbData(deviceExtension, srb);

                ASSERT(srbData);
                ASSERT(srbData->CurrentSrb != NULL && srbData->CompletedRequests == NULL);

                if ((srb->SrbStatus == SRB_STATUS_SUCCESS) &&
                    ((srb->Cdb[0] == SCSIOP_READ) ||
                     (srb->Cdb[0] == SCSIOP_WRITE))) {
                    ASSERT(srb->DataTransferLength);
                }

                ASSERT (deviceExtension->InterruptData.CompletedRequests == NULL);

                srbData->CompletedRequests =
                    deviceExtension->InterruptData.CompletedRequests;
                deviceExtension->InterruptData.CompletedRequests = srbData;

                //
                // Save the task file registers
                //
                IdeLogSaveTaskFile(srbData, baseIoAddress1);
            }

            break;

        case IdeResetDetected:

            {
                PIRP irp;
                PIO_STACK_LOCATION irpStack;

                //
                // Notifiy the port driver that a reset has been reported.
                //
                srb = va_arg(ap, PSCSI_REQUEST_BLOCK);
    
                if (srb) {

                    irp = srb->OriginalRequest;
                    irpStack = IoGetCurrentIrpStackLocation(irp);
                    logicalUnit = IDEPORT_GET_LUNEXT_IN_IRP(irpStack);

                } else {

                    logicalUnit = NULL;
                }
    
                ASSERT(deviceExtension->InterruptData.PdoExtensionResetBus == NULL);

                deviceExtension->InterruptData.InterruptFlags |= PD_RESET_REPORTED;
                deviceExtension->InterruptData.PdoExtensionResetBus = logicalUnit;
                break;
            }

        case IdeRequestTimerCall:

            //
            // The driver wants to set the miniport timer.
            // Save the timer parameters.
            //

            deviceExtension->InterruptData.InterruptFlags |=
                PD_TIMER_CALL_REQUEST;
            deviceExtension->InterruptData.HwTimerRequest =
                va_arg(ap, PHW_INTERRUPT);
            deviceExtension->InterruptData.MiniportTimerValue =
                va_arg(ap, ULONG);
            break;

        case IdeAllDeviceMissing:
            deviceExtension->InterruptData.InterruptFlags |= PD_ALL_DEVICE_MISSING;
            break;

        case IdeResetRequest:
            
            //
            // A reset was requested
            //
            deviceExtension->InterruptData.InterruptFlags |= PD_RESET_REQUEST;
            break;

        default:

             ASSERT(0);
    }

    va_end(ap);

    //
    // Request a DPC be queued after the interrupt completes.
    //

    deviceExtension->InterruptData.InterruptFlags |= PD_NOTIFICATION_REQUIRED;

} // end IdePortNotification()


VOID
IdePortLogError(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb OPTIONAL,
    IN UCHAR PathId,
    IN UCHAR TargetId,
    IN UCHAR Lun,
    IN ULONG ErrorCode,
    IN ULONG UniqueId
    )

/*++

Routine Description:

    This routine saves the error log information, and queues a DPC if necessary.

Arguments:

    HwDeviceExtension - Supplies the HBA miniport driver's adapter data storage.

    Srb - Supplies an optional pointer to srb if there is one.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    ErrorCode - Supplies an error code indicating the type of error.

    UniqueId - Supplies a unique identifier for the error.

Return Value:

    None.

--*/

{
    PFDO_EXTENSION deviceExtension =
        ((PFDO_EXTENSION) HwDeviceExtension) - 1;
    PDEVICE_OBJECT DeviceObject = deviceExtension->DeviceObject;
    PSRB_DATA srbData;
    PERROR_LOG_ENTRY errorLogEntry;

    //
    // If the error log entry is already full, then dump the error.
    //

    if (deviceExtension->InterruptData.InterruptFlags & PD_LOG_ERROR) {

#if DBG
        DebugPrint((1,"IdePortLogError: Dumping scsi error log packet.\n"));
        DebugPrint((1,
            "PathId = %2x, TargetId = %2x, Lun = %2x, ErrorCode = %x, UniqueId = %x.",
            PathId,
            TargetId,
            Lun,
            ErrorCode,
            UniqueId
            ));
#endif
        return;
    }

    //
    // Save the error log data in the log entry.
    //

    errorLogEntry = &deviceExtension->InterruptData.LogEntry;

    errorLogEntry->ErrorCode = ErrorCode;
    errorLogEntry->TargetId = TargetId;
    errorLogEntry->Lun = Lun;
    errorLogEntry->PathId = PathId;
    errorLogEntry->UniqueId = UniqueId;

    //
    // Get the sequence number from the SRB data.
    //

    if (Srb != NULL) {

        srbData = IdeGetSrbData(deviceExtension, Srb);

        if (srbData == NULL) {
            return;
        }

        errorLogEntry->SequenceNumber = srbData->SequenceNumber;
        errorLogEntry->ErrorLogRetryCount = srbData->ErrorLogRetryCount++;
    } else {
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->ErrorLogRetryCount = 0;
    }

    //
    // Indicate that the error log entry is in use.
    //

    deviceExtension->InterruptData.InterruptFlags |= PD_LOG_ERROR;

    //
    // Request a DPC be queued after the interrupt completes.
    //

    deviceExtension->InterruptData.InterruptFlags |= PD_NOTIFICATION_REQUIRED;

    return;

} // end IdePortLogError()


VOID
IdePortCompleteRequest(
    IN PVOID HwDeviceExtension,
    IN PSCSI_REQUEST_BLOCK Srb,
    IN UCHAR SrbStatus
    )

/*++

Routine Description:

    Complete all active requests for the specified logical unit.

Arguments:

    DeviceExtenson - Supplies the HBA miniport driver's adapter data storage.

    TargetId, Lun and PathId - specify device address on a SCSI bus.

    SrbStatus - Status to be returned in each completed SRB.

Return Value:

    None.

--*/

{
    PFDO_EXTENSION fdoExtension = ((PFDO_EXTENSION) HwDeviceExtension) - 1;
    PLOGICAL_UNIT_EXTENSION logUnitExtension;
    PIO_STACK_LOCATION irpStack;
    PIRP Irp;
    PSRB_DATA srbData;
    PLIST_ENTRY entry;
    ULONG limit = 0;

    Irp = (PIRP) Srb->OriginalRequest;
    irpStack = IoGetCurrentIrpStackLocation(Irp);
    logUnitExtension = IDEPORT_GET_LUNEXT_IN_IRP(irpStack);

    DebugPrint((2,
        "IdePortCompleteRequest: Complete requests for targetid %d\n",
        logUnitExtension->TargetId));

    //
    // Complete any pending abort reqeusts.
    //

    if (logUnitExtension->AbortSrb != NULL) {
        logUnitExtension->AbortSrb->SrbStatus = SrbStatus;

        IdePortNotification(
            IdeRequestComplete,
            HwDeviceExtension,
            logUnitExtension->AbortSrb
            );
    }

    IdeCompleteRequest(fdoExtension, &logUnitExtension->SrbData, SrbStatus);

    return;

} // end IdePortCompleteRequest()

BOOLEAN
TestForEnumProbing (
    IN PSCSI_REQUEST_BLOCK Srb
    )
{
    BOOLEAN enumProbing = FALSE;

    if (Srb) {

        if ((Srb->Function == SRB_FUNCTION_ATA_POWER_PASS_THROUGH) ||
            (Srb->Function == SRB_FUNCTION_ATA_PASS_THROUGH)) {

            PATA_PASS_THROUGH    ataPassThroughData;

            ataPassThroughData = Srb->DataBuffer;

            enumProbing = ataPassThroughData->IdeReg.bReserved & ATA_PTFLAGS_ENUM_PROBING ? TRUE: FALSE;
        }
    }

    return enumProbing;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\regutils.c ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    regutil.c

Abstract:

    This contain registry access routines

Author:

    Joe Dai (joedai)

Environment:

    kernel mode only

Notes:

Revision History:

--*/

#include "ideport.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IdePortGetParameterFromServiceSubKey)
#pragma alloc_text(PAGE, IdePortRegQueryRoutine)
#pragma alloc_text(PAGE, IdePortGetDeviceParameter)
#pragma alloc_text(PAGE, IdePortSaveDeviceParameter)
#pragma alloc_text(PAGE, IdePortOpenServiceSubKey)
#pragma alloc_text(PAGE, IdePortCloseServiceSubKey)

#endif // ALLOC_PRAGMA

NTSTATUS
IdePortGetParameterFromServiceSubKey (
    IN     PDRIVER_OBJECT  DriverObject,
    IN     PWSTR           ParameterName,
    IN     ULONG           ParameterType,
    IN     BOOLEAN         Read,
    OUT    PVOID           *ParameterValue,
    IN     ULONG           ParameterValueWriteSize
)
{
    NTSTATUS                 status;
    HANDLE                   deviceParameterHandle;
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    ULONG                    defaultParameterValue;   

    CCHAR                   deviceBuffer[50];
    ANSI_STRING             ansiString;
    UNICODE_STRING          subKeyPath;
    HANDLE                  subServiceKey;

    UNICODE_STRING          unicodeParameterName;

    PAGED_CODE();

    *ParameterValue = NULL;

    //
    // the driver parameter subkey is less than 50 characters
    //
    sprintf (deviceBuffer, DRIVER_PARAMETER_SUBKEY);
    RtlInitAnsiString(&ansiString, deviceBuffer);
    status = RtlAnsiStringToUnicodeString(&subKeyPath, &ansiString, TRUE);

    if (NT_SUCCESS(status)) {

        subServiceKey = IdePortOpenServiceSubKey (
                            DriverObject,
                            &subKeyPath
                            );

        RtlFreeUnicodeString (&subKeyPath);

        if (subServiceKey) {
        
            if (Read) {

                RtlZeroMemory(queryTable, sizeof(queryTable));
            
                queryTable->QueryRoutine  = IdePortRegQueryRoutine;
                queryTable->Flags         = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
                queryTable->Name          = ParameterName;
                queryTable->EntryContext  = ParameterValue;
                queryTable->DefaultType   = 0;
                queryTable->DefaultData   = NULL;
                queryTable->DefaultLength = 0;
            
                status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                                (PWSTR) subServiceKey,
                                                queryTable,
                                                ULongToPtr( ParameterType ),
                                                NULL);

            } else {

                RtlInitUnicodeString (&unicodeParameterName, ParameterName);


                status = ZwSetValueKey(
                             subServiceKey,
                             &unicodeParameterName,
                             0,
                             ParameterType,
                             ParameterValue,
                             ParameterValueWriteSize
                             );
            }


            //
            // close what we open
            //
            IdePortCloseServiceSubKey (
                subServiceKey
                );
        }
    }

    return status;
}
              
NTSTATUS
IdePortRegQueryRoutine (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
)
{
    PVOID *parameterValue = EntryContext;
    ULONG parameterType = PtrToUlong(Context);

    PAGED_CODE();

    if (ValueType == parameterType) {

        if (ValueType == REG_MULTI_SZ) {
    
            *parameterValue = ExAllocatePool(PagedPool, ValueLength);
    
            if (*parameterValue) {
    
                RtlMoveMemory(*parameterValue, ValueData, ValueLength);
                return STATUS_SUCCESS;
            }

        } else if (ValueType == REG_DWORD) {
    
            PULONG ulongValue;

            ulongValue = (PULONG) parameterValue;
            *ulongValue = *((PULONG) ValueData);
            return STATUS_SUCCESS;
        }
    }

    return STATUS_UNSUCCESSFUL;
}


              
              
NTSTATUS
IdePortGetDeviceParameter (
    IN     PFDO_EXTENSION  FdoExtension,
    IN     PWSTR           ParameterName,
    IN OUT PULONG          ParameterValue
    )
/*++

Routine Description:

    retrieve a devnode registry parameter

Arguments:

    FdoExtension - FDO Extension
    
    ParameterName - parameter name to look up                                        
                                           
    ParameterValuse - default parameter value

Return Value:

    NT Status

--*/
{
    NTSTATUS                 status;
    HANDLE                   deviceParameterHandle;
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    ULONG                    defaultParameterValue;   

    PAGED_CODE();

    //
    // open the given parameter
    //
    status = IoOpenDeviceRegistryKey(FdoExtension->AttacheePdo,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     KEY_READ,
                                     &deviceParameterHandle);

    if(!NT_SUCCESS(status)) {

        return status;
    }

    RtlZeroMemory(queryTable, sizeof(queryTable));

    defaultParameterValue = *ParameterValue;

    queryTable->Flags         = RTL_QUERY_REGISTRY_DIRECT | RTL_QUERY_REGISTRY_REQUIRED;
    queryTable->Name          = ParameterName;
    queryTable->EntryContext  = ParameterValue;
    queryTable->DefaultType   = REG_DWORD;
    queryTable->DefaultData   = &defaultParameterValue;
    queryTable->DefaultLength = sizeof(ULONG);

    status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                    (PWSTR) deviceParameterHandle,
                                    queryTable,
                                    NULL,
                                    NULL);
    if (!NT_SUCCESS(status)) {

        *ParameterValue = defaultParameterValue;
    }

    //
    // close what we open
    //
    ZwClose(deviceParameterHandle);

    return status;
} // IdePortGetDeviceParameter

NTSTATUS
IdePortSaveDeviceParameter (
    IN PFDO_EXTENSION FdoExtension,
    IN PWSTR          ParameterName,
    IN ULONG          ParameterValue
    )
/*++

Routine Description:

    save a devnode registry parameter

Arguments:

    FdoExtension - FDO Extension
    
    ParameterName - parameter name to save                                        
                                           
    ParameterValuse - parameter value to save

Return Value:

    NT Status

--*/
{
    NTSTATUS                 status;
    HANDLE                   deviceParameterHandle;

    PAGED_CODE();

    //
    // open the given parameter
    //
    status = IoOpenDeviceRegistryKey(FdoExtension->AttacheePdo,
                                     PLUGPLAY_REGKEY_DRIVER,
                                     KEY_WRITE,
                                     &deviceParameterHandle);

    if(!NT_SUCCESS(status)) {

        DebugPrint((DBG_WARNING,
                    "IdePortSaveDeviceParameter: IoOpenDeviceRegistryKey() returns 0x%x\n",
                    status));

        return status;
    }

    //
    // write the parameter value
    //
    status = RtlWriteRegistryValue(
                 RTL_REGISTRY_HANDLE,
                 (PWSTR) deviceParameterHandle,
                 ParameterName,
                 REG_DWORD,
                 &ParameterValue,
                 sizeof (ParameterValue)
                 );


    if(!NT_SUCCESS(status)) {

        DebugPrint((DBG_WARNING,
                    "IdePortSaveDeviceParameter: RtlWriteRegistryValue() returns 0x%x\n",
                    status));
    }

    //
    // close what we open
    //
    ZwClose(deviceParameterHandle);
    return status;
} // IdePortSaveDeviceParameter


HANDLE
IdePortOpenServiceSubKey (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  SubKeyPath
)
{
    PIDEDRIVER_EXTENSION ideDriverExtension;
    OBJECT_ATTRIBUTES objectAttributes;
    HANDLE serviceKey;
    HANDLE subServiceKey;
    NTSTATUS status;

    ideDriverExtension = IoGetDriverObjectExtension(
                             DriverObject,
                             DRIVER_OBJECT_EXTENSION_ID
                             );

    if (!ideDriverExtension) {

        return NULL;
    }

    InitializeObjectAttributes(&objectAttributes,
                               &ideDriverExtension->RegistryPath,
                               OBJ_CASE_INSENSITIVE,
                               NULL,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey(&serviceKey,
                       KEY_ALL_ACCESS,
                       &objectAttributes);

    if (!NT_SUCCESS(status)) {

        return NULL;
    }

    InitializeObjectAttributes(&objectAttributes,
                               SubKeyPath,
                               OBJ_CASE_INSENSITIVE,
                               serviceKey,
                               (PSECURITY_DESCRIPTOR) NULL);

    status = ZwOpenKey(&subServiceKey,
                       KEY_READ,
                       &objectAttributes);


    ZwClose(serviceKey);

    if (NT_SUCCESS(status)) {

        return subServiceKey;
    } else {

        return NULL;
    }
}

VOID 
IdePortCloseServiceSubKey (
    IN HANDLE  SubServiceKey
)
{
    ZwClose(SubServiceKey);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\regutils.h ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    regutil.h

Abstract:

--*/

#if !defined (___regutils_h___)
#define ___regutils_h___

// 
// Device Parameter Registry Flag Names
//        
#define MASTER_DEVICE_TYPE      L"MasterDeviceType"
#define SLAVE_DEVICE_TYPE       L"SlaveDeviceType"
#define MASTER_DEVICE_TYPE2     L"MasterDeviceType2"
#define SLAVE_DEVICE_TYPE2      L"SlaveDeviceType2"

#define DRIVER_PARAMETER_SUBKEY "Parameters"
                          
#define NEED_IDENT_DEVICE       L"NeedIdentDevice"
#define PIO_ONLY_DEVICE         L"PioOnlyDevice"
#define DEFAULT_PIO_DEVICE      L"DefaultPioAtapiDevice"
#define AUTO_EJECT_ZIP_DEVICE   L"AutoEjectZipDevice"
#define GHOST_SLAVE_DEVICE      L"GhostSlave"

#define CHECK_POWER_FLUSH_DEVICE L"UseCheckPowerForFlush"

#define NO_FLUSH_DEVICE         L"NoFlushDevice"
                  
#define NO_POWER_DOWN_DEVICE    L"NoPowerDownDevice"
                         
#define NONREMOVABLE_MEDIA_OVERRIDE L"NonRemovableMedia"

#define LEGACY_DETECTION        L"LegacyDetection"
                       
NTSTATUS
IdePortGetParameterFromServiceSubKey (
    IN     PDRIVER_OBJECT  DriverObject,
    IN     PWSTR           ParameterName,
    IN     ULONG           ParameterType,
    IN     BOOLEAN         Read,
    OUT    PVOID           *ParameterValue,
    IN     ULONG           ParameterValueWriteSize
);
  
NTSTATUS
IdePortRegQueryRoutine (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
);

NTSTATUS
IdePortGetDeviceParameter (
    IN     PFDO_EXTENSION  FdoExtension,
    IN     PWSTR           ParameterName,
    IN OUT PULONG          ParameterValue
    );

NTSTATUS
IdePortSaveDeviceParameter (
    IN PFDO_EXTENSION FdoExtension,
    IN PWSTR          ParameterName,
    IN ULONG          ParameterValue
    );

HANDLE
IdePortOpenServiceSubKey (
    IN PDRIVER_OBJECT   DriverObject,
    IN PUNICODE_STRING  SubKeyPath
);

VOID 
IdePortCloseServiceSubKey (
    IN HANDLE  SubServiceKey
);
                          
#endif // ___regutils_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\wmi.c ===
/*++

Copyright (C) 1998-99  Microsoft Corporation

Module Name:

    wmi.c

Abstract:

--*/

#if defined (IDEPORT_WMI_SUPPORT)

#include <initguid.h>
#include "ideport.h"
#include <wmistr.h>

//
// Instantiate the GUIDs define in ntddscsi.h in this module.
//
#include <devguid.h>

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, IdePortWmiRegister)
#pragma alloc_text(PAGE, IdePortWmiDeregister)
#pragma alloc_text(PAGE, IdePortWmiSystemControl)
#pragma alloc_text(PAGE, DeviceQueryWmiDataBlock)
#pragma alloc_text(PAGE, DeviceSetWmiDataBlock)
#pragma alloc_text(PAGE, DeviceSetWmiDataItem)
#pragma alloc_text(PAGE, DeviceQueryWmiRegInfo)
#endif
                 
typedef enum {
    WmiScsiAddress = 0
} WMI_DATA_BLOCK_TYPE;

#define NUMBER_OF_WMI_GUID 1
WMIGUIDREGINFO IdePortWmiGuidList[NUMBER_OF_WMI_GUID];

VOID
IdePortWmiInit (VOID)
{
    PAGED_CODE();

    IdePortWmiGuidList[WmiScsiAddress].Guid  = &WmiScsiAddressGuid;
    IdePortWmiGuidList[WmiScsiAddress].InstanceCount = 1;
    IdePortWmiGuidList[WmiScsiAddress].Flags = 0;

    return;
}

NTSTATUS
IdePortWmiRegister(
    PDEVICE_EXTENSION_HEADER DoCommonExtension
    )
{
    NTSTATUS status;

    PAGED_CODE();

    ASSERT(DoCommonExtension->AttacheePdo == NULL);

    DoCommonExtension->WmiLibInfo.GuidCount = NUMBER_OF_WMI_GUID;
    DoCommonExtension->WmiLibInfo.GuidList  = IdePortWmiGuidList;

    DoCommonExtension->WmiLibInfo.QueryWmiDataBlock  = DeviceQueryWmiDataBlock;
    DoCommonExtension->WmiLibInfo.QueryWmiRegInfo    = DeviceQueryWmiRegInfo;
    DoCommonExtension->WmiLibInfo.SetWmiDataBlock    = DeviceSetWmiDataBlock;
    DoCommonExtension->WmiLibInfo.SetWmiDataItem     = DeviceSetWmiDataItem;
    DoCommonExtension->WmiLibInfo.ExecuteWmiMethod   = NULL;
    DoCommonExtension->WmiLibInfo.WmiFunctionControl = NULL;

    status = IoWMIRegistrationControl(
                DoCommonExtension->DeviceObject,
                WMIREG_ACTION_REGISTER
                );

    if (!NT_SUCCESS(status)) {

        DebugPrint((
            DBG_ALWAYS, 
            "IdePortWmiRegister: IoWMIRegistrationControl(%x, WMI_ACTION_REGISTER) failed\n",
            DoCommonExtension->DeviceObject
            ));
    }

    return status;
}

NTSTATUS
IdePortWmiDeregister(
    PDEVICE_EXTENSION_HEADER DoCommonExtension
    )
{
    NTSTATUS status;

    PAGED_CODE();

    status = IoWMIRegistrationControl(
                 DoCommonExtension->DeviceObject,
                 WMIREG_ACTION_DEREGISTER
                 );

    if (!NT_SUCCESS(status)) {

        DebugPrint((
            DBG_ALWAYS, 
            "IdePortWmiDeregister: IoWMIRegistrationControl(%x, WMIREG_ACTION_DEREGISTER) failed\n",
            DoCommonExtension->DeviceObject
            ));
    }

    return status;
}


NTSTATUS
IdePortWmiSystemControl(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    )
/*++
Routine Description

    We have just received a System Control IRP.

    Assume that this is a WMI IRP and call into the WMI system library and let
    it handle this IRP for us.

--*/
{
    PPDO_EXTENSION pdoExtension;
    SYSCTL_IRP_DISPOSITION disposition;
    NTSTATUS status;

    PAGED_CODE();

    pdoExtension = RefPdoWithTag (DeviceObject, FALSE, (PVOID) ~(ULONG_PTR)Irp);

    if (pdoExtension) {

        status = WmiSystemControl(   &pdoExtension->WmiLibInfo,
                                     DeviceObject, 
                                     Irp,
                                     &disposition);
        switch(disposition)
        {
            case IrpProcessed:
            {
                //
                // This irp has been processed and may be completed 
                // or pending.
                break;
            }
            
            case IrpNotCompleted:
            {
                //
                // This irp has not been completed, but has been fully 
                // processed. We will complete it now
                IoCompleteRequest(Irp, IO_NO_INCREMENT);                
                break;
            }
            
            case IrpForward:
            case IrpNotWmi: 
            {
                //Fail the irp
                Irp->IoStatus.Status = status = STATUS_NOT_SUPPORTED;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);                
                break;
            }        
            default:
            {
                //
                // We really should never get here, but if we do just fail the irp
                ASSERT(FALSE);
                Irp->IoStatus.Status = status = STATUS_NOT_SUPPORTED;
                IoCompleteRequest(Irp, IO_NO_INCREMENT);                
                break;
            }        
        }
        
        UnrefPdoWithTag (
            pdoExtension,
            (PVOID) ~(ULONG_PTR)Irp
            );

    } else {

        ASSERT(!"got WMI irp after the device is removed!\n");

        Irp->IoStatus.Status = status = STATUS_UNSUCCESSFUL;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return status;
}

NTSTATUS
DeviceQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to query for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being queried.
            
    InstanceCount is the number of instnaces expected to be returned for
        the data block.
            
    InstanceLengthArray is a pointer to an array of ULONG that returns the 
        lengths of each instance of the data block. If this is NULL then
        there was not enough space in the output buffer to fufill the request
        so the irp should be completed with the buffer needed.        
                        
    BufferAvail on has the maximum size available to write the data
        block.

    Buffer on return is filled with the returned data block


Return Value:

    status

--*/
{
    PPDO_EXTENSION pdoExtension;
    NTSTATUS status;
    ULONG numBytesReturned = sizeof(WMI_SCSI_ADDRESS);

    PAGED_CODE();

    ASSERT((InstanceIndex == 0) && (InstanceCount == 1));

    pdoExtension = RefPdoWithTag (DeviceObject, FALSE, Irp);

    if (!pdoExtension) {

        ASSERT(!"got WMI irp after the device is removed!\n");

        Irp->IoStatus.Status = status = STATUS_UNSUCCESSFUL;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }

    switch (GuidIndex) {
    case WmiScsiAddress: {

        PWMI_SCSI_ADDRESS scsiAddress;

        if (OutBufferSize < sizeof(WMI_SCSI_ADDRESS)) {
            status = STATUS_BUFFER_TOO_SMALL;

        } else {

            scsiAddress = (PWMI_SCSI_ADDRESS) Buffer;
    
            scsiAddress->Bus = pdoExtension->PathId;
            scsiAddress->Target = pdoExtension->TargetId;
            scsiAddress->Lun = pdoExtension->Lun;

            *InstanceLengthArray = sizeof(WMI_SCSI_ADDRESS);
            status = STATUS_SUCCESS;
        }
        break;
    }

    default:
        status = STATUS_WMI_GUID_NOT_FOUND;
        break;
    }

    status = WmiCompleteRequest(  DeviceObject,
                                  Irp,
                                  status,
                                  numBytesReturned,
                                  IO_NO_INCREMENT
                                  );

    UnrefPdoWithTag (
        pdoExtension,
        Irp
        );

    return status;
}

NTSTATUS
DeviceQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    )
/*++

Routine Description:

    This routine is a callback into the driver to retrieve the list of
    guids or data blocks that the driver wants to register with WMI. This
    routine may not pend or block. Driver should NOT call
    ClassWmiCompleteRequest.

Arguments:

    DeviceObject is the device whose data block is being queried

    *RegFlags returns with a set of flags that describe the guids being
        registered for this device. If the device wants enable and disable
        collection callbacks before receiving queries for the registered
        guids then it should return the WMIREG_FLAG_EXPENSIVE flag. Also the
        returned flags may specify WMIREG_FLAG_INSTANCE_PDO in which case
        the instance name is determined from the PDO associated with the
        device object. Note that the PDO must have an associated devnode. If
        WMIREG_FLAG_INSTANCE_PDO is not set then Name must return a unique
        name for the device.

    InstanceName returns with the instance name for the guids if
        WMIREG_FLAG_INSTANCE_PDO is not set in the returned *RegFlags. The
        caller will call ExFreePool with the buffer returned.

    *RegistryPath returns with the registry path of the driver

    *MofResourceName returns with the name of the MOF resource attached to
        the binary file. If the driver does not have a mof resource attached
        then this can be returned as NULL.
                
    *Pdo returns with the device object for the PDO associated with this
        device if the WMIREG_FLAG_INSTANCE_PDO flag is retured in 
        *RegFlags.

Return Value:

    status

--*/
{
    PIDEDRIVER_EXTENSION ideDriverExtension;
    PPDO_EXTENSION pdoExtension;
    NTSTATUS status;

    PAGED_CODE();

    pdoExtension = RefPdoWithTag (DeviceObject, FALSE, DeviceQueryWmiRegInfo);

    if (!pdoExtension) {

        ASSERT(!"got WMI callback after the device is removed!\n");
        status = STATUS_UNSUCCESSFUL;

    } else {

        ideDriverExtension = IoGetDriverObjectExtension(
                                 pdoExtension->DriverObject,
                                 DRIVER_OBJECT_EXTENSION_ID
                                 );
    
        if (!ideDriverExtension) {
    
            status = STATUS_UNSUCCESSFUL;
    
        } else {
    
            *RegFlags = WMIREG_FLAG_INSTANCE_PDO;
            *RegistryPath = &ideDriverExtension->RegistryPath;
            *Pdo = pdoExtension->DeviceObject;
            status = STATUS_SUCCESS;
        }
    
        UnrefPdoWithTag (
            pdoExtension,
            DeviceQueryWmiRegInfo
            );
    }

    return status;
}

NTSTATUS
DeviceSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being set.
                        
    BufferSize has the size of the data block passed

    Buffer has the new values for the data block


Return Value:

    status

--*/
{
    PPDO_EXTENSION pdoExtension;
    NTSTATUS status;

    PAGED_CODE();

    pdoExtension = RefPdoWithTag (DeviceObject, FALSE, Irp);

    if (!pdoExtension) {

        ASSERT(!"got WMI callback after the device is removed!\n");
        status = STATUS_UNSUCCESSFUL;

    } else {

        switch (GuidIndex) {
        case WmiScsiAddress: {
                        status = STATUS_WMI_READ_ONLY;
                        break;
                }
    
        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
        }
    
        status = WmiCompleteRequest(  DeviceObject,
                                      Irp,
                                      status,
                                      0,
                                      IO_NO_INCREMENT
                                      );

        UnrefPdoWithTag (
            pdoExtension,
            Irp
            );
    }
    
    return status;
}

NTSTATUS
DeviceSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    )
/*++

Routine Description:

    This routine is a callback into the driver to set for the contents of
    a data block. When the driver has finished filling the data block it
    must call ClassWmiCompleteRequest to complete the irp. The driver can
    return STATUS_PENDING if the irp cannot be completed immediately.

Arguments:

    DeviceObject is the device whose data block is being queried

    Irp is the Irp that makes this request

    GuidIndex is the index into the list of guids provided when the
        device registered

    InstanceIndex is the index that denotes which instance of the data block
        is being set.
                        
    DataItemId has the id of the data item being set

    BufferSize has the size of the data item passed

    Buffer has the new values for the data item


Return Value:

    status

--*/
{
    PPDO_EXTENSION pdoExtension;
    NTSTATUS status;

    PAGED_CODE();

    pdoExtension = RefPdoWithTag (DeviceObject, FALSE, Irp);

    if (!pdoExtension) {

        ASSERT(!"got WMI callback after the device is removed!\n");
        status = STATUS_UNSUCCESSFUL;

    } else {

        switch(GuidIndex) {
    
        case WmiScsiAddress: {
                        status = STATUS_WMI_READ_ONLY;
                        break;
                }
    
        default:
            status = STATUS_WMI_GUID_NOT_FOUND;
            break;
        }
    
        status = WmiCompleteRequest(  DeviceObject,
                                      Irp,
                                      status,
                                      0,
                                      IO_NO_INCREMENT
                                      );

        UnrefPdoWithTag (
            pdoExtension,
            Irp
            );
    }
    return status;
}

#endif // IDEPORT_WMI_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\inc\ide.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    ide.h

Abstract:

    These are the structures and defines that are used in the
    PCI IDE mini drivers.

Revision History:

--*/


#if !defined (___ide_h___)
#define ___ide_h___

#include "ideuser.h"

#define MAX_IDE_DEVICE      2
#define MAX_IDE_LINE        2
#define MAX_IDE_CHANNEL     2

//
// Some miniports need this structure.
// IdentifyData is passed to the miniport in
// the XfermodeSelect structure
// 

//
// IDENTIFY data
//

#pragma pack (1)
typedef struct _IDENTIFY_DATA {
    USHORT GeneralConfiguration;            // 00 00
    USHORT NumCylinders;                    // 02  1
    USHORT Reserved1;                       // 04  2
    USHORT NumHeads;                        // 06  3
    USHORT UnformattedBytesPerTrack;        // 08  4
    USHORT UnformattedBytesPerSector;       // 0A  5
    USHORT NumSectorsPerTrack;              // 0C  6
    USHORT VendorUnique1[3];                // 0E  7-9
    UCHAR  SerialNumber[20];                // 14  10-19
    USHORT BufferType;                      // 28  20
    USHORT BufferSectorSize;                // 2A  21
    USHORT NumberOfEccBytes;                // 2C  22
    UCHAR  FirmwareRevision[8];             // 2E  23-26
    UCHAR  ModelNumber[40];                 // 36  27-46
    UCHAR  MaximumBlockTransfer;            // 5E  47
    UCHAR  VendorUnique2;                   // 5F
    USHORT DoubleWordIo;                    // 60  48
    USHORT Capabilities;                    // 62  49
    USHORT Reserved2;                       // 64  50
    UCHAR  VendorUnique3;                   // 66  51
    UCHAR  PioCycleTimingMode;              // 67
    UCHAR  VendorUnique4;                   // 68  52
    UCHAR  DmaCycleTimingMode;              // 69
    USHORT TranslationFieldsValid:3;        // 6A  53
    USHORT Reserved3:13;
    USHORT NumberOfCurrentCylinders;        // 6C  54
    USHORT NumberOfCurrentHeads;            // 6E  55
    USHORT CurrentSectorsPerTrack;          // 70  56
    ULONG  CurrentSectorCapacity;           // 72  57-58
    USHORT CurrentMultiSectorSetting;       //     59
    ULONG  UserAddressableSectors;          //     60-61
    USHORT SingleWordDMASupport : 8;        //     62
    USHORT SingleWordDMAActive : 8;
    USHORT MultiWordDMASupport : 8;         //     63
    USHORT MultiWordDMAActive : 8;
    USHORT AdvancedPIOModes : 8;            //     64
    USHORT Reserved4 : 8;
    USHORT MinimumMWXferCycleTime;          //     65
    USHORT RecommendedMWXferCycleTime;      //     66
    USHORT MinimumPIOCycleTime;             //     67
    USHORT MinimumPIOCycleTimeIORDY;        //     68
    USHORT Reserved5[11];                   //     69-79
    USHORT MajorRevision;                   //     80
    USHORT MinorRevision;                   //     81
    USHORT Reserved6;                       //     82
    USHORT CommandSetSupport;               //     83
    USHORT Reserved6a[2];                   //     84-85
    USHORT CommandSetActive;                //     86
    USHORT Reserved6b;                      //     87
    USHORT UltraDMASupport : 8;             //     88
    USHORT UltraDMAActive  : 8;             //
    USHORT Reserved7[11];                   //     89-99
    ULONG  Max48BitLBA[2];                  //     100-103
    USHORT Reserved7a[22];                  //     104-125
    USHORT LastLun:3;                       //     126
    USHORT Reserved8:13;
    USHORT MediaStatusNotification:2;       //     127
    USHORT Reserved9:6;
    USHORT DeviceWriteProtect:1;
    USHORT Reserved10:7;
    USHORT Reserved11[128];                  //     128-255
} IDENTIFY_DATA, *PIDENTIFY_DATA;

//
// Identify data without the Reserved4.
//

//typedef struct _IDENTIFY_DATA2 {
//    USHORT GeneralConfiguration;            // 00 00
//    USHORT NumCylinders;                    // 02  1
//    USHORT Reserved1;                       // 04  2
//    USHORT NumHeads;                        // 06  3
//    USHORT UnformattedBytesPerTrack;        // 08  4
//    USHORT UnformattedBytesPerSector;       // 0A  5
//    USHORT NumSectorsPerTrack;              // 0C  6
//    USHORT VendorUnique1[3];                // 0E  7-9
//    UCHAR  SerialNumber[20];                // 14  10-19
//    USHORT BufferType;                      // 28  20
//    USHORT BufferSectorSize;                // 2A  21
//    USHORT NumberOfEccBytes;                // 2C  22
//    UCHAR  FirmwareRevision[8];             // 2E  23-26
//    UCHAR  ModelNumber[40];                 // 36  27-46
//    UCHAR  MaximumBlockTransfer;            // 5E  47
//    UCHAR  VendorUnique2;                   // 5F
//    USHORT DoubleWordIo;                    // 60  48
//    USHORT Capabilities;                    // 62  49
//    USHORT Reserved2;                       // 64  50
//    UCHAR  VendorUnique3;                   // 66  51
//    UCHAR  PioCycleTimingMode;              // 67
//    UCHAR  VendorUnique4;                   // 68  52
//    UCHAR  DmaCycleTimingMode;              // 69
//    USHORT TranslationFieldsValid:3;        // 6A  53
//    USHORT Reserved3:13;
//    USHORT NumberOfCurrentCylinders;        // 6C  54
//    USHORT NumberOfCurrentHeads;            // 6E  55
//    USHORT CurrentSectorsPerTrack;          // 70  56
//    ULONG  CurrentSectorCapacity;           // 72  57-58
//    USHORT CurrentMultiSectorSetting;       //     59
//    ULONG  UserAddressableSectors;          //     60-61
//    USHORT SingleWordDMASupport : 8;        //     62
//    USHORT SingleWordDMAActive : 8;
//    USHORT MultiWordDMASupport : 8;         //     63
//    USHORT MultiWordDMAActive : 8;
//    USHORT AdvancedPIOModes : 8;            //     64
//    USHORT Reserved4 : 8;
//    USHORT MinimumMWXferCycleTime;          //     65
//    USHORT RecommendedMWXferCycleTime;      //     66
//    USHORT MinimumPIOCycleTime;             //     67
//    USHORT MinimumPIOCycleTimeIORDY;        //     68
//    USHORT Reserved5[11];                   //     69-79
//    USHORT MajorRevision;                   //     80
//    USHORT MinorRevision;                   //     81
//    USHORT Reserved6[6];                    //     82-87
//    USHORT UltraDMASupport : 8;             //     88
//    USHORT UltraDMAActive  : 8;             //
//    USHORT Reserved7[37];                   //     89-125
//    USHORT LastLun:3;                       //     126
//    USHORT Reserved8:13;
//    USHORT MediaStatusNotification:2;       //     127
//    USHORT Reserved9:6;
//    USHORT DeviceWriteProtect:1;
//    USHORT Reserved10:7;
//} IDENTIFY_DATA2, *PIDENTIFY_DATA2;
#pragma pack ()

#define IDENTIFY_DATA_SIZE sizeof(IDENTIFY_DATA)


//
// The structure is passed to pci ide mini driver
// TransferModeSelect callback for selecting
// proper transfer mode the the devices connected
// to the given IDE channel
//
typedef struct _PCIIDE_TRANSFER_MODE_SELECT {

    //
    // Input Parameters
    //          
          
    //
    // IDE Channel Number.  0 or 1
    //                                       
    ULONG   Channel;

    //
    // Indicate whether devices are present
    //                                  
    BOOLEAN DevicePresent[MAX_IDE_DEVICE * MAX_IDE_LINE];
    
    //
    // Indicate whether devices are ATA harddisk
    //
    BOOLEAN FixedDisk[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Indicate whether devices support IO Ready Line
    //                                                
    BOOLEAN IoReadySupported[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Indicate the data transfer modes devices support
    //               
    ULONG DeviceTransferModeSupported[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Indicate devices' best timings for PIO, single word DMA,
    // multiword DMA, and Ultra DMA modes
    //
    ULONG BestPioCycleTime[MAX_IDE_DEVICE * MAX_IDE_LINE];
    ULONG BestSwDmaCycleTime[MAX_IDE_DEVICE * MAX_IDE_LINE];
    ULONG BestMwDmaCycleTime[MAX_IDE_DEVICE * MAX_IDE_LINE];
    ULONG BestUDmaCycleTime[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Indicate devices' current data transfer modes
    //
    ULONG DeviceTransferModeCurrent[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // The user's choice. This will allow pciidex to
    // default to a transfer mode indicated by the mini driver
    //
    ULONG UserChoiceTransferMode[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // This enables UDMA66 on the intel chipsets
    //
    ULONG EnableUDMA66;

    //
    //Some miniports need this
    // The miniport will save this data in their deviceExtension
    //
    IDENTIFY_DATA IdentifyData[MAX_IDE_DEVICE];


    //
    // Output Parameters
    //          
                      
    //
    // Indicate devices' data transfer modes chosen by
    // the pcii ide mini drive
    //
    ULONG DeviceTransferModeSelected[MAX_IDE_DEVICE * MAX_IDE_LINE];

    //
    // Transfermode timings
    //
    PULONG TransferModeTimingTable;
    ULONG   TransferModeTableLength;

} PCIIDE_TRANSFER_MODE_SELECT, *PPCIIDE_TRANSFER_MODE_SELECT;

//
// possible ide channel state
//         
        
typedef enum {
    ChannelDisabled = 0,
    ChannelEnabled,
    ChannelStateUnknown
} IDE_CHANNEL_STATE;
                         
   
//
// Prototype for different PCI IDE mini driver
// callbacks
//   
typedef IDE_CHANNEL_STATE
    (*PCIIDE_CHANNEL_ENABLED) (
        IN PVOID DeviceExtension,
        IN ULONG Channel
        );

typedef BOOLEAN 
    (*PCIIDE_SYNC_ACCESS_REQUIRED) (
        IN PVOID DeviceExtension
        );

typedef NTSTATUS
    (*PCIIDE_TRANSFER_MODE_SELECT_FUNC) (
        IN     PVOID                     DeviceExtension,
        IN OUT PPCIIDE_TRANSFER_MODE_SELECT TransferModeSelect
        );

typedef    ULONG  
    (*PCIIDE_USEDMA_FUNC)(
        IN PVOID deviceExtension, 
        IN PVOID cdbCmd,
        IN UCHAR targetID
        ); 

typedef    NTSTATUS
    (*PCIIDE_UDMA_MODES_SUPPORTED) (
        IDENTIFY_DATA   IdentifyData,
        PULONG          BestXferMode,
        PULONG          CurrentMode
        );
// 
// This structure is for the PCI IDE mini driver to 
// return its properties
// 
typedef struct _IDE_CONTROLLER_PROPERTIES {

    //
    // sizeof (IDE_CONTROLLER_PROPERTIES)
    //
    ULONG Size;      
    
    //
    // Indicate the amount of memory PCI IDE mini driver
    // needs for its private data
    //
    ULONG ExtensionSize;

    //
    // Indicate all the data transfer modes the PCI IDE
    // controller supports
    //                                 
    ULONG SupportedTransferMode[MAX_IDE_CHANNEL][MAX_IDE_DEVICE];

    //
    // callback to query whether a IDE channel is enabled
    //                          
    PCIIDE_CHANNEL_ENABLED      PciIdeChannelEnabled;
    
    //
    // callback to query whether both IDE channels requires
    // synchronized access.  (one channel at a time)
    //                                                              
    PCIIDE_SYNC_ACCESS_REQUIRED PciIdeSyncAccessRequired;
    
    //
    // callback to select proper transfer modes for the
    // given devices
    //
    PCIIDE_TRANSFER_MODE_SELECT_FUNC PciIdeTransferModeSelect;

    //
    // at the end of a ATA data transfer, ignores busmaster 
    // status active bit.  Normally, it should be FALSE
    //                    
    BOOLEAN IgnoreActiveBitForAtaDevice;

    //
    // always clear the busmaster interrupt on every interrupt
    // generated by the device.  Normnally, it should be FALSE
    //
    BOOLEAN AlwaysClearBusMasterInterrupt;

    //
    // callback to determine whether DMA should be used or not
    // called for every IO
    //
    PCIIDE_USEDMA_FUNC PciIdeUseDma;


    //
    // if the miniport needs a different alignment
    //
    ULONG AlignmentRequirement;

    ULONG DefaultPIO;

    //
    // retrieves the supported udma modes from the Identify data
    //
    PCIIDE_UDMA_MODES_SUPPORTED PciIdeUdmaModesSupported;

} IDE_CONTROLLER_PROPERTIES, *PIDE_CONTROLLER_PROPERTIES;

//
// callback to query PCI IDE controller properties
//                            
typedef
NTSTATUS (*PCONTROLLER_PROPERTIES) (
    IN PVOID                      DeviceExtension,
    IN PIDE_CONTROLLER_PROPERTIES ControllerProperties
    );

                     
//
// To initailize PCI IDE mini driver
//                     
NTSTATUS
PciIdeXInitialize(
    IN PDRIVER_OBJECT           DriverObject,
    IN PUNICODE_STRING          RegistryPath,
    IN PCONTROLLER_PROPERTIES   PciIdeGetControllerProperties,
    IN ULONG                    ExtensionSize
    );

//
// To query PCI IDE config space data
//                                    
NTSTATUS
PciIdeXGetBusData(
    IN PVOID DeviceExtension,
    IN PVOID Buffer,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength
    );

//
// To save PCI IDE config space data
//                                    
NTSTATUS
PciIdeXSetBusData(
    IN PVOID DeviceExtension,
    IN PVOID Buffer,
    IN PVOID DataMask,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength
    );

                     
#pragma pack(1)
typedef struct _PCIIDE_CONFIG_HEADER {

    USHORT  VendorID;                   // (ro)
    USHORT  DeviceID;                   // (ro)

    //
    //  Command
    //
    union {

        struct {

            USHORT  IoAccessEnable:1;           // Device control
            USHORT  MemAccessEnable:1;
            USHORT  MasterEnable:1;
            USHORT  SpecialCycle:1;
            USHORT  MemWriteInvalidateEnable:1;
            USHORT  VgaPaletteSnoopEnable:1;
            USHORT  ParityErrorResponse:1;
            USHORT  WaitCycleEnable:1;
            USHORT  SystemErrorEnable:1;
            USHORT  FastBackToBackEnable:1;
            USHORT  CommandReserved:6;
        } b;

        USHORT w;

    } Command;


    USHORT  Status;
    UCHAR   RevisionID;                 // (ro)

    //
    //  Program Interface
    //
    UCHAR   Chan0OpMode:1;
    UCHAR   Chan0Programmable:1;
    UCHAR   Chan1OpMode:1;
    UCHAR   Chan1Programmable:1;
    UCHAR   ProgIfReserved:3;
    UCHAR   MasterIde:1;

    UCHAR   SubClass;                   // (ro)
    UCHAR   BaseClass;                  // (ro)
    UCHAR   CacheLineSize;              // (ro+)
    UCHAR   LatencyTimer;               // (ro+)
    UCHAR   HeaderType;                 // (ro)
    UCHAR   BIST;                       // Built in self test

    struct _PCI_HEADER_TYPE_0 type0;

} PCIIDE_CONFIG_HEADER, *PPCIIDE_CONFIG_HEADER;
#pragma pack()
                     
//
// Debug Print
//                        
#if DBG

VOID
PciIdeXDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    );

#define PciIdeXDebugPrint(x)    PciIdeXDebugPrint x
    
#else
    
#define PciIdeXDebugPrint(x)    

#endif // DBG
                     
#endif // ___ide_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\atapi\wmi.h ===
/*++

Copyright (C) 1997-99  Microsoft Corporation

Module Name:

    wmi.h

Abstract:

--*/

#if !defined (___wmi_h___)
#define ___wmi_h___

typedef struct _WMI_SCSI_ADDRESS {

    UCHAR Bus;
    UCHAR Target;
    UCHAR Lun;

} WMI_SCSI_ADDRESS, *PWMI_SCSI_ADDRESS;

VOID
IdePortWmiInit (
    VOID
    );

NTSTATUS
IdePortWmiRegister(
    PDEVICE_EXTENSION_HEADER DoCommonExtension
    );

NTSTATUS
IdePortWmiDeregister(
    PDEVICE_EXTENSION_HEADER DoCommonExtension
    );

NTSTATUS
IdePortWmiSystemControl(
    IN PDEVICE_OBJECT DeviceObject, 
    IN PIRP           Irp
    );

NTSTATUS
DeviceQueryWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            InstanceCount,
    IN OUT PULONG       InstanceLengthArray,
    IN ULONG            OutBufferSize,
    OUT PUCHAR          Buffer
    );

NTSTATUS
DeviceQueryWmiRegInfo(
    IN PDEVICE_OBJECT   DeviceObject,
    OUT PULONG          RegFlags,
    OUT PUNICODE_STRING InstanceName,
    OUT PUNICODE_STRING *RegistryPath,
    OUT PUNICODE_STRING MofResourceName,
    OUT PDEVICE_OBJECT *Pdo
    );

NTSTATUS
DeviceSetWmiDataBlock(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

NTSTATUS
DeviceSetWmiDataItem(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp,
    IN ULONG            GuidIndex,
    IN ULONG            InstanceIndex,
    IN ULONG            DataItemId,
    IN ULONG            BufferSize,
    IN PUCHAR           Buffer
    );

#endif // ___wmi_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\miniport\intel\init.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       init.c
//
//--------------------------------------------------------------------------

#include "intel.h"


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    return PciIdeXInitialize (
        DriverObject,
        RegistryPath,
        PiixIdeGetControllerProperties,
        sizeof (DEVICE_EXTENSION)
        );
}


//
// Called on every I/O. Returns 1 if DMA is allowed.
// Returns 0 if DMA is not allowed.
//
ULONG
PiixIdeUseDma(
    IN PVOID DeviceExtension,
    IN PVOID cdbcmd,
    IN UCHAR slave)
/**++
 * Arguments : DeviceExtension
               Cdb
               Slave =1, if slave
                     =0, if master
--**/                     
{
    PDEVICE_EXTENSION deviceExtension = DeviceExtension;
    PUCHAR cdb= cdbcmd;

    return 1;
}


NTSTATUS 
PiixIdeGetControllerProperties (
    IN PVOID                      DeviceExtension,
    IN PIDE_CONTROLLER_PROPERTIES ControllerProperties
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceExtension;
    NTSTATUS    status;
    ULONG       i;
    ULONG       j;
    ULONG       mode;
    PCIIDE_CONFIG_HEADER pciData;

    if (ControllerProperties->Size != sizeof (IDE_CONTROLLER_PROPERTIES)) {

        return STATUS_REVISION_MISMATCH;
    }

    status = PciIdeXGetBusData (
                 deviceExtension,
                 &pciData, 
                 0,
                 sizeof (pciData)
                 );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    deviceExtension->DeviceId = pciData.DeviceID;

    if (!IS_INTEL(pciData.VendorID)) {

        return STATUS_UNSUCCESSFUL;
    }

    mode = PIO_SUPPORT;
    deviceExtension->UdmaController = NoUdma;
    if (pciData.MasterIde) {

        mode |= SWDMA_SUPPORT | MWDMA_SUPPORT;

        if (IS_UDMA33_CONTROLLER(pciData.DeviceID)) {
    
            mode |= UDMA33_SUPPORT;
            deviceExtension->UdmaController = Udma33;
            
        }
        
        if (IS_UDMA66_CONTROLLER(pciData.DeviceID)) {
        
            ICH_PCI_CONFIG_DATA ichPciData;
            status = PciIdeXGetBusData (
                         deviceExtension,
                         &ichPciData, 
                         0,
                         sizeof (ichPciData)
                         );
                         
            if (NT_SUCCESS(status)) {
            
                deviceExtension->CableReady[0][0] = (BOOLEAN) ichPciData.IoConfig.b.PrimaryMasterCableReady;
                deviceExtension->CableReady[0][1] = (BOOLEAN) ichPciData.IoConfig.b.PrimarySlaveCableReady;
                deviceExtension->CableReady[1][0] = (BOOLEAN) ichPciData.IoConfig.b.SecondaryMasterCableReady;
                deviceExtension->CableReady[1][1] = (BOOLEAN) ichPciData.IoConfig.b.SecondarySlaveCableReady;
                mode |= UDMA66_SUPPORT;
            }
            
            deviceExtension->UdmaController = Udma66;
        }

        if (IS_UDMA100_CONTROLLER(pciData.DeviceID)) {
        
            ASSERT(IS_UDMA33_CONTROLLER(pciData.DeviceID));
            ASSERT(IS_UDMA66_CONTROLLER(pciData.DeviceID));

            if (NT_SUCCESS(status)) {
                mode |= UDMA100_SUPPORT;
            }
            deviceExtension->UdmaController = Udma100;
        }
    }
    
    for (i=0; i< MAX_IDE_CHANNEL; i++) {

        for (j=0; j< MAX_IDE_DEVICE; j++) {

            ControllerProperties->SupportedTransferMode[i][j] =
                deviceExtension->TransferModeSupported[i][j] = 
                    deviceExtension->TransferModeSupported[i][j] = mode;
        }
    }

    //
    // use this when required
    // if ((pciData.VendorID == 0x8086) && // Intel
    //       (pciData.DeviceID == 0x84c4) && // 82450GX/KX Pentium Pro Processor to PCI bridge
    //       (pciData.RevisionID < 0x4)) {   // Stepping less than 4
    // NO DMA


    ControllerProperties->PciIdeChannelEnabled     = PiixIdeChannelEnabled;
    ControllerProperties->PciIdeSyncAccessRequired = PiixIdeSyncAccessRequired;
    ControllerProperties->PciIdeUseDma = PiixIdeUseDma;
    ControllerProperties->PciIdeUdmaModesSupported = PiixIdeUdmaModesSupported;
    ControllerProperties->AlignmentRequirement=1;
    
#ifdef PIIX_TIMING_REGISTER_SUPPORT
    ControllerProperties->PciIdeTransferModeSelect = PiixIdeTransferModeSelect;
#else    
    ControllerProperties->PciIdeTransferModeSelect = NULL;
#endif 
    

    return STATUS_SUCCESS;
}


IDE_CHANNEL_STATE
PiixIdeChannelEnabled (
    IN PVOID DeviceExtension,
    IN ULONG Channel
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceExtension;
    NTSTATUS status;
    PIIX4_PCI_CONFIG_DATA pciData;

    ASSERT ((Channel & ~1) == 0);

    if (Channel & ~1) {
        return FALSE;
    }

    status = PciIdeXGetBusData (
                 deviceExtension,
                 &pciData.Timing, 
                 FIELD_OFFSET(PIIX4_PCI_CONFIG_DATA, Timing),
                 sizeof (pciData.Timing)
                 );

    if (!NT_SUCCESS(status)) {

        //
        // can't tell
        //
        return ChannelStateUnknown;
    }

    return pciData.Timing[Channel].b.ChannelEnable ? ChannelEnabled : ChannelDisabled;
}

BOOLEAN 
PiixIdeSyncAccessRequired (
    IN PVOID DeviceHandle
    )
{
    //
    // Never!
    //
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\inc\idep.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1999 - 1999
//
//  File:       idep.h
//
//--------------------------------------------------------------------------

#if !defined (___idep_h___)
#define ___idep_h___

#include "ide.h"

#include "wmilib.h"

// go to ntddscsi.h
#define SRB_FUNCTION_ATA_POWER_PASS_THROUGH  0xC7
#define SRB_FUNCTION_ATA_PASS_THROUGH        0xC8

#define ATA_PTFLAGS_BUS_RESET               (1 << 0)
#define ATA_PTFLAGS_OK_TO_FAIL              (1 << 1)
#define ATA_PTFLAGS_EMPTY_CHANNEL_TEST      (1 << 2)
#define ATA_PTFLAGS_INLINE_HARD_RESET       (1 << 3)
#define ATA_PTFLAGS_ENUM_PROBING            (1 << 4)
#define ATA_PTFLAGS_NO_OP                   (1 << 5)
#define ATA_PTFLAGS_STATUS_DRDY_REQUIRED    (1 << 6)
#define ATA_PTFLAGS_URGENT                  (1 << 7)
    
#define MAX_TRANSFER_SIZE_PER_SRB           (0x100 * 0x200)  // 128k ATA limits

typedef struct _ATA_PASS_THROUGH {

    IDEREGS IdeReg;
    ULONG   DataBufferSize;             // byte size of DataBuffer[]
    UCHAR   DataBuffer[1];

}ATA_PASS_THROUGH, *PATA_PASS_THROUGH;

#define NUM_PNP_MINOR_FUNCTION      (0x19)
#define NUM_POWER_MINOR_FUNCTION    (0x04)
#define NUM_WMI_MINOR_FUNCTION      (0xc)
       
#define SAMPLE_CYLINDER_LOW_VALUE       0x55
#define SAMPLE_CYLINDER_HIGH_VALUE      0xaa

//
// Scsiops to suuport dvd operation
// Should go to scsi.h?
//
#if 0
#define SCSIOP_DVD_READ             0xA8
#endif

//
// IDE drive control definitions
//

#define IDE_DC_DISABLE_INTERRUPTS    0x02
#define IDE_DC_RESET_CONTROLLER      0x04
#define IDE_DC_REENABLE_CONTROLLER   0x00

//
// IDE status definitions
//
#define IDE_STATUS_ERROR             0x01
#define IDE_STATUS_INDEX             0x02
#define IDE_STATUS_CORRECTED_ERROR   0x04
#define IDE_STATUS_DRQ               0x08
#define IDE_STATUS_DSC               0x10
#define IDE_STATUS_DRDY              0x40
#define IDE_STATUS_IDLE              0x50
#define IDE_STATUS_BUSY              0x80

#define GetStatus(BaseIoAddress, Status) \
    Status = READ_PORT_UCHAR((BaseIoAddress)->Command);

//
// NEC 98: ide control port.
//
#define CURRENT_INTERRUPT_SENCE (PUCHAR)0x430
#define SELECT_IDE_PORT         (PUCHAR)0x432

//
// NEC 98: dip-switch 2 system port.
//
#define SYSTEM_PORT_A           (PUCHAR)0x31

//
// NEC 98: check enhanced ide support.
//
#define EnhancedIdeSupport() \
    (READ_PORT_UCHAR(CURRENT_INTERRUPT_SENCE)&0x40)?TRUE:FALSE

//
// Checking legacy ide on NEC 98.
//

#ifdef IsNEC_98
#undef IsNEC_98
#endif
#define IsNEC_98 0

#define Is98LegacyIde(BaseIoAddress) \
    (BOOLEAN)(IsNEC_98 && \
             ((BaseIoAddress)->RegistersBaseAddress == \
                        (PUCHAR)IDE_NEC98_COMMAND_PORT_ADDRESS))

//
// Select IDE line(Primary or Secondary).
//    lineNumber:
//        0 - Primary
//        1 - Secondary
//

#define SelectIdeLine(BaseIoAddress,lineNumber) \
{ \
    if (Is98LegacyIde(BaseIoAddress)) { \
        WRITE_PORT_UCHAR (SELECT_IDE_PORT, (UCHAR)((lineNumber) & 0x1)); \
    } \
}

#define SelectIdeDevice(BaseIoAddress, deviceNumber, additional) {\
    SelectIdeLine(BaseIoAddress, (deviceNumber) >>1);\
    WRITE_PORT_UCHAR ((BaseIoAddress)->DriveSelect, (UCHAR)((((deviceNumber) & 0x1) << 4) | 0xA0 | additional));\
    }

#define GetSelectedIdeDevice(BaseIoAddress, cmd) {\
    cmd=READ_PORT_UCHAR((BaseIoAddress)->DriveSelect);\
}

#define ReSelectIdeDevice(BaseIoAddress, cmd) {\
    WRITE_PORT_UCHAR ((BaseIoAddress)->DriveSelect, (UCHAR)cmd);\
}

//
// ISSUE: 08/30/2000 How can I reserve this ioctl value?
//
//#define IOCTL_IDE_BIND_BUSMASTER_PARENT     CTL_CODE(FILE_DEVICE_CONTROLLER, 0x0500, METHOD_BUFFERED, FILE_ANY_ACCESS)
//#define IOCTL_IDE_UNBIND_BUSMASTER_PARENT   CTL_CODE(FILE_DEVICE_CONTROLLER, 0x0502, METHOD_BUFFERED, FILE_ANY_ACCESS)
//#define IOCTL_IDE_GET_SYNC_ACCESS           CTL_CODE(FILE_DEVICE_CONTROLLER, 0x0503, METHOD_BUFFERED, FILE_ANY_ACCESS)
//#define IOCTL_IDE_TRANSFER_MODE_SELECT      CTL_CODE(FILE_DEVICE_CONTROLLER, 0x0504, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define IOCTL_IDE_GET_RESOURCES_ALLOCATED   CTL_CODE(FILE_DEVICE_CONTROLLER, 0x0505, METHOD_BUFFERED, FILE_ANY_ACCESS)

#define MAX_IDE_DEVICE      2

#define MAX_IDE_LINE        2

#define MAX_IDE_CHANNEL     2

#define MAX_IDE_BUS         1

#define MAX_IDE_PATH        MAX_IDE_BUS
#define MAX_IDE_TARGETID    MAX_IDE_DEVICE
#define MAX_IDE_LUN         8

#define IDE_STANDARD_PRIMARY_ADDRESS    (0x1f0)
#define IDE_STANDARD_SECONDARY_ADDRESS  (0x170)

#define IDE_NEC98_COMMAND_PORT_ADDRESS  (0x640)

typedef ULONG BMSTATUS;
#define BMSTATUS_NO_ERROR                       (0)
#define BMSTATUS_NOT_REACH_END_OF_TRANSFER      (1 << 0)
#define BMSTATUS_ERROR_TRANSFER                 (1 << 1)
#define BMSTATUS_INTERRUPT                      (1 << 2)
#define BMSTATUS_SUCCESS(x)                     ((x & ~BMSTATUS_INTERRUPT) == 0)


//
// IDE Cycle Timing
//
#define PIO_MODE0_CYCLE_TIME        600
#define PIO_MODE1_CYCLE_TIME        383
#define PIO_MODE2_CYCLE_TIME        240
#define PIO_MODE3_CYCLE_TIME        180
#define PIO_MODE4_CYCLE_TIME        120

#define SWDMA_MODE0_CYCLE_TIME      960
#define SWDMA_MODE1_CYCLE_TIME      480
#define SWDMA_MODE2_CYCLE_TIME      240

#define MWDMA_MODE0_CYCLE_TIME      480
#define MWDMA_MODE1_CYCLE_TIME      150
#define MWDMA_MODE2_CYCLE_TIME      120

#define UDMA_MODE0_CYCLE_TIME       120
#define UDMA_MODE1_CYCLE_TIME       80
#define UDMA_MODE2_CYCLE_TIME       60
#define UDMA_MODE3_CYCLE_TIME       45
#define UDMA_MODE4_CYCLE_TIME       30
#define UDMA_MODE5_CYCLE_TIME       20
#define UDMA_MODE6_CYCLE_TIME       15




typedef union _IDE_PATH_ID {

    struct {

        ULONG Lun:8;
        ULONG TargetId:8;
        ULONG Path:8;
        ULONG Reserved:8;
    } b;

    ULONG l;

} IDE_PATH_ID, *PIDE_PATH_ID;

typedef struct _IDE_REGISTERS_1 {
    PUCHAR RegistersBaseAddress;

    PUSHORT Data;
    PUCHAR Error;
    PUCHAR BlockCount;
    PUCHAR BlockNumber;
    PUCHAR CylinderLow;
    PUCHAR CylinderHigh;
    PUCHAR DriveSelect;
    PUCHAR Command;
} IDE_REGISTERS_1, *PIDE_REGISTERS_1;

typedef struct _IDE_REGISTERS_2 {
    PUCHAR RegistersBaseAddress;

    PUCHAR DeviceControl;
    PUCHAR DriveAddress;
} IDE_REGISTERS_2, *PIDE_REGISTERS_2;


//
// device extension header
//

#define EXTENSION_COMMON_HEADER     PDEVICE_OBJECT   AttacheeDeviceObject; \
                                    PDEVICE_OBJECT   AttacheePdo; \
                                    PDRIVER_OBJECT   DriverObject; \
                                    PDEVICE_OBJECT   DeviceObject; \
                                    ULONG            PagingPathCount;    /* keep track of page path */ \
                                    ULONG            HiberPathCount;     /* keep track of hiber path */ \
                                    ULONG            CrashDumpPathCount; /* keep track of crashdump path */ \
                                    SYSTEM_POWER_STATE SystemPowerState; \
                                    DEVICE_POWER_STATE DevicePowerState; \
                                    WMILIB_CONTEXT     WmiLibInfo; \
                                    PIRP             PendingSystemPowerIrp; /* DEBUG */ \
                                    PIRP             PendingDevicePowerIrp; /* DEBUG */ \
                                    PDRIVER_DISPATCH DefaultDispatch; \
                                    PDRIVER_DISPATCH *PnPDispatchTable; \
                                    PDRIVER_DISPATCH *PowerDispatchTable; \
                                    PDRIVER_DISPATCH *WmiDispatchTable

typedef struct _DEVICE_EXTENSION_HEADER {

    EXTENSION_COMMON_HEADER;

} DEVICE_EXTENSION_HEADER, * PDEVICE_EXTENSION_HEADER;

typedef struct _PCIIDE_BUSMASTER_INTERFACE {

    ULONG Size;

    ULONG SupportedTransferMode[MAX_IDE_DEVICE * MAX_IDE_LINE];

    ULONG MaxTransferByteSize;

    PVOID Context;

    NTSTATUS
    (* BmSetup) (
        IN  PVOID   Context,
        IN  PVOID   DataVirtualAddress,
        IN  ULONG   TransferByteCount,
        IN  PMDL    Mdl,
        IN  BOOLEAN DataIn,
        IN  VOID    (*BmCallback) (PVOID Context),
        IN  PVOID   CallbackContext
        );

    NTSTATUS
    (* BmArm) (
        IN  PVOID   Context
        );

    BMSTATUS
    (* BmDisarm) (
        IN  PVOID   Context
        );

    BMSTATUS
    (* BmFlush) (
        IN  PVOID   Context
        );

    BMSTATUS
    (* BmStatus) (
        IN  PVOID   Context
        );


    NTSTATUS
    (* BmTimingSetup) (
        IN  PVOID   Context
        );

    BOOLEAN IgnoreActiveBitForAtaDevice;

    BOOLEAN AlwaysClearBusMasterInterrupt;

    ULONG ContextSize;

    NTSTATUS
    (* BmSetupOnePage) (
      IN  PVOID   Context,
      IN  PVOID   DataVirtualPageAddress,
      IN  ULONG   TransferByteCount,
      IN  PMDL    Mdl,
      IN  BOOLEAN DataIn,
      IN  PVOID   RegionDescriptorTablePage
      );

    NTSTATUS
    (* BmCrashDumpInitialize) (
        IN PVOID Context
        );
                
    NTSTATUS
    (* BmFlushAdapterBuffers) (
      IN  PVOID   Context,
      IN  PVOID   DataVirtualPageAddress,
      IN  ULONG   TransferByteCount,
      IN  PMDL    Mdl,
      IN  BOOLEAN DataIn
      );

} PCIIDE_BUSMASTER_INTERFACE, * PPCIIDE_BUSMASTER_INTERFACE;

typedef struct _PCIIDE_SYNC_ACCESS_INTERFACE {

    VOID
    (*AllocateAccessToken) (
        PVOID              Token,
        PDRIVER_CONTROL    Callback,
        PVOID              CallbackContext
        );

    VOID
    (*FreeAccessToken) (
        PVOID              Token
        );

    PVOID   Token;

} PCIIDE_SYNC_ACCESS_INTERFACE, *PPCIIDE_SYNC_ACCESS_INTERFACE;

typedef enum PCIIDE_XFER_MODE_SUPPORT_LEVEL {
    PciIdeBasicXferModeSupport,
    PciIdeFullXferModeSupport
} PCIIDE_XFER_MODE_SUPPORT_LEVEL;

typedef struct _PCIIDE_INTERRUPT_INTERFACE {

	NTSTATUS
	(*PciIdeInterruptControl) (
		PVOID Context,
		ULONG Disable
		);

	PVOID Context;

} PCIIDE_INTERRUPT_INTERFACE, *PPCIIDE_INTERRUPT_INTERFACE;

typedef struct _PCIIDE_XFER_MODE_INTERFACE {

    PCIIDE_XFER_MODE_SUPPORT_LEVEL SupportLevel;
    PVOID   VendorSpecificDeviceExtension;

    NTSTATUS
    (*TransferModeSelect) (
        PVOID                        Context,
        PPCIIDE_TRANSFER_MODE_SELECT XferMode
        );


    ULONG
    (*UseDma) (
        PVOID       deviceExtension,
        PVOID       Cdbcmd,
        UCHAR       targetId
        );


    PVOID Context;

    PULONG  TransferModeTimingTable;
    ULONG   TransferModeTableLength;

    NTSTATUS
    (*UdmaModesSupported) (
        IDENTIFY_DATA   IdentifyData,
        PULONG          BestXferMode,
        PULONG          CurrentMode
        );

} PCIIDE_XFER_MODE_INTERFACE, *PPCIIDE_XFER_MODE_INTERFACE;

#define PCIIDE_PROGIF_MASTER_IDE        (1 << 7)


typedef IDE_CHANNEL_STATE
    (*PCIIDE_CHANNEL_ENABLED) (
        IN PVOID DeviceExtension,
        IN ULONG Channel
        );

typedef BOOLEAN 
    (*PCIIDE_SYNC_ACCESS_REQUIRED) (
        IN PVOID DeviceExtension
        );

typedef NTSTATUS
    (*PCIIDE_TRANSFER_MODE_SELECT_FUNC) (
        IN     PVOID                     DeviceExtension,
        IN OUT PPCIIDE_TRANSFER_MODE_SELECT TransferModeSelect
        );

typedef VOID
    (*PCIIDE_REQUEST_PROPER_RESOURCES) (
        IN PDEVICE_OBJECT PhysicalDeviceObject
        );

typedef
NTSTATUS (*PCONTROLLER_PROPERTIES) (
    IN PVOID                      DeviceExtension,
    IN PIDE_CONTROLLER_PROPERTIES ControllerProperties
    );

NTSTATUS
PciIdeXInitialize(
    IN PDRIVER_OBJECT           DriverObject,
    IN PUNICODE_STRING          RegistryPath,
    IN PCONTROLLER_PROPERTIES   PciIdeGetControllerProperties,
    IN ULONG                    ExtensionSize
    );


NTSTATUS
PciIdeXGetBusData(
    IN PVOID DeviceExtension,
    IN PVOID Buffer,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength
    );

NTSTATUS
PciIdeXSetBusData(
    IN PVOID DeviceExtension,
    IN PVOID Buffer,
    IN PVOID DataMask,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength
    );
                     
NTSTATUS
PciIdeXSaveDeviceParameter (
    IN PVOID DeviceExtension,
    IN PWSTR ParameterName,
    IN ULONG ParameterValue
    );

#if DBG
#define IdePortWaitOnBusyEx(a,b,c) IdePortpWaitOnBusyEx (a,b,c,__FILE__,__LINE__)
#else
#define IdePortWaitOnBusyEx(a,b,c) IdePortpWaitOnBusyEx (a,b,c)
#endif

#ifdef DPC_FOR_EMPTY_CHANNEL
#define IdePortWaitOnBusyExK(CmdRegBase, status, BadStatus) {\
        int ki; \
        for (ki=0; ki<20; ki++) {\
            GetStatus(CmdRegBase, status);\
            if (status == BadStatus) {\
                break;\
            } else if (status & IDE_STATUS_BUSY) {\
                KeStallExecutionProcessor(5);\
                continue;\
            } else {\
                break;\
            }\
        }\
        }
#endif

NTSTATUS
IdePortpWaitOnBusyEx (
    IN PIDE_REGISTERS_1 CmdRegBase,
    IN OUT PUCHAR       Status, 
    IN UCHAR            BadStatus
#if DBG
    ,
    IN PCSTR            FileName,
    IN ULONG            LineNumber
#endif 
);

VOID
IdeCreateIdeDirectory(
    VOID
    );


#define DEVICE_OJBECT_BASE_NAME     L"\\Device\\Ide"
                     
#define MEMORY_SPACE    0
#define IO_SPACE        1

#define CLRMASK(x, mask)     ((x) &= ~(mask));
#define SETMASK(x, mask)     ((x) |=  (mask));

#define IS_PDO(doExtension)  (doExtension->AttacheeDeviceObject == NULL)
#define IS_FDO(doExtension)  (doExtension->AttacheeDeviceObject != NULL)

    /* 681190ea-e4ea-11d0-ab82-00a0c906962f */
DEFINE_GUID(GUID_PCIIDE_BUSMASTER_INTERFACE, 0x681190ea, 0xe4ea, 0x11d0, 0xab, 0x82, 0x00, 0xa0, 0xc9, 0x06, 0x96, 0x2f);
    /* 681190eb-e4ea-11d0-ab82-00a0c906962f */
DEFINE_GUID(GUID_PCIIDE_SYNC_ACCESS_INTERFACE, 0x681190eb, 0xe4ea, 0x11d0, 0xab, 0x82, 0x00, 0xa0, 0xc9, 0x06, 0x96, 0x2f);
    /* 681190ec-e4ea-11d0-ab82-00a0c906962f */
DEFINE_GUID(GUID_PCIIDE_XFER_MODE_INTERFACE, 0x681190ec,  0xe4ea, 0x11d0, 0xab, 0x82, 0x00, 0xa0, 0xc9, 0x06, 0x96, 0x2f);
    /* 681190ed-e4ea-11d0-ab82-00a0c906962f */
DEFINE_GUID(GUID_PCIIDE_REQUEST_PROPER_RESOURCES, 0x681190ed, 0xe4ea, 0x11d0, 0xab, 0x82, 0x00, 0xa0, 0xc9, 0x06, 0x96, 0x2f);
    /* 681190ee-e4ea-11d0-ab82-00a0c906962f */
DEFINE_GUID(GUID_PCIIDE_INTERRUPT_INTERFACE, 0x681190ee, 0xe4ea, 0x11d0, 0xab, 0x82, 0x00, 0xa0, 0xc9, 0x06, 0x96, 0x2f);
    /* {14A001C6-F837-4157-BFC9-496F52C18998} */
DEFINE_GUID(INTERFACENAME4, 0x14a001c6, 0xf837, 0x4157, 0xbf, 0xc9, 0x49, 0x6f, 0x52, 0xc1, 0x89, 0x98);

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))
                     
#if !DBG
#define DECLARE_EXTRA_DEBUG_PARAMETER(t, x)   
#else
#define DECLARE_EXTRA_DEBUG_PARAMETER(t, x)    ,t x
#endif //DBG

//
// ATAPI Exports
//
BOOLEAN
IdePortChannelEmpty (
    IN PIDE_REGISTERS_1 CmdRegBase,
    IN PIDE_REGISTERS_2 CtrlRegBase,
    IN ULONG            MaxIdeDevice
);

#ifdef DPC_FOR_EMPTY_CHANNEL
ULONG
IdePortChannelEmptyQuick (
    IN PIDE_REGISTERS_1 CmdRegBase,
    IN PIDE_REGISTERS_2 CtrlRegBase,
    IN ULONG            MaxIdeDevice,
    PULONG              CurrentIdeDevice,
    PULONG              MoreWait,
    PULONG              NoRetry
);
#endif

typedef struct _IDE_RESOURCE {

    ULONG               CommandBaseAddressSpace;
    ULONG               ControlBaseAddressSpace;
    PUCHAR              TranslatedCommandBaseAddress;
    PUCHAR              TranslatedControlBaseAddress;
    KINTERRUPT_MODE     InterruptMode;
    ULONG               InterruptLevel;

    //
    // Primary and Secondary at disk address (0x1f0 and 0x170) claimed.
    //
    BOOLEAN AtdiskPrimaryClaimed;
    BOOLEAN AtdiskSecondaryClaimed;

} IDE_RESOURCE, *PIDE_RESOURCE;

NTSTATUS
DigestResourceList (
    IN OUT PIDE_RESOURCE                IdeResource,
    IN  PCM_RESOURCE_LIST               ResourceList,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *IrqPartialDescriptors
    );

VOID
AtapiBuildIoAddress (
    IN  PUCHAR            CmdBaseAddress,
    IN  PUCHAR            CtrlBaseAddress,
    OUT PIDE_REGISTERS_1  BaseIoAddress1,
    OUT PIDE_REGISTERS_2  BaseIoAddress2,
    OUT PULONG            BaseIoAddress1Length,
    OUT PULONG            BaseIoAddress2Length,
    OUT PULONG            MaxIdeDevice,
    OUT PULONG            MaxIdeTargetId
);

NTSTATUS
IdeGetDeviceCapabilities(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PDEVICE_CAPABILITIES    DeviceCapabilities
    );

#if DBG
static PUCHAR IdeDebugPnpIrpName[NUM_PNP_MINOR_FUNCTION] = {
    "IRP_MN_START_DEVICE",
    "IRP_MN_QUERY_REMOVE_DEVICE",
    "IRP_MN_REMOVE_DEVICE",
    "IRP_MN_CANCEL_REMOVE_DEVICE",
    "IRP_MN_STOP_DEVICE",
    "IRP_MN_QUERY_STOP_DEVICE",
    "IRP_MN_CANCEL_STOP_DEVICE",

    "IRP_MN_QUERY_DEVICE_RELATIONS",
    "IRP_MN_QUERY_INTERFACE",
    "IRP_MN_QUERY_CAPABILITIES",
    "IRP_MN_QUERY_RESOURCES",
    "IRP_MN_QUERY_RESOURCE_REQUIREMENTS",
    "IRP_MN_QUERY_DEVICE_TEXT",
    "IRP_MN_FILTER_RESOURCE_REQUIREMENTS",
    "an undefined PnP IRP",
    "IRP_MN_READ_CONFIG",
    "IRP_MN_WRITE_CONFIG",
    "IRP_MN_EJECT",
    "IRP_MN_SET_LOCK",
    "IRP_MN_QUERY_ID",
    "IRP_MN_QUERY_PNP_DEVICE_STATE",
    "IRP_MN_QUERY_BUS_INFORMATION",
    "IRP_MN_DEVICE_USAGE_NOTIFICATION",
    "IRP_MN_SURPRISE_REMOVAL",
    "IRP_MN_QUERY_LEGACY_BUS_INFORMATION"
};
static PUCHAR IdeDebugPowerIrpName[NUM_POWER_MINOR_FUNCTION] = {
    "IRP_MN_WAIT_WAKE",
    "IRP_MN_POWER_SEQUENCE",
    "IRP_MN_SET_POWER",
    "IRP_MN_QUERY_POWER"
};
static PUCHAR IdeDebugWmiIrpName[NUM_WMI_MINOR_FUNCTION] = {
    "IRP_MN_QUERY_ALL_DATA",
    "IRP_MN_QUERY_SINGLE_INSTANCE",
    "IRP_MN_CHANGE_SINGLE_INSTANCE",
    "IRP_MN_CHANGE_SINGLE_ITEM",
    "IRP_MN_ENABLE_EVENTS",
    "IRP_MN_DISABLE_EVENTS",
    "IRP_MN_ENABLE_COLLECTION",
    "IRP_MN_DISABLE_COLLECTION",
    "IRP_MN_REGINFO",
    "IRP_MN_EXECUTE_METHOD"
};
#endif

#endif // ___idep_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\miniport\intel\timing.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       timing.h
//
//--------------------------------------------------------------------------

#if !defined (___timing_h___)
#define ___timing_h___

NTSTATUS
PiixIdeTransferModeSelect (
    IN     PDEVICE_EXTENSION            DeviceExtension,
    IN OUT PPCIIDE_TRANSFER_MODE_SELECT TransferModeSelect
    );

NTSTATUS
PiixIdepTransferModeSelect (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PPCIIDE_TRANSFER_MODE_SELECT TransferModeSelect,
    OUT ULONG DriveBestXferMode[MAX_IDE_DEVICE],
    OUT PPIIX_TIMING_REGISTER PiixTimingReg,
    OUT PPIIX3_SLAVE_TIMING_REGISTER PiixSlaveTimingReg,
    OUT PPIIX4_UDMA_CONTROL_REGISTER Piix4UdmaControlReg,
    OUT PPIIX4_UDMA_TIMING_REGISTER Piix4UdmaTimingReg,
    OUT PICH_IO_CONFIG_REGISTER ioConfigReg
    );
                         
#endif // ___timing_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\miniport\intel\intel.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       intel.h
//
//--------------------------------------------------------------------------

#if !defined (___intel_h___)
#define ___intel_h___

#include "stddef.h"
#include "ntddk.h"
#include "ntdddisk.h"
#include "ide.h"

#define INTEL_PCI_VENDOR_ID     ((USHORT)0x8086)
#define PIIX_DEVICE_ID          ((USHORT)0x1230)
#define PIIX3_DEVICE_ID         ((USHORT)0x7010)
#define PIIX4_DEVICE_ID         ((USHORT)0x7111)
#define ICH_DEVICE_ID           ((USHORT)0x2411)
#define ICH0_DEVICE_ID          ((USHORT)0x2421)
#define ICH2_LOWEND_DEVICE_ID   ((USHORT)0x2441)
#define ICH2_MOBILE_DEVICE_ID   ((USHORT)0x244A)
#define ICH2_HIGHEND_DEVICE_ID  ((USHORT)0x244B)
#define ICH3_DEVICE_ID_1        ((USHORT)0x248A)
#define ICH3_DEVICE_ID_2        ((USHORT)0x248B)
#define ICH4_DEVICE_ID_1        ((USHORT)0x24C1)
#define ICH4_DEVICE_ID_2        ((USHORT)0x24CA)
#define ICH4_DEVICE_ID_3        ((USHORT)0x24CB)
#define ICH5_DEVICE_ID_1        ((USHORT)0x24D1)
#define ICH5_DEVICE_ID_2        ((USHORT)0x24DB)
#define SINGLE_CHANNEL_IDE_DEVICE_ID      ((USHORT)0x7199)
#define IA64_IDE_CONTROLLER_DEVICE_ID     ((USHORT)0x7601)

#define IS_INTEL(vendorId)                (vendorId == INTEL_PCI_VENDOR_ID)
#define IS_PIIX(deviceId)                 (deviceId == PIIX_DEVICE_ID)
#define IS_PIIX3(deviceId)                (deviceId == PIIX3_DEVICE_ID)
#define IS_PIIX4(deviceId)                (deviceId == PIIX4_DEVICE_ID)
#define IS_ICH_(deviceId)                 (deviceId == ICH_DEVICE_ID)
#define IS_ICH0(deviceId)                 (deviceId == ICH0_DEVICE_ID || deviceId == IA64_IDE_CONTROLLER_DEVICE_ID)
#define IS_ICH2_LOW(deviceId)             (deviceId == ICH2_LOWEND_DEVICE_ID)
#define IS_ICH2_MOBILE(deviceId)          (deviceId == ICH2_MOBILE_DEVICE_ID)
#define IS_ICH2_HIGH(deviceId)            (deviceId == ICH2_HIGHEND_DEVICE_ID)
#define IS_ICH2(deviceId)                 (IS_ICH2_LOW(deviceId) || IS_ICH2_MOBILE(deviceId) || IS_ICH2_HIGH(deviceId))
#define IS_ICH3(deviceId)                 ((deviceId == ICH3_DEVICE_ID_1) || (deviceId == ICH3_DEVICE_ID_2))
#define IS_ICH4(deviceId)                 ((deviceId == ICH4_DEVICE_ID_1) || (deviceId == ICH4_DEVICE_ID_2) || (deviceId == ICH4_DEVICE_ID_3))
#define IS_ICH5(deviceId)                 ((deviceId == ICH5_DEVICE_ID_1) || (deviceId == ICH5_DEVICE_ID_2))
#define IS_SINGLE_IDE(deviceId)           (deviceId == SINGLE_CHANNEL_IDE_DEVICE_ID)

#define IS_UDMA33_CONTROLLER(deviceId)    (IS_PIIX4(deviceId) || IS_ICH0(deviceId) || IS_ICH_(deviceId) || IS_SINGLE_IDE(deviceId) || IS_ICH2(deviceId) || IS_ICH3(deviceId) || IS_ICH4(deviceId) || IS_ICH5(deviceId))
#define IS_UDMA66_CONTROLLER(deviceId)    (IS_ICH_(deviceId) || IS_ICH2(deviceId) || IS_ICH3(deviceId) || IS_ICH4(deviceId) || IS_ICH5(deviceId))
#define IS_UDMA100_CONTROLLER(deviceId)   (IS_ICH2_MOBILE(deviceId) || IS_ICH2_HIGH(deviceId) || IS_ICH3(deviceId) || IS_ICH4(deviceId) || IS_ICH5(deviceId))
#define IS_UDMA_CONTROLLER(deviceId)      (IS_UDMA33_CONTROLLER(deviceId) || IS_UDMA66_CONTROLLER(deviceId) || IS_UDMA100_CONTROLLER(deviceId))

#pragma pack(1)
typedef struct _PIIX_SPECIAL_TIMING_REGISTER {

    union {

        UCHAR AsUChar;

        struct {

            UCHAR FastTimingBankDriveSelect:1;
            UCHAR IoReadySamplePointEnableDriveSelect:1;
            UCHAR PrefetchAndPostingEnable:1;
            UCHAR DmaTimingEnable:1;
        } b;
    };

} PIIX_SPECIAL_TIMING_REGISTER, *PPIIX_SPECIAL_TIMING_REGISTER;

typedef struct _PIIX_TIMING_REGISTER {

    union {

        struct {
            union {
                struct {
        
                    UCHAR Device0SpecialTiming:4;
                    UCHAR Device1SpecialTiming:4;
        
                } n;
        
                struct {
        
                    UCHAR FastTimingBankDriveSelect0:1;
                    UCHAR IoReadySamplePointEnableDriveSelect0:1;
                    UCHAR PrefetchAndPostingEnable0:1;
                    UCHAR DmaTimingEnable0:1;

                    UCHAR FastTimingBankDriveSelect1:1;
                    UCHAR IoReadySamplePointEnableDriveSelect1:1;
                    UCHAR PrefetchAndPostingEnable1:1;
                    UCHAR DmaTimingEnable1:1;
        
                } b;
            };
        
            UCHAR RecoveryTime:2;
            UCHAR Reserved:2;
        
            UCHAR IoReadySamplePoint:2;
            UCHAR SlaveTimingEnable:1;
            UCHAR ChannelEnable:1;
        }b;

        USHORT AsUShort;
    };

} PIIX_TIMING_REGISTER, *PPIIX_TIMING_REGISTER;

typedef struct _PIIX3_SLAVE_TIMING_REGISTER {

    union {

        struct {

            UCHAR Channel0RecoveryTime:2;
            UCHAR Channel0IoReadySamplePoint:2;

            UCHAR Channel1RecoveryTime:2;
            UCHAR Channel1IoReadySamplePoint:2;
        } b;

        UCHAR AsUChar;
    };

} PIIX3_SLAVE_TIMING_REGISTER, *PPIIX3_SLAVE_TIMING_REGISTER;

typedef struct _PIIX4_UDMA_CONTROL_REGISTER {

    union {

        struct {

            UCHAR Channel0Drive0UdmaEnable:1;
            UCHAR Channel0Drive1UdmaEnable:1;
            UCHAR Channel1Drive0UdmaEnable:1;
            UCHAR Channel1Drive1UdmaEnable:1;
            UCHAR Reserved:4;
        } b;

        UCHAR AsUChar;
    };

}PIIX4_UDMA_CONTROL_REGISTER, *PPIIX4_UDMA_CONTROL_REGISTER;

typedef struct _PIIX4_UDMA_TIMING_REGISTER {

    union {
        struct {

            UCHAR Drive0CycleTime:2;
            UCHAR Reserved0:2;
            UCHAR Drive1CycleTime:2;
            UCHAR Reserved1:2;
        } b;

        UCHAR AsUChar;
    };

}PIIX4_UDMA_TIMING_REGISTER, *PPIIX4_UDMA_TIMING_REGISTER;

typedef struct _ICH_IO_CONFIG_REGISTER {

    union {
    
        USHORT AsUShort;                        
        struct {
            USHORT PrimaryMasterBaseClock:1;
            USHORT PrimarySlaveBaseClock:1;
            USHORT SecondaryMasterBaseClock:1;
            USHORT SecondarySlaveBaseClock:1;
            
            USHORT PrimaryMasterCableReady:1;
            USHORT PrimarySlaveCableReady:1;
            USHORT SecondaryMasterCableReady:1;
            USHORT SecondarySlaveCableReady:1;
            
            USHORT Reserved1:2;
            USHORT WriteBufferPingPongEnable:1;
            USHORT Reserved2:1;

            USHORT FastPrimaryMasterBaseClock:1;
            USHORT FastPrimarySlaveBaseClock:1;
            USHORT FastSecondaryMasterBaseClock:1;
            USHORT FastSecondarySlaveBaseClock:1;
/***
            union {
                USHORT Reserved3:4;
                struct {
                    USHORT FastPrimaryMasterBaseClock:1;
                    USHORT FastPrimarySlaveBaseClock:1;
                    USHORT FastSecondaryMasterBaseClock:1;
                    USHORT FastSecondarySlaveBaseClock:1;
                }f;
            };
***/
        } b;
    };                                             // offset 54              
                       
}ICH_IO_CONFIG_REGISTER, *PICH_IO_CONFIG_REGISTER;
       
#define PIIX4_UDMA_MODE2_TIMING      2
#define PIIX4_UDMA_MODE1_TIMING      1
#define PIIX4_UDMA_MODE0_TIMING      0

typedef struct _PIIX4_PCI_CONFIG_DATA {

    PCIIDE_CONFIG_HEADER h;

    PIIX_TIMING_REGISTER Timing[MAX_IDE_CHANNEL];           // offset 40, 41, 42, 43
                                                            
    PIIX3_SLAVE_TIMING_REGISTER SlaveTiming;                // offset 44
                                                            
    UCHAR Reserved0[3];                                     // offset 45, 46, 47
                                                            
    PIIX4_UDMA_CONTROL_REGISTER UdmaControl;                // offset 48
                                                            
    UCHAR Reserved1[1];                                     // offset 49

    PIIX4_UDMA_TIMING_REGISTER UdmaTiming[MAX_IDE_CHANNEL]; // offset 4a, 4b
                        
} PIIX4_PCI_CONFIG_DATA, *PPIIX4_PCI_CONFIG_DATA;
            
#define ICH2_UDMA_MODE5_TIMING      1

#define ICH_UDMA_MODE4_TIMING       2
#define ICH_UDMA_MODE3_TIMING       1
                               
typedef enum {
    NoUdma=0,
    Udma33,
    Udma66,
    Udma100
}CONTROLLER_MODE;

typedef struct _ICH_PCI_CONFIG_DATA {

    PIIX4_PCI_CONFIG_DATA Piix4PciConfigData;                       
                       
    UCHAR Reserved2[8];                                     // offset 4c-53
    
    ICH_IO_CONFIG_REGISTER IoConfig;                        // offset 54
                        
} ICH_PCI_CONFIG_DATA, *PICH_PCI_CONFIG_DATA;
#pragma pack()

typedef struct _DEVICE_EXTENSION {

    USHORT DeviceId;

    ULONG TransferModeSupported[MAX_IDE_CHANNEL][MAX_IDE_DEVICE];
    
    BOOLEAN CableReady[MAX_IDE_CHANNEL][MAX_IDE_DEVICE];
    
    CONTROLLER_MODE  UdmaController; 

    IDENTIFY_DATA IdentifyData[MAX_IDE_DEVICE];

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;

#define PIIX_TIMING_CHANNEL_ENABLE               0x8000
#define PIIX_TIMING_SLAVE_TIMING_ENABLE          0x4000

#define PIIX_TIMING_DMA_TIMING_ENABLE(x)           (x ? 0x0008 : 0)
#define PIIX_TIMING_PREFETCH_AND_POSTING_ENABLE(x) (x ? 0x0004 : 0)
#define PIIX_TIMING_IOREADY_SAMPLE_POINT_ENABLE(x) (x ? 0x0002 : 0)
#define PIIX_TIMING_FAST_TIMING_BANK_ENABLE(x)     (x ? 0x0001 : 0)


#define UDMA_MASK(controller, cable, enableUdma66, mask) {\
    switch (controller) { \
        case Udma100:   mask &= 0xffffffff;enableUdma66=1;break; \
        case Udma66:    mask &= 0x0000ffff;break; \
        case Udma33:    mask &= 0x00003fff;break; \
        default:        mask &= 0x000007ff;break; \
    } \
    if (!(cable && enableUdma66)) { \
        mask &= 0x00003fff; \
    } \
}


typedef enum {
    PiixMode_NotPresent = 0,
    PiixMode_Mode0,
    PiixMode_Mode2,
    PiixMode_Mode3,
    PiixMode_Mode4,
    PiixMode_MaxMode
} PIIX_TIMING_MODE;


NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

NTSTATUS 
PiixIdeGetControllerProperties (
    IN PVOID                      DeviceExtension,
    IN PIDE_CONTROLLER_PROPERTIES ControllerProperties
    );

IDE_CHANNEL_STATE 
PiixIdeChannelEnabled (
    IN PVOID DeviceHandle,
    IN ULONG Channel
    );

BOOLEAN 
PiixIdeSyncAccessRequired (
    IN PVOID DeviceHandle
    );

NTSTATUS
PiixIdeTransferModeSelect (
    IN     PDEVICE_EXTENSION            DeviceExtension,
    IN OUT PPCIIDE_TRANSFER_MODE_SELECT TransferModeSelect
    );

NTSTATUS
PiixIdeUdmaModesSupported (
    IN IDENTIFY_DATA    IdentifyData,
    IN OUT PULONG       BestXferMode,
    IN OUT PULONG       CurrentMode
    );

#include "timing.h"

#endif // ___intel_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\miniport\intel\timing.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       timing.c
//
//--------------------------------------------------------------------------

#include "intel.h"

//
// PiixTiming[Master Timing Mode][Slave Timing Mode]
//    
PIIX_SPECIAL_TIMING_REGISTER PiixSpecialTiming[PiixMode_MaxMode] =
{
    {
    PIIX_TIMING_DMA_TIMING_ENABLE(0) | 
    PIIX_TIMING_PREFETCH_AND_POSTING_ENABLE(0) |
    PIIX_TIMING_IOREADY_SAMPLE_POINT_ENABLE(0) |
    PIIX_TIMING_FAST_TIMING_BANK_ENABLE(0)
    },                                                  // not present

    {
    PIIX_TIMING_DMA_TIMING_ENABLE(0) | 
    PIIX_TIMING_PREFETCH_AND_POSTING_ENABLE(0) |
    PIIX_TIMING_IOREADY_SAMPLE_POINT_ENABLE(0) |    
    PIIX_TIMING_FAST_TIMING_BANK_ENABLE(0)
    },                                                  // piix timing mode 0

    {
    PIIX_TIMING_DMA_TIMING_ENABLE(0) |
    PIIX_TIMING_PREFETCH_AND_POSTING_ENABLE(0) |
    PIIX_TIMING_IOREADY_SAMPLE_POINT_ENABLE(0) |    
    PIIX_TIMING_FAST_TIMING_BANK_ENABLE(1)
    },                                                  // piix timing mode 2

    {
    PIIX_TIMING_DMA_TIMING_ENABLE(0) |
    PIIX_TIMING_PREFETCH_AND_POSTING_ENABLE(0) |
    PIIX_TIMING_IOREADY_SAMPLE_POINT_ENABLE(1) |    
    PIIX_TIMING_FAST_TIMING_BANK_ENABLE(1)
    },                                                  // piix timing mode 3

    {
    PIIX_TIMING_DMA_TIMING_ENABLE(0) |
    PIIX_TIMING_PREFETCH_AND_POSTING_ENABLE(0) |
    PIIX_TIMING_IOREADY_SAMPLE_POINT_ENABLE(1) |
    PIIX_TIMING_FAST_TIMING_BANK_ENABLE(1)
    }                                                   // piix timing mode 4
};

UCHAR PiixIoReadySamplePointClockSetting[PiixMode_MaxMode] =
{
    0,
    0,
    1,
    2,
    2
};

UCHAR PiixRecoveryTimeClockSetting[PiixMode_MaxMode] =
{
    0,
    0,
    0,
    1,
    3
};

NTSTATUS
PiixIdeUdmaModesSupported (
    IN IDENTIFY_DATA    IdentifyData,
    IN OUT PULONG       BestXferMode,
    IN OUT PULONG       CurrentMode
    )
{
    ULONG bestXferMode =0;
    ULONG currentMode = 0;

    if (IdentifyData.TranslationFieldsValid & (1 << 2)) {

        if (IdentifyData.UltraDMASupport) {

            GetHighestTransferMode( IdentifyData.UltraDMASupport,
                                       bestXferMode);
            *BestXferMode = bestXferMode;
        }

        if (IdentifyData.UltraDMAActive) {

            GetHighestTransferMode( IdentifyData.UltraDMAActive,
                                       currentMode);
            *CurrentMode = currentMode;
        }
    }

    return STATUS_SUCCESS;
}

NTSTATUS
PiixIdeTransferModeSelect (
    IN     PDEVICE_EXTENSION            DeviceExtension,
    IN OUT PPCIIDE_TRANSFER_MODE_SELECT TransferModeSelect
    )
{
    NTSTATUS status;
    ULONG driveBestXferMode[MAX_IDE_DEVICE];
    PIIX_TIMING_REGISTER piixTimingReg;
    PIIX3_SLAVE_TIMING_REGISTER piixSlaveTimingReg;
    PIIX4_UDMA_CONTROL_REGISTER piix4UdmaControlReg;
    PIIX4_UDMA_TIMING_REGISTER piix4UdmaTimingReg;
    ICH_IO_CONFIG_REGISTER ioConfigReg;
    USHORT dataMask;
    ULONG i;


    //
    // Store the identify data for later use.
    //
    for (i=0;i<MAX_IDE_DEVICE;i++) {
        DeviceExtension->IdentifyData[i]=TransferModeSelect->IdentifyData[i];
    }
    status = PiixIdepTransferModeSelect (
                 DeviceExtension,
                 TransferModeSelect,
                 driveBestXferMode,
                 &piixTimingReg,
                 &piixSlaveTimingReg,
                 &piix4UdmaControlReg,
                 &piix4UdmaTimingReg,
                 &ioConfigReg
                 );

    if (NT_SUCCESS(status)) {

#if DBG

    {
        PIIX_TIMING_REGISTER piixOldTimingReg[2];
        PIIX3_SLAVE_TIMING_REGISTER piixOldSlaveTimingReg;
        PIIX4_UDMA_CONTROL_REGISTER piix4OldUdmaControlReg;
        PIIX4_UDMA_TIMING_REGISTER piix4OldUdmaTimingReg;
        ICH_IO_CONFIG_REGISTER oldIoConfigReg;
        ULONG channel;

#define BitSet(Data, Mask, NewData)     Data = ((Data & ~Mask) | (Mask & NewData));

        piixOldSlaveTimingReg.AsUChar = 0;
        piix4OldUdmaControlReg.AsUChar = 0;
        piix4OldUdmaTimingReg.AsUChar = 0;

        channel = TransferModeSelect->Channel;

        PciIdeXGetBusData (
            DeviceExtension,
            piixOldTimingReg, 
            FIELD_OFFSET(PIIX4_PCI_CONFIG_DATA, Timing),
            sizeof (piixOldTimingReg)
            );

        PciIdeXDebugPrint ((1, 
                     "Old PIIX Timing Register Value (IDETIM = 0x%x", 
                     piixOldTimingReg[channel].AsUShort));

        if (!IS_PIIX(DeviceExtension->DeviceId)) {

            PciIdeXGetBusData (
                DeviceExtension,
                &piixOldSlaveTimingReg, 
                FIELD_OFFSET(PIIX4_PCI_CONFIG_DATA, SlaveTiming),
                sizeof (piixOldSlaveTimingReg)
                );

            PciIdeXDebugPrint ((1, 
                         " SIDETIM (0x%x)", 
                         piixOldSlaveTimingReg.AsUChar));
        }

        if (IS_UDMA_CONTROLLER(DeviceExtension->DeviceId)) {

            PciIdeXGetBusData (
                DeviceExtension,
                &piix4OldUdmaControlReg, 
                FIELD_OFFSET(PIIX4_PCI_CONFIG_DATA, UdmaControl),
                sizeof (piix4OldUdmaControlReg)
                );

            PciIdeXDebugPrint ((1, 
                         " SDMACTL (0x%x)", 
                         piix4OldUdmaControlReg.AsUChar));

            PciIdeXGetBusData (
                DeviceExtension,
                &piix4OldUdmaTimingReg, 
                FIELD_OFFSET(PIIX4_PCI_CONFIG_DATA, UdmaTiming[channel]),
                sizeof (piix4OldUdmaTimingReg)
                );

            PciIdeXDebugPrint ((1, 
                         " SDMATIM (0x%x)", 
                         piix4OldUdmaTimingReg.AsUChar));
        }

        if (IS_ICH_(DeviceExtension->DeviceId) || 
            IS_ICH0(DeviceExtension->DeviceId)) {

            PciIdeXGetBusData (
                DeviceExtension,
                &oldIoConfigReg, 
                FIELD_OFFSET(ICH_PCI_CONFIG_DATA, IoConfig),
                sizeof (oldIoConfigReg)
                );

            PciIdeXDebugPrint ((1, 
                         " I/O Control (0x%x)", 
                         oldIoConfigReg.AsUShort));
        }
                              
        PciIdeXDebugPrint ((1, "\n"));

        if (channel == 0) {

            BitSet (piixOldSlaveTimingReg.AsUChar, 0x0f, piixSlaveTimingReg.AsUChar);
            BitSet (piix4OldUdmaControlReg.AsUChar, 0x03, piix4UdmaControlReg.AsUChar);
                               
        } else {

            BitSet (piixOldSlaveTimingReg.AsUChar, 0xf0, piixSlaveTimingReg.AsUChar);
            BitSet (piix4OldUdmaControlReg.AsUChar, 0x0c, piix4UdmaControlReg.AsUChar);
        }
        BitSet (oldIoConfigReg.AsUShort, 0x0f, ioConfigReg.AsUShort);
                     
        PciIdeXDebugPrint ((1, 
                     "New PIIX/ICH Timing Register Value (IDETIM = 0x%x, SIDETIM (0x%x), SDMACTL (0x%x), SDMATIM (0x%x), IOCTRL (0x%x)\n", 
                     piixTimingReg.AsUShort, 
                     piixOldSlaveTimingReg.AsUChar,
                     piix4OldUdmaControlReg.AsUChar,
                     piix4UdmaTimingReg.AsUChar,
                     oldIoConfigReg.AsUShort
                     ));
    }

#endif // DBG


#ifndef PIIX_TIMING_REGISTER_SUPPORT
    status = STATUS_UNSUCCESSFUL;
    goto GetOut;
#endif 


        dataMask = 0xffff;
        status = PciIdeXSetBusData (
                     DeviceExtension,
                     &piixTimingReg, 
                     &dataMask,
                     FIELD_OFFSET(PIIX4_PCI_CONFIG_DATA, Timing) + 
                         sizeof(piixTimingReg) * 
                         TransferModeSelect->Channel,
                     sizeof (piixTimingReg)
                     );
        if (!NT_SUCCESS(status)) {
            goto GetOut;
        }


        if (!IS_PIIX(DeviceExtension->DeviceId)) {

            dataMask = TransferModeSelect->Channel == 0 ? 0x0f : 0xf0;
            status = PciIdeXSetBusData (
                         DeviceExtension,
                         &piixSlaveTimingReg, 
                         &dataMask,
                         FIELD_OFFSET(PIIX4_PCI_CONFIG_DATA, SlaveTiming),
                         sizeof (piixSlaveTimingReg)
                         );
    
            if (!NT_SUCCESS(status)) {
    
                ASSERT(!"Unable to set pci config data\n");
                goto GetOut;
            }
        }
        
        if (IS_UDMA_CONTROLLER(DeviceExtension->DeviceId)) {

            //
            // UDMA Control Register
            //
            dataMask = TransferModeSelect->Channel == 0 ? 0x03 : 0x0c;
            status = PciIdeXSetBusData (
                         DeviceExtension,
                         &piix4UdmaControlReg, 
                         &dataMask,
                         FIELD_OFFSET(PIIX4_PCI_CONFIG_DATA, UdmaControl),
                         sizeof (piix4UdmaControlReg)
                         );
    
            if (!NT_SUCCESS(status)) {
    
                ASSERT(!"Unable to set pci config data\n");
                goto GetOut;
            }
            
            //
            // UDMA Timing Register
            //
            dataMask = 0xff;
            status = PciIdeXSetBusData (
                         DeviceExtension,
                         &piix4UdmaTimingReg, 
                         &dataMask,
                         FIELD_OFFSET(PIIX4_PCI_CONFIG_DATA, UdmaTiming) +
                             sizeof(piix4UdmaTimingReg) * 
                             TransferModeSelect->Channel,
                         sizeof (piix4UdmaTimingReg)
                         );
    
            if (!NT_SUCCESS(status)) {
    
                ASSERT(!"Unable to set pci config data\n");
                goto GetOut;
            }
        }
        
        if (IS_ICH_(DeviceExtension->DeviceId) || 
            IS_ICH0(DeviceExtension->DeviceId) ||
            IS_ICH2(DeviceExtension->DeviceId)) {

            //
            // UDMA Control Register
            //
            dataMask = TransferModeSelect->Channel == 0 ? 0x0403 : 0x040c;
            status = PciIdeXSetBusData (
                         DeviceExtension,
                         &ioConfigReg, 
                         &dataMask,
                         FIELD_OFFSET(ICH_PCI_CONFIG_DATA, IoConfig),
                         sizeof (ioConfigReg)
                         );
    
            if (!NT_SUCCESS(status)) {
    
                ASSERT(!"Unable to set pci config data\n");
                goto GetOut;
            }
        }
    }

GetOut:

    if (NT_SUCCESS(status)) {

        for (i = 0; i < MAX_IDE_DEVICE; i++) {
            TransferModeSelect->DeviceTransferModeSelected[i] = 
                driveBestXferMode[i];
        }
    }

    return status;
}

     
NTSTATUS
PiixIdepTransferModeSelect (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN PPCIIDE_TRANSFER_MODE_SELECT TransferModeSelect,
    OUT ULONG DriveBestXferMode[MAX_IDE_DEVICE],
    OUT PPIIX_TIMING_REGISTER PiixTimingReg,
    OUT PPIIX3_SLAVE_TIMING_REGISTER PiixSlaveTimingReg,
    OUT PPIIX4_UDMA_CONTROL_REGISTER Piix4UdmaControlReg,
    OUT PPIIX4_UDMA_TIMING_REGISTER Piix4UdmaTimingReg,
    OUT PICH_IO_CONFIG_REGISTER IoConfigReg
    )
{
    ULONG i;
    ULONG xferMode;
    ULONG channel;
    NTSTATUS status;
    UCHAR ispClockSetting;
    UCHAR recoveryClockSetting;
    PIIX_TIMING_MODE piixTimingMode;
    PIIX_SPECIAL_TIMING_REGISTER piixSpecialTiming;

    ULONG driveBestXferMode[MAX_IDE_DEVICE];
    PIIX_TIMING_REGISTER piixTimingReg;
    PIIX3_SLAVE_TIMING_REGISTER piixSlaveTimingReg;
    PIIX4_UDMA_CONTROL_REGISTER piix4UdmaControlReg;
    PIIX4_UDMA_TIMING_REGISTER piix4UdmaTimingReg;
    ICH_IO_CONFIG_REGISTER ioConfigReg;

    ULONG transferModeSupported;
    PULONG transferModeTimingTable;

    channel = TransferModeSelect->Channel;

    piixTimingReg.AsUShort = 0;
    piixSlaveTimingReg.AsUChar = 0;

    transferModeTimingTable=TransferModeSelect->TransferModeTimingTable;
    ASSERT(transferModeTimingTable);

    for (i = 0; i < MAX_IDE_DEVICE; i++) {

        ULONG enableUdma66 = TransferModeSelect->EnableUDMA66;

        driveBestXferMode[i] = 0;

        if (TransferModeSelect->DevicePresent[i] == FALSE) {

            continue;
        }
#if 1
        //
        // UDMA transfer mode
        //
        transferModeSupported=TransferModeSelect->DeviceTransferModeSupported[i];

        //
        // only upto udma 5 is supported
        //
        transferModeSupported &= 0x1ffff;

        //
        // translate drive reported udma settings to drive's best udma mode
        // UDMA_MASK masks out udma mode >2 if cableReady or enableUdma is not set for a
        // controller that supports modes > udma2. enableUdma flag is ignored for Udma100
        // controllers
        //                                                                               
        UDMA_MASK(DeviceExtension->UdmaController, DeviceExtension->CableReady[channel][i],
                  enableUdma66, transferModeSupported);

        GetHighestDMATransferMode(transferModeSupported, xferMode);

        if (xferMode >= UDMA0) {

            driveBestXferMode[i] = 1 << xferMode;
        }

        //
        // DMA transfer mode
        //

        //
        // Get the highest DMA mode (exclude UDMA)
        //
        transferModeSupported = TransferModeSelect->
                                    DeviceTransferModeSupported[i] & (MWDMA_SUPPORT | SWDMA_SUPPORT);
        GetHighestDMATransferMode(transferModeSupported, xferMode);

        //
        // if xfermode is mwdma2 or 1, select mwdma2 , 1 or swdma2 depending on the cycle time
        //
        if (xferMode >= MWDMA1) {

            while (xferMode >= SWDMA2) {
                //
                // MWDMA0 is not supported
                //
                if (xferMode == MWDMA0) {
                    xferMode--;
                    continue;
                }
                if (TransferModeSelect->BestMwDmaCycleTime[i] <= transferModeTimingTable[xferMode]) {
                    driveBestXferMode[i] |= (1 << xferMode);
                    break;
                }
                xferMode--;
            }

        } else if (xferMode == SWDMA2) {

            if (TransferModeSelect->BestSwDmaCycleTime[i] <= transferModeTimingTable[xferMode]) {

                driveBestXferMode[i] |= SWDMA_MODE2;

            } //else use PIO

        }
        //
        // Don't use SWDMA0 and SWDMA1
        // 

        //
        // PIO transfer mode
        //
        transferModeSupported=TransferModeSelect->DeviceTransferModeSupported[i];
        GetHighestPIOTransferMode(transferModeSupported, xferMode);

        //
        // if PIO2 is the highest PIO mode supported, don't check the
        // bestPIOTiming reported by the device.
        //
        if (xferMode == PIO2) {

            driveBestXferMode[i] |= (1 << xferMode);

        } else {
            //
            // PIO1 is not supported
            //
            while (xferMode > PIO1) {

                if (TransferModeSelect->BestPioCycleTime[i] <= transferModeTimingTable[xferMode]) {

                    driveBestXferMode[i] |= (1 << xferMode);
                    break;

                }
                xferMode--;
            }

            //
            // default to PIO0
            //
            if (xferMode <= PIO1) {
                driveBestXferMode[i] |= (1 << PIO0);
            }
        }

#endif
    }
    //
    // use the slower mode if we have a old piix and two devices on the channel
    // 
    if (IS_PIIX(DeviceExtension->DeviceId)) {

        if (TransferModeSelect->DevicePresent[0] && TransferModeSelect->DevicePresent[1]) {

            ULONG mode;
    
            if ((driveBestXferMode[0] & PIO_SUPPORT) <=
                (driveBestXferMode[1] & PIO_SUPPORT)) {
    
                mode = driveBestXferMode[0] & PIO_SUPPORT;
    
            } else {
    
                mode = driveBestXferMode[1] & PIO_SUPPORT;
            }
    
            if ((driveBestXferMode[0] & SWDMA_SUPPORT) <=
                (driveBestXferMode[1] & SWDMA_SUPPORT)) {
    
                mode |= driveBestXferMode[0] & SWDMA_SUPPORT;
    
            } else {
    
                mode |= driveBestXferMode[1] & SWDMA_SUPPORT;
            }
    
            if ((driveBestXferMode[0] & MWDMA_SUPPORT) <=
                (driveBestXferMode[1] & MWDMA_SUPPORT)) {
    
                mode |= driveBestXferMode[0] & MWDMA_SUPPORT;
    
            } else {
    
                mode |= driveBestXferMode[1] & MWDMA_SUPPORT;
            }
    
            if ((driveBestXferMode[0] & UDMA_SUPPORT) <=
                (driveBestXferMode[1] & UDMA_SUPPORT)) {
    
                mode |= driveBestXferMode[0] & UDMA_SUPPORT;
    
            } else {
    
                mode |= driveBestXferMode[1] & UDMA_SUPPORT;
            }
    
            driveBestXferMode[0] = driveBestXferMode[1] = mode;
        }
    }

    //
    // translate device ATA timing mode to piix timing mode
    //
    for (i = 0; i < MAX_IDE_DEVICE; i++) {

        piixSpecialTiming.AsUChar = 0;

        if (TransferModeSelect->DevicePresent[i] == FALSE) {

            piixTimingMode = PiixMode_NotPresent;

        } else {

            //
            // default
            //
            piixTimingMode = PiixMode_Mode0;

            if (!(driveBestXferMode[i] & DMA_SUPPORT)) {
    
                //
                // pio only device
                //
    
                if (driveBestXferMode[i] & PIO_MODE0) {
    
                    piixTimingMode = PiixMode_Mode0;

                } else if (driveBestXferMode[i] & PIO_MODE2) {

                    piixTimingMode = PiixMode_Mode2;

                    if (TransferModeSelect->IoReadySupported[i]) {

                        piixSpecialTiming.AsUChar |= PIIX_TIMING_IOREADY_SAMPLE_POINT_ENABLE(1);
                    }

                } else if (driveBestXferMode[i] & PIO_MODE3) {

                    piixTimingMode = PiixMode_Mode3;

                } else if (driveBestXferMode[i] & PIO_MODE4) {

                    piixTimingMode = PiixMode_Mode4;

                } else {

                    ASSERT(FALSE);
                }

            } else if (driveBestXferMode[i] & SWDMA_MODE2) {

                piixTimingMode = PiixMode_Mode2;

                if (driveBestXferMode[i] & PIO_MODE0) {

                    piixSpecialTiming.AsUChar |= PIIX_TIMING_DMA_TIMING_ENABLE(1);
                }

                if (TransferModeSelect->IoReadySupported[i]) {

                    piixSpecialTiming.AsUChar |= PIIX_TIMING_IOREADY_SAMPLE_POINT_ENABLE(1);
                }

            } else if (driveBestXferMode[i] & MWDMA_MODE1) {
    
                piixTimingMode = PiixMode_Mode3;

                if (driveBestXferMode[i] & (PIO_MODE0 | PIO_MODE2)) {

                    piixSpecialTiming.AsUChar |= PIIX_TIMING_DMA_TIMING_ENABLE(1);
                }

            } else if (driveBestXferMode[i] & MWDMA_MODE2) {
    
                if (driveBestXferMode[i] & PIO_MODE3) {

                    piixTimingMode = PiixMode_Mode3;

                } else {

                    piixTimingMode = PiixMode_Mode4;
                }

                if (driveBestXferMode[i] & (PIO_MODE0 | PIO_MODE2)) {

                    piixSpecialTiming.AsUChar |= PIIX_TIMING_DMA_TIMING_ENABLE(1);
                }
            }

            if (TransferModeSelect->FixedDisk[i]) {

                piixSpecialTiming.AsUChar |= PIIX_TIMING_PREFETCH_AND_POSTING_ENABLE(1);
            }
        }

        piixSpecialTiming.AsUChar |= PiixSpecialTiming[piixTimingMode].AsUChar;

        if (i == 0) {

            //
            // master device
            //
            piixTimingReg.b.IoReadySamplePoint = PiixIoReadySamplePointClockSetting[piixTimingMode];
            piixTimingReg.b.RecoveryTime = PiixRecoveryTimeClockSetting[piixTimingMode];

            piixTimingReg.b.n.Device0SpecialTiming = piixSpecialTiming.AsUChar & 0xf;

        } else {

            //
            // slave device
            //
            if (channel == 0) {

                piixSlaveTimingReg.b.Channel0IoReadySamplePoint = PiixIoReadySamplePointClockSetting[piixTimingMode];
                piixSlaveTimingReg.b.Channel0RecoveryTime = PiixRecoveryTimeClockSetting[piixTimingMode];

            } else {

                piixSlaveTimingReg.b.Channel1IoReadySamplePoint = PiixIoReadySamplePointClockSetting[piixTimingMode];
                piixSlaveTimingReg.b.Channel1RecoveryTime = PiixRecoveryTimeClockSetting[piixTimingMode];
            }

            piixTimingReg.b.n.Device1SpecialTiming = piixSpecialTiming.AsUChar & 0xf;
        }
    }

    if (!IS_PIIX(DeviceExtension->DeviceId)) {

        //
        // enable the timing setting for the slave
        //
        piixTimingReg.b.SlaveTimingEnable = 1;        

    } else {

        piixSlaveTimingReg.AsUChar = 0;
    }

    //
    // make sure the channel is enabled
    //
    piixTimingReg.b.ChannelEnable = 1;

    //
    // setup up udma
    //

    piix4UdmaControlReg.AsUChar = 0;
    piix4UdmaTimingReg.AsUChar = 0;
    ioConfigReg.AsUShort = 0;
    ioConfigReg.b.WriteBufferPingPongEnable = 1;

    for (i = 0; i < MAX_IDE_DEVICE; i++) {

        if (driveBestXferMode[i] & UDMA_SUPPORT) {

            UCHAR udmaTiming;

            if (driveBestXferMode[i] & UDMA_MODE5) {
            
                udmaTiming = ICH2_UDMA_MODE5_TIMING;
                   
            } else if (driveBestXferMode[i] & UDMA_MODE4) {
            
                udmaTiming = ICH_UDMA_MODE4_TIMING;
                   
            } else if (driveBestXferMode[i] & UDMA_MODE3) {
                                         
                udmaTiming = ICH_UDMA_MODE3_TIMING;
                                         
            } else if (driveBestXferMode[i] & UDMA_MODE2) {

                udmaTiming = PIIX4_UDMA_MODE2_TIMING;

            } else if (driveBestXferMode[i] & UDMA_MODE1) {

                udmaTiming = PIIX4_UDMA_MODE1_TIMING;

            } else if (driveBestXferMode[i] & UDMA_MODE0) {

                udmaTiming = PIIX4_UDMA_MODE0_TIMING;

            } else {

                ASSERT (!"intelide: Unknown UDMA MODE\n");

                //
                // we will use udma mode 5
                //
                udmaTiming = ICH2_UDMA_MODE5_TIMING;
            }

            if (i == 0) {

                if (channel == 0) {
    
                    //
                    // primary master
                    //                                                            
                    piix4UdmaControlReg.b.Channel0Drive0UdmaEnable = 1;

                    if (driveBestXferMode[i] & UDMA66_SUPPORT) {
                    
                        ioConfigReg.b.PrimaryMasterBaseClock = 1;
                    }

                    if (driveBestXferMode[i] & UDMA100_SUPPORT) {
                    
                        ioConfigReg.b.FastPrimaryMasterBaseClock = 1;
                    }

                } else {

                    //
                    // secondary master
                    //                                                            
                    piix4UdmaControlReg.b.Channel1Drive0UdmaEnable = 1;
                    
                    if (driveBestXferMode[i] & UDMA66_SUPPORT) {
                    
                        ioConfigReg.b.SecondaryMasterBaseClock = 1;
                    }

                    if (driveBestXferMode[i] & UDMA100_SUPPORT) {
                    
                        ioConfigReg.b.FastSecondaryMasterBaseClock = 1;
                    }
                }

                piix4UdmaTimingReg.b.Drive0CycleTime = udmaTiming;

            } else {

                ASSERT(i==1);

                if (channel == 0) {
    
                    //
                    // primary slave
                    //                                                    
                    piix4UdmaControlReg.b.Channel0Drive1UdmaEnable = 1;

                    if (driveBestXferMode[i] & UDMA66_SUPPORT) {
                    
                        ioConfigReg.b.PrimarySlaveBaseClock = 1;
                    }

                    if (driveBestXferMode[i] & UDMA100_SUPPORT) {
                    
                        ioConfigReg.b.FastPrimarySlaveBaseClock = 1;
                    }
                                               
                } else {

                    //
                    // secondary slave
                    //                                                    
                    piix4UdmaControlReg.b.Channel1Drive1UdmaEnable = 1;
                    
                    if (driveBestXferMode[i] & UDMA66_SUPPORT) {
                    
                        ioConfigReg.b.SecondarySlaveBaseClock = 1;
                    }
                    if (driveBestXferMode[i] & UDMA100_SUPPORT) {
                    
                        ioConfigReg.b.FastSecondarySlaveBaseClock = 1;
                    }
                }

                piix4UdmaTimingReg.b.Drive1CycleTime = udmaTiming;
            }

            //
            // if the drive support UDMA, use UDMA
            // turn off other DMA mode
            //
            driveBestXferMode[i] &= ~(MWDMA_SUPPORT | SWDMA_SUPPORT);
        }
    }

    //
    // setup the return data
    //
    for (i = 0; i < MAX_IDE_DEVICE; i++) {
        DriveBestXferMode[i] = driveBestXferMode[i];
    }

    *PiixTimingReg       = piixTimingReg;
    *PiixSlaveTimingReg  = piixSlaveTimingReg;
    *Piix4UdmaControlReg = piix4UdmaControlReg;
    *Piix4UdmaTimingReg  = piix4UdmaTimingReg;
    *IoConfigReg         = ioConfigReg;

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\inc\ideuser.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    ideuser.h

Abstract:

    These are the structures and defines that are used in the
    PCI IDE mini drivers.

Revision History:

--*/

#if !defined (___ideuser_h___)
#define ___ideuser_h___

//@@BEGIN_DDKSPLIT
 
typedef enum  {
    DeviceUnknown = 0,
    DeviceIsAta,
    DeviceIsAtapi,
    DeviceNotExist
} IDE_DEVICETYPE;

typedef enum  {
    DdlPioOnly = 0,
    DdlFirmwareOk,
    DdlAlways
} DMADETECTIONLEVEL;

#define DMA_DETECTION_LEVEL_REG_KEY L"DmaDetectionLevel"

#define PCMCIA_IDE_CONTROLLER_HAS_SLAVE L"PcmciaIdeHasSlaveDevice"

#define MASTER_DEVICE_TIMEOUT    L"MasterDeviceDetectionTimeout"
#define SLAVE_DEVICE_TIMEOUT     L"SlaveDeviceDetectionTimeout"

#define MASTER_DEVICE_TYPE_REG_KEY    L"MasterDeviceType"
#define SLAVE_DEVICE_TYPE_REG_KEY     L"SlaveDeviceType"
#define MASTER_DEVICE_TYPE2_REG_KEY   L"MasterDeviceType2"
#define SLAVE_DEVICE_TYPE2_REG_KEY    L"SlaveDeviceType2"

#define USER_MASTER_DEVICE_TYPE_REG_KEY    L"UserMasterDeviceType"
#define USER_SLAVE_DEVICE_TYPE_REG_KEY     L"UserSlaveDeviceType"
#define USER_MASTER_DEVICE_TYPE2_REG_KEY   L"UserMasterDeviceType2"
#define USER_SLAVE_DEVICE_TYPE2_REG_KEY    L"UserSlaveDeviceType2"

#define MASTER_DEVICE_TIMING_MODE    L"MasterDeviceTimingMode"
#define SLAVE_DEVICE_TIMING_MODE     L"SlaveDeviceTimingMode"
#define MASTER_DEVICE_TIMING_MODE2   L"MasterDeviceTimingMode2"
#define SLAVE_DEVICE_TIMING_MODE2    L"SlaveDeviceTimingMode2"

#define MASTER_DEVICE_TIMING_MODE_ALLOWED    L"MasterDeviceTimingModeAllowed"
#define SLAVE_DEVICE_TIMING_MODE_ALLOWED     L"SlaveDeviceTimingModeAllowed"
#define MASTER_DEVICE_TIMING_MODE_ALLOWED2   L"MasterDeviceTimingModeAllowed2"
#define SLAVE_DEVICE_TIMING_MODE_ALLOWED2    L"SlaveDeviceTimingModeAllowed2"

#define USER_MASTER_DEVICE_TIMING_MODE_ALLOWED    L"UserMasterDeviceTimingModeAllowed"
#define USER_SLAVE_DEVICE_TIMING_MODE_ALLOWED     L"UserSlaveDeviceTimingModeAllowed"
#define USER_MASTER_DEVICE_TIMING_MODE_ALLOWED2   L"UserMasterDeviceTimingModeAllowed2"
#define USER_SLAVE_DEVICE_TIMING_MODE_ALLOWED2    L"UserSlaveDeviceTimingModeAllowed2"

#define MASTER_IDDATA_CHECKSUM      L"MasterIdDataCheckSum"
#define SLAVE_IDDATA_CHECKSUM       L"SlaveIdDataCheckSum"
#define MASTER_IDDATA_CHECKSUM2     L"MasterIdDataCheckSum2"
#define SLAVE_IDDATA_CHECKSUM2      L"SlaveIdDataCheckSum2" 
 
//@@END_DDKSPLIT
  
#define PIO_MODE0           (1 << 0)
#define PIO_MODE1           (1 << 1)
#define PIO_MODE2           (1 << 2)
#define PIO_MODE3           (1 << 3)
#define PIO_MODE4           (1 << 4)

#define SWDMA_MODE0         (1 << 5)
#define SWDMA_MODE1         (1 << 6)
#define SWDMA_MODE2         (1 << 7)

#define MWDMA_MODE0         (1 << 8)
#define MWDMA_MODE1         (1 << 9)
#define MWDMA_MODE2         (1 << 10)

#define UDMA_MODE0          (1 << 11)
#define UDMA_MODE1          (1 << 12)
#define UDMA_MODE2          (1 << 13)
#define UDMA_MODE3          (1 << 14)
#define UDMA_MODE4          (1 << 15)
#define UDMA_MODE5          (1 << 16)

#define PIO_SUPPORT         (PIO_MODE0      | PIO_MODE1     | PIO_MODE2    | PIO_MODE3     | PIO_MODE4)
#define SWDMA_SUPPORT       (SWDMA_MODE0    | SWDMA_MODE1   | SWDMA_MODE2)
#define MWDMA_SUPPORT       (MWDMA_MODE0    | MWDMA_MODE1   | MWDMA_MODE2)
#define UDMA33_SUPPORT      (UDMA_MODE0     | UDMA_MODE1    | UDMA_MODE2)
#define UDMA66_SUPPORT      (UDMA_MODE3     | UDMA_MODE4)
#define UDMA100_SUPPORT     (UDMA_MODE5 )
#define UDMA_SUPPORT        (UNINITIALIZED_TRANSFER_MODE & (~(PIO_SUPPORT | SWDMA_SUPPORT | MWDMA_SUPPORT)))

#define DMA_SUPPORT         (SWDMA_SUPPORT  | MWDMA_SUPPORT | UDMA_SUPPORT)
#define ALL_MODE_SUPPORT    (PIO_SUPPORT | DMA_SUPPORT)

#define PIO0                        0
#define PIO1                        1
#define PIO2                        2
#define PIO3                        3
#define PIO4                        4
#define SWDMA0                      5
#define SWDMA1                      6
#define SWDMA2                      7
#define MWDMA0                      8
#define MWDMA1                      9
#define MWDMA2                      10
#define UDMA0                       11

#define MAX_XFER_MODE               18
#define UNINITIALIZED_CYCLE_TIME    0xffffffff
#define UNINITIALIZED_TRANSFER_MODE 0x7fffffff
#define IS_DEFAULT(mode)    (!(mode & 0x80000000))

#define GenTransferModeMask(i, mode) {\
    ULONG temp=0xffffffff; \
    mode |= (temp >> (31-(i)));\
}

//
// mode should not be 0
//
#define GetHighestTransferMode(mode, i) {\
    ULONG temp=(mode); \
    ASSERT(temp); \
    i=0; \
    while ( temp) { \
        temp = (temp >> 1);\
        i++;\
    } \
    i--; \
}

#define GetHighestDMATransferMode(mode, i) {\
    ULONG temp=mode >> 5;\
    i=5; \
    while ( temp) { \
        temp = (temp >> 1); \
        i++; \
    } \
    i--; \
}
#define GetHighestPIOTransferMode(mode, i) { \
    ULONG temp = (mode & PIO_SUPPORT); \
    i=0; \
    temp = temp >> 1; \
    while (temp) { \
        temp = temp >> 1; \
        i++; \
    } \
}

#define SetDefaultTiming(timingTable, length) {\
    timingTable[0]=PIO_MODE0_CYCLE_TIME; \
    timingTable[1]=PIO_MODE1_CYCLE_TIME; \
    timingTable[2]=PIO_MODE2_CYCLE_TIME; \
    timingTable[3]=PIO_MODE3_CYCLE_TIME; \
    timingTable[4]=PIO_MODE4_CYCLE_TIME; \
    timingTable[5]=SWDMA_MODE0_CYCLE_TIME; \
    timingTable[6]=SWDMA_MODE1_CYCLE_TIME; \
    timingTable[7]=SWDMA_MODE2_CYCLE_TIME; \
    timingTable[8]=MWDMA_MODE0_CYCLE_TIME; \
    timingTable[9]=MWDMA_MODE1_CYCLE_TIME; \
    timingTable[10]=MWDMA_MODE2_CYCLE_TIME; \
    timingTable[11]=UDMA_MODE0_CYCLE_TIME; \
    timingTable[12]=UDMA_MODE1_CYCLE_TIME; \
    timingTable[13]=UDMA_MODE2_CYCLE_TIME; \
    timingTable[14]=UDMA_MODE3_CYCLE_TIME; \
    timingTable[15]=UDMA_MODE4_CYCLE_TIME; \
    timingTable[16]=UDMA_MODE5_CYCLE_TIME; \
    timingTable[17]=UDMA_MODE6_CYCLE_TIME; \
    length = MAX_XFER_MODE; \
}

#endif // ___ideuser_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\miniport\pciide\init.c ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    init.c

Abstract:

    Generic PCI IDE mini driver

Revision History:

--*/

#include "pciide.h"

//
// Driver Entry Point
//                               
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    //
    // call system pci ide driver (pciidex)
    // for initializeation
    //
    return PciIdeXInitialize (
        DriverObject,
        RegistryPath,
        GenericIdeGetControllerProperties,
        sizeof (DEVICE_EXTENSION)
        );
}


//
// Called on every I/O. Returns 1 if DMA is allowed.
// Returns 0 if DMA is not allowed.
//
ULONG
GenericIdeUseDma(
    IN PVOID DeviceExtension,
    IN PVOID cdbcmd,
    IN UCHAR slave)
/**++
 * Arguments : DeviceExtension
               Cdb
               Slave =1, if slave
                     =0, if master
--**/
{
    PDEVICE_EXTENSION deviceExtension = DeviceExtension;
    PUCHAR cdb= cdbcmd;

    return 1;
}

//
// Query controller properties
//                     
NTSTATUS 
GenericIdeGetControllerProperties (
    IN PVOID                      DeviceExtension,
    IN PIDE_CONTROLLER_PROPERTIES ControllerProperties
    )
{
    PDEVICE_EXTENSION deviceExtension = DeviceExtension;
    NTSTATUS    status;
    ULONG       i;
    ULONG       j;
    ULONG       xferMode;

    //
    // make sure we are in sync
    //                              
    if (ControllerProperties->Size != sizeof (IDE_CONTROLLER_PROPERTIES)) {

        return STATUS_REVISION_MISMATCH;
    }

    //
    // see what kind of PCI IDE controller we have
    //                               
    status = PciIdeXGetBusData (
                 deviceExtension,
                 &deviceExtension->pciConfigData, 
                 0,
                 sizeof (PCIIDE_CONFIG_HEADER)
                 );

    if (!NT_SUCCESS(status)) {

        return status;
    }

    //
    // assume we support all DMA mode if PCI master bit is set
    //                            
    xferMode = PIO_SUPPORT;
    if ((deviceExtension->pciConfigData.MasterIde) &&
        (deviceExtension->pciConfigData.Command.b.MasterEnable)) {

        xferMode |= SWDMA_SUPPORT | MWDMA_SUPPORT | UDMA_SUPPORT;
    }

// @@BEGIN_DDKSPLIT                    

    //
    // Run PIO by default for the Sis Chipset
    //
    if ((deviceExtension->pciConfigData.VendorID == 0x1039) &&
        (deviceExtension->pciConfigData.DeviceID == 0x5513)) {
        ControllerProperties->DefaultPIO  = 1;
    }

    //
    // Run PIO by default for the Rcc Chipset
    //
    if ((deviceExtension->pciConfigData.VendorID == 0x1166) &&
        (deviceExtension->pciConfigData.DeviceID == 0x0211)) {
        ControllerProperties->DefaultPIO  = 1;
    }


    //
    // continuous status register polling causes some ALI
    // controller to corrupt data if the controller internal
    // FIFO is enabled
    //
    // to play safe, we will always disable the FIFO
    // see the ALi IDE controller programming spec for details
    //
    if ((deviceExtension->pciConfigData.VendorID == 0x10b9) && 
        (deviceExtension->pciConfigData.DeviceID == 0x5229)) {

        USHORT pciData;
        USHORT pciDataMask;

        pciData = 0;
        pciDataMask = 0xcccc;
        status = PciIdeXSetBusData(
                    DeviceExtension,
                    &pciData, 
                    &pciDataMask,
                    0x54,
                    0x2);
        if (!NT_SUCCESS(status)) {
    
            return status;
        }
    }

    //
    // ALi IDE controllers have lots of busmaster problems
    // some versions of them can't do busmaster with ATAPI devices
    // and some other versions of them return bogus busmaster status values
    // (the busmaster active bit doesn't get cleared when it should be
    // during an end of busmaster interrupt)
    //
    if ((deviceExtension->pciConfigData.VendorID == 0x10b9) && 
        (deviceExtension->pciConfigData.DeviceID == 0x5229) && 
        ((deviceExtension->pciConfigData.RevisionID == 0x20) || 
         (deviceExtension->pciConfigData.RevisionID == 0xc1))) {
        
        PciIdeXDebugPrint ((0, "pciide: overcome the sticky BM active bit problem in ALi controller\n"));

        ControllerProperties->IgnoreActiveBitForAtaDevice = TRUE;
    }
    
    if ((deviceExtension->pciConfigData.VendorID == 0x0e11) && 
        (deviceExtension->pciConfigData.DeviceID == 0xae33) && 
        (deviceExtension->pciConfigData.Chan0OpMode || 
         deviceExtension->pciConfigData.Chan1OpMode)) {
        
        PciIdeXDebugPrint ((0, "pciide: overcome the bogus busmaster interrupt in CPQ controller\n"));

        ControllerProperties->AlwaysClearBusMasterInterrupt = TRUE;
    }

// @@END_DDKSPLIT                    
    
    //
    // fill in the controller properties
    //            
    for (i=0; i< MAX_IDE_CHANNEL; i++) {

        for (j=0; j< MAX_IDE_DEVICE; j++) {

            ControllerProperties->SupportedTransferMode[i][j] =
                deviceExtension->SupportedTransferMode[i][j] = xferMode;
        }
    }

    ControllerProperties->PciIdeChannelEnabled     = GenericIdeChannelEnabled;
    ControllerProperties->PciIdeSyncAccessRequired = GenericIdeSyncAccessRequired;
    ControllerProperties->PciIdeTransferModeSelect = NULL;
    ControllerProperties->PciIdeUdmaModesSupported = GenericIdeUdmaModesSupported;
    ControllerProperties->PciIdeUseDma = GenericIdeUseDma;
    ControllerProperties->AlignmentRequirement=1;

    return STATUS_SUCCESS;
}

IDE_CHANNEL_STATE
GenericIdeChannelEnabled (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN ULONG Channel
    )
{
// @@BEGIN_DDKSPLIT                    
    NTSTATUS    status;
    PCI_COMMON_CONFIG pciHeader;
    ULONG pciDataByte;
    UCHAR maskByte = 0;

    status = PciIdeXGetBusData (
                 DeviceExtension,
                 &pciHeader, 
                 0,
                 sizeof (pciHeader)
                 );

    if (NT_SUCCESS(status)) {

        if ((pciHeader.VendorID == 0x0e11) && 
            (pciHeader.DeviceID == 0xae33)) {

            //
            // Compaq
            //
            status = PciIdeXGetBusData (
                         DeviceExtension,
                         &pciDataByte, 
                         0x80,
                         sizeof (pciDataByte)
                         );
    
            if (NT_SUCCESS(status)) {
    
                if (pciDataByte & (1 << Channel)) {
    
                    return ChannelEnabled;
                } else {
    
                    return ChannelDisabled;
                }
            }

        } else if ((pciHeader.VendorID == 0x1095) && 
                   ((pciHeader.DeviceID == 0x0646) || (pciHeader.DeviceID == 0x0643))) {

            //
            // CMD
            //
            status = PciIdeXGetBusData (
                         DeviceExtension,
                         &pciDataByte, 
                         0x51,
                         sizeof (pciDataByte)
                         );

            if (NT_SUCCESS(status)) {

                if (pciHeader.RevisionID < 0x3) {
    
                    //
                    // early revision doesn't have a
                    // bit to enable/disable primary
                    // channel since it is always enabled
                    
                    // newer version does have a bit defined 
                    // for this purpose.  to make the check 
                    // easier later.  we will set primary enable bit
                    // for the early revision
                    pciDataByte |= 0x4;
                }

                if (Channel == 0) {

                    maskByte = 0x4;

                } else {

                    maskByte = 0x8;
                }

                if (pciDataByte & maskByte) {
                    return ChannelEnabled;
                } else {
                    return ChannelDisabled;
                }
            }
        } else if ((pciHeader.VendorID == 0x1039) && 
                   (pciHeader.DeviceID == 0x5513)) {

            //
            // SiS
            //
            status = PciIdeXGetBusData (
                         DeviceExtension,
                         &pciDataByte, 
                         0x4a,
                         sizeof (pciDataByte)
                         );
            if (Channel == 0) {
                maskByte = 0x2;
            } else {
                maskByte = 0x4;
            }

            if (pciDataByte & maskByte) {
                return ChannelEnabled;
            } else {
                return ChannelDisabled;
            }
        } else if ((pciHeader.VendorID == 0x110A) &&
               (pciHeader.DeviceID == 0x0002)) {
            //
            // Siemens
            //
            ULONG configOffset = (Channel == 0)?0x41:0x49;

            status = PciIdeXGetBusData (
                      DeviceExtension,
                      &pciDataByte, 
                      configOffset,
                      sizeof (pciDataByte)
                      );
            if (NT_SUCCESS(status)) {

                maskByte = 0x08;

                if (pciDataByte & maskByte) {

                  return ChannelEnabled;

                } else {

                  return ChannelDisabled;

                }
            }
		} else if ((pciHeader.VendorID == 0x1106) &&
			(pciHeader.DeviceID == 0x0571)) {
            //
            // VIA
            //
            status = PciIdeXGetBusData (
                      DeviceExtension,
                      &pciDataByte, 
                      0x40,
                      sizeof (pciDataByte)
                      );
            if (NT_SUCCESS(status)) {

                maskByte = (Channel == 0)? 0x02:0x01;

                if (pciDataByte & maskByte) {

                  return ChannelEnabled;

                } else {

                  return ChannelDisabled;

                }
            }
		}
    }
// @@END_DDKSPLIT                    
    //
    // Can't tell if a channel is enabled or not.  
    //
    return ChannelStateUnknown;
}


// @@BEGIN_DDKSPLIT                    
VENDOR_ID_DEVICE_ID SingleFifoController[] = {
    {0x1095, 0x0640},         // CMD  640
    {0x1039, 0x0601}          // SiS ????
};
#define NUMBER_OF_SINGLE_FIFO_CONTROLLER (sizeof(SingleFifoController) / sizeof(VENDOR_ID_DEVICE_ID))
// @@END_DDKSPLIT                    

BOOLEAN 
GenericIdeSyncAccessRequired (
    IN PDEVICE_EXTENSION DeviceExtension
    )
{
    ULONG i;

// @@BEGIN_DDKSPLIT                    
    for (i=0; i<NUMBER_OF_SINGLE_FIFO_CONTROLLER; i++) {

        if ((DeviceExtension->pciConfigData.VendorID == SingleFifoController[i].VendorId) &&
            (DeviceExtension->pciConfigData.DeviceID == SingleFifoController[i].DeviceId)) {

            return TRUE;
        }
    }
// @@END_DDKSPLIT                    
    return FALSE;
}


NTSTATUS
GenericIdeUdmaModesSupported (
    IN IDENTIFY_DATA    IdentifyData,
    IN OUT PULONG       BestXferMode,
    IN OUT PULONG       CurrentMode
    )
{
    ULONG bestXferMode =0;
    ULONG currentMode = 0;

    if (IdentifyData.TranslationFieldsValid & (1 << 2)) {

        if (IdentifyData.UltraDMASupport) {

            GetHighestTransferMode( IdentifyData.UltraDMASupport,
                                       bestXferMode);
            *BestXferMode = bestXferMode;
        }

        if (IdentifyData.UltraDMAActive) {

            GetHighestTransferMode( IdentifyData.UltraDMAActive,
                                       currentMode);
            *CurrentMode = currentMode;
        }
    }

    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\miniport\pciide\pciide.h ===
/*++

Copyright (C) Microsoft Corporation, 1999 - 1999

Module Name:

    init.c

Abstract:

    Generic PCI IDE mini driver

Revision History:

--*/
#if !defined (___pciide_h___)
#define ___pciide_h___

#include "ntddk.h"
#include "ntdddisk.h"
#include "ide.h"
      

//
// mini driver device extension
//
typedef struct _DEVICE_EXTENSION {

    //
    // pci config data cache
    //                               
    PCIIDE_CONFIG_HEADER pciConfigData;

    //
    // supported data transfer mode
    //                            
    ULONG SupportedTransferMode[MAX_IDE_CHANNEL][MAX_IDE_DEVICE];

    IDENTIFY_DATA IdentifyData[MAX_IDE_DEVICE];

} DEVICE_EXTENSION, *PDEVICE_EXTENSION;


#pragma pack(1)
typedef struct _VENDOR_ID_DEVICE_ID {

    USHORT  VendorId;
    USHORT  DeviceId;

} VENDOR_ID_DEVICE_ID, *PVENDOR_ID_DEVICE_ID;
#pragma pack()

//
// mini driver entry point
//
NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    );

//
// callback to query controller properties
//                          
NTSTATUS 
GenericIdeGetControllerProperties (
    IN PVOID                      DeviceExtension,
    IN PIDE_CONTROLLER_PROPERTIES ControllerProperties
    );

//
// to query whether a IDE channel is enabled
//                                          
IDE_CHANNEL_STATE 
GenericIdeChannelEnabled (
    IN PDEVICE_EXTENSION DeviceExtension,
    IN ULONG Channel
    );
             
//
// to query whether both IDE channels requires
// synchronized access
//                                          
BOOLEAN 
GenericIdeSyncAccessRequired (
    IN PDEVICE_EXTENSION DeviceExtension
    );

//
// to query the supported UDMA modes. This routine
// can be used to support newer UDMA modes
//
NTSTATUS
GenericIdeUdmaModesSupported (
    IN IDENTIFY_DATA    IdentifyData,
    IN OUT PULONG       BestXferMode,
    IN OUT PULONG       CurrentMode
    );
#endif // ___pciide_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\pciidex\bm.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bm.c
//
//--------------------------------------------------------------------------

#include "pciidex.h"

NTSTATUS
BmSetupOnePage (
    IN  PVOID   PdoExtension,
    IN  PVOID   DataVirtualPageAddress,
    IN  ULONG   TransferByteCount,
    IN  PMDL    Mdl,
    IN  BOOLEAN DataIn,
    IN  PVOID   RegionDescriptorTablePage
    );

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, BusMasterInitialize)
#pragma alloc_text(PAGE, BmQueryInterface)

#pragma alloc_text(NONPAGE, BmSetup)
#pragma alloc_text(NONPAGE, BmReceiveScatterGatherList)
#pragma alloc_text(NONPAGE, BmRebuildScatterGatherList)
#pragma alloc_text(NONPAGE, BmPrepareController)
#pragma alloc_text(NONPAGE, BmSetupOnePage)
#pragma alloc_text(NONPAGE, BmArm)
#pragma alloc_text(NONPAGE, BmDisarm)
#pragma alloc_text(NONPAGE, BmFlush)
#pragma alloc_text(NONPAGE, BmStatus)
#pragma alloc_text(NONPAGE, BmTimingSetup)
#endif // ALLOC_PRAGMA


NTSTATUS 
BusMasterInitialize (
    PCHANPDO_EXTENSION PdoExtension
    )
{
    NTSTATUS status;
    ULONG    numberOfMapRegisters;
    ULONG    scatterListSize;
    BOOLEAN  noBmRegister;

    PAGED_CODE();

    if (PdoExtension->ParentDeviceExtension->TranslatedBusMasterBaseAddress == NULL) {

        status = STATUS_INSUFFICIENT_RESOURCES;
        noBmRegister = TRUE;

    } else {

        if (PdoExtension->ChannelNumber == 0) {

            PdoExtension->BmRegister = 
                PdoExtension->ParentDeviceExtension->TranslatedBusMasterBaseAddress;

        } else if (PdoExtension->ChannelNumber == 1) {

            PdoExtension->BmRegister = 
                (PIDE_BUS_MASTER_REGISTERS)
                (((PUCHAR) PdoExtension->ParentDeviceExtension->TranslatedBusMasterBaseAddress) + 8);
        } else {

            ASSERT (FALSE);
        }

        if (READ_PORT_UCHAR (&PdoExtension->BmRegister->Status) & BUSMASTER_ZERO_BITS) {

            ULONG ignoreZeroBits = 0;
            status = PciIdeXGetDeviceParameter (
                       PdoExtension->ParentDeviceExtension->AttacheePdo,
                       L"IgnoreBusMasterStatusZeroBits",
                       (PULONG)&ignoreZeroBits
                       );

            if (!ignoreZeroBits) {
                //
                // The must-be-zero bits are not zero
                //
                DebugPrint ((0, "BusMasterInitialize: bad busmaster status register value (0x%x).  will never do busmastering ide\n"));
                PdoExtension->BmRegister = NULL;
                status = STATUS_INSUFFICIENT_RESOURCES;
                noBmRegister = TRUE;
            }

        } else {

            status = STATUS_SUCCESS;
            noBmRegister = FALSE;
        }
    }

    //
    // Allocate Adapter Object
    //
    if (status == STATUS_SUCCESS) {

        DEVICE_DESCRIPTION deviceDescription;

        RtlZeroMemory(&deviceDescription, sizeof(deviceDescription));

        deviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
        deviceDescription.Master = TRUE;
        deviceDescription.ScatterGather = TRUE;
        deviceDescription.DemandMode = FALSE;
        deviceDescription.AutoInitialize = FALSE;
        deviceDescription.Dma32BitAddresses = TRUE;
        deviceDescription.IgnoreCount = FALSE;
        deviceDescription.BusNumber = PdoExtension->ParentDeviceExtension->BmResourceList->List[0].BusNumber,
        deviceDescription.InterfaceType = PCIBus;


        //
        //  make sure MAX_TRANSFER_SIZE_PER_SRB is never larger than what
        //  the ide bus master controller can handle
        //
        ASSERT (MAX_TRANSFER_SIZE_PER_SRB <= (PAGE_SIZE * (PAGE_SIZE / sizeof(PHYSICAL_REGION_DESCRIPTOR))));
        deviceDescription.MaximumLength = MAX_TRANSFER_SIZE_PER_SRB;

        PdoExtension->DmaAdapterObject = IoGetDmaAdapter(
                                             PdoExtension->ParentDeviceExtension->AttacheePdo,
                                             &deviceDescription,
                                             &numberOfMapRegisters
                                             );

        ASSERT(PdoExtension->DmaAdapterObject);

        PdoExtension->MaximumPhysicalPages = numberOfMapRegisters;

        if (!PdoExtension->DmaAdapterObject) {

            status = STATUS_INSUFFICIENT_RESOURCES;
        }
    }

    if (status == STATUS_SUCCESS) {

        scatterListSize = PdoExtension->MaximumPhysicalPages * 
                              sizeof (PHYSICAL_REGION_DESCRIPTOR);

        PdoExtension->RegionDescriptorTable = 
            PdoExtension->DmaAdapterObject->DmaOperations->AllocateCommonBuffer(
                PdoExtension->DmaAdapterObject,
                scatterListSize,
                &PdoExtension->PhysicalRegionDescriptorTable,
                FALSE
                );

        ASSERT (PdoExtension->RegionDescriptorTable);
        ASSERT (PdoExtension->PhysicalRegionDescriptorTable.QuadPart);

        if (PdoExtension->RegionDescriptorTable) {

            RtlZeroMemory (
                PdoExtension->RegionDescriptorTable, 
                scatterListSize
                );

        } else {

            status = STATUS_INSUFFICIENT_RESOURCES;

        }
    }

    if (status != STATUS_SUCCESS) {

        //
        // free resources
        //
        if (PdoExtension->RegionDescriptorTable) {

                PdoExtension->DmaAdapterObject->DmaOperations->FreeCommonBuffer(
                    PdoExtension->DmaAdapterObject,
                    scatterListSize,
                    PdoExtension->PhysicalRegionDescriptorTable,
                    PdoExtension->RegionDescriptorTable,
                    FALSE
                    );
            PdoExtension->PhysicalRegionDescriptorTable.QuadPart = 0;
            PdoExtension->RegionDescriptorTable                  = NULL;
        }

        if (PdoExtension->DmaAdapterObject) {
            KIRQL currentIrql;

            KeRaiseIrql(DISPATCH_LEVEL, &currentIrql);
            PdoExtension->DmaAdapterObject->DmaOperations->PutDmaAdapter (
                PdoExtension->DmaAdapterObject
                );
            KeLowerIrql(currentIrql);

            PdoExtension->DmaAdapterObject = NULL;
        }
    }

    //
    // init. is still ok if we just not a bm controller
    //
    if (noBmRegister) {

        status = STATUS_SUCCESS;
    }

    return status;
} // BusMasterInitialize

NTSTATUS 
BusMasterUninitialize (
    PCHANPDO_EXTENSION PdoExtension
    )
{
    ULONG scatterListSize;
    KIRQL currentIrql;
    ASSERT (PdoExtension->BmState == BmIdle);

    if (PdoExtension->DmaAdapterObject) {

        scatterListSize = PdoExtension->MaximumPhysicalPages * 
                              sizeof (PHYSICAL_REGION_DESCRIPTOR);
    
        if (PdoExtension->PhysicalRegionDescriptorTable.QuadPart) {

            PdoExtension->DmaAdapterObject->DmaOperations->FreeCommonBuffer( 
                PdoExtension->DmaAdapterObject,
                scatterListSize,
                PdoExtension->PhysicalRegionDescriptorTable,
                PdoExtension->RegionDescriptorTable,
                FALSE
                );
            PdoExtension->RegionDescriptorTable = NULL;
            PdoExtension->PhysicalRegionDescriptorTable.QuadPart = 0;
        }
        

        KeRaiseIrql(DISPATCH_LEVEL, &currentIrql);
        PdoExtension->DmaAdapterObject->DmaOperations->PutDmaAdapter (
            PdoExtension->DmaAdapterObject
            );
        KeLowerIrql(currentIrql);

        PdoExtension->DmaAdapterObject = NULL;
    }

    return STATUS_SUCCESS;
}

NTSTATUS
BmSetup (
    IN  PVOID   PdoExtension,
    IN  PVOID   DataVirtualAddress,
    IN  ULONG   TransferByteCount,
    IN  PMDL    Mdl,
    IN  BOOLEAN DataIn,
    IN  VOID    (* BmCallback) (PVOID Context),
    IN  PVOID   CallbackContext
    )
{
    PCHANPDO_EXTENSION pdoExtension = PdoExtension;
    NTSTATUS status;
    PIDE_BUS_MASTER_REGISTERS bmRegister;

    ASSERT (pdoExtension->BmState == BmIdle);

    bmRegister = pdoExtension->BmRegister;

    pdoExtension->DataVirtualAddress = DataVirtualAddress;
    pdoExtension->TransferLength     = TransferByteCount;
    pdoExtension->Mdl                = Mdl;
    pdoExtension->DataIn             = DataIn;
    pdoExtension->BmCallback         = BmCallback;
    pdoExtension->BmCallbackContext  = CallbackContext;

    status = (*pdoExtension->DmaAdapterObject->DmaOperations->GetScatterGatherList)(
        pdoExtension->DmaAdapterObject,
        pdoExtension->DeviceObject,
        pdoExtension->Mdl,
        pdoExtension->DataVirtualAddress,
        pdoExtension->TransferLength,
        BmReceiveScatterGatherList,
        pdoExtension,
        (BOOLEAN) !pdoExtension->DataIn
        );

    return status;
} // BmSetup

VOID
BmReceiveScatterGatherList(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PVOID Context
    )
{
    PCHANPDO_EXTENSION pdoExtension = Context;
    ASSERT (pdoExtension);

    BmRebuildScatterGatherList (pdoExtension, ScatterGather);

    BmPrepareController (pdoExtension);

    //
    // Call the FDO back
    //
    pdoExtension->BmCallback (pdoExtension->BmCallbackContext);

    return;
} // BmReceiveScatterGatherList


VOID
BmRebuildScatterGatherList(
    IN PCHANPDO_EXTENSION PdoExtension,
    IN PSCATTER_GATHER_LIST ScatterGather
    )
{
    ULONG   bytesToMap;
    ULONG   i, j;

    ASSERT (ScatterGather);
    ASSERT (PdoExtension);
    ASSERT (PdoExtension->TransferLength);
    ASSERT (PdoExtension->Mdl);

    DebugPrint ((3, "PciIdeX: BmReceiveScatterGatherList() DataBuffer 0x%x, length 0x%x\n", PdoExtension->DataVirtualAddress, PdoExtension->TransferLength));

    //
    // save the original list
    //
    PdoExtension->HalScatterGatherList = ScatterGather;

    for (i=j=0; j<ScatterGather->NumberOfElements; j++) {

        ULONG   physicalAddress;
        PSCATTER_GATHER_ELEMENT sgElements;

        sgElements = ScatterGather->Elements + j;

        //
        // get the next block physical address
        //
        physicalAddress = sgElements->Address.LowPart;
        ASSERT (!(physicalAddress & 0x1));
        ASSERT (!sgElements->Address.HighPart);

        //
        // get the next block byte size
        //
        bytesToMap = sgElements->Length;

        while (bytesToMap) {

            ULONG   bytesLeftInCurrent64KPage;

            ASSERT (i < PdoExtension->MaximumPhysicalPages);

            PdoExtension->RegionDescriptorTable[i].PhysicalAddress = physicalAddress;
            bytesLeftInCurrent64KPage = 0x10000 - (physicalAddress & 0xffff);
    
            if (bytesLeftInCurrent64KPage < bytesToMap) {
    
                PdoExtension->RegionDescriptorTable[i].ByteCount = bytesLeftInCurrent64KPage;

                physicalAddress += bytesLeftInCurrent64KPage;
                bytesToMap -= bytesLeftInCurrent64KPage;
    
            } else if (bytesToMap <= 0x10000) {
                //
                // got a perfect page, map all of it
                //
                PdoExtension->RegionDescriptorTable[i].ByteCount = bytesToMap & 0xfffe;
                physicalAddress += bytesToMap & 0xfffe;
                bytesToMap = 0;

            } else {
                //
                // got a perfectly aligned 64k page, map all of it but the count
                // need to be 0
                //
                PdoExtension->RegionDescriptorTable[i].ByteCount = 0;  // 64K
                physicalAddress += 0x10000;
                bytesToMap -= 0x10000;
            }

            PdoExtension->RegionDescriptorTable[i].EndOfTable = 0;
            i++;
        }
    }

    //
    // the bus master circutry need to know it hits the end of the PRDT
    //
    PdoExtension->RegionDescriptorTable[i - 1].EndOfTable = 1;  // end of table

    return;
} // BmReceiveScatterGatherList

VOID
BmPrepareController (
    PCHANPDO_EXTENSION PdoExtension
    )
{
    PCHANPDO_EXTENSION pdoExtension = PdoExtension;
    PIDE_BUS_MASTER_REGISTERS bmRegister;

    KeFlushIoBuffers(pdoExtension->Mdl,
                     (BOOLEAN) (pdoExtension->DataIn),
                     TRUE);

    bmRegister = pdoExtension->BmRegister;

    //
    // Init bus master contoller, but keep it disabled
    //

    //
    // Disable Controller
    //
    WRITE_PORT_UCHAR (
        &bmRegister->Command, 
        0
        );

    //
    // Clear Errors
    //
    WRITE_PORT_UCHAR (
        &bmRegister->Status, 
        BUSMASTER_INTERRUPT | BUSMASTER_ERROR
        );

    //
    // Init. Scatter Gather List Register
    //
    WRITE_PORT_ULONG (
        &bmRegister->DescriptionTable, 
        PdoExtension->PhysicalRegionDescriptorTable.LowPart
        );

    pdoExtension->BmState = BmSet;

    return;
} // BmPrepareController



NTSTATUS
BmSetupOnePage (
    IN  PVOID   PdoExtension,
    IN  PVOID   DataVirtualPageAddress,
    IN  ULONG   TransferByteCount,
    IN  PMDL    Mdl,
    IN  BOOLEAN DataIn,
    IN  PVOID   RegionDescriptorTablePage
    )
/*++

Routine Description:

    Does the same thing as BmSetup except that it sets up DMA controller
    for one page only and therefore it simple and straightforward and
    does not use any of kernel services unlike BmSetup.

Arguments:
    
    PdoExtension          - context pointer
    DataVirtualPageAddress- address of IO page
    TransferByteCount     - size of IO (IO region shall not cross page boundary)
    Mdl                   - MDL descriptor containing DataVirtualAddress
    DataIn                - TRUE if input, FALSE if output
    RegionDescriptorTable - memory to store 1 entry of RegionDescriptor (shall be page-aligned)

Attention! Obviousely, it's caller responsibility to retain the values addressed
by DataMemoryAddress and RegionDescriptor table until completion of DMA transfer

Return Value:

    STATUS_SUCCESS if all conditions listed above were met,
    STATUS_UNSUCCESSFUL otherwise

Environment:

    Kernel mode.  Currently used by only by ATAPI during hibernation.


--*/
{
    PCHANPDO_EXTENSION pdoExtension = PdoExtension;
    PPHYSICAL_REGION_DESCRIPTOR RegionDescriptorTable = RegionDescriptorTablePage;
    PHYSICAL_ADDRESS OldPhysicalRegionDescriptorTable;
    PPHYSICAL_REGION_DESCRIPTOR OldRegionDescriptorTable;
    PHYSICAL_ADDRESS DataPhysicalPageAddress;
    ULONG Size;

    //
    // Check alignment of addresses and transfer size
    //
    Size = PAGE_SIZE - ((ULONG) (((ULONG_PTR) DataVirtualPageAddress) & (PAGE_SIZE-1)));
    if (
      TransferByteCount == 0 ||
      TransferByteCount > Size ||
      ((ULONG) ((ULONG_PTR)DataVirtualPageAddress | TransferByteCount) & 3) != 0 ||
      ((ULONG) (((ULONG_PTR)RegionDescriptorTablePage) & (PAGE_SIZE-1)))
    )
    {
      // Necessary requirements was not met, failure
      return (STATUS_UNSUCCESSFUL);
    }

    //
    // Initialize descriptor table
    //
    DataPhysicalPageAddress =(*pdoExtension->DmaAdapterObject->DmaOperations->MapTransfer)(
                                            (pdoExtension->DmaAdapterObject), 
                                             Mdl, 
                                             pdoExtension->MapRegisterBase, 
                                             DataVirtualPageAddress,
                                             &TransferByteCount, 
                                             !DataIn 
                                             );

    //DataPhysicalPageAddress = MmGetPhysicalAddress (DataVirtualPageAddress);
    RegionDescriptorTable[0].PhysicalAddress = DataPhysicalPageAddress.LowPart;
    RegionDescriptorTable[0].ByteCount  = TransferByteCount;
    RegionDescriptorTable[0].EndOfTable = 1;


    //
    // Preserve existing data table from context
    //
    OldPhysicalRegionDescriptorTable = pdoExtension->PhysicalRegionDescriptorTable;
    OldRegionDescriptorTable         = pdoExtension->RegionDescriptorTable;

    //
    // Set up IO request parameters
    //
    pdoExtension->PhysicalRegionDescriptorTable = MmGetPhysicalAddress (RegionDescriptorTable);
    pdoExtension->RegionDescriptorTable         = RegionDescriptorTable;
    pdoExtension->Mdl                           = Mdl;
    pdoExtension->DataIn                        = DataIn;

    //
    // Setup controller
    //
    BmPrepareController (pdoExtension);

    //
    // Restore original table values
    //
    pdoExtension->PhysicalRegionDescriptorTable = OldPhysicalRegionDescriptorTable;
    pdoExtension->RegionDescriptorTable         = OldRegionDescriptorTable;

    //
    // Done
    //
    return (STATUS_SUCCESS);
}


NTSTATUS
BmArm (
    IN  PVOID   PdoExtension
    )
{
    PCHANPDO_EXTENSION pdoExtension = PdoExtension;
    PIDE_BUS_MASTER_REGISTERS bmRegister;
    UCHAR bmStatus;

    ASSERT ((pdoExtension->BmState == BmSet) || (pdoExtension->BmState == BmDisarmed));

    bmRegister = pdoExtension->BmRegister;

//    if (Device == 0)
//        bmStatus = BUSMASTER_DEVICE0_DMA_OK;
//    else
//        bmStatus = BUSMASTER_DEVICE1_DMA_OK;

    //
    // clear the status bit
    //
    bmStatus = BUSMASTER_INTERRUPT | BUSMASTER_ERROR;

    WRITE_PORT_UCHAR (&bmRegister->Status, bmStatus);

    //
    // on your mark...get set...go!!
    //
#if !defined (FAKE_BAD_IDE_DMA_DEVICE)
    if (pdoExtension->DataIn) {
        WRITE_PORT_UCHAR (&bmRegister->Command, 0x09);  // enable BM read
    } else {
        WRITE_PORT_UCHAR (&bmRegister->Command, 0x01);  // enable BM write
    }
#endif // !FAKE_BAD_IDE_DMA_DEVICE

    pdoExtension->BmState = BmArmed;

    DebugPrint ((3, "PciIde: BmArm()\n"));

    return STATUS_SUCCESS;
} // BmArm

BMSTATUS
BmDisarm (
    IN  PVOID    PdoExtension
    )
{
    PCHANPDO_EXTENSION pdoExtension = PdoExtension;
    PIDE_BUS_MASTER_REGISTERS bmRegister = pdoExtension->BmRegister;
    BMSTATUS bmStatus;

    bmStatus = BmStatus (PdoExtension);

    WRITE_PORT_UCHAR (&bmRegister->Command, 0x0);  // disable BM
    WRITE_PORT_UCHAR (&bmRegister->Status, BUSMASTER_INTERRUPT);  // clear interrupt BM

    if (pdoExtension->BmState != BmIdle) {

        pdoExtension->BmState = BmDisarmed;

    }

    if (bmStatus) {

        DebugPrint ((1, "PciIdeX: BM 0x%x status = 0x%x\n", bmRegister, bmStatus));
    }

    return bmStatus;
} // BmDisarm


BMSTATUS
BmFlush (
    IN  PVOID   PdoExtension
    )
{
    PCHANPDO_EXTENSION pdoExtension = PdoExtension;

    ASSERT (pdoExtension->BmState != BmArmed);

    (*pdoExtension->DmaAdapterObject->DmaOperations->PutScatterGatherList)(
                          pdoExtension->DmaAdapterObject,
                          pdoExtension->HalScatterGatherList,
                          (BOOLEAN)(!pdoExtension->DataIn));

    pdoExtension->HalScatterGatherList  = NULL;
    pdoExtension->DataVirtualAddress    = NULL;
    pdoExtension->TransferLength        = 0;
    pdoExtension->Mdl                   = NULL;

    pdoExtension->BmState = BmIdle;

    DebugPrint ((3, "PciIde: BmFlush()\n"));

    return STATUS_SUCCESS;
} // BmFlush


BMSTATUS
BmStatus (
    IN  PVOID    PdoExtension
    )
{
    PCHANPDO_EXTENSION pdoExtension = PdoExtension;
    PIDE_BUS_MASTER_REGISTERS bmRegister;
    BMSTATUS bmStatus;
    UCHAR    bmRawStatus;

    bmRegister = pdoExtension->BmRegister;

    bmRawStatus = READ_PORT_UCHAR (&bmRegister->Status);

    bmStatus = 0;

    //
    // if we get back 0xff from the port, then the decodes
    // are probably not enabled (or the device is powered down). return 0.
    //
    if (bmRawStatus == 0xff) {
        return bmStatus;
    }

    if (bmRawStatus & BUSMASTER_ACTIVE) {

        bmStatus |= BMSTATUS_NOT_REACH_END_OF_TRANSFER;
    }

    if (bmRawStatus & BUSMASTER_ERROR) {
        bmStatus |= BMSTATUS_ERROR_TRANSFER;
    }

    if (bmRawStatus & BUSMASTER_INTERRUPT) {
        bmStatus |= BMSTATUS_INTERRUPT;
    }

    return bmStatus;
} // BmStatus

NTSTATUS
BmTimingSetup (
    IN  PVOID    PdoExtension
    )
{
    return STATUS_SUCCESS;
} // BmTimingSetup

NTSTATUS
BmCrashDumpInitialize (
    IN  PVOID    PdoExtension
    )
{
    PCHANPDO_EXTENSION pdoExtension = PdoExtension;
    ULONG nMapRegisters = pdoExtension->MaximumPhysicalPages-1;
    if (pdoExtension->DmaAdapterObject != NULL) {
        pdoExtension->MapRegisterBase = HalAllocateCrashDumpRegisters((PADAPTER_OBJECT)pdoExtension->DmaAdapterObject, 
                                                                      &nMapRegisters
                                                                      );
    }
    return STATUS_SUCCESS;
}

NTSTATUS 
BmQueryInterface (
    IN PCHANPDO_EXTENSION PdoExtension,
    IN OUT PPCIIDE_BUSMASTER_INTERFACE BusMasterInterface
    )
{
    PCTRLFDO_EXTENSION fdoExtension = PdoExtension->ParentDeviceExtension;

    PAGED_CODE();

    if (PdoExtension->BmRegister) {

        BusMasterInterface->Size = sizeof(PCIIDE_BUSMASTER_INTERFACE);

        BusMasterInterface->SupportedTransferMode[0] = 
            fdoExtension->ControllerProperties.SupportedTransferMode[PdoExtension->ChannelNumber][0];

        BusMasterInterface->SupportedTransferMode[1] = 
            fdoExtension->ControllerProperties.SupportedTransferMode[PdoExtension->ChannelNumber][1];
    
        BusMasterInterface->MaxTransferByteSize = (PdoExtension->MaximumPhysicalPages - 1) * PAGE_SIZE;
        BusMasterInterface->Context             = PdoExtension;
        BusMasterInterface->ContextSize         = sizeof (*PdoExtension);
    
        BusMasterInterface->BmSetup       = BmSetup;
        BusMasterInterface->BmArm         = BmArm;
        BusMasterInterface->BmDisarm      = BmDisarm;
        BusMasterInterface->BmFlush       = BmFlush;
        BusMasterInterface->BmStatus      = BmStatus;
        BusMasterInterface->BmTimingSetup = BmTimingSetup;
        BusMasterInterface->BmSetupOnePage= BmSetupOnePage;
        BusMasterInterface->BmCrashDumpInitialize= BmCrashDumpInitialize;
        BusMasterInterface->BmFlushAdapterBuffers= BmFlushAdapterBuffers;
        
        BusMasterInterface->IgnoreActiveBitForAtaDevice = 
            fdoExtension->ControllerProperties.IgnoreActiveBitForAtaDevice;

        BusMasterInterface->AlwaysClearBusMasterInterrupt = 
            (fdoExtension->ControllerProperties.AlwaysClearBusMasterInterrupt ||
            IsNativeMode(fdoExtension));
                            
        return STATUS_SUCCESS;

    } else {

        return STATUS_NOT_IMPLEMENTED;
    }
} // BmQueryInterface

NTSTATUS
BmFlushAdapterBuffers (
    IN  PVOID   PdoExtension,
    IN  PVOID   DataVirtualPageAddress,
    IN  ULONG   TransferByteCount,
    IN  PMDL    Mdl,
    IN  BOOLEAN DataIn
    )
/*++
--*/
{
    PCHANPDO_EXTENSION pdoExtension = PdoExtension;

    ASSERT (pdoExtension->BmState != BmArmed);

    (pdoExtension->DmaAdapterObject->DmaOperations->FlushAdapterBuffers)(
																 (pdoExtension->DmaAdapterObject), 
																  Mdl, 
																  pdoExtension->MapRegisterBase, 
																  DataVirtualPageAddress,
																  TransferByteCount, 
																  !DataIn 
																  );

    pdoExtension->BmState = BmIdle;

	return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\pciidex\bm.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       bm.h
//
//--------------------------------------------------------------------------

#if !defined (___bm_h___)
#define ___bm_h___

//
// Busmaster Status Register Bit Definition

#define BUSMASTER_DMA_SIMPLEX_BIT     ((UCHAR) (1 << 7))
#define BUSMASTER_DEVICE1_DMA_OK      ((UCHAR) (1 << 6))
#define BUSMASTER_DEVICE0_DMA_OK      ((UCHAR) (1 << 5))
#define BUSMASTER_INTERRUPT           ((UCHAR) (1 << 2))
#define BUSMASTER_ERROR               ((UCHAR) (1 << 1))
#define BUSMASTER_ACTIVE              ((UCHAR) (1 << 0))
#define BUSMASTER_ZERO_BITS           ((UCHAR) ((1 << 3) | (1 << 4)))


#pragma pack (1)
//
// Bus Master Controller Register
//
typedef struct _IDE_BUS_MASTER_REGISTERS {
         UCHAR  Command;
         UCHAR  Reserved1;
         UCHAR  Status;
         UCHAR  Reserved2;
         ULONG  DescriptionTable;
} IDE_BUS_MASTER_REGISTERS, *PIDE_BUS_MASTER_REGISTERS;

//
// Bus Master Physical Region Descriptor
//
typedef struct _PHYSICAL_REGION_DESCRIPTOR {
    ULONG PhysicalAddress;
    ULONG ByteCount:16;
    ULONG Reserved:15;
    ULONG EndOfTable:1;
} PHYSICAL_REGION_DESCRIPTOR, * PPHYSICAL_REGION_DESCRIPTOR;
#pragma pack ()


NTSTATUS 
BusMasterInitialize (
    PCHANPDO_EXTENSION pdoExtension
    );

NTSTATUS 
BusMasterUninitialize (
    PCHANPDO_EXTENSION PdoExtension
    );

NTSTATUS
BmSetup (
    IN  PVOID   PdoExtension,
    IN  PVOID   DataVirtualAddress,
    IN  ULONG   TransferByteCount,
    IN  PMDL    Mdl,
    IN  BOOLEAN DataIn,
    IN  VOID    (* BmCallback) (PVOID Context),
    IN  PVOID   Context
    );

VOID
BmReceiveScatterGatherList(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PSCATTER_GATHER_LIST ScatterGather,
    IN PVOID Context
    );

VOID
BmRebuildScatterGatherList(
    IN PCHANPDO_EXTENSION pdoExtension,
    IN PSCATTER_GATHER_LIST ScatterGather
    );

VOID
BmPrepareController (
    PCHANPDO_EXTENSION PdoExtension
    );

NTSTATUS
BmArm (
    IN  PVOID   PdoExtension
    );

BMSTATUS
BmDisarm (
    IN  PVOID   PdoExtension
    );

BMSTATUS
BmFlush (
    IN  PVOID   PdoExtension
    );

BMSTATUS
BmStatus (
    IN  PVOID   PdoExtension
    );

NTSTATUS
BmTimingSetup (
    IN  PVOID   PdoExtension
    );

NTSTATUS
BmFlushAdapterBuffers (
    IN  PVOID   PdoExtension,
    IN  PVOID   DataVirtualPageAddress,
    IN  ULONG   TransferByteCount,
    IN  PMDL    Mdl,
    IN  BOOLEAN DataIn
    );

NTSTATUS 
BmQueryInterface (
    IN PCHANPDO_EXTENSION PdoExtension,
    IN OUT PPCIIDE_BUSMASTER_INTERFACE BusMasterInterface
    );

#endif // ___bm_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\pciidex\chanpdo.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       chanpdo.c
//
//--------------------------------------------------------------------------

#include "pciidex.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ChannelStartDevice)
#pragma alloc_text(PAGE, ChannelQueryStopRemoveDevice)
#pragma alloc_text(PAGE, ChannelRemoveDevice)
#pragma alloc_text(PAGE, ChannelStopDevice)
#pragma alloc_text(PAGE, ChannelStopChannel)
#pragma alloc_text(PAGE, ChannelQueryId)
#pragma alloc_text(PAGE, ChannelBuildDeviceId)
#pragma alloc_text(PAGE, ChannelBuildInstanceId)
#pragma alloc_text(PAGE, ChannelBuildCompatibleId)
#pragma alloc_text(PAGE, ChannelBuildHardwareId)
#pragma alloc_text(PAGE, ChannelQueryCapabitilies)
#pragma alloc_text(PAGE, ChannelQueryResources)
#pragma alloc_text(PAGE, ChannelQueryResourceRequirements)
#pragma alloc_text(PAGE, ChannelInternalDeviceIoControl)
#pragma alloc_text(PAGE, ChannelQueryText)
#pragma alloc_text(PAGE, PciIdeChannelQueryInterface)
#pragma alloc_text(PAGE, ChannelQueryDeviceRelations)
#pragma alloc_text(PAGE, ChannelUsageNotification)
#pragma alloc_text(PAGE, ChannelQueryPnPDeviceState)

#pragma alloc_text(NONPAGE, ChannelGetPdoExtension)
#pragma alloc_text(NONPAGE, ChannelUpdatePdoState)
#pragma alloc_text(NONPAGE, PciIdeChannelTransferModeSelect)
#pragma alloc_text(NONPAGE, PciIdeChannelTransferModeInterface)

#endif // ALLOC_PRAGMA


PCHANPDO_EXTENSION
ChannelGetPdoExtension(
    PDEVICE_OBJECT DeviceObject
    )
{
    KIRQL currentIrql;
    PCHANPDO_EXTENSION pdoExtension = DeviceObject->DeviceExtension;
    PKSPIN_LOCK spinLock;


    spinLock = &pdoExtension->SpinLock;
    KeAcquireSpinLock(spinLock, &currentIrql);

    if ((pdoExtension->PdoState & PDOS_DEADMEAT) &&
        (pdoExtension->PdoState & PDOS_REMOVED)) {

        pdoExtension = NULL;
    }

    KeReleaseSpinLock(spinLock, currentIrql);

    return pdoExtension;
}

ULONG
ChannelUpdatePdoState(
    PCHANPDO_EXTENSION PdoExtension,
    ULONG SetFlags,
    ULONG ClearFlags
    )
{
    ULONG pdoState;
    KIRQL currentIrql;

    ASSERT (PdoExtension);

    KeAcquireSpinLock(&PdoExtension->SpinLock, &currentIrql);

    SETMASK (PdoExtension->PdoState, SetFlags);
    CLRMASK (PdoExtension->PdoState, ClearFlags);
    pdoState = PdoExtension->PdoState;

    KeReleaseSpinLock(&PdoExtension->SpinLock, currentIrql);

    return pdoState;
}



NTSTATUS
ChannelStartDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PCHANPDO_EXTENSION pdoExtension;
    NTSTATUS status;
    IDE_CHANNEL_STATE channelState;

    PAGED_CODE();

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        status = STATUS_SUCCESS;

        //
        // always keep native mode started
        //

        if (pdoExtension->ParentDeviceExtension->
            NativeMode[pdoExtension->ChannelNumber] == FALSE) {

            channelState = PciIdeChannelEnabled (
                               pdoExtension->ParentDeviceExtension,
                               pdoExtension->ChannelNumber
                               );
            //
            // ISSUE: we should free the resources assigned.
            //
            //ASSERT(channelState != ChannelDisabled);

            if (channelState == ChannelStateUnknown) {

                //
                // we don't really know if this channel
                // is acutally enabled
                //
                // we will do our empty channel test
                //

                PIO_STACK_LOCATION thisIrpSp;
                IDE_RESOURCE ideResource;
                PCM_PARTIAL_RESOURCE_DESCRIPTOR irqPartialDescriptors;
                IDE_REGISTERS_1  baseIoAddress1;
                IDE_REGISTERS_2  baseIoAddress2;
                ULONG baseIoAddressLength1;
                ULONG baseIoAddressLength2;
                ULONG maxIdeDevice;
                PCM_RESOURCE_LIST resourceList;

                thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

                //
                // legacy mode channel gets its the start device irp
                //
                resourceList = thisIrpSp->Parameters.StartDevice.AllocatedResourcesTranslated;

                status = DigestResourceList (
                             &ideResource,
                             resourceList,
                             &irqPartialDescriptors
                             );

                if (NT_SUCCESS(status)) {

                    AtapiBuildIoAddress (
                        ideResource.TranslatedCommandBaseAddress,
                        ideResource.TranslatedControlBaseAddress,
                        &baseIoAddress1,
                        &baseIoAddress2,
                        &baseIoAddressLength1,
                        &baseIoAddressLength2,
                        &maxIdeDevice,
                        NULL
                        );

                    if (IdePortChannelEmpty (
                            &baseIoAddress1,
                            &baseIoAddress2,
                            maxIdeDevice)) {

                        //
                        // upgrade its state to "disabled"
                        //
                        channelState = ChannelDisabled;

                    } else {

                        channelState = ChannelEnabled;
                    }

                    //
                    // don't need the io resource anymore
                    // unmap io space if nesscessary
                    //
                    if ((ideResource.CommandBaseAddressSpace == MEMORY_SPACE) &&
                        (ideResource.TranslatedCommandBaseAddress)) {

                        MmUnmapIoSpace (
                            ideResource.TranslatedCommandBaseAddress,
                            baseIoAddressLength1
                            );
                    }
                    if ((ideResource.ControlBaseAddressSpace == MEMORY_SPACE) &&
                        (ideResource.TranslatedControlBaseAddress)) {

                        MmUnmapIoSpace (
                            ideResource.TranslatedControlBaseAddress,
                            baseIoAddressLength2
                            );
                    }

                }
                if (channelState == ChannelDisabled) {

                    pdoExtension->EmptyChannel = TRUE;

                    //
                    // channel looks empty
                    // change our resource requirement to free our irq for other devices
                    //
                    if (irqPartialDescriptors) {
                        SETMASK (pdoExtension->PnPDeviceState, PNP_DEVICE_FAILED | PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED);
                        IoInvalidateDeviceState (DeviceObject);
                    }
                } else {

                    pdoExtension->EmptyChannel = FALSE;
                }
            }
        }

        if (NT_SUCCESS(status)) {

            //
            // grab the DmaDetectionLevel from the registry
            // default is DdlFirmwareOk
            //
            pdoExtension->DmaDetectionLevel = DdlFirmwareOk;
            status = PciIdeXGetDeviceParameter (
                       pdoExtension->DeviceObject,
                       DMA_DETECTION_LEVEL_REG_KEY,
                       (PULONG)&pdoExtension->DmaDetectionLevel
                       );

            status = BusMasterInitialize (pdoExtension);
        }
    }

    if (NT_SUCCESS(status)) {

        //
        // get the firmware initialized DMA capable bits
        //
        if (pdoExtension->BmRegister) {

            pdoExtension->BootBmStatus = READ_PORT_UCHAR (&pdoExtension->BmRegister->Status);
        }

        ChannelUpdatePdoState (
            pdoExtension,
            PDOS_STARTED,
            PDOS_DEADMEAT | PDOS_STOPPED | PDOS_REMOVED
            );



#if DBG
        {
           ULONG data;
           USHORT vendorId =0;
           USHORT deviceId = 0;
           PVOID deviceExtension;

           data = 0;
           deviceExtension = pdoExtension->ParentDeviceExtension->VendorSpecificDeviceEntension;

           PciIdeXGetBusData (
               deviceExtension,
               &vendorId,
               FIELD_OFFSET(PCI_COMMON_CONFIG, VendorID),
               sizeof(vendorId)
               );

           PciIdeXGetBusData (
               deviceExtension,
               &deviceId,
               FIELD_OFFSET(PCI_COMMON_CONFIG, DeviceID),
               sizeof(deviceId)
               );

           if (vendorId == 0x8086) {

               data = 0;
               PciIdeXGetBusData (
                   deviceExtension,
                   &data,
                   0x40,    // IDETIM0
                   2
                   );

                PciIdeXSaveDeviceParameter (
                    deviceExtension,
                    L"Old IDETIM0",
                    data
                    );

                data = 0;
                PciIdeXGetBusData (
                    deviceExtension,
                    &data,
                    0x42,    // IDETIM1
                    2
                    );

                 PciIdeXSaveDeviceParameter (
                     deviceExtension,
                     L"Old IDETIM1",
                     data
                     );

                if (deviceId != 0x1230) {       // !PIIX

                    data = 0;
                    PciIdeXGetBusData (
                        deviceExtension,
                        &data,
                        0x44,
                        1
                        );

                    PciIdeXSaveDeviceParameter (
                        deviceExtension,
                        L"Old SIDETIM",
                        data
                        );
                }

                if (deviceId == 0x7111) {

                    USHORT t;

                    data = 0;
                    PciIdeXGetBusData (
                        deviceExtension,
                        &data,
                        0x48,
                        1
                        );

                    PciIdeXSaveDeviceParameter (
                        deviceExtension,
                        L"Old SDMACTL",
                        data
                        );

                    data = 0;
                    PciIdeXGetBusData (
                        deviceExtension,
                        &data,
                        0x4a, //SDMATIM0
                        1
                        );

                    PciIdeXSaveDeviceParameter (
                        deviceExtension,
                        L"Old SDMATIM0",
                        data
                        );

                    data = 0;
                    PciIdeXGetBusData (
                        deviceExtension,
                        &data,
                        0x4b, //SDMATIM1
                        1
                        );

                    PciIdeXSaveDeviceParameter (
                        deviceExtension,
                        L"Old SDMATIM1",
                        data
                        );
                }
           }
        }
#endif // DBG
    }



    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
} // ChannelStartDevice

NTSTATUS
ChannelQueryStopRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS           status;
    PCHANPDO_EXTENSION pdoExtension;

    pdoExtension = ChannelGetPdoExtension(DeviceObject);

    if (pdoExtension) {

        //
        // Check the paging path count for this device.
        //

        if (pdoExtension->PagingPathCount ||
            pdoExtension->CrashDumpPathCount) {
            status = STATUS_UNSUCCESSFUL;
        } else {
            status = STATUS_SUCCESS;
        }

    } else {

        status = STATUS_NO_SUCH_DEVICE;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;

} // ChannelQueryStopRemoveDevice

NTSTATUS
ChannelRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PCHANPDO_EXTENSION pdoExtension;
    NTSTATUS status;
    PDEVICE_OBJECT AttacheePdo;
    BOOLEAN removeFromParent;
    BOOLEAN callIoDeleteDevice;

    PAGED_CODE();

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension) {

        PIO_STACK_LOCATION thisIrpSp;
        ULONG actionFlag;

        thisIrpSp = IoGetCurrentIrpStackLocation(Irp);

        status = ChannelStopChannel (pdoExtension);
        ASSERT (NT_SUCCESS(status));

        if (thisIrpSp->MinorFunction == IRP_MN_REMOVE_DEVICE) {

            if (pdoExtension->PdoState & PDOS_DEADMEAT) {

               actionFlag = PDOS_REMOVED;
               removeFromParent = TRUE;
               callIoDeleteDevice = TRUE;

            } else {
               actionFlag = PDOS_DISABLED_BY_USER;
               removeFromParent = FALSE;
               callIoDeleteDevice = FALSE;
            }

        } else {

            actionFlag = PDOS_SURPRISE_REMOVED;
            removeFromParent = FALSE;
            callIoDeleteDevice = FALSE;
        }

        ChannelUpdatePdoState (
            pdoExtension,
            actionFlag,
            PDOS_STARTED | PDOS_STOPPED
            );

        if (removeFromParent) {

            PCTRLFDO_EXTENSION  fdoExtension;

            fdoExtension = pdoExtension->ParentDeviceExtension;

            fdoExtension->ChildDeviceExtension[pdoExtension->ChannelNumber] = NULL;

            if (callIoDeleteDevice) {

                IoDeleteDevice (pdoExtension->DeviceObject);
            }
        }

        if (pdoExtension->NeedToCallIoInvalidateDeviceRelations) {

            pdoExtension->NeedToCallIoInvalidateDeviceRelations = FALSE;
            IoInvalidateDeviceRelations (
                pdoExtension->ParentDeviceExtension->AttacheePdo,
                BusRelations
                );
        }

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_NO_SUCH_DEVICE;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
} // ChannelRemoveDevice

NTSTATUS
ChannelStopDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PCHANPDO_EXTENSION pdoExtension;
    NTSTATUS status;

    PAGED_CODE();

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        status = ChannelStopChannel (pdoExtension);
        ASSERT (NT_SUCCESS(status));

        ChannelUpdatePdoState (
            pdoExtension,
            PDOS_STOPPED,
            PDOS_STARTED
            );

        status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
} // ChannelRemoveDevice

NTSTATUS
ChannelStopChannel (
    PCHANPDO_EXTENSION PdoExtension
    )
{
    NTSTATUS status;

    PAGED_CODE();

    status = BusMasterUninitialize (PdoExtension);
    ASSERT (NT_SUCCESS(status));

    return STATUS_SUCCESS;
} // ChannelStopChannel


NTSTATUS
ChannelQueryId (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  thisIrpSp;
    PCHANPDO_EXTENSION  pdoExtension;
    NTSTATUS status = STATUS_UNSUCCESSFUL;
    PWSTR idString = NULL;

    PAGED_CODE();

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
        switch (thisIrpSp->Parameters.QueryId.IdType) {

            case BusQueryDeviceID:

                //
                // Caller wants the bus ID of this device.
                //

                idString = ChannelBuildDeviceId (pdoExtension);
                break;

            case BusQueryInstanceID:

                //
                // Caller wants the unique id of the device
                //

                idString = ChannelBuildInstanceId (pdoExtension);
                break;

            case BusQueryCompatibleIDs:

                //
                // Caller wants the unique id of the device
                //

                idString = ChannelBuildCompatibleId (pdoExtension);
                break;

            case BusQueryHardwareIDs:

                //
                // Caller wants the unique id of the device
                //

                idString = ChannelBuildHardwareId (pdoExtension);
                break;

            default:
                idString = NULL;
                DebugPrint ((1, "pciide: QueryID type %d not supported\n", thisIrpSp->Parameters.QueryId.IdType));
                status = STATUS_NOT_SUPPORTED;
                break;
        }
    }

    if( idString != NULL ){
        Irp->IoStatus.Information = (ULONG_PTR) idString;
        status = STATUS_SUCCESS;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // ChannelQueryId

PWSTR
ChannelBuildDeviceId(
    IN PCHANPDO_EXTENSION pdoExtension
    )
{
    PWSTR       idString;
    ULONG       idStringBufLen;
    NTSTATUS    status;
    WCHAR       deviceIdFormat[] = L"PCIIDE\\IDEChannel";

    PAGED_CODE();

    idStringBufLen = ( wcslen( deviceIdFormat ) + 1 ) * sizeof( WCHAR );
    idString = ExAllocatePool( PagedPool, idStringBufLen );
    if( idString == NULL ){

        return NULL;
    }

    //
    // Form the string and return it.
    //

    wcscpy( idString,
              deviceIdFormat);

    return idString;
} // ChannelBuildDeviceId

PWSTR
ChannelBuildInstanceId(
    IN PCHANPDO_EXTENSION pdoExtension
    )
{
    PWSTR       idString;
    ULONG       idStringBufLen;
    NTSTATUS    status;
    WCHAR       instanceIdFormat[] = L"%d";

    PAGED_CODE();

    //
    // The maximum number of digits that a ulong can hold is 10.
    // So the id len should be 10 + 1 (for '\0')
    //
    idStringBufLen = 11 * sizeof( WCHAR );
    idString = ExAllocatePool (PagedPool, idStringBufLen);

    if( idString) {

        //
        // Form the string and return it.
        //
        swprintf( idString,
                  instanceIdFormat,
                  pdoExtension->ChannelNumber);
    }


    return idString;

} // ChannelBuildInstanceId

//
// Multi-string Compatible IDs
//
WCHAR ChannelCompatibleId[] = {
    L"*PNP0600"
    };
//
// internal Compatible IDs
//
PWCHAR ChannelInternalCompatibleId[MAX_IDE_CHANNEL] = {
    L"Primary_IDE_Channel",
    L"Secondary_IDE_Channel"
    };

PWSTR
ChannelBuildCompatibleId(
    IN PCHANPDO_EXTENSION pdoExtension
    )
{
    PWSTR idString;
    ULONG idStringBufLen;
    ULONG i;

    PAGED_CODE();

    idStringBufLen = sizeof(ChannelCompatibleId);
    idString = ExAllocatePool (PagedPool, idStringBufLen + sizeof (WCHAR) * 2);
    if( idString == NULL ){

        return NULL;
    }

    RtlCopyMemory (
        idString,
        ChannelCompatibleId,
        idStringBufLen
        );
    idString[idStringBufLen/2 + 0] = L'\0';
    idString[idStringBufLen/2 + 1] = L'\0';

    return idString;
} // ChannelBuildCompatibleId

PWSTR
ChannelBuildHardwareId(
    IN PCHANPDO_EXTENSION pdoExtension
    )
{
    NTSTATUS status;

    struct {
        USHORT  VendorId;
        USHORT  DeviceId;
    } hwRawId;

    PWSTR vendorIdString;
    PWSTR deviceIdString;
    WCHAR vendorId[10];
    WCHAR deviceId[10];

    PWSTR idString;
    ULONG idStringBufLen;

    ULONG stringLen;
    ULONG internalIdLen;

    PAGED_CODE();

    status = PciIdeBusData (
                 pdoExtension->ParentDeviceExtension,
                 &hwRawId,
                 0,
                 sizeof (hwRawId),
                 TRUE
                 );
    if (!NT_SUCCESS(status)) {

        return NULL;
    }

    vendorIdString = NULL;
    deviceIdString = NULL;

    switch (hwRawId.VendorId) {
        case 0x8086:
            vendorIdString = L"Intel";

            switch (hwRawId.DeviceId) {

                case 0x1230:
                    deviceIdString = L"PIIX";
                    break;

                case 0x7010:
                    deviceIdString = L"PIIX3";
                    break;

                case 0x7111:
                    deviceIdString = L"PIIX4";
                    break;
            }
            break;

        case 0x1095:
            vendorIdString = L"CMD";
            break;

        case 0x10b9:
            vendorIdString = L"ALi";
            break;

        case 0x1039:
            vendorIdString = L"SiS";
            break;

        case 0x0e11:
            vendorIdString = L"Compaq";
            break;

        case 0x10ad:
            vendorIdString = L"WinBond";
            break;
    }

    if (vendorIdString == NULL) {

        swprintf (vendorId,
                  L"%04x",
                  hwRawId.VendorId);

        vendorIdString = vendorId;
    }

    if (deviceIdString == NULL) {

        swprintf (deviceId,
                  L"%04x",
                  hwRawId.DeviceId);

        deviceIdString = deviceId;
    }

    idStringBufLen = (256 * sizeof (WCHAR));
    idStringBufLen += sizeof(ChannelCompatibleId);
    idString = ExAllocatePool( PagedPool, idStringBufLen);
    if( idString == NULL ){

        return NULL;
    }

    //
    // Form the string and return it.
    //
    swprintf (idString,
              L"%ws-%ws",
              vendorIdString,
              deviceIdString
              );
    stringLen = wcslen(idString);
    idString[stringLen] = L'\0';
    stringLen++;

    //
    // internal HW id
    //
    internalIdLen = wcslen(ChannelInternalCompatibleId[pdoExtension->ChannelNumber]);
    RtlCopyMemory (
        idString + stringLen,
        ChannelInternalCompatibleId[pdoExtension->ChannelNumber],
        internalIdLen * sizeof (WCHAR)
        );
    stringLen += internalIdLen;
    idString[stringLen] = L'\0';
    stringLen++;

    //
    // generic HW id
    //
    RtlCopyMemory (
        idString + stringLen,
        ChannelCompatibleId,
        sizeof(ChannelCompatibleId)
        );
    stringLen += sizeof(ChannelCompatibleId) / sizeof(WCHAR);
    idString[stringLen] = L'\0';
    stringLen++;
    idString[stringLen] = L'\0';
    stringLen++;

    return idString;
} // ChannelBuildHardwareId

NTSTATUS
ChannelQueryCapabitilies (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION      thisIrpSp;
    PCHANPDO_EXTENSION      pdoExtension;
    PDEVICE_CAPABILITIES    capabilities;
    NTSTATUS                status;

    PAGED_CODE();

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        DEVICE_CAPABILITIES parentDeviceCapabilities;

        status = IdeGetDeviceCapabilities(
                     pdoExtension->ParentDeviceExtension->AttacheePdo,
                     &parentDeviceCapabilities);

        if (NT_SUCCESS(status)) {

            thisIrpSp    = IoGetCurrentIrpStackLocation( Irp );
            capabilities = thisIrpSp->Parameters.DeviceCapabilities.Capabilities;

            *capabilities = parentDeviceCapabilities;

            capabilities->UniqueID          = FALSE;
            capabilities->Address           = pdoExtension->ChannelNumber;
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);
    return status;
} // ChannelQueryCapabitilies


NTSTATUS
ChannelQueryResources(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PCHANPDO_EXTENSION              pdoExtension;
    PCTRLFDO_EXTENSION              fdoExtension;
    PIO_STACK_LOCATION              thisIrpSp;
    NTSTATUS                        status;
    ULONG                           resourceListSize;
    PCM_RESOURCE_LIST               resourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
    IDE_CHANNEL_STATE 				channelState;

    PAGED_CODE();

    resourceList = NULL;
    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
        fdoExtension = pdoExtension->ParentDeviceExtension;

        if (fdoExtension->NativeMode[pdoExtension->ChannelNumber]) {

            //
            // Don't make up resources for native mode controller
            // PCI bus driver should find them all
            //
            resourceList = NULL;
            status = STATUS_SUCCESS;
            goto GetOut;
        }

		//
		// Don't claim resources if the channel is disabled
		//
        channelState = PciIdeChannelEnabled (
										pdoExtension->ParentDeviceExtension,
										pdoExtension->ChannelNumber
										);
		if (channelState == ChannelDisabled) {

			resourceList = NULL;
			status = STATUS_SUCCESS;
			goto GetOut;
		}

        //
        // TEMP CODE for the time without a real PCI driver.
		// Actually pciidex should do this
        //

        resourceListSize = sizeof (CM_RESOURCE_LIST) - sizeof (CM_FULL_RESOURCE_DESCRIPTOR) +
                             FULL_RESOURCE_LIST_SIZE(3);   // primary IO (2) + IRQ
        resourceList = ExAllocatePool (PagedPool, resourceListSize);
        if (resourceList == NULL) {
            status = STATUS_NO_MEMORY;
            goto GetOut;
        }

        RtlZeroMemory(resourceList, resourceListSize);

        resourceList->Count = 1;
        fullResourceList = resourceList->List;
        partialResourceList = &(fullResourceList->PartialResourceList);
        partialResourceList->Count = 0;
        partialDescriptors = partialResourceList->PartialDescriptors;

        fullResourceList->InterfaceType = Isa;
        fullResourceList->BusNumber = 0;

        if (pdoExtension->ChannelNumber == 0) {

            if (!fdoExtension->PdoCmdRegResourceFound[0]) {

                partialDescriptors[partialResourceList->Count].Type                  = CmResourceTypePort;
                partialDescriptors[partialResourceList->Count].ShareDisposition      = CmResourceShareDeviceExclusive;
                partialDescriptors[partialResourceList->Count].Flags                 = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                partialDescriptors[partialResourceList->Count].u.Port.Start.QuadPart = 0x1f0;
                partialDescriptors[partialResourceList->Count].u.Port.Length         = 8;

                partialResourceList->Count++;
            }

            if (!fdoExtension->PdoCtrlRegResourceFound[0]) {

                partialDescriptors[partialResourceList->Count].Type                  = CmResourceTypePort;
                partialDescriptors[partialResourceList->Count].ShareDisposition      = CmResourceShareDeviceExclusive;
                partialDescriptors[partialResourceList->Count].Flags                 = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                partialDescriptors[partialResourceList->Count].u.Port.Start.QuadPart = 0x3f6;
                partialDescriptors[partialResourceList->Count].u.Port.Length         = 1;

                partialResourceList->Count++;
            }

            if (!fdoExtension->PdoInterruptResourceFound[0]) {

                partialDescriptors[partialResourceList->Count].Type                  = CmResourceTypeInterrupt;
                partialDescriptors[partialResourceList->Count].ShareDisposition      = CmResourceShareDeviceExclusive;
                partialDescriptors[partialResourceList->Count].Flags                 = CM_RESOURCE_INTERRUPT_LATCHED;
                partialDescriptors[partialResourceList->Count].u.Interrupt.Level     = 14;
                partialDescriptors[partialResourceList->Count].u.Interrupt.Vector    = 14;
                partialDescriptors[partialResourceList->Count].u.Interrupt.Affinity  = 0x1;  // ISSUE: 08/28/2000: To be looked into.

                partialResourceList->Count++;
            }

        } else { // if (pdoExtension->ChannelNumber == 1)

            if (!fdoExtension->PdoCmdRegResourceFound[1]) {

                partialDescriptors[partialResourceList->Count].Type                  = CmResourceTypePort;
                partialDescriptors[partialResourceList->Count].ShareDisposition      = CmResourceShareDeviceExclusive;
                partialDescriptors[partialResourceList->Count].Flags                 = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                partialDescriptors[partialResourceList->Count].u.Port.Start.QuadPart = 0x170;
                partialDescriptors[partialResourceList->Count].u.Port.Length         = 8;

                partialResourceList->Count++;
            }

            if (!fdoExtension->PdoCtrlRegResourceFound[1]) {

                partialDescriptors[partialResourceList->Count].Type                  = CmResourceTypePort;
                partialDescriptors[partialResourceList->Count].ShareDisposition      = CmResourceShareDeviceExclusive;
                partialDescriptors[partialResourceList->Count].Flags                 = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                partialDescriptors[partialResourceList->Count].u.Port.Start.QuadPart = 0x376;
                partialDescriptors[partialResourceList->Count].u.Port.Length         = 1;

                partialResourceList->Count++;
            }

            if (!fdoExtension->PdoInterruptResourceFound[1]) {

                partialDescriptors[partialResourceList->Count].Type                  = CmResourceTypeInterrupt;
                partialDescriptors[partialResourceList->Count].ShareDisposition      = CmResourceShareDeviceExclusive;
                partialDescriptors[partialResourceList->Count].Flags                 = CM_RESOURCE_INTERRUPT_LATCHED;
                partialDescriptors[partialResourceList->Count].u.Interrupt.Level     = 15;
                partialDescriptors[partialResourceList->Count].u.Interrupt.Vector    = 15;
                partialDescriptors[partialResourceList->Count].u.Interrupt.Affinity  = 0x1;  // ISSUE: 08/28/2000: To be Looked into

                partialResourceList->Count++;
            }
        }

        if (!partialResourceList->Count) {

            ExFreePool (resourceList);
            resourceList = NULL;
        }

        status = STATUS_SUCCESS;
    }

GetOut:

    Irp->IoStatus.Information = (ULONG_PTR) resourceList;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // ChannelQueryResources

NTSTATUS
ChannelQueryResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION              thisIrpSp;
    PCHANPDO_EXTENSION              pdoExtension;
    PCTRLFDO_EXTENSION              fdoExtension;
    NTSTATUS                        status;

    PIO_RESOURCE_REQUIREMENTS_LIST  requirementsList;
    PIO_RESOURCE_LIST               resourceList;
    PIO_RESOURCE_DESCRIPTOR         resourceDescriptor;
    ULONG                           requirementsListSize;

    BOOLEAN                         reportIrq;
    IDE_CHANNEL_STATE 				channelState;

    PAGED_CODE();

    requirementsList = NULL;
    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
        fdoExtension = pdoExtension->ParentDeviceExtension;

        if (fdoExtension->NativeMode[pdoExtension->ChannelNumber]) {

            //
            // Don't make up resources for native mode controller
            // PCI bus driver should find them all
            //
            requirementsList = NULL;
            status = STATUS_SUCCESS;
            goto GetOut;
        }

        //
        // legacy controller
        //
        channelState = PciIdeChannelEnabled (
										pdoExtension->ParentDeviceExtension,
										pdoExtension->ChannelNumber
										);

		//
		// Don't claim resources if the channel is disabled
		//
        if (channelState == ChannelStateUnknown ) {

            if (pdoExtension->EmptyChannel) {

                reportIrq = FALSE;

            } else {

                reportIrq = TRUE;
            }
        } else if (channelState == ChannelDisabled) {

            requirementsList = NULL;
            status = STATUS_SUCCESS;
            goto GetOut;
		}

        //
        // TEMP CODE for the time without a real PCI driver.
		// pciidex should do this.
        //

        requirementsListSize = sizeof (IO_RESOURCE_REQUIREMENTS_LIST) +
                               sizeof (IO_RESOURCE_DESCRIPTOR) * (3 - 1);
        requirementsList = ExAllocatePool (PagedPool, requirementsListSize);
        if( requirementsList == NULL ){
            status = STATUS_NO_MEMORY;
            goto GetOut;
        }

        RtlZeroMemory(requirementsList, requirementsListSize);

        requirementsList->ListSize          = requirementsListSize;
        requirementsList->InterfaceType     = Isa;
        requirementsList->BusNumber         = 0;    // ISSUE: 08/30/2000
        requirementsList->SlotNumber        = 0;
        requirementsList->AlternativeLists  = 1;

        resourceList            = requirementsList->List;
        resourceList->Version   = 1;
        resourceList->Revision  = 1;
        resourceList->Count     = 0;

        resourceDescriptor = resourceList->Descriptors;

        if (pdoExtension->ChannelNumber == 0) {

            if (!fdoExtension->PdoCmdRegResourceFound[0]) {

                resourceDescriptor[resourceList->Count].Option           = IO_RESOURCE_PREFERRED;
                resourceDescriptor[resourceList->Count].Type             = CmResourceTypePort;
                resourceDescriptor[resourceList->Count].ShareDisposition = CmResourceShareDeviceExclusive;
                resourceDescriptor[resourceList->Count].Flags            = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                resourceDescriptor[resourceList->Count].u.Port.Length    = 8;
                resourceDescriptor[resourceList->Count].u.Port.Alignment = 1;
                resourceDescriptor[resourceList->Count].u.Port.MinimumAddress.QuadPart = 0x1f0;
                resourceDescriptor[resourceList->Count].u.Port.MaximumAddress.QuadPart = 0x1f7;

                resourceList->Count++;
            }

            if (!fdoExtension->PdoCtrlRegResourceFound[0]) {

                resourceDescriptor[resourceList->Count].Option           = IO_RESOURCE_PREFERRED;
                resourceDescriptor[resourceList->Count].Type             = CmResourceTypePort;
                resourceDescriptor[resourceList->Count].ShareDisposition = CmResourceShareDeviceExclusive;
                resourceDescriptor[resourceList->Count].Flags            = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                resourceDescriptor[resourceList->Count].u.Port.Length    = 1;
                resourceDescriptor[resourceList->Count].u.Port.Alignment = 1;
                resourceDescriptor[resourceList->Count].u.Port.MinimumAddress.QuadPart = 0x3f6;
                resourceDescriptor[resourceList->Count].u.Port.MaximumAddress.QuadPart = 0x3f6;

                resourceList->Count++;
            }

            if (!fdoExtension->PdoInterruptResourceFound[0] && reportIrq) {

                resourceDescriptor[resourceList->Count].Option           = IO_RESOURCE_PREFERRED;
                resourceDescriptor[resourceList->Count].Type             = CmResourceTypeInterrupt;
                resourceDescriptor[resourceList->Count].ShareDisposition = CmResourceShareDeviceExclusive;
                resourceDescriptor[resourceList->Count].Flags            = CM_RESOURCE_INTERRUPT_LATCHED;
                resourceDescriptor[resourceList->Count].u.Interrupt.MinimumVector = 0xe;
                resourceDescriptor[resourceList->Count].u.Interrupt.MaximumVector = 0xe;

                resourceList->Count++;
            }

        } else { // if (pdoExtension->ChannelNumber == 1)

            if (!fdoExtension->PdoCmdRegResourceFound[1]) {

                resourceDescriptor[resourceList->Count].Option           = IO_RESOURCE_PREFERRED;
                resourceDescriptor[resourceList->Count].Type             = CmResourceTypePort;
                resourceDescriptor[resourceList->Count].ShareDisposition = CmResourceShareDeviceExclusive;
                resourceDescriptor[resourceList->Count].Flags            = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                resourceDescriptor[resourceList->Count].u.Port.Length    = 8;
                resourceDescriptor[resourceList->Count].u.Port.Alignment = 1;
                resourceDescriptor[resourceList->Count].u.Port.MinimumAddress.QuadPart = 0x170;
                resourceDescriptor[resourceList->Count].u.Port.MaximumAddress.QuadPart = 0x177;

                resourceList->Count++;
            }

            if (!fdoExtension->PdoCtrlRegResourceFound[1]) {

                resourceDescriptor[resourceList->Count].Option           = IO_RESOURCE_PREFERRED;
                resourceDescriptor[resourceList->Count].Type             = CmResourceTypePort;
                resourceDescriptor[resourceList->Count].ShareDisposition = CmResourceShareDeviceExclusive;
                resourceDescriptor[resourceList->Count].Flags            = CM_RESOURCE_PORT_IO | CM_RESOURCE_PORT_16_BIT_DECODE;
                resourceDescriptor[resourceList->Count].u.Port.Length    = 1;
                resourceDescriptor[resourceList->Count].u.Port.Alignment = 1;
                resourceDescriptor[resourceList->Count].u.Port.MinimumAddress.QuadPart = 0x376;
                resourceDescriptor[resourceList->Count].u.Port.MaximumAddress.QuadPart = 0x376;

                resourceList->Count++;
            }

            if (!fdoExtension->PdoInterruptResourceFound[1] && reportIrq) {

                resourceDescriptor[resourceList->Count].Option           = IO_RESOURCE_PREFERRED;
                resourceDescriptor[resourceList->Count].Type             = CmResourceTypeInterrupt;
                resourceDescriptor[resourceList->Count].ShareDisposition = CmResourceShareDeviceExclusive;
                resourceDescriptor[resourceList->Count].Flags            = CM_RESOURCE_INTERRUPT_LATCHED;
                resourceDescriptor[resourceList->Count].u.Interrupt.MinimumVector = 0xf;
                resourceDescriptor[resourceList->Count].u.Interrupt.MaximumVector = 0xf;

                resourceList->Count++;
            }
        }

        if (!resourceList->Count) {

            ExFreePool (requirementsList);
            requirementsList = NULL;
        }

        status = STATUS_SUCCESS;
    }

GetOut:

    Irp->IoStatus.Information = (ULONG_PTR) requirementsList;
    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // ChannelQueryResourceRequirements


NTSTATUS
ChannelInternalDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    )
{
    PIO_STACK_LOCATION              thisIrpSp;
    PCHANPDO_EXTENSION              pdoExtension;
    NTSTATUS                        status;

    PAGED_CODE();

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        thisIrpSp    = IoGetCurrentIrpStackLocation(Irp);

        switch (thisIrpSp->Parameters.DeviceIoControl.IoControlCode) {

            //
            // TEMP CODE for the time without a real PCI driver.
			// pciidex knows about the resources.
            //
            case IOCTL_IDE_GET_RESOURCES_ALLOCATED:
                {
                PCTRLFDO_EXTENSION              fdoExtension;
                ULONG                           resourceListSize;
                PCM_RESOURCE_LIST               resourceList;
                PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
                PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
                PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
                ULONG                           channel;

                channel = pdoExtension->ChannelNumber;
                fdoExtension = pdoExtension->ParentDeviceExtension;

                resourceListSize = fdoExtension->PdoResourceListSize[channel];

                //
                // have the callee allocate the buffer. 
                //
                resourceList = (PCM_RESOURCE_LIST) Irp->AssociatedIrp.SystemBuffer;
                ASSERT(resourceList);

                RtlCopyMemory (
                    resourceList,
                    fdoExtension->PdoResourceList[channel],
                    resourceListSize);

                Irp->IoStatus.Information = resourceListSize;
                status = STATUS_SUCCESS;
                }
                break;

            default:
                DebugPrint ((1,
                             "PciIde, Channel PDO got Unknown IoControlCode 0x%x\n",
                             thisIrpSp->Parameters.DeviceIoControl.IoControlCode));
                status = STATUS_INVALID_PARAMETER;
                break;
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest (Irp, IO_NO_INCREMENT);

    return status;
} // ChannelInternalDeviceIoControl


NTSTATUS
ChannelQueryText (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  thisIrpSp;
    PCHANPDO_EXTENSION  pdoExtension;
    PWCHAR              returnString;
    ANSI_STRING         ansiString;
    UNICODE_STRING      unicodeString;
    ULONG               stringLen;
    NTSTATUS            status;

    PAGED_CODE();

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        thisIrpSp    = IoGetCurrentIrpStackLocation (Irp);

        returnString = NULL;
        Irp->IoStatus.Information = 0;

        if (thisIrpSp->Parameters.QueryDeviceText.DeviceTextType == DeviceTextDescription) {

            PMESSAGE_RESOURCE_ENTRY messageEntry;

            status = RtlFindMessage(pdoExtension->DriverObject->DriverStart,
                                    11,
                                    LANG_NEUTRAL,
                                    PCIIDEX_IDE_CHANNEL,
                                    &messageEntry);

            if (!NT_SUCCESS(status)) {

                returnString = NULL;

            } else {

                if (messageEntry->Flags & MESSAGE_RESOURCE_UNICODE) {

                    //
                    // Our caller wants a copy they can free, also we need to
                    // strip the trailing CR/LF.  The Length field of the
                    // message structure includes both the header and the
                    // actual text.
                    //
                    // Note: The message resource entry length will always be a
                    // multiple of 4 bytes in length.  The 2 byte null terminator
                    // could be in either the last or second last WCHAR position.
                    //

                    ULONG textLength;

                    textLength = messageEntry->Length -
                                 FIELD_OFFSET(MESSAGE_RESOURCE_ENTRY, Text) -
                                 2 * sizeof(WCHAR);

                    returnString = (PWCHAR)(messageEntry->Text);
                    if (returnString[textLength / sizeof(WCHAR)] == 0) {
                        textLength -= sizeof(WCHAR);
                    }

                    returnString = ExAllocatePool(PagedPool, textLength);

                    if (returnString) {

                        //
                        // Copy the text except for the CR/LF/NULL
                        //

                        textLength -= sizeof(WCHAR);
                        RtlCopyMemory(returnString, messageEntry->Text, textLength);

                        //
                        // New NULL terminator.
                        //

                        returnString[textLength / sizeof(WCHAR)] = 0;
                    }

                } else {

                    //
                    // RtlFindMessage returns a string?   Wierd.
                    //

                    ANSI_STRING    ansiDescription;
                    UNICODE_STRING unicodeDescription;

                    RtlInitAnsiString(&ansiDescription, messageEntry->Text);

                    //
                    // Strip CR/LF off the end of the string.
                    //

                    ansiDescription.Length -= 2;

                    //
                    // Turn it all into a unicode string so we can grab the buffer
                    // and return that to our caller.
                    //

                    status = RtlAnsiStringToUnicodeString(
                                 &unicodeDescription,
                                 &ansiDescription,
                                 TRUE
                                 );

                    returnString = unicodeDescription.Buffer;
                }
            }
        } else if (thisIrpSp->Parameters.QueryDeviceText.DeviceTextType == DeviceTextLocationInformation) {

            stringLen = 100;

            returnString = ExAllocatePool (
                               PagedPool,
                               stringLen
                               );

            if (returnString) {

                swprintf(returnString, L"%ws Channel",
                         ((pdoExtension->ChannelNumber == 0) ? L"Primary" :
                                                               L"Secondary"));

                RtlInitUnicodeString (&unicodeString, returnString);

                //
                // null terminate it
                //
                unicodeString.Buffer[unicodeString.Length/sizeof(WCHAR) + 0] = L'\0';
            }
        }

        Irp->IoStatus.Information = (ULONG_PTR) returnString;
        if (Irp->IoStatus.Information) {

            status = STATUS_SUCCESS;
        } else {

            //
            // return the original error code
            //
            status = Irp->IoStatus.Status;
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest(Irp, IO_NO_INCREMENT);
    return status;

} // ChannelQueryText


NTSTATUS
PciIdeChannelQueryInterface (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION          thisIrpSp;
    PCHANPDO_EXTENSION          pdoExtension;
    NTSTATUS                    status;

    PAGED_CODE();

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        status = Irp->IoStatus.Status;
        thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

        if (RtlEqualMemory(&GUID_PCIIDE_BUSMASTER_INTERFACE,
                thisIrpSp->Parameters.QueryInterface.InterfaceType,
                sizeof(GUID)) &&
            (thisIrpSp->Parameters.QueryInterface.Size >=
                sizeof(PCIIDE_BUSMASTER_INTERFACE))) {

            //
            // The query is for an busmaster interface
            //
            status = BmQueryInterface (
                         pdoExtension,
                         (PPCIIDE_BUSMASTER_INTERFACE) thisIrpSp->Parameters.QueryInterface.Interface
                         );

        } else if (RtlEqualMemory(&GUID_PCIIDE_SYNC_ACCESS_INTERFACE,
                       thisIrpSp->Parameters.QueryInterface.InterfaceType,
                       sizeof(GUID)) &&
                  (thisIrpSp->Parameters.QueryInterface.Size >=
                       sizeof(PCIIDE_SYNC_ACCESS_INTERFACE))) {

            //
            // The query is for dual ide channel sync access interface
            //
            status = PciIdeQuerySyncAccessInterface (
                         pdoExtension,
                         (PPCIIDE_SYNC_ACCESS_INTERFACE) thisIrpSp->Parameters.QueryInterface.Interface
                         );

        } else if (RtlEqualMemory(&GUID_PCIIDE_XFER_MODE_INTERFACE,
                       thisIrpSp->Parameters.QueryInterface.InterfaceType,
                       sizeof(GUID)) &&
                  (thisIrpSp->Parameters.QueryInterface.Size >=
                       sizeof(PCIIDE_XFER_MODE_INTERFACE))) {

            //
            // The query is for dual ide channel sync access interface
            //
            status = PciIdeChannelTransferModeInterface (
                         pdoExtension,
                         (PPCIIDE_XFER_MODE_INTERFACE) thisIrpSp->Parameters.QueryInterface.Interface
                         );

#ifdef ENABLE_NATIVE_MODE

        } else if (RtlEqualMemory(&GUID_PCIIDE_INTERRUPT_INTERFACE,
                       thisIrpSp->Parameters.QueryInterface.InterfaceType,
                       sizeof(GUID)) &&
                  (thisIrpSp->Parameters.QueryInterface.Size >=
                       sizeof(PCIIDE_INTERRUPT_INTERFACE))) {

            //
            // The query is for the channel interrupt interface
            //
            status = PciIdeChannelInterruptInterface (
                         pdoExtension,
                         (PPCIIDE_INTERRUPT_INTERFACE) thisIrpSp->Parameters.QueryInterface.Interface
                         );
#endif

        } else if (RtlEqualMemory(&GUID_PCIIDE_REQUEST_PROPER_RESOURCES,
                       thisIrpSp->Parameters.QueryInterface.InterfaceType,
                       sizeof(GUID)) &&
                  (thisIrpSp->Parameters.QueryInterface.Size >=
                       sizeof(PCIIDE_REQUEST_PROPER_RESOURCES))) {

            //
            // The query is for dual ide channel sync access interface
            //
            *((PCIIDE_REQUEST_PROPER_RESOURCES *) thisIrpSp->Parameters.QueryInterface.Interface) =
                PciIdeChannelRequestProperResources;
            status = STATUS_SUCCESS;
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // PciIdeChannelQueryInterface

#ifdef ENABLE_NATIVE_MODE

NTSTATUS
PciIdeInterruptControl (
	IN PVOID Context,
	IN ULONG DisConnect
	)
/*++
Description:

	Connects or disconnects the controller ISR. This intermediate function provides
	a clean interface to atapi. Since this is not a very frequently used function
	we can afford the extra call
	
Arguments :
	
	Context : Pdo extension
	Disconnect: 1 to disconnect and 0 to connect

	
Return Value:

	STATUS_SUCCESS : if the operation succeeds.	
	
--*/
{
	PCHANPDO_EXTENSION pdoExtension = Context;

	NTSTATUS status;

	//
	// Call the controller's interrupt control routine
	//
	status = ControllerInterruptControl(pdoExtension->ParentDeviceExtension,
										pdoExtension->ChannelNumber,
										DisConnect
										);

	return status;
}

NTSTATUS
PciIdeChannelInterruptInterface (
    IN PCHANPDO_EXTENSION PdoExtension,
    PPCIIDE_INTERRUPT_INTERFACE InterruptInterface
    )
{
	//
	// Return an interface only if we are in native mode.
	// Saves a few function calls on non native mode controllers
	//
	if (IsNativeMode(PdoExtension->ParentDeviceExtension)) {

		InterruptInterface->Context = PdoExtension;
		InterruptInterface->PciIdeInterruptControl = PciIdeInterruptControl;

		DebugPrint((1, "PciIdex: returing interrupt interface for channel %x\n", 
					PdoExtension->ChannelNumber));
	}

	return STATUS_SUCCESS;
}
#endif

NTSTATUS
PciIdeChannelTransferModeInterface (
    IN PCHANPDO_EXTENSION PdoExtension,
    PPCIIDE_XFER_MODE_INTERFACE XferMode
    )
{
    XferMode->TransferModeSelect = PciIdeChannelTransferModeSelect;
    XferMode->TransferModeTimingTable = PdoExtension->ParentDeviceExtension->
                                                                TransferModeTimingTable;
    XferMode->TransferModeTableLength = PdoExtension->ParentDeviceExtension->
                                                                TransferModeTableLength;
    XferMode->Context = PdoExtension;
    XferMode->VendorSpecificDeviceExtension=PdoExtension->
                    ParentDeviceExtension->VendorSpecificDeviceEntension;


    XferMode->UdmaModesSupported = PdoExtension->
                                    ParentDeviceExtension->
                                        ControllerProperties.PciIdeUdmaModesSupported;
    //
    //NULL is ok. checked in the IdePortDispatchRoutine
    //
    XferMode->UseDma = PdoExtension->
                            ParentDeviceExtension->
                                ControllerProperties.PciIdeUseDma;

    if (PdoExtension->
            ParentDeviceExtension->
                ControllerProperties.PciIdeTransferModeSelect) {

        //
        // Looks like the miniport fully support timing register programming
        //

        XferMode->SupportLevel = PciIdeFullXferModeSupport;

    } else {

        //
        // Looks like the miniport doens't support timing register programming
        //
        XferMode->SupportLevel = PciIdeBasicXferModeSupport;
    }

    //
    // This function can't fail
    //
    return STATUS_SUCCESS;
} // PciIdeChannelTransferModeInterface

NTSTATUS
PciIdeChannelTransferModeSelect (
    IN PCHANPDO_EXTENSION PdoExtension,
    PPCIIDE_TRANSFER_MODE_SELECT XferMode
    )
{
    ULONG i;
    NTSTATUS status;
    UCHAR    bmRawStatus;
    struct {
        USHORT  VendorID;
        USHORT  DeviceID;
    } pciId;

    //
    // check the registry for bus master mode
    // and overwrite the current if necessary
    //
    // if DMADetection = 0, clear current dma mode
    // if DMADetection = 1, set current mode
    // if DMADetection = 2, clear all current mode

    if (PdoExtension->DmaDetectionLevel == DdlPioOnly) {

        bmRawStatus = 0;

        for (i=0; i<MAX_IDE_DEVICE * MAX_IDE_LINE; i++) {

            XferMode->DeviceTransferModeSupported[i] &= PIO_SUPPORT;
            XferMode->DeviceTransferModeCurrent[i] &= PIO_SUPPORT;
        }

    } else if (PdoExtension->DmaDetectionLevel == DdlFirmwareOk) {

        if (PdoExtension->BmRegister) {

            //
            // get the firmware ok bits
            // the current value seems to be 0??
			//
            bmRawStatus = PdoExtension->BootBmStatus;

        } else {

            bmRawStatus = 0;
        }

    } else if (PdoExtension->DmaDetectionLevel == DdlAlways) {

        if (PdoExtension->BmRegister) {

            //
            // fake the firmware ok bits
            //
            bmRawStatus = BUSMASTER_DEVICE0_DMA_OK | BUSMASTER_DEVICE1_DMA_OK;

        } else {

            bmRawStatus = 0;
        }

    } else {

        bmRawStatus = 0;
    }

    //
    // in case there is no miniport support
    //
    status = STATUS_UNSUCCESSFUL;

    if (PdoExtension->DmaDetectionLevel != DdlPioOnly) {

        //
        // set up the channel number since the caller (atapi)
        // doesn't know how.
        //
        XferMode->Channel = PdoExtension->ChannelNumber;

        //
        // This decides whether UDMA modes > 2 should be supported or not
        // Currently impacts only the intel chipsets
        //
        XferMode->EnableUDMA66 = PdoExtension->ParentDeviceExtension->EnableUDMA66;

        if (PdoExtension->
                ParentDeviceExtension->
                    ControllerProperties.PciIdeTransferModeSelect) {

            status = (*PdoExtension->ParentDeviceExtension->ControllerProperties.PciIdeTransferModeSelect) (
                         PdoExtension->ParentDeviceExtension->VendorSpecificDeviceEntension,
                         XferMode
                         );
        }
    }

    DebugPrint((1, "Select in PCIIDEX: RawStatus=%x, current[0]=%x, current[1]=%x\n",
                bmRawStatus,
                XferMode->DeviceTransferModeCurrent[0],
                XferMode->DeviceTransferModeCurrent[1]));

    if (!NT_SUCCESS(status)) {

        status = STATUS_SUCCESS;

        if ((bmRawStatus & BUSMASTER_DEVICE0_DMA_OK) == 0) {

            XferMode->DeviceTransferModeSelected[0] = XferMode->DeviceTransferModeCurrent[0] & PIO_SUPPORT;
        } else {

            XferMode->DeviceTransferModeSelected[0] = XferMode->DeviceTransferModeCurrent[0];
        }

        if ((bmRawStatus & BUSMASTER_DEVICE1_DMA_OK) == 0) {

            XferMode->DeviceTransferModeSelected[1] = XferMode->DeviceTransferModeCurrent[1] & PIO_SUPPORT;
        } else {

            XferMode->DeviceTransferModeSelected[1] = XferMode->DeviceTransferModeCurrent[1];
        }

        for (i=0; i<MAX_IDE_DEVICE; i++) {

            DebugPrint((1, "Select in PCIIDEX: xfermode[%d]=%x\n",i,
                PdoExtension->ParentDeviceExtension->ControllerProperties.
                    SupportedTransferMode[PdoExtension->ChannelNumber][i]));


            if ((PdoExtension->ParentDeviceExtension->ControllerProperties.DefaultPIO == 1) && 
                (IS_DEFAULT(XferMode->UserChoiceTransferMode[i]))) {
                XferMode->DeviceTransferModeSelected[i] &= PIO_SUPPORT;
            }
            else  {
                XferMode->DeviceTransferModeSelected[i] &=
                    PdoExtension->ParentDeviceExtension->ControllerProperties.
                        SupportedTransferMode[PdoExtension->ChannelNumber][i];
            }
        }
    }

    return status;

} // PciIdeChannelTransferModeSelect

NTSTATUS
ChannelQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  thisIrpSp;
    PDEVICE_RELATIONS   deviceRelations;
    NTSTATUS            status;

    PAGED_CODE();

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

    switch (thisIrpSp->Parameters.QueryDeviceRelations.Type) {

        case TargetDeviceRelation:

            deviceRelations = ExAllocatePool (NonPagedPool, sizeof(*deviceRelations));

            if (deviceRelations != NULL) {

                deviceRelations->Count = 1;
                deviceRelations->Objects[0] = DeviceObject;

                ObReferenceObjectByPointer(DeviceObject,
                                           0,
                                           0,
                                           KernelMode);

                Irp->IoStatus.Status = STATUS_SUCCESS;
                Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
            } else {

                Irp->IoStatus.Status = STATUS_NO_MEMORY;
                Irp->IoStatus.Information = 0;
            }
            break;
    }

    status = Irp->IoStatus.Status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // ChannelQueryDeviceRelations

NTSTATUS
ChannelUsageNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS           status;
    PCHANPDO_EXTENSION pdoExtension;
    PIO_STACK_LOCATION irpSp;
    PDEVICE_OBJECT targetDeviceObject;
    IO_STATUS_BLOCK ioStatus;
    PULONG deviceUsageCount;

    PAGED_CODE();

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension == NULL) {

        status = STATUS_NO_SUCH_DEVICE;

    } else {

        irpSp = IoGetCurrentIrpStackLocation(Irp);

        if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging) {

            //
            // Adjust the paging path count for this device.
            //
            deviceUsageCount = &pdoExtension->PagingPathCount;

            //
            // changing device state
            //
            SETMASK (pdoExtension->PnPDeviceState, PNP_DEVICE_NOT_DISABLEABLE);
            IoInvalidateDeviceState(pdoExtension->DeviceObject);

        } else if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeHibernation) {

            //
            // Adjust the paging path count for this device.
            //
            deviceUsageCount = &pdoExtension->HiberPathCount;

        } else if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeDumpFile) {

            //
            // Adjust the paging path count for this device.
            //
            deviceUsageCount = &pdoExtension->CrashDumpPathCount;

        } else {

            deviceUsageCount = NULL;
            DebugPrint ((0,
                         "PCIIDEX: Unknown IRP_MN_DEVICE_USAGE_NOTIFICATION type: 0x%x\n",
                         irpSp->Parameters.UsageNotification.Type));
        }

        //
        // get the top of parent's device stack
        //
        targetDeviceObject = IoGetAttachedDeviceReference(
                                 pdoExtension->
                                     ParentDeviceExtension->
                                         DeviceObject);

        ioStatus.Status = STATUS_NOT_SUPPORTED;
        status = PciIdeXSyncSendIrp (targetDeviceObject, irpSp, &ioStatus);

        ObDereferenceObject (targetDeviceObject);

        if (NT_SUCCESS(status)) {

            if (deviceUsageCount) {

                IoAdjustPagingPathCount (
                    deviceUsageCount,
                    irpSp->Parameters.UsageNotification.InPath
                    );
            }
        }
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;

} // ChannelUsageNotification

NTSTATUS
ChannelQueryPnPDeviceState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PCHANPDO_EXTENSION pdoExtension;

    pdoExtension = ChannelGetPdoExtension(DeviceObject);

    if (pdoExtension) {

        PPNP_DEVICE_STATE deviceState;

        DebugPrint((2, "QUERY_DEVICE_STATE for PDOE 0x%x\n", pdoExtension));

        deviceState = (PPNP_DEVICE_STATE) &Irp->IoStatus.Information;
        SETMASK((*deviceState), pdoExtension->PnPDeviceState);

        CLRMASK (pdoExtension->PnPDeviceState, PNP_DEVICE_FAILED | PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED);

        status = STATUS_SUCCESS;

    } else {

        status = STATUS_DEVICE_DOES_NOT_EXIST;
    }

    Irp->IoStatus.Status = status;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // ChannelQueryPnPDeviceState


VOID
PciIdeChannelRequestProperResources(
    IN PDEVICE_OBJECT DeviceObject
    )
{
    PCHANPDO_EXTENSION pdoExtension;

    //
    // the FDO thinks the channel is not empty
    // anymore
    //
    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (pdoExtension) {
        pdoExtension->EmptyChannel = FALSE;
        SETMASK (pdoExtension->PnPDeviceState, PNP_DEVICE_FAILED | PNP_DEVICE_RESOURCE_REQUIREMENTS_CHANGED);
        IoInvalidateDeviceState (DeviceObject);
    }
}

NTSTATUS
ChannelFilterResourceRequirements (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    NTSTATUS status;
    PCHANPDO_EXTENSION pdoExtension;
    PIO_STACK_LOCATION thisIrpSp;
    ULONG             i, j;

    PIO_RESOURCE_REQUIREMENTS_LIST  requirementsListIn = NULL;
    PIO_RESOURCE_LIST               resourceListIn;
    PIO_RESOURCE_DESCRIPTOR         resourceDescriptorIn;

    PIO_RESOURCE_LIST               resourceListOut;
    PIO_RESOURCE_DESCRIPTOR         resourceDescriptorOut;

    ULONG newCount;

    PAGED_CODE();

    status = STATUS_NOT_SUPPORTED;

    //
    // the value will stay NULL if no filtering required
    //

#ifdef IDE_FILTER_PROMISE_TECH_RESOURCES
    if (NT_SUCCESS(ChannelFilterPromiseTechResourceRequirements (DeviceObject, Irp))) {
        goto getout;
    }
#endif // IDE_FILTER_PROMISE_TECH_RESOURCES

    pdoExtension = ChannelGetPdoExtension(DeviceObject);
    if (!pdoExtension) {
        goto getout;
    }


    //
    // filter out irq only if the channel is emtpy
    //
    if (!pdoExtension->EmptyChannel) {

        goto getout;
    }

    if (NT_SUCCESS(Irp->IoStatus.Status)) {
        //
        // already filtered.
        //
        requirementsListIn = (PIO_RESOURCE_REQUIREMENTS_LIST) Irp->IoStatus.Information;
    } else {
        thisIrpSp = IoGetCurrentIrpStackLocation(Irp);
        requirementsListIn = thisIrpSp->Parameters.FilterResourceRequirements.IoResourceRequirementList;
    }

    if (requirementsListIn == NULL) {
        goto getout;
    }

    if (requirementsListIn->AlternativeLists == 0) {
        goto getout;
    }

    resourceListIn = requirementsListIn->List;
    resourceListOut = resourceListIn;
    for (j=0; j<requirementsListIn->AlternativeLists; j++) {

        ULONG resCount;
        resourceDescriptorIn = resourceListIn->Descriptors;

        RtlMoveMemory (
           resourceListOut,
           resourceListIn,
           FIELD_OFFSET(IO_RESOURCE_LIST, Descriptors));
        resourceDescriptorOut = resourceListOut->Descriptors;

        resCount = resourceListIn->Count;
        for (i=newCount=0; i<resCount; i++) {

            if (resourceDescriptorIn[i].Type != CmResourceTypeInterrupt) {
                resourceDescriptorOut[newCount] = resourceDescriptorIn[i];
                newCount++;
            } else {
                status = STATUS_SUCCESS;
            }
        }
        resourceListIn = (PIO_RESOURCE_LIST) (resourceDescriptorIn + resCount);
        resourceListOut->Count = newCount;
        resourceListOut = (PIO_RESOURCE_LIST) (resourceDescriptorOut + newCount);
    }


getout:

    if (status != STATUS_NOT_SUPPORTED) {
        Irp->IoStatus.Status = status;
        Irp->IoStatus.Information = (ULONG_PTR) requirementsListIn;
    } else {
        status = Irp->IoStatus.Status;
    }
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\pciidex\chanpdo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       chanpdo.h
//
//--------------------------------------------------------------------------

#if !defined (___chanpdo_h___)
#define ___chanpdo_h___


typedef enum BMSTATE {
    BmIdle,
    BmSet,
    BmArmed,
    BmDisarmed,
} BMSTATE;


#define PDOS_STARTED          (1 << 0)
#define PDOS_DEADMEAT         (1 << 1)
#define PDOS_STOPPED          (1 << 2)
#define PDOS_REMOVED          (1 << 3)
#define PDOS_SURPRISE_REMOVED (1 << 4)
#define PDOS_DISABLED_BY_USER (1 << 5)

typedef struct _PHYSICAL_REGION_DESCRIPTOR * PPHYSICAL_REGION_DESCRIPTOR;

typedef struct _CHANNEL_PDO_EXTENSION {

    EXTENSION_COMMON_HEADER;

    PCTRLFDO_EXTENSION  ParentDeviceExtension;

    ULONG               ChannelNumber;

    KSPIN_LOCK          SpinLock;
    ULONG               PdoState;

    DMADETECTIONLEVEL   DmaDetectionLevel;

    ULONG               RefCount;

    ULONG               PnPDeviceState;

    //
    // Busmaster Properties
    //
    PIDE_BUS_MASTER_REGISTERS   BmRegister;
    PDMA_ADAPTER                DmaAdapterObject;
    ULONG                       MaximumPhysicalPages;
    PPHYSICAL_REGION_DESCRIPTOR RegionDescriptorTable;
    PHYSICAL_ADDRESS            PhysicalRegionDescriptorTable;
    PVOID                       DataVirtualAddress;
    PSCATTER_GATHER_LIST        HalScatterGatherList;
    ULONG                       TransferLength;
    PVOID                       MapRegisterBase;
    PMDL                        Mdl;
    BOOLEAN                     DataIn;
    VOID                        (* BmCallback) (PVOID Context);
    PVOID                       BmCallbackContext;
    BMSTATE                     BmState;

    UCHAR                       BootBmStatus;

    BOOLEAN                     EmptyChannel;
    BOOLEAN                     NeedToCallIoInvalidateDeviceRelations;

} CHANPDO_EXTENSION, *PCHANPDO_EXTENSION;

PCHANPDO_EXTENSION
ChannelGetPdoExtension(
    PDEVICE_OBJECT DeviceObject
    );

ULONG
ChannelUpdatePdoState(
    PCHANPDO_EXTENSION PdoExtension,
    ULONG SetFlags,
    ULONG ClearFlags
    );

NTSTATUS
ChannelStartDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelQueryStopRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelStopDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelStopChannel (
    PCHANPDO_EXTENSION pdoExtension
    );

NTSTATUS
ChannelQueryId (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

PWSTR
ChannelBuildDeviceId(
    IN PCHANPDO_EXTENSION pdoExtension
    );

PWSTR
ChannelBuildInstanceId(
    IN PCHANPDO_EXTENSION pdoExtension
    );

PWSTR
ChannelBuildCompatibleId(
    IN PCHANPDO_EXTENSION pdoExtension
    );

PWSTR
ChannelBuildHardwareId(
    IN PCHANPDO_EXTENSION pdoExtension
    );

NTSTATUS
ChannelQueryCapabitilies (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ChannelQueryResources(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChannelQueryResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
ChannelQueryResourceRequirementsCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

NTSTATUS
ChannelInternalDeviceIoControl(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );
    
NTSTATUS
ChannelQueryText (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PciIdeChannelQueryInterface (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
    
NTSTATUS
PciIdeChannelTransferModeInterface (
    IN PCHANPDO_EXTENSION PdoExtension,
    PPCIIDE_XFER_MODE_INTERFACE XferMode
    );

NTSTATUS
PciIdeChannelTransferModeSelect (
    IN PCHANPDO_EXTENSION PdoExtension,
    PPCIIDE_TRANSFER_MODE_SELECT XferMode
    );
    
NTSTATUS
ChannelQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
                         
NTSTATUS
ChannelUsageNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
            
NTSTATUS
ChannelQueryPnPDeviceState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
                         
VOID
PciIdeChannelRequestProperResources(
    IN PDEVICE_OBJECT DeviceObject
    );

NTSTATUS
ChannelFilterResourceRequirements (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

#ifdef ENABLE_NATIVE_MODE
NTSTATUS
PciIdeInterruptControl (
	IN PVOID Context,
	IN ULONG DisConnect
	);

NTSTATUS
PciIdeChannelInterruptInterface (
    IN PCHANPDO_EXTENSION PdoExtension,
    PPCIIDE_INTERRUPT_INTERFACE InterruptInterface
    );
#endif

#endif // ___chanpdo_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\pciidex\ctlrfdo.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ctlrfdo.h
//
//--------------------------------------------------------------------------

#if !defined (___ctrlfdo_h___)
#define ___ctrlfdo_h___

//
// DeviceControlsFlags
//
// WARNING: all of these flags must be correctly reflected 
//          in the mshdc.inf and txtsetuo.sif files
//
#define PCIIDEX_DCF_NO_ATAPI_DMA        (1 << 0)

//
// determine how often we rescan for new unknown child.
// unknown child is IDE channel which we don't know 
// it is enabled or not unless we pnp start the channel 
// and poke at it to find out.
#define MIN_BUS_SCAN_PERIOD_IN_SEC      90

#define IsNativeMode(d) ((d)->NativeMode[0] && (d)->NativeMode[1])

struct _CONTROLLER_FDO_EXTENSION;
typedef struct _CONTROLLER_FDO_EXTENSION * PCTRLFDO_EXTENSION;
typedef struct _IDE_BUS_MASTER_REGISTERS * PIDE_BUS_MASTER_REGISTERS;

typedef struct _DRIVER_OBJECT_EXTENSION {

    PCONTROLLER_PROPERTIES PciIdeGetControllerProperties;

    ULONG                  ExtensionSize;

} DRIVER_OBJECT_EXTENSION, *PDRIVER_OBJECT_EXTENSION;

typedef struct _FDO_POWER_CONTEXT {

    PIRP               OriginalPowerIrp;
    POWER_STATE_TYPE   newPowerType;
    POWER_STATE        newPowerState;

} FDO_POWER_CONTEXT, *PFDO_POWER_CONTEXT;

typedef struct _PCIIDE_INTERRUPT_CONTEXT {

	PVOID	DeviceExtension;
	ULONG	ChannelNumber;

} PCIIDE_INTERRUPT_CONTEXT, *PPCIIDE_INTERRUPT_CONTEXT;

struct _CHANNEL_PDO_EXTENSION;
typedef struct _CHANNEL_PDO_EXTENSION * PCHANPDO_EXTENSION;

typedef struct _CONTROLLER_FDO_EXTENSION {

    EXTENSION_COMMON_HEADER;

    ULONG ControllerNumber;

    PDEVICE_OBJECT  PhysicalDeviceObject;

    PCHANPDO_EXTENSION  ChildDeviceExtension[MAX_IDE_CHANNEL]; 

    ULONG   NumberOfChildren;

    //
    // Interlocked* protected
    //
    ULONG   NumberOfChildrenPowerUp;

    //
    // native mode channels
    //
    BOOLEAN NativeMode[MAX_IDE_CHANNEL];

    //
    // initialized by AnalyzeResourceList()
    //
    BOOLEAN             PdoCmdRegResourceFound[MAX_IDE_CHANNEL];
    BOOLEAN             PdoCtrlRegResourceFound[MAX_IDE_CHANNEL];
    BOOLEAN             PdoInterruptResourceFound[MAX_IDE_CHANNEL];

    ULONG               PdoResourceListSize[MAX_IDE_CHANNEL];
    PCM_RESOURCE_LIST   PdoResourceList[MAX_IDE_CHANNEL];
    ULONG               BmResourceListSize;
    PCM_RESOURCE_LIST   BmResourceList;

    //
    // Bus Master Register
    //
    ULONG                     BusMasterBaseAddressSpace;
    PIDE_BUS_MASTER_REGISTERS TranslatedBusMasterBaseAddress;
    //
    // Vendor Specific Controller Properties
    //
    IDE_CONTROLLER_PROPERTIES ControllerProperties;

    //
    // Vendor Specific Device Extension
    //
    PVOID   VendorSpecificDeviceEntension;

    //
    // Controller Object for serailizing access to broken PCI-IDE controller
    //
    //
    PCONTROLLER_OBJECT ControllerObject;

    //
    // mutex for setting pci config data
    //
    KSPIN_LOCK  PciConfigDataLock;

    //
    // Special device specific parameter
    //
    ULONG DeviceControlsFlags;

    //
    // Bus Interface
    //
    BUS_INTERFACE_STANDARD BusInterface;

    //
    // Last BusScan Time in sec
    //
    ULONG LastBusScanTime;

    //
    // Flag to enable udma66
    //
    ULONG EnableUDMA66;

    //
    // Timings for the different transfer modes
    //
    PULONG TransferModeTimingTable;

    //
    // Length of the table
    //
    ULONG TransferModeTableLength;

	//
	// Pre-alloced context structure for power routines
	//
    FDO_POWER_CONTEXT FdoPowerContext[MAX_IDE_CHANNEL];

#if DBG
    ULONG   PowerContextLock[MAX_IDE_CHANNEL];
#endif

#ifdef ENABLE_NATIVE_MODE
	//
	// Interrupt object
	//
    PKINTERRUPT InterruptObject[MAX_IDE_CHANNEL]; 

	//
	// Context structure for the ISR
	//
	PCIIDE_INTERRUPT_CONTEXT InterruptContext[MAX_IDE_CHANNEL];

	//
	// IDE resources for native mode controllers
	//
	IDE_RESOURCE IdeResource;

    //
    // Base register locations
    //
    IDE_REGISTERS_1            BaseIoAddress1[MAX_IDE_CHANNEL];
    IDE_REGISTERS_2            BaseIoAddress2[MAX_IDE_CHANNEL];

	//
	//interrupt
	//
    PCM_PARTIAL_RESOURCE_DESCRIPTOR IrqPartialDescriptors[MAX_IDE_CHANNEL];
    //
    // Register length.
    //
    ULONG   BaseIoAddress1Length[MAX_IDE_CHANNEL];
    ULONG   BaseIoAddress2Length[MAX_IDE_CHANNEL];

    //
    // Max ide device/target-id
    //
    ULONG   MaxIdeDevice[MAX_IDE_CHANNEL];
    ULONG   MaxIdeTargetId[MAX_IDE_CHANNEL];

	//
	// Flags to close the interrupt window
	//
	BOOLEAN	ControllerIsrInstalled;
	BOOLEAN	NativeInterruptEnabled;
	BOOLEAN NoBusMaster[MAX_IDE_CHANNEL];

	//
	// Native Ide Interface obtained from PCI
	//
	PCI_NATIVE_IDE_INTERFACE	NativeIdeInterface;
#endif

} CTRLFDO_EXTENSION, *PCTRLFDO_EXTENSION;

NTSTATUS
ControllerAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    );

NTSTATUS
ControllerStartDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ControllerStartDeviceCompletionRoutine(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN OUT PIRP            Irp,
    IN OUT PVOID           Context
    );

NTSTATUS
ControllerStopDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ControllerStopController (
    IN PCTRLFDO_EXTENSION fdoExtension
    );

NTSTATUS
ControllerSurpriseRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ControllerRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ControllerRemoveDeviceCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    );

NTSTATUS
ControllerQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ControllerQueryResourceRequirements(
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp
    );

NTSTATUS
LoadControllerParameters (
    PCTRLFDO_EXTENSION FdoExtension
    );

NTSTATUS
AnalyzeResourceList (
    PCTRLFDO_EXTENSION FdoExtension,
    PCM_RESOURCE_LIST  ResourceList
    );

VOID
ControllerOpMode (
    IN PCTRLFDO_EXTENSION FdoExtension
    );
                         
VOID
EnablePCIBusMastering ( 
    IN PCTRLFDO_EXTENSION FdoExtension
    );
                         
IDE_CHANNEL_STATE
PciIdeChannelEnabled (
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN ULONG Channel
);
      
VOID
ControllerTranslatorNull (
    IN PVOID Context
    );
      
NTSTATUS
ControllerTranslateResource (
    IN  PVOID Context,
    IN  PCM_PARTIAL_RESOURCE_DESCRIPTOR Source,
    IN  RESOURCE_TRANSLATION_DIRECTION Direction,
    IN  ULONG AlternativesCount OPTIONAL,
    IN  IO_RESOURCE_DESCRIPTOR Alternatives[] OPTIONAL,
    IN  PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR Target
    );
    
NTSTATUS
ControllerTranslateRequirement (
    IN  PVOID Context,
    IN  PIO_RESOURCE_DESCRIPTOR Source,
    IN  PDEVICE_OBJECT PhysicalDeviceObject,
    OUT PULONG TargetCount,
    OUT PIO_RESOURCE_DESCRIPTOR *Target
    );
    
NTSTATUS
ControllerQueryInterface (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );
    
VOID
PciIdeInitControllerProperties (
    IN PCTRLFDO_EXTENSION FdoExtension
    );
                         
NTSTATUS
ControllerUsageNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
ControllerUsageNotificationCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );
                         
NTSTATUS
PciIdeGetBusStandardInterface(
    IN PCTRLFDO_EXTENSION FdoExtension
    );
                         
NTSTATUS
ControllerQueryPnPDeviceState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PciIdeCreateTimingTable (
    IN PCTRLFDO_EXTENSION FdoExtension
    );

#ifdef ENABLE_NATIVE_MODE
NTSTATUS
ControllerInterruptControl (
	IN PCTRLFDO_EXTENSION 	FdoExtension,
	IN ULONG				Channel,
	IN ULONG 				Disconnect
	);

BOOLEAN
ControllerInterrupt(
    IN PKINTERRUPT Interrupt,
	PVOID Context
	);

NTSTATUS
PciIdeGetNativeModeInterface(
    IN PCTRLFDO_EXTENSION FdoExtension
    );

#define ControllerEnableInterrupt(FdoExtension) \
	if (FdoExtension->NativeIdeInterface.InterruptControl) { \
		(FdoExtension->NativeIdeInterface).InterruptControl((FdoExtension->NativeIdeInterface).Context,\
															TRUE);\
	}
#define ControllerDisableInterrupt(FdoExtension) \
	if (FdoExtension->NativeIdeInterface.InterruptControl) { \
		(FdoExtension->NativeIdeInterface).InterruptControl((FdoExtension->NativeIdeInterface).Context,\
															FALSE);\
	}

#endif //ENABLE_NATIVE_MODE
                         
#endif // ___ctrlfdo_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\pciidex\ctlrfdo.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       ctlrfdo.c
//
//--------------------------------------------------------------------------

#include "pciidex.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, ControllerAddDevice)
#pragma alloc_text(PAGE, ControllerStartDevice)
#pragma alloc_text(PAGE, ControllerStopDevice)
#pragma alloc_text(PAGE, ControllerStopController)
#pragma alloc_text(PAGE, ControllerSurpriseRemoveDevice)
#pragma alloc_text(PAGE, ControllerRemoveDevice)
#pragma alloc_text(PAGE, ControllerQueryDeviceRelations)
#pragma alloc_text(PAGE, ControllerQueryInterface)
#pragma alloc_text(PAGE, AnalyzeResourceList)
#pragma alloc_text(PAGE, ControllerOpMode)
#pragma alloc_text(PAGE, PciIdeChannelEnabled)
#pragma alloc_text(PAGE, PciIdeCreateTimingTable)
#pragma alloc_text(PAGE, PciIdeInitControllerProperties)
#pragma alloc_text(PAGE, ControllerUsageNotification)
#pragma alloc_text(PAGE, PciIdeGetBusStandardInterface)
#pragma alloc_text(PAGE, ControllerQueryPnPDeviceState)

#pragma alloc_text(NONPAGE, EnablePCIBusMastering)
#pragma alloc_text(NONPAGE, ControllerUsageNotificationCompletionRoutine)
#pragma alloc_text(NONPAGE, ControllerRemoveDeviceCompletionRoutine)
#pragma alloc_text(NONPAGE, ControllerStartDeviceCompletionRoutine)
#endif // ALLOC_PRAGMA

//
// Must match mshdc.inf
//
static PWCHAR ChannelEnableMaskName[MAX_IDE_CHANNEL] = {
     L"MasterOnMask",
     L"SlaveOnMask"
};
static PWCHAR ChannelEnablePciConfigOffsetName[MAX_IDE_CHANNEL] = {
     L"MasterOnConfigOffset",
     L"SlaveOnConfigOffset"
};


static ULONG PciIdeXNextControllerNumber = 0;
static ULONG PciIdeXNextChannelNumber = 0;

NTSTATUS
ControllerAddDevice(
    IN PDRIVER_OBJECT DriverObject,
    IN PDEVICE_OBJECT PhysicalDeviceObject
    )
{
    PDEVICE_OBJECT              deviceObject;
    PCTRLFDO_EXTENSION          fdoExtension;
    NTSTATUS                    status;
    PDRIVER_OBJECT_EXTENSION    driverObjectExtension;
    ULONG                       deviceExtensionSize;
    UNICODE_STRING              deviceName;
    WCHAR                       deviceNameBuffer[64];
    ULONG                       controllerNumber;

    PAGED_CODE();

    driverObjectExtension =
        (PDRIVER_OBJECT_EXTENSION) IoGetDriverObjectExtension(
                                       DriverObject,
                                       DRIVER_OBJECT_EXTENSION_ID
                                       );
    ASSERT (driverObjectExtension);

    //
    // devobj name
    //
    controllerNumber = InterlockedIncrement(&PciIdeXNextControllerNumber) - 1;
    swprintf(deviceNameBuffer, DEVICE_OJBECT_BASE_NAME L"\\PciIde%d", controllerNumber);
    RtlInitUnicodeString(&deviceName, deviceNameBuffer);

    deviceExtensionSize = sizeof(CTRLFDO_EXTENSION) +
                          driverObjectExtension->ExtensionSize;

    //
    // We've been given the PhysicalDeviceObject for an IDE controller.  Create the
    // FunctionalDeviceObject.  Our FDO will be nameless.
    //

    status = IoCreateDevice(
                DriverObject,               // our driver object
                deviceExtensionSize,        // size of our extension
                &deviceName,                // our name
                FILE_DEVICE_BUS_EXTENDER,   // device type
                FILE_DEVICE_SECURE_OPEN,    // device characteristics
                FALSE,                      // not exclusive
                &deviceObject               // store new device object here
                );

    if( !NT_SUCCESS( status )){

        return status;
    }

    fdoExtension = (PCTRLFDO_EXTENSION)deviceObject->DeviceExtension;
    RtlZeroMemory (fdoExtension, deviceExtensionSize);

    //
    // We have our FunctionalDeviceObject, initialize it.
    //

    fdoExtension->AttacheePdo                   = PhysicalDeviceObject;
    fdoExtension->DeviceObject                  = deviceObject;
    fdoExtension->DriverObject                  = DriverObject;
    fdoExtension->ControllerNumber              = controllerNumber;
    fdoExtension->VendorSpecificDeviceEntension = fdoExtension + 1;

    // Dispatch Table
    fdoExtension->DefaultDispatch               = PassDownToNextDriver;
    fdoExtension->PnPDispatchTable              = FdoPnpDispatchTable;
    fdoExtension->PowerDispatchTable            = FdoPowerDispatchTable;
    fdoExtension->WmiDispatchTable              = FdoWmiDispatchTable;

    //
    // Get the Device Control Flags out of the registry
    //
    fdoExtension->DeviceControlsFlags = 0;
    status = PciIdeXGetDeviceParameter (
               fdoExtension->AttacheePdo,
               L"DeviceControlFlags",
               &fdoExtension->DeviceControlsFlags
               );
    if (!NT_SUCCESS(status)) {

        DebugPrint ((1, "PciIdeX: Unable to get DeviceControlFlags from the registry\n"));

        //
        // this is not a serious error...continue to load
        //
        status = STATUS_SUCCESS;
    }

    //
    // Now attach to the PDO we were given.
    //
    fdoExtension->AttacheeDeviceObject = IoAttachDeviceToDeviceStack (
                                             deviceObject,
                                             PhysicalDeviceObject
                                             );

    if (fdoExtension->AttacheeDeviceObject == NULL){

        //
        // Couldn't attach.  Delete the FDO.
        //

        IoDeleteDevice (deviceObject);

    } else {

        //
        // fix up alignment requirement
        //
        deviceObject->AlignmentRequirement = fdoExtension->AttacheeDeviceObject->AlignmentRequirement;
        if (deviceObject->AlignmentRequirement < 1) {
            deviceObject->AlignmentRequirement = 1;
        }

        //
        // get the standard bus interface
        // (for READ_CONFIG/WRITE_CONFIG
        //
        status = PciIdeGetBusStandardInterface(fdoExtension);

        if (!NT_SUCCESS(status)) {

            IoDetachDevice (fdoExtension->AttacheeDeviceObject);
            IoDeleteDevice (deviceObject);

            return status;
        }
        //
        // Init operating mode (native or legacy)
        //
        ControllerOpMode (fdoExtension);

#ifdef ENABLE_NATIVE_MODE
		if (IsNativeMode(fdoExtension)) {

			NTSTATUS interfaceStatus = PciIdeGetNativeModeInterface(fdoExtension);

			//
			// bad pci.sys. 
			// we should still work. However, the window where an interrupt fires before
			// we are ready to dismiss it would not be closed. Can't do much at this point.
			//

			//ASSERT(NT_SUCCESS(interfaceStatus));
		}
#endif

        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
    }

    return status;
} // ControllerAddDevice


NTSTATUS
ControllerStartDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION              thisIrpSp;
    NTSTATUS                        status;
    PCTRLFDO_EXTENSION              fdoExtension;
    PCM_RESOURCE_LIST               resourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR irqPartialDescriptors;
    ULONG i;

    KEVENT                          event;

    POWER_STATE                     powerState;

    PAGED_CODE();

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    fdoExtension = (PCTRLFDO_EXTENSION) DeviceObject->DeviceExtension;

    resourceList     = thisIrpSp->Parameters.StartDevice.AllocatedResourcesTranslated;

    if (!resourceList) {

        DebugPrint ((1, "PciIde: Starting with no resource\n"));
    }

#ifdef ENABLE_NATIVE_MODE
	
	//
	// Let PCI know that we will manage the decodes
	//
	if (IsNativeMode(fdoExtension)) {
		ControllerDisableInterrupt(fdoExtension);
	}
#endif

    //
    // Call the lower level drivers with a the Irp
    //
    KeInitializeEvent(&event,
                      SynchronizationEvent,
                      FALSE);

    IoCopyCurrentIrpStackLocationToNext (Irp);

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoSetCompletionRoutine(
        Irp,
        ControllerStartDeviceCompletionRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE
        );

    //
    // Pass the irp along
    //
    status = IoCallDriver(fdoExtension->AttacheeDeviceObject, Irp);

    //
    // Wait for it to come back...
    //
    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(
            &event,
            Executive,
            KernelMode,
            FALSE,
            NULL
            );

        //
        // Grab back the 'real' status
        //
        status = Irp->IoStatus.Status;
    }

    if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

    powerState.SystemState = PowerSystemWorking;
    status = PciIdeIssueSetPowerState (
                 fdoExtension,
                 SystemPowerState,
                 powerState,
                 TRUE
                 );
    if (status == STATUS_INVALID_DEVICE_REQUEST) {

        //
        // The DeviceObject below us does not support power irp,
        // we will assume we are powered up
        //
        fdoExtension->SystemPowerState = PowerSystemWorking;

    } else if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

    powerState.DeviceState = PowerDeviceD0;
    status= PciIdeIssueSetPowerState (
                 fdoExtension,
                 DevicePowerState,
                 powerState,
                 TRUE
                 );
    if (status == STATUS_INVALID_DEVICE_REQUEST) {

        //
        // The DeviceObject Below us does not support power irp,
        // pretend we are powered up
        //
        fdoExtension->DevicePowerState = PowerDeviceD0;

    } else if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

#ifdef ENABLE_NATIVE_MODE
	if (!IsNativeMode(fdoExtension))  {
#endif

		//
		// Turn on PCI busmastering
		//
		EnablePCIBusMastering (
			fdoExtension
			);

#ifdef ENABLE_NATIVE_MODE
	}
#endif
    //
    // Initialize a fast mutex for later use
    //
    KeInitializeSpinLock(
        &fdoExtension->PciConfigDataLock
    );

    if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

	//
	// Analyze the resources
	//
    status = AnalyzeResourceList (fdoExtension, resourceList);

    if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

    //
    // Initialize controller properties. We need the resources
	// at this point for Native mode IDE controllers
    //
    PciIdeInitControllerProperties (
        fdoExtension
        );

#ifdef ENABLE_NATIVE_MODE
	if (IsNativeMode(fdoExtension)) {

		IDE_CHANNEL_STATE channelState;

#if DBG
    {
        PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
        PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
        PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
        ULONG                           resourceListSize;
        ULONG                           j;

        fullResourceList = resourceList->List;
        resourceListSize = 0;

        DebugPrint ((1, "Pciidex: Starting native mode device: FDOe\n", fdoExtension));

        for (i=0; i<resourceList->Count; i++) {
            partialResourceList = &(fullResourceList->PartialResourceList);
            partialDescriptors  = fullResourceList->PartialResourceList.PartialDescriptors;

            for (j=0; j<partialResourceList->Count; j++) {
                if (partialDescriptors[j].Type == CmResourceTypePort) {
                    DebugPrint ((1, "pciidex: IO Port = 0x%x. Lenght = 0x%x\n", partialDescriptors[j].u.Port.Start.LowPart, partialDescriptors[j].u.Port.Length));
                } else if (partialDescriptors[j].Type == CmResourceTypeInterrupt) {
                    DebugPrint ((1, "pciidex: Int Level = 0x%x. Int Vector = 0x%x\n", partialDescriptors[j].u.Interrupt.Level, partialDescriptors[j].u.Interrupt.Vector));
                } else {
                    DebugPrint ((1, "pciidex: Unknown resource\n"));
                }
            }
            fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + j);
        }

    }

#endif // DBG


		fdoExtension->ControllerIsrInstalled = FALSE;

		for (i=0; i< MAX_IDE_CHANNEL; i++) {


			//
			// Analyze the resources we are getting
			//
			status = DigestResourceList( 
							&fdoExtension->IdeResource, 
							fdoExtension->PdoResourceList[i], 
							&fdoExtension->IrqPartialDescriptors[i] 
							);

			if (!NT_SUCCESS(status) ) {

				goto GetOut;
			}

			if (!fdoExtension->IrqPartialDescriptors[i]) {

				status = STATUS_INSUFFICIENT_RESOURCES;

				goto GetOut;
			}

			DebugPrint((1, 
						"Pciidex: Connecting interrupt for channel %x interrupt vector 0x%x\n", 
						i,
						fdoExtension->IrqPartialDescriptors[i]->u.Interrupt.Vector
						));

			channelState = PciIdeChannelEnabled (fdoExtension, i);

			if (channelState != ChannelDisabled) {

				//
				// Build io address structure.
				//
				AtapiBuildIoAddress(
						fdoExtension->IdeResource.TranslatedCommandBaseAddress,
						fdoExtension->IdeResource.TranslatedControlBaseAddress,
						&fdoExtension->BaseIoAddress1[i],
						&fdoExtension->BaseIoAddress2[i],
						&fdoExtension->BaseIoAddress1Length[i],
						&fdoExtension->BaseIoAddress2Length[i],
						&fdoExtension->MaxIdeDevice[i],
						NULL);

				//
				// Install the ISR
				//
				status = ControllerInterruptControl(fdoExtension, i, 0);

				if (!NT_SUCCESS(status)) {
					break;
				}
			}
		}

		if (!NT_SUCCESS(status)) {

			goto GetOut;
		}

		//
		// This flag is needed for the ISR to enable interrupts. 
		//
		fdoExtension->ControllerIsrInstalled = TRUE;

		//
		// Enable the interrupt in both the channels
		//
		ControllerEnableInterrupt(fdoExtension);

		fdoExtension->NativeInterruptEnabled = TRUE;

		//
		// See the comments in the ISR regarding these flags
		//
		ASSERT(fdoExtension->ControllerIsrInstalled == TRUE);
		ASSERT(fdoExtension->NativeInterruptEnabled == TRUE);

		//
		// Turn on PCI busmastering
		//
		EnablePCIBusMastering (
			fdoExtension
			);

		for (i=0; i< MAX_IDE_CHANNEL; i++) {

			PIDE_BUS_MASTER_REGISTERS   bmRegister;

			//
			// Check the bus master registers
			//
			bmRegister = (PIDE_BUS_MASTER_REGISTERS)(((PUCHAR)fdoExtension->TranslatedBusMasterBaseAddress) + i*8);

			if (READ_PORT_UCHAR (&bmRegister->Status) & BUSMASTER_ZERO_BITS) {
				fdoExtension->NoBusMaster[i] = TRUE;
			}

		}
	}
#endif

    status = PciIdeCreateSyncChildAccess (fdoExtension);

    if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

    status = PciIdeCreateTimingTable(fdoExtension);

    if (!NT_SUCCESS(status)) {

        goto GetOut;
    }

GetOut:

    if (NT_SUCCESS(status)) {

#if DBG
        {

            PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
            PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
            PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
            ULONG                           j;
            ULONG                           k;

            DebugPrint ((1, "PciIdeX: Starting device:\n"));

            for (k=0; k <MAX_IDE_CHANNEL + 1; k++) {

                if (k == MAX_IDE_CHANNEL) {

                    DebugPrint ((1, "PciIdeX: Busmaster resources:\n"));

                    resourceList = fdoExtension->BmResourceList;
                } else {

                    DebugPrint ((1, "PciIdeX: PDO %d resources:\n", k));
                    resourceList = fdoExtension->PdoResourceList[k];
                }

                if (resourceList) {

                    fullResourceList = resourceList->List;


                    for (i=0; i<resourceList->Count; i++) {

                        partialResourceList = &(fullResourceList->PartialResourceList);
                        partialDescriptors  = fullResourceList->PartialResourceList.PartialDescriptors;

                        for (j=0; j<partialResourceList->Count; j++) {
                            if (partialDescriptors[j].Type == CmResourceTypePort) {
                                DebugPrint ((1, "IdePort: IO Port = 0x%x. Lenght = 0x%x\n", partialDescriptors[j].u.Port.Start.LowPart, partialDescriptors[j].u.Port.Length));
                            } else if (partialDescriptors[j].Type == CmResourceTypeMemory) {
                                    DebugPrint ((1, "IdePort: Memory Port = 0x%x. Lenght = 0x%x\n", partialDescriptors[j].u.Memory.Start.LowPart, partialDescriptors[j].u.Memory.Length));
                            } else if (partialDescriptors[j].Type == CmResourceTypeInterrupt) {
                                DebugPrint ((1, "IdePort: Int Level = 0x%x. Int Vector = 0x%x\n", partialDescriptors[j].u.Interrupt.Level, partialDescriptors[j].u.Interrupt.Vector));
                            } else {
                                DebugPrint ((1, "IdePort: Unknown resource\n"));
                            }
                        }
                        fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + j);
                    }
                }
            }
        }
#endif // DBG
    }

    Irp->IoStatus.Status = status;
    Irp->IoStatus.Information = 0;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );

    return status;
} // ControllerStartDevice

NTSTATUS
ControllerStartDeviceCompletionRoutine(
    IN     PDEVICE_OBJECT  DeviceObject,
    IN OUT PIRP            Irp,
    IN OUT PVOID           Context
    )
{
    PKEVENT event = (PKEVENT) Context;

    //
    // Signal the event
    //
    KeSetEvent( event, IO_NO_INCREMENT, FALSE );

    //
    // Always return MORE_PROCESSING_REQUIRED
    // will complete it later
    //
    return STATUS_MORE_PROCESSING_REQUIRED;
} // ControllerStartDeviceCompletionRoutine

NTSTATUS
ControllerStopDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PCTRLFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    NTSTATUS status;

    PAGED_CODE();

    status = ControllerStopController (
                fdoExtension
                );
    ASSERT (NT_SUCCESS(status));
    
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoSkipCurrentIrpStackLocation(Irp);
    return IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
} // ControllerStopDevice


NTSTATUS
ControllerStopController (
    IN PCTRLFDO_EXTENSION FdoExtension
    )
{
    ULONG i;

    PAGED_CODE();

    if (FdoExtension->BmResourceList) {
        ExFreePool (FdoExtension->BmResourceList);
        FdoExtension->BmResourceList = NULL;
    }

    for (i=0; i<MAX_IDE_CHANNEL; i++) {
        if (FdoExtension->PdoResourceList[i]) {
            ExFreePool (FdoExtension->PdoResourceList[i]);
            FdoExtension->PdoResourceList[i] = NULL;
        }
    }

#ifdef ENABLE_NATIVE_MODE

	//
	// We need to reset the flags in this order. Otherwise an interrupt would
	// result in the decodes to be enabled by the ISR. See the comments in the ISR
	//
	FdoExtension->ControllerIsrInstalled = FALSE;
	ControllerDisableInterrupt(FdoExtension);
	FdoExtension->NativeInterruptEnabled = FALSE;

	for (i=0; i< MAX_IDE_CHANNEL; i++) {

		NTSTATUS status;
		DebugPrint((1, "Pciidex: DisConnecting interrupt for channel %x\n", i));

		//
		// Disconnect the ISR
		//
		status = ControllerInterruptControl(FdoExtension, i, 1 );

		ASSERT(NT_SUCCESS(status));

	}

	ASSERT(FdoExtension->ControllerIsrInstalled == FALSE);
	ASSERT(FdoExtension->NativeInterruptEnabled == FALSE);

#endif

    PciIdeDeleteSyncChildAccess (FdoExtension);

    return STATUS_SUCCESS;
} // ControllerStopController


NTSTATUS
ControllerSurpriseRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PCTRLFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    NTSTATUS        status;
    ULONG           i;

    PAGED_CODE();

#if DBG
    //
    // make sure all the children are removed or surprise removed
    //
    for (i=0; i<MAX_IDE_CHANNEL; i++) {

        PCHANPDO_EXTENSION pdoExtension;

        pdoExtension = fdoExtension->ChildDeviceExtension[i];

        if (pdoExtension) {

            ASSERT (pdoExtension->PdoState & (PDOS_SURPRISE_REMOVED | PDOS_REMOVED));
        }
    }
#endif // DBG

    status = ControllerStopController (fdoExtension);
    ASSERT (NT_SUCCESS(status));

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoSkipCurrentIrpStackLocation ( Irp );
    return IoCallDriver(fdoExtension->AttacheeDeviceObject, Irp);

} // ControllerSurpriseRemoveDevice


NTSTATUS
ControllerRemoveDevice (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PCTRLFDO_EXTENSION fdoExtension = DeviceObject->DeviceExtension;
    NTSTATUS        status;
    KEVENT          event;
    ULONG           i;

    PAGED_CODE();

    //
    // Kill all the children if any
    //
    for (i=0; i<MAX_IDE_CHANNEL; i++) {

        PCHANPDO_EXTENSION pdoExtension;

        pdoExtension = fdoExtension->ChildDeviceExtension[i];

        if (pdoExtension) {

            status = ChannelStopChannel (pdoExtension);
            ASSERT (NT_SUCCESS(status));

            //
            // mark this device invalid
            //
            ChannelUpdatePdoState (
                pdoExtension,
                PDOS_DEADMEAT | PDOS_REMOVED,
                0
                );

            IoDeleteDevice (pdoExtension->DeviceObject);
            fdoExtension->ChildDeviceExtension[i] = NULL;
        }
    }

    status = ControllerStopController (fdoExtension);
    ASSERT (NT_SUCCESS(status));

    if (fdoExtension->TransferModeTimingTable) {
        ExFreePool(fdoExtension->TransferModeTimingTable);
        fdoExtension->TransferModeTimingTable = NULL;
        fdoExtension->TransferModeTableLength = 0;
    }

    KeInitializeEvent(&event, SynchronizationEvent, FALSE);

    IoCopyCurrentIrpStackLocationToNext (Irp);

    IoSetCompletionRoutine(
        Irp,
        ControllerRemoveDeviceCompletionRoutine,
        &event,
        TRUE,
        TRUE,
        TRUE
        );

    status = IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject(&event, Executive, KernelMode, FALSE, NULL);
    }

    IoDetachDevice (fdoExtension->AttacheeDeviceObject);

    IoDeleteDevice (DeviceObject);

    //return STATUS_SUCCESS;
    return status;
} // ControllerRemoveDevice


NTSTATUS
ControllerRemoveDeviceCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP           Irp,
    IN PVOID          Context
    )
{
    PKEVENT event = Context;

    KeSetEvent(event, 0, FALSE);

    return STATUS_SUCCESS;
} // ControllerRemoveDeviceCompletionRoutine

NTSTATUS
ControllerQueryDeviceRelations (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION  thisIrpSp;
    PCTRLFDO_EXTENSION  fdoExtension;
    PDEVICE_RELATIONS   deviceRelations;
    NTSTATUS            status;
    ULONG               deviceRelationsSize;
    ULONG               channel;
    PCONFIGURATION_INFORMATION configurationInformation = IoGetConfigurationInformation();
    ULONG               nextUniqueNumber;

    PAGED_CODE();

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    fdoExtension = (PCTRLFDO_EXTENSION) DeviceObject->DeviceExtension;
    status = STATUS_SUCCESS;

    switch (thisIrpSp->Parameters.QueryDeviceRelations.Type) {
        case BusRelations:
        DebugPrint ((3, "ControllerQueryDeviceRelations: bus relations\n"));

        deviceRelationsSize = FIELD_OFFSET (DEVICE_RELATIONS, Objects) +
                                MAX_IDE_CHANNEL * sizeof(PDEVICE_OBJECT);

        deviceRelations = ExAllocatePool (PagedPool, deviceRelationsSize);

        if(!deviceRelations) {

            DebugPrint ((1, 
                         "IdeQueryDeviceRelations: Unable to allocate DeviceRelations structures\n"));
            status = STATUS_INSUFFICIENT_RESOURCES;

        }

        if (NT_SUCCESS(status)) {

            LARGE_INTEGER tickCount;
            ULONG newBusScanTime;
            ULONG newBusScanTimeDelta;
            BOOLEAN reportUnknownAsNewChild;

            //
            // determine if we should return unknown child as new child
            // unknown child is IDE channel which we don't know 
            // it is enabled or not unless we pnp start the channel 
            // and poke at it to find out.
            //
            // since we don't want to go into an infinite cycle of
            // starting and failing start on a unknown child, we will
            // limit our frequency
            //
            KeQueryTickCount(&tickCount);
            newBusScanTime = (ULONG) ((tickCount.QuadPart * 
                ((ULONGLONG) KeQueryTimeIncrement())) / ((ULONGLONG) 10000000));
            newBusScanTimeDelta = newBusScanTime - fdoExtension->LastBusScanTime;
            DebugPrint ((1, "PCIIDEX: Last rescan was %d seconds ago.\n", newBusScanTimeDelta));

            if ((newBusScanTimeDelta < MIN_BUS_SCAN_PERIOD_IN_SEC) &&
                (fdoExtension->LastBusScanTime != 0)) {

                reportUnknownAsNewChild = FALSE;

            } else {

                reportUnknownAsNewChild = TRUE;
            }
            fdoExtension->LastBusScanTime = newBusScanTime;

            RtlZeroMemory (deviceRelations, deviceRelationsSize);

            for (channel = 0; channel < MAX_IDE_CHANNEL; channel++) {

                PDEVICE_OBJECT      deviceObject;
                PCHANPDO_EXTENSION  pdoExtension;
                UNICODE_STRING      deviceName;
                WCHAR               deviceNameBuffer[256];
                PDEVICE_OBJECT      deviceObjectToReturn;
                IDE_CHANNEL_STATE   channelState;

                deviceObjectToReturn = NULL;

                pdoExtension = fdoExtension->ChildDeviceExtension[channel];
                channelState = PciIdeChannelEnabled (fdoExtension, channel);

                if (pdoExtension) {

                    //
                    // already got a DeviceObject for this channel
                    //
                    if (channelState == ChannelDisabled) {

                        ULONG pdoState;

                        pdoState = ChannelUpdatePdoState (
                                      pdoExtension,
                                      PDOS_DEADMEAT,
                                      0
                                      );
                    } else {

                        deviceObjectToReturn = pdoExtension->DeviceObject;
                    }

                } else if ((channelState == ChannelEnabled) ||
                           ((channelState == ChannelStateUnknown) && reportUnknownAsNewChild)) {

                    if (!fdoExtension->NativeMode[channel]) {

                        if (channel == 0) {

                            configurationInformation->AtDiskPrimaryAddressClaimed = TRUE;

                        } else {

                            configurationInformation->AtDiskSecondaryAddressClaimed = TRUE;
                        }
                    }

                    //
                    // Remove this when pnp mgr can deal with pdo with no names
                    //
                    nextUniqueNumber = InterlockedIncrement(&PciIdeXNextChannelNumber) - 1;
                    swprintf(deviceNameBuffer, DEVICE_OJBECT_BASE_NAME  L"\\PciIde%dChannel%d-%x", fdoExtension->ControllerNumber, channel, nextUniqueNumber);
                    RtlInitUnicodeString (&deviceName, deviceNameBuffer);

                    status = IoCreateDevice(
                                fdoExtension->DriverObject, // our driver object
                                sizeof(CHANPDO_EXTENSION),  // size of our extension
                                &deviceName,                // our name
                                FILE_DEVICE_CONTROLLER,     // device type
                                FILE_DEVICE_SECURE_OPEN,    // device characteristics
                                FALSE,                      // not exclusive
                                &deviceObject       // store new device object here
                                );

                    if (NT_SUCCESS(status)) {

                        pdoExtension = (PCHANPDO_EXTENSION) deviceObject->DeviceExtension;
                        RtlZeroMemory (pdoExtension, sizeof(CHANPDO_EXTENSION));

                        pdoExtension->DeviceObject          = deviceObject;
                        pdoExtension->DriverObject          = fdoExtension->DriverObject;
                        pdoExtension->ParentDeviceExtension = fdoExtension;
                        pdoExtension->ChannelNumber         = channel;

                        //
                        // Dispatch Table
                        //
                        pdoExtension->DefaultDispatch        = NoSupportIrp;
                        pdoExtension->PnPDispatchTable       = PdoPnpDispatchTable;
                        pdoExtension->PowerDispatchTable     = PdoPowerDispatchTable;
                        pdoExtension->WmiDispatchTable       = PdoWmiDispatchTable;

                        KeInitializeSpinLock(&pdoExtension->SpinLock);

                        fdoExtension->ChildDeviceExtension[channel]   = pdoExtension;

                        deviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

                        fdoExtension->NumberOfChildren++;

                        InterlockedIncrement(&fdoExtension->NumberOfChildrenPowerUp);

                        //
                        // fix up alignment requirement
                        // check with the miniport also
                        //
                        deviceObject->AlignmentRequirement = fdoExtension->ControllerProperties.AlignmentRequirement;
                        if (deviceObject->AlignmentRequirement < fdoExtension->AttacheeDeviceObject->AlignmentRequirement) {
                            deviceObject->AlignmentRequirement = 
                                        fdoExtension->DeviceObject->AlignmentRequirement;
                        }

                        if (deviceObject->AlignmentRequirement < 1) {
                            deviceObject->AlignmentRequirement = 1;
                        }


                        //
                        // return this new DeviceObject
                        //
                        deviceObjectToReturn = deviceObject;
                    }
                }

                if (deviceObjectToReturn) {

                    deviceRelations->Objects[(deviceRelations)->Count] = deviceObjectToReturn;

                    ObReferenceObjectByPointer(deviceObjectToReturn,
                                               0,
                                               0,
                                               KernelMode);

                    deviceRelations->Count++;
                }
            }
        }

        Irp->IoStatus.Information = (ULONG_PTR) deviceRelations;
        Irp->IoStatus.Status = status;
        break;

    default:
        status=STATUS_SUCCESS;
        DebugPrint ((1, "PciIdeQueryDeviceRelations: Unsupported device relation\n"));
        break;
    }

    if (NT_SUCCESS(status)) {

        IoSkipCurrentIrpStackLocation ( Irp );
        return IoCallDriver(fdoExtension->AttacheeDeviceObject, Irp);

    } else {

        //
        //Complete the request
        //
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
        return status;
    }
} // ControllerQueryDeviceRelations

NTSTATUS
ControllerQueryInterface (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION    thisIrpSp;
    PCTRLFDO_EXTENSION    fdoExtension;
    NTSTATUS              status;
    PTRANSLATOR_INTERFACE translator;
    ULONG                 busNumber;

    PAGED_CODE();

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    fdoExtension = (PCTRLFDO_EXTENSION) DeviceObject->DeviceExtension;
    status = Irp->IoStatus.Status;

    if (RtlEqualMemory(&GUID_TRANSLATOR_INTERFACE_STANDARD,
                       thisIrpSp->Parameters.QueryInterface.InterfaceType,
                       sizeof(GUID))
     && (thisIrpSp->Parameters.QueryInterface.Size >=
        sizeof(TRANSLATOR_INTERFACE))
     && (PtrToUlong(thisIrpSp->Parameters.QueryInterface.InterfaceSpecificData) ==
        CmResourceTypeInterrupt)) {

        if (!fdoExtension->NativeMode[0] && !fdoExtension->NativeMode[1]) {

            //
            // we only return a translator only if we are legacy controller
            //
            status = HalGetInterruptTranslator(
                        PCIBus,
                        0,
                        InterfaceTypeUndefined, // special "IDE" cookie
                        thisIrpSp->Parameters.QueryInterface.Size,
                        thisIrpSp->Parameters.QueryInterface.Version,
                        (PTRANSLATOR_INTERFACE) thisIrpSp->Parameters.QueryInterface.Interface,
                        &busNumber
                        );
        }
    }

    //
    // Pass down.
    //

    Irp->IoStatus.Status = status;
    IoSkipCurrentIrpStackLocation ( Irp );
    return IoCallDriver(fdoExtension->AttacheeDeviceObject, Irp);
} // ControllerQueryInterface

//
// initialize PCTRLFDO_EXTENSION->PCM_PARTIAL_RESOURCE_DESCRIPTOR(s)
//
NTSTATUS
AnalyzeResourceList (
    PCTRLFDO_EXTENSION FdoExtension,
    PCM_RESOURCE_LIST  ResourceList
    )
{
    PCM_FULL_RESOURCE_DESCRIPTOR    fullResourceList;
    PCM_PARTIAL_RESOURCE_LIST       partialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR partialDescriptors;
    ULONG                           i;
    ULONG                           j;
    ULONG                           k;
    ULONG                           cmdChannel;
    ULONG                           ctrlChannel;
    ULONG                           intrChannel;
    ULONG                           bmAddr;

    ULONG                           pdoResourceListSize;
    PCM_RESOURCE_LIST               pdoResourceList[MAX_IDE_CHANNEL];
    PCM_FULL_RESOURCE_DESCRIPTOR    pdoFullResourceList[MAX_IDE_CHANNEL];
    PCM_PARTIAL_RESOURCE_LIST       pdoPartialResourceList[MAX_IDE_CHANNEL];
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pdoPartialDescriptors[MAX_IDE_CHANNEL];

    ULONG                           bmResourceListSize;
    PCM_RESOURCE_LIST               bmResourceList;
    PCM_FULL_RESOURCE_DESCRIPTOR    bmFullResourceList;
    PCM_PARTIAL_RESOURCE_LIST       bmPartialResourceList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR bmPartialDescriptors;

    NTSTATUS                        status;

    PAGED_CODE();

    if (!ResourceList) {
        return STATUS_SUCCESS;
    }

    bmResourceListSize =
        sizeof (CM_RESOURCE_LIST) * ResourceList->Count; // This will have one CM_PARTIAL_RESOURCE_LIST

    bmResourceList = (PCM_RESOURCE_LIST) ExAllocatePool (NonPagedPool, bmResourceListSize);
    if (bmResourceList == NULL) {

        return STATUS_NO_MEMORY;
    }

    RtlZeroMemory (bmResourceList, bmResourceListSize);

    pdoResourceListSize =
        sizeof (CM_RESOURCE_LIST) * ResourceList->Count + // This will have one CM_PARTIAL_RESOURCE_LIST
        sizeof (CM_PARTIAL_RESOURCE_LIST) * 2;

    for (i=0; i<MAX_IDE_CHANNEL; i++) {

        pdoResourceList[i] = (PCM_RESOURCE_LIST) ExAllocatePool (NonPagedPool, pdoResourceListSize);

        if (pdoResourceList[i] == NULL) {

            DebugPrint ((0, "Unable to allocate resourceList for PDOs\n"));

            for (j=0; j<i; j++) {

                ExFreePool (pdoResourceList[j]);
            }

            ExFreePool (bmResourceList);
            return STATUS_NO_MEMORY;
        }

        RtlZeroMemory (pdoResourceList[i], pdoResourceListSize);
    }

    fullResourceList = ResourceList->List;

    bmResourceList->Count = 0;
    bmFullResourceList = bmResourceList->List;

    for (k=0; k<MAX_IDE_CHANNEL; k++) {

        pdoResourceList[k]->Count = 0;
        pdoFullResourceList[k] = pdoResourceList[k]->List;
    }

    cmdChannel = ctrlChannel = intrChannel = bmAddr = 0;
    for (j=0; j<ResourceList->Count; j++) {

        partialResourceList = &(fullResourceList->PartialResourceList);
        partialDescriptors  = partialResourceList->PartialDescriptors;

        RtlCopyMemory (
            bmFullResourceList,
            fullResourceList,
            FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR, PartialResourceList.PartialDescriptors)
            );

        bmPartialResourceList = &(bmFullResourceList->PartialResourceList);
        bmPartialResourceList->Count = 0;
        bmPartialDescriptors  = bmPartialResourceList->PartialDescriptors;

        for (k=0; k<MAX_IDE_CHANNEL; k++) {

            RtlCopyMemory (
                pdoFullResourceList[k],
                fullResourceList,
                FIELD_OFFSET(CM_FULL_RESOURCE_DESCRIPTOR, PartialResourceList.PartialDescriptors)
                );

            pdoPartialResourceList[k] = &(pdoFullResourceList[k]->PartialResourceList);
            pdoPartialResourceList[k]->Count = 0;
            pdoPartialDescriptors[k]  = pdoPartialResourceList[k]->PartialDescriptors;

        }

        for (i=0; i<partialResourceList->Count; i++) {

            if (((partialDescriptors[j].Type == CmResourceTypePort) ||
                 (partialDescriptors[j].Type == CmResourceTypeMemory)) &&
                 (partialDescriptors[i].u.Port.Length == 8) &&
                 (cmdChannel < MAX_IDE_CHANNEL)) {

                ASSERT (cmdChannel < MAX_IDE_CHANNEL);

                RtlCopyMemory (
                    pdoPartialDescriptors[cmdChannel] + pdoPartialResourceList[cmdChannel]->Count,
                    partialDescriptors + i,
                    sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR)
                    );

                pdoPartialResourceList[cmdChannel]->Count++;

                cmdChannel++;

            } else if (((partialDescriptors[j].Type == CmResourceTypePort) ||
                        (partialDescriptors[j].Type == CmResourceTypeMemory)) &&
                        (partialDescriptors[i].u.Port.Length == 4) &&
                        (ctrlChannel < MAX_IDE_CHANNEL)) {

                ASSERT (ctrlChannel < MAX_IDE_CHANNEL);

                RtlCopyMemory (
                    pdoPartialDescriptors[ctrlChannel] + pdoPartialResourceList[ctrlChannel]->Count,
                    partialDescriptors + i,
                    sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR)
                    );

                pdoPartialResourceList[ctrlChannel]->Count++;

                ctrlChannel++;

            } else if (((partialDescriptors[j].Type == CmResourceTypePort) ||
                        (partialDescriptors[j].Type == CmResourceTypeMemory)) &&
                        (partialDescriptors[i].u.Port.Length == 16) &&
                        (bmAddr < 1)) {

                ASSERT (bmAddr < 1);

                RtlCopyMemory (
                    bmPartialDescriptors + bmPartialResourceList->Count,
                    partialDescriptors + i,
                    sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR)
                    );

                bmPartialResourceList->Count++;

                bmAddr++;

            } else if ((partialDescriptors[i].Type == CmResourceTypeInterrupt) &&
                (intrChannel < MAX_IDE_CHANNEL)) {

                ASSERT (intrChannel < MAX_IDE_CHANNEL);

                RtlCopyMemory (
                    pdoPartialDescriptors[intrChannel] + pdoPartialResourceList[intrChannel]->Count,
                    partialDescriptors + i,
                    sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR)
                    );

                pdoPartialResourceList[intrChannel]->Count++;

                if (intrChannel == 0) {

                    if (FdoExtension->NativeMode[1]) {

                        intrChannel++;

                        //
						// ISSUE: 08/30/2000
                        // do I need to mark it sharable?
						// this needs to be revisited. (there are more issues)
                        //
                        RtlCopyMemory (
                            pdoPartialDescriptors[intrChannel] + pdoPartialResourceList[intrChannel]->Count,
                            partialDescriptors + i,
                            sizeof (CM_PARTIAL_RESOURCE_DESCRIPTOR)
                            );

                        pdoPartialResourceList[intrChannel]->Count++;
                    }
                }

                intrChannel++;

            } else if (partialDescriptors[i].Type == CmResourceTypeDeviceSpecific) {

                partialDescriptors += partialDescriptors[i].u.DeviceSpecificData.DataSize;
            }
        }

        if (bmPartialResourceList->Count) {

            bmResourceList->Count++;
            bmFullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR)
                (bmPartialDescriptors + bmPartialResourceList->Count);

        }

        for (k=0; k<MAX_IDE_CHANNEL; k++) {

            if (pdoPartialResourceList[k]->Count) {

                pdoResourceList[k]->Count++;
                pdoFullResourceList[k] = (PCM_FULL_RESOURCE_DESCRIPTOR)
                    (pdoPartialDescriptors[k] + pdoPartialResourceList[k]->Count);
            }
        }

        fullResourceList = (PCM_FULL_RESOURCE_DESCRIPTOR) (partialDescriptors + i);
    }

    status = STATUS_SUCCESS;

    for (k=0; k<MAX_IDE_CHANNEL; k++) {

        if (FdoExtension->NativeMode[k]) {

            //
            // If the controller is in native mode, we should have all the resources
            //

            if ((k < cmdChannel) &&
                (k < ctrlChannel) &&
                (k < intrChannel)) {

                //
                // This is good
                //

            } else {

                cmdChannel  = 0;
                ctrlChannel = 0;
                intrChannel = 0;
                bmAddr      = 0;
                status      = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
    }


    //
    // If the controller is in legacy mode, we should not have any resources
    //
    if (!FdoExtension->NativeMode[0] && !FdoExtension->NativeMode[1]) {

        //
        // both channels in legacy mode
        //
        cmdChannel = 0;
        ctrlChannel = 0;
        intrChannel = 0;
    }


    FdoExtension->TranslatedBusMasterBaseAddress = NULL;
    if (0 < bmAddr) {

        FdoExtension->BmResourceList = bmResourceList;
        FdoExtension->BmResourceListSize = (ULONG)(((PUCHAR)bmFullResourceList) - ((PUCHAR)bmResourceList));

        if (FdoExtension->BmResourceList->List[0].PartialResourceList.PartialDescriptors->Type == CmResourceTypePort) {

            //
            // address is in i/o space
            //
            FdoExtension->TranslatedBusMasterBaseAddress =
                (PIDE_BUS_MASTER_REGISTERS) (ULONG_PTR)FdoExtension->BmResourceList->List[0].PartialResourceList.PartialDescriptors->u.Port.Start.QuadPart;
            FdoExtension->BusMasterBaseAddressSpace = IO_SPACE;

        } else if (FdoExtension->BmResourceList->List[0].PartialResourceList.PartialDescriptors->Type == CmResourceTypeMemory) {

            //
            // address is in memory space
            //
            FdoExtension->TranslatedBusMasterBaseAddress =
                (PIDE_BUS_MASTER_REGISTERS) MmMapIoSpace(
                                                FdoExtension->BmResourceList->List[0].PartialResourceList.PartialDescriptors->u.Port.Start,
                                                16,
                                                FALSE);
            ASSERT (FdoExtension->TranslatedBusMasterBaseAddress);

            // free mapped io resouces in stop/remove device
            // unmapiospace doesn't do anything. it is ok not to call it

            FdoExtension->BusMasterBaseAddressSpace = MEMORY_SPACE;

        } else {

            FdoExtension->TranslatedBusMasterBaseAddress = NULL;
            ASSERT (FALSE);
        }
    }

    if (FdoExtension->TranslatedBusMasterBaseAddress == NULL) {

        ExFreePool (bmResourceList);
        FdoExtension->BmResourceList = bmResourceList = NULL;
    }

    for (k=0; k<MAX_IDE_CHANNEL; k++) {

        if ((k < cmdChannel) ||
            (k < ctrlChannel) ||
            (k < intrChannel)) {

            FdoExtension->PdoResourceList[k] = pdoResourceList[k];
            FdoExtension->PdoResourceListSize[k] = (ULONG)(((PUCHAR)pdoFullResourceList[k]) - ((PUCHAR)pdoResourceList[k]));

            if (k < cmdChannel) {

                FdoExtension->PdoCmdRegResourceFound[k] = TRUE;
            }

            if (k < ctrlChannel) {

                FdoExtension->PdoCtrlRegResourceFound[k] = TRUE;
            }

            if (k < intrChannel) {

                FdoExtension->PdoInterruptResourceFound[k] = TRUE;
            }

        } else {

            ExFreePool (pdoResourceList[k]);
            FdoExtension->PdoResourceList[k] =
                pdoResourceList[k] = NULL;
        }

    }

    return status;
} // AnalyzeResourceList

VOID
ControllerOpMode (
    IN PCTRLFDO_EXTENSION FdoExtension
    )
{
    NTSTATUS    status;
    PCIIDE_CONFIG_HEADER pciIdeConfigHeader;

    PAGED_CODE();

    status = PciIdeBusData(
                 FdoExtension,
                 &pciIdeConfigHeader,
                 0,
                 sizeof (pciIdeConfigHeader),
                 TRUE
                 );

    FdoExtension->NativeMode[0] = FALSE;
    FdoExtension->NativeMode[1] = FALSE;

    if (NT_SUCCESS(status)) {

		//
		// ISSUE: 02/05/01: This should be removed. In pci we check for sublclass = 0x1
		// 
        if ((pciIdeConfigHeader.BaseClass == PCI_CLASS_MASS_STORAGE_CTLR) &&
            (pciIdeConfigHeader.SubClass == PCI_SUBCLASS_MSC_RAID_CTLR)) {

            //
            // We have a Promise Technology IDE "raid" controller
            //
            FdoExtension->NativeMode[0] = TRUE;
            FdoExtension->NativeMode[1] = TRUE;

        } else {

            if ((pciIdeConfigHeader.Chan0OpMode) &&
                (pciIdeConfigHeader.Chan1OpMode)) {

                //
                // we can't support a channel being legacy
                // and the other is in native because
                // we don't know what irq is for the native
                // channel
                //
                FdoExtension->NativeMode[0] = TRUE;
                FdoExtension->NativeMode[1] = TRUE;
            }
        }

        //
        // Have to be both TRUE or both FALSE
        //
        ASSERT ((FdoExtension->NativeMode[0] == FALSE) == (FdoExtension->NativeMode[1] == FALSE));
    }

    return;
} // ControllerOpMode

VOID
EnablePCIBusMastering (
    IN PCTRLFDO_EXTENSION FdoExtension
    )
{
    NTSTATUS             status;
    PCIIDE_CONFIG_HEADER pciIdeConfigHeader;

    status = PciIdeBusData(
                 FdoExtension,
                 &pciIdeConfigHeader,
                 0,
                 sizeof (PCIIDE_CONFIG_HEADER),
                 TRUE
                 );

    //
    // pci bus master disabled?
    //
    if (NT_SUCCESS(status) &&
        pciIdeConfigHeader.MasterIde &&
        !pciIdeConfigHeader.Command.b.MasterEnable) {

        //
        // Try to turn on pci bus mastering
        //
        pciIdeConfigHeader.Command.b.MasterEnable = 1;

        status = PciIdeBusData(
                     FdoExtension,
                     &pciIdeConfigHeader.Command.w,
                     FIELD_OFFSET (PCIIDE_CONFIG_HEADER, Command),
                     sizeof (pciIdeConfigHeader.Command.w),
                     FALSE
                     );
    }
    return;
} // EnablePCIBusMastering


#ifdef DBG
ULONG PciIdeXDebugFakeMissingChild = 0;
#endif // DBG

IDE_CHANNEL_STATE
PciIdeChannelEnabled (
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN ULONG Channel
)
{
    NTSTATUS status;
    ULONG longMask;

    UCHAR channelEnableMask;
    ULONG channelEnablePciConfigOffset;
    UCHAR pciConfigData;

    PAGED_CODE();

#if DBG
    if (PciIdeXDebugFakeMissingChild & 0xff000000) {

        DebugPrint ((0, "PciIdeXDebugFakeMissingChild: fake missing channel 0x%x\n", Channel));

        if ((PciIdeXDebugFakeMissingChild & 0x0000ff) == Channel) {
    
            PciIdeXDebugFakeMissingChild = 0;
            return ChannelDisabled;
        }
    }
#endif


    longMask = 0;
    status = PciIdeXGetDeviceParameter (
               FdoExtension->AttacheePdo,
               ChannelEnableMaskName[Channel],
               &longMask
               );
    channelEnableMask = (UCHAR) longMask;

    if (!NT_SUCCESS(status)) {

        DebugPrint ((1, "PciIdeX: Unable to get ChannelEnableMask from the registry\n"));

    } else {

        channelEnablePciConfigOffset = 0;
        status = PciIdeXGetDeviceParameter (
                   FdoExtension->AttacheePdo,
                   ChannelEnablePciConfigOffsetName[Channel],
                   &channelEnablePciConfigOffset
                   );

        if (!NT_SUCCESS(status)) {

            DebugPrint ((1, "PciIdeX: Unable to get ChannelEnablePciConfigOffset from the registry\n"));

        } else {

            status = PciIdeBusData(
                         FdoExtension,
                         &pciConfigData,
                         channelEnablePciConfigOffset,
                         sizeof (pciConfigData),
                         TRUE                           // Read
                         );

            if (NT_SUCCESS(status)) {

                return (pciConfigData & channelEnableMask) ? ChannelEnabled : ChannelDisabled;
            }
        }
    }

    //
    // couldn't figure out whether is channel enabled
    // try the miniport port
    //
    if (FdoExtension->ControllerProperties.PciIdeChannelEnabled) {

        return FdoExtension->ControllerProperties.PciIdeChannelEnabled (
                   FdoExtension->VendorSpecificDeviceEntension,
                   Channel
                   );
    }

    return ChannelStateUnknown;
} // PciIdeChannelEnabled

NTSTATUS
PciIdeCreateTimingTable (
    IN PCTRLFDO_EXTENSION FdoExtension
    )
{
    PULONG timingTable = NULL;
    PWSTR regTimingList = NULL;
    ULONG i;
    ULONG temp;
    ULONG length = 0;
    NTSTATUS status; 

    PAGED_CODE();

    //
    // Try to procure the timing table from the registry
    //
    status = PciIdeXGetDeviceParameterEx (
               FdoExtension->AttacheePdo,
               L"TransferModeTiming",
               &(regTimingList)
               );

    //
    // Fill in the table entries
    //
    if (NT_SUCCESS(status) && regTimingList) {

        PWSTR string = regTimingList;
        UNICODE_STRING  unicodeString;

        i=0;

        while (string[0]) {

            RtlInitUnicodeString(
                &unicodeString,
                string
                );

            RtlUnicodeStringToInteger(&unicodeString,10, &temp);

            //
            // The first entry is the length of the table
            //
            if (i==0) {

                length = temp;
                ASSERT(length <=31);

                if (length > 31) {
                    length=temp=31;
                }

                //
                // The table should atleast be MAX_XFER_MODE long.
                // if not fill it up with 0s
                //
                if (temp < MAX_XFER_MODE) {
                    temp=MAX_XFER_MODE;
                }

                timingTable = ExAllocatePool(NonPagedPool, temp*sizeof(ULONG));
                if (timingTable == NULL) {

                    length = 0;
                    status = STATUS_INSUFFICIENT_RESOURCES;
                    break;

                } else {

                    ULONG j;
                    //
                    // Initialize the known xferModes (default)
                    //
                    SetDefaultTiming(timingTable, j);

                    for (j=MAX_XFER_MODE; j<temp;j++) {
                        timingTable[j]=timingTable[MAX_XFER_MODE-1];
                    }
                }

            } else {

                if (i > length) {
                    DebugPrint((0, "Pciidex: Timing table overflow\n"));
                    break;
                }
                //
                // The timings (PIO0-...)
                // Use the default values if the cycletime is 0.
                //
                if (temp) {
                    timingTable[i-1]=temp;
                }
            }

            i++;
            string += (unicodeString.Length / sizeof(WCHAR)) + 1;
        }
        
        if (length < MAX_XFER_MODE) {
            length = MAX_XFER_MODE;
        }

        ExFreePool(regTimingList);

    } else {
        DebugPrint((1, "Pciidex: Unsuccessful regop status %x, regTimingList %x\n",
                    status, regTimingList));

        //
        // Nothing in the registry. Fill in the table with known transfer mode
        // timings.
        //
        status = STATUS_SUCCESS;
        timingTable=ExAllocatePool(NonPagedPool, MAX_XFER_MODE*sizeof(ULONG));

        if (timingTable == NULL) {
            length =0;
            status = STATUS_INSUFFICIENT_RESOURCES;
        } else {
            SetDefaultTiming(timingTable, length);
        }
    }

    FdoExtension->TransferModeTimingTable=timingTable;
    FdoExtension->TransferModeTableLength= length;

    /*
    for (i=0;i<FdoExtension->TransferModeTableLength;i++) {
        DebugPrint((0, "Table[%d]=%d\n", 
                    i,
                    FdoExtension->TransferModeTimingTable[i]));
    }
    */

    return status; 
}

VOID
PciIdeInitControllerProperties (
    IN PCTRLFDO_EXTENSION FdoExtension
    )
{
#if 1
    NTSTATUS status;
    PDRIVER_OBJECT_EXTENSION driverObjectExtension;
    ULONG                    i, j;

    PAGED_CODE();

    driverObjectExtension =
        (PDRIVER_OBJECT_EXTENSION) IoGetDriverObjectExtension(
                                       FdoExtension->DriverObject,
                                       DRIVER_OBJECT_EXTENSION_ID
                                       );
    ASSERT (driverObjectExtension);

    FdoExtension->ControllerProperties.Size = sizeof (IDE_CONTROLLER_PROPERTIES);

    FdoExtension->ControllerProperties.DefaultPIO = 0;
    status = (*driverObjectExtension->PciIdeGetControllerProperties) (
                 FdoExtension->VendorSpecificDeviceEntension,
                 &FdoExtension->ControllerProperties
                 );

    //
    // Look in the registry to determine whether
    // UDMA 66 should be enabled for INTEL chipsets
    //
    FdoExtension->EnableUDMA66 = 0;
    status = PciIdeXGetDeviceParameter (
               FdoExtension->AttacheePdo,
               L"EnableUDMA66",
               &(FdoExtension->EnableUDMA66)
               );

#else

    NTSTATUS status;
    PCIIDE_CONFIG_HEADER pciHeader;
    ULONG ultraDmaSupport;
    ULONG xferMode;
    ULONG i;
    ULONG j;

    PAGED_CODE();

    //
    // grab ultra dma flag from the registry
    //
    ultraDmaSupport = 0;
    status = PciIdeXGetDeviceParameter (
               FdoExtension,
               UltraDmaSupport,
               &ultraDmaSupport
               );

    //
    // grab ultra dma flag from the registry
    //
    status = PciIdeXGetBusData (
                 FdoExtension,
                 &pciHeader,
                 0,
                 sizeof (pciHeader)
                 );
    if (!NT_SUCCESS(status)) {

        //
        // could get the pci config data, fake it
        //
        pciHeader.MasterIde = 0;
        pciHeader.Command.b.MasterEnable = 0;
    }

    xferMode = PIO_SUPPORT;
    if (pciHeader.MasterIde && pciHeader.Command.b.MasterEnable) {

        xferMode |= SWDMA_SUPPORT | MWDMA_SUPPORT;

        if (ultraDmaSupport) {

            xferMode |= UDMA_SUPPORT;
        }
    }

    for (i=0; i<MAX_IDE_CHANNEL; i++) {
        for (i=0; i<MAX_IDE_DEVICE; i++) {

            FdoExtension->ControllerProperties.SupportedTransferMode[i][j] = xferMode;
        }
    }

#endif
} // PciIdeInitControllerProperties

NTSTATUS
ControllerUsageNotification (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PCTRLFDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpSp;
    PULONG deviceUsageCount;

    ASSERT (DeviceObject);
    ASSERT (Irp);
    PAGED_CODE();

    fdoExtension = (PCTRLFDO_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT (fdoExtension);

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypePaging) {

        //
        // Adjust the paging path count for this device.
        //
        deviceUsageCount = &fdoExtension->PagingPathCount;

    } else if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeHibernation) {

        //
        // Adjust the paging path count for this device.
        //
        deviceUsageCount = &fdoExtension->HiberPathCount;

    } else if (irpSp->Parameters.UsageNotification.Type == DeviceUsageTypeDumpFile) {

        //
        // Adjust the paging path count for this device.
        //
        deviceUsageCount = &fdoExtension->CrashDumpPathCount;

    } else {

        deviceUsageCount = NULL;
        DebugPrint ((0,
                     "PCIIDEX: Unknown IRP_MN_DEVICE_USAGE_NOTIFICATION type: 0x%x\n",
                     irpSp->Parameters.UsageNotification.Type));
    }

    IoCopyCurrentIrpStackLocationToNext (Irp);

    IoSetCompletionRoutine (
        Irp,
        ControllerUsageNotificationCompletionRoutine,
        deviceUsageCount,
        TRUE,
        TRUE,
        TRUE);

    ASSERT(fdoExtension->AttacheeDeviceObject);
    return IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);

} // ControllerUsageNotification

NTSTATUS
ControllerUsageNotificationCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    )
{
    PCTRLFDO_EXTENSION fdoExtension;
    PIO_STACK_LOCATION irpSp;
    PULONG deviceUsageCount = Context;

    fdoExtension = (PCTRLFDO_EXTENSION) DeviceObject->DeviceExtension;
    ASSERT (fdoExtension);

    irpSp = IoGetCurrentIrpStackLocation(Irp);

    if (NT_SUCCESS(Irp->IoStatus.Status)) {

        if (deviceUsageCount) {

            IoAdjustPagingPathCount (
                deviceUsageCount,
                irpSp->Parameters.UsageNotification.InPath
                );
        }
    }

    return Irp->IoStatus.Status;
} // ControllerUsageNotificationCompletionRoutine


NTSTATUS
PciIdeGetBusStandardInterface(
    IN PCTRLFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    This routine gets the bus iterface standard information from the PDO.

Arguments:

Return Value:

    NT status.

--*/
{
    KEVENT event;
    NTSTATUS status;
    PIRP irp;
    IO_STATUS_BLOCK ioStatusBlock;
    PIO_STACK_LOCATION irpStack;

    KeInitializeEvent( &event, NotificationEvent, FALSE );

    irp = IoBuildSynchronousFsdRequest( IRP_MJ_PNP,
                                        FdoExtension->AttacheeDeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        &event,
                                        &ioStatusBlock );

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation( irp );
    irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpStack->Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_BUS_INTERFACE_STANDARD;
    irpStack->Parameters.QueryInterface.Size = sizeof( BUS_INTERFACE_STANDARD );
    irpStack->Parameters.QueryInterface.Version = 1;
    irpStack->Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->BusInterface;
    irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Initialize the status to error in case the ACPI driver decides not to
    // set it correctly.
    //

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    status = IoCallDriver(FdoExtension->AttacheeDeviceObject, irp);

    if (!NT_SUCCESS( status)) {

        return status;
    }

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
    }

    if (NT_SUCCESS(ioStatusBlock.Status)) {

        ASSERT (FdoExtension->BusInterface.SetBusData);
        ASSERT (FdoExtension->BusInterface.GetBusData);
    }

    return ioStatusBlock.Status;
}

NTSTATUS
ControllerQueryPnPDeviceState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PCTRLFDO_EXTENSION fdoExtension;
    PPNP_DEVICE_STATE deviceState;

    fdoExtension = (PCTRLFDO_EXTENSION) DeviceObject->DeviceExtension;
 
    DebugPrint((2, "QUERY_DEVICE_STATE for FDOE 0x%x\n", fdoExtension));

    if(fdoExtension->PagingPathCount != 0) {
        deviceState = (PPNP_DEVICE_STATE) &(Irp->IoStatus.Information);
        SETMASK((*deviceState), PNP_DEVICE_NOT_DISABLEABLE);
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;

    IoSkipCurrentIrpStackLocation (Irp);
    return IoCallDriver (fdoExtension->AttacheeDeviceObject, Irp);
} // ControllerQueryPnPDeviceState

#ifdef ENABLE_NATIVE_MODE
NTSTATUS
ControllerInterruptControl (
	IN PCTRLFDO_EXTENSION 	FdoExtension,
	IN ULONG				Channel,
	IN ULONG 				Disconnect
	)
{
	NTSTATUS status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR irqPartialDescriptors;
    PCM_RESOURCE_LIST               resourceListForKeep = NULL;
	ULONG	i;

	status = STATUS_SUCCESS;


	if (Disconnect) {

		DebugPrint((1, "PciIdex: Interrupt control for %x - disconnect\n", Channel));
		
		//
		// Disconnect the ISR
		//
		if ( (FdoExtension->InterruptObject[Channel])) { 

			IoDisconnectInterrupt (
				FdoExtension->InterruptObject[Channel]
				);

			FdoExtension->InterruptObject[Channel] = 0;
		}


	} else  {

		//
		// connect the ISR
		//

		PPCIIDE_INTERRUPT_CONTEXT				context; 

		DebugPrint((1, "PciIdex: Interrupt control for %x - reconnect\n", Channel));

		irqPartialDescriptors = FdoExtension->IrqPartialDescriptors[Channel];

		if (!irqPartialDescriptors) {
			return STATUS_UNSUCCESSFUL;
		}

		//
		// Fill in the context
		//
		context = (PPCIIDE_INTERRUPT_CONTEXT) &(FdoExtension->InterruptContext[Channel]);
		context->DeviceExtension = (PVOID)FdoExtension;
		context->ChannelNumber = Channel;

        status = IoConnectInterrupt(&FdoExtension->InterruptObject[Channel],
                                    (PKSERVICE_ROUTINE) ControllerInterrupt,
                                    (PVOID) context,
                                    (PKSPIN_LOCK) NULL,
                                    irqPartialDescriptors->u.Interrupt.Vector,
                                    (KIRQL) irqPartialDescriptors->u.Interrupt.Level,
                                    (KIRQL) irqPartialDescriptors->u.Interrupt.Level,
                                    irqPartialDescriptors->Flags & CM_RESOURCE_INTERRUPT_LATCHED ? Latched : LevelSensitive,
                                    (BOOLEAN) (irqPartialDescriptors->ShareDisposition == CmResourceShareShared),
                                    irqPartialDescriptors->u.Interrupt.Affinity,
                                    FALSE);
    

        if (!NT_SUCCESS(status)) {
    
            DebugPrint((1, 
						"PciIde: Can't connect interrupt %d\n", 
						irqPartialDescriptors->u.Interrupt.Vector));

            FdoExtension->InterruptObject[Channel] = NULL;
        }
	}

	return status;
}

#define SelectDevice(BaseIoAddress, deviceNumber, additional) \
    WRITE_PORT_UCHAR ((BaseIoAddress)->DriveSelect, (UCHAR)((((deviceNumber) & 0x1) << 4) | 0xA0 | additional))

BOOLEAN
ControllerInterrupt(
    IN PKINTERRUPT Interrupt,
	PVOID Context
	)
{
	UCHAR statusByte;
	PPCIIDE_INTERRUPT_CONTEXT context = Context;
	PCTRLFDO_EXTENSION fdoExtension = context->DeviceExtension;
	ULONG channel = context->ChannelNumber;
	PIDE_REGISTERS_1 baseIoAddress1 = &(fdoExtension->BaseIoAddress1[channel]);
	BOOLEAN interruptCleared = FALSE;

	DebugPrint((1, "Pciidex: ISR called for channel %d\n", channel));

	//
	// Check if the interrupts are enabled.
	// Don't enable the interrupts if both the isrs are not installed
	//
	if (!fdoExtension->NativeInterruptEnabled) {

		if (fdoExtension->ControllerIsrInstalled) {

			//
			// we have just connected the ISRs. At this point we don't know whether
			// we actually enabled the decodes or not. So enable the decodes and set the
			// flag
			//
			//
			// if this fails we already bugchecked.
			//
			ControllerEnableInterrupt(fdoExtension);

			fdoExtension->NativeInterruptEnabled = TRUE;

		} else {

			// 
			// cannot be us
			//
			return FALSE;
		}

	} else {

		if (!fdoExtension->ControllerIsrInstalled) {

			//
			// At this point we don't know whether the decodes are disabled or not. We should
			// enable them.
			//
			//
			// if this fails we already bugchecked.
			//
			ControllerEnableInterrupt(fdoExtension);

			//
			// Now fall thru and determine whether it is our interrupt.
			// we will disable the decodes after that.
			//
		} else {

			//
			// all is well. Go process the interrupt.
			//
		}
	}


	//
	// Both the ISRs should be installed and the interrupts should
	// be enabled at this point
	//
	ASSERT(fdoExtension->NativeInterruptEnabled);

	// ControllerIsrInstalled need not be set.
	// if we get called, then it means that we are still connected
	// however, if the flag ControllerIsrInstalled is not set, then it is
	// safe to assume that we are in the process of stopping the controller.
	// Just dismiss the interrupt, the normal way. We are yet to turn off the decodes.
	//

    //
    // Clear interrupt by reading status.
    //
    GetStatus(baseIoAddress1, statusByte);

	//
	// Check the Bus master registers
	//
	if (!fdoExtension->NoBusMaster[channel]) {

		BMSTATUS bmStatus;
		PIDE_BUS_MASTER_REGISTERS   bmRegister;

		//
		// Get the correct bus master register
		//
		bmRegister = (PIDE_BUS_MASTER_REGISTERS)(((PUCHAR)fdoExtension->TranslatedBusMasterBaseAddress) + channel*8);

		bmStatus = READ_PORT_UCHAR (&bmRegister->Status);

		DebugPrint((1, "BmStatus = 0x%x\n", bmStatus));

		//
		// is Interrupt bit set?
		//
		if (bmStatus & BMSTATUS_INTERRUPT) {
			WRITE_PORT_UCHAR (&bmRegister->Command, 0x0);  // disable BM
			WRITE_PORT_UCHAR (&bmRegister->Status, BUSMASTER_INTERRUPT);  // clear interrupt BM
			interruptCleared = TRUE;
		}
	}
    
	DebugPrint((1, "ISR for %d returning %d\n", channel, interruptCleared?1:0));

	//
	// NativeInterruptEnabled should be set at this point
	//
	if (!fdoExtension->ControllerIsrInstalled) {

		// we are in the stop or remove code path where this flag has been cleared and
		// we are about to disconnect the ISR. Disable the decodes. 
		//
		ControllerDisableInterrupt(fdoExtension);

		//
		// we have dismissed our interrupt. Now clear the interruptEnabled flag.
		//
		fdoExtension->NativeInterruptEnabled = FALSE;

		//
		// return InterruptCleared.
		// 
	}
	return interruptCleared;
}

/***
NTSTATUS
ControllerEnableDecode(
	IN PCTRLFDO_EXTENSION 	FdoExtension,
	IN BOOLEAN			Enable
	)
{
	USHORT cmd;
	NTSTATUS status;
    PCIIDE_CONFIG_HEADER pciIdeConfigHeader;

    status = PciIdeBusData(
                 FdoExtension,
                 &pciIdeConfigHeader,
                 0,
                 sizeof (PCIIDE_CONFIG_HEADER),
                 TRUE
                 );

    //
    // get pci command register
    //
    if (!NT_SUCCESS(status)) {

		return status;
	}

    cmd = pciIdeConfigHeader.Command.w;

    cmd &= ~(PCI_ENABLE_IO_SPACE |
             PCI_ENABLE_MEMORY_SPACE |
             PCI_ENABLE_BUS_MASTER);

    if (Enable) {

        //
        // Set enables
        //

        cmd |= (PCI_ENABLE_IO_SPACE | PCI_ENABLE_MEMORY_SPACE | PCI_ENABLE_BUS_MASTER);
    }

    //
    // Set the new command register into the device.
    //
	status = PciIdeBusData(
				 FdoExtension,
				 &cmd,
				 FIELD_OFFSET (PCIIDE_CONFIG_HEADER, Command),
				 sizeof (pciIdeConfigHeader.Command.w),
				 FALSE
				 );

	return status;
}
**/

NTSTATUS
PciIdeGetNativeModeInterface(
    IN PCTRLFDO_EXTENSION FdoExtension
    )
/*++

Routine Description:

    This routine gets the native ide iterface information from the PDO.

Arguments:

Return Value:

    NT status.

--*/
{
    KEVENT event;
    NTSTATUS status;
    PIRP irp;
    IO_STATUS_BLOCK ioStatusBlock;
    PIO_STACK_LOCATION irpStack;

    KeInitializeEvent( &event, NotificationEvent, FALSE );

    irp = IoBuildSynchronousFsdRequest( IRP_MJ_PNP,
                                        FdoExtension->AttacheeDeviceObject,
                                        NULL,
                                        0,
                                        NULL,
                                        &event,
                                        &ioStatusBlock );

    if (irp == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    irpStack = IoGetNextIrpStackLocation( irp );
    irpStack->MinorFunction = IRP_MN_QUERY_INTERFACE;
    irpStack->Parameters.QueryInterface.InterfaceType = (LPGUID) &GUID_PCI_NATIVE_IDE_INTERFACE;
    irpStack->Parameters.QueryInterface.Size = sizeof( PCI_NATIVE_IDE_INTERFACE );
    irpStack->Parameters.QueryInterface.Version = 1;
    irpStack->Parameters.QueryInterface.Interface = (PINTERFACE) &FdoExtension->NativeIdeInterface;
    irpStack->Parameters.QueryInterface.InterfaceSpecificData = NULL;

    //
    // Initialize the status to error in case the ACPI driver decides not to
    // set it correctly.
    //

    irp->IoStatus.Status = STATUS_NOT_SUPPORTED;

    status = IoCallDriver(FdoExtension->AttacheeDeviceObject, irp);

    if (!NT_SUCCESS( status)) {

        return status;
    }

    if (status == STATUS_PENDING) {

        KeWaitForSingleObject( &event, Executive, KernelMode, FALSE, NULL );
    }

    if (NT_SUCCESS(ioStatusBlock.Status)) {

        ASSERT (FdoExtension->NativeIdeInterface.InterruptControl);
    }

    return ioStatusBlock.Status;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\pciidex\power.h ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       power.h
//
//--------------------------------------------------------------------------

#if !defined (___power_h___)
#define ___power_h___

typedef struct _SET_POWER_STATE_CONTEXT {

    KEVENT       Event;
    NTSTATUS     Status;

} SET_POWER_STATE_CONTEXT, *PSET_POWER_STATE_CONTEXT;

typedef struct _FDO_POWER_CONTEXT *PFDO_POWER_CONTEXT;

NTSTATUS
PciIdeIssueSetPowerState (
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN POWER_STATE_TYPE Type,
    IN POWER_STATE      State,
    IN BOOLEAN          Sync
    );
                       
NTSTATUS
PciIdePowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );
                          
NTSTATUS
PciIdeXQueryPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PciIdeSetPdoPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
PciIdeSetFdoPowerState (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    );

NTSTATUS
FdoContingentPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN UCHAR MinorFunction,
    IN POWER_STATE PowerState,
    IN PVOID Context,
    IN PIO_STATUS_BLOCK IoStatus
    );

NTSTATUS
FdoPowerCompletionRoutine (
    IN PDEVICE_OBJECT DeviceObject,
    IN PIRP Irp,
    IN PVOID Context
    );

VOID
FdoChildReportPowerDown (
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN PCHANPDO_EXTENSION PdoExtension
    );
                       
NTSTATUS
FdoChildRequestPowerUp (
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN PCHANPDO_EXTENSION PdoExtension,
    IN PIRP               ChildPowerIrp
    );

NTSTATUS
FdoChildRequestPowerUpCompletionRoutine (
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    );
                       
NTSTATUS
FdoSystemPowerUpCompletionRoutine (
    IN PDEVICE_OBJECT       DeviceObject,
    IN UCHAR                MinorFunction,
    IN POWER_STATE          PowerState,
    IN PVOID                Context,
    IN PIO_STATUS_BLOCK     IoStatus
    );
#endif // ___power_h___
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\drivers\storage\ide\pciidex\pciidex.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 1997 - 1999
//
//  File:       pciidex.c
//
//--------------------------------------------------------------------------

#include "pciidex.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, DriverEntry)
#pragma alloc_text(PAGE, PciIdeXInitialize)
#pragma alloc_text(PAGE, PciIdeXAlwaysStatusSuccessIrp)
#pragma alloc_text(PAGE, DispatchPnp)
#pragma alloc_text(PAGE, DispatchWmi)
#pragma alloc_text(PAGE, PassDownToNextDriver)
#pragma alloc_text(PAGE, PciIdeInternalDeviceIoControl)
#pragma alloc_text(PAGE, PciIdeXGetDeviceParameter)
#pragma alloc_text(PAGE, PciIdeXGetDeviceParameterEx)
#pragma alloc_text(PAGE, PciIdeXRegQueryRoutine)

#pragma alloc_text(PAGE, PciIdeUnload)
#pragma alloc_text(PAGE, PciIdeXSyncSendIrp)

#pragma alloc_text(NONPAGE, PciIdeXGetBusData)
#pragma alloc_text(NONPAGE, PciIdeXSetBusData)
                         
#pragma alloc_text(NONPAGE, DispatchPower)
#pragma alloc_text(NONPAGE, NoSupportIrp)
#pragma alloc_text(NONPAGE, PciIdeBusData)
#pragma alloc_text(NONPAGE, PciIdeBusDataCompletionRoutine)
#pragma alloc_text(NONPAGE, PciIdeXSyncSendIrpCompletionRoutine)

#if DBG
#pragma alloc_text(PAGE, PciIdeXSaveDeviceParameter)
#endif // DBG
             
#endif // ALLOC_PRAGMA

//
// get the share code
//
#include "..\share\util.c"


#if DBG

ULONG PciIdeDebug = 0;
UCHAR DebugBuffer[128 * 6];

VOID
PciIdeDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )

/*++

Routine Description:

    Debug print for all SCSI drivers

Arguments:

    Debug print level between 0 and 3, with 3 being the most verbose.

Return Value:

    None

--*/

{
    va_list ap;

    va_start(ap, DebugMessage);

    if (DebugPrintLevel <= PciIdeDebug) {

        vsprintf(DebugBuffer, DebugMessage, ap);

        //DbgPrint(DebugBuffer);

#if 1
        DbgPrintEx(DPFLTR_PCIIDE_ID,
                   DPFLTR_INFO_LEVEL,
                   DebugBuffer
                   );
#endif
    }

    va_end(ap);

} // end DebugPrint()

#else

VOID
PciIdeDebugPrint(
    ULONG DebugPrintLevel,
    PCCHAR DebugMessage,
    ...
    )
{
    return;
}

#endif

//
// PnP Dispatch Table
//
PDRIVER_DISPATCH FdoPnpDispatchTable[NUM_PNP_MINOR_FUNCTION];
PDRIVER_DISPATCH PdoPnpDispatchTable[NUM_PNP_MINOR_FUNCTION];

//
// Po Dispatch Table
//
PDRIVER_DISPATCH FdoPowerDispatchTable[NUM_POWER_MINOR_FUNCTION];
PDRIVER_DISPATCH PdoPowerDispatchTable[NUM_POWER_MINOR_FUNCTION];

//
// Wmi Dispatch Table
//
PDRIVER_DISPATCH FdoWmiDispatchTable[NUM_WMI_MINOR_FUNCTION];
PDRIVER_DISPATCH PdoWmiDispatchTable[NUM_WMI_MINOR_FUNCTION];

NTSTATUS
DriverEntry(
    IN PDRIVER_OBJECT DriverObject,
    IN PUNICODE_STRING RegistryPath
    )
{
    PAGED_CODE();

    return STATUS_SUCCESS;
} // DriverEntry

NTSTATUS
PciIdeXInitialize(
    IN PDRIVER_OBJECT           DriverObject,
    IN PUNICODE_STRING          RegistryPath,
    IN PCONTROLLER_PROPERTIES   PciIdeGetControllerProperties,
    IN ULONG                    ExtensionSize
    )
{
    NTSTATUS status;
    PDRIVER_EXTENSION driverExtension;
    PDRIVER_OBJECT_EXTENSION driverObjectExtension;
    ULONG i;

    PAGED_CODE();

    status = IoAllocateDriverObjectExtension(
                 DriverObject,
                 DRIVER_OBJECT_EXTENSION_ID,
                 sizeof (DRIVER_OBJECT_EXTENSION),
                 &driverObjectExtension
                 );

    if (!NT_SUCCESS(status)) {

        DebugPrint ((0, "PciIde: Unable to create driver extension\n"));
        return status; 
    }
    ASSERT (driverObjectExtension);

    driverObjectExtension->PciIdeGetControllerProperties = PciIdeGetControllerProperties;
    driverObjectExtension->ExtensionSize                 = ExtensionSize;

    //
    // some entry point init.
    //
    DriverObject->DriverUnload                                  = PciIdeUnload;
    DriverObject->MajorFunction[IRP_MJ_POWER]                   = DispatchPower;
    DriverObject->MajorFunction[IRP_MJ_PNP]                     = DispatchPnp;
    DriverObject->MajorFunction[IRP_MJ_INTERNAL_DEVICE_CONTROL] = PciIdeInternalDeviceIoControl;
    DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL]          = DispatchWmi;

    driverExtension = DriverObject->DriverExtension;
    driverExtension->AddDevice = ControllerAddDevice;

    //
    // FDO PnP Dispatch Table
    //
    for (i=0; i<NUM_PNP_MINOR_FUNCTION; i++) {

        FdoPnpDispatchTable[i] = PassDownToNextDriver;
    }
    FdoPnpDispatchTable[IRP_MN_START_DEVICE             ] = ControllerStartDevice;
    FdoPnpDispatchTable[IRP_MN_QUERY_REMOVE_DEVICE      ] = StatusSuccessAndPassDownToNextDriver;
    FdoPnpDispatchTable[IRP_MN_CANCEL_REMOVE_DEVICE     ] = StatusSuccessAndPassDownToNextDriver;
    FdoPnpDispatchTable[IRP_MN_STOP_DEVICE              ] = ControllerStopDevice;
    FdoPnpDispatchTable[IRP_MN_QUERY_STOP_DEVICE        ] = StatusSuccessAndPassDownToNextDriver;
    FdoPnpDispatchTable[IRP_MN_CANCEL_STOP_DEVICE       ] = StatusSuccessAndPassDownToNextDriver;
    FdoPnpDispatchTable[IRP_MN_REMOVE_DEVICE            ] = ControllerRemoveDevice;
    FdoPnpDispatchTable[IRP_MN_QUERY_DEVICE_RELATIONS   ] = ControllerQueryDeviceRelations;
    FdoPnpDispatchTable[IRP_MN_QUERY_INTERFACE          ] = ControllerQueryInterface;
    FdoPnpDispatchTable[IRP_MN_DEVICE_USAGE_NOTIFICATION] = ControllerUsageNotification;
    FdoPnpDispatchTable[IRP_MN_QUERY_PNP_DEVICE_STATE   ] = ControllerQueryPnPDeviceState;
    FdoPnpDispatchTable[IRP_MN_SURPRISE_REMOVAL         ] = ControllerSurpriseRemoveDevice;

    //
    // PDO PnP Dispatch Table
    //
    for (i=0; i<NUM_PNP_MINOR_FUNCTION; i++) {

        PdoPnpDispatchTable[i] = NoSupportIrp;
    }
    PdoPnpDispatchTable[IRP_MN_START_DEVICE               ] = ChannelStartDevice;
    PdoPnpDispatchTable[IRP_MN_QUERY_REMOVE_DEVICE        ] = ChannelQueryStopRemoveDevice;
    PdoPnpDispatchTable[IRP_MN_REMOVE_DEVICE              ] = ChannelRemoveDevice;
    PdoPnpDispatchTable[IRP_MN_CANCEL_REMOVE_DEVICE       ] = PciIdeXAlwaysStatusSuccessIrp;
    PdoPnpDispatchTable[IRP_MN_STOP_DEVICE                ] = ChannelStopDevice;
    PdoPnpDispatchTable[IRP_MN_QUERY_STOP_DEVICE          ] = ChannelQueryStopRemoveDevice;
    PdoPnpDispatchTable[IRP_MN_CANCEL_STOP_DEVICE         ] = PciIdeXAlwaysStatusSuccessIrp;
    PdoPnpDispatchTable[IRP_MN_QUERY_CAPABILITIES         ] = ChannelQueryCapabitilies;
    PdoPnpDispatchTable[IRP_MN_QUERY_RESOURCES            ] = ChannelQueryResources;
    PdoPnpDispatchTable[IRP_MN_QUERY_RESOURCE_REQUIREMENTS] = ChannelQueryResourceRequirements;
    PdoPnpDispatchTable[IRP_MN_QUERY_DEVICE_TEXT          ] = ChannelQueryText;
    PdoPnpDispatchTable[IRP_MN_QUERY_ID                   ] = ChannelQueryId;
    PdoPnpDispatchTable[IRP_MN_QUERY_DEVICE_RELATIONS     ] = ChannelQueryDeviceRelations;
    PdoPnpDispatchTable[IRP_MN_QUERY_INTERFACE            ] = PciIdeChannelQueryInterface;
    PdoPnpDispatchTable[IRP_MN_DEVICE_USAGE_NOTIFICATION  ] = ChannelUsageNotification;
    PdoPnpDispatchTable[IRP_MN_QUERY_PNP_DEVICE_STATE     ] = ChannelQueryPnPDeviceState;
    PdoPnpDispatchTable[IRP_MN_SURPRISE_REMOVAL           ] = ChannelRemoveDevice;
    PdoPnpDispatchTable[IRP_MN_FILTER_RESOURCE_REQUIREMENTS] = ChannelFilterResourceRequirements;

    //
    // FDO Power Dispatch Table
    //
    for (i=0; i<NUM_POWER_MINOR_FUNCTION; i++) {

        FdoPowerDispatchTable[i] = PassDownToNextDriver;
    }
    FdoPowerDispatchTable[IRP_MN_SET_POWER]   = PciIdeSetFdoPowerState;
    FdoPowerDispatchTable[IRP_MN_QUERY_POWER] = PciIdeXQueryPowerState;

    //
    // PDO Power Dispatch Table
    //
    for (i=0; i<NUM_POWER_MINOR_FUNCTION; i++) {

        PdoPowerDispatchTable[i] = NoSupportIrp;
    }
    PdoPowerDispatchTable[IRP_MN_SET_POWER]   = PciIdeSetPdoPowerState;
    PdoPowerDispatchTable[IRP_MN_QUERY_POWER] = PciIdeXQueryPowerState;

    //
    // FDO WMI Dispatch Table
    //
    for (i=0; i<NUM_WMI_MINOR_FUNCTION; i++) {

        FdoWmiDispatchTable[i] = PassDownToNextDriver;
    }

    //
    // PDO WMI Dispatch Table
    //
    for (i=0; i<NUM_WMI_MINOR_FUNCTION; i++) {

        PdoWmiDispatchTable[i] = NoSupportIrp;
    }

    //
    // Create device object name directory
    //
    IdeCreateIdeDirectory();

    return status;
} // PciIdeXInitialize

NTSTATUS
PciIdeXAlwaysStatusSuccessIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
/*++

Routine Description:

    Generic routine to STATUS_SUCCESS an irp

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP.

Return Value:

    NT status.

--*/
    )
{
    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return STATUS_SUCCESS;
} // PciIdeXAlwaysStatusSuccessIrp

NTSTATUS
DispatchPower(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION       thisIrpSp;
    NTSTATUS                 status;
    PDEVICE_EXTENSION_HEADER doExtension;

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //
    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    doExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    DebugPrint ((2, 
                 "PciIde: %s %d got %s\n",
                 doExtension->AttacheeDeviceObject ? "FDO" : "PDO",
                 doExtension->AttacheeDeviceObject ? 0 :
                    ((PCHANPDO_EXTENSION) doExtension)->ChannelNumber,
                 IdeDebugPowerIrpName[thisIrpSp->MinorFunction]));


    switch (thisIrpSp->MinorFunction) {

        case IRP_MN_WAIT_WAKE:
            DebugPrint ((2, "IRP_MN_WAIT_WAKE\n"));
            break;

        case IRP_MN_POWER_SEQUENCE:
            DebugPrint ((2, "IRP_MN_POWER_SEQUENCE\n"));
            break;

        case IRP_MN_SET_POWER:
            DebugPrint ((2, "IRP_MN_SET_POWER\n"));
            break;

        case IRP_MN_QUERY_POWER:
            DebugPrint ((2, "IRP_MN_QUERY_POWER\n"));
            break;

        default:
            DebugPrint ((2, "IRP_MN_0x%x\n", thisIrpSp->MinorFunction));
            break;
    }

    // Should always pass the irp down. It is taken care by the corresponding dispatch
    // funtion. 
    //

    if (thisIrpSp->MinorFunction < NUM_POWER_MINOR_FUNCTION) {

        status = doExtension->PowerDispatchTable[thisIrpSp->MinorFunction] (DeviceObject, Irp);
    } else {

        DebugPrint ((1,
					 "ATAPI: Power Dispatch Table too small\n"
					 ));

        status = doExtension->DefaultDispatch (DeviceObject, Irp);
    }

    return status;
} // DispatchPower

NTSTATUS
DispatchPnp(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine handles all IRP_MJ_PNP_POWER IRPs for this driver.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION  thisIrpSp;
    NTSTATUS            status;
    PDEVICE_EXTENSION_HEADER doExtension;

    PAGED_CODE();

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //
    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    doExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    DebugPrint ((2, 
                 "PciIde: %s %d got %s\n",
                 doExtension->AttacheeDeviceObject ? "FDO" : "PDO",
                 doExtension->AttacheeDeviceObject ? 0 :
                    ((PCHANPDO_EXTENSION) doExtension)->ChannelNumber,
                 IdeDebugPnpIrpName[thisIrpSp->MinorFunction]));

    if (thisIrpSp->MinorFunction < NUM_PNP_MINOR_FUNCTION) {

        status = doExtension->PnPDispatchTable[thisIrpSp->MinorFunction] (DeviceObject, Irp);
    } else {

        if (thisIrpSp->MinorFunction != 0xff) {

            ASSERT (!"ATAPI: PnP Dispatch Table too small\n");
        }

        status = doExtension->DefaultDispatch (DeviceObject, Irp);
    }

    return status;
} // DispatchPnp

NTSTATUS
DispatchWmi(
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
/*++

Routine Description:

    This routine handles all IRP_MJ_SYSTEM_CONTROL (WMI) IRPs for this driver.

Arguments:

    DeviceObject - Pointer to the device object for which this IRP applies.

    Irp - Pointer to the IRP_MJ_PNP_POWER IRP to dispatch.

Return Value:

    NT status.

--*/
{
    PIO_STACK_LOCATION  thisIrpSp;
    NTSTATUS            status;
    PDEVICE_EXTENSION_HEADER doExtension;

    PAGED_CODE();

    //
    // Get a pointer to our stack location and take appropriate action based
    // on the minor function.
    //
    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    doExtension = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    DebugPrint ((2, 
                 "PciIde: %s %d got %s\n",
                 doExtension->AttacheeDeviceObject ? "FDO" : "PDO",
                 doExtension->AttacheeDeviceObject ? 0 :
                    ((PCHANPDO_EXTENSION) doExtension)->ChannelNumber,
                 IdeDebugWmiIrpName[thisIrpSp->MinorFunction]));

    if (thisIrpSp->MinorFunction < NUM_WMI_MINOR_FUNCTION) {

        status = doExtension->WmiDispatchTable[thisIrpSp->MinorFunction] (DeviceObject, Irp);
    } else {

        DebugPrint ((1,
					 "ATAPI: WMI Dispatch Table too small\n"
					 ));

        status = doExtension->DefaultDispatch (DeviceObject, Irp);
    }

    return status;
} // DispatchWmi()


NTSTATUS
PassDownToNextDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PDEVICE_EXTENSION_HEADER deviceExtensionHeader;
    NTSTATUS            status;
    PIO_STACK_LOCATION  thisIrpSp;

    PAGED_CODE();

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );
    deviceExtensionHeader = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    ASSERT (deviceExtensionHeader->AttacheeDeviceObject);

	if (thisIrpSp->MajorFunction == IRP_MJ_POWER) {

		//
		// call PoStartNextPowerIrp before completing a power irp
		//
		PoStartNextPowerIrp (Irp);
		IoSkipCurrentIrpStackLocation (Irp);
		status = PoCallDriver (deviceExtensionHeader->AttacheeDeviceObject, Irp);

	} else {

		//
		// Not a power irp
		//
		IoSkipCurrentIrpStackLocation (Irp);
		status = IoCallDriver (deviceExtensionHeader->AttacheeDeviceObject, Irp);
	}

    return status;
} // PassDownToNextDriver

NTSTATUS
StatusSuccessAndPassDownToNextDriver (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PDEVICE_EXTENSION_HEADER deviceExtensionHeader;

    PAGED_CODE();

    IoSkipCurrentIrpStackLocation (Irp);

    deviceExtensionHeader = (PDEVICE_EXTENSION_HEADER) DeviceObject->DeviceExtension;

    Irp->IoStatus.Status = STATUS_SUCCESS;
    return IoCallDriver (deviceExtensionHeader->AttacheeDeviceObject, Irp);
} // PassDownToNextDriver


NTSTATUS
NoSupportIrp (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PIO_STACK_LOCATION       thisIrpSp;
    NTSTATUS status = Irp->IoStatus.Status;

    thisIrpSp = IoGetCurrentIrpStackLocation( Irp );

	//
	// You should call PoStartNextPowerIrp before completing a power irp
	//
	if (thisIrpSp->MajorFunction == IRP_MJ_POWER) {

		PoStartNextPowerIrp (Irp);

	}

    DebugPrint ((
        1,
        "IdePort: devobj 0x%x failing unsupported Irp (0x%x, 0x%x) with status = %x\n",
        DeviceObject,
        thisIrpSp->MajorFunction,
        thisIrpSp->MinorFunction,
		status
        ));

    IoCompleteRequest( Irp, IO_NO_INCREMENT );
    return status;
} // NoSupportIrp

NTSTATUS
PciIdeXGetBusData(
    IN PVOID DeviceExtension,
    IN PVOID Buffer,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength
    )
{
    PCTRLFDO_EXTENSION fdoExtension = ((PCTRLFDO_EXTENSION) DeviceExtension) - 1;

    return PciIdeBusData(
               fdoExtension,
               Buffer,
               ConfigDataOffset,
               BufferLength,
               TRUE
               );
} // PciIdeXGetBusData

NTSTATUS
PciIdeXSetBusData(
    IN PVOID DeviceExtension,
    IN PVOID Buffer,
    IN PVOID DataMask,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength
    )
{
    PCTRLFDO_EXTENSION fdoExtension = ((PCTRLFDO_EXTENSION) DeviceExtension) - 1;
    NTSTATUS status;
    PUCHAR pciData;
    KIRQL currentIrql;

    pciData = ExAllocatePool (NonPagedPool, BufferLength);
    if (pciData == NULL) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    KeAcquireSpinLock(
        &fdoExtension->PciConfigDataLock, 
        &currentIrql);
             
    //
    // get the current values
    //
    status = PciIdeBusData(
                 fdoExtension,
                 pciData,
                 ConfigDataOffset,
                 BufferLength,
                 TRUE
                 );
    if (NT_SUCCESS(status)) {

        ULONG i;
        PUCHAR dataMask = (PUCHAR) DataMask;
        PUCHAR newData = (PUCHAR) Buffer;

        for (i=0; i<BufferLength; i++) {

            // optimize for ULONG

            //
            // update bits according to the mask
            //
            pciData[i] = (pciData[i] & ~dataMask[i]) | (dataMask[i] & newData[i]);
        }

        status = PciIdeBusData(
                     fdoExtension,
                     pciData,
                     ConfigDataOffset,
                     BufferLength,
                     FALSE
                     );
    }

    KeReleaseSpinLock(
        &fdoExtension->PciConfigDataLock, 
        currentIrql);
        
    ExFreePool (pciData);
    return status;

} // PciIdeXSetBusData

NTSTATUS
PciIdeBusData(
    IN PCTRLFDO_EXTENSION FdoExtension,
    IN OUT PVOID Buffer,
    IN ULONG ConfigDataOffset,
    IN ULONG BufferLength,
    IN BOOLEAN ReadConfigData
    )
{
    ULONG byteTransferred;
    PGET_SET_DEVICE_DATA BusDataFunction;

    if (ReadConfigData) {

        BusDataFunction = FdoExtension->BusInterface.GetBusData;

    } else {

        BusDataFunction = FdoExtension->BusInterface.SetBusData;
    }

 //   if (!BusDataFunction) {
  //      DebugPrint((0, "PCIIDEX: ERROR: NULL BusDataFunction\n"));
   //     return STATUS_UNSUCCESSFUL;
    //}

    byteTransferred = BusDataFunction (
                         FdoExtension->BusInterface.Context,
                         PCI_WHICHSPACE_CONFIG,
                         Buffer,
                         ConfigDataOffset,
                         BufferLength
                         );

    if (byteTransferred != BufferLength) {

        return STATUS_UNSUCCESSFUL;

    } else {

        return STATUS_SUCCESS;
    }

} // PciIdeBusData

NTSTATUS
PciIdeBusDataCompletionRoutine(
    PDEVICE_OBJECT DeviceObject,
    PIRP Irp,
    PVOID Context
    )
{
    PIO_STATUS_BLOCK ioStatus = (PIO_STATUS_BLOCK) Context;
    PKEVENT          event;

    ioStatus->Status = Irp->IoStatus.Status;
    event = (PKEVENT) ioStatus->Information;
    KeSetEvent (event, 0, FALSE);

    IoFreeIrp (Irp);
    return STATUS_MORE_PROCESSING_REQUIRED;
} // PciIdeBusDataCompletionRoutine

NTSTATUS
PciIdeInternalDeviceIoControl (
    IN PDEVICE_OBJECT DeviceObject,
    IN OUT PIRP Irp
    )
{
    PDEVICE_EXTENSION_HEADER DoExtensionHeader;
    NTSTATUS status;

    PAGED_CODE();

    DoExtensionHeader = DeviceObject->DeviceExtension;

    if (DoExtensionHeader->AttacheeDeviceObject == NULL) {

        //
        // PDO
        //
        status = ChannelInternalDeviceIoControl (
            DeviceObject,
            Irp
            );

    } else {

        //
        // FDO
        //

        status = Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IoCompleteRequest( Irp, IO_NO_INCREMENT );
    }

    return status;
} // PciIdeInternalDeviceIoControl

NTSTATUS
PciIdeXRegQueryRoutine (
    IN PWSTR ValueName,
    IN ULONG ValueType,
    IN PVOID ValueData,
    IN ULONG ValueLength,
    IN PVOID Context,
    IN PVOID EntryContext
)
{
    PVOID *parameterValue = EntryContext;

    PAGED_CODE();

    if (ValueType == REG_MULTI_SZ) {

        *parameterValue = ExAllocatePool(PagedPool, ValueLength);

        if (*parameterValue) {

            RtlMoveMemory(*parameterValue, ValueData, ValueLength);
            return STATUS_SUCCESS;
        }

    } else if (ValueType == REG_DWORD) {

        PULONG ulongValue;

        ulongValue = (PULONG) parameterValue;
        *ulongValue = *((PULONG) ValueData);
        return STATUS_SUCCESS;
    }

    return STATUS_UNSUCCESSFUL;
}
NTSTATUS
PciIdeXGetDeviceParameterEx (
    IN     PDEVICE_OBJECT      DeviceObject,
    IN     PWSTR               ParameterName,
    IN OUT PVOID              *ParameterValue
    )
/*++

Routine Description:

    retrieve a devnode registry parameter

Arguments:

    FdoExtension - FDO Extension
    
    ParameterName - parameter name to look up                                        
                                           
    ParameterValuse - default parameter value

Return Value:

    NT Status

--*/
{
    NTSTATUS                 status;
    HANDLE                   deviceParameterHandle;
    RTL_QUERY_REGISTRY_TABLE queryTable[2];
    ULONG                    i;
    ULONG                    flag;

    PAGED_CODE();

    *ParameterValue = NULL;

    for (i=0; i<2; i++) {

        if (i == 0) {

            flag = PLUGPLAY_REGKEY_DRIVER | PLUGPLAY_REGKEY_CURRENT_HWPROFILE;

        } else {

            flag = PLUGPLAY_REGKEY_DRIVER;
        }
        //
        // open the given parameter
        //
        status = IoOpenDeviceRegistryKey(DeviceObject,
                                         flag,
                                         KEY_READ,
                                         &deviceParameterHandle);
    
        if(!NT_SUCCESS(status)) {
    
            continue;
        }
    
        RtlZeroMemory(queryTable, sizeof(queryTable));
    
        queryTable->QueryRoutine  = PciIdeXRegQueryRoutine;
        queryTable->Flags         = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
        queryTable->Name          = ParameterName;
        queryTable->EntryContext  = ParameterValue;
        queryTable->DefaultType   = REG_NONE;
        queryTable->DefaultData   = NULL;
        queryTable->DefaultLength = 0;
    
        status = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                        (PWSTR) deviceParameterHandle,
                                        queryTable,
                                        NULL,
                                        NULL);
        if (!NT_SUCCESS(status)) {
    
            *ParameterValue = NULL;
        }
    
        //
        // close what we open
        //
        ZwClose(deviceParameterHandle);

        if (NT_SUCCESS(status)) {

            break;
        }
    }
    return status;

} // PciIdeXGetDeviceParameter

NTSTATUS
PciIdeXGetDeviceParameter (
    IN     PDEVICE_OBJECT      DeviceObject,
    IN     PWSTR               ParameterName,
    IN OUT PULONG              ParameterValue
    )
/*++

Routine Description:

    retrieve a devnode registry parameter

Arguments:

    FdoExtension - FDO Extension
    
    ParameterName - parameter name to look up