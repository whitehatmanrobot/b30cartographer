ine,
        pContext,
        pszHeader,
        Indent,
        & pSab->Sockaddr,
        pSab->SockaddrLength
        );

    PrintRoutine(
        pContext,
        "%s\tsockaddr len   = %d\n"
        "%s\tprefix len     = %d\n"
        "%s\tflags          = %08x\n"
        "%s\tstatus         = %d\n"
        "%s\tpriority       = %d\n",
        pindent,    pSab->SockaddrLength,
        pindent,    pSab->SubnetLength,
        pindent,    pSab->Flags,
        pindent,    pSab->Status,
        pindent,    pSab->Priority );

    DnsPrint_Unlock();
}



VOID
DnsPrint_DnsAddrArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszName,
    IN      PDNS_ADDR_ARRAY pArray
    )
/*++

Routine Description:

    Print IP address array struct

    Just pass through to more generic print routine.

--*/
{
    DWORD   i;
    CHAR    buffer[ DNS_ADDR_STRING_BUFFER_LENGTH ];

    if ( !pszName )
    {
        pszName = "Addr";
    }
    if ( !pszHeader )
    {
        pszHeader = "IP Array";
    }

    //  protect against NULL case

    if ( !pArray )
    {
        PrintRoutine(
            pContext,
            "%s \tNULL IP Array.\n",
            pszHeader );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\n"
        "\tPtr          = %p\n"
        "\tMaxCount     = %d\n"
        "\tAddrCount    = %d\n",
        pszHeader,
        pArray,
        pArray->MaxCount,
        pArray->AddrCount );

    for( i=0; i<pArray->AddrCount; i++ )
    {
        //  convert DNS_ADDR to string
    
        DnsAddr_WriteStructString_A(
            buffer,
            & pArray->AddrArray[i] );

        PrintRoutine(
            pContext,
            "\t%s[%d] => %s\n",
            pszName,
            i,
            buffer );
    }

    DnsPrint_Unlock();
}



//
//  DNS message stuff
//

INT
Dns_WritePacketNameToBuffer(
    OUT     PCHAR           pBuffer,
    OUT     PCHAR *         ppBufferOut,
    IN      PBYTE           pMsgName,
    IN      PDNS_HEADER     pMsgHead,       OPTIONAL
    IN      PBYTE           pMsgEnd         OPTIONAL
    )
/*++

Routine Description:

    Write packet name into buffer.

Arguments:

    pBuffer -       buffer to print to, MUST be twice DNS_MAX_NAME_LENGTH
                    to avoid overflows on bad packets

    ppBufferOut -   ptr to terminating NULL in buffer conversion, this
                    is position at which additional printing to buffer
                    could resume

    pMsgName -      ptr to name in packet to print

    pMsgHead -      ptr to DNS message;  need for offsetting, if not given
                    names are not printed past first offset

    pMsgEnd -       ptr to end of message, specifically byte immediately after
                    message

Return Value:

    Count of bytes in packet name occupied.
    This offset from pMsgName is the next field in the packet.

    Zero return indicates error in message name.

--*/
{
    register PUCHAR pchbuf;
    register PUCHAR pchmsg;
    register UCHAR  cch;
    PCHAR           pbufStop;
    PCHAR           pnextLabel;
    UCHAR           compressionType;
    WORD            offset;
    PCHAR           pbyteAfterFirstOffset = NULL;

    //
    //  no message end specified?
    //  make it max ptr so we can do single test for ptr validity
    //  rather than testing for pMsgEnd existence first
    //

    if ( !pMsgEnd )
    {
        pMsgEnd = (PVOID)(INT_PTR)(-1);
    }

    //
    //  loop until copy as printable name, or hit compression or name error
    //
    //  buffer must be twice max label length
    //      - allow extra chars for label length byte and compression printing
    //      - but stop printing when within a label of end as label (or error
    //          message) is copied in one blob without end check
    //

    pchbuf = pBuffer;
    pbufStop = pchbuf + 2*DNS_MAX_NAME_LENGTH - DNS_MAX_LABEL_LENGTH - 10;
    pchmsg = pMsgName;

    while ( 1 )
    {
        //  bounds checking to survive bad packet
        //
        //  DEVNOTE:  note this is not strictly a bad packet (could be just a
        //      heck of a lot of labels) and we could
        //          a) let packet processing proceed without printing
        //          or
        //          b) require buffer that could contain max legal DNS name
        //      but not worth the effort

        if ( pchbuf >= pbufStop )
        {
            pchbuf += sprintf(
                        pchbuf,
                        "[ERROR name exceeds safe print buffer length]\r\n" );
            pchmsg = pMsgName;
            break;
        }

        cch = (UCHAR) *pchmsg++;
        compressionType = cch & 0xC0;

        DNSDBG( OFF, (
            "byte = (%d) (0x%02x)\r\n"
            "compress flag = (%d) (0x%02x)\r\n",
            cch, cch,
            compressionType, compressionType ));

        //
        //  normal length byte
        //      - write length field
        //      - copy label to print buffer
        //

        if ( compressionType == 0 )
        {
            pchbuf += sprintf( pchbuf, "(%d)", (INT)cch );

            //  terminate at root name

            if ( ! cch )
            {
                break;
            }

            //  check that within packet

            pnextLabel = pchmsg + cch;
            if ( pnextLabel >= pMsgEnd )
            {
                pchbuf += sprintf(
                            pchbuf,
                            "[ERROR length byte: 0x%02X at %p leads outside message]\r\n",
                            cch,
                            pchmsg );

                //  force zero byte return

                pchmsg = pMsgName;
                break;
            }

            //  copy label to output string

            memcpy(
                pchbuf,
                pchmsg,
                cch );

            pchbuf += cch;
            pchmsg = pnextLabel;
            continue;
        }

        //
        //  valid compression
        //

        else if ( compressionType == (UCHAR)0xC0 )
        {
            //  check that compression word not straddling message end

            if ( pchmsg >= pMsgEnd )
            {
                pchbuf += sprintf(
                            pchbuf,
                            "[ERROR compression word at %p is outside message]\r\n",
                            pchmsg );

                //  force zero byte return

                pchmsg = pMsgName;
                break;
            }

            //  calculate offset

            offset = cch;          // high byte
            offset <<= 8;
            offset |= *pchmsg++;   // low byte

            pchbuf += sprintf(
                        pchbuf,
                        "[%04hX]",
                        offset );

            if ( pMsgHead )
            {
                //
                //  on first compression, save ptr to byte immediately after
                //      name, so can calculate next byte
                //
                //  save ptr to next byte in mess, to calculate actual length
                //      name takes up in packet
                //

                if ( ! pbyteAfterFirstOffset )
                {
                    pbyteAfterFirstOffset = pchmsg;
                }

                //
                //  jump to offset for continuation of name
                //      - clear two highest bits to get length
                //

                offset = offset ^ 0xC000;
                DNS_ASSERT( (offset & 0xC000) == 0 );

                pnextLabel = (PCHAR)pMsgHead + offset;
                if ( pnextLabel >= pchmsg - sizeof(WORD) )
                {
                    pchbuf += sprintf(
                                pchbuf,
                                "[ERROR offset at %p to higher byte in packet %p]\r\n",
                                pchmsg - sizeof(WORD),
                                pnextLabel );
                    break;
                }
                pchmsg = pnextLabel;
                continue;
            }

            //  if no ptr to message head, can not continue at offset
            //  NULL terminate previous label

            else
            {
                *pchbuf++ = 0;
                break;
            }
        }

        //
        //  invalid compression
        //      - force zero byte return to indicate error

        else
        {
            pchbuf += sprintf(
                        pchbuf,
                        "[ERROR length byte: 0x%02X]",
                        cch );
            pchmsg = pMsgName;
            break;
        }
    }

    //
    //  return ptr to next position in output buffer
    //

    if ( ppBufferOut )
    {
        *ppBufferOut = pchbuf;
    }

    //
    //  return number of bytes read from message
    //

    if ( pbyteAfterFirstOffset )
    {
        pchmsg = pbyteAfterFirstOffset;
    }
    return (INT)( pchmsg - pMsgName );
}



INT
DnsPrint_PacketName(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,      OPTIONAL
    IN      PBYTE           pMsgName,
    IN      PDNS_HEADER     pMsgHead,       OPTIONAL
    IN      PBYTE           pMsgEnd,        OPTIONAL
    IN      PSTR            pszTrailer      OPTIONAL
    )
/*++

Routine Description:

    Print DNS name given in packet format.

Arguments:

    PrintRoutine -  routine to print with

    pszHeader -     header to print

    pMsgHead -      ptr to DNS message;  need for offsetting, if not given
                    names are not printed past first offset

    pMsgName -      ptr to name in packet to print

    pMsgEnd -       ptr to end of message;  OPTIONAL, but needed to protect
                    against AV accessing bad packet names

    pszTrailer -    trailer to print after name

Return Value:

    Count of bytes in packet name occupied.
    This offset from pMsgName is the next field in the packet.

    Zero return indicates error in message name.

--*/
{
    INT     countNameBytes;

    //  name buffer, allow space for full name, plus parens on length
    //  fields plus several compression flags

    CHAR    PrintName[ 2*DNS_MAX_NAME_LENGTH ];


    if ( ! pMsgName )
    {
        PrintRoutine(
            pContext,
            "%s(NULL packet name ptr)%s\r\n",
            pszHeader ? pszHeader : "",
            pszTrailer ? pszTrailer : ""
            );
        return 0;
    }

    //
    //  build packet name into buffer, then print
    //

    countNameBytes = Dns_WritePacketNameToBuffer(
                        PrintName,
                        NULL,
                        pMsgName,
                        pMsgHead,
                        pMsgEnd
                        );
    PrintRoutine(
        pContext,
        "%s%s%s",
        pszHeader ? pszHeader : "",
        PrintName,
        pszTrailer ? pszTrailer : ""
        );

    return( countNameBytes );
}



VOID
DnsPrint_Message(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_MSG_BUF    pMsg
    )
/*++

Routine Description:

    Print DNS message buffer.
    Includes context information as well as actual DNS message.

--*/
{
    PDNS_HEADER pmsgHeader;
    PCHAR       pchRecord;
    PBYTE       pmsgEnd;
    INT         i;
    INT         isection;
    INT         cchName;
    WORD        wLength;
    WORD        wOffset;
    WORD        wXid;
    WORD        wQuestionCount;
    WORD        wAnswerCount;
    WORD        wNameServerCount;
    WORD        wAdditionalCount;
    WORD        countSectionRR;
    BOOL        fFlipped = FALSE;

    DnsPrint_Lock();

    if ( pszHeader )
    {
        PrintRoutine(
            pContext,
            "%s\r\n",
            pszHeader );
    }

    //  get message info
    //
    //  note:  length may not be correctly set while building message,
    //      so make pmsgEnd greater of given length and pCurrent ptr
    //      but allow for case where set back to pre-OPT length
    //

    wLength = pMsg->MessageLength;
    pmsgHeader = &pMsg->MessageHead;
    pmsgEnd = ((PBYTE)pmsgHeader) + wLength;

    if ( pmsgEnd < pMsg->pCurrent &&
         pmsgEnd != pMsg->pPreOptEnd )
    {
        pmsgEnd = pMsg->pCurrent;
    }

    //
    //  print header info
    //

    PrintRoutine(
        pContext,
        "%s %s info at %p\r\n"
        "  Socket = %d 4=%d 6=%d\r\n"
        "  Remote addr %s\r\n"
        "    fam    = %d\n"
        "    port   = %d\n"
        "    len    = %d\n"
        "  Buf length = 0x%04x\r\n"
        "  Msg length = 0x%04x\r\n"
        "  Message:\r\n",
        ( pMsg->fTcp
            ? "TCP"
            : "UDP" ),
        ( pmsgHeader->IsResponse
            ? "response"
            : "question" ),
        pMsg,
        pMsg->Socket,
        pMsg->Socket4,
        pMsg->Socket6,
        MSG_REMOTE_IPADDR_STRING( pMsg ),
        MSG_REMOTE_FAMILY( pMsg ),
        MSG_REMOTE_IP_PORT( pMsg ),
        pMsg->RemoteAddress.SockaddrLength,
        pMsg->BufferLength,
        wLength
        );

    PrintRoutine(
        pContext,
        "    XID       0x%04hx\r\n"
        "    Flags     0x%04hx\r\n"
        "        QR        0x%lx (%s)\r\n"
        "        OPCODE    0x%lx (%s)\r\n"
        "        AA        0x%lx\r\n"
        "        TC        0x%lx\r\n"
        "        RD        0x%lx\r\n"
        "        RA        0x%lx\r\n"
        "        Z         0x%lx\r\n"
        "        RCODE     0x%lx (%s)\r\n"
        "    QCOUNT    0x%hx\r\n"
        "    ACOUNT    0x%hx\r\n"
        "    NSCOUNT   0x%hx\r\n"
        "    ARCOUNT   0x%hx\r\n",

        pmsgHeader->Xid,
        ntohs((*((PWORD)pmsgHeader + 1))),

        pmsgHeader->IsResponse,
        (pmsgHeader->IsResponse ? "response" : "question"),
        pmsgHeader->Opcode,
        Dns_OpcodeString( pmsgHeader->Opcode ),
        pmsgHeader->Authoritative,
        pmsgHeader->Truncation,
        pmsgHeader->RecursionDesired,
        pmsgHeader->RecursionAvailable,
        pmsgHeader->Reserved,
        pmsgHeader->ResponseCode,
        Dns_ResponseCodeString( pmsgHeader->ResponseCode ),

        pmsgHeader->QuestionCount,
        pmsgHeader->AnswerCount,
        pmsgHeader->NameServerCount,
        pmsgHeader->AdditionalCount );

    //
    //  determine if byte flipped and get correct count
    //

    wXid                = pmsgHeader->Xid;
    wQuestionCount      = pmsgHeader->QuestionCount;
    wAnswerCount        = pmsgHeader->AnswerCount;
    wNameServerCount    = pmsgHeader->NameServerCount;
    wAdditionalCount    = pmsgHeader->AdditionalCount;

    if ( wQuestionCount )
    {
        fFlipped = wQuestionCount & 0xff00;
    }
    else if ( wNameServerCount )
    {
        fFlipped = wNameServerCount & 0xff00;
    }
    if ( fFlipped )
    {
        wXid                = ntohs( wXid );
        wQuestionCount      = ntohs( wQuestionCount );
        wAnswerCount        = ntohs( wAnswerCount );
        wNameServerCount    = ntohs( wNameServerCount );
        wAdditionalCount    = ntohs( wAdditionalCount );
    }

    //
    //  catch record flipping problems -- all are flipped or none at all
    //      and no record count should be > 256 EXCEPT answer count
    //      during FAST zone transfer
    //

    DNS_ASSERT( ! (wQuestionCount & 0xff00) );
    DNS_ASSERT( ! (wNameServerCount & 0xff00) );
    DNS_ASSERT( ! (wAdditionalCount & 0xff00) );

#if 0
    //
    //  stop here if WINS response -- don't have parsing ready
    //

    if ( pmsgHeader->IsResponse && IS_WINS_XID(wXid) )
    {
        PrintRoutine(
            pContext,
            "  WINS Response packet.\r\n\r\n" );
        goto Unlock;
    }
#endif

    //
    //  print questions and resource records
    //

    pchRecord = (PCHAR)(pmsgHeader + 1);

    for ( isection=0; isection<4; isection++)
    {
        PrintRoutine(
            pContext,
            "  %s Section:\r\n",
            Dns_SectionNameString( isection, pmsgHeader->Opcode ) );

        if ( isection==0 )
        {
            countSectionRR = wQuestionCount;
        }
        else if ( isection==1 )
        {
            countSectionRR = wAnswerCount;
        }
        else if ( isection==2 )
        {
            countSectionRR = wNameServerCount;
        }
        else if ( isection==3 )
        {
            countSectionRR = wAdditionalCount;
        }

        for ( i=0; i < countSectionRR; i++ )
        {
            //
            //  verify not overrunning length
            //      - check against pCurrent as well as message length
            //        so can print packets while being built
            //

            wOffset = (WORD)(pchRecord - (PCHAR)pmsgHeader);
            if ( wOffset >= wLength
                    &&
                pchRecord >= pMsg->pCurrent )
            {
                PrintRoutine(
                    pContext,
                    "ERROR:  BOGUS PACKET:\r\n"
                    "\tFollowing RR (offset %d) past packet length (%d).\r\n",
                    wOffset,
                    wLength
                    );
                goto Unlock;
            }

            //
            //  print RR name
            //

            PrintRoutine(
                pContext,
                "    Name Offset = 0x%04x\r\n",
                wOffset
                );

            cchName = DnsPrint_PacketName(
                            PrintRoutine,
                            pContext,
                            "    Name      \"",
                            pchRecord,
                            pmsgHeader,
                            pmsgEnd,
                            "\"\r\n" );
            if ( ! cchName )
            {
                PrintRoutine(
                    pContext,
                    "ERROR:  Invalid name length, stop packet print\r\n" );
                DNS_ASSERT( FALSE );
                break;
            }
            pchRecord += cchName;

            //  print question or resource record

            if ( isection == 0 )
            {
                PrintRoutine(
                    pContext,
                    "      QTYPE   %d\r\n"
                    "      QCLASS  %d\r\n",
                    FlipUnalignedWord( pchRecord ),
                    FlipUnalignedWord( pchRecord + sizeof(WORD) )
                    );
                pchRecord += sizeof( DNS_WIRE_QUESTION );
            }
            else
            {
                pchRecord += DnsPrint_PacketRecord(
                                PrintRoutine,
                                pContext,
                                NULL,
                                (PDNS_WIRE_RECORD) pchRecord,
                                pmsgHeader,
                                pmsgEnd
                                );
            }
        }
    }

    //  check that at proper end of packet

    wOffset = (WORD)(pchRecord - (PCHAR)pmsgHeader);
    if ( pchRecord < pMsg->pCurrent || wOffset < wLength )
    {
        PrintRoutine(
            pContext,
            "WARNING:  message continues beyond these records\r\n"
            "\tpch = %p, pCurrent = %p, %d bytes\r\n"
            "\toffset = %d, msg length = %d, %d bytes\r\n",
            pchRecord,
            pMsg->pCurrent,
            pMsg->pCurrent - pchRecord,
            wOffset,
            wLength,
            wLength - wOffset );
    }
    PrintRoutine(
        pContext,
        "  Message length = %04x\n\r\n",
        wOffset );

Unlock:
    DnsPrint_Unlock();


}   // DnsPrint_Message



INT
DnsPrint_PacketRecord(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PDNS_WIRE_RECORD    pMsgRR,
    IN      PDNS_HEADER         pMsgHead,       OPTIONAL
    IN      PBYTE               pMsgEnd         OPTIONAL
    )
/*++

Routine Description:

    Print RR in packet format.

Arguments:

    pszHeader - Header message/name for RR.

    pMsgRR    - resource record to print

    pMsgHead  - ptr to DNS message;  need for offsetting, if not given
                names are not printed past first offset

    pMsgEnd   - ptr to end of message, specifically byte immediately after
                message

Return Value:

    Number of bytes in record.

--*/
{
    PCHAR   pdata = (PCHAR)(pMsgRR + 1);
    PCHAR   pdataStop;
    WORD    dlen = FlipUnalignedWord( &pMsgRR->DataLength );
    WORD    type;
    PCHAR   pRRString;

    DnsPrint_Lock();

    //
    //  print RR fixed fields
    //

    type = FlipUnalignedWord( &pMsgRR->RecordType );
    pRRString = Dns_RecordStringForType( type );

    if ( pszHeader )
    {
        PrintRoutine(
            pContext,
            "%s\r\n",
            pszHeader );
    }
    PrintRoutine(
        pContext,
        "      TYPE   %s  (%u)\r\n"
        "      CLASS  %u\r\n"
        "      TTL    %lu\r\n"
        "      DLEN   %u\r\n"
        "      DATA   ",
        pRRString,
        type,
        FlipUnalignedWord( &pMsgRR->RecordClass ),
        FlipUnalignedDword( &pMsgRR->TimeToLive ),
        dlen );

    //
    //  update records may not have data
    //

    if ( dlen == 0 )
    {
        PrintRoutine(
            pContext,
            "(none)\r\n" );
        goto Done;
    }

    //  stop byte after RR data

    pdataStop = pdata + dlen;
    if ( pMsgEnd < pdataStop )
    {
        PrintRoutine(
            pContext,
            "ERROR:  record at %p extends past end of packet!\n"
            "\tpmsg             = %p\n"
            "\tpmsgEnd          = %p\n"
            "\trecord end       = %p\n",
            pMsgRR,
            pMsgHead,
            pMsgEnd,
            pdataStop );
        goto Done;
    }

    //
    //  print RR data
    //

    switch ( type )
    {

    case DNS_TYPE_A:

        PrintRoutine(
            pContext,
            "%d.%d.%d.%d\r\n",
            * (PUCHAR)( pdata + 0 ),
            * (PUCHAR)( pdata + 1 ),
            * (PUCHAR)( pdata + 2 ),
            * (PUCHAR)( pdata + 3 )
            );
        break;

    case DNS_TYPE_AAAA:
    {
        IP6_ADDRESS ip6;

        RtlCopyMemory(
            &ip6,
            pdata,
            sizeof(ip6) );

        PrintRoutine(
            pContext,
            "%04x:%04x:%04x:%04x:%04x:%04x:%04x:%04x\n",
            ip6.IP6Word[0],
            ip6.IP6Word[1],
            ip6.IP6Word[2],
            ip6.IP6Word[3],
            ip6.IP6Word[4],
            ip6.IP6Word[5],
            ip6.IP6Word[6],
            ip6.IP6Word[7]
            );
        break;
    }

    case DNS_TYPE_PTR:
    case DNS_TYPE_NS:
    case DNS_TYPE_CNAME:
    case DNS_TYPE_MD:
    case DNS_TYPE_MB:
    case DNS_TYPE_MF:
    case DNS_TYPE_MG:
    case DNS_TYPE_MR:

        //
        //  these RRs contain single domain name
        //

        DnsPrint_PacketName(
            PrintRoutine,
            pContext,
            NULL,
            pdata,
            pMsgHead,
            pMsgEnd,
            "\r\n" );
        break;

    case DNS_TYPE_MX:
    case DNS_TYPE_RT:
    case DNS_TYPE_AFSDB:

        //
        //  these RR contain
        //      - one preference value
        //      - one domain name
        //

        PrintRoutine(
            pContext,
            "%d ",
            FlipUnalignedWord( pdata )
            );
        DnsPrint_PacketName(
            PrintRoutine,
            pContext,
            NULL,
            pdata + sizeof(WORD),
            pMsgHead,
            pMsgEnd,
            "\r\n" );
        break;

    case DNS_TYPE_SOA:

        pdata += DnsPrint_PacketName(
                        PrintRoutine,
                        pContext,
                        "\r\n\t\tPrimaryServer: ",
                        pdata,
                        pMsgHead,
                        pMsgEnd,
                        NULL );
        pdata += DnsPrint_PacketName(
                        PrintRoutine,
                        pContext,
                        "\r\n\t\tAdministrator: ",
                        pdata,
                        pMsgHead,
                        pMsgEnd,
                        "\r\n" );
        PrintRoutine(
            pContext,
            "\t\tSerialNo     = %d\r\n"
            "\t\tRefresh      = %d\r\n"
            "\t\tRetry        = %d\r\n"
            "\t\tExpire       = %d\r\n"
            "\t\tMinimumTTL   = %d\r\n",
            FlipUnalignedDword( pdata ),
            FlipUnalignedDword( (PDWORD)pdata+1 ),
            FlipUnalignedDword( (PDWORD)pdata+2 ),
            FlipUnalignedDword( (PDWORD)pdata+3 ),
            FlipUnalignedDword( (PDWORD)pdata+4 )
            );
        break;

    case DNS_TYPE_MINFO:
    case DNS_TYPE_RP:

        //
        //  these RRs contain two domain names
        //

        pdata += DnsPrint_PacketName(
                        PrintRoutine,
                        pContext,
                        NULL,
                        pdata,
                        pMsgHead,
                        pMsgEnd,
                        NULL );
        DnsPrint_PacketName(
            PrintRoutine,
            pContext,
            "  ",
            pdata,
            pMsgHead,
            pMsgEnd,
            "\r\n" );
        break;

    case DNS_TYPE_TEXT:
    case DNS_TYPE_HINFO:
    case DNS_TYPE_ISDN:
    case DNS_TYPE_X25:
    {
        //
        //  all these are simply text string(s)
        //

        PCHAR   pch = pdata;
        PCHAR   pchStop = pch + dlen;
        UCHAR   cch;

        while ( pch < pchStop )
        {
            cch = (UCHAR) *pch++;

            PrintRoutine(
                pContext,
                "\t%.*s\r\n",
                 cch,
                 pch );

            pch += cch;
        }
        if ( pch != pchStop )
        {
            PrintRoutine(
                pContext,
                "ERROR:  Bad RR.  "
                "Text strings do not add to RR length.\r\n" );
        }
        break;
    }

    case DNS_TYPE_WKS:
    {
        INT i;

        PrintRoutine(
            pContext,
            "WKS: Address %d.%d.%d.%d\r\n"
            "\t\tProtocol %d\r\n"
            "\t\tBitmask\r\n",
            * (PUCHAR)( pdata + 0 ),
            * (PUCHAR)( pdata + 1 ),
            * (PUCHAR)( pdata + 2 ),
            * (PUCHAR)( pdata + 3 ),
            * (PUCHAR)( pdata + 4 ) );

        pdata += SIZEOF_WKS_FIXED_DATA;

        for ( i=0;  i < (INT)(dlen-SIZEOF_WKS_FIXED_DATA);  i++ )
        {
            PrintRoutine(
                pContext,
                "\t\t\tbyte[%d] = %x\r\n",
                i,
                (UCHAR) pdata[i] );
        }
        break;
    }

    case DNS_TYPE_NULL:

        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            NULL,
            "\t\t",
            pdata,
            dlen );
        break;

    case DNS_TYPE_SRV:

        //  SRV <priority> <weight> <port> <target host>

        PrintRoutine(
            pContext,
            "\t\tPriority     = %d\r\n"
            "\t\tWeight       = %d\r\n"
            "\t\tPort         = %d\r\n",
            FlipUnalignedWord( pdata ),
            FlipUnalignedWord( (PWORD)pdata+1 ),
            FlipUnalignedWord( (PWORD)pdata+2 )
            );
        DnsPrint_PacketName(
            PrintRoutine,
            pContext,
            "\t\tTarget host ",
            pdata + 3*sizeof(WORD),
            pMsgHead,
            pMsgEnd,
            "\r\n" );
        break;

    case DNS_TYPE_OPT:

        //
        //  OPT
        //      - RR class is buffer size
        //      - RR TTL contains
        //          <extended RCODE> low byte
        //          <version> second byte
        //          <flags-zero> high word
        //

        {
            BYTE    version;
            BYTE    extendedRcode;
            DWORD   fullRcode = 0;
            WORD    flags;

            extendedRcode = *( (PBYTE) &pMsgRR->TimeToLive );
            version = *( (PBYTE) &pMsgRR->TimeToLive + 1 );
            flags = *( (PWORD) &pMsgRR->TimeToLive + 1 );

            if ( pMsgHead->ResponseCode )
            {
                fullRcode = ((DWORD)extendedRcode << 4) +
                            (DWORD)pMsgHead->ResponseCode;
            }

            PrintRoutine(
                pContext,
                "\t\tBuffer Size  = %d\r\n"
                "\t\tRcode Ext    = %d (%x)\r\n"
                "\t\tRcode Full   = %d\r\n"
                "\t\tVersion      = %d\r\n"
                "\t\tFlags        = %x\r\n",
                FlipUnalignedWord( &pMsgRR->RecordClass ),
                extendedRcode, extendedRcode,
                fullRcode,
                version,
                flags );
        }
        break;

    case DNS_TYPE_TKEY:
    {
        DWORD   beginTime;
        DWORD   expireTime;
        WORD    keyLength;
        WORD    mode;
        WORD    extRcode;
        WORD    otherLength;

        otherLength = (WORD)DnsPrint_PacketName(
                                PrintRoutine,
                                pContext,
                                "\r\n\t\tAlgorithm:     ",
                                pdata,
                                pMsgHead,
                                pMsgEnd,
                                NULL );
        if ( !otherLength )
        {
            PrintRoutine(
                pContext,
                "Invalid algorithm name in TKEY RR!\r\n" );
        }
        pdata += otherLength;

        beginTime = InlineFlipUnalignedDword( pdata );
        pdata += sizeof(DWORD);
        expireTime = InlineFlipUnalignedDword( pdata );
        pdata += sizeof(DWORD);

        mode = InlineFlipUnalignedWord( pdata );
        pdata += sizeof(WORD);
        extRcode = InlineFlipUnalignedWord( pdata );
        pdata += sizeof(WORD);
        keyLength = InlineFlipUnalignedWord( pdata );
        pdata += sizeof(WORD);

        PrintRoutine(
            pContext,
            "\r\n"
            "\t\tCreate time    = %d\r\n"
            "\t\tExpire time    = %d\r\n"
            "\t\tMode           = %d\r\n"
            "\t\tExtended RCODE = %d\r\n"
            "\t\tKey Length     = %d\r\n",
            beginTime,
            expireTime,
            mode,
            extRcode,
            keyLength );

        if ( pdata + keyLength > pdataStop )
        {
            PrintRoutine(
                pContext,
                "Invalid key length:  exceeds record data!\r\n" );
            break;
        }
        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "\t\tKey:",
            "\t\t  ",       // line header
            pdata,
            keyLength );

        pdata += keyLength;
        if ( pdata + sizeof(WORD) > pdataStop )
        {
            break;
        }
        otherLength = InlineFlipUnalignedWord( pdata );
        pdata += sizeof(WORD);

        PrintRoutine(
            pContext,
            "\r\n"
            "\t\tOther Length   = %d\r\n",
            otherLength );

        if ( pdata + otherLength > pdataStop )
        {
            PrintRoutine(
                pContext,
                "Invalid other data length:  exceeds record data!\r\n" );
            break;
        }
        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "\t\tOther Data:",
            "\t\t  ",           // line header
            pdata,
            otherLength );
        break;
    }

    case DNS_TYPE_TSIG:
    {
        ULONGLONG   signTime;
        WORD        fudgeTime;
        WORD        sigLength;
        WORD        extRcode;
        WORD        wOriginalId;
        WORD        otherLength;

        otherLength = (WORD) DnsPrint_PacketName(
                                PrintRoutine,
                                pContext,
                                "\r\n\t\tAlgorithm:     ",
                                pdata,
                                pMsgHead,
                                pMsgEnd,
                                NULL );
        if ( !otherLength )
        {
            PrintRoutine(
                pContext,
                "Invalid algorithm name in TSIG RR!\r\n" );
        }
        pdata += otherLength;

        signTime = InlineFlipUnaligned48Bits( pdata );
        pdata += sizeof(DWORD) + sizeof(WORD);

        fudgeTime = InlineFlipUnalignedWord( pdata );
        pdata += sizeof(WORD);

        sigLength = InlineFlipUnalignedWord( pdata );
        pdata += sizeof(WORD);

        PrintRoutine(
            pContext,
            "\r\n"
            "\t\tSigned time    = %I64u\r\n"
            "\t\tFudge time     = %u\r\n"
            "\t\tSig Length     = %u\r\n",
            signTime,
            fudgeTime,
            sigLength );

        if ( pdata + sigLength > pdataStop )
        {
            PrintRoutine(
                pContext,
                "Invalid signature length:  exceeds record data!\r\n" );
            break;
        }
        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "\t\tSignature:",
            "\t\t  ",           // line header
            pdata,
            sigLength );

        pdata += sigLength;
        if ( pdata + sizeof(DWORD) > pdataStop )
        {
            break;
        }
        wOriginalId = InlineFlipUnalignedWord( pdata );
        pdata += sizeof(WORD);

        extRcode = InlineFlipUnalignedWord( pdata );
        pdata += sizeof(WORD);

        otherLength = InlineFlipUnalignedWord( pdata );
        pdata += sizeof(WORD);

        PrintRoutine(
            pContext,
            "\r\n"
            "\t\tOriginal XID   = %x\r\n"
            "\t\tExtended RCODE = %u\r\n"
            "\t\tOther Length   = %u\r\n",
            wOriginalId,
            extRcode,
            otherLength );

        if ( pdata + otherLength > pdataStop )
        {
            PrintRoutine(
                pContext,
                "Invalid other data length:  exceeds record data!\r\n" );
            break;
        }
        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "\t\tOther Data:",
            "\t\t  ",           // line header
            pdata,
            otherLength );
        break;
    }

    case DNS_TYPE_WINS:
    {
        DWORD   i;
        DWORD   winsFlags;
        DWORD   lookupTimeout;
        DWORD   cacheTimeout;
        DWORD   winsCount;
        CHAR    flagString[ WINS_FLAG_MAX_LENGTH ];

        //
        //  WINS
        //      - scope/domain mapping flag
        //      - lookup timeout
        //      - cache timeout
        //      - WINS server count
        //      - WINS server list
        //

        winsFlags = FlipUnalignedDword( pdata );
        pdata += sizeof(DWORD);
        lookupTimeout = FlipUnalignedDword( pdata );
        pdata += sizeof(DWORD);
        cacheTimeout = FlipUnalignedDword( pdata );
        pdata += sizeof(DWORD);
        winsCount = FlipUnalignedDword( pdata );
        pdata += sizeof(DWORD);

        Dns_WinsRecordFlagString(
            winsFlags,
            flagString );

        PrintRoutine(
            pContext,
            "\r\n"
            "\t\tWINS flags     = %s (%08x)\r\n"
            "\t\tLookup timeout = %d\r\n"
            "\t\tCaching TTL    = %d\r\n",
            flagString,
            winsFlags,
            lookupTimeout,
            cacheTimeout );

        if ( pdata + (winsCount * SIZEOF_IP4_ADDRESS) > pdataStop )
        {
            PrintRoutine(
                pContext,
                "ERROR:  WINS server count leads beyond record data length!\n"
                "\tpmsg             = %p\n"
                "\tpmsgEnd          = %p\n"
                "\tpRR              = %p\n"
                "\trecord data end  = %p\n"
                "\twins count       = %d\n"
                "\tend of wins IPs  = %p\n",
                pMsgHead,
                pMsgEnd,
                pMsgRR,
                pdataStop,
                winsCount,
                pdata + (winsCount * SIZEOF_IP4_ADDRESS)
                );
            goto Done;
        }

        DnsPrint_Ip4AddressArray(
            PrintRoutine,
            pContext,
            NULL,
            "\tWINS",
            winsCount,
            (PIP4_ADDRESS) pdata );
        break;
    }

    case DNS_TYPE_WINSR:
    {
        DWORD   winsFlags;
        DWORD   lookupTimeout;
        DWORD   cacheTimeout;
        CHAR    flagString[ WINS_FLAG_MAX_LENGTH ];

        //
        //  NBSTAT
        //      - scope/domain mapping flag
        //      - lookup timeout
        //      - cache timeout
        //      - result domain -- optional
        //

        winsFlags = FlipUnalignedDword( pdata );
        pdata += sizeof(DWORD);
        lookupTimeout = FlipUnalignedDword( pdata );
        pdata += sizeof(DWORD);
        cacheTimeout = FlipUnalignedDword( pdata );
        pdata += sizeof(DWORD);

        Dns_WinsRecordFlagString(
            winsFlags,
            flagString );

        PrintRoutine(
            pContext,
            "\r\n"
            "\t\tWINS-R flags   = %s (%08x)\r\n"
            "\t\tLookup timeout = %d\r\n"
            "\t\tCaching TTL    = %d\r\n",
            flagString,
            winsFlags,
            lookupTimeout,
            cacheTimeout );

        DnsPrint_PacketName(
            PrintRoutine,
            pContext,
            "\t\tResult domain  = ",
            pdata,
            pMsgHead,
            pMsgEnd,
            "\r\n" );
        break;
    }
    
    case DNS_TYPE_KEY:
    {
        WORD    flags;
        BYTE    protocol;
        BYTE    algorithm;
        INT     keyLength;
        CHAR    szKeyFlags[ 100 ];

        keyLength = dlen - SIZEOF_KEY_FIXED_DATA;

        flags = FlipUnalignedWord( pdata );
        pdata += sizeof( WORD );
        protocol = * ( PBYTE ) pdata;
        ++pdata;
        algorithm = * ( PBYTE ) pdata;
        ++pdata;

        PrintRoutine(
            pContext,
            "\r\n"
            "\t\tKEY flags      = 0x%04x %s\r\n"
            "\t\tKEY protocol   = %s (%d)\r\n"
            "\t\tKEY algorithm  = %s (%d)\r\n",
            (INT) flags,
            Dns_KeyFlagString( szKeyFlags, flags ),
            Dns_GetKeyProtocolString( protocol ),
            (INT) protocol,
            Dns_GetDnssecAlgorithmString( algorithm ),
            (INT) algorithm );

        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "\t\tPublic key:",
            "\t\t  ",           // line header
            pdata,
            keyLength );
        break;
    }

    case DNS_TYPE_SIG:
    {
        WORD    typeCovered;
        BYTE    algorithm;
        BYTE    labelCount;
        DWORD   originalTTL;
        DWORD   sigInception;
        DWORD   sigExpiration;
        WORD    keyTag;
        CHAR    szSigInception[ 100 ];
        CHAR    szSigExpiration[ 100 ];
        INT     sigLength;

        typeCovered = FlipUnalignedWord( pdata );
        pdata += sizeof( WORD );
        algorithm = * ( PBYTE ) pdata;
        ++pdata;
        labelCount = * ( PBYTE ) pdata;
        ++pdata;
        originalTTL = FlipUnalignedDword( pdata );
        pdata += sizeof( DWORD );
        sigExpiration = FlipUnalignedDword( pdata );
        pdata += sizeof( DWORD );
        sigInception = FlipUnalignedDword( pdata );
        pdata += sizeof( DWORD );
        keyTag = FlipUnalignedWord( pdata );
        pdata += sizeof( WORD );

        PrintRoutine(
            pContext,
            "\r\n"
            "\t\tSIG type covered  = %s\r\n"
            "\t\tSIG algorithm     = %s (%d)\r\n"
            "\t\tSIG label count   = %d\r\n"
            "\t\tSIG original TTL  = %d\r\n"
            "\t\tSIG expiration    = %s\r\n"
            "\t\tSIG inception     = %s\r\n"
            "\t\tSIG key tag       = %d\r\n",
            Dns_RecordStringForType( typeCovered ),
            Dns_GetDnssecAlgorithmString( ( BYTE ) algorithm ),
            ( INT ) algorithm,
            ( INT ) labelCount,
            ( INT ) originalTTL,
            Dns_SigTimeString( sigExpiration, szSigExpiration ),
            Dns_SigTimeString( sigInception, szSigInception ),
            ( INT ) keyTag );

        pdata += DnsPrint_PacketName(
                        PrintRoutine,
                        pContext,
                        "\t\tSIG signer's name = ",
                        pdata,
                        pMsgHead,
                        pMsgEnd,
                        "\r\n" );

        sigLength = ( INT ) ( pdataStop - pdata );

        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "\t\tSignature:",
            "\t\t  ",           // line header
            pdata,
            sigLength );
        break;
    }

    case DNS_TYPE_NXT:
        {
        INT         bitmapLength;
        INT         byteIdx;
        INT         bitIdx;

        pdata += DnsPrint_PacketName(
                        PrintRoutine,
                        pContext,
                        "\r\n\t\tNXT next name      = ",
                        pdata,
                        pMsgHead,
                        pMsgEnd,
                        "\r\n" );

        bitmapLength = ( INT ) ( pdataStop - pdata );

        PrintRoutine( pContext, "\t\tNXT types covered  = " );

        for ( byteIdx = 0; byteIdx < bitmapLength; ++byteIdx )
        {
            for ( bitIdx = ( byteIdx ? 0 : 1 ); bitIdx < 8; ++bitIdx )
            {
                PCHAR   pszType;

                if ( !( pdata[ byteIdx ] & ( 1 << bitIdx ) ) )
                {
                    continue;   // Bit value is zero - do not write string.
                }
                pszType = Dns_RecordStringForType( byteIdx * 8 + bitIdx );
                if ( !pszType )
                {
                    ASSERT( FALSE );
                    continue;   // This type has no string - do not write.
                }
                PrintRoutine( pContext, "%s ", pszType );
            } 
        }

        PrintRoutine( pContext, "\r\n" );
        break;
        }

    default:

        PrintRoutine(
            pContext,
            "Unknown resource record type %d at %p.\r\n",
            type,
            pMsgRR );

        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            NULL,
            "\t\t",
            pdata,
            dlen );
        break;
    }

Done:

    DnsPrint_Unlock();

    return( sizeof(DNS_WIRE_RECORD) + dlen );
}



//
//  Print related utilities
//

INT
Dns_WriteFormattedSystemTimeToBuffer(
    OUT     PCHAR           pBuffer,
    IN      PSYSTEMTIME     pSystemTime
    )
/*++

Routine Description:

    Write SYSTEMTIME structure to buffer.

Arguments:

    pBuffer -- buffer to write into, assumed to have at least 50
                bytes available

    pSystemTime -- system time to convert;  assumed to be local, no
                    time zone conversion is done

Return Value:

    Bytes in formatted string.

--*/
{
    PCHAR   pend = pBuffer + 60;
    PCHAR   pstart = pBuffer;
    INT     count;

    pBuffer += GetDateFormat(
                    LOCALE_SYSTEM_DEFAULT,
                    LOCALE_NOUSEROVERRIDE,
                    (PSYSTEMTIME) pSystemTime,
                    NULL,
                    pBuffer,
                    (int)(pend - pBuffer) );

    //  Replace NULL from GetDateFormat with a space.

    *( pBuffer - 1 ) = ' ';

    pBuffer += GetTimeFormat(
                    LOCALE_SYSTEM_DEFAULT,
                    LOCALE_NOUSEROVERRIDE,
                    (PSYSTEMTIME) pSystemTime,
                    NULL,
                    pBuffer,
                    (int)(pend - pBuffer) );

    if ( pBuffer <= pstart+1 )
    {
        return( 0 );
    }
    return (INT)( pBuffer - pstart );
}



//
//  Response code print
//

#define DNS_RCODE_UNKNOWN   (DNS_RCODE_BADTIME + 1)

PCHAR   ResponseCodeStringTable[] =
{
    "NOERROR",
    "FORMERR",
    "SERVFAIL",
    "NXDOMAIN",
    "NOTIMP",
    "REFUSED",
    "YXDOMAIN",
    "YXRRSET",
    "NXRRSET",
    "NOTAUTH",
    "NOTZONE",
    "11 - unknown\r\n",
    "12 - unknown\r\n",
    "13 - unknown\r\n",
    "14 - unknown\r\n",
    "15 - unknown\r\n",

    //  DNS RCODEs stop at 15 -- these extended errors are available for security

    "BADSIG",
    "BADKEY",
    "BADTIME",
    "UNKNOWN"
};


PCHAR
Dns_ResponseCodeString(
    IN      INT     ResponseCode
    )
/*++

Routine Description:

    Get string corresponding to a response code.

Arguments:

    ResponseCode - response code

Return Value:

    Ptr to string for code.

--*/
{
    if ( ResponseCode > DNS_RCODE_UNKNOWN )
    {
        ResponseCode = DNS_RCODE_UNKNOWN;
    }
    return( ResponseCodeStringTable[ ResponseCode ] );
}



//
//  More detailed RCODE strings
//

PCHAR   ResponseCodeExplanationStringTable[] =
{
    "NOERROR:  no error",
    "FORMERR:  format error",
    "SERVFAIL:  server failure",
    "NXDOMAIN:  name error",
    "NOTIMP:  not implemented",
    "REFUSED",
    "YXDOMAIN:  name exists that should not",
    "YXRRSET:  RR set exists that should not",
    "NXRRSET:  required RR set does not exist",
    "NOTAUTH:  not authoritative",
    "NOTZONE:  name not in zone",
    "11 - unknown",
    "12 - unknown",
    "13 - unknown",
    "14 - unknown",
    "15 - unknown",

    //  DNS RCODEs stop at 15 -- these extended errors are available for security

    "BADSIG:  bad signature",
    "BADKEY:  bad signature",
    "BADTIME:  invalid or expired time on signature or key",
    "UNKNOWN"
};


PCHAR
Dns_ResponseCodeExplanationString(
    IN      INT     ResponseCode
    )
/*++

Routine Description:

    Get string corresponding to a response code.
    Basically for use by packet debug routine above.

Arguments:

    ResponseCode - response code

Return Value:

    Ptr to string for code.

--*/
{
    if ( ResponseCode > DNS_RCODE_UNKNOWN )
    {
        ResponseCode = DNS_RCODE_UNKNOWN;
    }
    return( ResponseCodeExplanationStringTable[ ResponseCode ] );
}



PCHAR
Dns_KeyFlagString(
    IN OUT      PCHAR       pszBuff,
    IN          WORD        Flags
    )
/*++

Routine Description:

    Formats a human-readable string based on the flags value
    (DNSSEC KEY RR flags). See RFC2535 section 3.2.1.

Arguments:

    pszBuff - buffer to dump string into should be min 100 chars

    flags - flag value to generate string for

Return Value:

    pszBuff

--*/
{
    BOOL    fZoneKey = FALSE;

    *pszBuff = '\0';

    // "type" bits

    if ( ( Flags & 0xC000 ) == 0xC000 )
    {
        strcat( pszBuff, "NOKEY " );
    }
    else if ( ( Flags & 0xC000 ) == 0x8000 )
    {
        strcat( pszBuff, "NOAUTH " );
    }
    else if ( ( Flags & 0xC000 ) == 0x4000 )
    {
        strcat( pszBuff, "NOCONF " );
    }
    else
    {
        strcat( pszBuff, "NOAUTH NOCONF " );
    }

    //  extended bit

    if ( Flags & 0x1000 )
    {
        strcat( pszBuff, "EXTEND " );
    }

    //  name type bits

    if ( ( Flags & 0x0300 ) == 0x0300 )
    {
        strcat( pszBuff, "RESNT " );    // reserved name type
    }
    else if ( ( Flags & 0x0200 ) == 0x0100 )
    {
        strcat( pszBuff, "ENTITY " );
    }
    else if ( ( Flags & 0x0100 ) == 0x4000 )
    {
        strcat( pszBuff, "ZONE " );
        fZoneKey = TRUE;
    }
    else
    {
        strcat( pszBuff, "USER " );
    }

    //  signatory bits
    
    if ( fZoneKey )
    {
        strcat( pszBuff, ( Flags & 0x0008 ) ? "MODEA " : "MODEB " );
        if ( Flags & 0x0004 )
        {
            strcat( pszBuff, "STRONG " );
        }
        if ( Flags & 0x0002 )
        {
            strcat( pszBuff, "UNIQ " );
        }
    }
    else
    {
        if ( Flags & 0x0008 )
        {
            strcat( pszBuff, "ZCTRL " );
        }
        if ( Flags & 0x0004 )
        {
            strcat( pszBuff, "STRONG " );
        }
        if ( Flags & 0x0002 )
        {
            strcat( pszBuff, "UNIQ " );
        }
    }

    return pszBuff;
}



//
//  Opcode print
//

PCHAR   OpcodeStringTable[] =
{
    "QUERY",
    "IQUERY",
    "SRV_STATUS",
    "UNKNOWN",
    "NOTIFY",
    "UPDATE",
    "UNKNOWN?"
};

CHAR    OpcodeCharacterTable[] =
{
    'Q',
    'I',
    'S',
    'K',
    'N',
    'U',
    '?'
};

#define DNS_OPCODE_UNSPEC (DNS_OPCODE_UPDATE + 1)


PCHAR
Dns_OpcodeString(
    IN      INT     Opcode
    )
/*++

Routine Description:

    Get string corresponding to a response code.

Arguments:

    Opcode - response code

Return Value:

    Ptr to string for code.

--*/
{
    if ( Opcode > DNS_OPCODE_UNSPEC )
    {
        Opcode = DNS_OPCODE_UNSPEC;
    }
    return( OpcodeStringTable[ Opcode ] );
}



CHAR
Dns_OpcodeCharacter(
    IN      INT     Opcode
    )
/*++

Routine Description:

    Get string corresponding to an opcode.

Arguments:

    Opcode - response code

Return Value:

    Ptr to string for code.

--*/
{
    if ( Opcode > DNS_OPCODE_UNSPEC )
    {
        Opcode = DNS_OPCODE_UNSPEC;
    }
    return( OpcodeCharacterTable[ Opcode ] );
}



//
//  Section names
//
//  With update get a new set of section names.
//  Provide single interface to putting a name on them.
//

PSTR  SectionNameArray[5] =
{
    "Question",
    "Answer",
    "Authority",
    "Additional",
    "ERROR:  Invalid Section"
};

PSTR  UpdateSectionNameArray[5] =
{
    "Zone",
    "Prerequisite",
    "Update",
    "Additional",
    "ERROR:  Invalid Section"
};

PCHAR
Dns_SectionNameString(
    IN      INT     iSection,
    IN      INT     iOpcode
    )
/*++

Routine Description:

    Get string corresponding to name of RR section id.
    For use by packet debug routine above.

Arguments:

    iSection - section id (0-3 for Question-Additional)

    iOpcode - opcode

Return Value:

    Ptr to string for section name.

--*/
{
    if ( iSection >= 4 )
    {
        iSection = 4;
    }

    if ( iOpcode == DNS_OPCODE_UPDATE )
    {
        return( UpdateSectionNameArray[iSection] );
    }
    else
    {
        return( SectionNameArray[iSection] );
    }
}


VOID
DnsPrint_MessageNoContext(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_HEADER     pMsgHead,
    IN      WORD            wLength     OPTIONAL
    )
/*++

Routine Description:

    Print DNS message buffer.
    Includes context information as well as actual DNS message.

--*/
{
    PCHAR       pchRecord;
    PBYTE       pmsgEnd;
    INT         i;
    INT         isection;
    INT         cchName;
    WORD        wOffset;
    WORD        wXid;
    WORD        wQuestionCount;
    WORD        wAnswerCount;
    WORD        wNameServerCount;
    WORD        wAdditionalCount;
    WORD        countSectionRR;
    BOOL        fFlipped = FALSE;

    //
    //  processing limits
    //      - if length given set stop limit
    //      - if length not given set wLength so checks against
    //          length overrun always fail (are ok)
    //

    if ( wLength )
    {
        pmsgEnd = ((PBYTE)pMsgHead) + wLength;
    }
    else
    {
        wLength = MAXWORD;
        pmsgEnd = NULL;
    }


    DnsPrint_Lock();

    if ( pszHeader )
    {
        PrintRoutine( pContext, "%s\r\n", pszHeader );
    }

    PrintRoutine(
        pContext,
        "DNS message header at %p\r\n",
        pMsgHead );

    PrintRoutine(
        pContext,
        "    XID       0x%04hx\r\n"
        "    Flags     0x%04hx\r\n"
        "        QR        0x%lx (%s)\r\n"
        "        OPCODE    0x%lx (%s)\r\n"
        "        AA        0x%lx\r\n"
        "        TC        0x%lx\r\n"
        "        RD        0x%lx\r\n"
        "        RA        0x%lx\r\n"
        "        Z         0x%lx\r\n"
        "        RCODE     0x%lx (%s)\r\n"
        "    QCOUNT    0x%hx\r\n"
        "    ACOUNT    0x%hx\r\n"
        "    NSCOUNT   0x%hx\r\n"
        "    ARCOUNT   0x%hx\r\n",

        pMsgHead->Xid,
        ntohs((*((PWORD)pMsgHead + 1))),

        pMsgHead->IsResponse,
        (pMsgHead->IsResponse ? "response" : "question"),
        pMsgHead->Opcode,
        Dns_OpcodeString( pMsgHead->Opcode ),
        pMsgHead->Authoritative,
        pMsgHead->Truncation,
        pMsgHead->RecursionDesired,
        pMsgHead->RecursionAvailable,
        pMsgHead->Reserved,
        pMsgHead->ResponseCode,
        Dns_ResponseCodeString( pMsgHead->ResponseCode ),

        pMsgHead->QuestionCount,
        pMsgHead->AnswerCount,
        pMsgHead->NameServerCount,
        pMsgHead->AdditionalCount );

    //
    //  determine if byte flipped and get correct count
    //

    wXid                = pMsgHead->Xid;
    wQuestionCount      = pMsgHead->QuestionCount;
    wAnswerCount        = pMsgHead->AnswerCount;
    wNameServerCount    = pMsgHead->NameServerCount;
    wAdditionalCount    = pMsgHead->AdditionalCount;

    if ( wQuestionCount )
    {
        fFlipped = wQuestionCount & 0xff00;
    }
    else if ( wNameServerCount )
    {
        fFlipped = wNameServerCount & 0xff00;
    }
    if ( fFlipped )
    {
        wXid                = ntohs( wXid );
        wQuestionCount      = ntohs( wQuestionCount );
        wAnswerCount        = ntohs( wAnswerCount );
        wNameServerCount    = ntohs( wNameServerCount );
        wAdditionalCount    = ntohs( wAdditionalCount );
    }

    //
    //  catch record flipping problems -- all are flipped or none at all
    //      and no record count should be > 256 EXCEPT answer count
    //      during FAST zone transfer
    //

    DNS_ASSERT( ! (wQuestionCount & 0xff00) );
    DNS_ASSERT( ! (wNameServerCount & 0xff00) );
    DNS_ASSERT( ! (wAdditionalCount & 0xff00) );

#if 0
    //
    //  stop here if WINS response -- don't have parsing ready
    //

    if ( pMsgHead->IsResponse && IS_WINS_XID(wXid) )
    {
        PrintRoutine( pContext, "  WINS Response packet.\r\n\r\n" );
        goto Unlock;
    }
#endif

    //
    //  print questions and resource records
    //

    pchRecord = (PCHAR)(pMsgHead + 1);

    for ( isection=0; isection<4; isection++)
    {
        PrintRoutine(
            pContext,
            "  %s Section:\r\n",
            Dns_SectionNameString( isection, pMsgHead->Opcode ) );

        if ( isection==0 )
        {
            countSectionRR = wQuestionCount;
        }
        else if ( isection==1 )
        {
            countSectionRR = wAnswerCount;
        }
        else if ( isection==2 )
        {
            countSectionRR = wNameServerCount;
        }
        else if ( isection==3 )
        {
            countSectionRR = wAdditionalCount;
        }

        for ( i=0; i < countSectionRR; i++ )
        {
            //
            //  verify not overrunning length
            //      - check against pCurrent as well as message length
            //        so can print packets while being built
            //

            wOffset = (WORD)(pchRecord - (PCHAR)pMsgHead);

            if ( wOffset >= wLength )
            {
                PrintRoutine(
                    pContext,
                    "ERROR:  BOGUS PACKET:\r\n"
                    "\tFollowing RR (offset %d) past packet length (%d).\r\n",
                    wOffset,
                    wLength
                    );
                goto Unlock;
            }

            //
            //  print RR name
            //

            PrintRoutine(
                pContext,
                "    Name Offset = 0x%04x\r\n",
                wOffset
                );

            cchName = DnsPrint_PacketName(
                            PrintRoutine,
                            pContext,
                            "    Name      \"",
                            pchRecord,
                            pMsgHead,
                            pmsgEnd,
                            "\"\r\n" );
            if ( !cchName )
            {
                PrintRoutine(
                    pContext,
                    "ERROR:  Invalid name length, stop packet print\r\n" );
                DNS_ASSERT( FALSE );
                break;
            }
            pchRecord += cchName;

            //  print question or resource record

            if ( isection == 0 )
            {
                PrintRoutine(
                    pContext,
                    "      QTYPE   %d\r\n"
                    "      QCLASS  %d\r\n",
                    FlipUnalignedWord( pchRecord ),
                    FlipUnalignedWord( pchRecord + sizeof(WORD) )
                    );
                pchRecord += sizeof( DNS_WIRE_QUESTION );
            }
            else
            {
                pchRecord += DnsPrint_PacketRecord(
                                PrintRoutine,
                                pContext,
                                NULL,
                                (PDNS_WIRE_RECORD) pchRecord,
                                pMsgHead,
                                pmsgEnd
                                );
            }
        }
    }

    //  check that at proper end of packet

    wOffset = (WORD)(pchRecord - (PCHAR)pMsgHead);
    PrintRoutine(
        pContext,
        "  Message length = %04x\r\n\r\n",
        wOffset );

    //  print warning if given message length and did not end up
    //  at end of message
    //  note:  pmsgEnd test in case passed wLength==0, in which case
    //  wLength set to MAXDWORD above

    if ( pmsgEnd && wOffset < wLength )
    {
        PrintRoutine(
            pContext,
            "WARNING:  message continues beyond these records\r\n"
            "\tpch = %p\r\n"
            "\toffset = %d, msg length = %d, %d bytes\r\n",
            pchRecord,
            wOffset,
            wLength,
            wLength - wOffset );

        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "Remaining bytes:",
            NULL,
            pchRecord,
            (wLength - wOffset) );
    }

Unlock:
    DnsPrint_Unlock();


} // DnsPrint_MessageNoContext



DWORD
DnsStringPrint_Guid(
    OUT     PCHAR           pBuffer,
    IN      PGUID           pGuid
    )
/*++

Routine Description:

    Print GUID to buffer.

Arguments:

    pBuffer - buffer to print to
        buffer must be big enough for GUID string
        GUID_STRING_BUFFER_LENGTH covers it

    pGuid - GUID to print

Return Value:

    Count of bytes printed to string.

--*/
{
    if ( !pGuid )
    {
        *pBuffer = 0;
        return 0;
    }

    return  sprintf(
                pBuffer,
                "%08x-%04x-%04x-%04x-%02x%02x%02x%02x%02x%02x",
                pGuid->Data1,
                pGuid->Data2,
                pGuid->Data3,
                *(PWORD) &pGuid->Data4[0],
                pGuid->Data4[2],
                pGuid->Data4[3],
                pGuid->Data4[4],
                pGuid->Data4[5],
                pGuid->Data4[6],
                pGuid->Data4[7] );
}



VOID
DnsPrint_Guid(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PGUID           pGuid
    )
/*++

Routine Description:

    Print GUID

Arguments:

    pszHeader - Header message/name for RR.

    pGuid -- ptr to GUID to print

Return Value:

    None.

--*/
{
    CHAR    guidBuffer[ GUID_STRING_BUFFER_LENGTH ];

    if ( !pszHeader )
    {
        pszHeader = "Guid";
    }
    if ( !pGuid )
    {
        PrintRoutine(
            pContext,
            "%s:  NULL GUID pointer!\r\n",
            pszHeader );
    }

    //  convert GUID to string

    DnsStringPrint_Guid(
        guidBuffer,
        pGuid );

    PrintRoutine(
        pContext,
        "%s:  (%p) %s\r\n",
        pszHeader,
        pGuid,
        guidBuffer );
}



DWORD
DnsStringPrint_RawOctets(
    OUT     PCHAR           pBuffer,
    IN      PCHAR           pchData,
    IN      DWORD           dwLength,
    IN      PSTR            pszLineHeader,
    IN      DWORD           dwLineLength
    )
/*++

Routine Description:

    Print raw octect data to sting

Arguments:

    pBuffer - buffer to print to

    pchData - data to print

    dwLength - length of data to print

    pszLineHeader - header on each line.

    dwLineLength - number of bytes to print on line;  default is 

Return Value:

    Count of bytes printed to string.

--*/
{
    INT     i;
    INT     lineCount = 0;
    PCHAR   pch = pBuffer;

    *pch = 0;

    //
    //  catch NULL pointer
    //      - return is null terminated
    //      - but indicate no bytes written
    //

    if ( !pchData )
    {
        return  0;
    }

    //
    //  write each byte in hex
    //      - if dwLineLength set break into lines with count
    //      or optional header
    //

    for ( i = 0; i < (INT)dwLength; i++ )
    {
        if ( dwLineLength  &&  (i % dwLineLength) == 0 )
        {
            if ( pszLineHeader )
            {
                pch += sprintf( pch, "\r\n%s", pszLineHeader );
            }
            else
            {
                pch += sprintf( pch, "\r\n%3d> ", i );
            }
            lineCount++;
        }

        pch += sprintf( pch, "%02x ", (UCHAR)pchData[i] );
    }

    return( (DWORD)(pch - pBuffer) );
}



VOID
DnsPrint_RawBinary(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszLineHeader,
    IN      PCHAR           pchData,
    IN      DWORD           dwLength,
    IN      DWORD           PrintSize
    )
/*++

Routine Description:

    Print raw data.

Arguments:

    pszHeader - Header message/name for RR.

    pszLineHeader - Header on each line.

    pchData - data to print

    dwLength - length of data to print

    PrintSize - size to print in
        size(QWORD)
        size(DWORD)
        size(WORD)
        defaults to bytes

Return Value:

    None.

--*/
{
    DWORD   i;
    DWORD   lineCount = 0;
    CHAR    buf[ 2000 ];
    PCHAR   pch = buf;
    PCHAR   pbyte;
    PCHAR   pend;

    DnsPrint_Lock();

    if ( pszHeader )
    {
        PrintRoutine(
            pContext,
            "%s",
            pszHeader );
    }

    buf[0] = 0;

    //
    //  print bytes
    //      - write 16 bytes a line
    //      - buffer up 10 lines for speed
    //
    //  note:  we'll write a partial (<16 byte) line the first
    //      time if data is unaligned with PrintSize, then we'll
    //      write at 16 a pop
    //

    if ( PrintSize == 0 )
    {
        PrintSize = 1;
    }

    i = 0;
    pch = buf;
    pend = (PBYTE)pchData + dwLength;

    while ( i < dwLength )
    {
        DWORD   lineBytes = (i%16);

        if ( lineBytes==0 || lineBytes > (16-PrintSize) )
        {
            if ( lineCount > 10 )
            {
                PrintRoutine( pContext, buf );
                lineCount = 0;
                pch = buf;
            }

            if ( pszLineHeader )
            {
                pch += sprintf( pch, "\r\n%s", pszLineHeader );
            }
            else
            {
                pch += sprintf( pch, "\r\n\t%3d> ", i );
            }
            lineCount++;

            //if ( i >= 128 && dlen > 256 )
            //{
            //    PrintRoutine( pContext, "skipping remaining bytes ...\r\n" ));
            //}
        }

        pbyte = &pchData[i];

        if ( PrintSize == sizeof(QWORD) &&
             POINTER_IS_ALIGNED( pbyte, ALIGN_QUAD ) &&
             pbyte + sizeof(QWORD) <= pend )
        {
            pch += sprintf( pch, "%I64x ", *(PQWORD)pbyte );
            i += sizeof(QWORD);
        }
        else if ( PrintSize == sizeof(DWORD) &&
                  POINTER_IS_ALIGNED( pbyte, ALIGN_DWORD ) &&
                  pbyte + sizeof(DWORD) <= pend )
        {
            pch += sprintf( pch, "%08x ", *(PDWORD)pbyte );
            i += sizeof(DWORD);
        }
        else if ( PrintSize == sizeof(WORD) &&
                  POINTER_IS_ALIGNED( pbyte, ALIGN_WORD ) &&
                  pbyte + sizeof(WORD) <= pend )
        {
            pch += sprintf( pch, "%04x ", *(PWORD)pbyte );
            i += sizeof(WORD);
        }
        else  // default to byte print
        {
            pch += sprintf( pch, "%02x ", *pbyte );
            i++;
        }
    }

    //  print remaining bytes in buffer

    PrintRoutine(
        pContext,
        "%s\r\n",
        buf );

    DnsPrint_Unlock();
}



VOID
DnsPrint_RawOctets(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSTR            pszLineHeader,
    IN      PCHAR           pchData,
    IN      DWORD           dwLength
    )
/*++

Routine Description:

    Print raw octect data.

Arguments:

    pszHeader - Header message/name for RR.

    pszLineHeader - Header on each line.

    pchData - data to print

    dwLength - length of data to print

Return Value:

    None.

--*/
{
    INT     i;
    INT     lineCount = 0;
    CHAR    buf[ 2000 ];
    PCHAR   pch = buf;

    DnsPrint_Lock();

    if ( pszHeader )
    {
        PrintRoutine(
            pContext,
            "%s",
            pszHeader );
    }

    buf[0] = 0;

    //  buffer every 20 lines for speed

    for ( i = 0; i < (INT)dwLength; i++ )
    {
        if ( !(i%16) )
        {
            if ( lineCount > 10 )
            {
                PrintRoutine( pContext, buf );
                lineCount = 0;
                pch = buf;
            }

            if ( pszLineHeader )
            {
                pch += sprintf( pch, "\r\n%s", pszLineHeader );
            }
            else
            {
                pch += sprintf( pch, "\r\n%3d> ", i );
            }
            lineCount++;

            //if ( i >= 128 && dlen > 256 )
            //{
            //    PrintRoutine( pContext, "skipping remaining bytes ...\r\n" ));
            //}
        }

        pch += sprintf( pch, "%02x ", (UCHAR)pchData[i] );
    }

    //  print remaining bytes in buffer

    PrintRoutine(
        pContext,
        "%s\r\n",
        buf );

    DnsPrint_Unlock();
}



VOID
DnsPrint_ParsedRecord(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PDNS_PARSED_RR  pParsedRR
    )
/*++

Routine Description:

    Print parsed RR structure.

Arguments:

    pszHeader - Header message/name for RR.

    pParsedRR - parsed RR to print

Return Value:

    None.

--*/
{
    if ( !pszHeader )
    {
        pszHeader = "Parsed RR:";
    }

    if ( !pParsedRR )
    {
        PrintRoutine(
            pContext,
            "%s %s\r\n",
            pszHeader,
            "NULL ParsedRR ptr." );
        return;
    }

    PrintRoutine(
        pContext,
        "%s\r\n"
        "\tpchName      = %p\r\n"
        "\tpchRR        = %p\r\n"
        "\tpchData      = %p\r\n"
        "\tpchNextRR    = %p\r\n"
        "\twType        = %d\r\n"
        "\twClass       = %d\r\n"
        "\tTTL          = %d\r\n"
        "\twDataLength  = %d\r\n",
        pszHeader,
        pParsedRR->pchName,
        pParsedRR->pchRR,
        pParsedRR->pchData,
        pParsedRR->pchNextRR,
        pParsedRR->Type,
        pParsedRR->Class,
        pParsedRR->Ttl,
        pParsedRR->DataLength
        );
}



//
//  Winsock RnR structures
//

VOID
DnsPrint_FdSet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      struct fd_set * pfd_set
    )
/*++

Routine Description:

    Print sockets in FD_SET.

--*/
{
    INT count;
    INT i;

    DNS_ASSERT( pfd_set );

    count = (INT) pfd_set->fd_count;

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s  (count = %d)\r\n",
        pszHeader ? pszHeader : "FD_SET:",
        count );

    for (i=0; i<count; i++)
    {
        PrintRoutine(
            pContext,
            "\tsocket[%d] = %d\r\n",
            i,
            pfd_set->fd_array[i] );
    }
    DnsPrint_Unlock();
}



VOID
DnsPrint_Sockaddr(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PSOCKADDR       pSockaddr,
    IN      INT             iSockaddrLength
    )
/*++

Routine Description:

    Print sockaddr structure and length used in call.

--*/
{
    PSTR    pindent = INDENT_STRING( Indent );

    if ( !pszHeader )
    {
        pszHeader = "Sockaddr:";
    }

    if ( !pSockaddr )
    {
        PrintRoutine(
            pContext,
            "%s%s\tNULL Sockaddr passed to print.\r\n",
            pindent,
            pszHeader );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s%s\r\n"
        "%s\tpointer         = %p\r\n"
        "%s\tlength          = %d\r\n"
        "%s\tsa_family       = %d\r\n",
        pindent,    pszHeader,
        pindent,    pSockaddr,
        pindent,    iSockaddrLength,
        pindent,    pSockaddr->sa_family
        );

    switch ( pSockaddr->sa_family )
    {

    case AF_INET:
        {
            PSOCKADDR_IN    psin = (PSOCKADDR_IN) pSockaddr;
    
            PrintRoutine(
                pContext,
                "%s\tsin_port        = %04x\r\n"
                "%s\tsin_addr        = %s (%08x)\r\n"
                "%s\tsin_zero        = %08x %08x\r\n",
                pindent,    psin->sin_port,
                pindent,    inet_ntoa( psin->sin_addr ),
                            psin->sin_addr.s_addr,
                pindent,    *(PDWORD) &psin->sin_zero[0],
                            *(PDWORD) &psin->sin_zero[4]
                );
            break;
        }

    case AF_INET6:
        {
            PSOCKADDR_IN6  psin = (PSOCKADDR_IN6) pSockaddr;

            CHAR    buffer[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

            Dns_Ip6AddressToString_A(
                buffer,
                (PIP6_ADDRESS) &psin->sin6_addr );

            PrintRoutine(
                pContext,
                "%s\tsin6_port       = %04x\r\n"
                "%s\tsin6_flowinfo   = %08x\r\n"
                "%s\tsin6_addr       = %s\r\n"
                "%s\tsin6_scope_id   = %08x\r\n",
                pindent,    psin->sin6_port,
                pindent,    psin->sin6_flowinfo,
                pindent,    buffer,
                pindent,    psin->sin6_scope_id
                );
            break;
        }       
                
    default:

        //  print unknown in WORDs
        //  limit print as this is probably a busted sockaddr due to bug
        {       
            DnsPrint_RawBinary(
                PrintRoutine,
                pContext,
                "\tdata:  ",
                pindent,            // line header
                pSockaddr->sa_data,
                iSockaddrLength < 100
                    ? iSockaddrLength
                    : 100,
                sizeof(WORD)
                );
            break;
        }
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_AddrInfoEx(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PADDRINFO       pAddrInfo,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Print ADDRINFO structure.

--*/
{
    PSTR    pindent = INDENT_STRING( Indent );

    if ( !pszHeader )
    {
        pszHeader = "AddrInfo:";
    }

    if ( !pAddrInfo )
    {
        PrintRoutine(
            pContext,
            "%s%s NULL AddrInfo.\n",
            pindent,
            pszHeader  );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s%s\n"
        "%s\tPtr            = %p\n"
        "%s\tNext Ptr       = %p\n"
        "%s\tFlags          = %08x\n"
        "%s\tFamily         = %d\n"
        "%s\tSockType       = %d\n"
        "%s\tProtocol       = %d\n"
        "%s\tAddrLength     = %d\n"
        "%s\tName           = %s%S\n",
        pindent,    pszHeader,
        pindent,    pAddrInfo,
        pindent,    pAddrInfo->ai_next,
        pindent,    pAddrInfo->ai_flags,
        pindent,    pAddrInfo->ai_family,
        pindent,    pAddrInfo->ai_socktype,
        pindent,    pAddrInfo->ai_protocol,
        pindent,    pAddrInfo->ai_addrlen,
        pindent,
            (fUnicode) ? "" : pAddrInfo->ai_canonname,
            (fUnicode) ? pAddrInfo->ai_canonname : ""
        );

    DnsPrint_Sockaddr(
        PrintRoutine,
        pContext,
        NULL,
        Indent + 1,
        pAddrInfo->ai_addr,
        pAddrInfo->ai_addrlen );

    DnsPrint_Unlock();
}



VOID
DnsPrint_AddrInfoListEx(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PADDRINFO       pAddrInfo,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Print ADDRINFO structure.

--*/
{
    PADDRINFO   paddr = pAddrInfo;
    PSTR        pindent = INDENT_STRING( Indent );

    //
    //  list header
    //

    if ( !pszHeader )
    {
        pszHeader = "AddrInfo List:";
    }

    if ( !paddr )
    {
        PrintRoutine(
            pContext,
            "%s%s NULL AddrInfo List.\r\n",
            pindent,
            pszHeader  );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s%s\n",
        pindent, pszHeader
        );

    //
    //  print each ADDRINFO in list
    //

    while ( paddr )
    {
        DnsPrint_AddrInfoEx(
            PrintRoutine,
            pContext,
            NULL,
            Indent,
            paddr,
            fUnicode );

        paddr = paddr->ai_next;
    }

    PrintRoutine(
        pContext,
        "End of AddrInfo list\n\n"
        );

    DnsPrint_Unlock();
}



VOID
DnsPrint_SocketAddress(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PSOCKET_ADDRESS pSocketAddress
    )
/*++

Routine Description:

    Print SOCKET_ADDRESS structure.

--*/
{
    PSTR    pindent = INDENT_STRING( Indent );

    if ( !pszHeader )
    {
        pszHeader = "SocketAddress:";
    }

    if ( !pSocketAddress )
    {
        PrintRoutine(
            pContext,
            "%s%s NULL SocketAddress.\r\n",
            pindent,
            pszHeader  );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s%s\n"
        "%s\tpSockaddr        = %p\r\n"
        "%s\tiSockaddrLength  = %d\r\n",
        pindent,    pszHeader,
        pindent,    pSocketAddress->lpSockaddr,
        pindent,    pSocketAddress->iSockaddrLength );

    DnsPrint_Sockaddr(
        PrintRoutine,
        pContext,
        NULL,
        Indent,
        pSocketAddress->lpSockaddr,
        pSocketAddress->iSockaddrLength );

    DnsPrint_Unlock();
}



VOID
DnsPrint_CsAddr(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      DWORD           Indent,
    IN      PCSADDR_INFO    pCsAddr
    )
/*++

Routine Description:

    Print CSADDR_INFO structure.

Arguments:

    PrintRoutine    - routine to print with

    pParam          - ptr to print context

    pszHeader       - header

    Indent          - indent count, for formatting CSADDR inside larger struct

    pCsAddr         - ptr to CSADDRINFO to print

Return Value:

    None.

--*/
{
    PSTR    pindent = INDENT_STRING( Indent );

    if ( !pszHeader )
    {
        pszHeader = "CSAddrInfo:";
    }

    if ( !pCsAddr )
    {
        PrintRoutine(
            pContext,
            "%s%s \tNULL CSADDR_INFO ptr.\r\n",
            pindent,    pszHeader
            );
        return;
    }

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s%s\r\n"
        "%s\tPtr        = %p\n"
        "%s\tSocketType = %d\n"
        "%s\tProtocol   = %d\n",
        pindent,    pszHeader,
        pindent,    pCsAddr,
        pindent,    pCsAddr->iSocketType,
        pindent,    pCsAddr->iProtocol
        );

    DnsPrint_SocketAddress(
        PrintRoutine,
        pContext,
        "LocalAddress:",
        Indent,
        & pCsAddr->LocalAddr
        );

    DnsPrint_SocketAddress(
        PrintRoutine,
        pContext,
        "RemoteAddress:",
        Indent,
        & pCsAddr->RemoteAddr
        );

    DnsPrint_Unlock();
}




VOID
DnsPrint_AfProtocolsArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PAFPROTOCOLS    pProtocolArray,
    IN      DWORD           ProtocolCount
    )
/*++

Routine Description:

    Print AFPROTOCOLS array.

Arguments:

    PrintRoutine - routine to print with

    pszHeader   - header

    pProtocolArray - protocols array

    ProtocolCount  - array count

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "AFPROTOCOLS Array:";
    }

    //  print
    //      - array + count
    //      - each protocol element

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\r\n"
        "\tProtocol Array   = %p\r\n"
        "\tProtocol Count   = %d\r\n",
        pszHeader,
        pProtocolArray,
        ProtocolCount );

    if ( pProtocolArray )
    {
        for ( i=0;  i<ProtocolCount;  i++ )
        {
            PrintRoutine(
                pContext,
                "\t\tfamily = %d;  proto = %d\r\n",
                pProtocolArray[i].iAddressFamily,
                pProtocolArray[i].iProtocol );
        }
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_WsaQuerySet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      LPWSAQUERYSET   pQuerySet,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Print WSAQUERYSET structure.

Arguments:

    PrintRoutine - routine to print with

    pszHeader   - header

    pQuerySet   - ptr to WSAQUERYSET to print

    fUnicode    - TRUE if WSAQUERYSET is wide (WSAQUERYSETW)
                  FALSE if ANSI

Return Value:

    None.

--*/
{
    CHAR    serviceGuidBuffer[ GUID_STRING_BUFFER_LENGTH ];
    CHAR    nameSpaceGuidBuffer[ GUID_STRING_BUFFER_LENGTH ];
    DWORD   i;


    if ( !pszHeader )
    {
        pszHeader = "WSAQuerySet:";
    }

    if ( !pQuerySet )
    {
        PrintRoutine(
            pContext,
            "%s NULL QuerySet ptr\r\n",
            pszHeader );
        return;
    }

    //  convert GUIDs to strings

    DnsStringPrint_Guid(
        serviceGuidBuffer,
        pQuerySet->lpServiceClassId
        );
    DnsStringPrint_Guid(
        nameSpaceGuidBuffer,
        pQuerySet->lpNSProviderId
        );

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\r\n"
        "\tSize                 = %d\r\n"
        "\tServiceInstanceName  = %S%s\r\n"
        "\tService GUID         = (%p) %s\r\n"
        "\tWSA version          = %p %x %d\r\n"
        "\tComment              = %S%s\r\n"
        "\tName Space           = %d %s\r\n"
        "\tName Space GUID      = (%p) %s\r\n"
        "\tContext              = %S%s\r\n"
        "\tNumberOfProtocols    = %d\r\n"
        "\tProtocol Array       = %p\r\n"
        "\tQueryString          = %S%s\r\n"
        "\tCS Addr Count        = %d\r\n"
        "\tCS Addr Array        = %p\r\n"
        "\tOutput Flags         = %08x\r\n"
        "\tpBlob                = %p\r\n",

        pszHeader,
        pQuerySet->dwSize,
        DNSSTRING_WIDE( fUnicode, pQuerySet->lpszServiceInstanceName ),
        DNSSTRING_ANSI( fUnicode, pQuerySet->lpszServiceInstanceName ),
        pQuerySet->lpServiceClassId,
        serviceGuidBuffer,
        pQuerySet->lpVersion,
        ( pQuerySet->lpVersion ) ? pQuerySet->lpVersion->dwVersion : 0,
        ( pQuerySet->lpVersion ) ? pQuerySet->lpVersion->ecHow : 0,

        DNSSTRING_WIDE( fUnicode, pQuerySet->lpszComment ),
        DNSSTRING_ANSI( fUnicode, pQuerySet->lpszComment ),
        pQuerySet->dwNameSpace,
        Dns_GetRnrNameSpaceIdString( pQuerySet->dwNameSpace ),
        pQuerySet->lpNSProviderId,
        nameSpaceGuidBuffer,
        DNSSTRING_WIDE( fUnicode, pQuerySet->lpszContext ),
        DNSSTRING_ANSI( fUnicode, pQuerySet->lpszContext ),

        pQuerySet->dwNumberOfProtocols,
        pQuerySet->lpafpProtocols,
        DNSSTRING_WIDE( fUnicode, pQuerySet->lpszQueryString ),
        DNSSTRING_ANSI( fUnicode, pQuerySet->lpszQueryString ),

        pQuerySet->dwNumberOfCsAddrs,
        pQuerySet->lpcsaBuffer,
        pQuerySet->dwOutputFlags,
        pQuerySet->lpBlob
        );

    //  print address-family\protocols array

    if ( pQuerySet->lpafpProtocols )
    {
        DnsPrint_AfProtocolsArray(
            PrintRoutine,
            pContext,
            "\tAFPROTOCOLS Array:",
            pQuerySet->lpafpProtocols,
            pQuerySet->dwNumberOfProtocols );
    }

    //  print CSADDR_INFO array

    if ( pQuerySet->dwNumberOfCsAddrs &&
         pQuerySet->lpcsaBuffer )
    {
        PrintRoutine(
            pContext,
            "--- CS_ADDR array:\r\n" );

        for ( i=0;  i<pQuerySet->dwNumberOfCsAddrs;  i++ )
        {
            DnsPrint_CsAddr(
                PrintRoutine,
                pContext,
                NULL,
                1,          // indent one level
                & pQuerySet->lpcsaBuffer[i] );
        }
    }

    //  print blob (the hostent)

    //
    //  DCR_FIX0:  need some sort of test for blob type?
    //      - most blobs are hostent, but some are servent
    //

    if ( pQuerySet->lpBlob )
    {
        GUID ianaGuid = SVCID_INET_SERVICEBYNAME;

        PrintRoutine(
            pContext,
            "--- BLOB:\n"
            "\tcbSize       = %d\r\n"
            "\tpBlobData    = %p\r\n",
            pQuerySet->lpBlob->cbSize,
            pQuerySet->lpBlob->pBlobData
            );

        //  note:  can't print blob as hostent
        //      1) may not be hostent
        //      2) is passed with offsets rather than pointers

        DnsPrint_RawBinary(
            PrintRoutine,
            pContext,
            NULL,
            "\t\t",
            pQuerySet->lpBlob->pBlobData,
            pQuerySet->lpBlob->cbSize,
            sizeof(DWORD)
            );
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_WsaNsClassInfo(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PWSANSCLASSINFO pInfo,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Print WSACLASSINFO structure.

Arguments:

    PrintRoutine - routine to print with

    pszHeader   - header

    pInfo       - ptr to WSACLASSINFO to print

    fUnicode    - TRUE if WSACLASSINFO is wide (WSACLASSINFOW)
                  FALSE if ANSI

Return Value:

    None.

--*/
{
    if ( !pszHeader )
    {
        pszHeader = "WSANsClassInfo:";
    }

    if ( !pInfo )
    {
        PrintRoutine(
            pContext,
            "%s NULL NsClassInfo ptr\r\n",
            pszHeader );
        return;
    }

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\r\n"
        "\tPtr                  = %d\r\n"
        "\tName                 = %S%s\r\n"
        "\tName Space           = %d\r\n"
        "\tValue Type           = %d\r\n"
        "\tValue Size           = %d\r\n"
        "\tpValue               = %p\r\n",
        pszHeader,
        pInfo,
        DNSSTRING_WIDE( fUnicode, pInfo->lpszName ),
        DNSSTRING_ANSI( fUnicode, pInfo->lpszName ),
        pInfo->dwNameSpace,
        pInfo->dwValueType,
        pInfo->dwValueSize,
        pInfo->lpValue
        );

    if ( pInfo->lpValue )
    {
        PrintRoutine(
            pContext,
            "--- Value:\r\n"
            );

        DnsPrint_RawBinary(
            PrintRoutine,
            pContext,
            NULL,
            "\t\t",
            pInfo->lpValue,
            pInfo->dwValueSize,
            sizeof(BYTE)        // print in bytes
            );
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_WsaServiceClassInfo(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pContext,
    IN      PSTR                    pszHeader,
    IN      LPWSASERVICECLASSINFO   pInfo,
    IN      BOOL                    fUnicode
    )
/*++

Routine Description:

    Print WSASERVICECLASSINFO structure.

Arguments:

    PrintRoutine - routine to print with

    pszHeader   - header

    pInfo       - ptr to WSASERVICECLASSINFO to print

    fUnicode    - TRUE if WSASERVICECLASSINFO is wide (WSASERVICECLASSINFOW)
                  FALSE if ANSI

Return Value:

    None.

--*/
{
    CHAR    serviceClassGuidBuffer[ GUID_STRING_BUFFER_LENGTH ];

    if ( !pszHeader )
    {
        pszHeader = "WSAServiceClassInfo:";
    }

    if ( !pInfo )
    {
        PrintRoutine(
            pContext,
            "%s NULL ServiceClassInfo ptr\r\n",
            pszHeader );
        return;
    }

    //  convert GUID to strings

    DnsStringPrint_Guid(
        serviceClassGuidBuffer,
        pInfo->lpServiceClassId
        );

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\r\n"
        "\tPtr                  = %p\r\n"
        "\tClass GUID           = (%p) %s\r\n"
        "\tClassName            = %S%s\r\n"
        "\tClass Info Count     = %d\r\n"
        "\tClass Info Array     = %p\r\n",
        pszHeader,
        pInfo,
        serviceClassGuidBuffer,
        DNSSTRING_WIDE( fUnicode, pInfo->lpszServiceClassName ),
        DNSSTRING_ANSI( fUnicode, pInfo->lpszServiceClassName ),
        pInfo->dwCount,
        pInfo->lpClassInfos
        );

    if ( pInfo->lpClassInfos )
    {
        DWORD   i;

        for ( i=0; i<pInfo->dwCount; i++ )
        {
            DnsPrint_WsaNsClassInfo(
                PrintRoutine,
                pContext,
                NULL,       // default header
                & pInfo->lpClassInfos[i],
                fUnicode
                );
        }
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_Hostent(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PHOSTENT        pHostent,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Print hostent structure.

Arguments:

    PrintRoutine - routine to print with

    pszHeader   - header

    pHostent    - ptr to hostent

    fUnicode    - TRUE if hostent is unicode
                  FALSE if ANSI

Return Value:

    None.

--*/
{
    if ( !pszHeader )
    {
        pszHeader = "Hostent:";
    }

    if ( !pHostent )
    {
        PrintRoutine(
            pContext,
            "%s %s\r\n",
            pszHeader,
            "NULL Hostent ptr." );
        return;
    }

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\r\n"
        "\th_name               = %p %S%s\n"
        "\th_aliases            = %p\n"
        "\th_addrtype           = %d\n"
        "\th_length             = %d\n"
        "\th_addrlist           = %p\n",
        pszHeader,
        pHostent->h_name,
        DNSSTRING_WIDE( fUnicode, pHostent->h_name ),
        DNSSTRING_ANSI( fUnicode, pHostent->h_name ),
        pHostent->h_aliases,
        pHostent->h_addrtype,
        pHostent->h_length,
        pHostent->h_addr_list
        );

    //  print the aliases

    if ( pHostent->h_aliases )
    {
        PSTR *  paliasArray = pHostent->h_aliases;
        PSTR    palias;

        while ( palias = *paliasArray++ )
        {
            PrintRoutine(
                pContext,
                "\tAlias = (%p) %S%s\n",
                palias,
                DNSSTRING_WIDE( fUnicode, palias ),
                DNSSTRING_ANSI( fUnicode, palias ) );
        }
    }

    //  print the addresses

    if ( pHostent->h_addr_list )
    {
        PCHAR * ppaddr = pHostent->h_addr_list;
        PCHAR   pip;
        INT     i = 0;
        INT     family = pHostent->h_addrtype;
        INT     addrLength = pHostent->h_length;
        CHAR    stringBuf[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];

        while ( pip = ppaddr[i] )
        {
            DWORD   bufLength = IP6_ADDRESS_STRING_BUFFER_LENGTH;

            Dns_AddressToString_A(
                stringBuf,
                & bufLength,
                pip,
                addrLength,
                family );

            PrintRoutine(
                pContext,
                "\tAddr[%d] = %s \t(ptr=%p)\n",
                i,
                stringBuf,
                pip );
            i++;
        }
    }

    DnsPrint_Unlock();
}



//
//  IP help types (iptypes.h)
//

VOID
DnsPrint_IpAdapterAddress(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PVOID               pAddr,
    IN      BOOL                fUnicast,
    IN      BOOL                fPrintList
    )
/*++

Routine Description:

    Print IP_ADAPTER_XXX_ADDRESS structures

    This prints:
        PIP_ADAPTER_UNICAST_ADDRESS
        PIP_ADAPTER_ANYCAST_ADDRESS   
        PIP_ADAPTER_MULTICAST_ADDRESS 
        PIP_ADAPTER_DNS_SERVER_ADDRESS

    fUnicast --
        TRUE for UNICAST,
        FALSE for all other types which are identical.

    fPrintList --
        TRUE to print all addresses.
        FALSE to print just this address.

--*/
{
    PIP_ADAPTER_UNICAST_ADDRESS paddr = (PIP_ADAPTER_UNICAST_ADDRESS) pAddr;
    DWORD   count = 0;

    if ( !pszHeader )
    {
        pszHeader = "IpAdapterAddress:";
    }

    if ( !paddr )
    {
        PrintRoutine(
            pContext,
            "%s\tNULL IpAdapterAddress passed to print.\n",
            pszHeader );
        return;
    }

    DnsPrint_Lock();

    if ( fPrintList )
    {
        PrintRoutine(
            pContext,
            "%s List:\n",
            pszHeader );
    }

    while ( paddr )
    {
        if ( fPrintList )
        {
            PrintRoutine(
                pContext,
                "%s [%d]:\n",
                pszHeader,
                count );
        }
        else
        {
            PrintRoutine(
                pContext,
                "%s\n",
                pszHeader );
        }

        PrintRoutine(
            pContext,
            "\tPointer          = %p\n"
            "\tLength           = %d\n"
            "\tFlags            = %08x\n"
            "\tpNext            = %p\n",
            paddr,
            paddr->Length,
            paddr->Flags,
            paddr->Next
            );

        DnsPrint_SocketAddress(
            PrintRoutine,
            pContext,
            "\tSocketAddress:",
            1,      // indent
            & paddr->Address
            );

        if ( fUnicast )
        {
            PrintRoutine(
                pContext,
                "\tPrefixOrigin     = %d\n"
                "\tSuffixOrigin     = %d\n"
                "\tDadState         = %d\n"
                "\tValidLifetime    = %u\n"
                "\tPrefLifetime     = %u\n"
                "\tLeaseLifetime    = %u\n",
                paddr->PrefixOrigin,
                paddr->SuffixOrigin,
                paddr->DadState,
                paddr->ValidLifetime,
                paddr->PreferredLifetime,
                paddr->LeaseLifetime
                );
        }

        //  print next in list (if desired)
        //      - hard stop at 50 addresses

        paddr = paddr->Next;
        if ( !fPrintList || count > 50 )
        {
            break;
        }
        count++;
    }

    if ( fPrintList )
    {
        PrintRoutine(
            pContext,
            "End of %s List\n",
            pszHeader );
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_IpAdapterList(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pContext,
    IN      PSTR                    pszHeader,
    IN      PIP_ADAPTER_ADDRESSES   pAdapt,
    IN      BOOL                    fPrintAddrs,
    IN      BOOL                    fPrintList
    )
/*++

Routine Description:

    Print IP_ADAPTER_ADDRESSES structure

Arguments:

    fPrintAddressLists -- TRUE to print address list subfields.

    fPrintList --
        TRUE to print list of adapters,
        FALSE to print just this adapter

--*/
{
    if ( !pszHeader )
    {
        pszHeader = "IpAdapter:";
    }

    if ( !pAdapt )
    {
        PrintRoutine(
            pContext,
            "%s\tNULL IpAdapter passed to print.\n",
            pszHeader );
        return;
    }

    DnsPrint_Lock();

    if ( fPrintList )
    {
        PrintRoutine(
            pContext,
            "%s List:\n",
            pszHeader );
    }

    while ( pAdapt )
    {
        PrintRoutine(
            pContext,
            "%s\n"
            "\tPointer          = %p\n"
            "\tLength           = %d\n"
            "\tIfIndex          = %d\n"
            "\tpNext            = %p\n"
            "\tAdapterName      = %s\n"
            "\tUnicastList      = %p\n"
            "\tAnycastList      = %p\n"
            "\tMulticastList    = %p\n"
            "\tDnsServerList    = %p\n"
            "\tDnsSuffix        = %S\n"
            "\tDescription      = %S\n"
            "\tFriendlyName     = %S\n"
            "\tPhysicalAddr Ptr = %p\n"
            "\tPhysicalLength   = %d\n"
            "\tFlags            = %d\n"
            "\tMtu              = %d\n"
            "\tIfType           = %d\n"
            "\tOperStatus       = %d\n"
            "\tIfIndex6         = %d\n",
            pszHeader,
            pAdapt,
            pAdapt->Length,
            pAdapt->IfIndex,
            pAdapt->Next,
            pAdapt->AdapterName,
            pAdapt->FirstUnicastAddress,
            pAdapt->FirstAnycastAddress,
            pAdapt->FirstMulticastAddress,
            pAdapt->FirstDnsServerAddress,
            pAdapt->DnsSuffix,
            pAdapt->Description,
            pAdapt->FriendlyName,
            pAdapt->PhysicalAddress,
            pAdapt->PhysicalAddressLength,
            pAdapt->Flags,
            pAdapt->Mtu,
            pAdapt->IfType,
            (INT) pAdapt->OperStatus,
            pAdapt->Ipv6IfIndex );

        PrintRoutine(
            pContext,
            "\tZoneIndices      = %d inf=%d lnk=%d sub=%d adm=%d site=%d %d %d\n"
            "\t                   %d %d %d %d %d %d %d %d\n",
            pAdapt->ZoneIndices[0],
            pAdapt->ZoneIndices[1],
            pAdapt->ZoneIndices[2],
            pAdapt->ZoneIndices[3],
            pAdapt->ZoneIndices[4],
            pAdapt->ZoneIndices[5],
            pAdapt->ZoneIndices[6],
            pAdapt->ZoneIndices[7],
            pAdapt->ZoneIndices[8],
            pAdapt->ZoneIndices[9],
            pAdapt->ZoneIndices[10],
            pAdapt->ZoneIndices[11],
            pAdapt->ZoneIndices[12],
            pAdapt->ZoneIndices[13],
            pAdapt->ZoneIndices[14],
            pAdapt->ZoneIndices[15] );
    
        DnsPrint_RawBinary(
            PrintRoutine,
            pContext,
            NULL,                   // no header
            "\tPhysical Address",   // line header
            pAdapt->PhysicalAddress,
            pAdapt->PhysicalAddressLength,
            0                       // no alignment, write in bytes
            );

        if ( fPrintAddrs )
        {
            if ( pAdapt->FirstUnicastAddress )
            {
                DnsPrint_IpAdapterAddress(
                    PrintRoutine,
                    pContext,
                    "Adapter Unicast Addrs",
                    pAdapt->FirstUnicastAddress,
                    TRUE,       // unicast
                    TRUE        // print list
                    );
            }
            if ( pAdapt->FirstAnycastAddress )
            {
                DnsPrint_IpAdapterAddress(
                    PrintRoutine,
                    pContext,
                    "Adapter Anycast Addrs",
                    pAdapt->FirstAnycastAddress,
                    FALSE,      // not unicast
                    TRUE        // print list
                    );
            }
            if ( pAdapt->FirstMulticastAddress )
            {
                DnsPrint_IpAdapterAddress(
                    PrintRoutine,
                    pContext,
                    "Adapter Multicast Addrs",
                    pAdapt->FirstMulticastAddress,
                    FALSE,      // not unicast
                    TRUE        // print list
                    );
            }
            if ( pAdapt->FirstDnsServerAddress )
            {
                DnsPrint_IpAdapterAddress(
                    PrintRoutine,
                    pContext,
                    "Adapter DnsServer Addrs",
                    pAdapt->FirstDnsServerAddress,
                    FALSE,      // not unicast
                    TRUE        // print list
                    );
            }
        }

        //  get next

        pAdapt = pAdapt->Next;
        if ( !fPrintList )
        {
            break;
        }
    }

    PrintRoutine(
        pContext,
        "End of %s%s\n"
        "\n",
        pszHeader,
        fPrintList ? " List" : "" );

    DnsPrint_Unlock();
}



//
//  Query print routines
//

VOID
DnsPrint_QueryBlob(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PQUERY_BLOB         pBlob
    )
/*++

Routine Description:

    Print query blob.

Arguments:

    PrintRoutine - routine to print with

    pContext    - print context

    pszHeader   - header

    pBlob       - query info

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "Query Blob:";
    }

    if ( !pBlob )
    {
        PrintRoutine(
            pContext,
            "%s %s\n",
            pszHeader,
            "NULL Query Blob ptr." );
        return;
    }

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "\tname orig        %S\n"
        "\tname query       %S\n"
        "\ttype             %d\n"
        "\tflags            %08x\n"

        "\tname length      %d\n"
        "\tname attributes  %08x\n"
        "\tquery count      %d\n"
        "\tname flags       %08x\n"
        "\tfappendedName    %d\n"

        "\tstatus           %d\n"
        "\trcode            %d\n"
        "\tnetfail status   %d\n"
        "\tcache negative   %d\n"
        "\tno ip local      %d\n"
        "\trecords          %p\n"
        "\tlocal records    %p\n"

        "\tnetwork info     %p\n"
        "\tserver list      %p\n"
        "\tserver4 list     %p\n"
        "\tpmsg             %p\n"
        "\tevent            %p\n",

        pBlob->pNameOrig,
        pBlob->pNameQuery,
        pBlob->wType,
        pBlob->Flags,
    
        pBlob->NameLength,
        pBlob->NameAttributes,
        pBlob->QueryCount,
        pBlob->NameFlags,
        pBlob->fAppendedName,
    
        pBlob->Status,
        pBlob->Rcode,
        pBlob->NetFailureStatus,
        pBlob->fCacheNegative,
        pBlob->fNoIpLocal,
        pBlob->pRecords,
        pBlob->pLocalRecords,

        pBlob->pNetInfo,
        pBlob->pServerList,
        pBlob->pServerList4,
        pBlob->pRecvMsg,
        pBlob->hEvent
        );

    //  DCR_FIX0:  cleanup when results in use

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Records:\n",
        pBlob->pRecords );

    //  DCR_FIX0:  use results when ready

    DnsPrint_Unlock();
}



VOID
DnsPrint_QueryResults(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PDNS_RESULTS        pResults
    )
/*++

Routine Description:

    Print query results.

Arguments:

    PrintRoutine - routine to print with

    pContext    - print context

    pszHeader   - header

    pResults    - results info

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "Results:";
    }

    if ( !pResults )
    {
        PrintRoutine(
            pContext,
            "%s %s\n",
            pszHeader,
            "NULL Results ptr." );
        return;
    }

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "\tstatus       %d\n"
        "\trcode        %d\n"
        "\tserver       %s\n"
        "\tpanswer      %p\n"
        "\tpalias       %p\n"
        "\tpauthority   %p\n"
        "\tpadditional  %p\n"
        "\tpsig         %p\n"
        "\tpmsg         %p\n",
        pResults->Status,
        pResults->Rcode,
        IP4_STRING( pResults->ServerAddr ),
        pResults->pAnswerRecords,
        pResults->pAliasRecords,
        pResults->pAuthorityRecords,
        pResults->pAdditionalRecords,
        pResults->pSigRecords,
        pResults->pMessage
        );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "\tAnswer records:\n",
        pResults->pAnswerRecords );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "\tAlias records:\n",
        pResults->pAliasRecords );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "\tAuthority records:\n",
        pResults->pAuthorityRecords );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "\tAdditional records:\n",
        pResults->pAdditionalRecords );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "\tSignature records:\n",
        pResults->pSigRecords );

    DnsPrint_Unlock();
}



VOID
DnsPrint_ParsedMessage(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PDNS_PARSED_MESSAGE pParsed
    )
/*++

Routine Description:

    Print parsed message.

Arguments:

    PrintRoutine - routine to print with

    pContext    - print context

    pszHeader   - header

    pResults       - query info

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "Parsed Message:";
    }

    if ( !pParsed )
    {
        PrintRoutine(
            pContext,
            "%s %s\n",
            pszHeader,
            "NULL Parsed Message ptr." );
        return;
    }

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "\tstatus       %d (%08x)\n"
        "\tchar set     %d\n",
        pParsed->Status, pParsed->Status,
        pParsed->CharSet
        );

    PrintRoutine(
        pContext,
        "\tquestion:\n"
        "\t\tname       %S%s\n"
        "\t\ttype       %d\n"
        "\t\tclass      %d\n",
        PRINT_STRING_WIDE_CHARSET( pParsed->pQuestionName, pParsed->CharSet ),
        PRINT_STRING_ANSI_CHARSET( pParsed->pQuestionName, pParsed->CharSet ),
        pParsed->QuestionType,
        pParsed->QuestionClass
        );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Answer records:\n",
        pParsed->pAnswerRecords );
    
    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Alias records:\n",
        pParsed->pAliasRecords );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Authority records:\n",
        pParsed->pAuthorityRecords );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Additional records:\n",
        pParsed->pAdditionalRecords );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Signature records:\n",
        pParsed->pSigRecords );

    DnsPrint_Unlock();
}



VOID
DnsPrint_QueryInfo(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PDNS_QUERY_INFO     pQueryInfo
    )
/*++

Routine Description:

    Print query info

Arguments:

    PrintRoutine - routine to print with

    pContext    - print context

    pszHeader   - header

    pQueryInfo  - query info

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "Query Info:";
    }

    if ( !pQueryInfo )
    {
        PrintRoutine(
            pContext,
            "%s %s\n",
            pszHeader,
            "NULL Query Info ptr." );
        return;
    }

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\n"
        "\tpointer      %p\n"
        "\tstatus       %d (%08x)\n"
        "\tchar set     %d\n"
        "\tname         %S%s\n"
        "\tname resv.   %s\n"
        "\ttype         %d\n"
        "\trcode        %d\n"
        "\tflags        %08x\n"

        "\tpanswer      %p\n"
        "\tpalias       %p\n"
        "\tpauthority   %p\n"
        "\tpadditional  %p\n"
        //"\tpsig         %p\n"

        "\tevent        %p\n"
        "\tserver list  %p\n"
        "\tserver4 list %p\n"
        "\tpmsg         %p\n",

        pszHeader,
        pQueryInfo,
        pQueryInfo->Status, pQueryInfo->Status,
        pQueryInfo->CharSet,
        PRINT_STRING_WIDE_CHARSET( pQueryInfo->pName, pQueryInfo->CharSet ),
        PRINT_STRING_ANSI_CHARSET( pQueryInfo->pName, pQueryInfo->CharSet ),
        pQueryInfo->pReservedName,
        pQueryInfo->Type,
        pQueryInfo->Rcode,
        pQueryInfo->Flags,

        pQueryInfo->pAnswerRecords,
        pQueryInfo->pAliasRecords,
        pQueryInfo->pAuthorityRecords,
        pQueryInfo->pAdditionalRecords,
        //pQueryInfo->pSigRecords,

        pQueryInfo->hEvent,
        pQueryInfo->pServerList,
        pQueryInfo->pServerListIp4,
        pQueryInfo->pMessage
        );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Answer records:\n",
        pQueryInfo->pAnswerRecords );
    
    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Alias records:\n",
        pQueryInfo->pAliasRecords );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Authority records:\n",
        pQueryInfo->pAuthorityRecords );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "Additional records:\n",
        pQueryInfo->pAdditionalRecords );

    //DnsPrint_RecordSet(
    //    "Signature records:\n",
    //    pQueryInfo->pSigRecords );

    DnsPrint_Unlock();
}



VOID
DnsPrint_EnvarInfo(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PENVAR_DWORD_INFO   pEnvar
    )
/*++

Routine Description:

    Print envar data

Arguments:

    PrintRoutine - routine to print with

    pContext    - print context

    pszHeader -- header to print with

    pEnvar -- ptr to envar info

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    PrintRoutine(
        pContext,
        "%s\n"
        "\tId       = %d\n"
        "\tValue    = %p\n"
        "\tfFound   = %d\n",
        pszHeader ? pszHeader : "Envar Info:",
        pEnvar->Id,
        pEnvar->Value,
        pEnvar->fFound
        );
}



//
//  Network info print routines.
//

VOID
DnsPrint_NetworkInfo(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_NETINFO        pNetworkInfo
    )
/*++

Routine Description:

    Prints and validates network info structure.
    Should also touch all the memory and AV when bogus.

Arguments:

    pNetworkInfo -- network info to print

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "NetworkInfo:";
    }
    if ( !pNetworkInfo )
    {
        PrintRoutine(
            pPrintContext,
            "%s NULL NetworkInfo.\n",
            pszHeader );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pPrintContext,
        "%s\n"
        "\tpointer          = %p\n"
        "\tpszHostName      = %S\n"
        "\tpszDomainName    = %S\n"
        "\tpSearchList      = %p\n"
        "\tTimeStamp        = %d\n"
        "\tTag              = %d\n"
        "\tInfoFlags        = %08x\n"
        "\tReturnFlags      = %08x\n"
        "\tAdapterIndex     = %d\n"
        "\tAdapterCount     = %d\n"
        "\tAdapterArraySize = %d\n",
        pszHeader,
        pNetworkInfo,
        pNetworkInfo->pszHostName,
        pNetworkInfo->pszDomainName,
        pNetworkInfo->pSearchList,
        pNetworkInfo->TimeStamp,
        pNetworkInfo->Tag,
        pNetworkInfo->InfoFlags,
        pNetworkInfo->ReturnFlags,
        pNetworkInfo->AdapterIndex,
        pNetworkInfo->AdapterCount,
        pNetworkInfo->MaxAdapterCount );

    //  print search list

    DnsPrint_SearchList(
        PrintRoutine,
        pPrintContext,
        "Search List: ",
        pNetworkInfo->pSearchList );

    //  print server lists

    for ( i=0; i < pNetworkInfo->AdapterCount; i++ )
    {
        CHAR    header[60];

        sprintf( header, "AdapterInfo[%d]:", i );

        DnsPrint_AdapterInfo(
            PrintRoutine,
            pPrintContext,
            header,
            NetInfo_GetAdapterByIndex( pNetworkInfo, i ) );
    }
    PrintRoutine(
        pPrintContext,
        "\n" );

    DnsPrint_Unlock();
}



VOID
DnsPrint_AdapterInfo(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_ADAPTER        pAdapter
    )
/*++

Routine Description:

    Prints and validates DNS adapter info.
    Should also touch all the memory and AV when bogus.

Arguments:

    pAdapter -- DNS adapter to print

Return Value:

    None.

--*/
{
    DWORD           i;
    PDNS_ADDR_ARRAY pserverArray;
    CHAR            buffer[ DNS_ADDR_STRING_BUFFER_LENGTH ];

    if ( !pszHeader )
    {
        pszHeader = "Adapter Info:";
    }
    if ( !pAdapter )
    {
        PrintRoutine(
            pPrintContext,
            "%s NULL Adapter info.\n",
            pszHeader );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pPrintContext,
        "%s\n"
        "\tpointer          = %p\n"
        "\tGuid Name        = %S\n"
        "\tDomain           = %S\n"
        "\tLocalAddrs       = %p\n"
        "\tDnsAddrs         = %p\n"
        "\tInterfaceIndex   = %d\n"
        "\tInterfaceIndex6  = %d\n"
        "\tInfoFlags        = %08x\n"
        "\tStatus           = %d\n"
        "\tRunFlags         = %08x\n"
        "\tSite             = %d\n",
        pszHeader,
        pAdapter,
        pAdapter->pszAdapterGuidName,
        pAdapter->pszAdapterDomain,
        pAdapter->pLocalAddrs,
        pAdapter->pDnsAddrs,
        pAdapter->InterfaceIndex,
        pAdapter->InterfaceIndex6,
        pAdapter->InfoFlags,
        pAdapter->Status,
        pAdapter->RunFlags,
        pAdapter->Site );

    //  DNS server info

    pserverArray = pAdapter->pDnsAddrs;
    if ( pserverArray )
    {
        for ( i=0; i < pserverArray->AddrCount; i++ )
        {
            PDNS_ADDR   pserver = &pserverArray->AddrArray[i];
    
            DnsAddr_WriteStructString_A(
                buffer,
                pserver );
    
            PrintRoutine(
                pPrintContext,
                "\tDNS Server [%d]:\n"
                "\t\tAddress    = %s\n"
                "\t\tPriority   = %d\n"
                "\t\tFlags      = %08x\n"
                "\t\tStatus     = %u\n",
                i,
                buffer,
                pserver->Priority,
                pserver->Flags,
                pserver->Status
                );
        }
    }

    //  IP address info

    if ( pAdapter->pLocalAddrs )
    {
        DnsPrint_DnsAddrArray(
            PrintRoutine,
            pPrintContext,
            "\tLocal Addrs",
            "\tAddr",
            pAdapter->pLocalAddrs );
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_SearchList(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PSEARCH_LIST        pSearchList
    )
/*++

Routine Description:

    Prints and validates DNS search list.
    Should also touch all the memory and AV when bogus.

Arguments:

    pSearchList -- search list to print

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "DNS Search List:";
    }

    if ( ! pSearchList )
    {
        PrintRoutine(
            pPrintContext,
            "%s NULL search list.\n",
            pszHeader );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pPrintContext,
        "%s\n"
        "\tpointer        = %p\n"
        "\tNameCount      = %d\n"
        "\tMaxNameCount   = %d\n"
        "\tCurrentIndex   = %d\n"
        "\tSearchListNames:\n",
        pszHeader,
        pSearchList,
        pSearchList->NameCount,
        pSearchList->MaxNameCount,
        pSearchList->CurrentNameIndex
        );

    for ( i=0; i < pSearchList->NameCount; i++ )
    {
        PrintRoutine(
            pPrintContext,
            "\t\t%S (Flags: %08x)\n",
            pSearchList->SearchNameArray[i].pszName,
            pSearchList->SearchNameArray[i].Flags );
    }
    DnsPrint_Unlock();
}



VOID
DnsPrint_HostentBlob(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PHOSTENT_BLOB   pBlob
    )
/*++

Routine Description:

    Print hostent structure.

Arguments:

    PrintRoutine - routine to print with

    pszHeader   - header

    pBlob       - ptr to hostent blob

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "Hostent Blob:";
    }

    if ( !pBlob )
    {
        PrintRoutine(
            pContext,
            "%s %s\n",
            pszHeader,
            "NULL Hostent blob ptr." );
        return;
    }

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\n"
        "\tPtr                  = %p\n"
        "\tpHostent             = %p\n"
        "\tfAllocatedBlob       = %d\n"
        "\tfAllocatedBuf        = %d\n"
        "\tpBuffer              = %p\n"
        "\tBufferLength         = %d\n"
        "\tAvailLength          = %d\n"
        "\tpAvailBuffer         = %p\n"
        "\tpCurrent             = %p\n"
        "\tBytesLeft            = %d\n"
        "\tMaxAliasCount        = %d\n"
        "\tAliasCount           = %d\n"
        "\tMaxAddrCount         = %d\n"
        "\tAddrCount            = %d\n"
        "\tfWroteName           = %d\n"
        "\tfUnicode             = %d\n"
        "\tCharSet              = %d\n",
        pszHeader,
        pBlob,
        pBlob->pHostent,
        pBlob->fAllocatedBlob,
        pBlob->fAllocatedBuf,
        pBlob->pBuffer,
        pBlob->BufferLength,
        pBlob->AvailLength,
        pBlob->pAvailBuffer,
        pBlob->pCurrent,
        pBlob->BytesLeft,
        pBlob->MaxAliasCount,
        pBlob->AliasCount,
        pBlob->MaxAddrCount,
        pBlob->AddrCount,
        pBlob->fWroteName,
        pBlob->fUnicode,
        pBlob->CharSet
        );

    //  print the hostent

    if ( pBlob->pHostent )
    {
        DnsPrint_Hostent(
            PrintRoutine,
            pContext,
            NULL,
            pBlob->pHostent,
            pBlob->fUnicode
            );
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_SaBlob(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSABLOB         pBlob
    )
/*++

Routine Description:

    Print sockaddr blob structure.

Arguments:

    PrintRoutine - routine to print with

    pszHeader   - header

    pBlob       - ptr to hostent blob

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "SockaddrBlob:";
    }

    if ( !pBlob )
    {
        PrintRoutine(
            pContext,
            "%s %s\n",
            pszHeader,
            "NULL SockaddrBlob ptr." );
        return;
    }

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\n"
        "\tPtr                  = %p\n"
        "\tpName                = %S\n"
        "\tpHostent             = %p\n"
        "\tAliasCount           = %d\n",
        pszHeader,
        pBlob,
        pBlob->pName,
        pBlob->pHostent,
        pBlob->AliasCount
        );

    //  print the aliases

    for ( i=0; i<pBlob->AliasCount; i++ )
    {
        PWSTR   palias = pBlob->AliasArray[i];

        PrintRoutine(
            pContext,
            "\tAlias = (%p) %S\n",
            palias,
            palias );
    }

    //  print the addresses

    DnsPrint_DnsAddrArray(
        PrintRoutine,
        pContext,
        "\tSockaddrs:",
        "\t\tAddr",
        pBlob->pAddrArray );

    DnsPrint_Unlock();
}




//
//  Update info print routines
//

VOID
DnsPrint_UpdateBlob(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PUPDATE_BLOB        pBlob
    )
/*++

Routine Description:

    Print update blob.

Arguments:

    PrintRoutine - routine to print with

    pContext    - print context

    pszHeader   - header

    pBlob       - update info

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "Update Blob:";
    }

    if ( !pBlob )
    {
        PrintRoutine(
            pContext,
            "%s %s\n",
            pszHeader,
            "NULL Update Blob ptr." );
        return;
    }

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\n"
        "\tBlob ptr         %p\n"
        "\tpRecords         %p\n"
        "\tFlags            %08x\n"
        "\ttest mode        %d\n"
        "\tsave msg         %d\n"
        "\thCreds           %p\n"
        "\tpExtraInfo       %p\n"
        "\tpNetInfo         %p\n"
        "\tpszZone          %s\n"
        "\tpszServerName    %s\n"
        "\tserver list      %p\n"
        "\tserver4 list     %p\n"
        "\tpRecvMsg         %p\n",

        pszHeader,
        pBlob,
        pBlob->pRecords,        
        pBlob->Flags,           
        pBlob->fUpdateTestMode, 
        pBlob->fSaveRecvMsg,    
        pBlob->hCreds,          
        pBlob->pExtraInfo,      
        pBlob->pNetInfo,        
        pBlob->pszZone,         
        pBlob->pszServerName,
        pBlob->pServerList,
        pBlob->pServ4List,
        pBlob->pMsgRecv
        );

    DnsPrint_RecordSet(
        PrintRoutine,
        pContext,
        "\tUpdate Records:\n",
        pBlob->pRecords );

    if ( pBlob->pServerList )
    {
        DnsPrint_DnsAddrArray(
            PrintRoutine,
            pContext,
            "Server List",
            NULL,
            pBlob->pServerList );
    }
    if ( pBlob->pServ4List )
    {
        DnsPrint_Ip4Array(
            PrintRoutine,
            pContext,
            "Server4 List",
            NULL,
            pBlob->pServ4List );
    }

    if ( !DnsAddr_IsEmpty( &pBlob->FailedServer ) )
    {
        DnsPrint_DnsAddrLine(
            PrintRoutine,
            pContext,
            "Failed Server Addr",
            & pBlob->FailedServer,
            NULL );
    }

#if 1
    if ( pBlob->pExtraInfo )
    {
        DnsPrint_ExtraInfo(
            PrintRoutine,
            pContext,
            NULL,
            pBlob->pExtraInfo );
    }
#endif

    DnsPrint_Unlock();
}



VOID
DnsPrint_ExtraInfo(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PDNS_EXTRA_INFO     pInfo
    )
/*++

Routine Description:

    Print update extra info.

Arguments:

    PrintRoutine - routine to print with

    pContext    - print context

    pszHeader   - header

    pInfo       - extra info

Return Value:

    None.

--*/
{
    if ( !pszHeader )
    {
        pszHeader = "Update Extra Info:";
    }

    if ( !pInfo )
    {
        PrintRoutine(
            pContext,
            "%s %s\n",
            pszHeader,
            "NULL Update Extra Info ptr." );
        return;
    }

    //  print the struct(s)

    DnsPrint_Lock();

    while ( pInfo )
    {
        PrintRoutine(
            pContext,
            "%s\n"
            "\tinfo ptr     %p\n"
            "\tnext ptr     %p\n"
            "\tid           %d\n",
            pszHeader,
            pInfo,
            pInfo->pNext,
            pInfo->Id
            );

        switch ( pInfo->Id )
        {
        case DNS_EXINFO_ID_RESULTS_V1:

            //  print the struct
        
            PrintRoutine(
                pContext,
                "\tstatus       %d\n"
                "\trcode        %d\n"
                "\tserver IP    %08x %s\n",
                pInfo->ResultsV1.Status,
                pInfo->ResultsV1.Rcode,
                pInfo->ResultsV1.ServerIp4,
                IP4_STRING( pInfo->ResultsV1.ServerIp4 )
                );
            break;

        case DNS_EXINFO_ID_RESULTS_BASIC:

            DnsPrint_ResultsBasic(
                PrintRoutine,
                pContext,
                NULL,
                (PBASIC_RESULTS) & pInfo->ResultsBasic
                );
            break;

        case DNS_EXINFO_ID_SERVER_LIST:

            DnsPrint_DnsAddrArray(
                PrintRoutine,
                pContext,
                "ServerList:",
                NULL,
                pInfo->pServerList
                );
            break;

        case DNS_EXINFO_ID_SERVER_LIST_IP4:

            DnsPrint_Ip4Array(
                PrintRoutine,
                pContext,
                "ServerList IP4:",
                NULL,
                pInfo->pServerList4
                );
            break;

        default:

            //  verify this is results blob
        
            PrintRoutine(
                pContext,
                "\tUnknown update info ID = %d\n",
                pInfo->Id );
            break;
        }

        pInfo = pInfo->pNext;
    }

    DnsPrint_Unlock();
}



#if 0
VOID
DnsPrint_UpdateResults(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pContext,
    IN      PSTR                    pszHeader,
    IN      PDNS_UPDATE_RESULT_INFO pResults
    )
/*++

Routine Description:

    Print update results.

Arguments:

    PrintRoutine - routine to print with

    pContext    - print context

    pszHeader   - header

    pResults    - results info

Return Value:

    None.

--*/
{
    if ( !pszHeader )
    {
        pszHeader = "Update Results:";
    }

    if ( !pResults )
    {
        PrintRoutine(
            pContext,
            "%s %s\n",
            pszHeader,
            "NULL Update Results ptr." );
        return;
    }

    //  verify this is results blob

    if ( pResults->Id != DNS_UPDATE_INFO_ID_RESULT_INFO )
    {
        PrintRoutine(
            pContext,
            "%s ptr=%p is NOT valid update results id=%d\n",
            pszHeader,
            pResults,
            pResults->Id );
        return;
    }

    //  print the struct

    PrintRoutine(
        pContext,
        "%s\n"
        "\tresults ptr  %p\n"
        "\tstatus       %d\n"
        "\trcode        %d\n"
        "\tserver IP    %08x %s\n",
        pszHeader,
        pResults,
        pResults->Status,
        pResults->Rcode,
        pResults->ServerIp,
        IP4_STRING( pResults->ServerIp ),
        );
}
#endif



VOID
DnsPrint_ResultsBasic(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PBASIC_RESULTS      pResults
    )
/*++

Routine Description:

    Print query results.

Arguments:

    PrintRoutine - routine to print with

    pContext    - print context

    pszHeader   - header

    pResults    - results info

Return Value:

    None.

--*/
{
    DWORD   i;
    CHAR    addrString[DNS_ADDR_STRING_BUFFER_LENGTH];

    if ( !pszHeader )
    {
        pszHeader = "Results:";
    }

    if ( !pResults )
    {
        PrintRoutine(
            pContext,
            "%s %s\n",
            pszHeader,
            "NULL Results ptr." );
        return;
    }

    //  print the struct

    DnsAddr_WriteStructString_A(
        addrString,
        & pResults->ServerAddr );

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "\tStatus           %d\n"
        "\tRcode            %d\n"
        "\tServer           %s\n",
        pResults->Status,
        pResults->Rcode,
        addrString
        );

    DnsPrint_Unlock();
}



VOID
DnsPrint_ResultBlob(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pContext,
    IN      PSTR                pszHeader,
    IN      PRESULT_BLOB        pResults
    )
/*++

Routine Description:

    Print query results.

Arguments:

    PrintRoutine - routine to print with

    pContext    - print context

    pszHeader   - header

    pResults    - results info

Return Value:

    None.

--*/
{
    DWORD   i;
    CHAR    addrString[DNS_ADDR_STRING_BUFFER_LENGTH];

    if ( !pszHeader )
    {
        pszHeader = "Results:";
    }

    if ( !pResults )
    {
        PrintRoutine(
            pContext,
            "%s %s\n",
            pszHeader,
            "NULL Results ptr." );
        return;
    }

    //  print the struct

    DnsAddr_WriteStructString_A(
        addrString,
        & pResults->ServerAddr );

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "\tStatus           %d\n"
        "\tRcode            %d\n"
        "\tfHaveResponse    %d\n"
        "\tServer           %s\n"
        "\tpRecords         %p\n"
        "\tpMessage         %p\n",
        pResults->Status,
        pResults->Rcode,
        pResults->fHaveResponse,
        addrString,
        pResults->pRecords,
        pResults->pMessage
        );

    if ( pResults->pRecords )
    {
        DnsPrint_RecordSet(
            PrintRoutine,
            pContext,
            "\tRecords:\n",
            pResults->pRecords );
    }
    DnsPrint_Unlock();
}


VOID
DnsPrint_SendBlob(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PSTR            pszHeader,
    IN      PSEND_BLOB      pBlob
    )
/*++

Routine Description:

    Print update blob.

Arguments:

    PrintRoutine - routine to print with

    pContext    - print context

    pszHeader   - header

    pBlob       - send blob

Return Value:

    None.

--*/
{
    DWORD   i;

    if ( !pszHeader )
    {
        pszHeader = "Send Blob:";
    }

    if ( !pBlob )
    {
        PrintRoutine(
            pContext,
            "%s %s\n",
            pszHeader,
            "NULL Send Blob ptr." );
        return;
    }

    //  print the struct

    DnsPrint_Lock();

    PrintRoutine(
        pContext,
        "%s\n"
        "\tBlob ptr         %p\n"
        "\tpNetInfo         %p\n"
        "\tpServerArray     %p\n"
        "\tpServ4Array      %p\n"
        "\tpSendMsg         %p\n"
        "\tFlags            %08x\n"
        "\tfSaveRecvMsg     %d\n"
        "\tfSaveRecords     %d\n",
        pszHeader,
        pBlob,
        pBlob->pNetInfo,        
        pBlob->pServerList,
        pBlob->pServ4List,
        pBlob->pSendMsg,        
        pBlob->Flags,           
        pBlob->fSaveResponse,
        pBlob->fSaveRecords
        );

    if ( pBlob->pServerList )
    {
        DnsPrint_DnsAddrArray(
            PrintRoutine,
            pContext,
            "Server List",
            NULL,
            pBlob->pServerList );
    }
    if ( pBlob->pServ4List )
    {
        DnsPrint_Ip4Array(
            PrintRoutine,
            pContext,
            "Server IP4 List",
            NULL,
            pBlob->pServ4List );
    }

    DnsPrint_ResultBlob(
        PrintRoutine,
        pContext,
        "\tSend Results:\n",
        &pBlob->Results );

    DnsPrint_Unlock();
}

//
//  End of print.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\record.c ===
/*++

Copyright (c) 1996-2001 Microsoft Corporation

Module Name:

    record.c

Abstract:

    Domain Name System (DNS) Library

    Routines to handle resource records (RR).

Author:

    Jim Gilroy (jamesg)     December 1996

Revision History:

--*/


#include "local.h"

#include "time.h"
#include "ws2tcpip.h"   // IPv6 inaddr definitions



//
//  Type name mapping.
//
//  Unlike above general value\string mapping the type lookup
//  has property of allowing direct lookup indexing with type, so
//  it is special cased.
//

//
//  DCR:   make combined type table
//  DCR:   add property flags to type table
//      - writeability flag?
//      - record/query type?
//      - indexable type?
//
//  then function just get index for type and check flag(s)
//


TYPE_NAME_TABLE TypeTable[] =
{
    "ZERO"      , 0                 ,
    "A"         , DNS_TYPE_A        ,
    "NS"        , DNS_TYPE_NS       ,
    "MD"        , DNS_TYPE_MD       ,
    "MF"        , DNS_TYPE_MF       ,
    "CNAME"     , DNS_TYPE_CNAME    ,
    "SOA"       , DNS_TYPE_SOA      ,
    "MB"        , DNS_TYPE_MB       ,
    "MG"        , DNS_TYPE_MG       ,
    "MR"        , DNS_TYPE_MR       ,
    "NULL"      , DNS_TYPE_NULL     ,
    "WKS"       , DNS_TYPE_WKS      ,
    "PTR"       , DNS_TYPE_PTR      ,
    "HINFO"     , DNS_TYPE_HINFO    ,
    "MINFO"     , DNS_TYPE_MINFO    ,
    "MX"        , DNS_TYPE_MX       ,
    "TXT"       , DNS_TYPE_TEXT     ,

    "RP"        , DNS_TYPE_RP       ,
    "AFSDB"     , DNS_TYPE_AFSDB    ,
    "X25"       , DNS_TYPE_X25      ,
    "ISDN"      , DNS_TYPE_ISDN     ,
    "RT"        , DNS_TYPE_RT       ,

    "NSAP"      , DNS_TYPE_NSAP     ,
    "NSAPPTR"   , DNS_TYPE_NSAPPTR  ,
    "SIG"       , DNS_TYPE_SIG      ,
    "KEY"       , DNS_TYPE_KEY      ,
    "PX"        , DNS_TYPE_PX       ,
    "GPOS"      , DNS_TYPE_GPOS     ,

    "AAAA"      , DNS_TYPE_AAAA     ,
    "LOC"       , DNS_TYPE_LOC      ,
    "NXT"       , DNS_TYPE_NXT      ,
    "EID"       , DNS_TYPE_EID      ,
    "NIMLOC"    , DNS_TYPE_NIMLOC   ,
    "SRV"       , DNS_TYPE_SRV      ,
    "ATMA"      , DNS_TYPE_ATMA     ,
    "NAPTR"     , DNS_TYPE_NAPTR    ,
    "KX"        , DNS_TYPE_KX       ,
    "CERT"      , DNS_TYPE_CERT     ,
    "A6"        , DNS_TYPE_A6       ,
    "DNAME"     , DNS_TYPE_DNAME    ,
    "SINK"      , DNS_TYPE_SINK     ,
    "OPT"       , DNS_TYPE_OPT      ,
    "42"        , 0x002a            ,
    "43"        , 0x002b            ,
    "44"        , 0x002c            ,
    "45"        , 0x002d            ,
    "46"        , 0x002e            ,
    "47"        , 0x002f            ,
    "48"        , 0x0030            ,

    //
    //  NOTE:   last type indexed by type ID MUST be set
    //          as MAX_SELF_INDEXED_TYPE #define in record.h
    //          and MUST be added to function tables below,
    //          even if with NULL entry
    //

    //
    //  Pseudo record types
    //

    "TKEY"      , DNS_TYPE_TKEY     ,
    "TSIG"      , DNS_TYPE_TSIG     ,


    //
    //  MS only types
    //

    "WINS"      , DNS_TYPE_WINS     ,
    "WINSR"     , DNS_TYPE_WINSR    ,


    //  **********************************************
    //
    //  NOTE:   This is the END of the type lookup table
    //          for dispatch purposes.
    //
    //          Defined by MAX_RECORD_TYPE_INDEX in dnslibp.h
    //          Type dispatch tables MUST be at least this size.
    //          Geyond this value table continues for string to type
    //          matching only
    //


    "UINFO"     , DNS_TYPE_UINFO    ,
    "UID"       , DNS_TYPE_UID      ,
    "GID"       , DNS_TYPE_GID      ,
    "UNSPEC"    , DNS_TYPE_UNSPEC   ,

    "WINS-R"    , DNS_TYPE_WINSR    ,
    "NBSTAT"    , DNS_TYPE_WINSR    ,

    //
    //  Query types -- only for getting strings
    //

    "ADDRS"     , DNS_TYPE_ADDRS    ,
    "TKEY"      , DNS_TYPE_TKEY     ,
    "TSIG"      , DNS_TYPE_TSIG     ,
    "IXFR"      , DNS_TYPE_IXFR     ,
    "AXFR"      , DNS_TYPE_AXFR     ,
    "MAILB"     , DNS_TYPE_MAILB    ,
    "MAILA"     , DNS_TYPE_MAILA    ,
    "MAILB"     , DNS_TYPE_MAILB    ,
    "ALL"       , DNS_TYPE_ALL      ,

    NULL,   0,
};


//  Handy for screening writeable types

#define LOW_QUERY_TYPE  (DNS_TYPE_ADDRS)




WORD
Dns_RecordTableIndexForType(
    IN      WORD            wType
    )
/*++

Routine Description:

    Get record table index for a given type.

Arguments:

    wType -- RR type in net byte order

Return Value:

    Ptr to RR mneumonic string.
    NULL if unknown RR type.

--*/
{
    //
    //  if type directly indexes table, directly get string
    //

    if ( wType <= MAX_SELF_INDEXED_TYPE )
    {
        return( wType );
    }

    //
    //  types not directly indexed
    //

    else
    {
        WORD i = MAX_SELF_INDEXED_TYPE + 1;

        while ( i <= MAX_RECORD_TYPE_INDEX )
        {
            if ( TypeTable[i].wType == wType )
            {
                return( i );
            }
            i++;
            continue;
        }
    }
    return( 0 );        // type not indexed
}



WORD
Dns_RecordTypeForNameA(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    )
/*++

Routine Description:

    Retrieve RR corresponding to RR database name.

Arguments:

    pchName - name of record type
    cchNameLength - record name length

Return Value:

    Record type corresponding to pchName, if found.
    Otherwise zero.

--*/
{
    INT     i;
    PCHAR   recordString;
    CHAR    firstNameChar;
    CHAR    upcaseName[ MAX_RECORD_NAME_LENGTH+1 ];

    //
    //  if not given get string length
    //

    if ( !cchNameLength )
    {
        cchNameLength = strlen( pchName );
    }

    //  upcase name to optimize compare
    //  allows single character comparison and use of faster case sensitive
    //  compare routine

    if ( cchNameLength > MAX_RECORD_NAME_LENGTH )
    {
        return( 0 );
    }
    memcpy(
        upcaseName,
        pchName,
        cchNameLength );
    upcaseName[ cchNameLength ] = 0;
    _strupr( upcaseName );
    firstNameChar = *upcaseName;

    //
    //  check all supported RR types for name match
    //

    i = 0;
    while( TypeTable[++i].wType != 0 )
    {
        recordString = TypeTable[i].pszTypeName;

        if ( firstNameChar == *recordString
            &&  ! strncmp( upcaseName, recordString, cchNameLength ) )
        {
            return( TypeTable[i].wType );
        }
    }
    return( 0 );
}



WORD
Dns_RecordTypeForNameW(
    IN      PWCHAR          pchName,
    IN      INT             cchNameLength
    )
/*++

Routine Description:

    Retrieve RR corresponding to RR database name.

Arguments:

    pchName - name of record type

    cchNameLength - record name length

Return Value:

    Record type corresponding to pchName, if found.
    Otherwise zero.

--*/
{
    DWORD   length;
    CHAR    ansiName[ MAX_RECORD_NAME_LENGTH+1 ];

    //
    //  convert to ANSI
    //

    length = MAX_RECORD_NAME_LENGTH + 1;

    if ( ! Dns_StringCopy(
                ansiName,
                & length,
                (PSTR) pchName,
                cchNameLength,
                DnsCharSetUnicode,
                DnsCharSetAnsi ) )
    {
        return  0;
    }

    return   Dns_RecordTypeForNameA(
                ansiName,
                0 );
}



PCHAR
private_StringForRecordType(
    IN      WORD            wType
    )
/*++

Routine Description:

    Get string corresponding to record type.

Arguments:

    wType -- RR type in net byte order

Return Value:

    Ptr to RR mneumonic string.
    NULL if unknown RR type.

--*/
{
    //
    //  if type directly indexes table, directly get string
    //

    if ( wType <= MAX_SELF_INDEXED_TYPE )
    {
        return( TypeTable[wType].pszTypeName );
    }

    //
    //  strings not indexed by type, walk the list
    //

    else
    {
        INT i = MAX_SELF_INDEXED_TYPE + 1;

        while( TypeTable[i].wType != 0 )
        {
            if ( wType == TypeTable[i].wType )
            {
                return( TypeTable[i].pszTypeName );
            }
            i++;
        }
    }
    return( NULL );
}



PCHAR
Dns_RecordStringForType(
    IN      WORD            wType
    )
/*++

Routine Description:

    Get type string for type.

    This routine gets pointer rather than direct access to buffer.

Arguments:

    wType -- RR type in net byte order

Return Value:

    Ptr to RR mneumonic string.
    NULL if unknown RR type.

--*/
{
    PSTR    pstr;

    pstr = private_StringForRecordType( wType );
    if ( !pstr )
    {
        pstr = "UNKNOWN";
    }
    return  pstr;
}



PCHAR
Dns_RecordStringForWritableType(
    IN      WORD            wType
    )
/*++

Routine Description:

    Retrieve RR string corresponding to the RR type -- ONLY if writable type.

Arguments:

    wType -- RR type in net byte order

Return Value:

    Ptr to RR mneumonic string.
    NULL if unknown RR type.

--*/
{
    //
    //  eliminate all supported types that are NOT writable
    //
    //  DCR:  should have writeability screen
    //      this misses OPT ... then QUERY types
    //

    if ( wType == DNS_TYPE_ZERO ||
         wType == DNS_TYPE_NULL ||
         wType == DNS_TYPE_OPT  ||
         (wType >= LOW_QUERY_TYPE && wType <= DNS_TYPE_ALL) )
    {
        return( NULL );
    }

    //
    //  otherwise return type string
    //  string is NULL if type is unknown
    //

    return( private_StringForRecordType(wType) );
}





BOOL
Dns_WriteStringForType_A(
    OUT     PCHAR           pBuffer,
    IN      WORD            wType
    )
/*++

Routine Description:

    Write type name string for type.

Arguments:

    wType -- RR type in net byte order

Return Value:

    TRUE if found string.
    FALSE if converted type numerically.

--*/
{
    PSTR    pstr;

    pstr = private_StringForRecordType( wType );
    if ( pstr )
    {
        strcpy( pBuffer, pstr );
    }
    else
    {
        sprintf( pBuffer, "%u", wType );
    }
    return  pstr ? TRUE : FALSE;
}


BOOL
Dns_WriteStringForType_W(
    OUT     PWCHAR          pBuffer,
    IN      WORD            wType
    )
{
    PSTR    pstr;

    pstr = private_StringForRecordType( wType );
    if ( pstr )
    {
        swprintf( pBuffer, L"%S", pstr );
    }
    else
    {
        swprintf( pBuffer, L"%u", wType );
    }
    return  pstr ? TRUE : FALSE;
}



BOOL
_fastcall
Dns_IsAMailboxType(
    IN      WORD            wType
    )
{
    return( wType == DNS_TYPE_MB ||
            wType == DNS_TYPE_MG ||
            wType == DNS_TYPE_MR );
}


BOOL
_fastcall
Dns_IsUpdateType(
    IN      WORD            wType
    )
{
    return( wType != 0 &&
            ( wType < DNS_TYPE_OPT ||
              (wType < DNS_TYPE_ADDRS && wType != DNS_TYPE_OPT) ) );
}



//
//  RPC-able record types
//

BOOL IsRpcTypeTable[] =
{
    0,      //  ZERO
    1,      //  A      
    1,      //  NS     
    1,      //  MD     
    1,      //  MF     
    1,      //  CNAME  
    1,      //  SOA    
    1,      //  MB     
    1,      //  MG     
    1,      //  MR     
    0,      //  NULL   
    0,      //  WKS    
    1,      //  PTR    
    0,      //  HINFO  
    1,      //  MINFO  
    1,      //  MX     
    0,      //  TXT

    1,      //  RP     
    1,      //  AFSDB  
    0,      //  X25    
    0,      //  ISDN   
    0,      //  RT

    0,      //  NSAP   
    0,      //  NSAPPTR
    0,      //  SIG    
    0,      //  KEY    
    0,      //  PX     
    0,      //  GPOS   
    1,      //  AAAA   
    0,      //  LOC    
    0,      //  NXT

    0,      //  EID    
    0,      //  NIMLOC 
    1,      //  SRV    
    1,      //  ATMA   
    0,      //  NAPTR  
    0,      //  KX     
    0,      //  CERT   
    0,      //  A6     
    0,      //  DNAME  
    0,      //  SINK   
    0,      //  OPT    
    0,      //  42     
    0,      //  43     
    0,      //  44     
    0,      //  45     
    0,      //  46     
    0,      //  47     
    0,      //  48     
};



BOOL
Dns_IsRpcRecordType(
    IN      WORD            wType
    )
/*++

Routine Description:

    Check if valid to RPC records of this type.

    MIDL compiler has problem with a union of types of varying
    length (no clue why -- i can write the code).  This function
    allows us to screen them out.

Arguments:

    wType -- type to check

Return Value:

    None

--*/
{
    if ( wType < MAX_SELF_INDEXED_TYPE )
    {
        return  IsRpcTypeTable[ wType ];
    }
    else
    {
        return  FALSE;
    }
}



//
//  RR type specific conversions
//

//
//  Text string type routine
//

BOOL
Dns_IsStringCountValidForTextType(
    IN      WORD            wType,
    IN      WORD            StringCount
    )
/*++

Routine Description:

    Verify a valid count of strings for the particular text
    string type.

    HINFO   -- 2
    ISDN    -- 1 or 2
    TXT     -- any number
    X25     -- 1

Arguments:

    wType -- type

    StringCount -- count of strings

Return Value:

    TRUE if string count is acceptable for type.
    FALSE otherwise.

--*/
{
    switch ( wType )
    {
    case DNS_TYPE_HINFO:

        return ( StringCount == 2 );

    case DNS_TYPE_ISDN:

        return ( StringCount == 1 || StringCount == 2 );

    case DNS_TYPE_X25:

        return ( StringCount == 1 );

    default:

        return( TRUE );
    }
}



//
//  WINS flag table
//
//  Associates a WINS flag with the string used for it in database
//  files.
//

DNS_FLAG_TABLE_ENTRY   WinsFlagTable[] =
{
    //  value               mask                    string

    DNS_WINS_FLAG_SCOPE,    DNS_WINS_FLAG_SCOPE,    "SCOPE",
    DNS_WINS_FLAG_LOCAL,    DNS_WINS_FLAG_LOCAL,    "LOCAL",
    0                  ,    0                  ,    NULL
};


DWORD
Dns_WinsRecordFlagForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    )
/*++

Routine Description:

    Retrieve WINS mapping flag corresponding to string.

Arguments:

    pchName - ptr to string
    cchNameLength - length of string

Return Value:

     flag corresponding to string, if found.
     WINS_FLAG_ERROR otherwise.

--*/
{
    return  Dns_FlagForString(
                WinsFlagTable,
                TRUE,               // ignore case
                pchName,
                cchNameLength );
}



PCHAR
Dns_WinsRecordFlagString(
    IN      DWORD           dwFlag,
    IN OUT  PCHAR           pchFlag
    )
/*++

Routine Description:

    Retrieve string corresponding to a given mapping type.

Arguments:

    dwFlag -- WINS mapping type string

    pchFlag -- buffer to write flag to

Return Value:

    Ptr to mapping mneumonic string.
    NULL if unknown mapping type.

--*/
{
    return  Dns_WriteStringsForFlag(
                WinsFlagTable,
                dwFlag,
                pchFlag );
}



//
//  WKS record conversions
//

#if 0
PCHAR
Dns_GetWksServicesString(
    IN      INT     Protocol,
    IN      PBYTE   ServicesBitmask,
    IN      WORD    wBitmaskLength
    )
/*++

Routine Description:

    Get list of services in WKS record.

Arguments:

    pRR - flat WKS record being written

Return Value:

    Ptr to services string, caller MUST free.
    NULL on error.

--*/
{
    struct servent *    pServent;
    struct protoent *   pProtoent;
    INT         i;
    DWORD       length;
    USHORT      port;
    UCHAR       portBitmask;
    CHAR        buffer[ WKS_SERVICES_BUFFER_SIZE ];
    PCHAR       pch = buffer;
    PCHAR       pchstart;
    PCHAR       pchstop;

    //  protocol

    pProtoent = getprotobynumber( iProtocol );
    if ( ! pProtoent )
    {
        DNS_PRINT((
            "ERROR:  Unable to find protocol %d, writing WKS record.\n",
            (INT) pRR->Data.WKS.chProtocol
            ));
        return( NULL );
    }

    //
    //  services
    //
    //  find each bit set in bitmask, lookup and write service
    //  corresponding to that port
    //
    //  note, that since that port zero is the front of port bitmask,
    //  lowest ports are the highest bits in each byte
    //

    pchstart = pch;
    pchstop = pch + WKS_SERVICES_BUFFER_SIZE;

    for ( i = 0;
            i < wBitmaskLength
                i++ )
    {
        portBitmask = (UCHAR) ServicesBitmask[i];

        port = i * 8;

        //  write service name for each bit set in byte
        //      - get out as soon byte is empty of ports
        //      - terminate each name with blank (until last)

        while ( bBitmask )
        {
            if ( bBitmask & 0x80 )
            {
                pServent = getservbyport(
                                (INT) htons(port),
                                pProtoent->p_name );

                if ( pServent )
                {
                    INT copyCount = strlen(pServent->s_name);

                    pch++;
                    if ( pchstop - pch <= copyCount+1 )
                    {
                        return( NULL );
                    }
                    RtlCopyMemory(
                        pch,
                        pServent->s_name,
                        copyCount );
                    pch += copyCount;
                    *pch = ' ';
                }
                else
                {
                    DNS_PRINT((
                        "ERROR:  Unable to find service for port %d, "
                        "writing WKS record.\n",
                        port
                        ));
                    pch += sprintf( pch, "%d", port );
                }
            }
            port++;           // next service port
            bBitmask <<= 1;     // shift mask up to read next port
        }
    }

    //  NULL terminate services string
    //  and determine length

    *pch++ = 0;
    length = pch - pchstart;

    //  allocate copy of this string

    pch = ALLOCATE_HEAP( length );
    if ( !pch )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    RtlCopyMemory(
        pch,
        pchstart,
        length );

    return( pch );
}

#endif


#if 0
DNS_STATUS
Dns_WksRecordToStrings(
    IN      PDNS_WKS_DATA   pWksData,
    IN      WORD            wLength,
    OUT     LPSTR *         ppszIpAddress,
    OUT     LPSTR *         ppszProtocol,
    OUT     LPSTR *         ppszServices
    )
/*++

Routine Description:

    Get string representation of WKS data.

Arguments:

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    //
    //  record must contain IP and protocol
    //

    if ( wLength < SIZEOF_WKS_FIXED_DATA )
    {
        return( ERROR_INVALID_DATA );
    }

    //
    //  convert IP
    //

    if ( ppszIpAddress )
    {
        LPSTR   pszip;

        pszip = ALLOCATE_HEAP( IP_ADDRESS_STRING_LENGTH+1 );
        if ( ! pszip )
        {
            return( GetLastError() );
        }
        strcpy( pszip, IP4_STRING( pWksData->ipAddress ) );
    }

    //
    //  convert protocol
    //

    pProtoent = getprotobyname( pszNameBuffer );

    if ( ! pProtoent || pProtoent->p_proto >= MAXUCHAR )
    {
        dns_LogFileParsingError(
            DNS_EVENT_UNKNOWN_PROTOCOL,
            pParseInfo,
            Argv );
        return( DNS_ERROR_INVALID_TOKEN );
    }

    //
    //  get port for each service
    //      - if digit, then use port number
    //      - if not digit, then service name
    //      - save max port for determining RR length
    //

    for ( i=1; i<Argc; i++ )
    {
        if ( dns_ParseDwordToken(
                    & portDword,
                    & Argv[i],
                    NULL ) )
        {
            if ( portDword > MAXWORD )
            {
                return( DNS_ERROR_INVALID_TOKEN );
            }
            port = (WORD) portDword;
        }
        else
        {
            if ( ! dns_MakeTokenString(
                        pszNameBuffer,
                        & Argv[i],
                        pParseInfo ) )
            {
                return( DNS_ERROR_INVALID_TOKEN );
            }
            pServent = getservbyname(
                            pszNameBuffer,
                            pProtoent->p_name );
            if ( ! pServent )
            {
                dns_LogFileParsingError(
                    DNS_EVENT_UNKNOWN_SERVICE,
                    pParseInfo,
                    & Argv[i] );
                return( DNS_ERROR_INVALID_TOKEN );
            }
            port = ntohs( pServent->s_port );
        }

        portArray[ i ] = port;
        if ( port > maxPort )
        {
            maxPort = port;
        }
    }

    //
    //  allocate required length
    //      - fixed length, plus bitmask covering max port
    //

    wbitmaskLength = maxPort/8 + 1;

    prr = RRecordAllocate(
                (WORD)(SIZEOF_WKS_FIXED_DATA + wbitmaskLength) );
    if ( !prr )
    {
        return( DNS_ERROR_NO_MEMORY );
    }

    //
    //  copy fixed fields -- IP and protocol
    //

    prr->Data.WKS.ipAddress = ipAddress;
    prr->Data.WKS.chProtocol = (UCHAR) pProtoent->p_proto;

    //
    //  build bitmask from port array
    //      - clear port array first
    //
    //  note that bitmask is just flat run of bits
    //  hence lowest port in byte, corresponds to highest bit
    //  highest port in byte, corresponds to lowest bit and
    //  requires no shift
    //

    bitmaskBytes = prr->Data.WKS.bBitMask;

    RtlZeroMemory(
        bitmaskBytes,
        (size_t) wbitmaskLength );

    for ( i=1; i<Argc; i++ )
    {
        port = portArray[ i ];
        bit  = port & 0x7;      // mod 8
        port = port >> 3;       // divide by 8
        bitmaskBytes[ port ] |= 1 << (7-bit);
    }

    //  return ptr to new WKS record

    *ppRR = prr;

    return( ERROR_SUCCESS );
}

#endif



//
//  Security KEY\SIG record routines
//

#define DNSSEC_ERROR_NOSTRING   (-1)


//
//  KEY flags table
//
//  Note that number-to-string mapping is NOT UNIQUE.
//  Zero is in the table a few times are multiple bit fields may have a
//  zero value which is given a particular mnemonic.
//

DNS_FLAG_TABLE_ENTRY   KeyFlagTable[] =
{
    //  value      mask     string

    0x0001,     0x0001,     "NOAUTH",
    0x0002,     0x0002,     "NOCONF",
    0x0004,     0x0004,     "FLAG2",
    0x0008,     0x0008,     "EXTEND",

    0x0010,     0x0010,     "FLAG4",
    0x0020,     0x0020,     "FLAG5",

    //  bits 6,7//  bits 6,7 are name type

    0x0000,     0x00c0,     "USER",
    0x0040,     0x00c0,     "ZONE",
    0x0080,     0x00c0,     "HOST",
    0x00c0,     0x00c0,     "NTPE3",

    //  bits 8-1//  bits 8-11 are reserved for future use

    0x0100,     0x0100,     "FLAG8",
    0x0200,     0x0200,     "FLAG9",
    0x0400,     0x0400,     "FLAG10",
    0x0800,     0x0800,     "FLAG11",

    //  bits 12-//  bits 12-15 are sig field

    0x0000,     0xf000,     "SIG0",
    0x1000,     0xf000,     "SIG1",
    0x2000,     0xf000,     "SIG2",
    0x3000,     0xf000,     "SIG3",
    0x4000,     0xf000,     "SIG4",
    0x5000,     0xf000,     "SIG5",
    0x6000,     0xf000,     "SIG6",
    0x7000,     0xf000,     "SIG7",
    0x8000,     0xf000,     "SIG8",
    0x9000,     0xf000,     "SIG9",
    0xa000,     0xf000,     "SIG10",
    0xb000,     0xf000,     "SIG11",
    0xc000,     0xf000,     "SIG12",
    0xd000,     0xf000,     "SIG13",
    0xe000,     0xf000,     "SIG14",
    0xf000,     0xf000,     "SIG15",

    0     ,     0     ,     NULL
};

//
//  KEY protocol table
//

DNS_VALUE_TABLE_ENTRY   KeyProtocolTable[] =
{
    0,      "NONE"      ,
    1,      "TLS"       ,
    2,      "EMAIL"     ,
    3,      "DNSSEC"    ,
    4,      "IPSEC"     ,
    0,      NULL
};

//
//  Security alogrithm table
//

DNS_VALUE_TABLE_ENTRY   DnssecAlgorithmTable[] =
{
    1,      "RSA/MD5"           ,
    2,      "DIFFIE-HELLMAN"    ,
    3,      "DSA"               ,
    253,    "NULL"              ,
    254,    "PRIVATE"           ,
    0,      NULL
};




WORD
Dns_KeyRecordFlagForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    )
/*++

Routine Description:

    Retrieve KEY record flag corresponding to a particular
    string mnemonics.

Arguments:

    pchName - ptr to string
    cchNameLength - length of string

Return Value:

    flag corresponding to string, if found.
    DNSSEC_ERROR_NOSTRING otherwise.

--*/
{
    return (WORD) Dns_FlagForString(
                    KeyFlagTable,
                    FALSE,          // case sensitive (all upcase)
                    pchName,
                    cchNameLength );
}



PCHAR
Dns_KeyRecordFlagString(
    IN      DWORD           dwFlag,
    IN OUT  PCHAR           pchFlag
    )
/*++

Routine Description:

    Write mnemonics corresponding to string.

Arguments:

    dwFlag -- KEY mapping type string

    pchFlag -- buffer to write flag to

Return Value:

    Ptr to mapping mneumonic string.
    NULL if unknown mapping type.

--*/
{
    return Dns_WriteStringsForFlag(
                KeyFlagTable,
                dwFlag,
                pchFlag );
}






UCHAR
Dns_KeyRecordProtocolForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    )
/*++

Routine Description:

    Retrieve KEY record protocol for string.

Arguments:

    pchName - ptr to string
    cchNameLength - length of string

Return Value:

    Protocol value corresponding to string, if found.
    DNSSEC_ERROR_NOSTRING otherwise.

--*/
{
    return (UCHAR) Dns_ValueForString(
                        KeyProtocolTable,
                        FALSE,          // case sensitive (all upcase)
                        pchName,
                        cchNameLength );
}



PCHAR
Dns_GetKeyProtocolString(
    IN      UCHAR           uchProtocol
    )
/*++

Routine Description:

    Retrieve KEY protocol string for protocol.

Arguments:

    dwProtocol  - KEY protocol to map to string

Return Value:

    Ptr to protocol mneumonic for string.
    NULL if unknown protocol.

--*/
{
    return Dns_GetStringForValue(
                KeyProtocolTable,
                (DWORD) uchProtocol );
}




UCHAR
Dns_SecurityAlgorithmForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    )
/*++

Routine Description:

    Retrieve DNSSEC algorithm for string.

Arguments:

    pchName - ptr to string
    cchNameLength - length of string

Return Value:

    Algorithm value corresponding to string, if found.
    DNSSEC_ERROR_NOSTRING otherwise.

--*/
{
    return (UCHAR) Dns_ValueForString(
                        DnssecAlgorithmTable,
                        FALSE,          // case sensitive (all upcase)
                        pchName,
                        cchNameLength );
}



PCHAR
Dns_GetDnssecAlgorithmString(
    IN      UCHAR           uchAlgorithm
    )
/*++

Routine Description:

    Retrieve DNSSEC algorithm string.

Arguments:

    dwAlgorithm  -  security alogorithm to map to string

Return Value:

    Ptr to algorithm string if found.
    NULL if unknown algorithm.

--*/
{
    return Dns_GetStringForValue(
                DnssecAlgorithmTable,
                (DWORD) uchAlgorithm );
}



//
//  Security base64 conversions.
//
//  Keys and signatures are represented in base 64 mapping for human use.
//  (Why?  Why not just use give the hex representation?
//  All this for 33% compression -- amazing.)
//

#if 0
//  forward lookup table doesn't buy much, simple function actually smaller
//  and not much slower

UCHAR   DnsSecurityBase64Mapping[] =
{
    // 0-31 unprintable

    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,

    //  '0' - '9' map

    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   62,         // '+' => 62
    0xff,   0xff,   0xff,   63,         // '/' => 63
    52,     53,     54,     55,         // 0-9 map to 52-61
    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,
    0xff,   0xff,   0xff,   0xff,
}
#endif


//
//  Security KEY, SIG 6-bit values to base64 character mapping
//

CHAR  DnsSecurityBase64Mapping[] =
{
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H',
    'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P',
    'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X',
    'Y', 'Z', 'a', 'b', 'c', 'd', 'e', 'f',
    'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n',
    'o', 'p', 'q', 'r', 's', 't', 'u', 'v',
    'w', 'x', 'y', 'z', '0', '1', '2', '3',
    '4', '5', '6', '7', '8', '9', '+', '/'
};

#define SECURITY_PAD_CHAR   ('=')



UCHAR
Dns_SecurityBase64CharToBits(
    IN      CHAR            ch64
    )
/*++

Routine Description:

    Get value of security base64 character.

Arguments:

    ch64 -- character in security base64

Return Value:

    Value of character, only low 6-bits are significant, high bits zero.
    (-1) if not a base64 character.

--*/
{
    //  A - Z map to 0 -25
    //  a - z map to 26-51
    //  0 - 9 map to 52-61
    //  + is 62
    //  / is 63

    //  could do a lookup table
    //  since we can in general complete mapping with an average of three
    //  comparisons, just encode

    if ( ch64 >= 'a' )
    {
        if ( ch64 <= 'z' )
        {
            return( ch64 - 'a' + 26 );
        }
    }
    else if ( ch64 >= 'A' )
    {
        if ( ch64 <= 'Z' )
        {
            return( ch64 - 'A' );
        }
    }
    else if ( ch64 >= '0')
    {
        if ( ch64 <= '9' )
        {
            return( ch64 - '0' + 52 );
        }
        else if ( ch64 == '=' )
        {
            //*pPadCount++;
            return( 0 );
        }
    }
    else if ( ch64 == '+' )
    {
        return( 62 );
    }
    else if ( ch64 == '/' )
    {
        return( 63 );
    }

    //  all misses fall here

    return (UCHAR)(-1);
}



DNS_STATUS
Dns_SecurityBase64StringToKey(
    OUT     PBYTE           pKey,
    OUT     PDWORD          pKeyLength,
    IN      PCHAR           pchString,
    IN      DWORD           cchLength
    )
/*++

Routine Description:

    Write base64 representation of key to buffer.

Arguments:

    pchString   - base64 string to write

    cchLength   - length of string

    pKey        - ptr to key to write

Return Value:

    None

--*/
{
    DWORD   blend = 0;
    DWORD   index = 0;
    UCHAR   bits;
    PBYTE   pkeyStart = pKey;

    //
    //  Mapping is essentially in 24 bit quantums.
    //  Take 4 characters of string key and convert to 3 bytes of binary key.
    //

    while ( cchLength-- )
    {
        bits = Dns_SecurityBase64CharToBits( *pchString++ );
        if ( bits >= 64 )
        {
            return ERROR_INVALID_PARAMETER;
        }
        blend <<= 6;
        blend |= bits;
        index++;

        if ( index == 4 )
        {
            index = 0;

            //
            //  The first byte of key is top 8 bits of the 24 bit quantum.
            //

            *pKey++ = ( UCHAR ) ( ( blend & 0x00ff0000 ) >> 16 );

            if ( cchLength || *( pchString - 1 ) != SECURITY_PAD_CHAR )
            {
                //
                //  There is no padding so the next two bytes of key
                //  are bottom 16 bits of the 24 bit quantum. 
                //

                *pKey++ = ( UCHAR ) ( ( blend & 0x0000ff00 ) >> 8 );
                *pKey++ = ( UCHAR ) ( blend & 0x000000ff );
            }
            else if ( *( pchString - 2 ) != SECURITY_PAD_CHAR )
            {
                //
                //  There is one pad character, so we need to get one
                //  more byte of key out of the 24 bit quantum. Make sure
                //  that there are no one bits in the bottom 8 bits of the
                //  quantum.
                //

                if ( blend & 0x000000ff )
                {
                    return ERROR_INVALID_PARAMETER;
                }
                *pKey++ = ( UCHAR ) ( ( blend & 0x0000ff00 ) >> 8 );
            }
            else
            {
                //
                //  There are two pad characters. Make sure that there
                //  are no one bits in the bottom 16 bits of the quantum.
                //
                
                if ( blend & 0x0000ffff )
                {
                    return ERROR_INVALID_PARAMETER;
                }
            }
            blend = 0;
        }
    }

    //
    //  Base64 representation should always be padded out to an even
    //  multiple of 4 characters.
    //

    if ( index == 0 )
    {
        //
        //  Key length does not include padding.
        //

        *pKeyLength = ( DWORD ) ( pKey - pkeyStart );
        return ERROR_SUCCESS;
    }
    return ERROR_INVALID_PARAMETER;
}



PCHAR
Dns_SecurityKeyToBase64String(
    IN      PBYTE           pKey,
    IN      DWORD           KeyLength,
    OUT     PCHAR           pchBuffer
    )
/*++

Routine Description:

    Write base64 representation of key to buffer.

Arguments:

    pKey        - ptr to key to write

    KeyLength   - length of key in bytes

    pchBuffer   - buffer to write to (must be adequate for key length)

Return Value:

    Ptr to next byte in buffer after string.

--*/
{
    DWORD   blend = 0;
    DWORD   index = 0;

    //
    //  mapping is essentially in 24bit blocks
    //  read three bytes of key and transform into four 64bit characters
    //

    while ( KeyLength-- )
    {
        blend <<= 8;
        blend += *pKey++;
        index++;

        if ( index == 3 )
        {
            *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x00fc0000) >> 18 ];
            *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x0003f000) >> 12 ];
            *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x00000fc0) >> 6 ];
            *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x0000003f) ];
            blend = 0;
            index = 0;
        }
    }

    //
    //  key terminates on byte boundary, but not necessarily 24bit block boundary
    //  shift to fill 24bit block filling with zeros
    //  if two bytes written
    //          => write three 6-bits chars and one pad
    //  if one byte written
    //          => write two 6-bits chars and two pads
    //

    if ( index )
    {
        blend <<= (8 * (3-index));

        *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x00fc0000) >> 18 ];
        *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x0003f000) >> 12 ];
        if ( index == 2 )
        {
            *pchBuffer++ = DnsSecurityBase64Mapping[ (blend & 0x00000fc0) >> 6 ];
        }
        else
        {
            *pchBuffer++ = SECURITY_PAD_CHAR;
        }
        *pchBuffer++ = SECURITY_PAD_CHAR;
    }

    return( pchBuffer );
}



//
//  Hex digit \ Hex char mapping.
//
//  This stuff ought to be in system (CRTs) somewhere but apparently isn't.
//

UCHAR  HexCharToHexDigitTable[] =
{
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,     // 0-47 invalid
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0x0,  0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,     // 0-9 chars map to 0-9
    0x08, 0x09, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

    0xff, 0xa,  0xb,  0xc,  0xd,  0xe,  0xf,  0xff,     // A-F chars map to 10-15
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

    0xff, 0xa,  0xb,  0xc,  0xd,  0xe,  0xf,  0xff,     // a-f chars map to 10-15
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,

    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,     // above 127 invalid
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
};

UCHAR  HexDigitToHexCharTable[] =
{
    '0',    '1',    '2',    '3',
    '4',    '5',    '6',    '7',
    '8',    '9',    'a',    'b',
    'c',    'd',    'e',    'f'
};


#define HexCharToHexDigit(_ch)      ( HexCharToHexDigitTable[(_ch)] )
#define HexDigitToHexChar(_d)       ( HexDigitToHexCharTable[(_d)] )





time_t
makeGMT(
    IN      struct tm *     tm
    )
/*++

Routine Description:

    This function is like mktime for GMT times. The CRT is missing such
    a function, unfortunately. Which is weird, because it does provide
    gmtime() for the reverse conversion.

    //
    //  DCR:  add makeGMT() to CRT dll?
    //

Arguments:

    tm - ptr to tm struct (tm_dst, tm_yday, tm_wday are all ignored)

Return Value:

    Returns the time_t corresponding to the time in the tm struct,
    assuming GMT.

--*/
{
    static const int daysInMonth[ 12 ] =
        { 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 };

    time_t      gmt = 0;
    int         i;
    int         j;

    #define IS_LEAP_YEAR(x) \
                    (( ((x)%4)==0 && ((x)%100)!=0 ) || ((x)%400)==0 )
    #define SECONDS_PER_DAY (60*60*24)

    //
    //  Years
    //

    j = 0;
    for ( i = 70; i < tm->tm_year; i++ )
    {
        // j += IS_LEAP_YEAR( 1900 + i ) ? 366 : 365;  // Days in year.
        if ( IS_LEAP_YEAR( 1900 + i ) )
            j += 366;  // Days in year.
        else
            j += 365;  // Days in year.
    }
    gmt += j * SECONDS_PER_DAY;

    //
    //  Months
    //

    j = 0;
    for ( i = 0; i < tm->tm_mon; i++ )
    {
        j += daysInMonth[ i ];      // Days in month.
        if ( i == 1 && IS_LEAP_YEAR( 1900 + tm->tm_year ) )
        {
            ++j;                    // Add February 29.
        }
    }
    gmt += j * SECONDS_PER_DAY;

    //
    //  Days, hours, minutes, seconds
    //

    gmt += ( tm->tm_mday - 1 ) * SECONDS_PER_DAY;
    gmt += tm->tm_hour * 60 * 60;
    gmt += tm->tm_min * 60;
    gmt += tm->tm_sec;

    return gmt;
}

        

LONG
Dns_ParseSigTime(
    IN      PCHAR           pTimeString,
    IN      INT             cchLength
    )
/*++

Routine Description:

    Parse time string into a time_t value. The time string will be in
    the format: YYYYMMDDHHMMSS. See RFC2535 section 7.2.

    It is assumed that the time is GMT, not local time, but I have not
    found this in an RFC or other document (it just makes sense).

Arguments:

    pTimeString - pointer to time string

    cchLength - length of time string

Return Value:

    Returns -1 on failure.

--*/
{
    time_t      timeValue = -1;
    struct tm   t = { 0 };
    CHAR        szVal[ 10 ];
    PCHAR       pch = pTimeString;

    if ( cchLength == 0 )
    {
        cchLength = strlen( pch );
    }

    if ( cchLength != 14 )
    {
        goto Cleanup;
    }

    RtlCopyMemory( szVal, pch, 4 );
    szVal[ 4 ] = '\0';
    t.tm_year = atoi( szVal ) - 1900;

    RtlCopyMemory( szVal, pch + 4, 2 );
    szVal[ 2 ] = '\0';
    t.tm_mon = atoi( szVal ) - 1;

    RtlCopyMemory( szVal, pch + 6, 2 );
    t.tm_mday = atoi( szVal );

    RtlCopyMemory( szVal, pch + 8, 2 );
    t.tm_hour = atoi( szVal );

    RtlCopyMemory( szVal, pch + 10, 2 );
    t.tm_min = atoi( szVal );

    RtlCopyMemory( szVal, pch + 12, 2 );
    t.tm_sec = atoi( szVal );

    timeValue = makeGMT( &t );

    Cleanup:

    return ( LONG ) timeValue;
} // Dns_ParseSigTime



PCHAR
Dns_SigTimeString(
    IN      LONG            SigTime,
    OUT     PCHAR           pchBuffer
   )
/*++

Routine Description:

    Formats the input time in the buffer in YYYYMMDDHHMMSS format. 

    See RFC 2535 section 7.2 for spec.

Arguments:

    SigTime - time to convert to string format in HOST byte order
    pchBuffer - output buffer - must be 15 chars minimum

Return Value:

    pchBuffer

--*/
{
    time_t          st = SigTime;
    struct tm *     t;

    t = gmtime( &st );
    if ( !t )
    {
        *pchBuffer = '\0';
        goto Cleanup;
    }
    sprintf(
        pchBuffer,
        "%04d%02d%02d%02d%02d%02d",
        t->tm_year + 1900,
        t->tm_mon + 1,
        t->tm_mday,
        t->tm_hour,
        t->tm_min,
        t->tm_sec );

    Cleanup:

    return pchBuffer;
} // SigTimeString
                


//
//  ATMA record conversions
//

#define ATMA_AESA_HEX_DIGIT_COUNT   (40)
#define ATMA_AESA_RECORD_LENGTH     (21)


DWORD
Dns_AtmaAddressLengthForAddressString(
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    )
/*++

Routine Description:

    Find length of ATMA address corresponding to ATMA address string.

Arguments:

    pchString       - address string

    dwStringLength  - address string length

Return Value:

    Length of ATMA address -- includes the format\type byte.
    Non-zero value indicates successful conversion.
    Zero indicates bad address string.

--*/
{
    PCHAR   pchstringEnd;
    DWORD   length = 0;
    UCHAR   ch;

    DNSDBG( PARSE2, (
        "Dns_AtmaLengthForAddressString()\n"
        "\tpchString = %p\n",
        dwStringLength,
        pchString,
        pchString ));

    //
    //  get string length if not given
    //

    if ( ! dwStringLength )
    {
        dwStringLength = strlen( pchString );
    }
    pchstringEnd = pchString + dwStringLength;

    //
    //  get address length
    //
    //  E164 type
    //      ex.  +358.400.1234567
    //      - '+' to indicate E164
    //      - chars map one-to-one into address
    //      - arbitrarily placed "." separators
    //

    if ( *pchString == '+' )
    {
        pchString++;
        length++;

        while( pchString < pchstringEnd )
        {
            if ( *pchString++ != '.' )
            {
                length++;
            }
        }
        return( length );
    }

    //
    //  AESA type
    //      ex. 39.246f.123456789abcdef0123.00123456789a.00
    //      - 40 hex digits, mapping to 20 bytes
    //      - arbitrarily placed "." separators
    //

    else    // AESA format
    {
        while( pchString < pchstringEnd )
        {
            ch = *pchString++;

            if ( ch != '.' )
            {
                ch = HexCharToHexDigit(ch);
                if ( ch > 0xf )
                {
                    //  bad hex digit
                    DNSDBG( PARSE2, (
                        "ERROR:  Parsing ATMA AESA address;\n"
                        "\tch = %c not hex digit\n",
                        *(pchString-1) ));
                    return( 0 );
                }
                length++;
            }
        }

        if ( length == ATMA_AESA_HEX_DIGIT_COUNT )
        {
            return ATMA_AESA_RECORD_LENGTH;
        }
        DNSDBG( PARSE2, (
            "ERROR:  Parsing ATMA AESA address;\n"
            "\tinvalid length = %d\n",
            length ));
        return( 0 );    // bad digit count
    }
}



DNS_STATUS
Dns_AtmaStringToAddress(
    OUT     PBYTE           pAddress,
    IN OUT  PDWORD          pdwAddrLength,
    IN      PCHAR           pchString,
    IN      DWORD           dwStringLength
    )
/*++

Routine Description:

    Convert string to ATMA address.

Arguments:

    pAddress        - buffer to receive address

    pdwAddrLength   - ptr to DWORD holding buffer length (if MAX_DWORD) no length check

    pchString       - address string

    dwStringLength  - address string length

Return Value:

    ERROR_SUCCESS if converted
    ERROR_MORE_DATA if buffer too small.
    ERROR_INVALID_DATA on bum ATMA address string.

--*/
{
    UCHAR   ch;
    PCHAR   pch;
    PCHAR   pchstringEnd;
    DWORD   length;

    DNSDBG( PARSE2, (
        "Parsing ATMA address %.*s\n"
        "\tpchString = %p\n",
        dwStringLength,
        pchString,
        pchString ));

    //
    //  get string length if not given
    //

    if ( ! dwStringLength )
    {
        dwStringLength = strlen( pchString );
    }
    pchstringEnd = pchString + dwStringLength;

    //
    //  check for adequate length
    //
    //  DCR_PERF:  if have max length on ATMA, skip length check
    //      allow direct conversion, catching errors there
    //

    length = Dns_AtmaAddressLengthForAddressString(
                pchString,
                dwStringLength );
    if ( length == 0 )
    {
        return( ERROR_INVALID_DATA );
    }
    if ( length > *pdwAddrLength )
    {
        *pdwAddrLength = length;
        return( ERROR_MORE_DATA );
    }

    //
    //  read address into buffer
    //
    //  E164 type
    //      ex.  +358.400.1234567
    //      - '+' to indicate E164
    //      - chars map one-to-one into address
    //      - arbitrarily placed "." separators
    //

    pch = pAddress;

    if ( *pchString == '+' )
    {
        *pch++ = DNS_ATMA_FORMAT_E164;
        pchString++;

        while( pchString < pchstringEnd )
        {
            ch = *pchString++;
            if ( ch != '.' )
            {
                *pch++ = ch;
            }
        }
        ASSERT( pch == (PCHAR)pAddress + length );
    }

    //
    //  AESA type
    //      ex. 39.246f.123456789abcdef0123.00123456789a.00
    //      - 40 hex digits, mapping to 20 bytes
    //      - arbitrarily placed "." separators
    //

    else    // AESA format
    {
        BOOL    fodd = FALSE;

        *pch++ = DNS_ATMA_FORMAT_AESA;

        while( pchString < pchstringEnd )
        {
            ch = *pchString++;

            if ( ch != '.' )
            {
                ch = HexCharToHexDigit(ch);
                if ( ch > 0xf )
                {
                    ASSERT( FALSE );        // shouldn't hit with test above
                    return( ERROR_INVALID_DATA );
                }
                if ( !fodd )
                {
                    *pch = (ch << 4);
                    fodd = TRUE;
                }
                else
                {
                    *pch++ += ch;
                    fodd = FALSE;
                }
            }
        }
        ASSERT( !fodd );
        ASSERT( pch == (PCHAR)pAddress + length );
    }

    *pdwAddrLength = length;
    return( ERROR_SUCCESS );
}



PCHAR
Dns_AtmaAddressToString(
    OUT     PCHAR           pchString,
    IN      UCHAR           AddrType,
    IN      PBYTE           pAddress,
    IN      DWORD           dwAddrLength
    )
/*++

Routine Description:

    Convert ATMA address to string format.

Arguments:

    pchString -- buffer to hold string;  MUST be at least
        IPV6_ADDRESS_STRING_LENGTH+1 in length

    pAddress -- ATMA address to convert to string

    dwAddrLength -- length of address

Return Value:

    Ptr to next location in buffer (the terminating NULL).
    NULL on bogus ATM address.

--*/
{
    DWORD   count = 0;
    UCHAR   ch;
    UCHAR   lowDigit;

    //
    //  read address into buffer
    //
    //  E164 type
    //      ex.  +358.400.1234567
    //      - '+' to indicate E164
    //      - chars map one-to-one into address
    //      - arbitrarily placed "." separators
    //      -> write with separating dots after 3rd and 6th chars
    //

    if ( AddrType == DNS_ATMA_FORMAT_E164 )
    {
        *pchString++ = '+';

        while( count < dwAddrLength )
        {
            if ( count == 3 || count == 6 )
            {
                *pchString++ = '.';
            }
            *pchString++ = pAddress[count++];
        }
    }

    //
    //  AESA type
    //      ex. 39.246f.123456789abcdef0123.00123456789a.00
    //      - 40 hex digits, mapping to 20 bytes
    //      - arbitrarily placed "." separators
    //      -> write with separators after chars 1,3,13,19
    //          (hex digits 2,6,26,38)
    //

    else if ( AddrType == DNS_ATMA_FORMAT_AESA )
    {
        if ( dwAddrLength != DNS_ATMA_AESA_ADDR_LENGTH )
        {
            return( NULL );
        }

        while( count < dwAddrLength )
        {
            if ( count == 1 || count == 3 || count == 13 || count == 19 )
            {
                *pchString++ = '.';
            }
            ch = pAddress[count++];

            //  save low hex digit, then get and convert high digit

            lowDigit = ch & 0xf;
            ch >>= 4;
            *pchString++ = HexDigitToHexChar( ch );
            *pchString++ = HexDigitToHexChar( lowDigit );
        }
        //  could ASSERT here that have written exactly 44 chars
    }

    //  no other ATM address formats supported

    else
    {
        return( NULL );
    }

    *pchString = 0;             // NULL terminate
    return( pchString );
}


//
//  End record.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\memory.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    memory.c

Abstract:

    Domain Name System (DNS) Library

    Memory allocation routines for DNS library.

Author:

    Jim Gilroy (jamesg)    January, 1997

Revision History:

--*/


#include "local.h"


//
//  Memory allocation
//
//  Some DNS library functions -- including the IP array and string utils
//  -- allocate memory.  This memory allocation defaults to routines that
//  use LocalAlloc, LocalReAlloc, LocalFree.
//
//  Dns_Api.dll users can reset the memory allocation through
//  Dns_ApiHeapReset(), which saves pointers to remote allocation functions
//  which will override default allocators.
//

//
//  Allow overide of default memory allocation
//

DNSLIB_ALLOC_FUNCTION      pDnsAllocFunction = NULL;
DNSLIB_REALLOC_FUNCTION    pDnsReallocFunction = NULL;
DNSLIB_FREE_FUNCTION       pDnsFreeFunction = NULL;



VOID
Dns_LibHeapReset(
    IN  DNSLIB_ALLOC_FUNCTION      pAlloc,
    IN  DNSLIB_REALLOC_FUNCTION    pRealloc,
    IN  DNSLIB_FREE_FUNCTION       pFree
    )
/*++

Routine Description:

    Resets heap routines used by dnsapi.dll routines.

Arguments:

    pAlloc      -- ptr to desired alloc function
    pRealloc    -- ptr to desired realloc function
    pFree       -- ptr to desired free function

Return Value:

    None.

--*/
{
    pDnsAllocFunction = pAlloc;
    pDnsReallocFunction = pRealloc;
    pDnsFreeFunction = pFree;
}



//
//  Exported public memory routines.
//
//  These use whatever the current memory allocation routines are, and
//  hence will always handle memory in the same fashion as dnsapi.dll
//  internal routines.
//

PVOID
Dns_Alloc(
    IN  INT iSize
    )
/*++

Routine Description:

    Allocates memory.

Arguments:

    iSize   - number of bytes to allocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    if ( pDnsAllocFunction )
    {
        return (*pDnsAllocFunction)( iSize );
    }

    //  default

    return LocalAlloc( LPTR, iSize );
}



PVOID
Dns_Realloc(
    IN OUT  PVOID   pMem,
    IN      INT     iSize
    )
/*++

Routine Description:

    Reallocates memory

Arguments:

    pMem    - ptr to existing memory to reallocated
    iSize   - number of bytes to reallocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    if ( pDnsReallocFunction )
    {
        return (*pDnsReallocFunction)( pMem, iSize );
    }

    //  default

    return LocalReAlloc( pMem, iSize, 0 );
}



VOID
Dns_Free(
    IN OUT  PVOID   pMem
    )
/*++

Routine Description:

    Free memory

Arguments:

    pMem    - ptr to existing memory to reallocated

Return Value:

    None

--*/
{

    if ( !pMem )
    {
        return;
    }
    if ( pDnsFreeFunction )
    {
        (*pDnsFreeFunction)( pMem );
        return;
    }

    //  default

    LocalFree( pMem );
}



PVOID
Dns_AllocZero(
    IN      INT             iSize
    )
/*++

Routine Description:

    Allocates and zeros memory.

Arguments:

    iSize   - number of bytes to allocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    if ( pDnsAllocFunction )
    {
        PCHAR   ptr;

        ptr = (*pDnsAllocFunction)( iSize );
        if ( !ptr )
        {
            return( NULL );
        }
        RtlZeroMemory( ptr, iSize );
        return( ptr );
    }

    //  default

    return LocalAlloc( LPTR, iSize );
}




//
//  Helpful util
//

PVOID
Dns_AllocMemCopy(
    IN      PVOID           pMem,
    IN      INT             Size
    )
/*++

Routine Description:

    Allocates and copies memory

Arguments:

    pMem   - memory to copy

    Size   - number of bytes to allocate

Return Value:

    Pointer to memory allocated.
    NULL if allocation fails.

--*/
{
    PBYTE   ptr;

    ptr = Dns_Alloc( Size );

    if ( ptr )
    {
        if ( pMem )
        {
            RtlCopyMemory(
                ptr,
                pMem,
                Size );
        }
        else
        {
            RtlZeroMemory( ptr, Size );
        }
    }
    return  ptr;
}

//
//  End of memory.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\rralloc.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    rralloc.c

Abstract:

    Domain Name System (DNS) Library

    Resource record allocation \ creation routines.

Author:

    Jim Gilroy (jamesg)     January, 1997

Environment:

    User Mode - Win32

Revision History:

--*/


#include "local.h"

#define SET_FLAGS(Flags, value) \
            ( *(PWORD)&(Flags) = value )



PDNS_RECORD
WINAPI
Dns_AllocateRecord(
    IN      WORD            wBufferLength
    )
/*++

Routine Description:

    Allocate record structure.

Arguments:

    wBufferLength - desired buffer length (beyond structure header)

Return Value:

    Ptr to message buffer.
    NULL on error.

--*/
{
    PDNS_RECORD prr;

    prr = ALLOCATE_HEAP( SIZEOF_DNS_RECORD_HEADER + wBufferLength );
    if ( prr == NULL )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }
    RtlZeroMemory(
        prr,
        SIZEOF_DNS_RECORD_HEADER );

    //  as first cut, set datalength to buffer length

    prr->wDataLength = wBufferLength;
    return( prr );
}



VOID
WINAPI
Dns_RecordFree(
    IN OUT  PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Free a record

Arguments:

    pRecord -- record list to free

Return Value:

    None.

--*/
{
    DNSDBG( HEAP, ( "Dns_RecordFree( %p )\n", pRecord ));

    //  handle NULL for convenience

    if ( !pRecord )
    {
        return;
    }

    //  free owner name?

    if ( FLAG_FreeOwner( pRecord ) )
    {
        FREE_HEAP( pRecord->pName );
    }

    //
    //  free data -- but only if flag set
    //
    //  note:  even if we fix copy functions to do atomic
    //      allocations, we'll still have to have free to
    //      handle RPC allocations
    //      (unless we very cleverly, treated RPC as flat blob, then
    //      did fix up (to offsets before and afterward)
    //

    if ( FLAG_FreeData( pRecord ) )
    {
        switch( pRecord->wType )
        {
        case DNS_TYPE_A:
            break;

        case DNS_TYPE_PTR:
        case DNS_TYPE_NS:
        case DNS_TYPE_CNAME:
        case DNS_TYPE_MB:
        case DNS_TYPE_MD:
        case DNS_TYPE_MF:
        case DNS_TYPE_MG:
        case DNS_TYPE_MR:

            if ( pRecord->Data.PTR.pNameHost )
            {
                FREE_HEAP( pRecord->Data.PTR.pNameHost );
            }
            break;

        case DNS_TYPE_SOA:

            if ( pRecord->Data.SOA.pNamePrimaryServer )
            {
                FREE_HEAP( pRecord->Data.SOA.pNamePrimaryServer );
            }
            if ( pRecord->Data.SOA.pNameAdministrator )
            {
                FREE_HEAP( pRecord->Data.SOA.pNameAdministrator );
            }
            break;

        case DNS_TYPE_MINFO:
        case DNS_TYPE_RP:

            if ( pRecord->Data.MINFO.pNameMailbox )
            {
                FREE_HEAP( pRecord->Data.MINFO.pNameMailbox );
            }
            if ( pRecord->Data.MINFO.pNameErrorsMailbox )
            {
                FREE_HEAP( pRecord->Data.MINFO.pNameErrorsMailbox );
            }
            break;

        case DNS_TYPE_MX:
        case DNS_TYPE_AFSDB:
        case DNS_TYPE_RT:

            if ( pRecord->Data.MX.pNameExchange )
            {
                FREE_HEAP( pRecord->Data.MX.pNameExchange );
            }
            break;

        case DNS_TYPE_HINFO:
        case DNS_TYPE_ISDN:
        case DNS_TYPE_TEXT:
        case DNS_TYPE_X25:

            {
                DWORD   iter;
                DWORD   count = pRecord->Data.TXT.dwStringCount;

                for ( iter = 0; iter < count; iter++ )
                {
                    if ( pRecord->Data.TXT.pStringArray[iter] )
                    {
                        FREE_HEAP( pRecord->Data.TXT.pStringArray[iter] );
                    }
                }
                break;
            }

        case DNS_TYPE_SRV:

            if ( pRecord->Data.SRV.pNameTarget )
            {
                FREE_HEAP( pRecord->Data.SRV.pNameTarget );
            }
            break;

        case DNS_TYPE_WINSR:

            if ( pRecord->Data.WINSR.pNameResultDomain )
            {
                FREE_HEAP( pRecord->Data.WINSR.pNameResultDomain );
            }
            break;

        default:

            // other types -- A, AAAA, ATMA, WINS, NULL,
            // have no internal pointers

            break;
        }
    }

    //  for catching heap problems

    pRecord->pNext = DNS_BAD_PTR;
    pRecord->pName = DNS_BAD_PTR;

    FREE_HEAP( pRecord );
}



VOID
WINAPI
Dns_RecordListFree(
    IN OUT  PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Free list of records.

Arguments:

    pRecord -- record list to free

Return Value:

    None.

--*/
{
    PDNS_RECORD pnext;

    DNSDBG( TRACE, (
        "Dns_RecordListFree( %p )\n",
        pRecord ));

    //
    //  loop through and free every RR in list
    //

    while ( pRecord )
    {
        pnext = pRecord->pNext;

        Dns_RecordFree( pRecord );

        pRecord = pnext;
    }
}



VOID
WINAPI
Dns_RecordListFreeEx(
    IN OUT  PDNS_RECORD     pRecord,
    IN      BOOL            fFreeOwner
    )
/*++

Routine Description:

    Free list of records.

    DCR:  RecordListFreeEx  (no free owner option) is probably useless

    Note:  owner name is freed ONLY when indicated by flag;
        other ptrs are considered to be either
            1) internal as when records read from wire or copied
            2) external and to be freed by record creator

Arguments:

    pRecord -- record list to free

    fFreeOwner -- flag indicating owner name should be freed

Return Value:

    None.

--*/
{
    PDNS_RECORD pnext;

    DNSDBG( TRACE, (
        "Dns_RecordListFreeEx( %p, %d )\n",
        pRecord,
        fFreeOwner ));

    //
    //  loop through and free every RR in list
    //

    while ( pRecord )
    {
        pnext = pRecord->pNext;

        //  free owner name?
        //      - if "FreeOwner" flag NOT set, then don't free

        if ( !fFreeOwner )
        {
            FLAG_FreeOwner( pRecord ) = FALSE;
        }

        //  free record

        Dns_RecordFree( pRecord );

        pRecord = pnext;
    }
}



//
//  Special record type creation routines
//

PDNS_RECORD
CreateRecordBasic(
    IN      PDNS_NAME       pOwnerName,
    IN      BOOL            fCopyName,
    IN      WORD            wType,
    IN      WORD            wDataLength,
    IN      DWORD           AllocLength,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create record of arbitary type.

    Helper function to wrap up
        - record alloc
        - name alloc
        - basic setup

Arguments:

    pOwnerName -- owner name

    fCopyName -- TRUE - make copy of owner name
                 FALSE - use directly

    wType -- type

    AllocLength -- allocaction length, including any imbedded data

    wDataLength -- data length to set

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    PDNS_RECORD precord;
    PDNS_RECORD prr;
    PCHAR       pname;
    DWORD       bufLength;

    //
    //  alloc record
    //

    prr = Dns_AllocateRecord( (WORD)AllocLength );
    if ( !prr )
    {
        return( NULL );
    }

    //
    //  copy owner name
    //

    if ( fCopyName && pOwnerName )
    {
        pname = Dns_NameCopyAllocate(
                    pOwnerName,
                    0,              // length unknown
                    NameCharSet,
                    RecordCharSet );
        if ( !pname )
        {
            FREE_HEAP( prr );
            return( NULL );
        }
    }
    else
    {
        pname = pOwnerName;
    }
    
    //
    //  set fields
    //      - name, type and charset
    //      - TTL, section left zero
    //      - FreeData is specifically off
    //

    prr->pName = pname;
    prr->wType = wType;
    prr->wDataLength = wDataLength;
    SET_FREE_OWNER(prr);
    prr->Flags.S.CharSet = RecordCharSet;
    prr->dwTtl = Ttl;

    return( prr );
}



PDNS_RECORD
Dns_CreateFlatRecord(
    IN      PDNS_NAME       pOwnerName,
    IN      WORD            wType,
    IN      PCHAR           pData,
    IN      DWORD           DataLength,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create flat record.

Arguments:

    pOwnerName -- owner name

    wType -- record type

    pData -- ptr to data for record

    DataLength -- length (in bytes) of data

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    PDNS_RECORD prr;

    //
    //  determine record size
    //      - record buffer will include hostname
    //

    prr = CreateRecordBasic(
                pOwnerName,
                TRUE,               // copy name
                wType,
                (WORD) DataLength,  // datalength
                DataLength,         // alloc datalength
                Ttl,
                NameCharSet,
                RecordCharSet );
    if ( !prr )
    {
        return( NULL );
    }

    //
    //  copy in data
    //

    RtlCopyMemory(
        (PBYTE) &prr->Data,
        pData,
        DataLength );

    return( prr );
}



//
//  Reverse record creation
//

PDNS_RECORD
Dns_CreatePtrTypeRecord(
    IN      PDNS_NAME       pOwnerName,
    IN      BOOL            fCopyName,
    IN      PDNS_NAME       pTargetName,
    IN      WORD            wType,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create PTR type (single-indirection) record.

    This can be used to create any "PTR-type" record:
        PTR, CNAME, NS, etc.

Arguments:

    pOwnerName -- owner name

    fCopyName -- TRUE - make copy of owner name
                 FALSE - use directly

    pTargetName -- target name

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    PDNS_RECORD precord;
    PDNS_RECORD prr;
    PCHAR       pname;
    DWORD       bufLength;

    //
    //  determine record size
    //      - record buffer will include hostname
    //

    bufLength = Dns_GetBufferLengthForNameCopy(
                        pTargetName,
                        0,              // length unknown
                        NameCharSet,
                        RecordCharSet );
    if ( !bufLength )
    {
        return( NULL );
    }

    //
    //  create record
    //

    prr = CreateRecordBasic(
                pOwnerName,
                fCopyName,
                wType,
                sizeof(DNS_PTR_DATA),               // data length
                (sizeof(DNS_PTR_DATA) + bufLength), // alloc length
                Ttl,
                NameCharSet,
                RecordCharSet );
    if ( !prr )
    {
        return( NULL );
    }

    //
    //  write target name into buffer, immediately following PTR data struct
    //

    prr->Data.PTR.pNameHost = (PCHAR)&prr->Data + sizeof(DNS_PTR_DATA);

    Dns_NameCopy(
        prr->Data.PTR.pNameHost,
        NULL,
        pTargetName,
        0,
        NameCharSet,
        RecordCharSet
        );

    return( prr );
}



PDNS_RECORD
Dns_CreatePtrRecordEx(
    IN      PDNS_ADDR       pAddr,
    IN      PDNS_NAME       pszHostName,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create PTR record from IP address and hostname.

Arguments:

    pAddr -- addr (IP4 or IP6) to map into PTR

    pszHostName -- host name, FULL FQDN

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    PCHAR   pname = NULL;
    DWORD   family;

    //
    //  create reverse lookup name
    //      - note this is external allocation
    //

    family = DnsAddr_Family( pAddr );

    if ( family == AF_INET )
    {
        IP4_ADDRESS ip = DnsAddr_GetIp4(pAddr);

        if ( RecordCharSet == DnsCharSetUnicode )
        {
            pname = (PCHAR) Dns_Ip4AddressToReverseNameAlloc_W( ip );
        }
        else
        {
            pname = Dns_Ip4AddressToReverseNameAlloc_A( ip );
        }
    }
    else if ( family == AF_INET6 )
    {
        PIP6_ADDRESS  p6 = DnsAddr_GetIp6Ptr(pAddr);

        if ( RecordCharSet == DnsCharSetUnicode )
        {
            pname = (PCHAR) Dns_Ip6AddressToReverseNameAlloc_W( *p6 );
        }
        else
        {
            pname = Dns_Ip6AddressToReverseNameAlloc_A( *p6 );
        }
    }

    if ( !pname )
    {
        return( NULL );
    }

    //
    //  build record
    //

    return  Dns_CreatePtrTypeRecord(
                pname,
                FALSE,          // don't copy IP
                pszHostName,    // target name
                DNS_TYPE_PTR,
                Ttl,
                NameCharSet,
                RecordCharSet );
}



PDNS_RECORD
Dns_CreatePtrRecordExEx(
    IN      PDNS_ADDR       pAddr,
    IN      PSTR            pszHostName,
    IN      PSTR            pszDomainName,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create PTR record from hostname and domain name.

    Helper function for DHCP registrations when hostname
    and domain name are separate and both required.

Arguments:

    pAddr -- addr (IP4 or IP6) to map into PTR

    pszHostName -- host name (single label)

    pszDomainName -- domain name

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    WCHAR   nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];

    DNSDBG( TRACE, (
        "Dns_CreatePtrRecordExEx()\n" ));

    //
    //  build appended name
    //
    //  DCR:  could require just host name and check that
    //          either domain exists or hostname is full
    //

    if ( !pszHostName || !pszDomainName )
    {
        return  NULL;
    }

    if ( NameCharSet != DnsCharSetUnicode )
    {
        if ( ! Dns_NameAppend_A(
                    (PCHAR) nameBuffer,
                    DNS_MAX_NAME_BUFFER_LENGTH,
                    pszHostName,
                    pszDomainName ) )
        {
            DNS_ASSERT( FALSE );
            return  NULL;
        }
    }
    else
    {
        if ( ! Dns_NameAppend_W(
                    (PWCHAR) nameBuffer,
                    DNS_MAX_NAME_BUFFER_LENGTH,
                    (PWSTR) pszHostName,
                    (PWSTR) pszDomainName ) )
        {
            DNS_ASSERT( FALSE );
            return  NULL;
        }
    }

    //
    //  build record
    //

    return  Dns_CreatePtrRecordEx(
                    pAddr,
                    (PCHAR) nameBuffer,
                    Ttl,
                    NameCharSet,
                    RecordCharSet
                    );
}



//
//  Forward record creation
//

PDNS_RECORD
Dns_CreateARecord(
    IN      PDNS_NAME       pOwnerName,
    IN      IP4_ADDRESS     Ip4Addr,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create A record.

Arguments:

    pOwnerName -- owner name

    Ip4Addr -- IP address

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    PDNS_RECORD prr;

    //
    //  determine record size
    //      - record buffer will include hostname
    //

    prr = CreateRecordBasic(
                pOwnerName,
                TRUE,           // copy name
                DNS_TYPE_A,
                sizeof(DNS_A_DATA),
                sizeof(DNS_A_DATA),
                Ttl,
                NameCharSet,
                RecordCharSet );
    if ( !prr )
    {
        return( NULL );
    }

    //
    //  set IP
    //

    prr->Data.A.IpAddress = Ip4Addr;

    return( prr );
}



PDNS_RECORD
Dns_CreateAAAARecord(
    IN      PDNS_NAME       pOwnerName,
    IN      IP6_ADDRESS     Ip6Addr,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create A record.

Arguments:

    pOwnerName -- owner name

    Ip6Addr -- IP6 address

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    PDNS_RECORD prr;

    //
    //  determine record size
    //      - record buffer will include hostname
    //

    prr = CreateRecordBasic(
                pOwnerName,
                TRUE,               // copy name
                DNS_TYPE_AAAA,
                sizeof(DNS_AAAA_DATA),
                sizeof(DNS_AAAA_DATA),
                Ttl,
                NameCharSet,
                RecordCharSet );
    if ( !prr )
    {
        return( NULL );
    }

    //
    //  set IP
    //

    prr->Data.AAAA.Ip6Address = Ip6Addr;

    return( prr );
}



PDNS_RECORD
Dns_CreateAAAARecordFromDnsAddr(
    IN      PDNS_NAME       pOwnerName,
    IN      PDNS_ADDR       pAddr,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create A record.

Arguments:

    pOwnerName -- owner name

    pAddr -- Ptr to DNS_ADDR

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    PDNS_RECORD prr;

    //
    //  determine record size
    //      - record buffer will include hostname
    //

    prr = Dns_CreateAAAARecord(
                pOwnerName,
                * (PIP6_ADDRESS) &pAddr->SockaddrIn6.sin6_addr,
                Ttl,
                NameCharSet,
                RecordCharSet
                );
    if ( !prr )
    {
        return( NULL );
    }

    //
    //  slap scope into reserved field
    //

    prr->dwReserved = pAddr->SockaddrIn6.sin6_scope_id;

    return( prr );
}



PDNS_RECORD
Dns_CreateForwardRecord(
    IN      PDNS_NAME       pOwnerName,
    IN      WORD            wType,          OPTIONAL
    IN      PDNS_ADDR       pAddr,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create forward lookup record.

    This is just a shim to avoid duplicating selection logic.

Arguments:

    pOwnerName -- owner name

    wType -- type, if specified;  zero for getting type from pAddr

    pAddr -- ptr to DNS_ADDR

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    //
    //  build desired type
    //

    if ( DnsAddr_IsIp4( pAddr ) )
    {
        if ( wType == 0 || wType == DNS_TYPE_A )
        {
            return   Dns_CreateARecord(
                        pOwnerName,
                        DnsAddr_GetIp4( pAddr ),
                        Ttl,
                        NameCharSet,
                        RecordCharSet );
        }

    }
    else if ( DnsAddr_IsIp6( pAddr ) )
    {
        if ( wType == 0 || wType == DNS_TYPE_AAAA )
        {
            return   Dns_CreateAAAARecordFromDnsAddr(
                        pOwnerName,
                        pAddr,
                        Ttl,
                        NameCharSet,
                        RecordCharSet );
        }
    }

    return   NULL;
}



PDNS_RECORD
Dns_CreateForwardRecordFromIp6(
    IN      PDNS_NAME       pOwnerName,
    IN      PIP6_ADDRESS    pIp,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create forward lookup record.

    This is just a shim to avoid duplicating selection logic.

Arguments:

    pOwnerName -- owner name

    pIp -- IP6 address

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    //
    //  build desired type
    //

    if ( IP6_IS_ADDR_V4MAPPED( pIp ) )
    {
        return   Dns_CreateARecord(
                    pOwnerName,
                    IP6_GET_V4_ADDR( pIp ),
                    Ttl,
                    NameCharSet,
                    RecordCharSet );
    }
    else
    {
        return   Dns_CreateAAAARecord(
                    pOwnerName,
                    *pIp,
                    Ttl,
                    NameCharSet,
                    RecordCharSet );
    }
}



PDNS_RECORD
Dns_CreateForwardRecordForSockaddr(
    IN      PDNS_NAME       pOwnerName,
    IN      PSOCKADDR       pSockaddr,
    IN      DWORD           Ttl,
    IN      DNS_CHARSET     NameCharSet,
    IN      DNS_CHARSET     RecordCharSet
    )
/*++

Routine Description:

    Create forward lookup record.

    This is just a shim to avoid duplicating selection logic.

Arguments:

    pOwnerName -- owner name

    pSockaddr -- ptr to sockaddr

    Ttl -- TTL

    NameCharSet -- character set of name

    RecordCharSet -- character set for resulting record

Return Value:

    Ptr to PTR record.
    NULL on error.

--*/
{
    PFAMILY_INFO pinfo;

    DNSDBG( TRACE, (
        "Dns_CreateForwardRecordForSockaddr()\n" ));

    pinfo = FamilyInfo_GetForSockaddr( pSockaddr );
    if ( !pinfo )
    {
        SetLastError( ERROR_INVALID_DATA );
        return  NULL;
    }

    //
    //  build flat record of desired type
    //

    return  Dns_CreateFlatRecord(
                pOwnerName,
                pinfo->DnsType,
                (PBYTE)pSockaddr + pinfo->OffsetToAddrInSockaddr,
                pinfo->LengthAddr,
                Ttl,
                NameCharSet,
                RecordCharSet );
}



PDNS_RECORD
Dns_CreateRecordForIpString_W(
    IN      PCWSTR          pwsName,
    IN      WORD            wType,      OPTIONAL
    IN      DWORD           Ttl
    )
/*++

Routine Description:

    Create record for IP string query.

Arguments:

    pwsName -- name that may be IP string query

    wType -- type of query;  OPTIONAL, if zero type
        derived from string

Return Value:

    Ptr to record for query, if query name\type is IP.
    NULL if query not for IP.

--*/
{
    DNS_ADDR        addr;
    PDNS_RECORD     prr;


    DNSDBG( TRACE, (
        "\nDns_CreateRecordForIpString( %S, wType = %d )\n",
        pwsName,
        wType ));

    if ( !pwsName )
    {
        return  NULL;
    }

    //
    //  support A or AAAA queries for IP strings
    //      - IP4 strings must be in w.x.y.z form otherwise
    //      we convert the all numeric names also
    //

    if ( wType == DNS_TYPE_A ||
         wType == 0 )
    {
        IP4_ADDRESS ip4;
        PCWSTR      pdot;
        DWORD       count;

        if ( ! Dns_Ip4StringToAddress_W(
                    & ip4,
                    (PWSTR) pwsName ) )
        {
            goto Try6;
        }

        //  verify three dot form w.x.y.z

        pdot = pwsName;
        count = 3;
        while ( count-- )
        {
            pdot = wcschr( pdot, L'.' );
            if ( !pdot || !*++pdot )
            {
                goto Try6;
            }
        }

        DnsAddr_BuildFromIp4(
            &addr,
            ip4,
            0 );

        wType = DNS_TYPE_A;
        goto Build;
    }

Try6:

    if ( wType == DNS_TYPE_AAAA ||
         wType == 0 )
    {
        //  this will convert any form,
        //  but set type==AAAA to fail record build if
        //  did NOT build IP6

        if ( Dns_StringToDnsAddr_W(
                    & addr,
                    (PWSTR) pwsName ) )
        {
            wType = DNS_TYPE_AAAA;
            goto Build;
        }
    }

    return  NULL;       // no match


Build:

    //
    //  name is IP string -- build record
    //

    prr = Dns_CreateForwardRecord(
                (PDNS_NAME) pwsName,
                wType,    
                & addr,
                Ttl,
                DnsCharSetUnicode,
                DnsCharSetUnicode );

    DNSDBG( TRACE, (
        "Create record %p for IP string %S type %d.\n",
        prr,
        pwsName,
        wType ));

    return  prr;
}

//
//  End rralloc.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\rrcopy.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    rrcopy.c

Abstract:

    Domain Name System (DNS) Library

    Copy resource record routines.

Author:

    Jim Gilroy (jamesg)     February, 1997

Revision History:

--*/


#include "local.h"




PDNS_RECORD
ARecordCopy(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy A record data from packet.

Arguments:

    pRR - RR to copy

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    precord = Dns_AllocateRecord( sizeof(IP4_ADDRESS) );
    if ( !precord )
    {
        return NULL;
    }
    precord->Data.A.IpAddress = pRR->Data.A.IpAddress;

    return precord;
}


PDNS_RECORD
PtrRecordCopy(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy PTR compatible record.
    Includes: NS, PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRR - RR to copy

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    precord = Dns_AllocateRecord( sizeof( DNS_PTR_DATA ) );
    if ( !precord )
    {
        return NULL;
    }

    precord->Data.PTR.pNameHost = Dns_NameCopyAllocate(
                                        pRR->Data.PTR.pNameHost,
                                        0,      // length unknown
                                        CharSetIn,
                                        CharSetOut
                                        );
    if ( ! precord->Data.PTR.pNameHost )
    {
        FREE_HEAP( precord );
        return NULL;
    }

    FLAG_FreeData( precord ) = TRUE;

    return precord;
}



PDNS_RECORD
SoaRecordCopy(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy SOA record.

Arguments:

    pRR - RR to copy

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    LPSTR       pname;

    precord = Dns_AllocateRecord( sizeof( DNS_SOA_DATA ) );
    if ( !precord )
    {
        return NULL;
    }

    //
    //  copy integer data
    //

    memcpy(
        & precord->Data.SOA.dwSerialNo,
        & pRR->Data.SOA.dwSerialNo,
        SIZEOF_SOA_FIXED_DATA );

    //
    //  create copy of primary and admin
    //

    pname = Dns_NameCopyAllocate(
                pRR->Data.SOA.pNamePrimaryServer,
                0,      // length unknown
                CharSetIn,
                CharSetOut
                );
    if ( !pname )
    {
        FREE_HEAP( precord );
        return NULL;
    }
    precord->Data.SOA.pNamePrimaryServer = pname;

    pname = Dns_NameCopyAllocate(
                pRR->Data.SOA.pNameAdministrator,
                0,      // length unknown
                CharSetIn,
                CharSetOut
                );
    if ( !pname )
    {
        FREE_HEAP( precord->Data.SOA.pNamePrimaryServer );
        FREE_HEAP( precord );
        return NULL;
    }
    precord->Data.SOA.pNameAdministrator = pname;

    FLAG_FreeData( precord ) = TRUE;

    return precord;
}



PDNS_RECORD
MinfoRecordCopy(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy MINFO and RP records from wire.

Arguments:

    pRR - RR to copy

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    LPSTR       pname;

    precord = Dns_AllocateRecord( sizeof( DNS_MINFO_DATA ) );
    if ( !precord )
    {
        return NULL;
    }

    //
    //  create copy of name fields
    //

    pname = Dns_NameCopyAllocate(
                pRR->Data.MINFO.pNameMailbox,
                0,      // length unknown
                CharSetIn,
                CharSetOut
                );
    if ( !pname )
    {
        FREE_HEAP( precord );
        return NULL;
    }
    precord->Data.MINFO.pNameMailbox = pname;

    pname = Dns_NameCopyAllocate(
                pRR->Data.MINFO.pNameErrorsMailbox,
                0,      // length unknown
                CharSetIn,
                CharSetOut
                );
    if ( !pname )
    {
        FREE_HEAP( precord->Data.MINFO.pNameMailbox );
        FREE_HEAP( precord );
        return NULL;
    }
    precord->Data.MINFO.pNameErrorsMailbox = pname;

    FLAG_FreeData( precord ) = TRUE;

    return precord;
}



PDNS_RECORD
MxRecordCopy(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy MX compatible record from wire.
    Includes: MX, RT, AFSDB

Arguments:

    pRR - RR to copy

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PCHAR       pname;

    precord = Dns_AllocateRecord( sizeof( DNS_MX_DATA ) );
    if ( !precord )
    {
        return NULL;
    }

    //  MX preference value
    //  RT preference
    //  AFSDB subtype

    precord->Data.MX.wPreference = pRR->Data.MX.wPreference;

    //  MX exchange
    //  RT exchange
    //  AFSDB hostname
    //      - name immediately follows MX data struct

    pname = Dns_NameCopyAllocate(
                pRR->Data.MX.pNameExchange,
                0,      // length unknown
                CharSetIn,
                CharSetOut
                );
    if ( !pname )
    {
        FREE_HEAP( precord );
        return NULL;
    }
    precord->Data.MX.pNameExchange = pname;

    FLAG_FreeData( precord ) = TRUE;

    return precord;
}



PDNS_RECORD
TxtRecordCopy(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy TXT compatible records.
    Includes: TXT, X25, HINFO, ISDN

Arguments:

    pRR - RR to copy

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength = sizeof( DNS_TXT_DATA );
    INT         count = pRR->Data.TXT.dwStringCount;
    LPSTR *     ppstringIn;
    LPSTR *     ppstringNew;
    LPSTR       pstring;

    bufLength += (WORD)(sizeof(LPSTR) * count);

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return NULL;
    }
    precord->Data.TXT.dwStringCount = 0;

    //
    //  copy each string
    //      - first string written immediately after string ptr list
    //      - each string written immediately after previous
    //

    ppstringIn = (LPSTR *) pRR->Data.TXT.pStringArray;
    ppstringNew = (LPSTR *) precord->Data.TXT.pStringArray;

    FLAG_FreeData( precord ) = TRUE;

    while ( count-- )
    {
        pstring = Dns_StringCopyAllocate(
                        *ppstringIn,
                        0,      // length unknown
                        CharSetIn,
                        CharSetOut
                        );
        if ( ! pstring )
        {
            Dns_RecordFree( precord );
            return NULL;
        }
        *ppstringNew = pstring;

        precord->Data.TXT.dwStringCount += 1;

        ppstringIn++;
        ppstringNew++;
    }

    return precord;
}



PDNS_RECORD
FlatRecordCopy(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy flat data compatible record.
    Includes: AAAA

Arguments:

    pRR - RR to copy

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    //
    //  allocate given datalength
    //

    precord = Dns_AllocateRecord( pRR->wDataLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  flat copy of data
    //

    memcpy(
        & precord->Data,
        & pRR->Data,
        pRR->wDataLength );

    return( precord );
}



PDNS_RECORD
SrvRecordCopy(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy SRV compatible record from wire.
    Includes: SRV, RT, AFSDB

Arguments:

    pRR - RR to copy

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PCHAR       pname;

    precord = Dns_AllocateRecord( sizeof( DNS_SRV_DATA ) );
    if ( !precord )
    {
        return NULL;
    }

    //  copy integer data

    precord->Data.SRV.wPriority = pRR->Data.SRV.wPriority;
    precord->Data.SRV.wWeight   = pRR->Data.SRV.wWeight;
    precord->Data.SRV.wPort     = pRR->Data.SRV.wPort;

    //  copy target name

    pname = Dns_NameCopyAllocate(
                pRR->Data.SRV.pNameTarget,
                0,      // length unknown
                CharSetIn,
                CharSetOut
                );
    if ( !pname )
    {
        FREE_HEAP( precord );
        return NULL;
    }
    precord->Data.SRV.pNameTarget = pname;

    SET_FREE_DATA( precord );

    return precord;
}



PDNS_RECORD
AtmaRecordCopy(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy Atma compatible record from wire.
    Includes:

Arguments:

    pRR - RR to copy

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof(DNS_ATMA_DATA) +  DNS_ATMA_MAX_ADDR_LENGTH ;

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //  copy integer data

    precord->Data.ATMA.AddressType = pRR->Data.ATMA.AddressType;

    if ( precord->Data.ATMA.AddressType == DNS_ATMA_FORMAT_E164 )
    {
        precord->wDataLength = (WORD) strlen(pRR->Data.ATMA.Address);

        if ( precord->wDataLength > DNS_ATMA_MAX_ADDR_LENGTH )
        {
            precord->wDataLength = DNS_ATMA_MAX_ADDR_LENGTH;
        }
        strncpy(
            precord->Data.ATMA.Address,
            pRR->Data.ATMA.Address,
            precord->wDataLength );
    }
    else
    {
        precord->wDataLength = DNS_ATMA_MAX_ADDR_LENGTH;

        memcpy(
            precord->Data.ATMA.Address,
            pRR->Data.ATMA.Address,
            precord->wDataLength );
    }

    return( precord );
}



PDNS_RECORD
WinsrRecordCopy(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy WINSR compatible record.

Arguments:

    pRR - RR to copy

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PSTR        pname;

    //
    //  determine required buffer length and allocate
    //

    precord = Dns_AllocateRecord( sizeof(DNS_WINSR_DATA) );
    if ( !precord )
    {
        return NULL;
    }

    //  allocate name copy

    pname = Dns_NameCopyAllocate(
                pRR->Data.WINSR.pNameResultDomain,
                0,      // length unknown
                CharSetIn,
                CharSetOut
                );
    if ( !pname )
    {
        FREE_HEAP( precord );
        return NULL;
    }

    //  fill record fields

    precord->Data.WINSR.pNameResultDomain   = pname;
    precord->Data.WINSR.dwMappingFlag       = pRR->Data.WINSR.dwMappingFlag;
    precord->Data.WINSR.dwLookupTimeout     = pRR->Data.WINSR.dwLookupTimeout;
    precord->Data.WINSR.dwCacheTimeout      = pRR->Data.WINSR.dwCacheTimeout;

    FLAG_FreeData( precord ) = TRUE;

    return precord;
}



//
//  RR copy jump table
//

typedef PDNS_RECORD (* RR_COPY_FUNCTION)(
                            PDNS_RECORD,
                            DNS_CHARSET,
                            DNS_CHARSET );

//  extern  RR_COPY_FUNCTION   RRCopyTable[];

RR_COPY_FUNCTION   RRCopyTable[] =
{
    NULL,               //  ZERO
    ARecordCopy,        //  A
    PtrRecordCopy,      //  NS
    PtrRecordCopy,      //  MD
    PtrRecordCopy,      //  MF
    PtrRecordCopy,      //  CNAME
    SoaRecordCopy,      //  SOA
    PtrRecordCopy,      //  MB
    PtrRecordCopy,      //  MG
    PtrRecordCopy,      //  MR
    NULL,               //  NULL
    NULL,   //WksRecordCopy,      //  WKS
    PtrRecordCopy,      //  PTR
    TxtRecordCopy,      //  HINFO
    MinfoRecordCopy,    //  MINFO
    MxRecordCopy,       //  MX
    TxtRecordCopy,      //  TXT
    MinfoRecordCopy,    //  RP
    MxRecordCopy,       //  AFSDB
    TxtRecordCopy,      //  X25
    TxtRecordCopy,      //  ISDN
    MxRecordCopy,       //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    NULL,               //  SIG
    NULL,               //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    FlatRecordCopy,     //  AAAA
    NULL,               //  LOC
    NULL,               //  NXT
    NULL,               //  EID   
    NULL,               //  NIMLOC
    SrvRecordCopy,      //  SRV   
    AtmaRecordCopy,     //  ATMA  
    NULL,               //  NAPTR 
    NULL,               //  KX    
    NULL,               //  CERT  
    NULL,               //  A6    
    NULL,               //  DNAME 
    NULL,               //  SINK  
    NULL,               //  OPT   
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //
    //  Pseudo record types
    //

    NULL,               //  TKEY
    NULL,               //  TSIG

    //
    //  MS only types
    //

    FlatRecordCopy,     //  WINS
    WinsrRecordCopy,    //  WINSR

};




//
//  Generic copy functions
//

PDNS_RECORD
privateRecordCopy(
    IN      PDNS_RECORD     pRecord,
    IN      PDNS_RECORD     pPrevIn,
    IN      PDNS_RECORD     pPrevCopy,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy record to as member of record set.

    The previous records allow suppression of owner name copy when copying
    RR set.

Arguments:

    pRecord - record to copy

    pPrevIn - previous incoming record copied

    pPrevCopy - copy of pPrevIn in new set

    CharSetIn - input record character set;  OPTIONAL
        if zero, pRecord must have CharSet;
        if non-zero, pRecord must have zero or matching CharSet;
        allow this to be specified independently of pRecord, to handle
        conversion of user supplied records, which we do not want to
        modify

    CharSetOut - desired record character set

Return Value:

    Ptr to copy of record in desired character set.
    NULL on error.

--*/
{
    PDNS_RECORD prr;
    WORD        index;
    DNS_CHARSET recordCharSet;

    DNSDBG( TRACE, ( "privateRecordCopy( %p )\n", pRecord ));

    //
    //  input character set
    //  allow specification of input character set to handle case
    //  of user created records, but if input record has a set
    //  then it's assumed to be valid
    //  so validity check:
    //      - CharSetIn == 0 => use record's != 0 set
    //      - record's set == 0 => use CharSetIn != 0
    //      - CharSetIn == record's set
    //

    recordCharSet = RECORD_CHARSET( pRecord );

    if ( recordCharSet )
    {
        ASSERT( CharSetIn == 0 || CharSetIn == recordCharSet );
        CharSetIn = recordCharSet;
    }
    else    // record has no charset
    {
        if ( CharSetIn == 0 )
        {
            ASSERT( FALSE );
            goto Failed;
        }
    }

    //
    //  copy record data
    //

    if ( pRecord->wDataLength != 0 )
    {
        index = INDEX_FOR_TYPE( pRecord->wType );
        DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

        if ( !index || !RRCopyTable[ index ] )
        {
            DNS_PRINT((
                "WARNING:  No copy routine for type = %d\n"
                "\tdoing flat copy of record at %p\n",
                pRecord->wType,
                pRecord ));
            prr = FlatRecordCopy(
                        pRecord,
                        CharSetIn,
                        CharSetOut );
        }
        else
        {
            prr = RRCopyTable[ index ](
                        pRecord,
                        CharSetIn,
                        CharSetOut );
        }
    }
    else    // no data record
    {
        prr = FlatRecordCopy(
                    pRecord,
                    CharSetIn,
                    CharSetOut );
    }

    if ( !prr )
    {
        goto Failed;
    }

    //
    //  copy record structure fields
    //      - type
    //      - TTL
    //      - flags
    //

    prr->dwTtl = pRecord->dwTtl;
    prr->wType = pRecord->wType;

    prr->Flags.S.Section = pRecord->Flags.S.Section;
    prr->Flags.S.Delete  = pRecord->Flags.S.Delete;
    prr->Flags.S.CharSet = CharSetOut;

    //
    //  copy name
    //

    if ( pRecord->pName )
    {
        //
        //      - if incoming name has FreeOwner set, then always copy
        //      as never know when incoming set will be tossed
        //
        //      - then check if incoming name same as previous incoming
        //      name in which case we can use previous copied name
        //
        //      - otherwise full copy of name
        //

        if ( !FLAG_FreeOwner( pRecord ) &&
            pPrevIn && pPrevCopy &&
            pRecord->pName == pPrevIn->pName )
        {
            prr->pName = pPrevCopy->pName;
        }
        else
        {
            prr->pName = Dns_NameCopyAllocate(
                                pRecord->pName,
                                0,              // unknown length
                                CharSetIn,
                                CharSetOut
                                );
            if ( !prr->pName )
            {
                FREE_HEAP( prr );
                goto Failed;
            }
            FLAG_FreeOwner( prr ) = TRUE;
        }
    }

    DNSDBG( TRACE, (
        "Leaving privateRecordCopy(%p) = %p.\n",
        pRecord,
        prr ));
    return( prr );


Failed:

    DNSDBG( TRACE, (
        "privateRecordCopy(%p) failed\n",
        pRecord ));
    return( NULL );
}



PDNS_RECORD
WINAPI
Dns_RecordCopyEx(
    IN      PDNS_RECORD     pRecord,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy record.

Arguments:

    pRecord - record to copy

    CharSetIn - incoming record's character set

    CharSetOut -- char set for resulting record

Return Value:

    Ptr to copy of record in desired character set.
    NULL on error.

--*/
{

    DNSDBG( TRACE, ( "Dns_RecordCopyEx( %p )\n", pRecord ));

    //
    //  call private copy routine
    //      - set optional ptrs to cause full owner name copy
    //

    return privateRecordCopy(
                pRecord,
                NULL,
                NULL,
                CharSetIn,
                CharSetOut );
}


PDNS_RECORD
WINAPI
Dns_RecordCopy_W(
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Copy record.

Arguments:

    pRecord - unicode record to copy to unicode

Return Value:

    Ptr to copy of record in desired character set.
    NULL on error.

--*/
{
    DNSDBG( TRACE, ( "Dns_RecordCopy( %p )\n", pRecord ));

    //
    //  call private copy routine
    //      - set optional ptrs to cause full owner name copy
    //

    return privateRecordCopy(
                pRecord,
                NULL,
                NULL,
                DnsCharSetUnicode,
                DnsCharSetUnicode );
}


PDNS_RECORD
WINAPI
Dns_RecordCopy_A(
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Copy record.

Arguments:

    pRecord - ANSI record to copy to ANSI

Return Value:

    Ptr to copy of record in desired character set.
    NULL on error.

--*/
{
    DNSDBG( TRACE, ( "Dns_RecordCopy( %p )\n", pRecord ));

    //
    //  call private copy routine
    //      - set optional ptrs to cause full owner name copy
    //

    return privateRecordCopy(
                pRecord,
                NULL,
                NULL,
                DnsCharSetAnsi,
                DnsCharSetAnsi );
}



//
//  Record set copy
//

PDNS_RECORD
Dns_RecordSetCopyEx(
    IN      PDNS_RECORD     pRR,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Copy record set, converting to UTF8 if necessary.

Arguments:

    pRR - incoming record set

    CharSetIn - incoming record's character set

    CharSetOut -- char set for resulting record

Return Value:

    Ptr to new record set, if successful.
    NULL on error.

--*/
{
    return  Dns_RecordListCopyEx(
                pRR,
                0,      // no screening flags
                CharSetIn,
                CharSetOut
                );
}



PDNS_RECORD
Dns_RecordListCopyEx(
    IN      PDNS_RECORD     pRR,
    IN      DWORD           ScreenFlag,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Screened copy of record set.

Arguments:

    pRR - incoming record set

    ScreenFlag - flag with record screening parameters

    CharSetIn - incoming record's character set

    CharSetOut -- char set for resulting record

Return Value:

    Ptr to new record set, if successful.
    NULL on error.

--*/
{
    PDNS_RECORD prr;        // most recent copied
    PDNS_RECORD prevIn;     // previous in set being copied
    DNS_RRSET   rrset;

    DNSDBG( TRACE, (
        "Dns_RecordListCopyEx( %p, %08x, %d, %d )\n",
        pRR,
        ScreenFlag,
        CharSetIn,
        CharSetOut ));

    //  init copy rrset

    DNS_RRSET_INIT( rrset );

    //
    //  loop through RR set, add records to either match or diff sets
    //

    prevIn = NULL;
    prr = NULL;

    while ( pRR )
    {
        //  skip copy on record not matching copy criteria

        if ( ScreenFlag )
        {
            if ( !Dns_ScreenRecord( pRR, ScreenFlag ) )
            {
                pRR = pRR->pNext;
                continue;
            }
        }

        prr = privateRecordCopy(
                pRR,
                prevIn,
                prr,        // previous rr copied
                CharSetIn,
                CharSetOut
                );
        if ( prr )
        {
            DNS_RRSET_ADD( rrset, prr );
            prevIn = pRR;
            pRR = pRR->pNext;
            continue;
        }

        //  if fail, toss entire new set

        Dns_RecordListFree( rrset.pFirstRR );
        return( NULL );
    }

    return( rrset.pFirstRR );
}

//
//  End rrcopy.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\rrbuild.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    rrbuild.c

Abstract:

    Domain Name System (DNS) Library

    Build resource record routines.

Author:

    Jim Gilroy (jamesg)     January, 1997

Revision History:

    Jing Chen (t-jingc)     June, 1998

--*/


#include "local.h"



//
//  Type specific record build routines
//

PDNS_RECORD
A_RecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build A record from string data.

Arguments:

    Argc -- count of data arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    if ( Argc != 1 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( sizeof(DNS_A_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    if ( ! Dns_Ip4StringToAddress_A(
                &precord->Data.A.IpAddress,
                Argv[0] ) )
    {
        Dns_RecordFree( precord );
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }

    return( precord );
}


PDNS_RECORD
A_RecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build A record from string data.

Arguments:

    Argc -- count of data arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    if ( Argc != 1 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( sizeof(DNS_A_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    if ( ! Dns_Ip4StringToAddress_W(
                &precord->Data.A.IpAddress,
                Argv[0] ) )
    {
        Dns_RecordFree( precord );
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }

    return( precord );
}



PDNS_RECORD
Ptr_RecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build PTR compatible record from string data.
    Includes: NS, PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    Argc -- count of data arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    if ( Argc != 1 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( sizeof(DNS_PTR_DATA) );
    if ( !precord )
    {
        return( NULL );
    }
    precord->Data.PTR.pNameHost = Argv[0];

    return( precord );
}


PDNS_RECORD
Ptr_RecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build PTR compatible record from string data.
    Includes: NS, PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    Argc -- count of data arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    if ( Argc != 1 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( sizeof(DNS_PTR_DATA) );
    if ( !precord )
    {
        return( NULL );
    }
    precord->Data.PTR.pNameHost = (PDNS_NAME) Argv[0];

    return( precord );
}



PDNS_RECORD
Mx_RecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build MX compatible record from string data.
    Includes: MX, RT, AFSDB

Arguments:

    Argc -- count of data arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    DWORD       temp;

    if ( Argc != 2 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_MX_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  MX preference value
    //  RT preference
    //  AFSDB subtype
    //

    temp = strtoul( Argv[0], NULL, 10 );
    if ( temp > MAXWORD )
    {
        temp = MAXWORD;
    }
    precord->Data.MX.wPreference = (USHORT) temp;

    //
    //  MX exchange
    //  RT exchange
    //  AFSDB hostname
    //

    precord->Data.MX.pNameExchange = Argv[1];

    return( precord );
}


PDNS_RECORD
Mx_RecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build MX compatible record from string data.
    Includes: MX, RT, AFSDB

Arguments:

    Argc -- count of data arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    DWORD       temp;

    if ( Argc != 2 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_MX_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  MX preference value
    //  RT preference
    //  AFSDB subtype
    //

    temp = wcstoul( Argv[0], NULL, 10 );
    if ( temp > MAXWORD )
    {
        temp = MAXWORD;
    }
    precord->Data.MX.wPreference = (USHORT) temp;

    //
    //  MX exchange
    //  RT exchange
    //  AFSDB hostname
    //

    precord->Data.MX.pNameExchange = (PDNS_NAME) Argv[1];

    return( precord );
}



PDNS_RECORD
Soa_RecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build SOA record from string data.

Arguments:

    Argc -- count of data arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PDWORD      pdword;

    if ( Argc != 7 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_SOA_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read primary server and responsible party
    //

    precord->Data.SOA.pNamePrimaryServer = Argv[0];
    Argc--;
    Argv++;
    precord->Data.SOA.pNameAdministrator = Argv[0];
    Argc--;
    Argv++;

    //
    //  read integer data
    //

    pdword = &precord->Data.SOA.dwSerialNo;

    while( Argc-- )
    {
        *pdword = strtoul( Argv[0], NULL, 10 );
        pdword++;
        Argv++;
    }

    return( precord );
}


PDNS_RECORD
Soa_RecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build SOA record from string data.

Arguments:

    Argc -- count of data arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PDWORD      pdword;

    if ( Argc != 7 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_SOA_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read primary server and responsible party
    //

    precord->Data.SOA.pNamePrimaryServer = (PDNS_NAME) Argv[0];
    Argc--;
    Argv++;
    precord->Data.SOA.pNameAdministrator = (PDNS_NAME) Argv[0];
    Argc--;
    Argv++;

    //
    //  read integer data
    //

    pdword = &precord->Data.SOA.dwSerialNo;

    while( Argc-- )
    {
        *pdword = wcstoul( Argv[0], NULL, 10 );
        pdword++;
        Argv++;
    }

    return( precord );
}



PDNS_RECORD
Minfo_RecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build MINFO and RP records from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    if ( Argc != 2 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_MINFO_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  MINFO responsible mailbox
    //  RP responsible person mailbox

    precord->Data.MINFO.pNameMailbox = Argv[0];
    Argc--;
    Argv++;

    //
    //  MINFO errors to mailbox
    //  RP text RR location

    precord->Data.MINFO.pNameErrorsMailbox = Argv[0];
    Argc--;
    Argv++;

    return( precord );
}


PDNS_RECORD
Minfo_RecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build MINFO and RP records from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    if ( Argc != 2 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_MINFO_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  MINFO responsible mailbox
    //  RP responsible person mailbox

    precord->Data.MINFO.pNameMailbox = (PDNS_NAME) Argv[0];
    Argc--;
    Argv++;

    //
    //  MINFO errors to mailbox
    //  RP text RR location

    precord->Data.MINFO.pNameErrorsMailbox = (PDNS_NAME) Argv[0];
    Argc--;
    Argv++;

    return( precord );
}



PDNS_RECORD
Txt_RecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build TXT compatible records from string data.
    Includes: TXT, X25, HINFO, ISDN

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        dataLength;
    PCHAR *     pstringPtr;

    if ( Argc < 1 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    //
    //  allocate space for a pointer for each data string
    //

    precord = Dns_AllocateRecord( (WORD)DNS_TEXT_RECORD_LENGTH(Argc) );
    if ( !precord )
    {
        return( NULL );
    }
    precord->Data.TXT.dwStringCount = Argc;

    //
    //  read as many strings as we have
    //
    //  DCR_FIX:  no checking for string limits
    //      - string count limits on HINFO, X25, ISDN
    //      - 256 length on strings
    //      - 64K on overall size
    //

    pstringPtr = (PCHAR *) precord->Data.TXT.pStringArray;
    while ( Argc-- )
    {
        *pstringPtr = Argv[0];
        pstringPtr++;
        Argv++;
    }
    return( precord );
}


PDNS_RECORD
Txt_RecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build TXT compatible records from string data.
    Includes: TXT, X25, HINFO, ISDN

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        dataLength;
    LPWSTR *    pstringPtr;

    if ( Argc < 1 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    //
    //  allocate space for a pointer for each data string
    //

    precord = Dns_AllocateRecord( (WORD)DNS_TEXT_RECORD_LENGTH(Argc) );
    if ( !precord )
    {
        return( NULL );
    }
    precord->Data.TXT.dwStringCount = Argc;

    //
    //  read as many strings as we have
    //
    //  DCR_FIX:  no checking for string limits
    //      - string count limits on HINFO, X25, ISDN
    //      - 256 length on strings
    //      - 64K on overall size
    //

    pstringPtr = (LPWSTR *) precord->Data.TXT.pStringArray;
    while ( Argc-- )
    {
        *pstringPtr = Argv[0];
        pstringPtr++;
        Argv++;
    }
    return( precord );
}



PDNS_RECORD
Aaaa_RecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build AAAA record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    if ( Argc != 1 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_AAAA_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read IP6 address
    //

    if ( ! Dns_Ip6StringToAddress_A(
                (PIP6_ADDRESS) &precord->Data.AAAA.Ip6Address,
                Argv[0] ) )
    {
        Dns_RecordFree( precord );
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }
    return( precord );
}



PDNS_RECORD
Aaaa_RecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build AAAA record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;

    if ( Argc != 1 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( sizeof(DNS_AAAA_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  convert IPv6 string to address
    //

    if ( ! Dns_Ip6StringToAddress_W(
                &precord->Data.AAAA.Ip6Address,
                Argv[0]
                ) )
    {
        SetLastError( ERROR_INVALID_DATA );
        Dns_RecordFree( precord );
        return NULL;
    }

    return( precord );
}



PDNS_RECORD
Srv_RecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build SRV record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PWORD       pword;

    if ( Argc != 4 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_SRV_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read integer data
    //

    pword = &precord->Data.SRV.wPriority;

    while( Argc-- > 1 )
    {
        DWORD   temp;

        temp = strtoul( Argv[0], NULL, 10 );
        if ( temp > MAXWORD )
        {
            temp = MAXWORD;
        }
        *pword++ = (WORD) temp;
        Argv++;
    }

    //
    //  target host
    //

    precord->Data.SRV.pNameTarget = Argv[0];

    return( precord );
}



PDNS_RECORD
Srv_RecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build SRV record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PWORD       pword;

    if ( Argc != 4 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_SRV_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read integer data
    //

    pword = &precord->Data.SRV.wPriority;

    while( Argc-- > 1 )
    {
        DWORD   temp;

        temp = wcstoul( Argv[0], NULL, 10 );
        if ( temp > MAXWORD )
        {
            temp = MAXWORD;
        }
        *pword++ = (WORD) temp;
        Argv++;
    }

    //
    //  target host
    //

    precord->Data.SRV.pNameTarget = (PDNS_NAME) Argv[0];

    return( precord );
}



PDNS_RECORD
Atma_RecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build ATMA record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PBYTE       pbyte;

    if ( Argc != 2 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( sizeof(DNS_ATMA_DATA) +
                                  DNS_ATMA_MAX_ADDR_LENGTH );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read integer data
    //

    pbyte = &precord->Data.ATMA.AddressType;

    *pbyte = (BYTE) strtoul( Argv[0], NULL, 10 );
    pbyte++;
    Argv++;

    if ( precord->Data.ATMA.AddressType == DNS_ATMA_FORMAT_E164 )
    {
        UINT length = strlen( Argv[0] );
        UINT iter;

        if ( length > DNS_ATMA_MAX_ADDR_LENGTH )
        {
            length = DNS_ATMA_MAX_ADDR_LENGTH;
        }
        for ( iter = 0; iter < length; iter++ )
        {
            precord->Data.ATMA.Address[iter] = Argv[0][iter];
        }

        precord->wDataLength = (WORD) length;
    }
    else
    {
        UINT length = strlen( Argv[0] );
        UINT iter;

        length /= 2;

        if ( length != DNS_ATMA_MAX_ADDR_LENGTH )
        {
            Dns_RecordListFree( precord );
            return NULL;
        }

        for ( iter = 0; iter < length; iter++ )
        {
            char temp[3];

            temp[0] = Argv[0][(2*iter)];
            temp[1] = Argv[0][(2*iter) + 1];
            temp[2] = 0;

            precord->Data.ATMA.Address[iter] = (char) strtoul( temp, NULL, 16 );
        }

        precord->wDataLength = (WORD) length;
    }

    return( precord );


}



PDNS_RECORD
Atma_RecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build ATMA record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PBYTE       pbyte;
    CHAR        addrBuffer[256];
    DWORD       bufLength;

    if ( Argc != 2 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(DNS_ATMA_DATA) +
                                  DNS_ATMA_MAX_ADDR_LENGTH );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read integer data
    //

    pbyte = &precord->Data.ATMA.AddressType;

    *pbyte = (BYTE) wcstoul( Argv[0], NULL, 10 );
    pbyte++;
    Argv++;

    //
    //  copy ATMA address string to wire
    //

    bufLength = DNS_ATMA_MAX_ADDR_LENGTH+1;

    if ( ! Dns_StringCopy(
                addrBuffer,
                & bufLength,
                (PCHAR) Argv[0],
                0,          // length unknown
                DnsCharSetUnicode,
                DnsCharSetWire
                ) )
    {
        Dns_RecordListFree( precord );
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }

    //
    //  read address into record buffer
    //
    //  DCR_CLEANUP:  this is duplicate code with above function,
    //      functionalize and fix;  also remove this loop
    //      and do a memcopy
    //

    if ( precord->Data.ATMA.AddressType == DNS_ATMA_FORMAT_E164 )
    {
        UINT length = strlen( addrBuffer );
        UINT iter;

        if ( length > DNS_ATMA_MAX_ADDR_LENGTH )
        {
            length = DNS_ATMA_MAX_ADDR_LENGTH;
        }

        for ( iter = 0; iter < length; iter++ )
        {
            precord->Data.ATMA.Address[iter] = addrBuffer[iter];
        }

        precord->wDataLength = (WORD) length;
    }
    else
    {
        UINT length = strlen( addrBuffer );
        UINT iter;

        length /= 2;

        if ( length != DNS_ATMA_MAX_ADDR_LENGTH )
        {
            Dns_RecordListFree( precord );
            return NULL;
        }

        for ( iter = 0; iter < length; iter++ )
        {
            char temp[3];

            temp[0] = addrBuffer[(2*iter)];
            temp[1] = addrBuffer[(2*iter) + 1];
            temp[2] = 0;

            precord->Data.ATMA.Address[iter] = (char) strtoul( temp, NULL, 16 );
        }

        precord->wDataLength = (WORD) length;
    }

    return( precord );
}



PDNS_RECORD
Wins_RecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build WINS record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;
    DWORD           ipCount = Argc - 3;
    PDWORD          pdword;
    PIP4_ADDRESS    pip;

    if ( Argc < 4 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( (WORD) DNS_WINS_RECORD_LENGTH((WORD) ipCount) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read integer data
    //
    //  DCR_ENHANCE:  could check for non-conversion in strtoul
    //

    pdword = &precord->Data.WINS.dwMappingFlag;

    while ( Argc > ipCount )
    {
        *pdword = (DWORD) strtoul( Argv[0], NULL, 10 );
        pdword++;
        Argv++;
        Argc--;
    }

    *pdword = ipCount;

    //
    //  convert IP addresses
    //

    pip = precord->Data.WINS.WinsServers;

    while ( Argc-- )
    {
        if ( ! Dns_Ip4StringToAddress_A(
                    pip,
                    Argv[0] ) )
        {
            Dns_RecordFree( precord );
            SetLastError( ERROR_INVALID_DATA );
            return NULL;
        }
        pip++;
        Argv++;
    }

    return( precord );
}


PDNS_RECORD
Wins_RecordBuildW(
    IN      DWORD           Argc,
    IN      PWCHAR *        Argv
    )
/*++

Routine Description:

    Build WINS record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;
    DWORD           ipCount = Argc - 3;
    PDWORD          pdword;
    PIP4_ADDRESS    pip;
    char            szAddr[256];

    if ( Argc < 4 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( (WORD) DNS_WINS_RECORD_LENGTH((WORD) ipCount) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read integer data
    //
    //  DCR_ENHANCE:  could check for non-conversion in strtoul
    //

    pdword = &precord->Data.WINS.dwMappingFlag;

    while ( Argc-- > 1 )
    {
        *pdword = (DWORD) wcstoul( Argv[0], NULL, 10 );
        pdword++;
        Argv++;
    }

    *pdword =  ipCount;

    //
    //  convert IP addresses
    //

    pip = precord->Data.WINS.WinsServers;

    while ( Argc-- )
    {
        if ( ! Dns_Ip4StringToAddress_W(
                    pip,
                    Argv[0] ) )
        {
            Dns_RecordFree( precord );
            SetLastError( ERROR_INVALID_DATA );
            return NULL;
        }
        pip++;
        Argv++;
    }

    return( precord );
}



PDNS_RECORD
Winsr_RecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build WINSR record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PDWORD      pdword;

    if ( Argc != 4 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( sizeof(DNS_WINSR_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read integer data
    //
    //  DCR_ENHANCE:  could check for non-conversion in strtoul
    //

    pdword = &precord->Data.WINSR.dwMappingFlag;

    while( Argc-- > 1 )
    {
        *pdword = (WORD) strtoul( Argv[0], NULL, 10 );
        pdword++;
        Argv++;
    }

    //
    //  result domain
    //

    precord->Data.WINSR.pNameResultDomain = Argv[0];

    return( precord );
}


PDNS_RECORD
Winsr_RecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *     Argv
    )
/*++

Routine Description:

    Build WINSR record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PDWORD      pdword;

    if ( Argc != 4 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    precord = Dns_AllocateRecord( sizeof(DNS_WINSR_DATA) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  read integer data
    //
    //  DCR_ENHANCE:  could check for non-conversion in strtoul
    //

    pdword = &precord->Data.WINSR.dwMappingFlag;

    while( Argc-- > 1 )
    {
        *pdword = (WORD) wcstoul( Argv[0], NULL, 10 );
        pdword++;
        Argv++;
    }

    //
    //  result domain
    //

    precord->Data.WINSR.pNameResultDomain = (PDNS_NAME) Argv[0];

    return( precord );
}



PDNS_RECORD
Wks_RecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build WKS record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD         precord;
    DWORD               byteCount = 0;
    DWORD               i;
    PCHAR               pch;
    WSADATA             wsaData;
    DNS_STATUS          status;
    struct protoent *   pProtoent;


    if ( Argc < 3 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    i = 2;
    while ( i < Argc)
    {
        byteCount += strlen( Argv[i] ) + 1;
        i++;
    }
    byteCount++;    //bBitMasks[0] : string length

    //
    // allocate space for WKS
    //
                
    precord = Dns_AllocateRecord( (WORD)DNS_WKS_RECORD_LENGTH(byteCount) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  get protocol number:
    //

    //  start winsock:
    //
    //  DCR:  this is busted, winsock should be started by now
    status = WSAStartup( DNS_WINSOCK_VERSION, &wsaData );
    if ( status == SOCKET_ERROR )
    {
        Dns_RecordFree( precord );
        status = WSAGetLastError();
        SetLastError( status );
        return( NULL );
    }

    pProtoent = getprotobyname( Argv[0] );

    if ( ! pProtoent || pProtoent->p_proto >= MAXUCHAR )
    {
        Dns_RecordFree( precord );
        status = WSAGetLastError();
        SetLastError( status );
        return( NULL );
    }

    precord->Data.WKS.chProtocol = (UCHAR) pProtoent->p_proto;

    //
    // get ipAddresss:
    //

    precord->Data.WKS.IpAddress = inet_addr( Argv[1] );

    //
    // get the services, put all in one string
    //

    pch = precord->Data.WKS.BitMask;

    (UCHAR) *pch = (UCHAR) byteCount-1;     //string length
    pch++;


    i = 2;
    strcpy( pch, Argv[i] );
    while ( ++i < Argc )
    {
        strcat( pch, " " );
        strcat( pch, Argv[i] );
    }

    return( precord );
}



PDNS_RECORD
Wks_RecordBuildW(
    IN      DWORD        Argc,
    IN      PWCHAR *     Argv
    )
/*++

Routine Description:

    Build WKS record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD         precord;
    DWORD               byteCount = 0;
    DWORD               i;
    PWCHAR              pch;
    WSADATA             wsaData;
    DNS_STATUS          status;
    struct protoent *   pProtoent;
    char                szAddr[256];
    WCHAR               tcpStr[4], udpStr[4], space[2];

    if ( Argc < 3 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    i = 2;
    while ( i < Argc)
    {
        byteCount += wcslen( Argv[i] ) + 1;
        i++;
    }
    byteCount++;    //bBitMasks[0] : string length

    //
    //  allocate space for WKS
    //

    precord = Dns_AllocateRecord( (WORD)DNS_WKS_RECORD_LENGTH(byteCount) );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  get protocol number
    //

    status = WSAStartup( DNS_WINSOCK_VERSION, &wsaData );
    if ( status == SOCKET_ERROR )
    {
        Dns_RecordFree( precord );
        status = WSAGetLastError();
        SetLastError( status );
        return( NULL );
    }


#if 0
    //
    //  DCR_FIX:  WKS build
    //

    if ( ! Dns_CopyStringEx( szAddr, 0, (PCHAR) Argv[0], 0, TRUE, FALSE ) )
    {
        Dns_RecordListFree( precord );
        return NULL;
    }

    pProtoent = getprotobyname( szAddr );

    if ( ! pProtoent || pProtoent->p_proto >= MAXUCHAR )
    {
        Dns_RecordFree( precord );
        status = WSAGetLastError();
        SetLastError( status );
        return( NULL );
    }

    precord->Data.WKS.chProtocol = (UCHAR) pProtoent->p_proto;

    //
    //  IP Address
    //

    if ( ! Dns_CopyStringEx( szAddr, 0, (PCHAR) Argv[0], 0, TRUE, FALSE ) )
    {
        Dns_RecordListFree( precord );
        return NULL;
    }

    precord->Data.WKS.IpAddress = inet_addr( szAddr );

    //
    //  get the services, put all in one string
    //

    pch = (PWCHAR) precord->Data.WKS.bBitMask;

    (UCHAR) *pch = (UCHAR) byteCount-1;
    pch++;

    i = 2;
    if ( ! Dns_NameCopy(
                (PBYTE) space,
                0,
                " ",
                0,
                DnsCharSetUnicode,
                DnsCharSetWire ) )
    {
        Dns_RecordListFree( precord );
        return NULL;
    }

    wcscpy( pch, Argv[i] );
    while ( ++i < Argc )
    {
        wcscat( pch, space );
        wcscat( pch, Argv[i] );
    }
#endif

    return( precord );
}



PDNS_RECORD
Key_RecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build KEY record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     prec;
    int             keyStringLength;
    DWORD           keyLength = 0;

    if ( Argc != 4 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }

    keyStringLength = strlen( Argv[ 3 ] );

    prec = Dns_AllocateRecord( (WORD)
                sizeof( DNS_KEY_DATA ) + keyStringLength );
    if ( !prec )
    {
        return NULL;
    }

    prec->Data.KEY.wFlags = (WORD) strtoul( *( Argv++ ), NULL, 0 );
    prec->Data.KEY.chProtocol = (BYTE) strtoul( *( Argv++ ), NULL, 10 );
    prec->Data.KEY.chAlgorithm = (BYTE) strtoul( *( Argv++ ), NULL, 10 );
    Argc -= 3;

    Dns_SecurityBase64StringToKey(
                prec->Data.KEY.Key,
                &keyLength,
                *Argv,
                keyStringLength );
    Argc--;
    Argv++;

    prec->wDataLength = (WORD) ( SIZEOF_KEY_FIXED_DATA + keyLength );

    return prec;
}   //  Key_RecordBuild



PDNS_RECORD
Key_RecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build KEY record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     prec;
    int             keyStringLength;
    DWORD           keyLength = 0;

    if ( Argc != 4 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }

    keyStringLength = wcslen( Argv[ 3 ] );

    prec = Dns_AllocateRecord( (WORD)
                sizeof( DNS_KEY_DATA ) + keyStringLength / 2 );
    if ( !prec )
    {
        return NULL;
    }

    prec->Data.KEY.wFlags = (WORD) wcstoul( *( Argv++ ), NULL, 0 );
    prec->Data.KEY.chProtocol = (BYTE) wcstoul( *( Argv++ ), NULL, 10 );
    prec->Data.KEY.chAlgorithm = (BYTE) wcstoul( *( Argv++ ), NULL, 10 );
    Argc -= 3;

#if 0
    //  JJW: MUST COPY BUFFER???
    Dns_SecurityBase64StringToKey(
                prec->Data.KEY.Key,
                &keyLength,
                *Argv,
                keyStringLength );
#endif
    Argc--;
    Argv++;

    prec->wDataLength = (WORD) ( SIZEOF_KEY_FIXED_DATA + keyLength );

    return prec;
}   //  Key_RecordBuildW



PDNS_RECORD
Sig_RecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build SIG record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     prec;
    int             sigStringLength;
    DWORD           sigLength = 0;

    if ( Argc != 9 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }

    sigStringLength = strlen( Argv[8] );

    prec = Dns_AllocateRecord( (WORD)
                ( sizeof(DNS_SIG_DATA) + sigStringLength ) );
    if ( !prec )
    {
        return NULL;
    }

    prec->Data.SIG.wTypeCovered = Dns_RecordTypeForName( *( Argv++ ), 0 );
    prec->Data.SIG.chAlgorithm = (BYTE) strtoul( *( Argv++ ), NULL, 10 );
    prec->Data.Sig.chLabelCount = (BYTE) strtoul( *( Argv++ ), NULL, 10 );
    prec->Data.SIG.dwOriginalTtl = ( DWORD ) strtoul( *( Argv++ ), NULL, 10 );
    prec->Data.SIG.dwExpiration = Dns_ParseSigTime( *( Argv++ ), 0 );
    prec->Data.SIG.dwTimeSigned = Dns_ParseSigTime( *( Argv++ ), 0 );
    prec->Data.SIG.wKeyTag = (WORD) strtoul( *( Argv++ ), NULL, 10 );
    prec->Data.SIG.pNameSigner = *( Argv++ );

    Argc -= 8;

    //
    //  Validate signature times.
    //

    if ( prec->Data.SIG.dwExpiration == 0 ||
        prec->Data.SIG.dwTimeSigned == 0 ||
        prec->Data.SIG.dwTimeSigned >= prec->Data.SIG.dwExpiration )
    {
        Dns_RecordFree( prec );
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }

    //
    //  Parse signature.
    //

    if ( Dns_SecurityBase64StringToKey(
                prec->Data.SIG.Signature,
                &sigLength,
                *Argv,
                sigStringLength ) != ERROR_SUCCESS )
    {
        Dns_RecordFree( prec );
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }

    Argc--;
    Argv++;

    prec->wDataLength = (WORD) ( sizeof( DNS_SIG_DATA ) - 4 + sigLength );

    return prec;
} // Sig_RecordBuild



PDNS_RECORD
Sig_RecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build SIG record from string data.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     prec;
    int             sigStringLength;
    DWORD           sigLength = 0;
    PCHAR           pch;

    if ( Argc != 8 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }

    sigStringLength = wcslen( Argv[ 7 ] );

    prec = Dns_AllocateRecord( (WORD)
                ( sizeof( DNS_SIG_DATA ) + sigStringLength ) );
    if ( !prec )
    {
        return NULL;
    }

#if 0
    //  JJW: how to convert all args here???
    prec->Data.SIG.wTypeCovered = Dns_RecordTypeForName( *( Argv++ ), 0 );
    prec->Data.SIG.chAlgorithm = (BYTE) strtoul( *( Argv++ ), NULL, 10 );
    prec->Data.Sig.chLabelCount = (BYTE) strtoul( *( Argv++ ), NULL, 10 );
    prec->Data.SIG.dwOriginalTtl = ( DWORD ) strtoul( *( Argv++ ), NULL, 10 );
    prec->Data.SIG.dwExpiration = Dns_ParseSigTime( *( Argv++ ), 0 );
    prec->Data.SIG.dwTimeSigned = Dns_ParseSigTime( *( Argv++ ), 0 );
    prec->Data.SIG.wKeyTag = (WORD) strtoul( *( Argv++ ), NULL, 10 );
    prec->Data.SIG.pNameSigner = *( Argv++ );

    Argc -= 8;

    Dns_SecurityBase64StringToKey(
                prec->Data.SIG.Signature,
                &sigLength,
                *Argv,
                sigStringLength );
#endif
    Argc--;
    Argv++;

    prec->wDataLength = (WORD) ( sizeof( DNS_SIG_DATA ) - 4 + sigLength );

    return prec;
} // Sig_RecordBuildW



PDNS_RECORD
Nxt_RecordBuild(
    IN      DWORD       Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build NXT record from string data.

    First arg is next name, followed by list of record types at that name.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     prec;
    int             typeIdx = 0;

    if ( Argc < 2 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }
    prec = Dns_AllocateRecord( (WORD) (
                sizeof( LPTSTR ) + sizeof(WORD) * Argc ) );
    if ( !prec )
    {
        return NULL;
    }

    prec->Data.NXT.pNameNext = *( Argv++ );
    --Argc;

    prec->Data.NXT.wNumTypes = 0;
    while ( Argc-- )
    {
        ++prec->Data.NXT.wNumTypes;
        prec->Data.NXT.wTypes[ typeIdx++ ] =
            Dns_RecordTypeForName( *( Argv++ ), 0 );
    }

    return prec;
} // Nxt_RecordBuild



PDNS_RECORD
Nxt_RecordBuildW(
    IN      DWORD       Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build NXT record from string data.

    First arg is next name, followed by list of record types at that name.

Arguments:

    Argc -- count of data Arguments

    Argv -- argv array of data string pointers

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     prec;
    int             typeIdx = 0;

    if ( Argc < 2 )
    {
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }
    prec = Dns_AllocateRecord( (WORD) (
                sizeof( LPTSTR ) + sizeof(WORD) * ( Argc - 1 ) ) );
    if ( !prec )
    {
        return NULL;
    }

    prec->Data.NXT.pNameNext = ( PDNS_NAME ) ( *( Argv++ ) );
    --Argc;

#if 0
    //  JJW: convert type string???
    while ( Argc-- )
    {
        prec->Data.NXT.wTypes[ typeIdx++ ] =
            Dns_RecordTypeForName( *( Argv++ ), 0 );
    }
#endif

    return prec;
} // Nxt_RecordBuildW



//
//  RR build routines jump table
//

typedef PDNS_RECORD (* RR_BUILD_FUNCTION)(
                            DWORD,
                            PCHAR * );

//extern  RR_BUILD_FUNCTION   RRBuildTable[];

typedef PDNS_RECORD (* RR_BUILD_FUNCTION_W)(
                            DWORD,
                            PWCHAR * );

//extern  RR_BUILD_FUNCTION_W   RRBuildTableW[];


RR_BUILD_FUNCTION   RRBuildTable[] =
{
    NULL,               //  ZERO
    A_RecordBuild,       //  A
    Ptr_RecordBuild,     //  NS
    Ptr_RecordBuild,     //  MD
    Ptr_RecordBuild,     //  MF
    Ptr_RecordBuild,     //  CNAME
    Soa_RecordBuild,     //  SOA
    Ptr_RecordBuild,     //  MB
    Ptr_RecordBuild,     //  MG
    Ptr_RecordBuild,     //  MR
    NULL,               //  NULL
    Wks_RecordBuild,     //  WKS
    Ptr_RecordBuild,     //  PTR
    Txt_RecordBuild,     //  HINFO
    Minfo_RecordBuild,   //  MINFO
    Mx_RecordBuild,      //  MX
    Txt_RecordBuild,     //  TXT
    Minfo_RecordBuild,   //  RP
    Mx_RecordBuild,      //  AFSDB
    Txt_RecordBuild,     //  X25
    Txt_RecordBuild,     //  ISDN
    Mx_RecordBuild,      //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    Sig_RecordBuild,     //  SIG
    Key_RecordBuild,     //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    Aaaa_RecordBuild,    //  AAAA
    NULL,               //  LOC
    Nxt_RecordBuild,     //  NXT
    NULL,               //  EID
    NULL,               //  NIMLOC
    Srv_RecordBuild,     //  SRV
    Atma_RecordBuild,    //  ATMA
    NULL,               //  NAPTR
    NULL,               //  KX
    NULL,               //  CERT
    NULL,               //  A6
    NULL,               //  DNAME
    NULL,               //  SINK
    NULL,               //  OPT
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //
    //  Pseudo record types
    //

    NULL,               //  TKEY
    NULL,               //  TSIG

    //
    //  MS only types
    //

    Wins_RecordBuild,    //  WINS
    Winsr_RecordBuild,   //  WINSR
};


RR_BUILD_FUNCTION_W   RRBuildTableW[] =
{
    NULL,               //  ZERO
    A_RecordBuildW,      //  A
    Ptr_RecordBuildW,    //  NS
    Ptr_RecordBuildW,    //  MD
    Ptr_RecordBuildW,    //  MF
    Ptr_RecordBuildW,    //  CNAME
    Soa_RecordBuildW,    //  SOA
    Ptr_RecordBuildW,    //  MB
    Ptr_RecordBuildW,    //  MG
    Ptr_RecordBuildW,    //  MR
    NULL,               //  NULL
    Wks_RecordBuildW,    //  WKS
    Ptr_RecordBuildW,    //  PTR
    Txt_RecordBuildW,    //  HINFO
    Minfo_RecordBuildW,  //  MINFO
    Mx_RecordBuildW,     //  MX
    Txt_RecordBuildW,    //  TXT
    Minfo_RecordBuildW,  //  RP
    Mx_RecordBuildW,     //  AFSDB
    Txt_RecordBuildW,    //  X25
    Txt_RecordBuildW,    //  ISDN
    Mx_RecordBuildW,     //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    Sig_RecordBuildW,    //  SIG
    Key_RecordBuildW,    //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    Aaaa_RecordBuildW,   //  AAAA
    NULL,               //  LOC
    Nxt_RecordBuildW,    //  NXT
    NULL,               //  EID   
    NULL,               //  NIMLOC
    Srv_RecordBuildW,    //  SRV   
    Atma_RecordBuildW,   //  ATMA  
    NULL,               //  NAPTR 
    NULL,               //  KX    
    NULL,               //  CERT  
    NULL,               //  A6    
    NULL,               //  DNAME 
    NULL,               //  SINK  
    NULL,               //  OPT   
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //
    //  Pseudo record types
    //

    NULL,               //  TKEY
    NULL,               //  TSIG

    //
    //  MS only types
    //

    Wins_RecordBuildW,   //  WINS
    Winsr_RecordBuildW,  //  WINSR
};



//
//  Public build routine
//

PDNS_RECORD
Dns_RecordBuild_A(
    IN OUT  PDNS_RRSET  pRRSet,
    IN      LPSTR       pszOwner,
    IN      WORD        wType,
    IN      BOOL        fAdd,
    IN      UCHAR       Section,
    IN      INT         Argc,
    IN      PCHAR *     Argv
    )
/*++

Routine Description:

    Build record from data strings.

Arguments:

    pRRSet -- ptr to RR set structure being built

    pszOwner -- DNS name of RR owner

    wType -- record type

    fAdd -- add\delete, exist\no-exist flag

    Section -- RR section for record

    Argc -- count of data strings

    Argv -- argv array of ptrs to data strings

Return Value:

    Ptr to record built.
    NULL on error.

--*/
{
    PDNS_RECORD precord;
    WORD        index;

    IF_DNSDBG( INIT )
    {
        DNS_PRINT((
            "Dns_RecordBuild()\n"
            "\trrset    = %p\n"
            "\towner    = %s\n"
            "\ttype     = %d\n"
            "\tfAdd     = %d\n"
            "\tsection  = %d\n"
            "\targc     = %d\n",
            pRRSet,
            pszOwner,
            wType,
            fAdd,
            Section,
            Argc ));
    }

    //
    //  every record MUST have owner name
    //

    if ( !pszOwner )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    //
    //  if no data, no dispatch required
    //

    if ( Argc == 0 )
    {
        precord = Dns_AllocateRecord( 0 );
        if ( ! precord )
        {
            return( NULL );
        }
    }

    //  have data, dispatch to type specific build routine

    else
    {
        index = INDEX_FOR_TYPE( wType );
        DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

        if ( !index || !RRBuildTable[ index ] )
        {
            //  can NOT build unknown types

            SetLastError( DNS_ERROR_INVALID_TYPE );
            DNS_PRINT((
                "ERROR:  can not build record of type %d\n",
                wType ));
            return( NULL );
        }

        precord = RRBuildTable[ index ](
                        Argc,
                        Argv );
        if ( ! precord )
        {
            DNS_PRINT((
                "ERROR:  Record build routine failure for record type %d.\n"
                "\tstatus = %d\n\n",
                wType,
                GetLastError() ));
            if ( !GetLastError() )
            {
                SetLastError( ERROR_INVALID_DATA );
            }
            return( NULL );
        }
    }

    //
    //  fill out record structure
    //

    precord->pName = pszOwner;
    precord->wType = wType;
    precord->Flags.S.Section = Section;
    precord->Flags.S.Delete = !fAdd;
    precord->Flags.S.CharSet = DnsCharSetAnsi;

    IF_DNSDBG( INIT )
    {
        DnsDbg_Record(
            "New record built\n",
            precord );
    }

    //
    //  link into existing RR set (if any)
    //

    if ( pRRSet )
    {
        DNS_RRSET_ADD( *pRRSet, precord );
    }
    return( precord );
}



PDNS_RECORD
Dns_RecordBuild_W(
    IN OUT  PDNS_RRSET  pRRSet,
    IN      LPWSTR      pszOwner,
    IN      WORD        wType,
    IN      BOOL        fAdd,
    IN      UCHAR       Section,
    IN      INT         Argc,
    IN      PWCHAR *    Argv
    )
/*++

Routine Description:

    Build record from data strings.

Arguments:

    pRRSet -- ptr to RR set structure being built

    pszOwner -- DNS name of RR owner

    wType -- record type

    fAdd -- add\delete, exist\no-exist flag

    Section -- RR section for record

    Argc -- count of data strings

    Argv -- argv array of ptrs to data strings

Return Value:

    Ptr to record built.
    NULL on error.

--*/
{
    PDNS_RECORD precord;
    WORD        index;

    DNSDBG( INIT, (
        "Dns_RecordBuild()\n"
        "\trrset    = %p\n"
        "\towner    = %S\n"
        "\ttype     = %d\n"
        "\tfAdd     = %d\n"
        "\tsection  = %d\n"
        "\targc     = %d\n",
        pRRSet,
        pszOwner,
        wType,
        fAdd,
        Section,
        Argc ));

    //
    //  every record MUST have owner name
    //

    if ( !pszOwner )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    //
    //  if no data, no dispatch required
    //

    if ( Argc == 0 )
    {
        precord = Dns_AllocateRecord( 0 );
        if ( ! precord )
        {
            return( NULL );
        }
    }

    //  have data, dispatch to type specific build routine

    else
    {
        index = INDEX_FOR_TYPE( wType );
        DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

        if ( !index || !RRBuildTableW[ index ] )
        {
            //  can NOT build unknown types

            SetLastError( DNS_ERROR_INVALID_TYPE );
            DNS_PRINT((
                "ERROR:  can not build record of type %d\n",
                wType ));
            return( NULL );
        }

        precord = RRBuildTableW[ index ](
                        Argc,
                        Argv );
        if ( ! precord )
        {
            DNS_PRINT((
                "ERROR:  Record build routine failure for record type %d.\n"
                "\tstatus = %d\n\n",
                wType,
                GetLastError() ));

            if ( !GetLastError() )
            {
                SetLastError( ERROR_INVALID_DATA );
            }
            return( NULL );
        }
    }

    //
    //  fill out record structure
    //

    precord->pName = (PDNS_NAME) pszOwner;
    precord->wType = wType;
    precord->Flags.S.Section = Section;
    precord->Flags.S.Delete = !fAdd;
    precord->Flags.S.CharSet = DnsCharSetUnicode;

    IF_DNSDBG( INIT )
    {
        DnsDbg_Record(
            "New record built\n",
            precord );
    }

    //
    //  link into existing RR set (if any)
    //

    if ( pRRSet )
    {
        DNS_RRSET_ADD( *pRRSet, precord );
    }
    return( precord );
}


//
//  End rrbuild.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\rrlist.c ===
/*++

Copyright (c) 1996-2001  Microsoft Corporation

Module Name:

    rrlist.c

Abstract:

    Domain Name System (DNS) Library

    Record list manipulation.

Author:

    Jim Gilroy (jamesg)     January, 1997

Environment:

    User Mode - Win32

Revision History:

--*/


#include "local.h"




PDNS_RECORD
Dns_RecordSetDetach(
    IN OUT  PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Detach first RR set from the rest of the list.

Arguments:

    pRR - incoming record set

Return Value:

    Ptr to first record of next RR set.
    NULL if at end of list.

--*/
{
    PDNS_RECORD prr = pRR;
    PDNS_RECORD pback;      // previous RR in set
    WORD        type;       // first RR set type
    DWORD       section;    // section of first RR set

    if ( !prr )
    {
        return( NULL );
    }

    //
    //  loop until find start of new RR set
    //      - new type or
    //      - new section or
    //      - new name
    //      note that NULL name is automatically considered
    //      previous name
    //  

    type = prr->wType;
    section = prr->Flags.S.Section;
    pback = prr;

    while ( prr = pback->pNext )
    {
        if ( prr->wType == type &&
             prr->Flags.S.Section == section &&
             ( prr->pName == NULL ||
               Dns_NameComparePrivate(
                    prr->pName,
                    pback->pName,
                    pback->Flags.S.CharSet ) ) )
        {
            pback = prr;
            continue;
        }

        //  should not be detaching nameless record
        //      - fixup for robustness

        if ( !prr->pName )
        {
            ASSERT( prr->pName );
            prr->pName = Dns_NameCopyAllocate(
                            pRR->pName,
                            0,      // length unknown
                            pRR->Flags.S.CharSet,
                            prr->Flags.S.CharSet );
            SET_FREE_OWNER( prr );
        }
        break;
    }

    //  have following RR set, NULL terminate first set

    if ( prr )
    {
        pback->pNext = NULL;
    }
    return( prr );
}



PDNS_RECORD
WINAPI
Dns_RecordListAppend(
    IN OUT  PDNS_RECORD     pHeadList,
    IN      PDNS_RECORD     pTailList
    )
/*++

Routine Description:

    Append record list onto another.

Arguments:

    pHeadList -- record list to be head

    pTailList -- record list to append to pHeadList

Return Value:

    Ptr to first record of combined RR set.
        - pHeadList UNLESS pHeadList is NULL,
        then it is pTailList.

--*/
{
    PDNS_RECORD prr = pHeadList;

    if ( !pTailList )
    {
        return  prr;
    }
    if ( !prr )
    {
        return  pTailList;
    }

    //  find end of first list and append second list

    while ( prr->pNext )
    {
        prr = prr->pNext;
    }

    //  should be appending new set (with new name)
    //  or matching previous set

    DNS_ASSERT( !pTailList || pTailList->pName ||
                (pTailList->wType == prr->wType &&
                 pTailList->Flags.S.Section == prr->Flags.S.Section) );

    prr->pNext = pTailList;

    return pHeadList;
}



DWORD
Dns_RecordListCount(
    IN      PDNS_RECORD     pRRList,
    IN      WORD            wType
    )
/*++

Routine Description:

    Count records in list.

Arguments:

    pRRList - incoming record set

Return Value:

    Count of records of given type in list.

--*/
{
    DWORD   count = 0;

    //
    //  loop counting all records that match
    //      - either direct match
    //      - or if matching type is ALL
    //

    while ( pRRList )
    {
        if ( pRRList->wType == wType ||
             wType == DNS_TYPE_ALL )
        {
            count++;
        }

        pRRList = pRRList->pNext;
    }

    return( count );
}



DWORD
Dns_RecordListGetMinimumTtl(
    IN      PDNS_RECORD     pRRList
    )
/*++

Routine Description:

    Get minimum TTL of record list

Arguments:

    pRRList - incoming record set

Return Value:

    Minimum TTL of records in list.

--*/
{
    PDNS_RECORD prr = pRRList;
    DWORD       minTtl = MAXDWORD;

    DNSDBG( TRACE, (
        "Dns_RecordListGetMinimumTtl( %p )\n",
        pRRList ));

    //
    //  loop through list build minimum TTL
    //

    while ( prr )
    {
        if ( prr->dwTtl < minTtl )
        {
            minTtl = prr->dwTtl;
        }
        prr = prr->pNext;
    }

    return  minTtl;
}




//
//  Record screening
//

BOOL
Dns_ScreenRecord(
    IN      PDNS_RECORD     pRR,
    IN      DWORD           ScreenFlag
    )
/*++

Routine Description:

    Screen a record.

Arguments:

    pRR - incoming record

    ScreenFlag - screeing flag

Return Value:

    TRUE if passes screening.
    FALSE if record fails screen.

--*/
{
    BOOL    fsave = TRUE;

    DNSDBG( TRACE, (
        "Dns_ScreenRecord( %p, %08x )\n",
        pRR,
        ScreenFlag ));

    //  section screening

    if ( ScreenFlag & SCREEN_OUT_SECTION )
    {
        if ( IS_ANSWER_RR(pRR) )
        {
            fsave = !(ScreenFlag & SCREEN_OUT_ANSWER);
        }
        else if ( IS_AUTHORITY_RR(pRR) )
        {
            fsave = !(ScreenFlag & SCREEN_OUT_AUTHORITY);
        }
        else if ( IS_ADDITIONAL_RR(pRR) )
        {
            fsave = !(ScreenFlag & SCREEN_OUT_ADDITIONAL);
        }
        if ( !fsave )
        {
            return  FALSE;
        }
    }

    //  type screening

    if ( ScreenFlag & SCREEN_OUT_NON_RPC )
    {
        fsave = Dns_IsRpcRecordType( pRR->wType );
    }

    return  fsave;
}



PDNS_RECORD
Dns_RecordListScreen(
    IN      PDNS_RECORD     pRR,
    IN      DWORD           ScreenFlag
    )
/*++

Routine Description:

    Screen records from record set.

Arguments:

    pRR - incoming record set

    ScreenFlag - flag with record screening parameters

Return Value:

    Ptr to new record set, if successful.
    NULL on error.

--*/
{
    PDNS_RECORD     prr;
    PDNS_RECORD     pnext;
    DNS_RRSET       rrset;

    DNSDBG( TRACE, (
        "Dns_RecordListScreen( %p, %08x )\n",
        pRR,
        ScreenFlag ));

    //  init copy rrset

    DNS_RRSET_INIT( rrset );

    //
    //  loop through RR list
    //

    pnext = pRR;

    while ( pnext )
    {
        prr = pnext;
        pnext = prr->pNext;

        //
        //  screen
        //      - reappend record passing screen
        //      - delete record failing screen
        //

        if ( Dns_ScreenRecord( prr, ScreenFlag ) )
        {
            prr->pNext = NULL;
            DNS_RRSET_ADD( rrset, prr );
            continue;
        }
        else
        {
            Dns_RecordFree( prr );
        }
    }

    return( rrset.pFirstRR );
}



//
//  List sorting
//

PDNS_RECORD
Dns_PrioritizeSingleRecordSet(
    IN OUT  PDNS_RECORD     pRecordSet,
    IN      PDNS_ADDR_ARRAY pArray
    )
/*++

Routine Description:

    Prioritize records in record set.

    Note:  REQUIRES single record set.
    Caller should use Dns_PrioritizeRecordList() for multiple lists.

Arguments:

    pRecordSet -- record set to prioritize

    pArray -- address array to sort against

Return Value:

    Ptr to prioritized set.
    Set is NOT new, but is same set as pRecordSet, with records shuffled.

--*/
{
    PDNS_RECORD     prr;
    PDNS_RECORD     pprevRR;
    PDNS_RECORD     prrUnmatched;
    DWORD           iter;
    DNS_LIST        listSubnetMatch;
    DNS_LIST        listClassMatch;
    DNS_LIST        listUnmatched;

    //
    //  DCR_FIX:  this whole routine is bogus
    //      - it lets you do no intermediate ranking
    //      it's binary and in order of IPs in list
    //
    //  need
    //      - knowledge of fast\slow interfaces (WAN for example)
    //  then
    //      - do best match on each RR in turn (rank it)
    //      - then arrange in rank order
    //

    //
    //  verify multirecord set
    //      -- currently only handle type A
    //
    //  DCR_ENHANCE:  prioritize AAAA records?
    //      may need scope info to do properly
    //

    prr = pRecordSet;

    if ( !prr ||
         prr->pNext == NULL  ||
         prr->wType != DNS_TYPE_A )
    {
        return( pRecordSet );
    }

    //  init prioritized list

    DNS_LIST_STRUCT_INIT( listSubnetMatch );
    DNS_LIST_STRUCT_INIT( listClassMatch );
    DNS_LIST_STRUCT_INIT( listUnmatched );


    //
    //  loop through all RRs in set
    //

    while ( prr )
    {
        PDNS_RECORD pnext;
        DWORD       matchLevel;

        ASSERT( prr->wType == DNS_TYPE_A );

        pnext = prr->pNext;
        prr->pNext = NULL;

        //  check for subnet match

        matchLevel = DnsAddrArray_NetworkMatchIp4(
                        pArray,
                        prr->Data.A.IpAddress,
                        NULL        // don't need match addr
                        );

        if ( matchLevel == 0 )
        {
            DNS_LIST_STRUCT_ADD( listUnmatched, prr );
        }
        else if ( matchLevel == DNSADDR_NETMATCH_SUBNET )
        {
            DNS_LIST_STRUCT_ADD( listSubnetMatch, prr );
        }
        else
        {
            DNS_LIST_STRUCT_ADD( listClassMatch, prr );
        }

        prr = pnext;
    }
    
    //
    //  pull lists back together
    //

    if ( prr = listClassMatch.pFirst )
    {
        DNS_LIST_STRUCT_ADD( listSubnetMatch, prr );
    }
    if ( prr = listUnmatched.pFirst )
    {
        DNS_LIST_STRUCT_ADD( listSubnetMatch, prr );
    }
    prr = (PDNS_RECORD) listSubnetMatch.pFirst;

    DNS_ASSERT( prr );

    //
    //  make sure first record has name
    //      - use the name from the original first record
    //      - or copy it
    //

    if ( !prr->pName  ||  !FLAG_FreeOwner(prr) )
    {
        //  steal name from first record

        if ( pRecordSet->pName && FLAG_FreeOwner(pRecordSet) )
        {
            prr->pName = pRecordSet->pName;
            FLAG_FreeOwner(prr) = TRUE;
            pRecordSet->pName = NULL;
            FLAG_FreeOwner(pRecordSet) = FALSE;
        }

        //  if can't poach name, copy it
        //  if copy fails, just point at it
        //      note:  if cared enough about mem failure could
        //             just put original record back at the front

        else
        {
            PBYTE pnameCopy = NULL;

            pnameCopy = Dns_NameCopyAllocate(
                            pRecordSet->pName,
                            0,              // length unknown
                            RECORD_CHARSET( prr ),
                            RECORD_CHARSET( prr )
                            );
            if ( pnameCopy )
            {
                prr->pName = pnameCopy;
                FLAG_FreeOwner( prr ) = TRUE;
            }
            else if ( !prr->pName )
            {
                prr->pName = pRecordSet->pName;
                FLAG_FreeOwner( prr ) = FALSE;
            }
        }
    }

    //
    //  return prioritized list
    //

    return  prr;
}



PDNS_RECORD
Dns_PrioritizeRecordList(
    IN OUT  PDNS_RECORD     pRecordList,
    IN      PDNS_ADDR_ARRAY pArray
    )
/*++

Routine Description:

    Prioritize records in record list.

    Record list may contain multiple record sets.
    Note, currently only prioritize A records, but may
    later do A6 also.

Arguments:

    pRecordSet -- record set to prioritize

    pArray -- address array to sort against

Return Value:

    Ptr to prioritized set.
    Set is NOT new, but is same set as pRecordSet, with records shuffled.

--*/
{
    PDNS_RECORD     pnewList = NULL;
    PDNS_RECORD     prr;
    PDNS_RECORD     prrNextSet;

    if ( ! pRecordList ||
         ! pArray  ||
         pArray->AddrCount == 0 )
    {
        return pRecordList;
    }

    //
    //  loop through all record sets prioritizing
    //      - whack off each RR set in turn
    //      - prioritize it (if possible)
    //      - pour it back into full list
    //      
    //

    prr = pRecordList;

    while ( prr )
    {
        prrNextSet = Dns_RecordSetDetach( prr );

        prr = Dns_PrioritizeSingleRecordSet(
                    prr,
                    pArray );

        DNS_ASSERT( prr );

        pnewList = Dns_RecordListAppend(
                        pnewList,
                        prr );

        prr = prrNextSet;
    }

    return  pnewList;
}

//
//  End rrlist.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\rrcomp.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    rrcomp.c

Abstract:

    Domain Name System (DNS) Library

    Compare resource record routines.

Author:

    Jim Gilroy (jamesg)     February, 1997

Revision History:

--*/


#include "local.h"
#include "locale.h"     // for setlocale stuff for Win9x



//
//  Type specific RR compare routine prototypes
//

BOOL
ARecordCompare(
    IN  PDNS_RECORD     pRR1,
    IN  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare A records.

    All these routines assume:
        - type compare complete
        - datalength compare completed
        - NO unicode

Arguments:

    pRR1 - first record

    pRR2 -- second record

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    return( pRR1->Data.A.IpAddress == pRR2->Data.A.IpAddress );
}



BOOL
PtrRecordCompare(
    IN  PDNS_RECORD     pRR1,
    IN  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare PTR compatible record.
    Includes: NS, PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRR1 - first record

    pRR2 -- second record

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    return Dns_NameComparePrivate(
                (LPSTR) pRR1->Data.PTR.pNameHost,
                (LPSTR) pRR2->Data.PTR.pNameHost,
                RECORD_CHARSET(pRR1) );
}



BOOL
MxRecordCompare(
    IN  PDNS_RECORD     pRR1,
    IN  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare MX compatible record.
    Includes: MX, RT, AFSDB

Arguments:

    pRR1 - first record

    pRR2 -- second record

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    //  verify preference match first

    if ( pRR1->Data.MX.wPreference != pRR2->Data.MX.wPreference )
    {
        return( FALSE );
    }

    //  then result is name comparison

    return Dns_NameComparePrivate(
                (LPSTR) pRR1->Data.MX.pNameExchange,
                (LPSTR) pRR2->Data.MX.pNameExchange,
                RECORD_CHARSET(pRR1) );
}



BOOL
SoaRecordCompare(
    IN  PDNS_RECORD     pRR1,
    IN  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare SOA record.

Arguments:

    pRR1 - first record

    pRR2 -- second record

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    //  verify integer data match first

    if ( memcmp( & pRR1->Data.SOA.dwSerialNo,
                 & pRR2->Data.SOA.dwSerialNo,
                 SIZEOF_SOA_FIXED_DATA ) )
    {
        return( FALSE );
    }

    //  match check names
    //      - primary name server
    //      - admin email name

    if ( ! Dns_NameComparePrivate(
                (LPSTR) pRR1->Data.SOA.pNamePrimaryServer,
                (LPSTR) pRR2->Data.SOA.pNamePrimaryServer,
                RECORD_CHARSET(pRR1) ) )
    {
        return( FALSE );
    }

    return Dns_NameComparePrivate(
                (LPSTR) pRR1->Data.SOA.pNameAdministrator,
                (LPSTR) pRR2->Data.SOA.pNameAdministrator,
                RECORD_CHARSET(pRR1) );
}



BOOL
MinfoRecordCompare(
    IN  PDNS_RECORD     pRR1,
    IN  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare MINFO and RP records.

Arguments:

    pRR1 -- first record

    pRR2 -- second record

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    if ( ! Dns_NameComparePrivate(
                (LPSTR) pRR1->Data.MINFO.pNameMailbox,
                (LPSTR) pRR2->Data.MINFO.pNameMailbox,
                RECORD_CHARSET(pRR1) ) )
    {
        return( FALSE );
    }

    return Dns_NameComparePrivate(
                (LPSTR) pRR1->Data.MINFO.pNameErrorsMailbox,
                (LPSTR) pRR2->Data.MINFO.pNameErrorsMailbox,
                RECORD_CHARSET(pRR1) );
}



BOOL
TxtRecordCompare(
    IN  PDNS_RECORD     pRR1,
    IN  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare TXT compatible records.
    Includes: TXT, X25, HINFO, ISDN

Arguments:

    pRR1 -- first record

    pRR2 -- second record

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    DWORD   count;
    PCHAR * pstring1;
    PCHAR * pstring2;

    //
    //  compare every string
    //  since string order DOES matter
    //      - find string count
    //      - compare each (case-sensitive)
    //

    count = pRR1->Data.TXT.dwStringCount;
    if ( count != pRR2->Data.TXT.dwStringCount )
    {
        return( FALSE );
    }

    pstring1 = (PCHAR *) pRR1->Data.TXT.pStringArray;
    pstring2 = (PCHAR *) pRR2->Data.TXT.pStringArray;

    while ( count-- )
    {
        if ( IS_UNICODE_RECORD(pRR1) )
        {
            if ( wcscmp( (LPWSTR)*pstring1++, (LPWSTR)*pstring2++ ) != 0 )
            {
                return( FALSE );
            }
        }
        else
        {
            if ( strcmp( *pstring1++, *pstring2++ ) != 0 )
            {
                return( FALSE );
            }
        }
    }
    return( TRUE );
}



BOOL
FlatRecordCompare(
    IN  PDNS_RECORD     pRR1,
    IN  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare flat data records.
    Includes AAAA type.

Arguments:

    pRR1 -- first record

    pRR2 -- second record

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    if ( pRR1->wDataLength != pRR2->wDataLength )
    {
        return( FALSE );
    }
    return( !memcmp( & pRR1->Data,
                     & pRR2->Data,
                     pRR1->wDataLength ) );
}



BOOL
SrvRecordCompare(
    IN  PDNS_RECORD     pRR1,
    IN  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare SRV record.

Arguments:

    pRR1 -- first record

    pRR2 -- second record

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    //  verify integer data match first

    if ( memcmp( & pRR1->Data.SRV.wPriority,
                 & pRR2->Data.SRV.wPriority,
                 SIZEOF_SRV_FIXED_DATA ) )
    {
        return( FALSE );
    }

    //  then result is compare on target host

    return Dns_NameComparePrivate(
                (LPSTR) pRR1->Data.SRV.pNameTarget,
                (LPSTR) pRR2->Data.SRV.pNameTarget,
                RECORD_CHARSET(pRR1) );
}



BOOL
AtmaRecordCompare(
    IN  PDNS_RECORD     pRR1,
    IN  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare ATMA record.

Arguments:

    pRR1 -- first record

    pRR2 -- second record

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    WORD length = pRR1->wDataLength;

    if ( length > pRR2->wDataLength )
    {
        length = pRR2->wDataLength;
    }

    //  verify integer data match first

    if ( pRR1->Data.ATMA.AddressType != pRR2->Data.ATMA.AddressType )
    {
        return( FALSE );
    }

    if ( memcmp(
            pRR1->Data.ATMA.Address,
            pRR2->Data.ATMA.Address,
            length ) != 0 )
    {
        return( FALSE );
    }

    return( TRUE );
}



//
//  RR compare routines jump table
//

typedef BOOL (* RR_COMPARE_FUNCTION)(
                            PDNS_RECORD,
                            PDNS_RECORD );

//extern  RR_COMPARE_FUNCTION RRCompareTable[];

RR_COMPARE_FUNCTION   RRCompareTable[] =
{
    NULL,               //  ZERO
    ARecordCompare,     //  A
    PtrRecordCompare,   //  NS
    PtrRecordCompare,   //  MD
    PtrRecordCompare,   //  MF
    PtrRecordCompare,   //  CNAME
    SoaRecordCompare,   //  SOA
    PtrRecordCompare,   //  MB
    PtrRecordCompare,   //  MG
    PtrRecordCompare,   //  MR
    NULL,               //  NULL
    NULL,   //WksRecordCompare,     //  WKS
    PtrRecordCompare,   //  PTR
    TxtRecordCompare,   //  HINFO
    MinfoRecordCompare, //  MINFO
    MxRecordCompare,    //  MX
    TxtRecordCompare,   //  TXT
    MinfoRecordCompare, //  RP
    MxRecordCompare,    //  AFSDB
    TxtRecordCompare,   //  X25
    TxtRecordCompare,   //  ISDN
    MxRecordCompare,    //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    NULL,               //  SIG
    NULL,               //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    FlatRecordCompare,  //  AAAA
    NULL,               //  LOC
    NULL,               //  NXT
    NULL,               //  EID   
    NULL,               //  NIMLOC
    SrvRecordCompare,   //  SRV   
    AtmaRecordCompare,  //  ATMA  
    NULL,               //  NAPTR 
    NULL,               //  KX    
    NULL,               //  CERT  
    NULL,               //  A6    
    NULL,               //  DNAME 
    NULL,               //  SINK  
    NULL,               //  OPT   
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //
    //  Pseudo record types
    //

    NULL,               //  TKEY
    NULL,               //  TSIG

    //
    //  MS only types
    //

    FlatRecordCompare,  //  WINS
    NULL,               //  WINSR
};



BOOL
WINAPI
Dns_RecordCompare(
    IN      PDNS_RECORD     pRecord1,
    IN      PDNS_RECORD     pRecord2
    )
/*++

Routine Description:

    Compare two records.

    Record compare ignores TTL and flags and section information.

Arguments:

    pRecord1 -- first record

    pRecord2 -- second record

Return Value:

    TRUE if records equal.
    FALSE otherwise.

--*/
{
    BOOL    fresult;
    WORD    type = pRecord1->wType;
    WORD    index;

    IF_DNSDBG( UPDATE )
    {
        DNS_PRINT((
            "Dns_RecordCompare()\n"
            "\tfirst    = %p\n"
            "\tfirst    = %p\n",
            pRecord1,
            pRecord2 ));
    }

    //
    //  verify that both records have same character set
    //

    if ( RECORD_CHARSET(pRecord1) != RECORD_CHARSET(pRecord2) )
    {
        DNS_PRINT(( "ERROR:  comparing records with non-matching character sets!\n" ));

        //
        // If they are different and one of them is undefined, just use
        // the defined char set of the other for each.
        //

        if ( !RECORD_CHARSET(pRecord1) && RECORD_CHARSET(pRecord2) )
        {
            RECORD_CHARSET(pRecord1) = RECORD_CHARSET(pRecord2);
        }

        if ( !RECORD_CHARSET(pRecord2) && RECORD_CHARSET(pRecord1) )
        {
            RECORD_CHARSET(pRecord2) = RECORD_CHARSET(pRecord1);
        }
    }

    //
    //  compare type
    //

    if ( type != pRecord2->wType )
    {
        DNSDBG( UPDATE, (
            "record compare failed -- type mismatch\n" ));
        return( FALSE );
    }

    //
    //  compare names
    //

    if ( ! Dns_NameComparePrivate(
                pRecord1->pName,
                pRecord2->pName,
                RECORD_CHARSET( pRecord1 )
                ) )
    {
        DNSDBG( UPDATE, (
            "record compare failed -- owner name mismatch\n" ));
        return( FALSE );
    }

    //
    //  compare data
    //

    index = INDEX_FOR_TYPE( type );
    DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

    if ( !index || !RRCompareTable[ index ] )
    {
        fresult = FlatRecordCompare( pRecord1, pRecord2 );
    }
    else
    {
        fresult = RRCompareTable[ index ](
                    pRecord1,
                    pRecord2 );
    }

    IF_DNSDBG( UPDATE )
    {
        DNS_PRINT((
            "Dns_RecordCompare(%p, %p) returns = %d.\n",
            pRecord1,
            pRecord2,
            fresult ));
    }
    return( fresult );
}



DNS_STATUS
buildUnmatchedRecordSet(
    OUT     PDNS_RECORD *   ppDiffRR,
    IN OUT  PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Build new list of difference records.

Arguments:

    ppDiffRR - address to recieve PTR to new set

    pRR - incoming RR set;  matched records marked wReserved TRUE

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    PDNS_RECORD pcur;
    PDNS_RECORD pnew;
    DNS_RRSET   rrset;

    //  init comparison rrset

    DNS_RRSET_INIT( rrset );

    //
    //  loop through RR set, add records to either match or diff sets
    //

    pcur = pRR;

    while ( pcur )
    {
        if ( ! IS_RR_MATCHED(pcur) )
        {
            //  make copy of record

            pnew = Dns_RecordCopyEx(
                        pcur,
                        RECORD_CHARSET(pcur),
                        RECORD_CHARSET(pcur)
                        );
            if ( !pnew )
            {
                //  DCR_FIX1:  last error not set on all Dns_RecordCopy() failures
                //      Charlie Wickham was getting some random win32 error
                //
                //  DNS_STATUS status = GetLastError();

                //  assume unable to copy because of invalid data

                DNS_PRINT((
                    "ERROR:  unable to copy record at %p\n"
                    "\thence unable to build diff of set at %p\n",
                    pcur,
                    pRR ));
                Dns_RecordListFree( rrset.pFirstRR );
                *ppDiffRR = NULL;

                //return( status ? status : ERROR_INVALID_DATA );
                return( ERROR_INVALID_DATA );
            }
            DNS_RRSET_ADD( rrset, pnew );
        }
        pcur = pcur->pNext;
    }

    *ppDiffRR = rrset.pFirstRR;
    return( ERROR_SUCCESS );
}



DWORD
isUnmatchedRecordInSet(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Check if unmatched record in set.

Arguments:

    pRR - incoming RR set;  matched records marked wReserved TRUE

Return Value:

    Count of all unmatched records in set.
    Zero if all records matched.

--*/
{
    PDNS_RECORD pcur;
    DWORD       countUnmatched = 0;

    //
    //  loop through RR set check for unmatched records
    //

    pcur = pRR;

    while ( pcur )
    {
        if ( ! IS_RR_MATCHED(pcur) )
        {
            countUnmatched++;
        }
        pcur = pcur->pNext;
    }

    return( countUnmatched );
}



DNS_SET_COMPARE_RESULT
WINAPI
Dns_RecordSetCompareEx(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2,
    OUT     PDNS_RECORD *   ppDiff1,    OPTIONAL
    OUT     PDNS_RECORD *   ppDiff2     OPTIONAL
    )
/*++

Routine Description:

    Compare two records.

    Record compare ignores TTL and flags and section information.

Arguments:

    pRR1 - first incoming RR set
    pRR2 - second incoming RR set

    ppDiff1 - addr to receive ptr to unmatched records from first set
    ppDiff2 - addr to receive ptr to unmatched records from second set

Return Value:

    Result indicating relationship -- or error on allocation error:
        DnsSetCompareError
        DnsSetCompareIdentical
        DnsSetCompareNoOverlap
        DnsSetCompareOneSubsetOfTwo
        DnsSetCompareTwoSubsetOfOne
        DnsSetCompareIntersection

--*/
{
    PDNS_RECORD pcur1;
    PDNS_RECORD pcur2;
    DWORD       count1 = 0;
    DWORD       count2 = 0;
    DNS_STATUS  status;
    DWORD       unmatched1;
    DWORD       unmatched2;
    DNS_SET_COMPARE_RESULT result;

    //
    //  init RR sets for compare
    //      - clear reserved field used as matched flag in compare
    //

    pcur1 = pRR1;
    while ( pcur1 )
    {
        CLEAR_RR_MATCHED(pcur1);
        pcur1 = pcur1->pNext;
        count1++;
    }
    pcur1 = pRR2;
    while ( pcur1 )
    {
        CLEAR_RR_MATCHED(pcur1);
        pcur1 = pcur1->pNext;
        count2++;
    }

    //
    //  loop through set 1
    //  attempt match of each record to all records in set 2
    //      except those already matched

    pcur1 = pRR1;

    while ( pcur1 )
    {
        pcur2 = pRR2;
        while ( pcur2 )
        {
            if ( !IS_RR_MATCHED(pcur2)  &&  Dns_RecordCompare( pcur1, pcur2 ) )
            {
                SET_RR_MATCHED(pcur1);
                SET_RR_MATCHED(pcur2);
            }
            pcur2 = pcur2->pNext;
        }
        pcur1 = pcur1->pNext;
    }

    //
    //  get diff record lists, return
    //      - if no diffs, then have match
    //
    //  tedious, but do all this error handling because it is easy for
    //  user to pass in bad records that may fail copy routines, need
    //  way to easily report info, even if only for debugging apps calling in
    //

    if ( ppDiff2 )
    {
        *ppDiff2 = NULL;
    }
    if ( ppDiff1 )
    {
        *ppDiff1 = NULL;
        status = buildUnmatchedRecordSet( ppDiff1, pRR1 );
        if ( status != ERROR_SUCCESS )
        {
            goto Failed;
        }
    }
    if ( ppDiff2 )
    {
        status = buildUnmatchedRecordSet( ppDiff2, pRR2 );
        if ( status != ERROR_SUCCESS )
        {
            if ( ppDiff1 && *ppDiff1 )
            {
                Dns_RecordListFree( *ppDiff1 );
            }
            goto Failed;
        }
    }

    //
    //  determine relationship between sets
    //
    //  impl note:  the only better way i could see doing this
    //  is to map relationships directly to bit flags
    //  however, our enum type doesn't map to bit flags, so
    //  then would have to run mapping table to map flags to enum
    //
    //  note, we do compare so that NULL lists comes out the first
    //  as no-overlap rather than as subset
    //

    unmatched1 = isUnmatchedRecordInSet( pRR1 );
    unmatched2 = isUnmatchedRecordInSet( pRR2 );

    if ( unmatched1 == count1 )
    {
        ASSERT( unmatched2 == count2 );
        result = DnsSetCompareNoOverlap;
    }
    else if ( unmatched1 == 0 )
    {
        if ( unmatched2 == 0 )
        {
            result = DnsSetCompareIdentical;
        }
        else
        {
            ASSERT( unmatched2 != count2 );
            result = DnsSetCompareOneSubsetOfTwo;
        }
    }
    else if ( unmatched2 == 0 )
    {
        result = DnsSetCompareTwoSubsetOfOne;
    }
    else
    {
        ASSERT( unmatched2 != count2 );
        result = DnsSetCompareIntersection;
    }
    return( result );


Failed:

    SetLastError( status );
    return( DnsSetCompareError );
}



BOOL
WINAPI
Dns_RecordSetCompare(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2,
    OUT     PDNS_RECORD *   ppDiff1,    OPTIONAL
    OUT     PDNS_RECORD *   ppDiff2     OPTIONAL
    )
/*++

Routine Description:

    Compare two records.

    Record compare ignores TTL and flags and section information.

Arguments:

    pRR1 - first incoming RR set
    pRR2 - second incoming RR set

    ppDiff1 - addr to receive ptr to unmatched records from first set
    ppDiff2 - addr to receive ptr to unmatched records from second set

Return Value:

    TRUE if record sets equal.
    FALSE otherwise.

--*/
{
    DNS_SET_COMPARE_RESULT result;

    result = Dns_RecordSetCompareEx(
                    pRR1,
                    pRR2,
                    ppDiff1,
                    ppDiff2 );

    return( result == DnsSetCompareIdentical );
}



BOOL
WINAPI
Dns_RecordSetCompareForIntersection(
    IN OUT  PDNS_RECORD     pRR1,
    IN OUT  PDNS_RECORD     pRR2
    )
/*++

Routine Description:

    Compare two record sets for intersection.

Arguments:

    pRR1 - first incoming RR set
    pRR2 - second incoming RR set

Return Value:

    TRUE if record sets intersect.
    FALSE otherwise.

--*/
{
    DNS_SET_COMPARE_RESULT result;

    result = Dns_RecordSetCompareEx(
                    pRR1,
                    pRR2,
                    NULL,
                    NULL );

    return( result == DnsSetCompareIdentical ||
            result == DnsSetCompareIntersection ||
            result == DnsSetCompareOneSubsetOfTwo ||
            result == DnsSetCompareTwoSubsetOfOne );
}


//
//  End rrcomp.c
//



BOOL
WINAPI
Dns_DeleteRecordFromList(
    IN OUT  PDNS_RECORD *   ppRRList,
    IN      PDNS_RECORD     pRRDelete
    )
/*++

Routine Description:

    Delete matching record from record list.

Arguments:

    ppRRList -- addr of record list ptr
        note that in case FIRST record in list is deleted, ppRRList
        is set with ptr to new first record in the list (possibly NULL)

    pRRDelete -- record to delete

Return Value:

    TRUE if record found in list and deleted.
    FALSE if no match.

--*/
{
    PDNS_RECORD prr;
    PDNS_RECORD pprev;

    DNSDBG( TRACE, (
        "Dns_DeleteRecordFromList( %p, %p )\n",
        ppRRList,
        pRRDelete ));


    //
    //  loop through list
    //
    //  note, startup works as pNext is first field in DNS_RECORD
    //  so access to pNext is simply dereference of the record ptr
    //  -- same operation as deref of list address to get first record;
    //  this allows us to have pprev pointer starting at ppRRList, and
    //  eliminates special code for handling delete of first record
    //  

    prr = (PDNS_RECORD) ppRRList;

    while ( pprev = prr,
            prr = prr->pNext )
    {
        if ( Dns_RecordCompare(
                prr,
                pRRDelete ) )
        {
            pprev->pNext = prr->pNext;

            Dns_RecordFree( prr );
            return  TRUE;
        }
    }

    return  FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\rrprint.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    rrprint.c

Abstract:

    Domain Name System (DNS) Library

    Print resource record routines.

Author:

    Jim Gilroy (jamesg)     February, 1997

Revision History:

--*/


#include "local.h"

//
//  Private prototypes
//

VOID
printBadDataLength(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    );



VOID
ARecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print A records.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    WORD    dataLength = pRecord->wDataLength;

    if ( dataLength == sizeof(IP4_ADDRESS) )
    {
        PrintRoutine(
            pContext,
            "\tIP address     = %s\n",
            IP4_STRING(pRecord->Data.A.IpAddress) );
    }
    else if ( dataLength % sizeof(DNS_A_DATA) )
    {
        printBadDataLength( PrintRoutine, pContext, pRecord );
    }
    else    // multiple records
    {
        PIP4_ADDRESS    pip = &pRecord->Data.A.IpAddress;

        DnsPrint_Lock();
        while ( dataLength )
        {
            PrintRoutine(
                pContext,
                "\tIP address     = %s\n",
                IP4_STRING(*pip) );
            dataLength -= sizeof(IP4_ADDRESS);
            pip++;
        }
        DnsPrint_Unlock();
    }
}



VOID
PtrRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print PTR compatible record.
    Includes: NS, PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    PrintRoutine(
        pContext,
        "\tHostName       = %s%S\n",
        RECSTRING_UTF8( pRecord, pRecord->Data.PTR.pNameHost ),
        RECSTRING_WIDE( pRecord, pRecord->Data.PTR.pNameHost )
        );
}



VOID
MxRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print MX compatible record.
    Includes: MX, RT, AFSDB

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    PrintRoutine(
        pContext,
        "\tPreference     = %d\n"
        "\tExchange       = %s%S\n",
        pRecord->Data.MX.wPreference,
        RECSTRING_UTF8( pRecord, pRecord->Data.MX.pNameExchange ),
        RECSTRING_WIDE( pRecord, pRecord->Data.MX.pNameExchange )
        );
}



VOID
SoaRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print SOA record.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    PrintRoutine(
        pContext,
        "\tPrimary        = %s%S\n"
        "\tAdmin          = %s%S\n"
        "\tSerial         = %d\n"
        "\tRefresh        = %d\n"
        "\tRetry          = %d\n"
        "\tExpire         = %d\n"
        "\tDefault TTL    = %d\n",
        RECSTRING_UTF8( pRecord, pRecord->Data.SOA.pNamePrimaryServer ),
        RECSTRING_WIDE( pRecord, pRecord->Data.SOA.pNamePrimaryServer ),
        RECSTRING_UTF8( pRecord, pRecord->Data.SOA.pNameAdministrator ),
        RECSTRING_WIDE( pRecord, pRecord->Data.SOA.pNameAdministrator ),
        pRecord->Data.SOA.dwSerialNo,
        pRecord->Data.SOA.dwRefresh,
        pRecord->Data.SOA.dwRetry,
        pRecord->Data.SOA.dwExpire,
        pRecord->Data.SOA.dwDefaultTtl );
}



VOID
MinfoRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print MINFO and RP records.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    PrintRoutine(
        pContext,
        "\tMailbox        = %s%S\n"
        "\tErrorsMbox     = %s%S\n",
        RECSTRING_UTF8( pRecord, pRecord->Data.MINFO.pNameMailbox ),
        RECSTRING_WIDE( pRecord, pRecord->Data.MINFO.pNameMailbox ),
        RECSTRING_UTF8( pRecord, pRecord->Data.MINFO.pNameErrorsMailbox ),
        RECSTRING_WIDE( pRecord, pRecord->Data.MINFO.pNameErrorsMailbox )
        );
}



VOID
TxtRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print TXT compatible records.
    Includes: TXT, X25, HINFO, ISDN

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    LPTSTR * ppstring;
    INT     i;
    INT     count;

    count = pRecord->Data.TXT.dwStringCount;
    ppstring = pRecord->Data.TXT.pStringArray;

    DnsPrint_Lock();
    PrintRoutine(
        pContext,
        "\tStringCount    = %d\n",
        count );

    for( i=1; i<=count; i++ )
    {
        PrintRoutine(
            pContext,
            "\tString[%d]      = %s%S\n",
            i,
            RECSTRING_UTF8( pRecord, *ppstring ),
            RECSTRING_WIDE( pRecord, *ppstring )
            );
        ppstring++;
    }
    DnsPrint_Unlock();
}



VOID
AaaaRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print flat data records.
    Includes AAAA type.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    CHAR    ip6String[ IP6_ADDRESS_STRING_LENGTH ];

    Dns_Ip6AddressToString_A(
        ip6String,
        (PIP6_ADDRESS) &pRecord->Data.AAAA.Ip6Address );

    PrintRoutine(
        pContext,
        "\tIP6 Address    = %s\n",
        ip6String );
}



VOID
SrvRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print SRV record.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    PrintRoutine(
        pContext,
        "\tPriority       = %d\n"
        "\tWeight         = %d\n"
        "\tPort           = %d\n"
        "\tTarget Host    = %s%S\n",
        pRecord->Data.SRV.wPriority,
        pRecord->Data.SRV.wWeight,
        pRecord->Data.SRV.wPort,
        RECSTRING_UTF8( pRecord, pRecord->Data.SRV.pNameTarget ),
        RECSTRING_WIDE( pRecord, pRecord->Data.SRV.pNameTarget )
        );
}



VOID
AtmaRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print ATMA record.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    PrintRoutine(
        pContext,
        "\tAddress type   = %d\n",
        pRecord->Data.ATMA.AddressType );

    if ( pRecord->Data.ATMA.Address &&
         pRecord->Data.ATMA.AddressType == DNS_ATMA_FORMAT_E164 )
    {
        PrintRoutine(
            pContext,
            "\tAddress        = %s\n",
            pRecord->Data.ATMA.Address );
    }
    else if ( pRecord->Data.ATMA.Address )
    {
        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "\tAddress        = ",
            "\t                 ",   // no line header
            pRecord->Data.ATMA.Address,
            pRecord->wDataLength - 1
            );
    }
}



VOID
TsigRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print TSIG record.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    DnsPrint_Lock();

    if ( pRecord->Data.TSIG.bPacketPointers )
    {
        DnsPrint_PacketName(
            PrintRoutine,
            pContext,
            "\tAlgorithm      = ",
            pRecord->Data.TSIG.pAlgorithmPacket,
            NULL,       // no packet context
            NULL,
            "\n" );
    }
    else
    {
        PrintRoutine(
            pContext,
            "\tAlgorithm      = %s%S\n",
            RECSTRING_UTF8( pRecord, pRecord->Data.TSIG.pNameAlgorithm ),
            RECSTRING_WIDE( pRecord, pRecord->Data.TSIG.pNameAlgorithm )
            );
    }

    PrintRoutine(
        pContext,
        "\tSigned Time    = %I64u\n"
        "\tFudge Time     = %u\n"
        "\tSig Length     = %u\n"
        "\tSig Ptr        = %p\n"
        "\tXid            = %u\n"
        "\tError          = %u\n"
        "\tOtherLength    = %u\n"
        "\tOther Ptr      = %p\n",
        pRecord->Data.TSIG.i64CreateTime,
        pRecord->Data.TSIG.wFudgeTime,
        pRecord->Data.TSIG.wSigLength,
        pRecord->Data.TSIG.pSignature,
        pRecord->Data.TSIG.wOriginalXid,
        pRecord->Data.TSIG.wError,
        pRecord->Data.TSIG.wOtherLength,
        pRecord->Data.TSIG.pOtherData
        );

    if ( pRecord->Data.TSIG.pSignature )
    {
        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "Signature:",
            NULL,   // no line header
            pRecord->Data.TSIG.pSignature,
            pRecord->Data.TSIG.wSigLength
            );
    }

    if ( pRecord->Data.TSIG.pOtherData )
    {
        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "Other Data:",
            NULL,   // no line header
            pRecord->Data.TSIG.pOtherData,
            pRecord->Data.TSIG.wOtherLength
            );
    }

    DnsPrint_Unlock();
}



VOID
TkeyRecordPrint(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print TKEY record.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record to print

Return Value:

    TRUE if record data equal
    FALSE otherwise

--*/
{
    DnsPrint_Lock();

    if ( pRecord->Data.TKEY.bPacketPointers )
    {
        DnsPrint_PacketName(
            PrintRoutine,
            pContext,
            "\tAlgorithm      = ",
            pRecord->Data.TKEY.pAlgorithmPacket,
            NULL,       // no packet context
            NULL,
            "\n" );
    }
    else
    {
        PrintRoutine(
            pContext,
            "\tAlgorithm      = %s%S\n",
            RECSTRING_UTF8( pRecord, pRecord->Data.TKEY.pNameAlgorithm ),
            RECSTRING_WIDE( pRecord, pRecord->Data.TKEY.pNameAlgorithm )
            );
    }

    PrintRoutine(
        pContext,
        "\tCreate Time    = %d\n"
        "\tExpire Time    = %d\n"
        "\tMode           = %d\n"
        "\tError          = %d\n"
        "\tKey Length     = %d\n"
        "\tKey Ptr        = %p\n"
        "\tOtherLength    = %d\n"
        "\tOther Ptr      = %p\n",
        pRecord->Data.TKEY.dwCreateTime,
        pRecord->Data.TKEY.dwExpireTime,
        pRecord->Data.TKEY.wMode,
        pRecord->Data.TKEY.wError,
        pRecord->Data.TKEY.wKeyLength,
        pRecord->Data.TKEY.pKey,
        pRecord->Data.TKEY.wOtherLength,
        pRecord->Data.TKEY.pOtherData
        );

    if ( pRecord->Data.TKEY.pKey )
    {
        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "Key:",
            NULL,   // no line header
            pRecord->Data.TKEY.pKey,
            pRecord->Data.TKEY.wKeyLength
            );
    }

    if ( pRecord->Data.TKEY.pOtherData )
    {
        DnsPrint_RawOctets(
            PrintRoutine,
            pContext,
            "Other Data:",
            NULL,   // no line header
            pRecord->Data.TKEY.pOtherData,
            pRecord->Data.TKEY.wOtherLength
            );
    }

    DnsPrint_Unlock();
}



//
//  RR Print Dispatch Table
//

typedef VOID (* RR_PRINT_FUNCTION)(
                            PRINT_ROUTINE,
                            PPRINT_CONTEXT,
                            PDNS_RECORD );

//  extern  RR_PRINT_FUNCTION   RRPrintTable[];

RR_PRINT_FUNCTION   RRPrintTable[] =
{
    NULL,               //  ZERO
    ARecordPrint,       //  A
    PtrRecordPrint,     //  NS
    PtrRecordPrint,     //  MD
    PtrRecordPrint,     //  MF
    PtrRecordPrint,     //  CNAME
    SoaRecordPrint,     //  SOA
    PtrRecordPrint,     //  MB
    PtrRecordPrint,     //  MG
    PtrRecordPrint,     //  MR
    NULL,               //  NULL
    NULL,   //WksRecordPrint,     //  WKS
    PtrRecordPrint,     //  PTR
    TxtRecordPrint,     //  HINFO
    MinfoRecordPrint,   //  MINFO
    MxRecordPrint,      //  MX
    TxtRecordPrint,     //  TXT
    MinfoRecordPrint,   //  RP
    MxRecordPrint,      //  AFSDB
    TxtRecordPrint,     //  X25
    TxtRecordPrint,     //  ISDN
    MxRecordPrint,      //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    NULL,               //  SIG
    NULL,               //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    AaaaRecordPrint,    //  AAAA
    NULL,               //  LOC
    NULL,               //  NXT
    NULL,               //  EID   
    NULL,               //  NIMLOC
    SrvRecordPrint,     //  SRV   
    AtmaRecordPrint,    //  ATMA  
    NULL,               //  NAPTR 
    NULL,               //  KX    
    NULL,               //  CERT  
    NULL,               //  A6    
    NULL,               //  DNAME 
    NULL,               //  SINK  
    NULL,               //  OPT   
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //
    //  Pseudo record types
    //

    TkeyRecordPrint,    //  TKEY
    TsigRecordPrint,    //  TSIG

    //
    //  MS only types
    //

    NULL,               //  WINS
    NULL,               //  WINSR
};



//
//  Generic print record functions
//

VOID
DnsPrint_Record(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_RECORD     pRecord,
    IN      PDNS_RECORD     pPreviousRecord     OPTIONAL
    )
/*++

Routine Description:

    Print record.

Arguments:

    PrintRoutine -- routine to print with

    pszHeader -- header message

    pRecord -- record to print

    pPreviousRecord -- previous record in RR set (if any)

Return Value:

    None.

--*/
{
    WORD    type = pRecord->wType;
    WORD    dataLength = pRecord->wDataLength;
    WORD    index;

    DnsPrint_Lock();

    if ( pszHeader )
    {
        PrintRoutine(
            pContext,
            pszHeader );
    }

    if ( !pRecord )
    {
        PrintRoutine(
            pContext,
            "ERROR:  Null record ptr to print!\n" );
        goto Unlock;
    }

    //
    //  print record info
    //
    //  same as previous -- skip duplicated info
    //      must match
    //          - name ptr (or have no name)
    //          - type
    //          - flags that make set (section)

    if ( pPreviousRecord &&
        (!pRecord->pName || pPreviousRecord->pName == pRecord->pName) &&
        pPreviousRecord->wType == type &&
        pPreviousRecord->Flags.S.Section == pRecord->Flags.S.Section )
    {
        PrintRoutine(
            pContext,
            "  Next record in set:\n"
            "\tPtr = %p, pNext = %p\n"
            "\tFlags          = %08x\n"
            "\tTTL            = %d\n"
            "\tReserved       = %d\n"
            "\tDataLength     = %d\n",
            pRecord,
            pRecord->pNext,
            pRecord->Flags.DW,
            pRecord->dwTtl,
            pRecord->dwReserved,
            dataLength );
    }

    //
    //  different from previous -- full print
    //

    else
    {
        PrintRoutine(
            pContext,
            "  Record:\n"
            "\tPtr            = %p, pNext = %p\n"
            "\tOwner          = %s%S\n"
            "\tType           = %s (%d)\n"
            "\tFlags          = %08x\n"
            "\t\tSection      = %d\n"
            "\t\tDelete       = %d\n"
            "\t\tCharSet      = %d\n"
            "\tTTL            = %d\n"
            "\tReserved       = %d\n"
            "\tDataLength     = %d\n",
            pRecord,
            pRecord->pNext,
            RECSTRING_UTF8( pRecord, pRecord->pName ),
            RECSTRING_WIDE( pRecord, pRecord->pName ),
            Dns_RecordStringForType( type ),
            type,
            pRecord->Flags.DW,
            pRecord->Flags.S.Section,
            pRecord->Flags.S.Delete,
            pRecord->Flags.S.CharSet,
            pRecord->dwTtl,
            pRecord->dwReserved,
            dataLength );
    }

    //
    //  if no data -- done
    //

    if ( ! dataLength )
    {
        goto Unlock;
    }

    //
    //  print data
    //

    index = INDEX_FOR_TYPE( type );
    DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

    if ( index && RRPrintTable[ index ] )
    {
        RRPrintTable[ index ](
            PrintRoutine,
            pContext,
            pRecord );
    }
    else if ( !index )
    {
        PrintRoutine(
            pContext,
            "\tUnknown type:  can not print data\n" );
    }
    else
    {
        //  DCR:  should do raw bytes print
        PrintRoutine(
            pContext,
            "\tNo print routine for this type\n" );
    }

Unlock:

    DnsPrint_Unlock();
}



VOID
printBadDataLength(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Prints waring on bad data in record.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record with bad data

Return Value:

    None.

--*/
{
    PrintRoutine(
        pContext,
        "\tERROR:  Invalid record data length for this type.\n" );
}



VOID
DnsPrint_RecordSet(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Print record set.

Arguments:

    PrintRoutine -- routine to print with

    pRecord -- record set to print

Return Value:

    None

--*/
{
    PDNS_RECORD pprevious;

    DnsPrint_Lock();
    if ( pszHeader )
    {
        PrintRoutine(
            pContext,
            pszHeader );
    }
    if ( !pRecord )
    {
        PrintRoutine(
            pContext,
            "  No Records in list.\n" );
        goto Unlock;
    }

    //
    //  print all records in set
    //

    pprevious = NULL;

    while ( pRecord )
    {
        DnsPrint_Record(
            PrintRoutine,
            pContext,
            NULL,
            pRecord,
            pprevious );

        pprevious = pRecord;
        pRecord = pRecord->pNext;
    }
    PrintRoutine(
        pContext,
        "\n" );

Unlock:

    DnsPrint_Unlock();
}

//
//  End rrprint.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\rrread.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    rrread.c

Abstract:

    Domain Name System (DNS) Library

    Read resource record from packet routines.

Author:

    Jim Gilroy (jamesg)     January, 1997

Revision History:

--*/


#include "local.h"



PDNS_RECORD
A_RecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read A record data from packet.

Arguments:

    pRR - RR context

    pchStart - start of DNS message

    pchData - ptr to packet RR data

    wLength - length of RR data in packet

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    if ( pchEnd - pchData != sizeof(IP4_ADDRESS) )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    precord = Dns_AllocateRecord( sizeof(IP4_ADDRESS) );
    if ( !precord )
    {
        return( NULL );
    }
    precord->Data.A.IpAddress = *(UNALIGNED DWORD *) pchData;

    return( precord );
}



PDNS_RECORD
Ptr_RecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Process PTR compatible record from wire.
    Includes: NS, PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRR - ptr to record with RR set context

    pchStart - start of DNS message

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;
    WORD        nameLength;
    CHAR        nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];

    //
    //  PTR data is another domain name
    //

    pchData = Dns_ReadPacketName(
                nameBuffer,
                & nameLength,
                NULL,
                NULL,
                pchData,
                pchStart,
                pchEnd );

    if ( pchData != pchEnd )
    {
        DNS_PRINT(( "ERROR:  bad packet name.\n" ));
        SetLastError( DNS_ERROR_INVALID_NAME );
        return( NULL );
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_PTR_DATA );
    bufLength += STR_BUF_SIZE_GIVEN_UTF8_LEN( nameLength, OutCharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  write hostname into buffer, immediately following PTR data struct
    //

    precord->Data.PTR.pNameHost = (PCHAR)&precord->Data + sizeof( DNS_PTR_DATA );

    Dns_NameCopy(
        precord->Data.PTR.pNameHost,
        NULL,                           // no buffer length
        nameBuffer,
        nameLength,
        DnsCharSetWire,
        OutCharSet
        );

    return( precord );
}



PDNS_RECORD
Soa_RecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read SOA record from wire.

Arguments:

    pRR - ptr to record with RR set context

    pchStart - start of DNS message

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;
    PCHAR       pchendFixed;
    PDWORD      pdword;
    WORD        nameLength1;
    WORD        nameLength2;
    CHAR        nameBuffer1[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR        nameBuffer2[ DNS_MAX_NAME_BUFFER_LENGTH ];

    //
    //  read DNS names
    //

    pchData = Dns_ReadPacketName(
                nameBuffer1,
                & nameLength1,
                NULL,
                NULL,
                pchData,
                pchStart,
                pchEnd );
    if ( !pchData || pchData >= pchEnd )
    {
        DNS_PRINT(( "ERROR:  bad packet name.\n" ));
        SetLastError( DNS_ERROR_INVALID_NAME );
        return( NULL );
    }
    pchData = Dns_ReadPacketName(
                nameBuffer2,
                & nameLength2,
                NULL,
                NULL,
                pchData,
                pchStart,
                pchEnd );

    pchendFixed = pchData + SIZEOF_SOA_FIXED_DATA;
    if ( pchendFixed != pchEnd )
    {
        DNS_PRINT(( "ERROR:  bad packet name.\n" ));
        SetLastError( DNS_ERROR_INVALID_NAME );
        return( NULL );
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_SOA_DATA );
    bufLength += STR_BUF_SIZE_GIVEN_UTF8_LEN( nameLength1, OutCharSet );
    bufLength += STR_BUF_SIZE_GIVEN_UTF8_LEN( nameLength2, OutCharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  copy fixed fields
    //

    pdword = &precord->Data.SOA.dwSerialNo;
    while ( pchData < pchendFixed )
    {
        *pdword++ = FlipUnalignedDword( pchData );
        pchData += sizeof(DWORD);
    }

    //
    //  copy names into RR buffer
    //      - primary server immediately follows SOA data struct
    //      - responsible party follows primary server
    //

    precord->Data.SOA.pNamePrimaryServer =
                (PCHAR)&precord->Data + sizeof(DNS_SOA_DATA);

    precord->Data.SOA.pNameAdministrator =
                precord->Data.SOA.pNamePrimaryServer +
                Dns_NameCopy(
                        precord->Data.SOA.pNamePrimaryServer,
                        NULL,                           // no buffer length
                        nameBuffer1,
                        nameLength1,
                        DnsCharSetWire,
                        OutCharSet );

    Dns_NameCopy(
        precord->Data.SOA.pNameAdministrator,
        NULL,                           // no buffer length
        nameBuffer2,
        nameLength2,
        DnsCharSetWire,
        OutCharSet
        );

    return( precord );
}



PDNS_RECORD
Txt_RecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read TXT compatible record from wire.
    Includes: TXT, X25, HINFO, ISDN

Arguments:

    pRR - ptr to record with RR set context

    pchStart - start of DNS message

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;
    WORD        length;
    INT         count;
    PCHAR       pch;
    PCHAR       pchbuffer;
    PCHAR *     ppstring;

    //
    //  determine required buffer length and allocate
    //      - allocate space for each string
    //      - and ptr for each string
    //

    bufLength = 0;
    count = 0;
    pch = pchData;

    while ( pch < pchEnd )
    {
        length = (UCHAR) *pch++;
        pch += length;
        count++;
        bufLength += STR_BUF_SIZE_GIVEN_UTF8_LEN( length, OutCharSet );
    }
    if ( pch != pchEnd )
    {
        DNS_PRINT((
            "ERROR:  Invalid packet string data.\n"
            "\tpch = %p\n"
            "\tpchEnd = %p\n"
            "\tcount = %d\n"
            "\tlength = %d\n",
            pch, pchEnd, count, length
            ));
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    //  allocate

    bufLength += (WORD) DNS_TEXT_RECORD_LENGTH(count);
    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }
    precord->Data.TXT.dwStringCount = count;

    //
    //  DCR:  if separate HINFO type -- handle this here
    //      - set pointer differently
    //      - validate string count found
    //

    //
    //  go back through list copying strings to buffer
    //      - ptrs to strings are saved to argv like data section
    //          ppstring walks through this section
    //      - first string written immediately following data section
    //      - each subsequent string immediately follows predecessor
    //          pchbuffer keeps ptr to position to write strings
    //

    pch = pchData;
    ppstring = (PCHAR *) precord->Data.TXT.pStringArray;
    pchbuffer = (PBYTE)ppstring + (count * sizeof(PCHAR));

    while ( pch < pchEnd )
    {
        length = (UCHAR) *pch++;
#if DBG
        DNS_PRINT((
             "Reading text at %p (len %d), to buffer at %p\n"
            "\tsave text ptr[%d] at %p in precord (%p)\n",
            pch,
            length,
            pchbuffer,
            (PCHAR *) ppstring - (PCHAR *) precord->Data.TXT.pStringArray,
            ppstring,
            precord ));
#endif
        *ppstring++ = pchbuffer;
        pchbuffer += Dns_StringCopy(
                        pchbuffer,
                        NULL,
                        pch,
                        length,
                        DnsCharSetWire,
                        OutCharSet );
        pch += length;
#if DBG
        DNS_PRINT((
            "Read text string %s\n",
            * (ppstring - 1)
            ));
        count--;
#endif
    }
    DNS_ASSERT( pch == pchEnd && count == 0 );

    return( precord );
}



PDNS_RECORD
Minfo_RecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read MINFO record from wire.

Arguments:

    pRR - ptr to record with RR set context

    pchStart - start of DNS message

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;
    WORD        nameLength1;
    WORD        nameLength2;
    CHAR        nameBuffer1[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR        nameBuffer2[ DNS_MAX_NAME_BUFFER_LENGTH ];

    //
    //  read DNS names
    //

    pchData = Dns_ReadPacketName(
                nameBuffer1,
                & nameLength1,
                NULL,
                NULL,
                pchData,
                pchStart,
                pchEnd );

    if ( !pchData || pchData >= pchEnd )
    {
        DNS_PRINT(( "ERROR:  bad packet name.\n" ));
        SetLastError( DNS_ERROR_INVALID_NAME );
        return( NULL );
    }
    pchData = Dns_ReadPacketName(
                nameBuffer2,
                & nameLength2,
                NULL,
                NULL,
                pchData,
                pchStart,
                pchEnd );

    if ( pchData != pchEnd )
    {
        DNS_PRINT(( "ERROR:  bad packet name.\n" ));
        SetLastError( DNS_ERROR_INVALID_NAME );
        return( NULL );
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_MINFO_DATA );
    bufLength += STR_BUF_SIZE_GIVEN_UTF8_LEN( nameLength1, OutCharSet );
    bufLength += STR_BUF_SIZE_GIVEN_UTF8_LEN( nameLength2, OutCharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  copy names into RR buffer
    //      - primary server immediately follows MINFO data struct
    //      - responsible party follows primary server
    //

    precord->Data.MINFO.pNameMailbox =
                    (PCHAR)&precord->Data + sizeof( DNS_MINFO_DATA );

    precord->Data.MINFO.pNameErrorsMailbox =
                precord->Data.MINFO.pNameMailbox +
                Dns_NameCopy(
                        precord->Data.MINFO.pNameMailbox,
                        NULL,                           // no buffer length
                        nameBuffer1,
                        nameLength1,
                        DnsCharSetWire,
                        OutCharSet );

    Dns_NameCopy(
        precord->Data.MINFO.pNameErrorsMailbox,
        NULL,                           // no buffer length
        nameBuffer2,
        nameLength2,
        DnsCharSetWire,
        OutCharSet
        );

    return( precord );
}



PDNS_RECORD
Mx_RecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read MX compatible record from wire.
    Includes: MX, RT, AFSDB

Arguments:

    pRR - ptr to record with RR set context

    pchStart - start of DNS message

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;
    WORD        nameLength;
    WORD        wpreference;
    CHAR        nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];

    //  read preference value

    wpreference = FlipUnalignedWord( pchData );
    pchData += sizeof(WORD);

    //  read mail exchange

    pchData = Dns_ReadPacketName(
                nameBuffer,
                & nameLength,
                NULL,
                NULL,
                pchData,
                pchStart,
                pchEnd );

    if ( pchData != pchEnd )
    {
        DNS_PRINT(( "ERROR:  bad packet name.\n" ));
        SetLastError( DNS_ERROR_INVALID_NAME );
        return( NULL );
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_MX_DATA );
    bufLength += STR_BUF_SIZE_GIVEN_UTF8_LEN( nameLength, OutCharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //  copy preference

    precord->Data.MX.wPreference = wpreference;

    //
    //  write exchange name into buffer, immediately following MX data struct
    //

    precord->Data.MX.pNameExchange = (PCHAR)&precord->Data + sizeof( DNS_MX_DATA );

    Dns_NameCopy(
        precord->Data.MX.pNameExchange,
        NULL,                           // no buffer length
        nameBuffer,
        nameLength,
        DnsCharSetWire,
        OutCharSet
        );

    return( precord );
}



PDNS_RECORD
Flat_RecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read memory copy compatible record from wire.
    Includes AAAA type.

Arguments:

    pRR - ptr to record with RR set context

    pchStart - start of DNS message

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;

    //
    //  determine required buffer length and allocate
    //

    bufLength = (WORD)(pchEnd - pchData);

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  copy packet data to record
    //

    memcpy(
        & precord->Data,
        pchData,
        bufLength );

    return( precord );
}



PDNS_RECORD
Srv_RecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read SRV record from wire.

Arguments:

    pRR - ptr to record with RR set context

    pchStart - start of DNS message

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;
    WORD        nameLength;
    PCHAR       pchstart;
    CHAR        nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];

    //
    //  read SRV target name
    //      - name is after fixed length integer data

    pchstart = pchData;
    pchData += SIZEOF_SRV_FIXED_DATA;

    pchData = Dns_ReadPacketName(
                nameBuffer,
                & nameLength,
                NULL,
                NULL,
                pchData,
                pchStart,
                pchEnd );

    if ( pchData != pchEnd )
    {
        DNS_PRINT(( "ERROR:  bad packet name.\n" ));
        SetLastError( DNS_ERROR_INVALID_NAME );
        return( NULL );
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_SRV_DATA );
    bufLength += STR_BUF_SIZE_GIVEN_UTF8_LEN( nameLength, OutCharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  copy integer fields
    //

    precord->Data.SRV.wPriority = FlipUnalignedWord( pchstart );
    pchstart += sizeof( WORD );
    precord->Data.SRV.wWeight = FlipUnalignedWord( pchstart );
    pchstart += sizeof( WORD );
    precord->Data.SRV.wPort = FlipUnalignedWord( pchstart );

    //
    //  copy target host name into RR buffer
    //      - write target host immediately following SRV data struct
    //

    precord->Data.SRV.pNameTarget = (PCHAR)&precord->Data + sizeof( DNS_SRV_DATA );

    Dns_NameCopy(
        precord->Data.SRV.pNameTarget,
        NULL,                           // no buffer length
        nameBuffer,
        nameLength,
        DnsCharSetWire,
        OutCharSet
        );

    return( precord );
}


PDNS_RECORD
Atma_RecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read ATMA record from wire.

Arguments:

    pRR - ptr to record with RR set context

    pchStart - start of DNS message

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    PCHAR       pchstart;
    WORD        wLen = (WORD) (pchEnd - pchData);

    pchstart = pchData;

    precord = Dns_AllocateRecord( sizeof( DNS_ATMA_DATA ) +
                                  DNS_ATMA_MAX_ADDR_LENGTH );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  copy ATMA integer fields
    //

    precord->Data.ATMA.AddressType = *pchstart;
    pchstart += sizeof( BYTE );

    if ( precord->Data.ATMA.AddressType == DNS_ATMA_FORMAT_E164 )
    {
        precord->wDataLength = wLen;

        if ( precord->wDataLength > DNS_ATMA_MAX_ADDR_LENGTH )
            precord->wDataLength = DNS_ATMA_MAX_ADDR_LENGTH;
    }
    else
    {
        precord->wDataLength = DNS_ATMA_MAX_ADDR_LENGTH;
    }

    //
    //  copy ATMA address field
    //
    memcpy( (PCHAR)&precord->Data.ATMA.Address,
            pchstart,
            precord->wDataLength - sizeof( BYTE ) );

    return( precord );
}



PDNS_RECORD
Wks_RecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read Wks record data from packet.

Arguments:

    pRR - RR context

    pchStart - start of DNS message

    pchData - ptr to packet RR data field

    pchEnd - ptr to end of the data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

Author:
        Cameron Etezadi (camerone) - 1 May 1997
                        - for NS Lookup purposes, must add this function

NOTE:
        NONE of the getXXXbyYYY calls return unicode in their
        structures!  If we want the returned record to be unicode,
        then we must translate.  I am leaving it as char* for now,
        can go back later and fix this.
--*/
{
    PDNS_RECORD         pRecord;
    WORD                wLength;
    PCHAR               pStart;
    UCHAR               cProto;
    struct protoent *   proto;
    struct servent  *   serv;
    IP4_ADDRESS         ipAddress;
    char *              szListOfServices;
    int                 nSize;
    char *              szProtoName;
    BYTE                cMask = 0x80;         // is this right?  Left to right?
    BYTE                cByteToCheck;
    int                 i;
    int                 j = 0;
    int                 nPortNumToQuery;
    int                 nCurLength = 1;
    char *              szTemp;

    pStart = pchData;
    if (! pStart)
    {
        DNS_PRINT(( "ERROR:  WKS did not get a record.\n" ));
        SetLastError( ERROR_INVALID_DATA );
        return(NULL);
    }

    //
    // Check size.  Must at least be an IP Address + a protocol
    //

    if ((pchEnd - pchData) < (sizeof(IP4_ADDRESS) + sizeof(UCHAR)))
    {
        DNS_PRINT(( "ERROR:  WKS packet was too small for any data.\n" ));
        SetLastError( ERROR_INVALID_DATA );
        return(NULL);
    }

    //
    // Fill in the ip and protocol
    //

    ipAddress = *(UNALIGNED DWORD *)pStart;
    pStart += sizeof(IP4_ADDRESS);
    cProto = *(UCHAR *)pStart;
    pStart += sizeof(UCHAR);

    //
    // Redefined the WKS structure to contain a listing
    // of space separated monikers for the services
    //
    // Get the protocol
    //

    proto = getprotobynumber(cProto);
    if (!proto)
    {
    DNS_PRINT(( "ERROR:  WKS failed to resolve protocol number to name.\n" ));
            SetLastError(ERROR_INVALID_DATA);
            return(NULL);
    }

    nSize = strlen(proto->p_name);
    szProtoName = ALLOCATE_HEAP((nSize + 1) * sizeof(char));

    if (!szProtoName)
    {
            DNS_PRINT(( "ERROR:  WKS could not allocate space for proto name\n"));
            SetLastError(ERROR_OUTOFMEMORY);
            return(NULL);
    }
    strcpy(szProtoName, proto->p_name);

    //
    // Now, the tricky part.  This is a bitmask.
    // I must translate to a string for each bit marked in the bitmask
    //

    DNS_PRINT(( "Now checking bitmask bits.\n"));

    szTemp = NULL;

    szListOfServices = ALLOCATE_HEAP(sizeof(char));
    if (!szListOfServices)
    {
            DNS_PRINT(( "ERROR:  WKS could not allocate space for services name\n"));
            SetLastError(ERROR_OUTOFMEMORY);
            FREE_HEAP(szProtoName);
            return(NULL);
    }
    else
    {
            *szListOfServices = '\0';
    }

    while (pStart < pchEnd)
    {
            cByteToCheck = *(BYTE *)pStart;

            for (i = 0; i < 8; i++)
            {
                    if (cByteToCheck & cMask)
                    {
                            // This is a service that is valid
                            nPortNumToQuery = i + (8 * j);
                            serv = getservbyport(htons((USHORT)nPortNumToQuery), szProtoName);
                            if (! serv)
                            {
                                    DNS_PRINT(( "ERROR: WKS found a port that could not be translated\n"));
                                    SetLastError(ERROR_INVALID_DATA);
                                    FREE_HEAP(szProtoName);
                                    FREE_HEAP(szListOfServices);
                                    return(NULL);
                            }
                            nSize = strlen(serv->s_name);
                            nCurLength = nCurLength + nSize + 1;

                            //
                            // Allocate more memory.  We need the + 1 here
                            // because we will overwrite the existing null with a strcat
                            // (removing the need) but use a space to separate items
                            //

                            szTemp = ALLOCATE_HEAP( nCurLength);

                            if (! szTemp)
                            {
                                    DNS_PRINT(( "ERROR:  WKS alloc space for services name\n" ));
                                    SetLastError(ERROR_OUTOFMEMORY);
                                    FREE_HEAP(szProtoName);
                                    FREE_HEAP(szListOfServices);
                                    return(NULL);
                            }
                            else
                            {
                                strcpy( szTemp, szListOfServices );
                                FREE_HEAP( szListOfServices );
                                szListOfServices = szTemp;
                                szTemp = NULL;
                            }

                            //
                            // Append the retrieved service name to the end of the list
                            //

                            strcat(szListOfServices, serv->s_name);
                            strcat(szListOfServices, " ");
                    }
                    cByteToCheck <<= 1;
            }

            //
            // Increment the "how many bytes have we done" offset counter
            //

            j++;
            pStart += sizeof(BYTE);
    }
    FREE_HEAP(szProtoName);

    //
    // Allocate a record and fill it in.
    //

    wLength = (WORD)(sizeof(IP4_ADDRESS) + sizeof(UCHAR) + sizeof(int)
                    + (sizeof(char) * ++nCurLength));

    pRecord = Dns_AllocateRecord(wLength);
    if ( !pRecord )
    {
            DNS_PRINT(( "ERROR: WKS failed to allocate record\n" ));
            SetLastError(ERROR_OUTOFMEMORY);
            FREE_HEAP(szListOfServices);
            return(NULL);
    }

    pRecord->Data.WKS.IpAddress = ipAddress;
    pRecord->Data.WKS.chProtocol = cProto;

    strcpy((char *)pRecord->Data.WKS.BitMask, szListOfServices);
    FREE_HEAP(szListOfServices);

    return(pRecord);
}



PDNS_RECORD
Tkey_RecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
{
    PCHAR       pch;
    PDNS_RECORD prr;
    WORD        bufLength;
    WORD        keyLength;
    PCHAR       pchstart;
    CHAR        nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];

    //
    //  allocate record
    //

    bufLength = sizeof( DNS_TKEY_DATA );

    prr = Dns_AllocateRecord( bufLength );
    if ( !prr )
    {
        return( NULL );
    }
    prr->wType = DNS_TYPE_TKEY;

    //
    //  algorithm name
    //

    pch = Dns_SkipPacketName(
                pchData,
                pchEnd );
    if ( !pch )
    {
        goto Formerr;
    }
    prr->Data.TKEY.pAlgorithmPacket = (PDNS_NAME) pchData;
    prr->Data.TKEY.cAlgNameLength = (UCHAR)(pch - pchData);
    prr->Data.TKEY.pNameAlgorithm = NULL;

#if 0
    //
    //  DEVNOTE:  currently not allocating data for TKEY, using internal pointers
    //
    //  allocated version
    //      note for this we won't have compression pointer which is fine
    //          since no name compression in data
    //      however function may need dummy to do the right thing
    //      should perhaps just pass in pchStart which can be dummy to
    //      real header
    //

    pch = Dns_ReadPacketNameAllocate(
                & prr->Data.TKEY.pNameAlgorithm,
                & nameLength,
                NULL,           // no previous name
                NULL,           // no previous name
                pchData,
                //pchStart,   // have no packet context
                NULL,
                pchEnd );
    if ( !pch )
    {
        DNSDBG( SECURITY, (
            "WARNING:  invalid TKEY algorithm name at %p.\n",
            pch ));
        goto Formerr;
    }
#endif

    //
    //  read fixed fields
    //

    if ( pch + SIZEOF_TKEY_FIXED_DATA >= pchEnd )
    {
        goto Formerr;
    }
    prr->Data.TKEY.dwCreateTime = InlineFlipUnalignedDword( pch );
    pch += sizeof(DWORD);
    prr->Data.TKEY.dwExpireTime = InlineFlipUnalignedDword( pch );
    pch += sizeof(DWORD);
    prr->Data.TKEY.wMode = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);
    prr->Data.TKEY.wError = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);
    prr->Data.TKEY.wKeyLength = keyLength = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);

    //  now have key and other length to read

    if ( pch + keyLength + sizeof(WORD) > pchEnd )
    {
        goto Formerr;
    }

    //
    //  save ptr to key
    //

    prr->Data.TKEY.pKey = pch;
    pch += keyLength;

#if 0
    //
    //  copy key
    //

    pkey = ALLOCATE_HEAP( keyLength );
    if ( !pkey )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Failed;
    }

    RtlCopyMemory(
        pkey,
        pch,
        keyLength );

    pch += keyLength;
#endif

    //
    //  other data
    //

    prr->Data.TKEY.wOtherLength = keyLength = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);

    if ( pch + keyLength > pchEnd )
    {
        goto Formerr;
    }
    if ( !keyLength )
    {
        prr->Data.TKEY.pOtherData = NULL;
    }
    else
    {
        prr->Data.TKEY.pOtherData = pch;
    }

    //  DCR_ENHANCE:  TKEY end-of-data verification

    //  returning TKEY with packet pointers as only point is processing

    prr->Data.TKEY.bPacketPointers = TRUE;

    //
    //  DCR_ENHANCE:  copied subfields, best to get here with stack record, then
    //      allocate RR containing subfields and copy everything

    return( prr );

Formerr:

    DNSDBG( ANY, (
        "ERROR:  FOMERR processing TKEY at %p in message\n",
        pchData ));

    //  free record
    //      if switch to allocated subfields need

    FREE_HEAP( prr );
    return( NULL );
}



PDNS_RECORD
Tsig_RecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read SRV record from wire.

Arguments:

    pRR - ptr to record with RR set context

    pchStart - [OLD SEMANTICS, UNUSED] start of DNS message

     OVERLOAD pchStart!!
     Since we're stuck w/ this function signature, we'll overload
     the unused param pchStart to get the iKeyVersion.

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field


Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PCHAR       pch;
    PDNS_RECORD prr;
    WORD        bufLength;
    WORD        sigLength;
    PCHAR       pchstart;
    CHAR        nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];

#if 0
    //  currently do not need versioning info
    //      if had to do again, should extract version then pass
    //      in another pRR field;  or send entire packet context
    //
    //  extract current TSIG version (from key string)
    //

    ASSERT( pRR );
    iKeyVersion = Dns_GetKeyVersion( pRR->pName );
#endif

    //
    //  allocate record
    //

    bufLength = sizeof( DNS_TSIG_DATA );

    prr = Dns_AllocateRecord( bufLength );
    if ( !prr )
    {
        return( NULL );
    }
    prr->wType = DNS_TYPE_TSIG;

    //
    //  algorithm name
    //

    pch = Dns_SkipPacketName(
                pchData,
                pchEnd );
    if ( !pch )
    {
        DNSDBG( SECURITY, (
            "WARNING:  invalid TSIG RR algorithm name.\n" ));
        goto Formerr;
    }

    prr->Data.TSIG.pAlgorithmPacket = (PDNS_NAME) pchData;
    prr->Data.TSIG.cAlgNameLength = (UCHAR)(pch - pchData);

#if 0
    //  allocated version
    //      note for this we won't have compression pointer which is fine
    //          since no name compression in data
    //      however function may need dummy to do the right thing
    //      should perhaps just pass in pchStart which can be dummy
    //      to real header
    //

    pch = Dns_ReadPacketNameAllocate(
                & prr->Data.TSIG.pNameAlgorithm,
                & nameLength,
                NULL,           // no previous name
                NULL,           // no previous name
                pchData,
                //pchStart,   // have no packet context
                NULL,
                pchEnd );
    if ( !pch )
    {
        DNSDBG( SECURITY, (
            "WARNING:  invalid TSIG RR algorithm name at %p.\n",
            pch ));
        goto Formerr;
    }
#endif

    //
    //  read fixed fields
    //

    if ( pch + SIZEOF_TSIG_FIXED_DATA >= pchEnd )
    {
        DNSDBG( SECURITY, (
            "ERROR:  TSIG has inadequate length for fixed fields.\n" ));
        goto Formerr;
    }

    //
    //  read time fields
    //      - 48 bit create time
    //      - 16 bit fudge
    //

    prr->Data.TSIG.i64CreateTime = InlineFlipUnaligned48Bits( pch );
    pch += sizeof(DWORD) + sizeof(WORD);

    prr->Data.TSIG.wFudgeTime = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);

    //
    //  save sig length and sig pointer
    //

    prr->Data.TSIG.wSigLength = sigLength = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);

    prr->Data.TSIG.pSignature = pch;
    pch += sigLength;

    //
    //  verify rest of fields within packet
    //      - signature
    //      - original XID
    //      - extended RCODE
    //      - other data length field
    //      - other data
    //

    if ( pch + SIZEOF_TSIG_POST_SIG_FIXED_DATA > pchEnd )
    {
        DNSDBG( SECURITY, (
            "ERROR:  TSIG has inadequate length for post-sig fixed fields.\n" ));
        goto Formerr;
    }

#if 0
    //
    //  note:  if this activated, would need to validate length pull
    //      sig ptr thing above and change validation to include sig length
    //
    //  copy sig
    //

    psig = ALLOCATE_HEAP( sigLength );
    if ( !psig )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Failed;
    }

    RtlCopyMemory(
        psig,
        pch,
        sigLength );

    pch += sigLength;
#endif

    //  original XID
    //      - leave in net order, as just replace in message for signing

    prr->Data.TSIG.wOriginalXid = READ_PACKET_NET_WORD( pch );
    pch += sizeof(WORD);

    DNSDBG( SECURITY, (
        "Read original XID <== 0x%x.\n",
        prr->Data.TSIG.wOriginalXid ));

    //  error field

    prr->Data.TSIG.wError = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);

    //
    //  other data
    //

    prr->Data.TSIG.wOtherLength = sigLength = InlineFlipUnalignedWord( pch );
    pch += sizeof(WORD);

    if ( pch + sigLength > pchEnd )
    {
        DNSDBG( SECURITY, (
            "WARNING:  invalid TSIG RR sigLength %p.\n",
            pch ));
        goto Formerr;
    }
    if ( !sigLength )
    {
        prr->Data.TSIG.pOtherData = NULL;
    }
    else
    {
        prr->Data.TSIG.pOtherData = pch;
    }

    //  DCR_ENHANCE:  TSIG end-of-data verification

    //  returning TSIG with packet pointers as only point is processing

    prr->Data.TSIG.bPacketPointers = TRUE;

    //
    //  DCR_ENHANCE:  copied subfields, best to get here with stack record, then
    //      allocate RR containing subfields and copy everything

    return( prr );

Formerr:

    DNSDBG( ANY, (
        "ERROR:  FOMERR processing TSIG in message at %p\n" ));

    //  free record
    //      if switch to allocated subfields need

    FREE_HEAP( prr );

    return( NULL );
}



PDNS_RECORD
Wins_RecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read WINS record from wire.

Arguments:

    pRR - ptr to record with RR set context

    pchStart - start of DNS message

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;

    //
    //  determine required buffer length and allocate
    //

    bufLength = (WORD)(pchEnd - pchData);

    precord = Dns_AllocateRecord( bufLength );

    if ( !precord )
    {
        return( NULL );
    }

    //
    //  copy packet data to record
    //

    memcpy(
        & precord->Data,
        pchData,
        bufLength );

    precord->Data.WINS.dwMappingFlag =
        FlipUnalignedDword( &precord->Data.Wins.dwMappingFlag );
    precord->Data.WINS.dwLookupTimeout =
        FlipUnalignedDword( &precord->Data.Wins.dwLookupTimeout );
    precord->Data.WINS.dwCacheTimeout =
        FlipUnalignedDword( &precord->Data.Wins.dwCacheTimeout );
    precord->Data.WINS.cWinsServerCount =
        FlipUnalignedDword( &precord->Data.Wins.cWinsServerCount );

    return( precord );
}



PDNS_RECORD
Winsr_RecordRead(
    IN OUT  PDNS_RECORD     pRR,
    IN      DNS_CHARSET     OutCharSet,
    IN OUT  PCHAR           pchStart,
    IN      PCHAR           pchData,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Read WINSR record.

Arguments:

    pRR - ptr to record with RR set context

    pchStart - start of DNS message

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
#define SIZEOF_WINSR_FIXED_DATA     (sizeof(DNS_WINSR_DATA)-sizeof(PCHAR))

    PDNS_RECORD precord;
    WORD        bufLength;
    WORD        nameLength;
    CHAR        nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];
    PCHAR       pchstart;
        
    //
    //  read WINSR domain name
    //      - name is after fixed length integer data

    pchstart = pchData;
    pchData += SIZEOF_WINSR_FIXED_DATA;

    pchData = Dns_ReadPacketName(
                    nameBuffer,
                    & nameLength,
                    NULL,
                    NULL,
                    pchData,
                    pchStart,
                    pchEnd );

    if ( pchData != pchEnd )
    {
        DNS_PRINT(( "ERROR:  bad packet name.\n" ));
        SetLastError( DNS_ERROR_INVALID_NAME );
        return( NULL );
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof(DNS_WINSR_DATA);
    bufLength += STR_BUF_SIZE_GIVEN_UTF8_LEN( nameLength, OutCharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return( NULL );
    }

    //
    //  copy fixed data
    //      - copy first so flipping is aligned

    memcpy(
        & precord->Data,
        pchstart,
        SIZEOF_WINSR_FIXED_DATA );
    
    precord->Data.WINSR.dwMappingFlag   = ntohl( precord->Data.WINSR.dwMappingFlag );
    precord->Data.WINSR.dwLookupTimeout = ntohl( precord->Data.WINSR.dwLookupTimeout );
    precord->Data.WINSR.dwCacheTimeout  = ntohl( precord->Data.WINSR.dwCacheTimeout );

    //
    //  write hostname into buffer, immediately following PTR data struct
    //

    precord->Data.WINSR.pNameResultDomain = (PCHAR)&precord->Data + sizeof(DNS_WINSR_DATA);

    Dns_NameCopy(
        precord->Data.WINSR.pNameResultDomain,
        NULL,                           // no buffer length
        nameBuffer,
        nameLength,
        DnsCharSetUtf8,
        OutCharSet
        );

    return( precord );
}



//
//  RR read to packet jump table
//

RR_READ_FUNCTION   RR_ReadTable[] =
{
    NULL,               //  ZERO
    A_RecordRead,       //  A
    Ptr_RecordRead,     //  NS
    Ptr_RecordRead,     //  MD
    Ptr_RecordRead,     //  MF
    Ptr_RecordRead,     //  CNAME
    Soa_RecordRead,     //  SOA
    Ptr_RecordRead,     //  MB
    Ptr_RecordRead,     //  MG
    Ptr_RecordRead,     //  MR
    Flat_RecordRead,    //  NULL
    Wks_RecordRead,     //  WKS
    Ptr_RecordRead,     //  PTR
    Txt_RecordRead,     //  HINFO
    Minfo_RecordRead,   //  MINFO
    Mx_RecordRead,      //  MX
    Txt_RecordRead,     //  TXT
    Minfo_RecordRead,   //  RP
    Mx_RecordRead,      //  AFSDB
    Txt_RecordRead,     //  X25
    Txt_RecordRead,     //  ISDN
    Mx_RecordRead,      //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    NULL,               //  SIG
    NULL,               //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    Flat_RecordRead,    //  AAAA
    NULL,               //  LOC
    NULL,               //  NXT
    NULL,               //  EID   
    NULL,               //  NIMLOC
    Srv_RecordRead,     //  SRV   
    Atma_RecordRead,    //  ATMA  
    NULL,               //  NAPTR 
    NULL,               //  KX    
    NULL,               //  CERT  
    NULL,               //  A6    
    NULL,               //  DNAME 
    NULL,               //  SINK  
    NULL,               //  OPT   
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //
    //  Pseudo record types
    //

    Tkey_RecordRead,    //  TKEY
    Tsig_RecordRead,    //  TSIG

    //
    //  MS only types
    //

    Wins_RecordRead,    //  WINS
    Winsr_RecordRead,   //  WINSR

};

//
//  End rrread.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\rrstrw.c ===
/*++

Copyright (c) 2001-2001  Microsoft Corporation

Module Name:

    rrstrw.c

Abstract:

    Domain Name System (DNS) Library

    Record to string routines.

Author:

    Jim Gilroy (jamesg)     October 2001

Revision History:

--*/


#include "local.h"

//
//  Min string lengths
//      - in chars
//      - includes spacing and terminating NULL
//      - excludes name lengths
//      - they are "rough" lengths
//

#define MIN_SRV_STRING_LENGTH       (20)        //  3*5u
#define MIN_MX_STRING_LENGTH        (10)        //  1*5u
#define MIN_SOA_STRING_LENGTH       (60)        //  5*10u

#define MIN_NAME_LENGTH             (3)         //  space, name, NULL


//
//  String writing context
//
//  Blob to pass through write routines to preserve extensibility.
//  For name\string writing must have access to record charset
//  (so need record).  If we ever want to use in context of
//  zone file writing then would need zone context info.
//

typedef struct _RecordStringWriteContext
{
    PDNS_RECORD     pRecord;
    PSTR            pZoneName;
    DWORD           Flags;
    DNS_CHARSET     CharSet;
}
STR_WRITE_CONTEXT, *PSTR_WRITE_CONTEXT;



//
//  Private prototypes
//



//
//  Record to string utilities
//

PCHAR
WriteRecordDataNameToString(
    IN OUT  PCHAR               pBuf,
    IN      PCHAR               pBufEnd,
    IN      PCHAR               pString,
    IN      PSTR_WRITE_CONTEXT  pContext
    )
/*++

Routine Description:

    Write record name\string to string.

Arguments:

    pBuf - position in to write record

    pBufEnd - end of buffer

    pString - record name\string

    pContext - write context

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    DWORD   count;
    DWORD   length = (DWORD) (pBufEnd - pBuf);

    count = Dns_StringCopy(
                pBuf,
                & length,
                pString,
                0,          // string length unknown
                RECORD_CHARSET( pContext->pRecord ),
                pContext->CharSet
                );

    if ( count )
    {
        return  pBuf+count-1;
    }
    else
    {
        return  NULL;
    }
}




//
//  Record to string type specific functions
//

PCHAR
A_StringWrite(
    IN      PDNS_RECORD     pRR,
    IN OUT  PCHAR           pBuf,
    IN      PCHAR           pBufEnd,
    IN      PVOID           pContext
    )
/*++

Routine Description:

    Write A record.

Arguments:

    pRR - ptr to database record

    pBuf - position in to write record

    pBufEnd - end of buffer

    pContext - write context

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    //if ( pRecord->wDataLength != sizeof(IP_ADDRESS) )
    //{
    //    return  NULL;
    //}
    if ( pBufEnd - pBuf < IP4_ADDRESS_STRING_BUFFER_LENGTH )
    {
        return  NULL;
    }

    pBuf += sprintf(
                pBuf,
                "%d.%d.%d.%d",
                * ( (PUCHAR) &(pRR->Data.A) + 0 ),
                * ( (PUCHAR) &(pRR->Data.A) + 1 ),
                * ( (PUCHAR) &(pRR->Data.A) + 2 ),
                * ( (PUCHAR) &(pRR->Data.A) + 3 )
                );

    return( pBuf );
}



PCHAR
Aaaa_StringWrite(
    IN      PDNS_RECORD     pRR,
    IN OUT  PCHAR           pBuf,
    IN      PCHAR           pBufEnd,
    IN      PVOID           pContext
    )
/*++

Routine Description:

    Write AAAA record.

Arguments:

    pRR - ptr to database record

    pBuf - position in to write record

    pBufEnd - end of buffer

    pContext - write context

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    if ( pBufEnd - pBuf < IP6_ADDRESS_STRING_BUFFER_LENGTH )
    {
        return  NULL;
    }

    pBuf = Dns_Ip6AddressToString_A(
                pBuf,
                & pRR->Data.AAAA.Ip6Address );

    ASSERT( pBuf );
    return( pBuf );
}



PCHAR
Ptr_StringWrite(
    IN      PDNS_RECORD     pRR,
    IN OUT  PCHAR           pBuf,
    IN      PCHAR           pBufEnd,
    IN      PVOID           pContext
    )
/*++

Routine Description:

    Write PTR compatible record.
    Includes: PTR, NS, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRR - ptr to database record

    pBuf - position in to write record

    pBufEnd - end of buffer

    pContext - write context

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    //  target host

    return  WriteRecordDataNameToString(
                pBuf,
                pBufEnd,
                pRR->Data.PTR.pNameHost,
                pContext );
}



PCHAR
Mx_StringWrite(
    IN      PDNS_RECORD     pRR,
    IN OUT  PCHAR           pBuf,
    IN      PCHAR           pBufEnd,
    IN      PVOID           pContext
    )
/*++

Routine Description:

    Write SRV record.

Arguments:

    pRR - ptr to database record

    pBuf - position in to write record

    pBufEnd - end of buffer

    pContext - write context

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    //  fixed fields

    if ( pBufEnd - pBuf < 7 )
    {
        return  NULL;
    }
    pBuf += sprintf(
                pBuf,
                "%d ",
                pRR->Data.MX.wPreference
                );

    //  target host

    return  WriteRecordDataNameToString(
                pBuf,
                pBufEnd,
                pRR->Data.MX.pNameExchange,
                pContext );
}



PCHAR
Srv_StringWrite(
    IN      PDNS_RECORD     pRR,
    IN OUT  PCHAR           pBuf,
    IN      PCHAR           pBufEnd,
    IN      PVOID           pContext
    )
/*++

Routine Description:

    Write SRV record.

Arguments:

    pRR - ptr to database record

    pBuf - position in to write record

    pBufEnd - end of buffer

    pContext - write context

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    //  fixed fields

    if ( pBufEnd - pBuf < MIN_SRV_STRING_LENGTH )
    {
        return  NULL;
    }
    pBuf += sprintf(
                pBuf,
                "%d %d %d ",
                pRR->Data.SRV.wPriority,
                pRR->Data.SRV.wWeight,
                pRR->Data.SRV.wPort
                );

    //  target host

    return  WriteRecordDataNameToString(
                pBuf,
                pBufEnd,
                pRR->Data.SRV.pNameTarget,
                pContext );
}



PCHAR
Soa_StringWrite(
    IN      PDNS_RECORD     pRR,
    IN OUT  PCHAR           pBuf,
    IN      PCHAR           pBufEnd,
    IN      PVOID           pContext
    )
/*++

Routine Description:

    Write SOA record.

Arguments:

    pRR - ptr to database record

    pBuf - position in to write record

    pBufEnd - end of buffer

    pContext - write context

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    //  primary server

    pBuf = WriteRecordDataNameToString(
                pBuf,
                pBufEnd,
                pRR->Data.SOA.pNamePrimaryServer,
                pContext );

    if ( !pBuf ||
        pBufEnd - pBuf < MIN_SOA_STRING_LENGTH )
    {
        return  NULL;
    }

    //  admin

    pBuf += sprintf( pBuf, " " );

    pBuf = WriteRecordDataNameToString(
                pBuf,
                pBufEnd,
                pRR->Data.SOA.pNameAdministrator,
                pContext );

    if ( !pBuf ||
        pBufEnd - pBuf < MIN_SOA_STRING_LENGTH )
    {
        return  NULL;
    }

    //  fixed fields

    pBuf += sprintf(
                pBuf,
                " %u %u %u %u %u",
                pRR->Data.SOA.dwSerialNo,
                pRR->Data.SOA.dwRefresh,
                pRR->Data.SOA.dwRetry,
                pRR->Data.SOA.dwExpire,
                pRR->Data.SOA.dwDefaultTtl
                );

    return( pBuf );
}



PCHAR
Minfo_StringWrite(
    IN      PDNS_RECORD     pRR,
    IN OUT  PCHAR           pBuf,
    IN      PCHAR           pBufEnd,
    IN      PVOID           pContext
    )
/*++

Routine Description:

    Write MINFO type record.

Arguments:

    pRR - ptr to database record

    pBuf - position in to write record

    pBufEnd - end of buffer

    pContext - write context

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    //  primary server

    pBuf = WriteRecordDataNameToString(
                pBuf,
                pBufEnd,
                pRR->Data.MINFO.pNameMailbox,
                pContext );

    if ( !pBuf ||
        pBufEnd - pBuf < MIN_NAME_LENGTH + 1 )
    {
        return  NULL;
    }

    //  admin

    pBuf += sprintf( pBuf, " " );

    pBuf = WriteRecordDataNameToString(
                pBuf,
                pBufEnd,
                pRR->Data.MINFO.pNameErrorsMailbox,
                pContext );

    return  pBuf;
}



PCHAR
Txt_StringWrite(
    IN      PDNS_RECORD     pRR,
    IN OUT  PCHAR           pBuf,
    IN      PCHAR           pBufEnd,
    IN      PVOID           pContext
    )
/*++

Routine Description:

    Write TXT record.
    Includes: TXT, X25, HINFO, ISDN

Arguments:

    pRR - ptr to database record

    pBuf - position in to write record

    pBufEnd - end of buffer

    pContext - write context

Return Value:

    Ptr to next location in buffer.
    NULL if out of space in buffer.

--*/
{
    PSTR *  ppstring;
    INT     i;
    INT     count;

    //
    //  loop through all strings in count
    //

    count = pRR->Data.TXT.dwStringCount;
    ppstring = pRR->Data.TXT.pStringArray;

    for( i=0; i<count; i++ )
    {
        //  separator

        if ( i > 0 )
        {
            if ( pBufEnd - pBuf < MIN_NAME_LENGTH + 1 )
            {
                return  NULL;
            }
            pBuf += sprintf( pBuf, " " );
        }

        //  string

        pBuf = WriteRecordDataNameToString(
                    pBuf,
                    pBufEnd,
                    *ppstring,
                    pContext );
        ppstring++;

        if ( !pBuf );
        {
            break;
        }
    }

    return  pBuf;
}




//
//  Write RR to file dispatch table
//

typedef PCHAR (* RR_STRING_WRITE_FUNCTION)(
                            PDNS_RECORD,
                            PCHAR,
                            PCHAR,
                            PVOID );

RR_STRING_WRITE_FUNCTION   RR_StringWriteTable[] =
{
    //RawRecord_StringWrite,  //  ZERO -- default for unknown types
    NULL,

    A_StringWrite,          //  A
    Ptr_StringWrite,        //  NS
    Ptr_StringWrite,        //  MD
    Ptr_StringWrite,        //  MF
    Ptr_StringWrite,        //  CNAME
    Soa_StringWrite,        //  SOA
    Ptr_StringWrite,        //  MB
    Ptr_StringWrite,        //  MG
    Ptr_StringWrite,        //  MR
    //RawRecord_StringWrite,  //  NULL
    NULL,                   //  NULL
    NULL,                   //  WKS
    Ptr_StringWrite,        //  PTR
    Txt_StringWrite,        //  HINFO
    Minfo_StringWrite,      //  MINFO
    Mx_StringWrite,         //  MX
    Txt_StringWrite,        //  TXT
    Minfo_StringWrite,      //  RP
    Mx_StringWrite,         //  AFSDB
    Txt_StringWrite,        //  X25
    Txt_StringWrite,        //  ISDN
    Mx_StringWrite,         //  RT
    NULL,                   //  NSAP
    NULL,                   //  NSAPPTR
    NULL,                   //  SIG
    NULL,                   //  KEY
    NULL,                   //  PX
    NULL,                   //  GPOS
    Aaaa_StringWrite,       //  AAAA
    NULL,                   //  LOC
    NULL,                   //  NXT
    NULL,                   //  EID   
    NULL,                   //  NIMLOC
    Srv_StringWrite,        //  SRV
    NULL,                   //  ATMA  
    NULL,                   //  NAPTR 
    NULL,                   //  KX    
    NULL,                   //  CERT  
    NULL,                   //  A6    
    NULL,                   //  DNAME 
    NULL,                   //  SINK  
    NULL,                   //  OPT   
    NULL,                   //  42
    NULL,                   //  43
    NULL,                   //  44
    NULL,                   //  45
    NULL,                   //  46
    NULL,                   //  47
    NULL,                   //  48
                            
    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    NULL,                   //  WINS
    NULL                    //  WINS-R
};




//
//  Record to string functions.
//

DNS_STATUS
Dns_WriteRecordToString(
    OUT     PCHAR           pBuffer,
    IN      DWORD           BufferLength,
    IN      PDNS_RECORD     pRecord,
    IN      DNS_CHARSET     CharSet,
    IN      DWORD           Flags
    )
/*++

Routine Description:

    Write record to string.

Arguments:

    pBuffer -- string buffer to write to

    BufferLength -- buffer length (bytes)

    pRecord -- record to print

    CharSet -- char set for string

    Flags -- flags

Return Value:

    NO_ERROR if successful.
    ErrorCode on failure:
        ERROR_INSUFFICIENT_BUFFER -- buffer too small.
        ERROR_INVALID_DATA -- bad record.

--*/
{
    DNS_STATUS          status = NO_ERROR;
    PCHAR               pch = pBuffer;
    PCHAR               pend = pBuffer + BufferLength;
    WORD                type = pRecord->wType;
    DWORD               index;
    CHAR                typeNameBuf[ MAX_RECORD_NAME_LENGTH+1 ];
    STR_WRITE_CONTEXT   context;


    //
    //  validity check
    //

    if ( !pRecord )
    {
        return  ERROR_INVALID_DATA;
    }

    //
    //  DCR:  currently can only write narrow char set record strings
    //

    if ( CharSet == DnsCharSetUnicode )
    {
        return  ERROR_INVALID_DATA;
    }

    //  setup context

    RtlZeroMemory( &context, sizeof(context) );
    context.pRecord = pRecord;
    context.Flags   = Flags;
    context.CharSet = CharSet;

    //
    //  print record name
    //

    pch = WriteRecordDataNameToString(
                pch,
                pend,
                pRecord->pName,
                & context );

    //
    //  write record type
    //

    if ( !pch  ||  pend-pch < MAX_RECORD_NAME_LENGTH+1 )
    {
        status = ERROR_INSUFFICIENT_BUFFER;
        goto Done;
    }
    Dns_WriteStringForType_A(
          typeNameBuf,
          type );
    
    pch += sprintf(
                pch,
                " %s ",
                typeNameBuf );

    //
    //  write no-exist record?
    //

    if ( !pRecord->wDataLength )
    {
        if ( pend-pch < MAX_RECORD_NAME_LENGTH+1 )
        {
            status = ERROR_INSUFFICIENT_BUFFER;
            goto Done;
        }
        pch += sprintf( pch, "NOEXIST" );
        status = NO_ERROR;
        goto Done;
    }

    //
    //  write data
    //

    index = INDEX_FOR_TYPE( type );
    DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

    if ( index  &&  RR_StringWriteTable[index] )
    {
        pch = RR_StringWriteTable[index](
                    pRecord,
                    pch,
                    pend,
                    & context
                    );
        if ( !pch )
        {
            //status = GetLastError();
            status = ERROR_INSUFFICIENT_BUFFER;
        }
    }
    else //if ( !index )
    {
        //  DCR:  could do an unknown type print

        status = ERROR_INVALID_DATA;
        goto Done;
    }

Done:

    DNSDBG( WRITE, (
        "Leaving Dns_WriteRecordToString() => %d\n"
        "\tstring = %s\n",
        status,
        (status == NO_ERROR)
            ? pBuffer
            : "" ));

    return  status;
}



PDNS_RECORD
Dns_CreateRecordFromString(
    IN      PSTR            pString,
    IN      DNS_CHARSET     CharSet,
    IN      DWORD           Flags
    )
/*++

Routine Description:

    Create record from string.

Arguments:

    pString -- record string to parse

    CharSet -- char set of result

    Flags -- flags

Return Value:

    Ptr to record if successful.
    Null on failure.  GetLastError() returns error.

--*/
{
    SetLastError( ERROR_CALL_NOT_IMPLEMENTED );
    return  NULL;
}

//
//  End rrstrw.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\rrwrite.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    rrwrite.c

Abstract:

    Domain Name System (DNS) Library

    Write resource record to packet routines.

Author:

    Jim Gilroy (jamesg)     January, 1997

Revision History:

--*/


#include "local.h"




PCHAR
A_RecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write A record data to packet.

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    if ( pch + sizeof(IP4_ADDRESS) > pchEnd )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }

    *(UNALIGNED DWORD *) pch = pRR->Data.A.IpAddress;

    return ( pch + sizeof(IP4_ADDRESS) );
}



PCHAR
Ptr_RecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write PTR compatible record data to packet.
    Includes: PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    //
    //  write name to packet
    //      - no compression in data
    //

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pchEnd,
                pRR->Data.PTR.pNameHost,
                NULL,
                0,
                IS_UNICODE_RECORD(pRR) );
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
    }
    return( pch );
}



PCHAR
Soa_RecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write SOA compatible to wire.

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    PCHAR   pchdone;
    PDWORD  pdword;

    //
    //  SOA names: primary server, responsible party
    //

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pchEnd,
                pRR->Data.SOA.pNamePrimaryServer,
                NULL,
                0,
                IS_UNICODE_RECORD(pRR) );
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }
    pch = Dns_WriteDottedNameToPacket(
                pch,
                pchEnd,
                pRR->Data.SOA.pNameAdministrator,
                NULL,
                0,
                IS_UNICODE_RECORD(pRR) );
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }

    //
    //  SOA integer fields
    //

    pchdone = pch + SIZEOF_SOA_FIXED_DATA;
    if ( pchdone > pchEnd )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }

    pdword = &pRR->Data.SOA.dwSerialNo;
    while( pch < pchdone )
    {
        *(UNALIGNED DWORD *) pch = htonl( *pdword++ );
        pch += sizeof( DWORD );
    }
    return( pch );
}



PCHAR
Mx_RecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write MX compatible record to wire.
    Includes: MX, RT, AFSDB

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    //
    //  MX preference value
    //  RT preference
    //  AFSDB subtype
    //

    if ( pch + sizeof(WORD) > pchEnd )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }
    *(UNALIGNED WORD *) pch = htons( pRR->Data.MX.wPreference );
    pch += sizeof( WORD );

    //
    //  MX exchange
    //  RT exchange
    //  AFSDB hostname
    //

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pchEnd,
                pRR->Data.MX.pNameExchange,
                NULL,
                0,
                IS_UNICODE_RECORD(pRR) );
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
    }
    return( pch );
}



PCHAR
Txt_RecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write TXT compatible record to wire.
    Includes: TXT, HINFO, ISDN, X25 types.

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    WORD    i;
    PCHAR * ppstring;

    //
    //  write all available text strings
    //

    i = (WORD) pRR->Data.TXT.dwStringCount;

    if ( ! Dns_IsStringCountValidForTextType( pRR->wType, i ) )
    {
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }

    ppstring = pRR->Data.TXT.pStringArray;
    while ( i-- )
    {
        pch = Dns_WriteStringToPacket(
                pch,
                pchEnd,
                *ppstring,
                IS_UNICODE_RECORD(pRR) );
        if ( !pch )
        {
            SetLastError( ERROR_MORE_DATA );
            break;
        }
        ppstring++;
    }
    return( pch );
}



PCHAR
Hinfo_RecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write HINFO (string like) record to wire.
    Includes: HINFO, ISDN, X25 types.

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    WORD    i;
    PCHAR * ppstring;

    //
    //  write all available text strings
    //
    //  DCR:  ISDN HINFO write -- not sure works
    //      not sure this works, because NULL may need to
    //      be written for ISDN or even HINFO
    //

    i = 2;
    if ( pRR->wType == DNS_TYPE_X25 )
    {
        i=1;
    }

    ppstring = (PSTR *) & pRR->Data.TXT;
    while ( i-- )
    {
        if ( ! *ppstring )
        {
            break;
        }
        pch = Dns_WriteStringToPacket(
                pch,
                pchEnd,
                *ppstring,
                IS_UNICODE_RECORD(pRR) );
        if ( !pch )
        {
            SetLastError( ERROR_MORE_DATA );
            break;
        }
        ppstring++;
    }
    return( pch );
}



PCHAR
Minfo_RecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write MINFO compatible to wire.
    Includes MINFO and RP types.

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    //
    //  MINFO responsible mailbox
    //  RP responsible person mailbox

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pchEnd,
                pRR->Data.MINFO.pNameMailbox,
                NULL,
                0,
                IS_UNICODE_RECORD(pRR) );
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }

    //
    //  MINFO errors to mailbox
    //  RP text RR location

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pchEnd,
                pRR->Data.MINFO.pNameErrorsMailbox,
                NULL,
                0,
                IS_UNICODE_RECORD(pRR) );
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }

    return( pch );
}



PCHAR
Flat_RecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write flat record type data to packet.
    Flat types include:
        AAAA
        WINS

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    WORD    length = pRR->wDataLength;

    if ( pch + length > pchEnd )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }

    memcpy(
        pch,
        (PCHAR)&pRR->Data,
        length );

    pch += length;
    return( pch );
}



PCHAR
Srv_RecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write SRV record to wire.

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    PCHAR   pchname;
    PWORD   pword;

    //
    //  SRV integer values
    //

    pchname = pch + SIZEOF_SRV_FIXED_DATA;
    if ( pchname > pchEnd )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }
    pword = &pRR->Data.SRV.wPriority;
    while ( pch < pchname )
    {
        *(UNALIGNED WORD *) pch = htons( *pword++ );
        pch += sizeof(WORD);
    }

    //
    //  SRV target host
    //

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pchEnd,
                pRR->Data.SRV.pNameTarget,
                NULL,
                0,
                IS_UNICODE_RECORD(pRR) );
    if ( !pch )
    {
        SetLastError( ERROR_MORE_DATA );
    }
    return( pch );
}


PCHAR
Atma_RecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
/*++

Routine Description:

    Write ATMA record to wire.

Arguments:

    pRR - ptr to record to write

    pch - ptr to position in buffer to write

    pchEnd - end of buffer position

Return Value:

    Ptr to next byte in buffer to write.
    NULL on error.  (Error code through GetLastError())

--*/
{
    PBYTE  pbyte;

    //
    //  ATMA integer values
    //

    if ( ( pch + sizeof( DNS_ATMA_DATA ) + DNS_ATMA_MAX_ADDR_LENGTH ) >
         pchEnd )
    {
        SetLastError( ERROR_MORE_DATA );
        return( NULL );
    }

    pbyte = &pRR->Data.ATMA.AddressType;
    *(BYTE *) pch = *pbyte;
    pch += sizeof( BYTE );

    //
    // write ATMA address
    //
    memcpy( pch,
            (PCHAR)&pRR->Data.ATMA.Address,
            pRR->wDataLength );

    pch += pRR->wDataLength;

    return( pch );
}


//
//  stubs until read to go
//

PCHAR
Tkey_RecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
{
    return( NULL );
}

PCHAR
Tsig_RecordWrite(
    IN OUT  PDNS_RECORD     pRR,
    IN      PCHAR           pch,
    IN      PCHAR           pchEnd
    )
{
    return( NULL );
}




//
//  RR write to packet jump table
//

RR_WRITE_FUNCTION   RR_WriteTable[] =
{
    NULL,               //  ZERO
    A_RecordWrite,      //  A
    Ptr_RecordWrite,    //  NS
    Ptr_RecordWrite,    //  MD
    Ptr_RecordWrite,    //  MF
    Ptr_RecordWrite,    //  CNAME
    Soa_RecordWrite,    //  SOA
    Ptr_RecordWrite,    //  MB
    Ptr_RecordWrite,    //  MG
    Ptr_RecordWrite,    //  MR
    NULL,               //  NULL
    NULL,   //Wks_RecordWrite,     //  WKS
    Ptr_RecordWrite,    //  PTR
    Txt_RecordWrite,    //  HINFO
    Minfo_RecordWrite,  //  MINFO
    Mx_RecordWrite,     //  MX
    Txt_RecordWrite,    //  TXT
    Minfo_RecordWrite,  //  RP
    Mx_RecordWrite,     //  AFSDB
    Txt_RecordWrite,    //  X25
    Txt_RecordWrite,    //  ISDN
    Mx_RecordWrite,     //  RT
    NULL,               //  NSAP
    NULL,               //  NSAPPTR
    NULL,               //  SIG
    NULL,               //  KEY
    NULL,               //  PX
    NULL,               //  GPOS
    Flat_RecordWrite,   //  AAAA
    NULL,               //  LOC
    NULL,               //  NXT
    NULL,               //  EID   
    NULL,               //  NIMLOC
    Srv_RecordWrite,    //  SRV   
    Atma_RecordWrite,   //  ATMA  
    NULL,               //  NAPTR 
    NULL,               //  KX    
    NULL,               //  CERT  
    NULL,               //  A6    
    NULL,               //  DNAME 
    NULL,               //  SINK  
    NULL,               //  OPT   
    NULL,               //  42
    NULL,               //  43
    NULL,               //  44
    NULL,               //  45
    NULL,               //  46
    NULL,               //  47
    NULL,               //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //
    //  Pseudo record types
    //

    Tkey_RecordWrite,   //  TKEY
    Tsig_RecordWrite,   //  TSIG

    //
    //  MS only types
    //

    Flat_RecordWrite,   //  WINS
    NULL,               //  WINSR
};

//
//  End rrwire.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\straddr.c ===
/*++

Copyright (c) 1996-2002 Microsoft Corporation

Module Name:

    straddr.c

Abstract:

    Domain Name System (DNS) Library

    Routines to string to\from address conversions.

Author:

    Jim Gilroy (jamesg)     December 1996

Revision History:

    jamesg      June 2000       New IP6 parsing.
    jamesg      Oct 2000        Created this module.

--*/


#include "local.h"
#include "ws2tcpip.h"   // IP6 inaddr definitions




//
//  String to address
//

BOOL
Dns_Ip6StringToAddress_A(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCSTR           pString
    )
/*++

Routine Description:

    Convert string to IP6 address.

Arguments:

    pAddress -- ptr to IP6 address to be filled in

    pString -- string with IP6 address

Return Value:

    TRUE if successful.
    FALSE otherwise.

--*/
{
    DNS_STATUS  status;
    PCHAR       pstringEnd = NULL;


    DNSDBG( PARSE2, (
        "Dns_Ip6StringToAddress_A( %s )\n",
        pString ));

    //
    //  convert to IP6 address
    //

    status = RtlIpv6StringToAddressA(
                pString,
                & pstringEnd,
                (PIN6_ADDR) pIp6Addr );

    return( status == NO_ERROR  &&  *pstringEnd==0 );
}



BOOL
Dns_Ip6StringToAddressEx_A(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCSTR           pchString,
    IN      DWORD           dwStringLength
    )
/*++

Routine Description:

    Convert string to IP6 address.

    This version handles non-NULL-terminated strings
    for DNS server file load.

Arguments:

    pAddress -- ptr to IP6 address to be filled in

    pchString -- string with IP6 address

    dwStringLength -- string length

Return Value:

    TRUE if successful.
    FALSE otherwise.

--*/
{
    CHAR        tempBuf[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];
    PCSTR       pstring;
    
    DNSDBG( PARSE2, (
        "Dns_Ip6StringToAddressEx_A( %.*s )\n"
        "\tpchString = %p\n",
        dwStringLength,
        pchString,
        pchString ));

    //
    //  copy string if given length
    //  if no length assume NULL terminated
    //

    pstring = pchString;

    if ( dwStringLength )
    {
        DWORD   bufLength = IP6_ADDRESS_STRING_BUFFER_LENGTH;

        if ( ! Dns_StringCopy(
                    tempBuf,
                    & bufLength,
                    (PCHAR) pstring,
                    dwStringLength,
                    DnsCharSetAnsi,
                    DnsCharSetAnsi ) )
        {
            return( FALSE );
        }
        pstring = tempBuf;
    }

    //  convert to IP6 address

    return  Dns_Ip6StringToAddress_A(
                pIp6Addr,
                pstring );
}



BOOL
Dns_Ip6StringToAddress_W(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCWSTR          pwString
    )
/*++

Routine Description:

    Build IP6 address from wide string.

Arguments:

    pwString -- unicode IP6 string

    pIp6Addr -- addr to recv IP6 address

Return Value:

    TRUE if successful conversion.
    FALSE on bad string.

--*/
{
    DNS_STATUS  status;
    PWCHAR      pstringEnd = NULL;

    DNSDBG( PARSE2, (
        "Dns_Ip6StringToAddress_W( %S )\n",
        pwString ));

    //
    //  convert to IP6 address
    //

    status = RtlIpv6StringToAddressW(
                pwString,
                & pstringEnd,
                (PIN6_ADDR) pIp6Addr );

    return( status == NO_ERROR  &&  *pstringEnd==0 );
}



BOOL
Dns_Ip4StringToAddress_A(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCSTR           pString
    )
/*++

Routine Description:

    Build IP4 address from narrow string.

Arguments:

    pIp4Addr -- addr to recv IP6 address

    pString -- unicode IP4 string

Return Value:

    TRUE if successful conversion.
    FALSE on bad string.

--*/
{
    IP4_ADDRESS ip;

    //  if inet_addr() returns error, verify then error out

    ip = inet_addr( pString );

    if ( ip == INADDR_BROADCAST &&
        strcmp( pString, "255.255.255.255" ) != 0 )
    {
        return( FALSE );
    }

    *pIp4Addr = ip;

    return( TRUE );
}



BOOL
Dns_Ip4StringToAddressEx_A(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCSTR           pchString,
    IN      DWORD           dwStringLength
    )
/*++

Routine Description:

    Build IP4 address from narrow string.

    This version handles non-NULL terminated strings

Arguments:

    pIp4Addr -- addr to recv IP6 address

    pString -- unicode IP4 string

    dwStringLength -- string length; 0 if NULL terminated

Return Value:

    TRUE if successful conversion.
    FALSE on bad string.

--*/
{
    CHAR        tempBuf[ IP4_ADDRESS_STRING_BUFFER_LENGTH ];
    PCSTR       pstring;
    
    DNSDBG( PARSE2, (
        "Dns_Ip4StringToAddressEx_A( %.*s )\n"
        "\tpchString = %p\n",
        dwStringLength,
        pchString,
        pchString ));

    //
    //  copy string if given length
    //  if no length assume NULL terminated
    //

    pstring = pchString;

    if ( dwStringLength )
    {
        DWORD   bufLength = IP4_ADDRESS_STRING_BUFFER_LENGTH;

        if ( ! Dns_StringCopy(
                    tempBuf,
                    & bufLength,
                    (PCHAR) pstring,
                    dwStringLength,
                    DnsCharSetAnsi,
                    DnsCharSetAnsi ) )
        {
            return( FALSE );
        }
        pstring = tempBuf;
    }

    return  Dns_Ip4StringToAddress_A(
                pIp4Addr,
                pstring );
}



BOOL
Dns_Ip4StringToAddress_W(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCWSTR          pwString
    )
/*++

Routine Description:

    Build IP4 address from wide string.

Arguments:

    pIp4Addr -- addr to recv IP6 address

    pwString -- unicode IP6 string

Return Value:

    TRUE if successful conversion.
    FALSE on bad string.

--*/
{
    CHAR        bufAddr[ IP4_ADDRESS_STRING_BUFFER_LENGTH ];
    DWORD       bufLength = IP4_ADDRESS_STRING_BUFFER_LENGTH;

    //  convert to narrow string
    //      - UTF8 quicker and just fine for numeric

    if ( ! Dns_StringCopy(
                bufAddr,
                & bufLength,
                (PCHAR) pwString,
                0,          // length unknown
                DnsCharSetUnicode,
                DnsCharSetUtf8
                ) )
    {
        return( FALSE );
    }

    return  Dns_Ip4StringToAddress_A(
                pIp4Addr,
                bufAddr );
}



//
//  Combined IP4/IP6 string-to-address
//

BOOL
Dns_StringToDnsAddr_W(
    OUT     PDNS_ADDR       pAddr,
    IN      PCWSTR          pString
    )
/*++

Routine Description:

    Build address (IP4 or IP6) from reverse lookup name.

Arguments:

    pAddr -- DNS_ADDR to receive address

    pString -- address string

Return Value:

    TRUE if successful.
    FALSE on error.  GetLastError() for status.

--*/
{
    return  Dns_StringToDnsAddrEx(
                pAddr,
                (PCSTR) pString,
                0,          // any family
                TRUE,       // unicode
                FALSE       // forward
                );
}

BOOL
Dns_StringToDnsAddr_A(
    OUT     PDNS_ADDR       pAddr,
    IN      PCSTR           pString
    )
{
    return  Dns_StringToDnsAddrEx(
                pAddr,
                pString,
                0,          // any family
                FALSE,      // not unicode
                FALSE       // forward
                );
}



BOOL
Dns_StringToAddress_W(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCWSTR          pString,
    IN OUT  PDWORD          pAddrFamily
    )
/*++

Routine Description:

    Build address (IP4 or IP6) from address string.

Arguments:

    pAddrBuf -- buffer to receive address

    pBufLength -- ptr to address length
        input   - length of buffer
        output  - length of address found

    pString -- address string

    pAddrFamily -- ptr to address family
        input   - zero for any family or particular family to check
        output  - family found;  zero if no conversion

Return Value:

    TRUE if successful.
    FALSE on error.  GetLastError() for status.

--*/
{
    return  Dns_StringToAddressEx(
                pAddrBuf,
                pBufLength,
                (PCSTR) pString,
                pAddrFamily,
                TRUE,       // unicode
                FALSE       // forward
                );
}

BOOL
Dns_StringToAddress_A(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCSTR           pString,
    IN OUT  PDWORD          pAddrFamily
    )
{
    return  Dns_StringToAddressEx(
                pAddrBuf,
                pBufLength,
                pString,
                pAddrFamily,
                FALSE,      // ANSI
                FALSE       // forward
                );
}




//
//  Address to string
//

PWCHAR
Dns_Ip6AddressToString_W(
    OUT     PWCHAR          pwString,
    IN      PIP6_ADDRESS    pIp6Addr
    )
/*++

Routine Description:

    Convert IP6 address to string format.

Arguments:

    pwString -- buffer to hold string;  MUST be at least
        IPV6_ADDRESS_STRING_LENGTH+1 in length

    pAddress -- IP6 address to convert to string

Return Value:

    Ptr to next location in buffer (the terminating NULL).

--*/
{
    //  DCR:  could be macro

    return  RtlIpv6AddressToStringW(
                (PIN6_ADDR) pIp6Addr,
                pwString );
}



PCHAR
Dns_Ip6AddressToString_A(
    OUT     PCHAR           pchString,
    IN      PIP6_ADDRESS    pIp6Addr
    )
/*++

Routine Description:

    Convert IP6 address to string format.

Arguments:

    pchString -- buffer to hold string;  MUST be at least
        IPV6_ADDRESS_STRING_LENGTH+1 in length

    pAddress -- IP6 address to convert to string

Return Value:

    Ptr to next location in buffer (the terminating NULL).

--*/
{
    //  DCR:  could be macro

    return  RtlIpv6AddressToStringA(
                (PIN6_ADDR) pIp6Addr,
                pchString );
}



//
//  Address to string -- IP4
//

PWCHAR
Dns_Ip4AddressToString_W(
    OUT     PWCHAR          pwString,
    IN      PIP4_ADDRESS    pIp4Addr
    )
/*++

Routine Description:

    Convert IP4 address to string format.

Arguments:

    pwString -- buffer to hold string;  MUST be at least
        IPV6_ADDRESS_STRING_LENGTH+1 in length

    pAddress -- IP4 address to convert to string

Return Value:

    Ptr to next location in buffer (the terminating NULL).

--*/
{
    IP4_ADDRESS ip = *pIp4Addr;

    //
    //  convert IP4 address to string
    //      - address is in net order, lead byte in low memory
    //

    pwString += wsprintfW(
                    pwString,
                    L"%u.%u.%u.%u",
                    (UCHAR) (ip & 0x000000ff),
                    (UCHAR) ((ip & 0x0000ff00) >> 8),
                    (UCHAR) ((ip & 0x00ff0000) >> 16),
                    (UCHAR) ((ip & 0xff000000) >> 24)
                    );

    return( pwString );
}



PCHAR
Dns_Ip4AddressToString_A(
    OUT     PCHAR           pString,
    IN      PIP4_ADDRESS    pIp4Addr
    )
/*++

Routine Description:

    Convert IP4 address to string format.

Arguments:

    pchString -- buffer to hold string;  MUST be at least
        IPV6_ADDRESS_STRING_LENGTH+1 in length

    pAddress -- IP4 address to convert to string

Return Value:

    Ptr to next location in buffer (the terminating NULL).

--*/
{
    IP4_ADDRESS ip = *pIp4Addr;

    //
    //  convert IP4 address to string
    //      - address is in net order, lead byte in low memory
    //

    pString += sprintf(
                    pString,
                    "%u.%u.%u.%u",
                    (UCHAR) (ip & 0x000000ff),
                    (UCHAR) ((ip & 0x0000ff00) >> 8),
                    (UCHAR) ((ip & 0x00ff0000) >> 16),
                    (UCHAR) ((ip & 0xff000000) >> 24)
                    );

    return( pString );
}



//
//  Address-to-string -- combined IP4/6
//

PCHAR
Dns_AddressToString_A(
    OUT     PCHAR           pchString,
    IN OUT  PDWORD          pStringLength,
    IN      PBYTE           pAddr,
    IN      DWORD           AddrLength,
    IN      DWORD           AddrFamily
    )
/*++

Routine Description:

    Convert address to string format.

Arguments:

    pchString -- buffer to hold string;  MUST be at least
        IPV6_ADDRESS_STRING_LENGTH+1 in length

    pStringLength -- string buffer length

    pAddr -- ptr to address

    AddrLength -- address length

    AddrFamily -- address family (AF_INET, AF_INET6)

Return Value:

    Ptr to next location in buffer (the terminating NULL).
    NULL if no conversion.

--*/
{
    DWORD   length = *pStringLength;

    //  dispatch to conversion routine for this type

    if ( AddrFamily == AF_INET )
    {
        if ( length < IP4_ADDRESS_STRING_LENGTH+1 )
        {
            length = IP4_ADDRESS_STRING_LENGTH+1;
            goto Failed;
        }
        return  Dns_Ip4AddressToString_A(
                    pchString,
                    (PIP4_ADDRESS) pAddr );
    }

    if ( AddrFamily == AF_INET6 )
    {
        if ( length < IP6_ADDRESS_STRING_LENGTH+1 )
        {
            length = IP6_ADDRESS_STRING_LENGTH+1;
            goto Failed;
        }
        return  Dns_Ip6AddressToString_A(
                    pchString,
                    (PIP6_ADDRESS) pAddr );
    }

Failed:

    *pStringLength = length;

    return  NULL;
}




//
//  DNS_ADDR-to-string
//

PCHAR
Dns_DnsAddrToString_A(
    OUT     PCHAR           pBuffer,
    IN OUT  PDWORD          pBufLength,
    IN      PDNS_ADDR       pAddr
    )
/*++

Routine Description:

    Convert address to string format.

Arguments:

    pBuffer -- buffer to hold string;
        if pBufLength not given, then MUST be at least
        IPV6_ADDRESS_STRING_LENGTH+1 in length

    pBufLength -- ptr to string buffer length

    pAddr -- ptr to address

Return Value:

    Ptr to next location in buffer (the terminating NULL).
    NULL if no conversion.

--*/
{
    DNS_STATUS  status;

    //
    //  DCR:  handle no buffer length given -- handles IP6 default?
    //

    //
    //  print support for IP4/IP6
    //

    if ( DnsAddr_IsIp4(pAddr) )
    {
        status = RtlIpv4AddressToStringExA(
                        &pAddr->SockaddrIn.sin_addr,
                        pAddr->SockaddrIn.sin_port,
                        pBuffer,
                        pBufLength );
    }
    else if ( DnsAddr_IsIp6(pAddr) )
    {
        status = RtlIpv6AddressToStringExA(
                        &pAddr->SockaddrIn6.sin6_addr,
                        pAddr->SockaddrIn6.sin6_scope_id,
                        pAddr->SockaddrIn6.sin6_port,
                        pBuffer,
                        pBufLength );
    }
    else
    {
        status = ERROR_INVALID_PARAMETER;

        if ( !pBufLength || *pBufLength > 40 )
        {
            sprintf(
                pBuffer,
                "Invalid DNS_ADDR at %p",
                pAddr );
        }
        pBuffer = NULL;
    }

    //
    //  return ptr to next char in buffer
    //

    if ( status == NO_ERROR )
    {
        pBuffer += *pBufLength;
    }
    else
    {
        pBuffer = NULL;
    }

    return  pBuffer;
}



PWCHAR
Dns_DnsAddrToString_W(
    OUT     PWCHAR          pBuffer,
    IN      PDWORD          pBufLength,
    IN      PDNS_ADDR       pAddr
    )
{
    DNS_STATUS  status;

    //
    //  print support for IP4/IP6
    //

    if ( DnsAddr_IsIp4(pAddr) )
    {
        status = RtlIpv4AddressToStringExW(
                        &pAddr->SockaddrIn.sin_addr,
                        pAddr->SockaddrIn.sin_port,
                        pBuffer,
                        pBufLength );
    }
    else if ( DnsAddr_IsIp6(pAddr) )
    {
        status = RtlIpv6AddressToStringExW(
                        &pAddr->SockaddrIn6.sin6_addr,
                        pAddr->SockaddrIn6.sin6_scope_id,
                        pAddr->SockaddrIn6.sin6_port,
                        pBuffer,
                        pBufLength );
    }
    else
    {
        status = ERROR_INVALID_PARAMETER;

        if ( !pBufLength || *pBufLength > 40 )
        {
            wsprintfW(
                pBuffer,
                L"Invalid DNS_ADDR at %p",
                pAddr );
        }
        pBuffer = NULL;
    }

    //
    //  return ptr to next char in buffer
    //

    if ( status == NO_ERROR )
    {
        pBuffer += *pBufLength;
    }
    else
    {
        pBuffer = NULL;
    }

    return  pBuffer;
}



//
//  Reverse lookup address-to-name IP4
//

PCHAR
Dns_Ip4AddressToReverseName_A(
    OUT     PCHAR           pBuffer,
    IN      IP4_ADDRESS     IpAddress
    )
/*++

Routine Description:

    Write reverse lookup name, given corresponding IP

Arguments:

    pBuffer -- ptr to buffer for reverse lookup name;
        MUST contain at least DNS_MAX_REVERSE_NAME_BUFFER_LENGTH bytes

    IpAddress -- IP address to create

Return Value:

    Ptr to next location in buffer.

--*/
{
    DNSDBG( TRACE, ( "Dns_Ip4AddressToReverseName_A()\n" ));

    //
    //  write digits for each octect in IP address
    //      - note, it is in net order so lowest octect, is in highest memory
    //

    pBuffer += sprintf(
                    pBuffer,
                    "%u.%u.%u.%u.in-addr.arpa.",
                    (UCHAR) ((IpAddress & 0xff000000) >> 24),
                    (UCHAR) ((IpAddress & 0x00ff0000) >> 16),
                    (UCHAR) ((IpAddress & 0x0000ff00) >> 8),
                    (UCHAR) (IpAddress & 0x000000ff) );

    return( pBuffer );
}



PWCHAR
Dns_Ip4AddressToReverseName_W(
    OUT     PWCHAR          pBuffer,
    IN      IP4_ADDRESS     IpAddress
    )
/*++

Routine Description:

    Write reverse lookup name, given corresponding IP

Arguments:

    pBuffer -- ptr to buffer for reverse lookup name;
        MUST contain at least DNS_MAX_REVERSE_NAME_BUFFER_LENGTH wide chars

    IpAddress -- IP address to create

Return Value:

    Ptr to next location in buffer.

--*/
{
    DNSDBG( TRACE, ( "Dns_Ip4AddressToReverseName_W()\n" ));

    //
    //  write digits for each octect in IP address
    //      - note, it is in net order so lowest octect, is in highest memory
    //

    pBuffer += wsprintfW(
                    pBuffer,
                    L"%u.%u.%u.%u.in-addr.arpa.",
                    (UCHAR) ((IpAddress & 0xff000000) >> 24),
                    (UCHAR) ((IpAddress & 0x00ff0000) >> 16),
                    (UCHAR) ((IpAddress & 0x0000ff00) >> 8),
                    (UCHAR) (IpAddress & 0x000000ff) );

    return( pBuffer );
}



PCHAR
Dns_Ip4AddressToReverseNameAlloc_A(
    IN      IP4_ADDRESS     IpAddress
    )
/*++

Routine Description:

    Create reverse lookup name string, given corresponding IP.

    Caller must free the string.

Arguments:

    IpAddress -- IP address to create

Return Value:

    Ptr to new reverse lookup string.

--*/
{
    PCHAR   pch;
    PCHAR   pchend;

    DNSDBG( TRACE, ( "Dns_Ip4AddressToReverseNameAlloc_A()\n" ));

    //
    //  allocate space for string
    //

    pch = ALLOCATE_HEAP( DNS_MAX_REVERSE_NAME_BUFFER_LENGTH );
    if ( !pch )
    {
        return( NULL );
    }

    //
    //  write string for IP
    //

    pchend = Dns_Ip4AddressToReverseName_A( pch, IpAddress );
    if ( !pchend )
    {
        FREE_HEAP( pch );
        return( NULL );
    }

    return( pch );
}



PWCHAR
Dns_Ip4AddressToReverseNameAlloc_W(
    IN      IP4_ADDRESS     IpAddress
    )
/*++

Routine Description:

    Create reverse lookup name string, given corresponding IP.

    Caller must free the string.

Arguments:

    IpAddress -- IP address to create

Return Value:

    Ptr to new reverse lookup string.

--*/
{
    PWCHAR   pch;
    PWCHAR   pchend;

    DNSDBG( TRACE, ( "Dns_Ip4AddressToReverseNameAlloc_W()\n" ));

    //
    //  allocate space for string
    //

    pch = ALLOCATE_HEAP( DNS_MAX_REVERSE_NAME_BUFFER_LENGTH * sizeof(WCHAR) );
    if ( !pch )
    {
        return( NULL );
    }

    //
    //  write string for IP
    //

    pchend = Dns_Ip4AddressToReverseName_W( pch, IpAddress );
    if ( !pchend )
    {
        FREE_HEAP( pch );
        return( NULL );
    }

    return( pch );
}



//
//  Reverse lookup address-to-name -- IP6
//

PCHAR
Dns_Ip6AddressToReverseName_A(
    OUT     PCHAR           pBuffer,
    IN      IP6_ADDRESS     Ip6Addr
    )
/*++

Routine Description:

    Write reverse lookup name, given corresponding IP6 address

Arguments:

    pBuffer -- ptr to buffer for reverse lookup name;
        MUST contain at least DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH bytes

    Ip6Addr -- IP6 address to create reverse string for

Return Value:

    Ptr to next location in buffer.

--*/
{
    DWORD   i;

    DNSDBG( TRACE, ( "Dns_Ip6AddressToReverseName_A()\n" ));

    //
    //  write digit for each nibble in IP6 address
    //
    //  note we are reversing net order here
    //      since address is in net order and we are filling
    //      in least to most significant order
    //      - go DOWN through DWORDS
    //      - go DOWN through the BYTES
    //      - but we must put the lowest (least significant) nibble
    //          first as our bits are not in "bit net order"
    //          which is sending the highest bit in the byte first
    //

#if 0
    i = 4;

    while ( i-- )
    {
        DWORD thisDword = Ip6Address.IP6Dword[i];

        pBuffer += sprintf(
                        pBuffer,
                        "%u.%u.%u.%u.%u.%u.%u.%u.",
                        (thisDword & 0x0f000000) >> 24,
                        (thisDword & 0xf0000000) >> 28,
                        (thisDword & 0x000f0000) >> 16,
                        (thisDword & 0x00f00000) >> 20,
                        (thisDword & 0x00000f00) >>  8,
                        (thisDword & 0x0000f000) >> 12,
                        (thisDword & 0x0000000f)      ,
                        (thisDword & 0x000000f0) >>  4
                        );
    }
#endif
    i = 16;

    while ( i-- )
    {
        BYTE thisByte = Ip6Addr.IP6Byte[i];

        pBuffer += sprintf(
                        pBuffer,
                        "%x.%x.",
                        (thisByte & 0x0f),
                        (thisByte & 0xf0) >> 4
                        );
    }

    pBuffer += sprintf(
                    pBuffer,
                    DNS_IP6_REVERSE_DOMAIN_STRING );

    return( pBuffer );
}



PWCHAR
Dns_Ip6AddressToReverseName_W(
    OUT     PWCHAR          pBuffer,
    IN      IP6_ADDRESS     Ip6Addr
    )
/*++

Routine Description:

    Write reverse lookup name, given corresponding IP6 address

Arguments:

    pBuffer -- ptr to buffer for reverse lookup name;
        MUST contain at least DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH wide chars

    Ip6Addr -- IP6 address to create reverse string for

Return Value:

    Ptr to next location in buffer.

--*/
{
    DWORD   i;

    DNSDBG( TRACE, ( "Dns_Ip6AddressToReverseName_W()\n" ));

    //
    //  write digit for each nibble in IP6 address
    //      - in net order so lowest nibble is in highest memory
    //

    i = 16;

    while ( i-- )
    {
        BYTE thisByte = Ip6Addr.IP6Byte[i];

        pBuffer += wsprintfW(
                        pBuffer,
                        L"%x.%x.",
                        (thisByte & 0x0f),
                        (thisByte & 0xf0) >> 4
                        );
    }

    pBuffer += wsprintfW(
                    pBuffer,
                    DNS_IP6_REVERSE_DOMAIN_STRING_W );

    return( pBuffer );
}



PCHAR
Dns_Ip6AddressToReverseNameAlloc_A(
    IN      IP6_ADDRESS     Ip6Addr
    )
/*++

Routine Description:

    Create reverse lookup name given corresponding IP.

    Caller must free the string.

Arguments:

    Ip6Addr -- IP6 address to create reverse name for

Return Value:

    Ptr to new reverse lookup name string.

--*/
{
    PCHAR   pch;
    PCHAR   pchend;

    DNSDBG( TRACE, ( "Dns_Ip6AddressToReverseNameAlloc_A()\n" ));

    //
    //  allocate space for string
    //

    pch = ALLOCATE_HEAP( DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH );
    if ( !pch )
    {
        return( NULL );
    }

    //
    //  write string for IP
    //

    pchend = Dns_Ip6AddressToReverseName_A( pch, Ip6Addr );
    if ( !pchend )
    {
        FREE_HEAP( pch );
        return( NULL );
    }

    return( pch );
}



PWCHAR
Dns_Ip6AddressToReverseNameAlloc_W(
    IN      IP6_ADDRESS     Ip6Addr
    )
/*++

Routine Description:

    Create reverse lookup name given corresponding IP.

    Caller must free the string.

Arguments:

    Ip6Addr -- IP6 address to create reverse name for

Return Value:

    Ptr to new reverse lookup name string.

--*/
{
    PWCHAR  pch;
    PWCHAR  pchend;

    DNSDBG( TRACE, ( "Dns_Ip6AddressToReverseNameAlloc_W()\n" ));

    //
    //  allocate space for string
    //

    pch = (PWCHAR) ALLOCATE_HEAP(
                    DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH * sizeof(WCHAR) );
    if ( !pch )
    {
        return( NULL );
    }

    //
    //  write string for IP
    //

    pchend = Dns_Ip6AddressToReverseName_W( pch, Ip6Addr );
    if ( !pchend )
    {
        FREE_HEAP( pch );
        return( NULL );
    }

    return( pch );
}



//
//  Reverse name-to-address -- IP4
//

BOOL
Dns_Ip4ReverseNameToAddress_A(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Get IP for reverse lookup name.

Arguments:

    pIp4Addr -- addr to receive IP address if found

    pszName -- name to lookup

Return Value:

    TRUE -- if reverse lookup name converted to IP
    FALSE -- if not IP4 reverse lookup name

--*/
{
#define SIZE_IP4REV  (sizeof(".in-addr.arpa")-1)

    CHAR        nameBuffer[ DNS_MAX_IP4_REVERSE_NAME_BUFFER_LENGTH+1 ];
    DWORD       nameLength;
    IP4_ADDRESS ip;
    PCHAR       pch;
    DWORD       i;
    DWORD       byte;

    DNSDBG( TRACE, (
        "Dns_Ip4ReverseNameToAddress_A( %s )\n",
        pszName ));

    //
    //  validate name
    //  fail if
    //      - too long
    //      - too short
    //      - not in in-addr.arpa domain
    //

    nameLength = strlen( pszName );

    if ( nameLength > DNS_MAX_IP4_REVERSE_NAME_BUFFER_LENGTH )
    {
        return( FALSE );
    }
    if ( pszName[nameLength-1] == '.' )
    {
        nameLength--;
    }
    if ( nameLength <= SIZE_IP4REV )
    {
        return( FALSE );
    }
    nameLength -= SIZE_IP4REV;

    if ( _strnicmp( ".in-addr.arpa", &pszName[nameLength], SIZE_IP4REV ) != 0 )
    {
        return( FALSE );
    }

    //
    //  copy reverse dotted decimal piece of name
    //

    RtlCopyMemory(
        nameBuffer,
        pszName,
        nameLength );

    nameBuffer[nameLength] = 0;

    //
    //  read digits
    //

    ip = 0;
    i = 0;

    pch = nameBuffer + nameLength;

    while ( 1 )
    {
        --pch;

        if ( *pch == '.' )
        {
            *pch = 0;
            pch++;
        }
        else if ( pch == nameBuffer )
        {
        }
        else
        {
            continue;
        }

        //  convert byte

        byte = strtoul( pch, NULL, 10 );
        if ( byte > 255 )
        {
            return( FALSE );
        }
        if ( i > 3 )
        {
            return( FALSE );
        }
        ip |= byte << (8*i);

        //  terminate at string beginning
        //  or continue back up string

        if ( pch == nameBuffer )
        {
            break;
        }
        i++;
        pch--;
    }

    *pIp4Addr = ip;

    DNSDBG( TRACE, (
        "Success on Dns_Ip4ReverseNameToAddress_A( %s ) => %s\n",
        pszName,
        IP4_STRING(ip) ));

    return( TRUE );
}



BOOL
Dns_Ip4ReverseNameToAddress_W(
    OUT     PIP4_ADDRESS    pIp4Addr,
    IN      PCWSTR          pwsName
    )
/*++

Routine Description:

    Get IP for reverse lookup name.

Arguments:

    pIp4Addr -- addr to receive IP address if found

    pszName -- name to lookup

Return Value:

    TRUE -- if reverse lookup name converted to IP
    FALSE -- if not IP4 reverse lookup name

--*/
{
    CHAR        nameBuffer[ DNS_MAX_IP4_REVERSE_NAME_BUFFER_LENGTH+1 ];
    DWORD       bufLength;
    DWORD       nameLengthUtf8;


    DNSDBG( TRACE, (
        "Dns_Ip4ReverseNameToAddress_W( %S )\n",
        pwsName ));

    //
    //  convert to UTF8
    //      - use UTF8 since conversion to it is trivial and it
    //      is identical to ANSI for all reverse lookup names
    //

    bufLength = DNS_MAX_IP4_REVERSE_NAME_BUFFER_LENGTH + 1;

    nameLengthUtf8 = Dns_StringCopy(
                        nameBuffer,
                        & bufLength,
                        (PCHAR) pwsName,
                        0,          // NULL terminated
                        DnsCharSetUnicode,
                        DnsCharSetUtf8 );
    if ( nameLengthUtf8 == 0 )
    {
        return  FALSE;
    }

    //
    //  call ANSI routine to do conversion
    //

    return  Dns_Ip4ReverseNameToAddress_A(
                pIp4Addr,
                (PCSTR) nameBuffer );
}



//
//  Reverse name-to-address -- IP6
//

BOOL
Dns_Ip6ReverseNameToAddress_A(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCSTR           pszName
    )
/*++

Routine Description:

    Get IP6 address for reverse lookup name.

Arguments:

    pIp6Addr -- addr to receive IP address if found

    pszName -- name to lookup

Return Value:

    TRUE -- if reverse lookup name converted to IP
    FALSE -- if not IP4 reverse lookup name

--*/
{
#define SIZE_IP6REV  (sizeof(".ip6.arpa")-1)

    CHAR            nameBuffer[ DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH+1 ];
    DWORD           nameLength;
    PCHAR           pch;
    BYTE            byteArray[16];
    DWORD           byteCount;
    DWORD           nibble;
    DWORD           highNibble;
    BOOL            fisLow;

    DNSDBG( TRACE, ( "Dns_Ip6ReverseNameToAddress_A()\n" ));

    //
    //  validate name
    //  fail if
    //      - too long
    //      - too short
    //      - not in in6.int domain
    //

    nameLength = strlen( pszName );

    if ( nameLength > DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH )
    {
        return( FALSE );
    }
    if ( pszName[nameLength-1] == '.' )
    {
        nameLength--;
    }
    if ( nameLength <= SIZE_IP6REV )
    {
        return( FALSE );
    }
    nameLength -= SIZE_IP6REV;

    if ( _strnicmp( ".ip6.arpa", &pszName[nameLength], SIZE_IP6REV ) != 0 )
    {
        return( FALSE );
    }

    //
    //  copy name
    //

    RtlCopyMemory(
        nameBuffer,
        pszName,
        nameLength );

    nameBuffer[nameLength] = 0;

    //
    //  clear IP6 address
    //      - need for partial reverse lookup name
    //

    RtlZeroMemory(
        byteArray,
        sizeof(byteArray) );

    //
    //  read digits
    //

    byteCount = 0;
    fisLow = FALSE;

    pch = nameBuffer + nameLength;

    while ( 1 )
    {
        if ( byteCount > 15 )
        {
            return( FALSE );
        }

        --pch;

        if ( *pch == '.' )
        {
            *pch = 0;
            pch++;
        }
        else if ( pch == nameBuffer )
        {
        }
        else
        {
            //  DCR:   multi-digit nibbles in reverse name -- error?
            continue;
        }

        //  convert nibble
        //      - zero test special as
        //      A) faster
        //      B) strtoul() uses for error case

        if ( *pch == '0' )
        {
            nibble = 0;
        }
        else
        {
            nibble = strtoul( pch, NULL, 16 );
            if ( nibble == 0 || nibble > 15 )
            {
                return( FALSE );
            }
        }

        //  save high nibble
        //  on low nibble, write byte to IP6 address

        if ( !fisLow )
        {
            highNibble = nibble;
            fisLow = TRUE;
        }
        else
        {
            //byteArray[byteCount++] = (BYTE) (lowNibble | (nibble << 4));

            pIp6Addr->IP6Byte[byteCount++] = (BYTE) ( (highNibble<<4) | nibble );
            fisLow = FALSE;
        }

        //  terminate at string beginning
        //  or continue back up string

        if ( pch == nameBuffer )
        {
            break;
        }
        pch--;
    }

    //*pIp6Addr = *(PIP6_ADDRESS) byteArray;

    DNSDBG( TRACE, (
        "Success on Dns_Ip6ReverseNameToAddress_A( %s )\n",
        pszName ));

    return( TRUE );
}



BOOL
Dns_Ip6ReverseNameToAddress_W(
    OUT     PIP6_ADDRESS    pIp6Addr,
    IN      PCWSTR          pwsName
    )
/*++

Routine Description:

    Get IP for reverse lookup name.

Arguments:

    pIp6Addr -- addr to receive IP address if found

    pszName -- name to lookup

Return Value:

    TRUE -- if reverse lookup name converted to IP
    FALSE -- if not IP6 reverse lookup name

--*/
{
    CHAR        nameBuffer[ DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH+1 ];
    DWORD       bufLength;
    DWORD       nameLengthUtf8;


    DNSDBG( TRACE, (
        "Dns_Ip6ReverseNameToAddress_W( %S )\n",
        pwsName ));

    //
    //  convert to UTF8
    //      - use UTF8 since conversion to it is trivial and it
    //      is identical to ANSI for all reverse lookup names
    //

    bufLength = DNS_MAX_IP6_REVERSE_NAME_BUFFER_LENGTH + 1;

    nameLengthUtf8 = Dns_StringCopy(
                        nameBuffer,
                        & bufLength,
                        (PCHAR) pwsName,
                        0,          // NULL terminated
                        DnsCharSetUnicode,
                        DnsCharSetUtf8 );
    if ( nameLengthUtf8 == 0 )
    {
        return  FALSE;
    }

    //
    //  call ANSI routine to do conversion
    //

    return  Dns_Ip6ReverseNameToAddress_A(
                pIp6Addr,
                (PCSTR) nameBuffer );
}



//
//  Combined IP4/IP6 reverse-name-to-address
//

BOOL
Dns_ReverseNameToDnsAddr_W(
    OUT     PDNS_ADDR       pAddr,
    IN      PCWSTR          pString
    )
/*++

Routine Description:

    Build address (IP4 or IP6) from reverse lookup name.

Arguments:

    pAddr -- DNS_ADDR to receive address

    pString -- address string

Return Value:

    TRUE if successful.
    FALSE on error.  GetLastError() for status.

--*/
{
    return  Dns_StringToDnsAddrEx(
                pAddr,
                (PCSTR) pString,
                0,          // any family
                TRUE,       // unicode
                TRUE        // reverse
                );
}

BOOL
Dns_ReverseNameToDnsAddr_A(
    OUT     PDNS_ADDR       pAddr,
    IN      PCSTR           pString
    )
{
    return  Dns_StringToDnsAddrEx(
                pAddr,
                pString,
                0,          // any family
                FALSE,      // not unicode
                TRUE        // reverse
                );
}

//
//  Could discontinue these and use DnsAddr
//  version as NameToAddress_X version
//

BOOL
Dns_ReverseNameToAddress_W(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCWSTR          pString,
    IN OUT  PDWORD          pAddrFamily
    )
/*++

Routine Description:

    Build address (IP4 or IP6) from reverse lookup name.

Arguments:

    pAddrBuf -- buffer to receive address

    pBufLength -- ptr to address length
        input   - length of buffer
        output  - length of address found

    pString -- address string

    pAddrFamily -- ptr to address family
        input   - zero for any family or particular family to check
        output  - family found;  zero if no conversion

Return Value:

    TRUE if successful.
    FALSE on error.  GetLastError() for status.

--*/
{
    return  Dns_StringToAddressEx(
                pAddrBuf,
                pBufLength,
                (PCSTR) pString,
                pAddrFamily,
                TRUE,       // unicode
                TRUE        // reverse
                );
}

BOOL
Dns_ReverseNameToAddress_A(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCSTR           pString,
    IN OUT  PDWORD          pAddrFamily
    )
{
    return  Dns_StringToAddressEx(
                pAddrBuf,
                pBufLength,
                pString,
                pAddrFamily,
                FALSE,      // ANSI
                TRUE        // reverse
                );
}



//
//  Combined string-to-address private workhorse
//

BOOL
Dns_StringToAddressEx(
    OUT     PCHAR           pAddrBuf,
    IN OUT  PDWORD          pBufLength,
    IN      PCSTR           pString,
    IN OUT  PDWORD          pAddrFamily,
    IN      BOOL            fUnicode,
    IN      BOOL            fReverse
    )
/*++

Routine Description:

    Build address (IP4 or IP6 from string)

    This routine is capable of all string-to-address
    conversions and is the backbone of all the
    combined string-to-address conversion routines.

Arguments:

    pAddrBuf -- buffer to receive address

    pBufLength -- ptr to address length
        input   - length of buffer
        output  - length of address found

    pString -- address string

    pAddrFamily -- ptr to address family
        input   - zero for any family or particular family to check
        output  - family found;  zero if no conversion

    fUnicode -- unicode string

    fReverse -- reverse lookup string

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    DNS_STATUS  status = NO_ERROR;
    DWORD       length = 0;
    INT         family = *pAddrFamily;
    DWORD       bufLength = *pBufLength;
    BOOL        fconvert;
    PCSTR       preverseString;
    CHAR        nameBuffer[ DNS_MAX_REVERSE_NAME_BUFFER_LENGTH+1 ];

    DNSDBG( TRACE, (
        "Dns_StringToAddressEx( %S%s )\n",
        fUnicode ? pString : "",
        fUnicode ? "" : pString ));

    //
    //  convert reverse to ANSI
    //  
    //  reverse lookups are done in ANSI;  convert here to avoid
    //  double string conversion to check both IP4 and IP6
    //

    if ( fReverse )
    {
        preverseString = pString;

        if ( fUnicode )
        {
            DWORD   reverseLength = DNS_MAX_REVERSE_NAME_BUFFER_LENGTH;

            if ( ! Dns_StringCopy(
                        nameBuffer,
                        & reverseLength,
                        (PCHAR) pString,
                        0,          // NULL terminated
                        DnsCharSetUnicode,
                        DnsCharSetUtf8 ) )
            {
                return  FALSE;
            }
            preverseString = nameBuffer;
        }
    }

    //
    //  check IP4
    //

    if ( family == 0 ||
         family == AF_INET )
    {
        IP4_ADDRESS ip;

        if ( fReverse )
        {
            fconvert = Dns_Ip4ReverseNameToAddress_A(
                            & ip,
                            preverseString );
        }
        else
        {
            if ( fUnicode )
            {
                fconvert = Dns_Ip4StringToAddress_W(
                                & ip,
                                (PCWSTR)pString );
            }
            else
            {
                fconvert = Dns_Ip4StringToAddress_A(
                                & ip,
                                pString );
            }
        }
        if ( fconvert )
        {
            length = sizeof(IP4_ADDRESS);
            family = AF_INET;

            if ( bufLength < length )
            {
                status = ERROR_MORE_DATA;
            }
            else
            {
                * (PIP4_ADDRESS) pAddrBuf = ip;
            }

            DNSDBG( INIT2, (
                "Converted string to IP4 address %s\n",
                IP4_STRING(ip) ));
            goto Done;
        }
    }

    //
    //  check IP6
    //

    if ( family == 0 ||
         family == AF_INET6 )
    {
        IP6_ADDRESS ip;

        if ( fReverse )
        {
            fconvert = Dns_Ip6ReverseNameToAddress_A(
                            & ip,
                            preverseString );
        }
        else
        {
            if ( fUnicode )
            {
                fconvert = Dns_Ip6StringToAddress_W(
                                & ip,
                                (PCWSTR)pString );
            }
            else
            {
                fconvert = Dns_Ip6StringToAddress_A(
                                & ip,
                                pString );
            }
        }
        if ( fconvert )
        {
            length = sizeof(IP6_ADDRESS);

            if ( bufLength < length )
            {
                status = ERROR_MORE_DATA;
            }
            else
            {
                family = AF_INET6;
                * (PIP6_ADDRESS) pAddrBuf = ip;
            }

            IF_DNSDBG( INIT2 )
            {
                DnsDbg_Ip6Address(
                    "Converted string to IP6 address: ",
                    (PIP6_ADDRESS) pAddrBuf,
                    "\n" );
            }
            goto Done;
        }
    }

    length = 0;
    family = 0;
    status = DNS_ERROR_INVALID_IP_ADDRESS;

Done:

    if ( status )
    {
        SetLastError( status );
    }

    *pAddrFamily = family;
    *pBufLength = length;

    DNSDBG( TRACE, (
        "Leave Dns_StringToAddressEx()\n"
        "\tstatus   = %d\n"
        "\tptr      = %p\n"
        "\tlength   = %d\n"
        "\tfamily   = %d\n",
        status,
        pAddrBuf,
        length,
        family ));

    return( status==ERROR_SUCCESS );
}



BOOL
Dns_StringToDnsAddrEx(
    OUT     PDNS_ADDR       pAddr,
    IN      PCSTR           pString,
    IN      DWORD           Family,     OPTIONAL
    IN      BOOL            fUnicode,
    IN      BOOL            fReverse
    )
/*++

Routine Description:

    Build address (IP4 or IP6 from string)

    This routine is capable of all string-to-address
    conversions and is the backbone of all the
    combined string-to-address conversion routines.

Arguments:

    pAddr -- ptr to DNS_ADDR to receive address

    pString -- address string

    Family -- if only accepting specific family;  zero for any

    fUnicode -- unicode string

    fReverse -- reverse lookup string

Return Value:

    TRUE if successful.
    FALSE on error.

--*/
{
    DNS_STATUS  status = NO_ERROR;
    DWORD       length = 0;
    BOOL        fconvert;
    PCSTR       preverseString;
    CHAR        nameBuffer[ DNS_MAX_REVERSE_NAME_BUFFER_LENGTH+1 ];

    DNSDBG( TRACE, (
        "Dns_StringToDnsAddrEx( %S%s, rev=%d, unicode=%d )\n",
        fUnicode ? pString : "",
        fUnicode ? "" : pString,
        fReverse,
        fUnicode ));

    //
    //  convert reverse to ANSI
    //  
    //  reverse lookups are done in ANSI;  convert here to avoid
    //  double string conversion to check both IP4 and IP6
    //

    if ( fReverse )
    {
        preverseString = pString;

        if ( fUnicode )
        {
            DWORD   bufLength = DNS_MAX_REVERSE_NAME_BUFFER_LENGTH;

            if ( ! Dns_StringCopy(
                        nameBuffer,
                        & bufLength,
                        (PCHAR) pString,
                        0,          // NULL terminated
                        DnsCharSetUnicode,
                        DnsCharSetUtf8 ) )
            {
                return  FALSE;
            }
            preverseString = nameBuffer;
        }
    }

    //
    //  check IP4
    //

    if ( Family == 0 || Family == AF_INET )
    {
        IP4_ADDRESS ip;

        if ( fReverse )
        {
            fconvert = Dns_Ip4ReverseNameToAddress_A(
                            & ip,
                            preverseString );
        }
        else
        {
            if ( fUnicode )
            {
                fconvert = Dns_Ip4StringToAddress_W(
                                & ip,
                                (PCWSTR)pString );
            }
            else
            {
                fconvert = Dns_Ip4StringToAddress_A(
                                & ip,
                                pString );
            }
        }
        if ( fconvert )
        {
            DnsAddr_BuildFromIp4(
                pAddr,
                ip,
                0   // no port
                );
            DNSDBG( INIT2, (
                "Converted string to IP4 address %s\n",
                IP4_STRING(ip) ));
            goto Done;
        }
    }

    //
    //  check IP6
    //

    if ( Family == 0 || Family == AF_INET6 )
    {
        if ( fReverse )
        {
            IP6_ADDRESS ip;

            fconvert = Dns_Ip6ReverseNameToAddress_A(
                            & ip,
                            preverseString );
            if ( fconvert )
            {
                DnsAddr_BuildFromIp6(
                    pAddr,
                    &ip,
                    0,  // no scope
                    0   // no port
                    );
                IF_DNSDBG( INIT2 )
                {
                    DnsDbg_Ip6Address(
                        "Converted string to IP6 address: ",
                        (PIP6_ADDRESS) &ip,
                        "\n" );
                }
                goto Done;
            }
        }
        else
        {
            DnsAddr_Clear( pAddr );

            if ( fUnicode )
            {
                status = RtlIpv6StringToAddressExW(
                            (PCWSTR) pString,
                            & pAddr->SockaddrIn6.sin6_addr,
                            & pAddr->SockaddrIn6.sin6_scope_id,
                            & pAddr->SockaddrIn6.sin6_port
                            );
            }
            else
            {
                status = RtlIpv6StringToAddressExA(
                            (PCSTR) pString,
                            & pAddr->SockaddrIn6.sin6_addr,
                            & pAddr->SockaddrIn6.sin6_scope_id,
                            & pAddr->SockaddrIn6.sin6_port
                            );
            }
            if ( status == NO_ERROR )
            {
                pAddr->SockaddrIn6.sin6_family = AF_INET6;
                pAddr->SockaddrLength = sizeof(SOCKADDR_IN6);
                goto Done;
            }
        }
    }

    DnsAddr_Clear( pAddr );
    status = DNS_ERROR_INVALID_IP_ADDRESS;

Done:

    if ( status )
    {
        SetLastError( status );
    }

    DNSDBG( TRACE, (
        "Leave Dns_StringToDnsAddrEx()\n"
        "\tstatus   = %d\n",
        status ));

    return( status==ERROR_SUCCESS );
}



//
//  UPNP IP6 literal hack
//

WCHAR   g_Ip6LiteralDomain[] = L".ipv6-literal.net";

DWORD   g_Ip6LiteralDomainSize = sizeof(g_Ip6LiteralDomain);


VOID
Dns_Ip6AddressToLiteralName(
    OUT     PWCHAR          pBuffer,
    IN      PIP6_ADDRESS    pIp6
    )
/*++

Routine Description:

    Write UPNP-hack-literal.

Arguments:

    pBuffer -- ptr to buffer for reverse lookup name;
        MUST contain DNS_MAX_NAME_LENGTH characters.

    pIp6 -- IP6 address to create reverse string for

Return Value:

    None

--*/
{
    DWORD   length;

    DNSDBG( TRACE, ( "Dns_Ip6AddressToLiteralName()\n" ));

    //
    //  convert IP6 to address
    //

    Dns_Ip6AddressToString_W(
        pBuffer,
        pIp6 );

    length = wcslen( pBuffer );

    //
    //  replace all colons with dashes
    //

    String_ReplaceCharW(
        pBuffer,
        L':',
        L'-' );

    //
    //  write ip6 literal domain immediately after
    //

    wcscpy(
        pBuffer + length,
        g_Ip6LiteralDomain );

    DNSDBG( TRACE, (
        "Leave Dns_Ip6AddressToLiteralName() => %S\n",
        pBuffer ));
}



BOOL
Dns_Ip6LiteralNameToAddress(
    OUT     PSOCKADDR_IN6   pSockAddr,
    IN      PCWSTR          pwsString
    )
/*++

Routine Description:

    IP6 literal to IP6 sockaddr.

Arguments:

    pSock6Addr -- address to fill with IP6 corresponding to literal

    pwsString -- literal string

Return Value:

    TRUE if IP6 literal found and convert.
    FALSE if not IP6 literal.

--*/
{
    WCHAR       nameBuf[ DNS_MAX_NAME_LENGTH ];
    DWORD       iter;
    DWORD       length;
    DWORD       size;
    PWCHAR      pch;
    PWCHAR      pdomain;
    DNS_STATUS  status;


    DNSDBG( TRACE, (
        "Dns_Ip6LiteralNameToAddress( %S )\n",
        pwsString ));

    //
    //  test for literal
    //      - test undotted
    //      - test as FQDN
    //      note that even FQDN test is safe, as we insist
    //      that string size is GREATER than literal size
    //  

    length = wcslen( pwsString );
    size = (length+1) * sizeof(WCHAR);

    if ( size <= g_Ip6LiteralDomainSize )
    {
        DNSDBG( INIT2, (
            "Stopped UPNP parse -- short string.\n" ));
        return  FALSE;
    }

    pdomain = (PWSTR) ((PBYTE)pwsString + size - g_Ip6LiteralDomainSize);

    if ( ! RtlEqualMemory(
                pdomain,
                g_Ip6LiteralDomain,
                g_Ip6LiteralDomainSize-sizeof(WCHAR) ) )
    {
        pdomain--;

        if ( pwsString[length-1] != L'.'
                ||
             ! RtlEqualMemory(
                    pdomain,
                    g_Ip6LiteralDomain,
                    g_Ip6LiteralDomainSize-sizeof(WCHAR) ) )
        {
            DNSDBG( INIT2, (
                "Stopped UPNP parse -- no tag match.\n" ));
            return  FALSE;
        }
    }

    //
    //  copy literal to buffer
    //

    if ( length >= DNS_MAX_NAME_LENGTH )
    {
        DNSDBG( INIT2, (
            "Stopped UPNP parse -- big string.\n" ));
        return  FALSE;
    }

    length = (DWORD) ((PWSTR)pdomain - pwsString);

    RtlCopyMemory(
        nameBuf,
        pwsString,
        length*sizeof(WCHAR) );

    nameBuf[ length ] = 0;

    //
    //  replace dashes with colons
    //  replace 's' with % for scope
    //

    String_ReplaceCharW(
        nameBuf,
        L'-',
        L':' );

    String_ReplaceCharW(
        nameBuf,
        L's',
        L'%' );

    DNSDBG( INIT2, (
        "Reconverted IP6 literal %S\n",
        nameBuf ));

    //
    //  convert to IP6 address
    //

    status = RtlIpv6StringToAddressExW(
                (PCWSTR) nameBuf,
                & pSockAddr->sin6_addr,
                & pSockAddr->sin6_scope_id,
                & pSockAddr->sin6_port
                );

    if ( status == NO_ERROR )
    {
        if ( IN6_IS_ADDR_LINKLOCAL( &pSockAddr->sin6_addr )
                ||
             IN6_IS_ADDR_SITELOCAL( &pSockAddr->sin6_addr ) )
        {
            pSockAddr->sin6_flowinfo = 0;
            pSockAddr->sin6_family = AF_INET6;
        }
        else
        {
            status = ERROR_INVALID_PARAMETER;
        }
    }
    return( status == NO_ERROR );
}

//
//  End straddr.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\security.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    security.c

Abstract:

    Domain Name System (DNS) Library

    DNS secure update API.

Author:

    Jim Gilroy (jamesg)         January, 1998

Revision History:

--*/

#include "local.h"

#include "time.h"       // time() function

//  security headers

#define SECURITY_WIN32
#include "sspi.h"
#include "issperr.h"
#include "rpc.h"
#include "rpcndr.h"
#include "ntdsapi.h"

#include "dnssec.h"

//  security definitions

#define SIG_LEN                 33
#define NAME_OWNER              "."         // root node
#define SEC_SUCCESS(Status)     ((Status) >= 0)
#define PACKAGE_NAME            L"negotiate"
#define NT_DLL_NAME             "security.dll"


//
//  Maximum length of data signed
//      - full packet, length, and sig
//
//  If a problem can use packet buffer length and sig length and allocate that
//

#define MAX_SIGNING_SIZE    (0x11000)


//
//  Global Sspi credentials handle
//

SECURITY_INTEGER g_SspiCredentialsLifetime = { 0, 0 };

TimeStamp   g_SspiCredentialsLifetime;

CredHandle  g_hSspiCredentials;

#define SSPI_INVALID_HANDLE(x)  \
        ( ((PSecHandle) (x))->dwLower == (ULONG_PTR) -1 && \
          ((PSecHandle) (x))->dwUpper == (ULONG_PTR) -1 )


//
//  DEV_NOTE:   Security ticket expiration
//
//  Security team is yet unsure about how to use the expiration time &
//  currently tix are valid forever. If it becomes invalid accept/init context
//  will re-nego a new one for us underneath so we should concern ourselves
//  at this point. Still, in principal they say we may need to worry about it
//  in the future...
//

#define SSPI_EXPIRED_HANDLE( x )           ( FALSE )

//
//  Currently only negotiate kerberos
//
//  DCR:  tie this to regkey, then set in init function
//

BOOL    g_NegoKerberosOnly = TRUE;


//
//  Context name uniqueness
//
//  Tick helps insure uniqueness of context name

LONG    g_ContextCount = 0;

//  UUID insures uniqueness across IP reuse

CHAR    g_ContextUuid[ GUID_STRING_BUFFER_LENGTH ] = {0};


//
//  Security context request blob
//

typedef struct _DNS_SECCTXT_REQUEST
{
    PSTR            pszServerName;
    PCHAR           pCredentials;
    PSTR            pszContext;
    DWORD           dwFlag;
    IP4_ADDRESS     ipServer;
    PIP4_ARRAY      aipServer;
}
DNS_SECCTXT_REQUEST, *PDNS_SECCTXT_REQUEST;


//
//  DNS API context
//

typedef struct _DnsAPIContext
{
    DWORD       Flags;
    PVOID       Credentials;
    PSEC_CNTXT  pSecurityContext;
}
DNS_API_CONTEXT, *PDNS_API_CONTEXT;


//
//  TCP timeout
//

#define DEFAULT_TCP_TIMEOUT         10
#define SECURE_UPDATE_TCP_TIMEOUT   (15)


//
//  Public security globals (exposed in dnslib.h)
//

BOOL    g_fSecurityPackageInitialized = FALSE;


//
//  Private security globals
//

HINSTANCE                   g_hLibSecurity;
PSecurityFunctionTableW     g_pSecurityFunctionTable;

DWORD   g_SecurityTokenMaxLength = 0;
DWORD   g_SignatureMaxLength = 0;


//
//  Security context caching
//

PSEC_CNTXT SecurityContextListHead = NULL;

CRITICAL_SECTION    SecurityContextListCS;

DWORD   SecContextCreate = 0;
DWORD   SecContextFree = 0;
DWORD   SecContextQueue = 0;
DWORD   SecContextQueueInNego = 0;
DWORD   SecContextDequeue = 0;
DWORD   SecContextTimeout = 0;

//
//  Security packet info memory tracking
//

DWORD   SecPackAlloc = 0;
DWORD   SecPackFree = 0;

//
//  Security packet verifications
//

DWORD   SecTkeyInvalid          = 0;
DWORD   SecTkeyBadTime          = 0;

DWORD   SecTsigFormerr          = 0;
DWORD   SecTsigEcho             = 0;
DWORD   SecTsigBadKey           = 0;
DWORD   SecTsigVerifySuccess    = 0;
DWORD   SecTsigVerifyFailed     = 0;

//
//  Hacks
//

//  Allowing old TSIG off by default, server can turn on.

BOOL    SecAllowOldTsig         = 0;    // 1 to allow old sigs, 2 any sig

DWORD   SecTsigVerifyOldSig     = 0;
DWORD   SecTsigVerifyOldFailed  = 0;


//
// TIME values
//
// (in seconds)
#define TIME_WEEK_S         604800
#define TIME_DAY_S          86400
#define TIME_10_HOUR_S      36000
#define TIME_8_HOUR_S       28800
#define TIME_4_HOUR_S       14400
#define TIME_HOUR_S         3600
#define TIME_10_MINUTE_S    600
#define TIME_5_MINUTE_S     300
#define TIME_3_MINUTE_S     160
#define TIME_MINUTE_S       60


//  Big Time skew on by default


DWORD   SecBigTimeSkew          = TIME_DAY_S;
DWORD   SecBigTimeSkewBypass    = 0;


//
//  TSIG - GSS alogrithm
//

#define W2K_GSS_ALGORITHM_NAME_PACKET           ("\03gss\011microsoft\03com")
#define W2K_GSS_ALGORITHM_NAME_PACKET_LENGTH    (sizeof(W2K_GSS_ALGORITHM_NAME_PACKET))

#define GSS_ALGORITHM_NAME_PACKET               ("\010gss-tsig")
#define GSS_ALGORITHM_NAME_PACKET_LENGTH        (sizeof(GSS_ALGORITHM_NAME_PACKET))

PCHAR   g_pAlgorithmNameW2K     = W2K_GSS_ALGORITHM_NAME_PACKET;
PCHAR   g_pAlgorithmNameCurrent = GSS_ALGORITHM_NAME_PACKET;

//
//  TKEY context name
//

#define MAX_CONTEXT_NAME_LENGTH     DNS_MAX_NAME_BUFFER_LENGTH

//
//  TKEY/TSIG versioning
//
//  Win2K shipped with some deviations from current the GSS-TSIG RFC.
//  Specifically
//      - alg name was "gss.microsoft.com", new name is "gss-tsig"
//      - client sent TKEY query in Answer section instead of addtional
//      - client would reuse context based on process id, rather than
//          forcing unique context
//      - signing did NOT include length when including previous sig
//      - signing did NOT downcase the context name
//
//  Defining versioning -- strictly internal to this module
//

#define TKEY_VERSION_W2K            3
#define TKEY_VERSION_XP             7

#define TKEY_VERSION_CURRENT        TKEY_VERSION_XP


//
//  TKEY expiration
//      - cleanup if inactive for 3 minutes
//      - max kept alive four hours then must renego
//

#define TKEY_CLEANUP_INTERVAL       (TIME_3_MINUTE_S)

//
//  DCR_FIX:  Nego time issue (GM vs local time)
//
//  Currently netlogon seems to run in GM time, so we limit our time
//  check to one day. Later on, we should move it back to 1 hour.
//

#define TKEY_EXPIRE_INTERVAL        (TIME_DAY_S)
#define TSIG_EXPIRE_INTERVAL        (TIME_10_HOUR_S)

#define TKEY_MAX_EXPIRE_INTERVAL    (TIME_4_HOUR_S)

#define MAX_TIME_SKEW               (TIME_DAY_S)


//
//  ntdsapi.dll loading
//      - for making SPN for DNS server
//

#define NTDSAPI_DLL_NAMEW   L"ntdsapi.dll"
#define MAKE_SPN_FUNC       "DsClientMakeSpnForTargetServerW"

FARPROC g_pfnMakeSpn = NULL;

HMODULE g_hLibNtdsa = NULL;


//
//  Private protos
//

VOID
DnsPrint_SecurityContextList(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      PSTR            pszHeader,
    IN      PSEC_CNTXT      pListHead
    );

VOID
DnsPrint_SecurityContext(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      PSTR            pszHeader,
    IN      PSEC_CNTXT      pSecCtxt
    );

VOID
DnsPrint_SecurityPacketInfo(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      PSTR            pszHeader,
    IN      PSECPACK        pSecPack
    );


#if DBG

#define DnsDbg_SecurityContextList(a,b) DnsPrint_SecurityContextList(DnsPR,NULL,a,b)
#define DnsDbg_SecurityContext(a,b)     DnsPrint_SecurityContext(DnsPR,NULL,a,b)
#define DnsDbg_SecurityPacketInfo(a,b)  DnsPrint_SecurityPacketInfo(DnsPR,NULL,a,b)

#else

#define DnsDbg_SecurityContextList(a,b)
#define DnsDbg_SecurityContext(a,b)
#define DnsDbg_SecurityPacketInfo(a,b)

#endif

#define Dns_FreeSecurityPacketInfo(p)   Dns_CleanupSecurityPacketInfoEx((p),TRUE)
#define Dns_ResetSecurityPacketInfo(p)  Dns_CleanupSecurityPacketInfoEx((p),FALSE)



DNS_STATUS
Dns_LoadNtdsapiProcs(
    VOID
    );

PWSTR
MakeCredKey(
    IN      PCHAR           pCreds
    );

BOOL
CompareCredKeys(
    IN      PWSTR           pwsCredKey1,
    IN      PWSTR           pwsCredKey2
    );

DNS_STATUS
Dns_AcquireCredHandle(
    OUT     PCredHandle     pCredHandle,
    IN      BOOL            fDnsServer,
    IN      PCHAR           pCreds
    );

PCredHandle
getDefaultCredentialsHandle(
    IN      BOOL            fDnsServer
    );



//
//  Security session packet info
//

PSECPACK
Dns_CreateSecurityPacketInfo(
    VOID
    )
/*++

Routine Description:

    Create security packet info structure.

Arguments:

    None.

Return Value:

    Ptr to new zeroed security packet info.

--*/
{
    PSECPACK    psecPack;

    psecPack = (PSECPACK) ALLOCATE_HEAP_ZERO( sizeof(SECPACK) );
    if ( !psecPack )
    {
        return( NULL );
    }
    SecPackAlloc++;

    return( psecPack );
}



VOID
Dns_InitSecurityPacketInfo(
    OUT     PSECPACK        pSecPack,
    IN      PSEC_CNTXT      pSecCtxt
    )
/*++

Routine Description:

    Init security packet info for given context

Arguments:
    
Return Value:

    None.

--*/
{
    //  clear previous info

    RtlZeroMemory(
        pSecPack,
        sizeof(SECPACK) );

    //  set context ptr

    pSecPack->pSecContext = pSecCtxt;
}



VOID
Dns_CleanupSecurityPacketInfoEx(
    IN OUT  PSECPACK        pSecPack,
    IN      BOOL            fFree
    )
/*++

Routine Description:

    Cleans up security packet info.

Arguments:

    pSecPack -- ptr to security packet info to clean up

Return Value:

    None.

--*/
{
    if ( !pSecPack )
    {
        return;
    }

    if ( pSecPack->pszContextName )
    {
        DnsApiFree( pSecPack->pszContextName );
    }

    if ( pSecPack->pTsigRR )
    {
        FREE_HEAP( pSecPack->pTsigRR );
        //Dns_RecordFree( pSecPack->pTsigRR );
    }
    if ( pSecPack->pTkeyRR )
    {
        FREE_HEAP( pSecPack->pTkeyRR );
        //Dns_RecordFree( pSecPack->pTkeyRR );
    }

    if ( pSecPack->pQuerySig )
    {
        FREE_HEAP( pSecPack->pQuerySig );
    }
    if ( pSecPack->LocalBuf.pvBuffer )
    {
        FREE_HEAP( pSecPack->LocalBuf.pvBuffer );
    }

    if ( fFree )
    {
        FREE_HEAP( pSecPack );
        SecPackFree++;
    }
    else
    {
        RtlZeroMemory(
            pSecPack,
            sizeof(SECPACK) );
    }
}



VOID
DnsPrint_SecurityPacketInfo(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      PSTR            pszHeader,
    IN      PSECPACK        pSecPack
    )
{
    if ( !pSecPack )
    {
        PrintRoutine(
            pPrintContext,
            "%s NULL security context\n",
            pszHeader ? pszHeader : "" );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pPrintContext,
        "%s\n"
        "\tptr              = %p\n"
        "\tpSec Context     = %p\n"
        "\tContext Name     = %s\n"
        "\tVersion          = %d\n"
        "\tpTsigRR          = %p\n"
        "\tpTkeyRR          = %p\n"
        "\tExt RCODE        = %d\n"
        "\tremote buf       = %p\n"
        "\t  length         = %d\n"
        "\tlocal buf        = %p\n"
        "\t  length         = %d\n",
        pszHeader ? pszHeader : "Security packet info:",
        pSecPack,
        pSecPack->pSecContext,
        pSecPack->pszContextName,
        pSecPack->TkeyVersion,
        pSecPack->pTsigRR,
        pSecPack->pTkeyRR,
        pSecPack->ExtendedRcode,
        pSecPack->RemoteBuf.pvBuffer,
        pSecPack->RemoteBuf.cbBuffer,
        pSecPack->LocalBuf.pvBuffer,
        pSecPack->LocalBuf.cbBuffer
        );

    DnsPrint_ParsedRecord(
        PrintRoutine,
        pPrintContext,
        "Parsed Security RR",
        & pSecPack->ParsedRR
        );

    if ( pSecPack->pTsigRR )
    {
        DnsPrint_Record(
            PrintRoutine,
            pPrintContext,
            "TSIG RR",
            pSecPack->pTsigRR,
            NULL                // no previous record
            );
    }
    if ( pSecPack->pTkeyRR )
    {
        DnsPrint_Record(
            PrintRoutine,
            pPrintContext,
            "TKEY RR",
            pSecPack->pTkeyRR,
            NULL                // no previous record
            );
    }

    if ( pSecPack->pSecContext )
    {
        DnsPrint_SecurityContext(
            PrintRoutine,
            pPrintContext,
            "Associated Security Context",
            pSecPack->pSecContext
            );
    }

    DnsPrint_Unlock();
}



//
//  Security context routines
//

PSEC_CNTXT
Dns_CreateSecurityContext(
    VOID
    )
/*++

Routine Description:

    Allocate a new security context blob.

Arguments:

    None.

Return Value:

    Ptr to new context.
    NULL on alloc failure.

--*/
{
    PSEC_CNTXT psecCtxt;

    psecCtxt = (PSEC_CNTXT) ALLOCATE_HEAP_ZERO( sizeof(SEC_CNTXT) );
    if ( !psecCtxt )
    {
        return( NULL );
    }
    SecContextCreate++;

    return( psecCtxt );
}



VOID
Dns_FreeSecurityContext(
    IN OUT  PSEC_CNTXT          pSecCtxt
    )
/*++

Routine Description:

    Cleans up security session data.

Arguments:

    pSecCtxt -- handle to context to clean up

Return Value:

    TRUE if successful
    FALSE otherwise

--*/
{
    PSEC_CNTXT   psecCtxt = (PSEC_CNTXT)pSecCtxt;

    if ( !psecCtxt )
    {
        return;
    }

    if ( psecCtxt->Key.pszTkeyName )
    {
        DnsApiFree( psecCtxt->Key.pszTkeyName );
    }
    if ( psecCtxt->Key.pszClientContext )
    {
        FREE_HEAP( psecCtxt->Key.pszClientContext );
    }
    if ( psecCtxt->Key.pwsCredKey )
    {
        FREE_HEAP( psecCtxt->Key.pwsCredKey );
    }
    if ( psecCtxt->fHaveSecHandle )
    {
        g_pSecurityFunctionTable->DeleteSecurityContext( &psecCtxt->hSecHandle );
    }
    if ( psecCtxt->fHaveCredHandle )
    {
        g_pSecurityFunctionTable->FreeCredentialsHandle( &psecCtxt->CredHandle );
    }
    FREE_HEAP( psecCtxt );

    SecContextFree++;
}



//
//  Security context list routines
//
//  Server side may have multiple security sessions active and does
//      not maintain client state on a thread's stack, so must have
//      a list to hold previous session info.
//

PSEC_CNTXT
Dns_DequeueSecurityContextByKey(
    IN      DNS_SECCTXT_KEY     Key,
    IN      BOOL                fComplete
    )
/*++

Routine Description:

    Get security session context from session list based on key.

Arguments:

    Key -- session key

    fComplete -- TRUE if need fully negotiated context
                 FALSE if still in negotiation

Return Value:

    Handle to security session context, if found.
    NULL if no context for key.

--*/
{
    PSEC_CNTXT  pcur;
    PSEC_CNTXT  pback;
    DWORD       currentTime = Dns_GetCurrentTimeInSeconds();

    DNSDBG( SECURITY, (
        "DequeueSecurityContext()\n"
        "\tIP           = %s\n"
        "\tTKEY name    = %s\n"
        "\tcontext name = %s\n"
        "\tcred string  = %S\n",
        DNSADDR_STRING( &Key.RemoteAddr ),
        Key.pszTkeyName,
        Key.pszClientContext,
        Key.pwsCredKey ));

    EnterCriticalSection( &SecurityContextListCS );
    IF_DNSDBG( SECURITY )
    {
        DnsDbg_SecurityContextList(
            "Before Get",
            SecurityContextListHead );
    }

    pback = (PSEC_CNTXT) &SecurityContextListHead;

    while ( pcur = pback->pNext )
    {
        //  if context is stale -- delete it

        if ( pcur->dwCleanupTime < currentTime )
        {
            pback->pNext = pcur->pNext;
            SecContextTimeout++;
            Dns_FreeSecurityContext( pcur );
            continue;
        }

        //  match context to key
        //      - must match IP
        //      - server side must match TKEY name
        //      - client side must match context key

        if ( DnsAddr_IsEqual(
                &Key.RemoteAddr,
                &pcur->Key.RemoteAddr,
                DNSADDR_MATCH_IP )
                &&
             (  ( Key.pszTkeyName &&
                  Dns_NameCompare_UTF8(
                        Key.pszTkeyName,
                        pcur->Key.pszTkeyName ))
                    ||
                ( Key.pszClientContext &&
                  Dns_NameCompare_UTF8(
                        Key.pszClientContext,
                        pcur->Key.pszClientContext )) )
                &&
             CompareCredKeys(
                Key.pwsCredKey,
                pcur->Key.pwsCredKey ) )
        {
            //  if expect completed context, ignore incomplete
            //
            //  DCR:  should dump once RFC compliant

            if ( fComplete && !pcur->fNegoComplete )
            {
                DNSDBG( ANY, (
                    "WARNING:  Requested dequeue security context still in nego!\n"
                    "\tmatching key         %s %s\n"
                    "\tcontext complete     = %d\n"
                    "\trequest fComplete    = %d\n",
                    Key.pszTkeyName,
                    DNSADDR_STRING( &Key.RemoteAddr ),
                    pcur->fNegoComplete,
                    fComplete ));

                pback = pcur;
                continue;
            }

            //  detach context
            //  DCR:  could ref count context and leave in
            //      not sure this adds much -- how many process do MT
            //      updates in same security context

            pback->pNext = pcur->pNext;
            SecContextDequeue++;
            break;
        }

        //  not found -- continue search

        pback = pcur;
    }

    IF_DNSDBG( SECURITY )
    {
        DnsDbg_SecurityContextList(
            "After Dequeue",
            SecurityContextListHead );
    }
    LeaveCriticalSection( &SecurityContextListCS);

    return( pcur );
}



PSEC_CNTXT
Dns_FindOrCreateSecurityContext(
    IN      DNS_SECCTXT_KEY    Key
    )
/*++

Routine Description:

    Find and extract existing security context from list,
        OR
    create a new one.

Arguments:

    Key -- key for context

Return Value:

    Ptr to security context.

--*/
{
    PSEC_CNTXT  psecCtxt;


    DNSDBG( SECURITY, (
        "Dns_FindOrCreateSecurityContext()\n" ));

    //  find existing context

    psecCtxt = Dns_DequeueSecurityContextByKey( Key, FALSE );
    if ( psecCtxt )
    {
        return  psecCtxt;
    }

    //
    //  create context
    //
    //  server's will come with complete TKEY name from packet
    //  client's will come with specific context name, we must
    //      generate globally unique name
    //          - context count
    //          - tick count
    //          - UUID
    //
    //  implementation notes:
    //  -   UUID to make sure we're unique across IP reuse
    //
    //  -   UUID and timer enforce uniqueness across process shutdown
    //      and restart (even if generation UUID fails, you'll be at
    //      a different tick count)
    //
    //  -   context count enforces uniqueness within process
    //      - interlock allows us to eliminate thread id
    //      - even with thread id, we'd still need this anyway
    //      (without interlock) to back up timer since GetTickCount()
    //      is "chunky" and a thread could concievably not "tick"
    //      between contexts on the same thread if they were dropped
    //      before going to the wire
    //
    //

    psecCtxt = Dns_CreateSecurityContext();
    if ( psecCtxt )
    {
        PSTR    pstr;
        PSTR    pnameTkey;
        CHAR    nameBuf[ DNS_MAX_NAME_BUFFER_LENGTH ];

        pnameTkey = Key.pszTkeyName;

        if ( Key.pszClientContext )
        {
            LONG  count = InterlockedIncrement( &g_ContextCount );

            //
            //  Note: it is important that this string is in canonical
            //  form as per RFC 2535 section 8.1 - basically this means
            //  lower case.
            //

            _snprintf(
                nameBuf,
                MAX_CONTEXT_NAME_LENGTH,    
                "%s.%d-%x.%s",
                Key.pszClientContext,
                count,
                GetTickCount(),
                g_ContextUuid );
    
            nameBuf[ DNS_MAX_NAME_LENGTH ] = 0;
            pnameTkey = nameBuf;

            pstr = DnsStringCopyAllocateEx(
                            Key.pszClientContext,
                            0,              //  string length
                            FALSE,          //  Unicode input flag
                            FALSE );        //  Unicode output flag
            if ( !pstr )
            {
                goto Failed;
            }
            psecCtxt->Key.pszClientContext = pstr;
        }

        //  remote IP

        DnsAddr_Copy( &psecCtxt->Key.RemoteAddr, &Key.RemoteAddr );

        //  TKEY name

        pstr = DnsStringCopyAllocateEx( pnameTkey, 0, FALSE, FALSE );
        if ( !pstr )
        {
            goto Failed;
        }
        psecCtxt->Key.pszTkeyName = pstr;

        //  cred key

        if ( Key.pwsCredKey )
        {
            pstr = (PSTR) Dns_CreateStringCopy_W( Key.pwsCredKey );
            if ( !pstr )
            {
                goto Failed;
            }
            psecCtxt->Key.pwsCredKey = (PWSTR) pstr;
        }
    }

    IF_DNSDBG( SECURITY )
    {
        DnsDbg_SecurityContextList(
            "New security context:",
            psecCtxt );
    }
    return( psecCtxt );


Failed:

    //  memory allocation failure
    
    Dns_FreeSecurityContext( psecCtxt );
    return  NULL;
}



VOID
Dns_EnlistSecurityContext(
    IN OUT  PSEC_CNTXT          pSecCtxt
    )
/*++

Routine Description:

    Enlist a security context.
    Note this does NOT create the context it simply enlists a current one.

Arguments:

    Key -- key for context

Return Value:

    Handle to security context.

--*/
{
    PSEC_CNTXT  pnew = (PSEC_CNTXT)pSecCtxt;
    DWORD       currentTime;

    //
    //  catch queuing up some bogus blob
    //

    ASSERT( pnew->dwCreateTime < pnew->dwCleanupTime || pnew->dwCleanupTime == 0 );
    ASSERT( pnew->Key.pszTkeyName );
    //ASSERT( !DnsAddr_IsZero( &pnew->Key.RemoteAddr ) );

    //
    //  reset expire time so keep context active if in use
    //
    //  DCR_FIX:  need expire time to use min of TKEY and fixed hard timeout
    //

    currentTime = Dns_GetCurrentTimeInSeconds();
    if ( !pnew->dwCreateTime )
    {
        pnew->dwCreateTime = currentTime;
    }
    if ( !pnew->dwExpireTime )
    {
        pnew->dwExpireTime = currentTime + TKEY_MAX_EXPIRE_INTERVAL;
    }

    //
    //  cleanup after interval not used
    //  unconditionally maximum of cleanup interval.
    //

    pnew->dwCleanupTime = currentTime + TKEY_CLEANUP_INTERVAL;

    EnterCriticalSection( &SecurityContextListCS );

    pnew->pNext = SecurityContextListHead;
    SecurityContextListHead = pnew;

    SecContextQueue++;
    if ( !pnew->fNegoComplete )
    {
        SecContextQueueInNego++;
    }

    IF_DNSDBG( SECURITY )
    {
        DnsDbg_SecurityContextList(
            "After add",
            SecurityContextListHead );
    }
    LeaveCriticalSection( &SecurityContextListCS );
}



VOID
Dns_TimeoutSecurityContextList(
    IN      BOOL            fClearList
    )
/*++

Routine Description:

    Eliminate old session data.

Arguments:

    fClearList -- TRUE to delete all, FALSE to timeout

Return Value:

    None.

--*/
{
    PSEC_CNTXT  pcur;
    PSEC_CNTXT  pback;
    DWORD       currentTime;

    if ( fClearList )
    {
        currentTime = MAXDWORD;
    }
    else
    {
        currentTime = Dns_GetCurrentTimeInSeconds();
    }

    EnterCriticalSection( &SecurityContextListCS );

    pback = (PSEC_CNTXT) &SecurityContextListHead;

    while ( pcur = pback->pNext )
    {
        //  if haven't reached cleanup time, keep in list

        if ( pcur->dwCleanupTime > currentTime )
        {
            pback = pcur;
            continue;
        }

        //  entry has expired
        //      - cut from list
        //      - free the session context

        pback->pNext = pcur->pNext;

        SecContextTimeout++;
        Dns_FreeSecurityContext( pcur );
    }

    ASSERT( !fClearList || SecurityContextListHead==NULL );

    LeaveCriticalSection( &SecurityContextListCS );
}



VOID
Dns_FreeSecurityContextList(
    VOID
    )
/*++

Routine Description ():

    Free all security contexts in global list

Arguments:

    None

Return Value:

    None

--*/
{
    PSEC_CNTXT  pcur;
    PSEC_CNTXT  ptmp;
    INT         countDelete = 0;

    DNSDBG( SECURITY, (
        "Dns_FreeSecurityContextList()\n" ));

    EnterCriticalSection( &SecurityContextListCS );

    IF_DNSDBG( SECURITY )
    {
        DnsDbg_SecurityContextList(
            "Before Get",
            SecurityContextListHead );
    }

    //  if empty list -- done

    if ( !SecurityContextListHead )
    {
        DNSDBG( SECURITY, (
            "Attempt to free empty SecurityCOntextList.\n" ));
        goto Done;
    }

    //
    // Cycle through list & free all entries
    //

    pcur = SecurityContextListHead->pNext;

    while( pcur )
    {
        ptmp = pcur;
        pcur = pcur->pNext;
        Dns_FreeSecurityContext( ptmp );
        countDelete++;
    }

Done:

    SecContextDequeue += countDelete;

    LeaveCriticalSection( &SecurityContextListCS );

    DNSDBG( SECURITY, (
        "Dns_FreeSecurityContextList emptied %d entries\n",
        countDelete ));
}



VOID
DnsPrint_SecurityContext(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      PSTR            pszHeader,
    IN      PSEC_CNTXT      pSecCtxt
    )
{
    PSEC_CNTXT   pctxt = (PSEC_CNTXT)pSecCtxt;

    if ( !pSecCtxt )
    {
        PrintRoutine(
            pPrintContext,
            "%s NULL security context\n",
            pszHeader ? pszHeader : "" );
        return;
    }

    DnsPrint_Lock();

    PrintRoutine(
        pPrintContext,
        "%s\n"
        "\tptr          = %p\n"
        "\tpnext        = %p\n"
        "\tkey          = %s %s %s\n"
        "\tversion      = %d\n"
        "\tCred Handle  = %p %p\n"
        "\tSec Handle   = %p %p\n"
        "\tcreate time  = %d\n"
        "\texpire time  = %d\n"
        "\tcleanup time = %d\n"
        "\thave cred    = %d\n"
        "\thave sec     = %d\n"
        "\tinitialized  = %d\n"
        "\tusage count  = %d\n",
        pszHeader ? pszHeader : "Security context:",
        pctxt,
        pctxt->pNext,
        DNSADDR_STRING(&pctxt->Key.RemoteAddr),
            pctxt->Key.pszTkeyName,
            pctxt->Key.pszClientContext,
        pctxt->Version,
        pctxt->CredHandle.dwUpper,
        pctxt->CredHandle.dwLower,
        pctxt->hSecHandle.dwUpper,
        pctxt->hSecHandle.dwLower,
        pctxt->dwCreateTime,
        pctxt->dwExpireTime,
        pctxt->dwCleanupTime,
        pctxt->fHaveCredHandle,
        pctxt->fHaveSecHandle,
        pctxt->fNegoComplete,
        pctxt->UseCount
        );

    if ( !pctxt->fHaveCredHandle )
    {
        PrintRoutine(
            pPrintContext,
            "Global cred handle\n"
            "\tCred Handle  = %p %p\n",
            g_hSspiCredentials.dwUpper,
            g_hSspiCredentials.dwLower );
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_SecurityContextList(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      PSTR            pszHeader,
    IN      PSEC_CNTXT      pList
    )
{
    PSEC_CNTXT   pcur;

    EnterCriticalSection( &SecurityContextListCS );
    DnsPrint_Lock();

    pcur = pList;

    PrintRoutine(
        pPrintContext,
        "Security context list %s\n"
        "\tList ptr = %p\n"
        "%s",
        pszHeader,
        pList,
        pcur ? "" : "\tList EMPTY\n" );

    while ( pcur != NULL )
    {
        DnsPrint_SecurityContext(
            PrintRoutine,
            pPrintContext,
            NULL,
            pcur );
        pcur = pcur->pNext;
    }
    PrintRoutine(
        pPrintContext,
        "*** End security context list ***\n" );

    DnsPrint_Unlock();
    LeaveCriticalSection( &SecurityContextListCS );
}



//
//  Security utils
//

DNS_STATUS
MakeKerberosName(
    OUT     PWSTR           pwsKerberosName,
    IN      DWORD           BufLength,
    IN      PWSTR           pszDnsName,
    IN      BOOL            fTrySpn
    )
/*++

Routine Description:

    Map DNS name to kerberos name for security lookup.

Arguments:

    pwsKerberosName -- buffer to recv kerb name

    BufLength       -- length of pwsKeberosName buffer

    pszDnsName      -- DNS name

    fSPNFormat      -- use SPN format

Return Value:

    ERROR_SUCCESS successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    PWCHAR      pwMachine;
    PWCHAR      pwDomain;
    PWCHAR      pwTmp;


    DNSDBG( SECURITY, (
        "MakeKerberosName( %p, %d, %S %d )\n",
        pwsKerberosName,
        BufLength,
        pszDnsName,
        fTrySpn
        ));

    if ( !pszDnsName ||  !pwsKerberosName )
    {
       DNS_ASSERT( FALSE );
       return ERROR_INVALID_PARAMETER;
    }

    //
    //  build SPN name
    //

    if ( fTrySpn  &&  g_pfnMakeSpn )
    {
        DWORD   nameLength = BufLength;

        status = (DNS_STATUS) g_pfnMakeSpn(
                                    DNS_SPN_SERVICE_CLASS_W,
                                    pszDnsName,
                                    & nameLength,
                                    pwsKerberosName );
        DNSDBG( SECURITY, (
            "Translated (via DsSpn) %S into Kerberos name: %S\n",
            pszDnsName,
            pwsKerberosName ));
        goto Cleanup;
    }

    //
    //  no SPN -- build kerberos name
    //      - convert FQDN to domain\machine$
    //      compatible with old servers that did not register SPNs.
    //

    {
        WCHAR   nameBuf[ DNS_MAX_NAME_BUFFER_LENGTH ];
        INT     nameLength;
        PWSTR   pdomain;
        PWSTR   pdump;

        //
        //  break into host\domain name pieces
        //

        wcsncpy( nameBuf, pszDnsName, DNS_MAX_NAME_LENGTH );

        pdomain = Dns_GetDomainNameW( nameBuf );
        if ( !pdomain )
        {
            status = ERROR_INVALID_DATA;
            goto Cleanup;
        }
        *(pdomain-1) = 0;
    
        //  break off single label domain name
    
        pdump = Dns_GetDomainNameW( pdomain );
        if ( pdump )
        {
            *(pdump-1) = 0;
        }

        //
        //  note:  tried this and got linker error
        //
        //  DCR:  need to fix with snwprint() type function
        //
#if 0
        wsprintfW(
            pwsKerberosName,
            L"%S\\%S$",
            pdomain,
            nameBuf );
#endif
        _snwprintf(
            pwsKerberosName,
            BufLength,
            L"%s\\%s$",
            pdomain,
            nameBuf );
    }

    DNSDBG( SECURITY, (
        "Translated %S into Kerberos name: %S\n",
        pszDnsName,
        pwsKerberosName ));

Cleanup:

    return status;
}



DNS_STATUS
Dns_LoadNtdsapiProcs(
    VOID
    )
/*++

Routine Description:

    Dynamically loads SPN function from Ntdsapi.dll

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    HMODULE     hlib = NULL;
    DNS_STATUS  status = ERROR_SUCCESS;

    //
    //  Note, function assumes MT safe.
    //  At single thread startup or protected by CS
    //

    //
    //  return if module already loaded
    //

    if ( g_hLibNtdsa )
    {
        ASSERT( g_pfnMakeSpn );
        return  ERROR_SUCCESS;
    }

    //
    //  load ntdsapi.dll -- for getting SPNs
    //

    hlib = LoadLibraryExW(
                  NTDSAPI_DLL_NAMEW,
                  NULL,
                  0 );          // Previously used: DONT_RESOLVE_DLL_REFERENCES
    if ( !hlib )
    {
        return  GetLastError();
    }

    //
    //  get SPN function
    //

    g_pfnMakeSpn = GetProcAddress( hlib, MAKE_SPN_FUNC );
    if ( !g_pfnMakeSpn )
    {
        status = GetLastError();
        FreeLibrary( hlib );
    }
    else
    {
        g_hLibNtdsa = hlib;
    }

    return ERROR_SUCCESS;
}



DNS_STATUS
initializeSecurityPackage(
    IN      BOOL            fDnsServer
    )
/*++

Routine Description:

    Load and initialize the security package.

    Note, call this function at first UPDATE.
    MUST NOT call this function at DLL init, this becomes possibly cyclic.

Parameters:

    pdwMaxMessage - addr to recv max security token length

    fDnsServer - in server process

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    SECURITY_STATUS status;
    FARPROC         psecurityEntry;
    PSecPkgInfoW    pkgInfo;
    UUID            uuid;

    //
    //  protect with CS
    //

    EnterCriticalSection( &SecurityContextListCS );

    if ( g_fSecurityPackageInitialized )
    {
        status = NO_ERROR;
        goto Unlock;
    }

    //
    //  clear SSPI credentials handle (regardless of package state)
    //

    SecInvalidateHandle( &g_hSspiCredentials );

    //
    //  load and initialize the appropriate SSP
    //

    g_hLibSecurity = LoadLibrary( NT_DLL_NAME );
    if ( !g_hLibSecurity )
    {
        status = GetLastError();
        DNS_PRINT(( "Couldn't load dll: %u\n", status ));
        goto Failed;
    }

    psecurityEntry = GetProcAddress( g_hLibSecurity, SECURITY_ENTRYPOINTW );
    if ( !psecurityEntry )
    {
        status = GetLastError();
        DNS_PRINT(( "Couldn't get sec init routine: %u\n", status ));
        goto Failed;
    }

    g_pSecurityFunctionTable = (PSecurityFunctionTableW) psecurityEntry();
    if ( !g_pSecurityFunctionTable )
    {
        status = ERROR_DLL_INIT_FAILED;
        DNS_PRINT(( "ERROR:  unable to get security function table.\n"));
        goto Failed;
    }

    //  Get info for security package (negotiate)
    //      - need max size of tokens

    status = g_pSecurityFunctionTable->QuerySecurityPackageInfoW( PACKAGE_NAME, &pkgInfo );
    if ( !SEC_SUCCESS(status) )
    {
        DNS_PRINT((
            "Couldn't query package info for %s, error %u\n",
            PACKAGE_NAME,
            status ));
        goto Failed;
    }

    g_SecurityTokenMaxLength = pkgInfo->cbMaxToken;

    g_pSecurityFunctionTable->FreeContextBuffer( pkgInfo );

    //
    //  acquire cred handle with default process creds
    //      - for DNS server only
    //      - for client may have different creds so leave this step
    //          until creds required
    //

    if ( fDnsServer )
    {
        status = Dns_RefreshSSpiCredentialsHandle(
                        fDnsServer,
                        NULL );
        
        if ( !SEC_SUCCESS(status) )
        {
            DNSDBG( SECURITY, (
               "Error 0xX: Cannot acquire credentials handle\n",
                status ));
            ASSERT ( FALSE );
            goto Failed;
        }
    }

    //
    //  clients load ntdsapi.dll for SPN building
    //

    else
    {
        status = Dns_LoadNtdsapiProcs();
    }

    //
    //  Get a unique id
    //      - even if call fails, just take what's in stack
    //      and make a string out of it -- we just want the string
    //

    UuidCreateSequential( &uuid );

    DnsStringPrint_Guid(
        g_ContextUuid,
        & uuid );

    DNSDBG( SECURITY, (
        "Started security package (%S)\n"
        "\tmax token = %d\n",
        PACKAGE_NAME,
        g_SecurityTokenMaxLength ));

    g_fSecurityPackageInitialized = TRUE;
    status = ERROR_SUCCESS;
    goto Unlock;

Failed:

    if ( status == ERROR_SUCCESS )
    {
        status = ERROR_DLL_INIT_FAILED;
    }

Unlock:

    LeaveCriticalSection( &SecurityContextListCS );
    return( status );
}



DNS_STATUS
Dns_StartSecurity(
    IN      BOOL            fProcessAttach
    )
/*++

Routine Description:

    Initialize the security package for dynamic update.

    Note, this function is self-initializing, BUT is not
    MT safe, unless called at process attach.

Parameters:

    fProcessAttach - TRUE if called during process attach
        in that case we initialize only the CS
        otherwise we initialize completely

Return Value:

    TRUE if successful.
    FALSE otherwise, error code available from GetLastError().

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    static BOOL     fcsInitialized = FALSE;

    //
    //  DCR_PERF:  ought to have one CS for dnslib, initialized on a DnsLib
    //      init function;  then it is always valid and can be used
    //      whenever necessary
    //

    if ( fProcessAttach || !fcsInitialized )
    {
        fcsInitialized = TRUE;
        InitializeCriticalSection( &SecurityContextListCS );
        SecInvalidateHandle( &g_hSspiCredentials );
        g_fSecurityPackageInitialized = FALSE;
    }

    //
    //  do full security package init
    //

    if ( !fProcessAttach )
    {
        status = initializeSecurityPackage(
                        FALSE       // client
                        );
    }

    return( status );
}



DNS_STATUS
Dns_StartServerSecurity(
    VOID
    )
/*++

Routine Description:

    Startup server security.

    Note this function is NOT MT-safe.
    Call it once on load, or protect call with a CS.

Arguments:

    None.

Return Value:

    TRUE if security is initialized.
    FALSE if security initialization failure.

--*/
{
    DNS_STATUS  status;

    if ( g_fSecurityPackageInitialized )
    {
        return( ERROR_SUCCESS );
    }

    //
    //  init globals
    //      - this protects us on server restart
    //

    g_SecurityTokenMaxLength = 0;
    g_SignatureMaxLength = 0;

    SecurityContextListHead = NULL;
    g_pfnMakeSpn = NULL;

    //
    //  CS is initialized before init sec pak in order to
    //  have it done similarly to the client code.
    //

    InitializeCriticalSection( &SecurityContextListCS );

    status = initializeSecurityPackage(
                    TRUE        // DNS server
                    );

    if ( status != ERROR_SUCCESS )
    {
        ASSERT ( g_fSecurityPackageInitialized == FALSE );
        DeleteCriticalSection( &SecurityContextListCS );
    }
    return( status );
}



VOID
Dns_TerminateSecurityPackage(
    VOID
    )
/*++

Routine Description:

    Terminate security package on shutdown.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD status=ERROR_SUCCESS;

    if ( g_fSecurityPackageInitialized )
    {

#if 0
//
// it turns out that the security lib get unloaded before in some cases
// us for some reason (alhtough we explicity tells it to unload
// after us).
// We will never alloc over ourselves anyway (see startup).
//
        if ( !SSPI_INVALID_HANDLE ( &g_hSspiCredentials ) )
        {
            //
            // Free previously allocated handle
            //

            status = g_pSecurityFunctionTable->FreeCredentialsHandle(
                                                   &g_hSspiCredentials );
            if ( !SEC_SUCCESS(status) )
            {
                DNSDBG( SECURITY, (
                    "Error <0x%x>: Cannot free credentials handle\n",
                    status ));
            }
        }

        // continue regardless.
        SecInvalidateHandle( &g_hSspiCredentials );

        Dns_FreeSecurityContextList();
#endif

        if ( g_hLibSecurity )
        {
            FreeLibrary( g_hLibSecurity );
        }
        if ( g_hLibNtdsa )
        {
            FreeLibrary( g_hLibNtdsa );
        }
    }

    DeleteCriticalSection( &SecurityContextListCS );
}



DNS_STATUS
Dns_InitClientSecurityContext(
    IN OUT  PSECPACK        pSecPack,
    IN      PWSTR           pszNameServer,
    OUT     PBOOL           pfDoneNegotiate
    )
/*++

Routine Description:

    Initialize client security context building security token to send.

    On first pass, creates context blob (and returns handle).
    On second pass, uses server context to rebuild negotiated token.

Arguments:

    pSecPack -- ptr to security info for packet

    pszNameServer -- DNS server to nego with

    pCreds -- credentials (if given)

    pfDoneNegotiate -- addr to set if done with negotiation
        TRUE if done with nego
        FALSE if continuing

Return Value:

    ERROR_SUCCESS -- if done
    DNS_STATUS_CONTINUE_NEEDED -- if continue respone to client is needed
    ErrorCode on failure.

--*/
{
    //PSECPACK            pSecPack = (PSECPACK)hSecPack;
    SECURITY_STATUS     status;
    PSEC_CNTXT          psecCtxt;
    BOOL                fcreatedContext = FALSE;
    TimeStamp           lifetime;
    SecBufferDesc       outBufDesc;
    SecBufferDesc       inBufDesc;
    ULONG               contextAttributes = 0;
    WCHAR               wszKerberosName[ MAX_PATH ];
    PCredHandle         pcredHandle;

    DNSDBG( SECURITY, ( "Enter InitClientSecurityContext()\n" ));
    IF_DNSDBG( SECURITY )
    {
        DnsDbg_SecurityPacketInfo(
            "InitClientSecurityContext() at top.\n",
            pSecPack );
    }

    //
    //  if not existing context, create new one
    //
    //  note:  if want to create new here, then need context key
    //

    psecCtxt = pSecPack->pSecContext;
    if ( !psecCtxt )
    {
        DNSDBG( SECURITY, (
           "ERROR: Called into Dns_InitClientSecurityContext w/ no security context!!\n" ));
        ASSERT ( FALSE );
        return( DNS_ERROR_NO_MEMORY );
    }

    //
    //  client completed initialization
    //      - if server sent back token, should be echo of client's token
    //

    if ( psecCtxt->fNegoComplete )
    {
        if ( pSecPack->LocalBuf.pvBuffer &&
            pSecPack->LocalBuf.cbBuffer == pSecPack->RemoteBuf.cbBuffer &&
            RtlEqualMemory(
                pSecPack->LocalBuf.pvBuffer,
                pSecPack->RemoteBuf.pvBuffer,
                pSecPack->LocalBuf.cbBuffer
                ) )
        {
            return( ERROR_SUCCESS );
        }
        DNSDBG( ANY, (
            "InitClientSecurityContext() on already negotiated context %p\n"
            "\tserver buffer is NOT echo of buffer sent!\n",
            psecCtxt ));

        return( DNS_ERROR_RCODE_BADKEY );
    }


    //
    //  cred handle
    //      - from explicit creds or get process default
    //      creating if necessary
    //
    //  DCR:  if cred handle can be changed (expired?) out from
    //      underneath us, then we should actually have a lock
    //      while we are using it during the call;  this could be
    //      as simple as a checked out count flag;
    //

    if ( psecCtxt->fHaveCredHandle )
    {
        pcredHandle = &psecCtxt->CredHandle;
    }
    else
    {
        pcredHandle = getDefaultCredentialsHandle(
                            FALSE       // client
                            );
        if ( !pcredHandle )
        {
            status = GetLastError();
            goto Failed;
        }
    }

    //
    //  prepare output buffer, allocate if necessary
    //      - security token will be written to this buffer
    //

    if ( !pSecPack->LocalBuf.pvBuffer )
    {
        PCHAR   pbuf;

        ASSERT( g_SecurityTokenMaxLength );
        pbuf = (PVOID) ALLOCATE_HEAP( g_SecurityTokenMaxLength );
        if ( !pbuf )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Failed;
        }
        pSecPack->LocalBuf.pvBuffer     = pbuf;
        pSecPack->LocalBuf.BufferType   = SECBUFFER_TOKEN;
        //pSecPack->LocalBuf.cbBuffer     = g_SecurityTokenMaxLength;
    }

    //  set\reset buffer length

    pSecPack->LocalBuf.cbBuffer = g_SecurityTokenMaxLength;

    outBufDesc.ulVersion    = 0;
    outBufDesc.cBuffers     = 1;
    outBufDesc.pBuffers     = &pSecPack->LocalBuf;

    //  DCR_PERF:  zeroing buffer is unnecessary -- remove

    RtlZeroMemory(
        pSecPack->LocalBuf.pvBuffer,
        pSecPack->LocalBuf.cbBuffer );

    //
    //  if have response from server, then send as input buffer
    //

    if ( pSecPack->RemoteBuf.pvBuffer )
    {
        ASSERT( psecCtxt->fHaveSecHandle );
        ASSERT( pSecPack->RemoteBuf.cbBuffer );
        ASSERT( pSecPack->RemoteBuf.BufferType == SECBUFFER_TOKEN );

        inBufDesc.ulVersion    = 0;
        inBufDesc.cBuffers     = 1;
        inBufDesc.pBuffers     = & pSecPack->RemoteBuf;
    }
    ELSE_ASSERT( !psecCtxt->fHaveSecHandle );

    //
    //  get server in SPN format
    //
    //  DCR_PERF:  SPN name lookup duplicated on second pass
    //      - if know we are synchronous could keep
    //      - or could save to packet stuct (but then would have to alloc)

    status = MakeKerberosName(
                wszKerberosName,
                MAX_PATH,
                pszNameServer,
                TRUE
                );
    if ( status != ERROR_SUCCESS )
    {
        status = ERROR_INVALID_DATA;
        goto Failed;
    }

    IF_DNSDBG( SECURITY )
    {
        DNS_PRINT((
            "Before InitClientSecurityContextW().\n"
            "\ttime (ms) = %d\n"
            "\tkerb name = %S\n",
            GetCurrentTime(),
            wszKerberosName ));
        DnsDbg_SecurityPacketInfo(
            "Before call to InitClientSecurityContextW().\n",
            pSecPack );
    }

    //
    //  do init
    //

    status = g_pSecurityFunctionTable->InitializeSecurityContextW(
                    pcredHandle,
                    !psecCtxt->fHaveSecHandle
                        ?   NULL
                        :   &psecCtxt->hSecHandle,
                    wszKerberosName,
                    ISC_REQ_REPLAY_DETECT |
                        ISC_REQ_DELEGATE |
                        ISC_REQ_MUTUAL_AUTH,            // context requirements
                    0,                                  // reserved1
                    SECURITY_NATIVE_DREP,
                    !psecCtxt->fHaveSecHandle
                        ?   NULL
                        :   &inBufDesc,
                    0,                                  // reserved2
                    & psecCtxt->hSecHandle,
                    & outBufDesc,
                    & contextAttributes,
                    & lifetime
                    );

    DNSDBG( SECURITY, (
        "After InitClientSecurityContextW().\n"
        "\ttime (ms)    = %d\n"
        "\tkerb name    = %S\n"
        "\tcontext attr = %08x\n"
        "\tstatus       = %d (%08x)\n",
        GetCurrentTime(),
        wszKerberosName,
        contextAttributes,
        status, status ));

    //
    //  failed?
    //      - if unable to get kerberos (mutual auth) then bail
    //      this eliminates trying to do nego when in workgroup
    //

    if ( !SEC_SUCCESS(status) ||
        ( status == SEC_E_OK &&
            !(contextAttributes & ISC_REQ_MUTUAL_AUTH) ) )
    {
        DNS_PRINT((
            "InitializeSecurityContextW() failed: %08x %u\n"
            "\tContext Attributes   = %p\n"
            "\tTokenMaxLength       = %d\n"
            "\tSigMaxLength         = %d\n"
            "\tPackageInitialized   = %d\n"
            "\tlifetime             = %d\n",
            status, status,
            contextAttributes,
            g_SecurityTokenMaxLength,
            g_SignatureMaxLength,
            g_fSecurityPackageInitialized,
            lifetime
            ));

        //
        //  DCR:  security error codes on local function failures:
        //      - key's no good
        //      - sigs no good
        //      RCODE errors are fine for sending back to remote, but don't
        //      convey the correct info locally
        //

        status = DNS_ERROR_RCODE_BADKEY;
        goto Failed;
    }

    //
    //  now have context, flag for next pass
    //

    psecCtxt->fHaveSecHandle = TRUE;

    DNSDBG( SECURITY, (
        "Finished InitializeSecurityContext():\n"
        "\tstatus       = %08x (%d)\n"
        "\thandle       = %p\n"
        "\toutput buffers\n"
        "\t\tcBuffers   = %d\n"
        "\t\tpBuffers   = %p\n"
        "\tlocal buffer\n"
        "\t\tptr        = %p\n"
        "\t\tlength     = %d\n",
        status, status,
        & psecCtxt->hSecHandle,
        outBufDesc.cBuffers,
        outBufDesc.pBuffers,
        pSecPack->LocalBuf.pvBuffer,
        pSecPack->LocalBuf.cbBuffer
        ));

    ASSERT( status == SEC_E_OK ||
            status == SEC_I_CONTINUE_NEEDED ||
            status == SEC_I_COMPLETE_AND_CONTINUE );

    //
    //  determine signature length
    //
    //  note:  not safe to do just once on start of process, as can fail
    //          to locate DC and end up ntlm on first pass then locate
    //          DC later and need a larger sig;  so many potential client's
    //          under services, it is dangerous not to calculate each time
    //

    if ( status == SEC_E_OK )
    {
        SecPkgContext_Sizes Sizes;

        status = g_pSecurityFunctionTable->QueryContextAttributesW(
                         & psecCtxt->hSecHandle,
                         SECPKG_ATTR_SIZES,
                         (PVOID) &Sizes
                         );
        if ( !SEC_SUCCESS(status) )
        {
            //  DEVNOTE:   this will leave us will valid return but
            //      potentially unset sig max length
            goto Failed;
        }
        if ( Sizes.cbMaxSignature > g_SignatureMaxLength )
        {
            g_SignatureMaxLength = Sizes.cbMaxSignature;
        }

        DNSDBG( SECURITY, (
            "Signature max length = %d\n",
            g_SignatureMaxLength
            ));
    }

    //
    //  completed -- have key
    //      - if just created, then need to send back to server
    //      - otherwise done
    //

    if ( status == ERROR_SUCCESS )
    {
        psecCtxt->fNegoComplete = TRUE;
        ASSERT( pSecPack->LocalBuf.pvBuffer );

        if ( pSecPack->LocalBuf.cbBuffer )
        {
            //ASSERT( pSecPack->LocalBuf.cbBuffer != pSecPack->RemoteBuf.cbBuffer );
            status = DNS_STATUS_CONTINUE_NEEDED;
        }
    }

    //
    //  continue needed? -- use single return code
    //

    else
    {
        ASSERT( status == SEC_I_CONTINUE_NEEDED ||
                status == SEC_I_COMPLETE_AND_CONTINUE );

        DNSDBG( SECURITY, (
            "Initializing client context continue needed.\n"
            "\tlocal complete = %d\n",
            ( status == SEC_I_COMPLETE_AND_CONTINUE )
            ));
        //psecCtxt->State = DNSGSS_STATE_CONTINUE;
        status = DNS_STATUS_CONTINUE_NEEDED;
        psecCtxt->fNegoComplete = FALSE;
    }

    *pfDoneNegotiate = psecCtxt->fNegoComplete;
    ASSERT( status == ERROR_SUCCESS || status == DNS_STATUS_CONTINUE_NEEDED );

Failed:

    IF_DNSDBG( SECURITY )
    {
        DnsPrint_Lock();
        DNSDBG( SECURITY, (
            "Leaving InitClientSecurityContext().\n"
            "\tstatus       = %08x (%d)\n",
            status, status ));

        DnsDbg_SecurityContext(
            "Security Context",
            psecCtxt );
        DnsDbg_SecurityPacketInfo(
            "Security Session Packet Info",
            pSecPack );

        DnsPrint_Unlock();
    }

#if 0
    //
    //  security context (the struct) is NEVER created in this function
    //      so no need to determine cleanup issue on failure
    //      caller determines action if
    //

    if ( status == ERROR_SUCCESS || status == DNS_STATUS_CONTINUE_NEEDED )
    {
        return( status );
    }

    //
    //  DEVNOTE:  should we attempt to preserve a context on failure?
    //      - could be a potential security attack to crash negotiation contexts,
    //          by sending garbage
    //      - however don't want bad context to stay around and block all future
    //          attempts to renegotiate
    //
    //  delete any locally create context
    //  caller will be responsible for making determination about recaching or
    //      deleting context for passed in context
    //

    if ( fcreatedContext )
    {
        Dns_FreeSecurityContext( psecCtxt );
        pSecPack->pSecContext = NULL;
    }
    else
    {
        Dns_EnlistSecurityContext( (PSEC_CNTXT)psecCtxt );
    }
#endif

    return( status );
}



DNS_STATUS
Dns_ServerAcceptSecurityContext(
    IN OUT  PSECPACK        pSecPack,
    IN      BOOL            fBreakOnAscFailure
    )
/*++

Routine Description:

    Initialized server's security context for session with client.

    This is called with newly created context on first client packet,
    then called again with previously initialized context, after client
    responds to negotiation.

Arguments:

    pSecPack -- security context info for server's session with client

Return Value:

    ERROR_SUCCESS -- if done
    DNS_STATUS_CONTINUE_NEEDED -- if continue respone to client is needed
    ErrorCode on failure.

--*/
{
    PSEC_CNTXT          psecCtxt;
    SECURITY_STATUS     status;
    TimeStamp           lifetime;
    SecBufferDesc       outBufDesc;
    SecBufferDesc       inBufDesc;
    ULONG               contextAttributes = 0;

    DNSDBG( SECURITY, (
        "ServerAcceptSecurityContext(%p, fBreak=%d)\n",
        pSecPack,
        fBreakOnAscFailure ));

    IF_DNSDBG( SECURITY )
    {
        DnsDbg_SecurityPacketInfo(
            "Entering ServerAcceptSecurityContext()",
            pSecPack );
    }

    //
    //  get context
    //

    psecCtxt = pSecPack->pSecContext;
    if ( !psecCtxt )
    {
        DNSDBG( SECURITY, (
            "ERROR: ServerAcceptSecurityContext called with no security context\n" ));
        ASSERT( FALSE );
        return( DNS_ERROR_NO_MEMORY );
    }

    //
    //  already initialized
    //      - echo of previous token is legitimate
    //      - if client still thinks it's negotiating => problem
    //
    //  DCR_CLEAN:  need clear story here on how to handle this -- do these
    //      "mistaken" clients cause context to be scrapped from cache?
    //

    if ( psecCtxt->fNegoComplete )
    {
        if ( psecCtxt->TkeySize == pSecPack->RemoteBuf.cbBuffer )
        {
            return( ERROR_SUCCESS );
        }
#if 0
        //  DCR_FIX:
        //  NOTE:  couldn't do buf compare as not MT
        //      safe when allow context\buffer cleanup
        //  QUESTION:  how can this be dumped while in use

        if ( pSecPack->LocalBuf.pvBuffer &&
            psecCtxt->TkeySize == pSecPack->RemoteBuf.cbBuffer &&
            pSecPack->LocalBuf.cbBuffer == pSecPack->RemoteBuf.cbBuffer &&
            RtlEqualMemory(
                pSecPack->LocalBuf.pvBuffer,
                pSecPack->RemoteBuf.pvBuffer,
                pSecPack->LocalBuf.cbBuffer
                ) )
        {
            return( ERROR_SUCCESS );
        }
#endif
        DNSDBG( ANY, (
            "WARNING:  Server receiving new or incorrect TKEY on already\n"
            "\tnegotiated context %p;\n"
            "\tserver buffer is NOT echo of buffer sent!\n",
            psecCtxt ));

        return( DNS_ERROR_RCODE_BADKEY );
    }

    //  refresh SSPI credentials if expired

    if ( SSPI_EXPIRED_HANDLE( g_SspiCredentialsLifetime ) )
    {
        status = Dns_RefreshSSpiCredentialsHandle( TRUE, NULL );
        if ( !SEC_SUCCESS(status) )
        {
            DNS_PRINT((
                "Error <0x%x>: Cannot refresh Sspi Credentials Handle\n",
                status ));
        }
    }

    //
    //  accept security context
    //
    //  allocate local token buffer if doesn't exists
    //  note, the reason I do this is so I won't have the memory of
    //  a large buffer sitting around during a two pass security session
    //      and hence tied up until I time out
    //
    //  DCR_PERF:  security token buffer allocation
    //      since context will be verified before queued, is this approach
    //      sensible?
    //      if can delete when TCP connection fails, or on short timeout, then
    //      ok to append to SEC_CNTXT and save an allocation
    //

    if ( !pSecPack->LocalBuf.pvBuffer )
    {
        PCHAR   pbuf;
        pbuf = (PVOID) ALLOCATE_HEAP( g_SecurityTokenMaxLength );
        if ( !pbuf )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Failed;
        }
        pSecPack->LocalBuf.pvBuffer     = pbuf;
        pSecPack->LocalBuf.cbBuffer     = g_SecurityTokenMaxLength;
        pSecPack->LocalBuf.BufferType   = SECBUFFER_TOKEN;
    }

    pSecPack->LocalBuf.cbBuffer = g_SecurityTokenMaxLength;

    outBufDesc.ulVersion   = 0;
    outBufDesc.cBuffers    = 1;
    outBufDesc.pBuffers    = &pSecPack->LocalBuf;

    //  DCR_PERF:  zeroing nego buffer is unnecessary

    RtlZeroMemory(
        pSecPack->LocalBuf.pvBuffer,
        pSecPack->LocalBuf.cbBuffer );

    //  prepare input buffer with client token

    inBufDesc.ulVersion    = 0;
    inBufDesc.cBuffers     = 1;
    inBufDesc.pBuffers     = & pSecPack->RemoteBuf;

    status = g_pSecurityFunctionTable->AcceptSecurityContext(
                & g_hSspiCredentials,
                !psecCtxt->fHaveSecHandle
                    ?   NULL
                    :   & psecCtxt->hSecHandle,
                & inBufDesc,
                ASC_REQ_REPLAY_DETECT
                        | ASC_REQ_DELEGATE
                        | ASC_REQ_MUTUAL_AUTH,      // context requirements
                SECURITY_NATIVE_DREP,
                & psecCtxt->hSecHandle,
                & outBufDesc,
                & contextAttributes,
                & lifetime
                );

    if ( fBreakOnAscFailure &&
        ( status != SEC_E_OK &&
            status != SEC_I_CONTINUE_NEEDED &&
            status != SEC_I_COMPLETE_AND_CONTINUE ) )
    {
        DNS_PRINT(( "HARD BREAK: BreakOnAscFailure status=%d\n",
            status ));
        DebugBreak();
    }

    if ( !SEC_SUCCESS(status) )
    {
        DNS_PRINT((
            "ERROR:  Accept security context failed status = %d (%08x)\n",
            status, status ));
        goto Failed;
    }

    psecCtxt->fHaveSecHandle = TRUE;

    DNSDBG( SECURITY, (
        "Finished AcceptSecurityContext():\n"
        "\tstatus       = %08x (%d)\n"
        "\thandle       = %p\n"
        "\toutput buffers\n"
        "\t\tcBuffers   = %d\n"
        "\t\tpBuffers   = %p\n"
        "\tlocal buffer\n"
        "\t\tptr        = %p\n"
        "\t\tlength     = %d\n"
        "\tlifetime     = %ld %ld\n"
        "\tcontext flag = 0x%lx\n",
        status, status,
        & psecCtxt->hSecHandle,
        outBufDesc.cBuffers,
        outBufDesc.pBuffers,
        pSecPack->LocalBuf.pvBuffer,
        pSecPack->LocalBuf.cbBuffer,
        lifetime.HighPart,
        lifetime.LowPart,
        contextAttributes
        ));

    ASSERT( status == SEC_E_OK ||
            status == SEC_I_CONTINUE_NEEDED ||
            status == SEC_I_COMPLETE_AND_CONTINUE );

    //
    //  compute the size of signature if you are done with initializing
    //  the security context and haven't done it before
    //

    if ( status == SEC_E_OK )
    {
        SecPkgContext_Sizes     Sizes;

        //
        //  reject NULL sessions
        //  NTLM security will establish NULL sessions to non-domain clients,
        //      even if ASC_REQ_ALLOW_NULL_SESSION is not set
        //  note, context has been created, but will be cleaned up in normal
        //      failure path
        //

        if ( contextAttributes & ASC_RET_NULL_SESSION )
        {
            DNSDBG( SECURITY, (
                "Rejecting NULL session from AcceptSecurityContext()\n" ));
            status = DNS_ERROR_RCODE_BADKEY;
            goto Failed;
        }

        status = g_pSecurityFunctionTable->QueryContextAttributesW(
                             &psecCtxt->hSecHandle,
                             SECPKG_ATTR_SIZES,
                             (PVOID)& Sizes
                             );
        if ( !SEC_SUCCESS(status) )
        {
            DNS_PRINT(( "Query context attribtues failed\n" ));
            ASSERT( FALSE );
            goto Failed;
        }

        //
        //  we should use the largest signature there is among all
        //  packages
        //
        //  DCR_FIX:  signature length stuff bogus???
        //
        //  when packet is signed, the length is assumed to be g_SignatureMaxLength
        //      if this is not the signature length for the desired package, does
        //      this still work properly???
        //
        //  DCR_FIX:  potential very small timing window where two clients
        //      getting different packages could cause this to miss highest
        //      value -- potential causing a signing failure?
        //

        if ( Sizes.cbMaxSignature > g_SignatureMaxLength )
        {
            g_SignatureMaxLength = Sizes.cbMaxSignature;
        }

        //
        //  finished negotiation
        //      - set flag
        //      - save final TKEY data length, so can recognize response
        //
        //  this is valid only on new conversation, shouldn't have
        //  no sig second time through
        //

        psecCtxt->fNegoComplete = TRUE;
        psecCtxt->TkeySize = (WORD) pSecPack->LocalBuf.cbBuffer;

        //
        //  need token response from server
        //  some protocols (kerberos) complete in one pass, but hence require
        //      non-echo response from server for mutual-authentication
        //

        if ( psecCtxt->TkeySize )
        {
            DNSDBG( SECURITY, (
                "Successful security context accept, but need server reponse\n"
                "\t-- doing continue.\n" ));
            status = DNS_STATUS_CONTINUE_NEEDED;
        }

#if 0
        if ( !psecCtxt->pTsigRR  &&  !psecCtxt->fHaveSecHandle )
        {
            DNSDBG( SECURITY, (
                "Successful security context accept, without sig, doing continue\n" ));
            status = DNS_STATUS_CONTINUE_NEEDED;
        }
#endif
    }

    //
    //  continue needed?
    //      - single status code returned for continue needed
    //

    else if ( status == SEC_I_CONTINUE_NEEDED  ||  status == SEC_I_COMPLETE_AND_CONTINUE )
    {
        DNSDBG( SECURITY, (
            "Initializing server context, continue needed.\n"
            "\tlocal complete = %d\n",
            ( status == SEC_I_COMPLETE_AND_CONTINUE )
            ));
        psecCtxt->fNegoComplete = FALSE;
        status = DNS_STATUS_CONTINUE_NEEDED;
    }

Failed:

    IF_DNSDBG( SECURITY )
    {
        DNSDBG( SECURITY, (
            "Leaving ServerAcceptSecurityContext().\n"
            "\tstatus       = %d %08x\n",
            status, status ));

        DnsDbg_SecurityContext(
            "Security Session Context leaving ServerAcceptSecurityContext()",
            psecCtxt );
    }
    return( status );
}



DNS_STATUS
Dns_SrvImpersonateClient(
    IN      HANDLE          hSecPack
    )
/*++

Routine Description:

    Make server impersonate client.

Parameters:

    hSecPack -- session context handle

Return Value:

    ERROR_SUCCESS if successful impersonation.
    ErrorCode on failue.

--*/
{
    PSEC_CNTXT      psecCtxt;

    //  get security context

    psecCtxt = ((PSECPACK)hSecPack)->pSecContext;
    if ( !psecCtxt )
    {
        DNS_PRINT(( "ERROR:  Dns_SrvImpersonateClient without context!!!\n" ));
        ASSERT( FALSE );
        return( DNS_ERROR_RCODE_BADKEY );
    }

    return  g_pSecurityFunctionTable->ImpersonateSecurityContext( &psecCtxt->hSecHandle );
}



DNS_STATUS
Dns_SrvRevertToSelf(
    IN      HANDLE          hSecPack
    )
/*++

Routine Description:

    Return server context to itself.

Parameters:

    hSecPack -- session context handle

Return Value:

    ERROR_SUCCESS if successful impersonation.
    ErrorCode on failue.

--*/
{
    PSEC_CNTXT      psecCtxt;

    //  get security context

    psecCtxt = ((PSECPACK)hSecPack)->pSecContext;
    if ( !psecCtxt )
    {
        DNS_PRINT(( "ERROR:  Dns_SrvRevertToSelf without context!!!\n" ));
        ASSERT( FALSE );
        return( DNS_ERROR_RCODE_BADKEY );
    }

    return  g_pSecurityFunctionTable->RevertSecurityContext( &psecCtxt->hSecHandle );
}



//
//  Security record packet write
//

DNS_STATUS
Dns_WriteGssTkeyToMessage(
    IN      PSECPACK        pSecPack,
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgBufEnd,
    IN OUT  PCHAR *         ppCurrent,
    IN      BOOL            fIsServer
    )
/*++

Routine Description:

    Write security record into packet, and optionally sign.

Arguments:

    hSecPack    -- security session handle

    pMsgHead    -- ptr to start of DNS message

    pMsgEnd     -- ptr to end of message buffer

    ppCurrent   -- addr to recv ptr to end of message

    fIsServer   -- performing this operation as DNS server?

Return Value:

    ERROR_SUCCESS on success
    ErrorCode of failure to accomodate or sign message.

--*/
{
    DNS_STATUS      status = ERROR_INVALID_DATA;
    PSEC_CNTXT      psecCtxt;
    PCHAR           pch;
    DWORD           expireTime;
    WORD            keyLength;
    WORD            keyRecordDataLength;
    PCHAR           precordData;
    PCHAR           pnameAlg;
    WORD            lengthAlg;

    DNSDBG( SECURITY, ( "Dns_WriteGssTkeyToMessage( %p )\n", pSecPack ));

    //
    //  get security context
    //

    psecCtxt = pSecPack->pSecContext;
    if ( !psecCtxt )
    {
        DNS_PRINT(( "ERROR:  attempted signing without security context!!!\n" ));
        ASSERT( FALSE );
        return( DNS_ERROR_RCODE_BADKEY );
    }

    //
    //  peal packet back to question section
    //

    pMsgHead->AnswerCount = 0;
    pMsgHead->NameServerCount = 0;
    pMsgHead->AdditionalCount = 0;

    //  go to end of packet to insert TKEY record

    pch = Dns_SkipToRecord(
                pMsgHead,
                pMsgBufEnd,
                0           // go to end of packet
                );
    if ( !pch )
    {
        DNS_ASSERT( FALSE );
        DNS_PRINT(("Dns_SkipToSecurityRecord failed!\n" ));
        goto Exit;
    }

    //
    //  reset section count where the TKEY RR will be written
    //
    //  for client section depends on version
    //      W2K -> answer
    //      later -> additional
    //

    if ( fIsServer )
    {
        pMsgHead->AnswerCount = 1;

        //  for server set client TKEY version in context
        //      - if not learned on previous pass

        if ( psecCtxt->Version == 0 )
        {
            psecCtxt->Version = pSecPack->TkeyVersion;
        }
    }
    else
    {
        if ( psecCtxt->Version == TKEY_VERSION_W2K )
        {
            pMsgHead->AnswerCount = 1;
        }
        else
        {
            pMsgHead->AdditionalCount = 1;
        }
    }

    //
    //  write TKEY owner
    //      - this is context "name"
    //

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pMsgBufEnd,
                psecCtxt->Key.pszTkeyName,
                NULL,       // FQDN, no domain
                0,          // no domain offset
                FALSE       // not unicode
                );
    if ( !pch )
    {
        goto Exit;
    }

    //
    //  TKEY record
    //      - algorithm owner
    //      - time
    //      - expire time
    //      - key length
    //      - key
    //

    if ( psecCtxt->Version == TKEY_VERSION_W2K )
    {
        pnameAlg  = g_pAlgorithmNameW2K;
        lengthAlg = W2K_GSS_ALGORITHM_NAME_PACKET_LENGTH;
    }
    else
    {
        pnameAlg  = g_pAlgorithmNameCurrent;
        lengthAlg = GSS_ALGORITHM_NAME_PACKET_LENGTH;
    }

    keyLength = (WORD) pSecPack->LocalBuf.cbBuffer;

    keyRecordDataLength = keyLength + SIZEOF_TKEY_FIXED_DATA + lengthAlg;

    if ( pch + sizeof(DNS_WIRE_RECORD) + keyRecordDataLength > pMsgBufEnd )
    {
        DNS_PRINT(( "Dns_WriteGssTkeyToMessage() failed! -- insufficient length\n" ));
        DNS_ASSERT( FALSE );
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }
    pch = Dns_WriteRecordStructureToPacketEx(
                pch,
                DNS_TYPE_TKEY,
                DNS_CLASS_ANY,
                0,
                keyRecordDataLength );

    //  write algorithm name

    precordData = pch;
    RtlCopyMemory(
        pch,
        pnameAlg,
        lengthAlg );

    pch += lengthAlg;

    //  time signed and expire time
    //      give ten minutes before expiration

    expireTime = (DWORD) time( NULL );
    INLINE_WRITE_FLIPPED_DWORD( pch, expireTime );
    pch += sizeof(DWORD);

    expireTime += TKEY_EXPIRE_INTERVAL;
    INLINE_WRITE_FLIPPED_DWORD( pch, expireTime );
    pch += sizeof(DWORD);

    //  mode

    INLINE_WRITE_FLIPPED_WORD( pch, DNS_TKEY_MODE_GSS );
    pch += sizeof(WORD);

    //  extended RCODE -- report back to caller

    INLINE_WRITE_FLIPPED_WORD( pch, pSecPack->ExtendedRcode );
    pch += sizeof(WORD);

    //  key length

    INLINE_WRITE_FLIPPED_WORD( pch, keyLength );
    pch += sizeof(WORD);

    //  write key token

    RtlCopyMemory(
        pch,
        pSecPack->LocalBuf.pvBuffer,
        keyLength );

    pch += keyLength;

    DNSDBG( SECURITY, (
        "Wrote TKEY to packet at %p\n"
        "\tlength = %d\n"
        "\tpacket end = %p\n",
        pMsgHead,
        keyLength,
        pch ));

    ASSERT( pch < pMsgBufEnd );

    //  other length

    WRITE_UNALIGNED_WORD( pch, 0 );
    pch += sizeof(WORD);

    ASSERT( pch < pMsgBufEnd );
    ASSERT( pch - precordData == keyRecordDataLength );

    *ppCurrent = pch;
    status = ERROR_SUCCESS;

Exit:

    return( status );
}



DNS_STATUS
Dns_SignMessageWithGssTsig(
    IN      HANDLE          hSecPackCtxt,
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgBufEnd,
    IN OUT  PCHAR *         ppCurrent
    )
/*++

Routine Description:

    Write GSS TSIG record to packet.

Arguments:

    hSecPackCtxt -- packet security context

    pMsgHead    -- ptr to start of DNS message

    pMsgEnd     -- ptr to end of message buffer

    ppCurrent   -- addr to recv ptr to end of message

Return Value:

    ERROR_SUCCESS on success
    ErrorCode of failure to accomodate or sign message.

--*/
{
    PSECPACK        pSecPack = (PSECPACK) hSecPackCtxt;
    PSEC_CNTXT      psecCtxt;
    DNS_STATUS      status = ERROR_INVALID_DATA;
    PCHAR           pch;            //  ptr to walk through TSIG record during build
    PCHAR           ptsigRRHead;
    PCHAR           ptsigRdataBegin;
    PCHAR           ptsigRdataEnd;
    PCHAR           pbufStart = NULL;   //  signing buf
    PCHAR           pbuf;               //  ptr to walk through signing buf
    PCHAR           psig = NULL;        //  query signature
    WORD            sigLength;
    DWORD           length;
    DWORD           createTime;
    SecBufferDesc   outBufDesc;
    SecBuffer       outBuffs[2];
    WORD            netXid;
    PCHAR           pnameAlg;
    DWORD           lengthAlg;

    DNSDBG( SECURITY, (
        "Dns_SignMessageWithGssTsig( %p )\n",
        pMsgHead ));

    //
    //  get security context
    //

    psecCtxt = pSecPack->pSecContext;
    if ( !psecCtxt )
    {
        DNS_PRINT(( "ERROR:  attempted signing without security context!!!\n" ));
        ASSERT( FALSE );
        return( DNS_ERROR_RCODE_BADKEY );
    }

    //
    //  peal off existing TSIG (if any)
    //

    if ( pMsgHead->AdditionalCount )
    {
        DNS_PARSED_RR   parsedRR;

        pch = Dns_SkipToRecord(
                    pMsgHead,
                    pMsgBufEnd,
                    (-1)        // go to last record
                    );
        if ( !pch )
        {
            DNS_ASSERT( FALSE );
            DNS_PRINT(("Dns_SkipToRecord() failed!\n" ));
            goto Exit;
        }

        pch = Dns_ParsePacketRecord(
                    pch,
                    pMsgBufEnd,
                    &parsedRR );
        if ( !pch )
        {
            DNS_ASSERT( FALSE );
            DNS_PRINT(("Dns_ParsePacketRecord failed!\n" ));
            goto Exit;
        }

        if ( parsedRR.Type == DNS_TYPE_TSIG )
        {
            DNSDBG( SECURITY, (
                "Erasing existing TSIG before resigning packet %p\n",
                pMsgHead ));
            pMsgHead->AdditionalCount--;
        }

        //  note could save end-of-message here (pch)
        //  for non-TSIG case instead of redoing skip
    }

    //  go to end of packet to insert TSIG record

    pch = Dns_SkipToRecord(
                pMsgHead,
                pMsgBufEnd,
                0           // go to end of packet
                );
    if ( !pch )
    {
        DNS_ASSERT( FALSE );
        DNS_PRINT(("Dns_SkipToSecurityRecord failed!\n" ));
        goto Exit;
    }

    //
    //  write TSIG owner
    //      - this is context "name"
    //

    pch = Dns_WriteDottedNameToPacket(
                pch,
                pMsgBufEnd,
                psecCtxt->Key.pszTkeyName,
                NULL,       // FQDN, no domain
                0,          // no domain offset
                FALSE       // not unicode
                );
    if ( !pch )
    {
        goto Exit;
    }

    //
    //  TSIG record
    //      - algorithm owner
    //      - time
    //      - expire time
    //      - original XID
    //      - sig length
    //      - sig
    //

    if ( psecCtxt->Version == TKEY_VERSION_W2K )
    {
        pnameAlg  = g_pAlgorithmNameW2K;
        lengthAlg = W2K_GSS_ALGORITHM_NAME_PACKET_LENGTH;
    }
    else
    {
        pnameAlg  = g_pAlgorithmNameCurrent;
        lengthAlg = GSS_ALGORITHM_NAME_PACKET_LENGTH;
    }

    if ( pch +
            sizeof(DNS_WIRE_RECORD) +
            SIZEOF_TSIG_FIXED_DATA +
            lengthAlg +
            g_SignatureMaxLength > pMsgBufEnd )
    {
        DNS_PRINT(( "Dns_WriteTsigToMessage() failed! -- insufficient length\n" ));
        DNS_ASSERT( FALSE );
        status = ERROR_INVALID_PARAMETER;
        goto Exit;
    }

    //  write record structure

    ptsigRRHead = pch;
    pch = Dns_WriteRecordStructureToPacketEx(
                pch,
                DNS_TYPE_TSIG,
                DNS_CLASS_ANY,      // per TSIG-04 draft
                0,
                0 );

    //  write algorithm name
    //      - save ptr to RDATA as all is directly signable in packet
    //      format up to SigLength field

    ptsigRdataBegin = pch;

    RtlCopyMemory(
        pch,
        pnameAlg,
        lengthAlg );

    pch += lengthAlg;

    //
    //  set time fields
    //      - signing time seconds since 1970 in 48 bit
    //      - expire time
    //
    //  DCR_FIX: not 2107 safe
    //      have 48 bits on wire, but setting with 32 bit time
    //

    RtlZeroMemory( pch, sizeof(WORD) );
    pch += sizeof(WORD);
    createTime = (DWORD) time( NULL );
    INLINE_WRITE_FLIPPED_DWORD( pch, createTime );
    pch += sizeof(DWORD);

    INLINE_WRITE_FLIPPED_WORD( pch, TSIG_EXPIRE_INTERVAL );
    pch += sizeof(WORD);

    ptsigRdataEnd = pch;

    //
    //  create signing buffer
    //      - everything signed must fit into message
    //

    pbuf = ALLOCATE_HEAP( MAX_SIGNING_SIZE );
    if ( !pbuf )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Exit;
    }
    pbufStart = pbuf;

    //
    //  sign
    //      - query signature (if exists)
    //      (note, W2K improperly left out query sig length)
    //      - message up to TSIG
    //      - TSIG owner name
    //      - TSIG header
    //          - class
    //          - TTL
    //      - TSIG RDATA
    //          - everything before SigLength
    //          - original id
    //          - other data length and other data
    //

    if ( pMsgHead->IsResponse )
    {
        if ( pSecPack->pQuerySig )
        {
            sigLength = pSecPack->QuerySigLength;

            ASSERT( sigLength != 0 );
            DNS_ASSERT( psecCtxt->Version != 0 );

            if ( psecCtxt->Version != TKEY_VERSION_W2K )
            {
                INLINE_WRITE_FLIPPED_WORD( pbuf, sigLength );
                pbuf += sizeof(WORD);
            }
            RtlCopyMemory(
                pbuf,
                pSecPack->pQuerySig,
                sigLength );

            pbuf += sigLength;
        }

        //  if server has just completed TKEY nego, it may sign response without query
        //  otherwise no query sig is invalid for response

        else if ( !pSecPack->pTkeyRR )
        {
            DNS_PRINT((
                "ERROR: no query sig available when signing response at %p!!!\n",
                pMsgHead ));
            ASSERT( FALSE );
            status = DNS_ERROR_RCODE_SERVER_FAILURE;
            goto Exit;
        }
        DNSDBG( SECURITY, (
            "Signing TKEY response without query sig.\n" ));
    }

    //
    //  copy message
    //      - go right through, TSIG owner name
    //      - message header MUST be in network order
    //      - save XID in netorder, it is included in TSIG RR
    //

    DNS_BYTE_FLIP_HEADER_COUNTS( pMsgHead );
    length = (DWORD)(ptsigRRHead - (PCHAR)pMsgHead);

    netXid = pMsgHead->Xid;

    RtlCopyMemory(
        pbuf,
        (PCHAR) pMsgHead,
        length );

    pbuf += length;
    DNS_BYTE_FLIP_HEADER_COUNTS( pMsgHead );

    //  copy TSIG class (ANY) and TTL (0)

    WRITE_UNALIGNED_WORD( pbuf, DNS_RCLASS_ANY );
    pbuf += sizeof(WORD);
    WRITE_UNALIGNED_DWORD( pbuf, 0 );
    pbuf += sizeof(DWORD);

    //  copy TSIG RDATA through sig

    length = (DWORD)(ptsigRdataEnd - ptsigRdataBegin);

    RtlCopyMemory(
        pbuf,
        ptsigRdataBegin,
        length );

    pbuf += length;

    //  copy extended RCODE -- report back to caller

    INLINE_WRITE_FLIPPED_WORD( pbuf, pSecPack->ExtendedRcode );
    pbuf += sizeof(WORD);

    //  copy other data length and other data
    //      - currently just zero length field

    *pbuf++ = 0;
    *pbuf++ = 0;

    length = (DWORD)(pbuf - pbufStart);

    DNSDBG( SECURITY, (
        "Copied %d bytes to TSIG signing buffer.\n",
        length ));

    //
    //  sign the packet
    //      buf[0] is data
    //      buf[1] is signature
    //
    //  note:  we write signature DIRECTLY into the real packet buffer
    //

    ASSERT( pch + g_SignatureMaxLength <= pMsgBufEnd );

    outBufDesc.ulVersion    = 0;
    outBufDesc.cBuffers     = 2;
    outBufDesc.pBuffers     = outBuffs;

    outBuffs[0].pvBuffer    = pbufStart;
    outBuffs[0].cbBuffer    = length;
    outBuffs[0].BufferType  = SECBUFFER_DATA; // | SECBUFFER_READONLY;

    outBuffs[1].pvBuffer    = pch + sizeof(WORD);
    outBuffs[1].cbBuffer    = g_SignatureMaxLength;
    outBuffs[1].BufferType  = SECBUFFER_TOKEN;

    status = g_pSecurityFunctionTable->MakeSignature(
                    & psecCtxt->hSecHandle,
                    0,
                    & outBufDesc,
                    0               // sequence detection
                    );

    if ( status != SEC_E_OK  &&
         status != SEC_E_CONTEXT_EXPIRED  &&
             status != SEC_E_QOP_NOT_SUPPORTED )
    {
        DNS_PRINT(( "MakeSignature() failed status = %08x (%d)\n", status, status ));
        goto Exit;
    }

    IF_DNSDBG( SECURITY )
    {
        DnsPrint_Lock();
        DnsDbg_MessageNoContext(
            "Signed packet",
            pMsgHead,
            (WORD) (pch - (PCHAR)pMsgHead) );

        DNS_PRINT((
            "Signing info:\n"
            "\tsign data buf    %p\n"
            "\t  length         %d\n"
            "\tsignature buf    %p (in packet)\n"
            "\t  length         %d\n",
            outBuffs[0].pvBuffer,
            outBuffs[0].cbBuffer,
            outBuffs[1].pvBuffer,
            outBuffs[1].cbBuffer
            ));
        DnsDbg_RawOctets(
            "Signing buffer:",
            NULL,
            outBuffs[0].pvBuffer,
            outBuffs[0].cbBuffer
            );
        DnsDbg_RawOctets(
            "Signature:",
            NULL,
            outBuffs[1].pvBuffer,
            outBuffs[1].cbBuffer
            );
        DnsPrint_Unlock();
    }

    //
    //  continue building packet TSIG RDATA
    //      - siglength
    //      - signature
    //      - original id
    //      - error code
    //      - other length
    //      - other data

    //
    //  get signature length
    //  set sig length in packet
    //
    //  if this is query SAVE signature, to verify response
    //

    sigLength = (WORD) outBuffs[1].cbBuffer;

    INLINE_WRITE_FLIPPED_WORD( pch, sigLength );
    pch += sizeof(WORD);

    //
    //  client saves off signature sent, to use in hash on response
    //      - server using client's sig in hash, blocks some attacks
    //

    if ( !pMsgHead->IsResponse )
    {
        ASSERT( !pSecPack->pQuerySig );

        psig = ALLOCATE_HEAP( sigLength );
        if ( !psig )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Exit;
        }
        RtlCopyMemory(
            psig,
            pch,
            sigLength );

        pSecPack->pQuerySig = psig;
        pSecPack->QuerySigLength = sigLength;
    }

    //  jump over signature -- it was directly written to packet

    pch += sigLength;

    //  original id follows signature

    WRITE_UNALIGNED_WORD( pch, netXid );
    //RtlCopyMemory( pch, (PCHAR)&netXid, sizeof(WORD) );
    pch += sizeof(WORD);

    //  extended RCODE -- report back to caller

    INLINE_WRITE_FLIPPED_WORD( pch, pSecPack->ExtendedRcode );
    pch += sizeof(WORD);

    //  other length

    WRITE_UNALIGNED_WORD( pch, 0 );
    pch += sizeof(WORD);

    //  set TSIG record datalength

    Dns_SetRecordDatalength(
        (PDNS_WIRE_RECORD) ptsigRRHead,
        (WORD) (pch - ptsigRdataBegin) );

    //  increment AdditionalCount

    pMsgHead->AdditionalCount++;

    DNSDBG( SECURITY, (
        "Signed packet at %p with GSS TSIG.\n"
        "\tsig length           = %d\n"
        "\tTSIG RR header       = %p\n"
        "\tTSIG RDATA           = %p\n"
        "\tTSIG RDATA End       = %p\n"
        "\tTSIG RDATA length    = %d\n",
        pMsgHead,
        sigLength,
        ptsigRRHead,
        ptsigRdataBegin,
        pch,
        (WORD) (pch - ptsigRdataBegin)
        ));

    *ppCurrent = pch;
    status = ERROR_SUCCESS;

Exit:

    //  free signing buffer
    //  note:  no cleanup of allocated pQuerySig is needed;  from point
    //          of allocation there is no failure scenario

    if ( pbufStart )
    {
        FREE_HEAP( pbufStart );
    }
    return( status );
}



//
//  Security record reading
//

DNS_STATUS
Dns_ExtractGssTsigFromMessage(
    IN OUT  PSECPACK            pSecPack,
    IN      PDNS_HEADER         pMsgHead,
    IN      PCHAR               pMsgEnd
    )
/*++

Routine Description:

    Extracts a TSIG from packet and loads into security context.

Arguments:

    pSecPack    - security info for packet

    pMsgHead    - msg to extract security context from

    pMsgEnd     - end of message

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_FORMERR if badly formed TSIG
    DNS_STATUS_PACKET_UNSECURE if security context in response is same as query's
        indicating non-security aware partner
    RCODE or extended RCODE on failure.

--*/
{
    DNS_STATUS      status = ERROR_INVALID_DATA;
    PCHAR           pch;
    PCHAR           pnameOwner;
    WORD            nameLength;
    WORD            extRcode;
    WORD            sigLength;
    DWORD           currentTime;
    PDNS_PARSED_RR  pparsedRR;
    PDNS_RECORD     ptsigRR;
    DNS_RECORD      ptempRR;
    PCHAR           psig;

    DNSDBG( SECURITY, (
        "ExtractGssTsigFromMessage( %p )\n", pMsgHead ));

    //  clear any previous TSIG

    if ( pSecPack->pTsigRR || pSecPack->pszContextName )
    //    if ( pSecPack->pTsigRR || pSecPack->pszContextName )
    {
        // Dns_RecordFree( pSecPack->pTsigRR );
        FREE_HEAP( pSecPack->pTsigRR );
        DnsApiFree( pSecPack->pszContextName );

        pSecPack->pTsigRR = NULL;
        pSecPack->pszContextName = NULL;
    }

    //  set message pointers

    pSecPack->pMsgHead = pMsgHead;
    pSecPack->pMsgEnd = pMsgEnd;

    //
    //  if no additional record, don't bother, not a secure message
    //

    if ( pMsgHead->AdditionalCount == 0 )
    {
        status = DNS_STATUS_PACKET_UNSECURE;
        goto Failed;
    }

    //
    //  skip to security record (last record in packet)
    //

    pch = Dns_SkipToRecord(
                pMsgHead,
                pMsgEnd,
                (-1)           // goto last record
                );
    if ( !pch )
    {
        status = DNS_ERROR_RCODE_FORMAT_ERROR;
        goto Failed;
    }

    //
    //  read TSIG owner name
    //

    pparsedRR = &pSecPack->ParsedRR;

    pparsedRR->pchName = pch;

    pch = Dns_ReadPacketNameAllocate(
            & pSecPack->pszContextName,
            & nameLength,
            0,
            0,
            pch,
            (PCHAR)pMsgHead,
            pMsgEnd );
    if ( !pch )
    {
        DNSDBG( SECURITY, (
            "WARNING:  invalid TSIG RR owner name at %p.\n",
            pch ));
        status = DNS_ERROR_RCODE_FORMAT_ERROR;
        goto Failed;              
    }

    //
    //  parse record structure
    //

    pch = Dns_ReadRecordStructureFromPacket(
                pch,
                pMsgEnd,
                pparsedRR );
    if ( !pch )
    {
        DNSDBG( SECURITY, (
            "ERROR:  invalid security RR in packet at %p.\n"
            "\tstructure or data not within packet\n",
            pMsgHead ));
        status = DNS_ERROR_RCODE_FORMAT_ERROR;
        goto Failed;
    }
    if ( pparsedRR->Type != DNS_TYPE_TSIG )
    {
        status = DNS_STATUS_PACKET_UNSECURE;
        goto Failed;
    }

    if ( pch != pMsgEnd )
    {
        DNSDBG( SECURITY, (
            "WARNING:  security RR does NOT end at packet end.\n"
            "\tRR end offset    = %04x\n"
            "\tmsg end offset   = %04x\n",
            pch - (PCHAR)pMsgHead,
            pMsgEnd - (PCHAR)pMsgHead ));
    }

    //
    //  extract TSIG record
    //
    //  TsigReadRecord() requires RR owner name for versioning
    //      - pass TSIG name in temp RR
    //

    ptsigRR = Tsig_RecordRead(
                NULL,
                DnsCharSetWire,
                NULL,
                pparsedRR->pchData,
                pparsedRR->pchNextRR
                );
    if ( !ptsigRR )
    {
        DNSDBG( ANY, (
            "ERROR:  invalid TSIG RR in packet at %p.\n"
            "\tstructure or data not within packet\n",
            pMsgHead ));
        status = DNS_ERROR_RCODE_FORMAT_ERROR;
        DNS_ASSERT( FALSE );
        goto Failed;
    }
    pSecPack->pTsigRR = ptsigRR;

    //
    //  currently callers expect error on Extract when ext RCODE is set
    //

    if ( ptsigRR->Data.TSIG.wError )
    {
        DNSDBG( SECURITY, (
            "Leaving ExtractGssTsig(), TSIG had extended RCODE = %d\n",
            ptsigRR->Data.TSIG.wError ));
        status = DNS_ERROR_FROM_RCODE( ptsigRR->Data.TSIG.wError );
        goto Failed;
    }

    //
    //  Server side:
    //  if query, save off signature for signing response
    //

    sigLength = ptsigRR->Data.TSIG.wSigLength;

    if ( !pMsgHead->IsResponse )
    {
        ASSERT( !pSecPack->pQuerySig );
        if ( pSecPack->pQuerySig )
        {
            FREE_HEAP( pSecPack->pQuerySig );
            pSecPack->pQuerySig = NULL;
        }

        psig = ALLOCATE_HEAP( sigLength );
        if ( !psig )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Failed;
        }
        RtlCopyMemory(
            psig,
            ptsigRR->Data.TSIG.pSignature,
            sigLength );

        pSecPack->pQuerySig = psig;
        pSecPack->QuerySigLength = sigLength;
    }

    //
    //  Client side:
    //  check for security record echo on response
    //
    //  if we signed and got echo signature back, then may have security unaware
    //  server or lost\timed out key condition
    //

    else
    {
        if ( pSecPack->pQuerySig &&
            pSecPack->QuerySigLength == sigLength &&
            RtlEqualMemory(
                ptsigRR->Data.TSIG.pSignature,
                pSecPack->pQuerySig,
                sigLength ) )
        {
            status = DNS_STATUS_PACKET_UNSECURE;
            goto Failed;
        }
    }

    status = ERROR_SUCCESS;

Failed:

    if ( status != ERROR_SUCCESS )
    {
        DNS_ASSERT( status != DNS_ERROR_RCODE_FORMAT_ERROR );

        ( status == DNS_STATUS_PACKET_UNSECURE )
            ?   (SecTsigEcho++)
            :   (SecTsigFormerr++);
    }

    DNSDBG( SECURITY, (
        "Leave ExtractGssTsigFromMessage() => %d\n"
        "\tpMsgHead     = %p\n"
        "\tsig length   = %d\n"
        "\tpsig         = %p\n"
        "\tOriginalXid  = 0x%x\n"
        "\tpQuerySig    = %p\n"
        "\tQS length    = %d\n",
        status,
        pMsgHead,
        sigLength,
        ptsigRR->Data.TSIG.pSignature,
        ptsigRR->Data.TSIG.wOriginalXid,
        pSecPack->pQuerySig,
        pSecPack->QuerySigLength ));

    return( status );
}



DNS_STATUS
Dns_ExtractGssTkeyFromMessage(
    IN OUT  PSECPACK            pSecPack,
    IN      PDNS_HEADER         pMsgHead,
    IN      PCHAR               pMsgEnd,
    IN      BOOL                fIsServer
    )
/*++

Routine Description:

    Extracts a TKEY from packet and loads into security context.

Arguments:

    pSecPack    - security info for packet

    pMsgHead    - msg to extract security context from

    pMsgEnd     - end of message

    fIsServer   - performing this operation as DNS server?

Return Value:

    ERROR_SUCCESS if successful.
    DNS_ERROR_FORMERR if badly formed TKEY
    DNS_STATUS_PACKET_UNSECURE if security context in response is same as query's
        indicating non-security aware partner
    RCODE or extended RCODE on failure.

--*/
{
    DNS_STATUS      status = ERROR_INVALID_DATA;
    PCHAR           pch;
    PCHAR           pnameOwner;
    WORD            nameLength;
    DWORD           currentTime;
    PDNS_PARSED_RR  pparsedRR;
    PDNS_RECORD     ptkeyRR;
    WORD            returnExtendedRcode = 0;
    DWORD           version;

    DNSDBG( SECURITY, (
        "ExtractGssTkeyFromMessage( %p )\n", pMsgHead ));

    //
    //  free any previous TKEY
    //      - may have one from previous pass in two pass negotiation
    //
    //  DCR:  name should be attached to TKEY\TSIG record
    //      then lookup made with IP\name pair against context key
    //      no need for pszContextName field
    //

    if ( pSecPack->pTkeyRR || pSecPack->pszContextName )
    {
        // Dns_RecordFree( pSecPack->pTkeyRR );
        FREE_HEAP( pSecPack->pTkeyRR );
        DnsApiFree( pSecPack->pszContextName );

        pSecPack->pTkeyRR = NULL;
        pSecPack->pszContextName = NULL;
    }

    //  set message pointers

    pSecPack->pMsgHead = pMsgHead;
    pSecPack->pMsgEnd = pMsgEnd;

    //
    //  skip to TKEY record (second record in packet)
    //

    pch = Dns_SkipToRecord(
                 pMsgHead,
                 pMsgEnd,
                 (1)            // skip question only
                 );
    if ( !pch )
    {
        status = DNS_ERROR_RCODE_FORMAT_ERROR;
        goto Failed;
    }

    //
    //  read TKEY owner name
    //

    pparsedRR = &pSecPack->ParsedRR;

    pparsedRR->pchName = pch;

    pch = Dns_ReadPacketNameAllocate(
            & pSecPack->pszContextName,
            & nameLength,
            0,
            0,
            pch,
            (PCHAR)pMsgHead,
            pMsgEnd );
    if ( !pch )
    {
        DNSDBG( SECURITY, (
            "WARNING:  invalid TKEY RR owner name at %p.\n",
            pch ));
        status = DNS_ERROR_RCODE_FORMAT_ERROR;
        goto Failed;
    }

    //
    //  parse record structure
    //

    pch = Dns_ReadRecordStructureFromPacket(
                pch,
                pMsgEnd,
                pparsedRR );
    if ( !pch )
    {
        DNSDBG( SECURITY, (
            "ERROR:  invalid security RR in packet at %p.\n"
            "\tstructure or data not within packet\n",
            pMsgHead ));
        status = DNS_ERROR_RCODE_FORMAT_ERROR;
        goto Failed;
    }
    if ( pparsedRR->Type != DNS_TYPE_TKEY )
    {
        status = DNS_ERROR_RCODE_FORMAT_ERROR;
        DNS_ASSERT( status != DNS_ERROR_RCODE_FORMAT_ERROR );
        goto Failed;
    }
    if ( pch != pMsgEnd  &&  pMsgHead->AdditionalCount == 0 )
    {
        DNSDBG( SECURITY, (
            "WARNING:  TKEY RR does NOT end at packet end and no TSIG is present.\n"
            "\tRR end offset    = %04x\n"
            "\tmsg end offset   = %04x\n",
            pch - (PCHAR)pMsgHead,
            pMsgEnd - (PCHAR)pMsgHead ));
    }

    //
    //  extract TKEY record
    //

    ptkeyRR = Tkey_RecordRead(
                NULL,
                DnsCharSetWire,
                NULL,                   // message buffer unknown
                pparsedRR->pchData,
                pparsedRR->pchNextRR
                );
    if ( !ptkeyRR )
    {
        DNSDBG( ANY, (
            "ERROR:  invalid TKEY RR data in packet at %p.\n",
            pMsgHead ));
        status = DNS_ERROR_RCODE_FORMAT_ERROR;
        goto Failed;
    }
    pSecPack->pTkeyRR = ptkeyRR;

    //
    //  verify GSS algorithm and mode name
    //
    //  if server, save off version for later responses
    //

    if ( RtlEqualMemory(
            ptkeyRR->Data.TKEY.pAlgorithmPacket,
            g_pAlgorithmNameCurrent,
            GSS_ALGORITHM_NAME_PACKET_LENGTH ) )
    {
        version = TKEY_VERSION_CURRENT;
    }
    else if ( RtlEqualMemory(
                ptkeyRR->Data.TKEY.pAlgorithmPacket,
                g_pAlgorithmNameW2K,
                W2K_GSS_ALGORITHM_NAME_PACKET_LENGTH ) )
    {
        version = TKEY_VERSION_W2K;
    }
    else
    {
        DNSDBG( ANY, (
            "ERROR:  TKEY record is NOT GSS alogrithm.\n" ));
        returnExtendedRcode = DNS_RCODE_BADKEY;
        goto Failed;
    }

    //  save client version
    //  need additional check on TKEY_VERSION_CURRENT as Whistler
    //  beta clients had fixed AlgorithmName but were still not
    //  generating unique keys, so need separate version to handle them

    if ( fIsServer )
    {
        if ( version == TKEY_VERSION_CURRENT )
        {
            version = Dns_GetKeyVersion( pSecPack->pszContextName );
            if ( version == 0 )
            {
                //  note, this essentially means unknown non-MS client

                DNSDBG( SECURITY, (
                    "Non-MS TKEY client.\n"
                    "\tkey name = %s\n",
                    pSecPack->pszContextName ));
                version = TKEY_VERSION_CURRENT;
            }
        }
        pSecPack->TkeyVersion = version;
    }

    //  mode

    if ( ptkeyRR->Data.TKEY.wMode != DNS_TKEY_MODE_GSS )
    {
        DNSDBG( SECURITY, (
            "ERROR:  non-GSS mode (%d) in TKEY\n",
            ptkeyRR->Data.TKEY.wMode ));
        returnExtendedRcode = DNS_RCODE_BADKEY;
        goto Failed;
    }

    //
    //  allow small time slew, otherwise must have fresh key
    //

    currentTime = (DWORD) time(NULL);

    if ( ptkeyRR->Data.TKEY.dwCreateTime > ptkeyRR->Data.TKEY.dwExpireTime ||
        ptkeyRR->Data.TKEY.dwExpireTime + MAX_TIME_SKEW < currentTime )
    {
        DNSDBG( ANY, (
            "ERROR:  TKEY failed expire time check.\n"
            "\tcreate time  = %d\n"
            "\texpire time  = %d\n"
            "\tcurrent time = %d\n",
            ptkeyRR->Data.TKEY.dwCreateTime,
            ptkeyRR->Data.TKEY.dwExpireTime,
            currentTime ));

        if ( !SecBigTimeSkew ||
            ptkeyRR->Data.TKEY.dwExpireTime + SecBigTimeSkew < currentTime )
        {
            returnExtendedRcode = DNS_RCODE_BADTIME;
            SecTkeyBadTime++;
            goto Failed;
        }

        DNSDBG( ANY, (
            "REPRIEVED:  TKEY Time slew %d within %d allowable slew!\n",
            currentTime - ptkeyRR->Data.TKEY.dwCreateTime,
            SecBigTimeSkew ));

        SecBigTimeSkewBypass++;
    }

    //
    //  currently callers expect error on Extract when ext RCODE is set
    //

    if ( ptkeyRR->Data.TKEY.wError )
    {
        DNSDBG( SECURITY, (
            "Leaving ExtractGssTkey(), TKEY had extended RCODE = %d\n",
            ptkeyRR->Data.TKEY.wError ));
        status = DNS_ERROR_FROM_RCODE( ptkeyRR->Data.TKEY.wError );
        goto Failed;
    }

#if 0
    //
    //  check for security record echo on response
    //
    //  if we get echo of TKEY back, then probably simple, no-secure server
    //
#endif

    //
    //  pack key token into GSS security token buffer
    //      do this here simply to avoid doing in both client and server routines
    //

    pSecPack->RemoteBuf.pvBuffer     = ptkeyRR->Data.TKEY.pKey;
    pSecPack->RemoteBuf.cbBuffer     = ptkeyRR->Data.TKEY.wKeyLength;
    pSecPack->RemoteBuf.BufferType   = SECBUFFER_TOKEN;

    status = ERROR_SUCCESS;

Failed:

    if ( status != ERROR_SUCCESS )
    {
        SecTkeyInvalid++;
    }

    //  if failed with extended RCODE, set for return

    if ( returnExtendedRcode )
    {
        pSecPack->ExtendedRcode = returnExtendedRcode;
        status = DNS_ERROR_FROM_RCODE( returnExtendedRcode );
    }

    DNSDBG( SECURITY, (
        "Leave ExtractGssTkeyFromMessage()\n"
        "\tstatus       = %08x (%d)\n"
        "\tpMsgHead     = %p\n"
        "\tpkey         = %p\n"
        "\tlength       = %d\n",
        status, status,
        pMsgHead,
        pSecPack->RemoteBuf.pvBuffer,
        pSecPack->RemoteBuf.cbBuffer ));

    return( status );
}



PCHAR
Dns_CopyAndCanonicalizeWireName(
    IN      PCHAR       pszInput,
    OUT     PCHAR       pszOutput,
    OUT     DWORD       dwOutputSize
    )
/*++

Routine Description:

    Copy a UTF-8 uncompressed DNS wire packet name performing
    canonicalization during the copy.

Arguments:

    pszInput -- pointer to input buffer
    pszOutput -- pointer to output buffer
    dwOutputSize -- number of bytes available at output buffer

Return Value:

    Returns a pointer to the byte after the last byte written into
    the output buffer or NULL on error.

--*/
{
    UCHAR   labelLength;
    WCHAR   wszlabel[ DNS_MAX_LABEL_BUFFER_LENGTH + 1 ];
    DWORD   bufLength;
    DWORD   outputCharsRemaining = dwOutputSize;
    DWORD   dwtemp;
    PCHAR   pchlabelLength;

    while ( ( labelLength = *pszInput++ ) != 0 )
    {
        //
        //  Error if this label is too long or if the output buffer can't
        //  hold at least as many chars as in the uncanonicalized buffer.
        //

        if ( labelLength > DNS_MAX_LABEL_LENGTH ||
             outputCharsRemaining < labelLength )
        {
            goto Error;
        }

        //
        //  Copy this UTF-8 label to a Unicode buffer.
        //

        bufLength = DNS_MAX_NAME_BUFFER_LENGTH_UNICODE;

        if ( !Dns_NameCopy(
                    ( PCHAR ) wszlabel,
                    &bufLength,
                    pszInput,
                    labelLength,
                    DnsCharSetUtf8,
                    DnsCharSetUnicode ) )
        {
            goto Error;
        }

        pszInput += labelLength;

        //
        //  Canonicalize the buffer.
        //

        dwtemp = Dns_MakeCanonicalNameInPlaceW(
                            wszlabel,
                            (DWORD) labelLength );
        if ( dwtemp == 0 || dwtemp > DNS_MAX_LABEL_LENGTH )
        {
            goto Error;
        }
        labelLength = ( UCHAR ) dwtemp;

        //
        //  Copy the label to the output buffer.
        //

        pchlabelLength = pszOutput++;       //  Reserve byte for label length.

        dwtemp = outputCharsRemaining;
        if ( !Dns_NameCopy(
                    pszOutput,
                    &dwtemp,
                    ( PCHAR ) wszlabel,
                    labelLength,
                    DnsCharSetUnicode,
                    DnsCharSetUtf8 ) )
        {
            goto Error;
        }

        outputCharsRemaining -= dwtemp;

        --dwtemp;   //  Don't include NULL in label length.

        *pchlabelLength = (UCHAR) dwtemp;
        pszOutput += dwtemp;
    }
    
    //
    //  Add name terminator.
    //

    *pszOutput++ = 0;

    return pszOutput;

Error:

    return NULL;
}   //  Dns_CopyAndCanonicalizeWireName



DNS_STATUS
Dns_VerifySignatureOnPacket(
    IN      PSECPACK        pSecPack
    )
/*++

Routine Description:

    Verify signature on packet contained in security record.

Arguments:

    pSecPack - security packet session info

Return Value:

    ERROR_SUCCESS on success
    DNS_ERROR_BADSIG if sig doesn't exist or doesn't verify
    DNS_ERROR_BADTIME if sig expired
    Extended RCODE from caller if set.

--*/
{
    PSEC_CNTXT      psecCtxt;
    PDNS_HEADER     pmsgHead = pSecPack->pMsgHead;
    PCHAR           pmsgEnd = pSecPack->pMsgEnd;
    PDNS_RECORD     ptsigRR;
    PDNS_PARSED_RR  pparsedRR;
    DWORD           currentTime;
    PCHAR           pbufStart = NULL;
    PCHAR           pbuf;
    DNS_STATUS      status;
    DWORD           length;
    WORD            returnExtendedRcode = 0;
    SecBufferDesc   bufferDesc;
    SecBuffer       buffer[2];
    WORD            msgXid;
    DWORD           version;
    BOOL            fcanonicalizeTsigOwnerName;


    DNSDBG( SECURITY, (
        "VerifySignatureOnPacket( %p )\n", pmsgHead ));

    //
    //  get security context
    //

    psecCtxt = pSecPack->pSecContext;
    if ( !psecCtxt )
    {
        DNS_PRINT(( "ERROR:  attempted signing without security context!!!\n" ));
        ASSERT( FALSE );
        status = DNS_ERROR_RCODE_BADKEY;
        goto Exit;
    }

    //
    //  if no signature extracted from packet, we're dead
    //

    pparsedRR = &pSecPack->ParsedRR;
    ptsigRR = pSecPack->pTsigRR;
    if ( !ptsigRR )
    {
        returnExtendedRcode = DNS_RCODE_BADSIG;
        goto Exit;
    }

    //
    //  validity check GSS-TSIG
    //      - GSS algorithm
    //      - valid time
    //      - extract extended RCODE
    //
    //  DCR_ENHANCE:  check tampering on bad TSIG?
    //      - for tampered algorithm all we can do is immediate return
    //      - but can check signature and detect tampering
    //          before excluding or basis or time or believing ext RCODE
    //

    //  check algorithm name

    if ( RtlEqualMemory(
            ptsigRR->Data.TKEY.pAlgorithmPacket,
            g_pAlgorithmNameCurrent,
            GSS_ALGORITHM_NAME_PACKET_LENGTH ) )
    {
        version = TKEY_VERSION_CURRENT;
    }
    else if ( RtlEqualMemory(
                ptsigRR->Data.TKEY.pAlgorithmPacket,
                g_pAlgorithmNameW2K,
                W2K_GSS_ALGORITHM_NAME_PACKET_LENGTH ) )
    {
        version = TKEY_VERSION_W2K;
    }
    else
    {
        DNSDBG( ANY, (
            "ERROR:  TSIG record is NOT GSS alogrithm.\n" ));
        returnExtendedRcode = DNS_RCODE_BADSIG;
        goto Exit;
    }

    //
    //  set version if server
    //      - if don't know our version, must be server
    //      note:  alternative is fIsServer flag or IsServer to SecPack
    //

    if ( psecCtxt->Version == 0 )
    {
        psecCtxt->Version = version;
    }

    //
    //  time check
    //      - should be within specified fudge of signing time
    //

    currentTime = (DWORD) time(NULL);

    if ( (LONGLONG)currentTime >
         ptsigRR->Data.TSIG.i64CreateTime +
         (LONGLONG)ptsigRR->Data.TSIG.wFudgeTime
            ||
        (LONGLONG)currentTime <
         ptsigRR->Data.TSIG.i64CreateTime -
         (LONGLONG)ptsigRR->Data.TSIG.wFudgeTime )
    {
        DNSDBG( ANY, (
            "ERROR:  TSIG failed fudge time check.\n"
            "\tcreate time  = %I64d\n"
            "\tfudge time  = %d\n"
            "\tcurrent time = %d\n",
            ptsigRR->Data.TSIG.i64CreateTime,
            ptsigRR->Data.TSIG.wFudgeTime,
            currentTime ));

        //
        //  DCR_FIX:  currently not enforcing time check
        //      in fact have ripped out the counter to track failures
        //      within some allowed skew
    }

    //
    //  extended RCODE -- follows signature
    //      - if set, report back to caller
    //

    if ( ptsigRR->Data.TSIG.wError )
    {
        DNSDBG( SECURITY, (
            "Leaving VerifySignature(), TSIG had extended RCODE = %d\n",
            ptsigRR->Data.TSIG.wError ));
        returnExtendedRcode = ptsigRR->Data.TSIG.wError;
        goto Exit;
    }

    //
    //  create signing buffer
    //      - everything signed must fit into message
    //

    pbuf = ALLOCATE_HEAP( MAX_SIGNING_SIZE );
    if ( !pbuf )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Exit;
    }
    pbufStart = pbuf;

    //
    //  verify signature over:
    //      - query signature (if exists)
    //      - message
    //          - without TSIG in Additional count
    //          - with original XID
    //      - TSIG owner name
    //      - TSIG header
    //          - class
    //          - TTL
    //      - TSIG RDATA
    //          - everything before SigLength
    //          - other data length and other data
    //

    if ( pmsgHead->IsResponse )
    {
        if ( pSecPack->pQuerySig )
        {
            WORD    sigLength = pSecPack->QuerySigLength;

            ASSERT( sigLength );
            DNS_ASSERT( psecCtxt->Version != 0 );

            if ( psecCtxt->Version != TKEY_VERSION_W2K )
            {
                INLINE_WRITE_FLIPPED_WORD( pbuf, sigLength );
                pbuf += sizeof(WORD);
            }
            RtlCopyMemory(
                pbuf,
                pSecPack->pQuerySig,
                sigLength );

            pbuf += sigLength;
        }

        //  if server has just completed TKEY nego, it may sign response without query
        //  so client need not have query sig
        //  in all other cases client must have query sig to verify response

        else if ( !pSecPack->pTkeyRR )
        {
            DNS_PRINT((
                "ERROR:  verify on response at %p without having QUERY signature!\n",
                pmsgHead ));
            ASSERT( FALSE );
            returnExtendedRcode = DNS_RCODE_BADSIG;
            goto Exit;
        }
        ELSE_IF_DNSDBG( SECURITY )
        {
            DNS_PRINT(( "Verifying TSIG on TKEY response without query sig.\n" ));
        }
    }

    //
    //  copy message
    //      - go right through, TSIG owner name
    //      - message header MUST be in network order
    //      - does NOT include TSIG record in additional count
    //      - must have orginal XID in place
    //      (save existing XID and replace with orginal, then
    //      restore after copy)
    //

    ASSERT( pmsgHead->AdditionalCount );

    pmsgHead->AdditionalCount--;
    msgXid = pmsgHead->Xid;

    DNS_BYTE_FLIP_HEADER_COUNTS( pmsgHead );

    //
    //  determine if must canonicalize the TSIG owner name
    //      - if so, copy only to start of name
    //      - if not (Win2K) copy entire name
    //

    fcanonicalizeTsigOwnerName = !psecCtxt->fClient &&
                                 psecCtxt->Version >= TKEY_VERSION_XP;

    length = (DWORD) ( ( fcanonicalizeTsigOwnerName
                                ? pparsedRR->pchName 
                                : pparsedRR->pchRR ) -
                           (PCHAR) pmsgHead );

    //  restore original XID

    pmsgHead->Xid = ptsigRR->Data.TSIG.wOriginalXid;

    RtlCopyMemory(
        pbuf,
        (PCHAR) pmsgHead,
        length );

    pbuf += length;

    DNS_BYTE_FLIP_HEADER_COUNTS( pmsgHead );
    pmsgHead->AdditionalCount++;
    pmsgHead->Xid = msgXid;

    //
    //  If the TSIG owner name needs to be canonicalized, write it out
    //  to the signing buffer in canonical form (lower case).
    //

    if ( fcanonicalizeTsigOwnerName )
    {
        pbuf = Dns_CopyAndCanonicalizeWireName(
                    pparsedRR->pchName,
                    pbuf,
                    MAXDWORD );

        if ( pbuf == NULL )
        {
            DNSDBG( SECURITY, (
                "Unable to canonicalize TSIG owner name at %p",
                pparsedRR->pchName ));
            returnExtendedRcode = DNS_RCODE_BADSIG;
            goto Exit;
        }
    }

    //  copy TSIG class and TTL
    //      - currently always zero

    INLINE_WRITE_FLIPPED_WORD( pbuf, pparsedRR->Class );
    pbuf += sizeof(WORD);
    INLINE_WRITE_FLIPPED_DWORD( pbuf, pparsedRR->Ttl );
    pbuf += sizeof(DWORD);

    //  copy TSIG RDATA up to signature length

    length = (DWORD)(ptsigRR->Data.TSIG.pSignature - sizeof(WORD) - pparsedRR->pchData);

    ASSERT( (INT)length < (pparsedRR->DataLength - ptsigRR->Data.TSIG.wSigLength) );

    RtlCopyMemory(
        pbuf,
        pparsedRR->pchData,
        length );

    pbuf += length;

    //  copy extended RCODE -- report back to caller

    INLINE_WRITE_FLIPPED_WORD( pbuf, ptsigRR->Data.TSIG.wError );
    pbuf += sizeof(WORD);

    //  copy other data length and other data
    //      - currently just zero length field

    INLINE_WRITE_FLIPPED_WORD( pbuf, ptsigRR->Data.TSIG.wOtherLength );
    pbuf += sizeof(WORD);

    length = ptsigRR->Data.TSIG.wOtherLength;
    if ( length )
    {
        RtlCopyMemory(
            pbuf,
            ptsigRR->Data.TSIG.pOtherData,
            length );
        pbuf += length;
    }

    //  calculate total length signature is over

    length = (DWORD)(pbuf - pbufStart);

    //
    //  verify signature
    //      buf[0] is data
    //      buf[1] is signature
    //
    //  signature is verified directly in packet buffer
    //

    bufferDesc.ulVersion  = 0;
    bufferDesc.cBuffers   = 2;
    bufferDesc.pBuffers   = buffer;

    //  signature is over everything up to signature itself

    buffer[0].pvBuffer     = pbufStart;
    buffer[0].cbBuffer     = length;
    buffer[0].BufferType   = SECBUFFER_DATA;

    //  sig MUST be pointed to by remote buffer
    //
    //  DCR:  can pull copy when eliminate retry below
    //
    //  copy packet signature as signing is destructive
    //      and want to allow for retry
    //

    buffer[1].pvBuffer     = ptsigRR->Data.TSIG.pSignature;
    buffer[1].cbBuffer     = ptsigRR->Data.TSIG.wSigLength;
    buffer[1].BufferType   = SECBUFFER_TOKEN;

    IF_DNSDBG( SECURITY )
    {
        DnsPrint_Lock();
        DNS_PRINT((
            "Doing VerifySignature() on packet %p.\n"
            "\tpSecPack     = %p\n"
            "\tpSecCntxt    = %p\n",
            pmsgHead,
            pSecPack,
            psecCtxt
            ));
        DNS_PRINT((
            "Verify sig info:\n"
            "\tsign data buf    %p\n"
            "\t  length         %d\n"
            "\tsignature buf    %p (in packet)\n"
            "\t  length         %d\n",
            buffer[0].pvBuffer,
            buffer[0].cbBuffer,
            buffer[1].pvBuffer,
            buffer[1].cbBuffer
            ));
        DnsDbg_RawOctets(
            "Signing buffer:",
            NULL,
            buffer[0].pvBuffer,
            buffer[0].cbBuffer
            );
        DnsDbg_RawOctets(
            "Signature:",
            NULL,
            buffer[1].pvBuffer,
            buffer[1].cbBuffer
            );
        DnsDbg_SecurityContext(
            "Verify context",
            psecCtxt );
        DnsPrint_Unlock();
    }

    status = g_pSecurityFunctionTable->VerifySignature(
                    & psecCtxt->hSecHandle,
                    & bufferDesc,
                    0,
                    NULL
                    );

    if ( status != SEC_E_OK )
    {
        IF_DNSDBG( SECURITY )
        {
            DnsPrint_Lock();
            DNS_PRINT((
                "ERROR:  TSIG does not match on packet %p.\n"
                "\tVerifySignature() status = %d (%08x)\n"
                "\tpSecPack     = %p\n"
                "\tpSecCntxt    = %p\n"
                "\thSecHandle   = %p\n",
                pmsgHead,
                status, status,
                pSecPack,
                psecCtxt,
                & psecCtxt->hSecHandle
                ));
            DNS_PRINT((
                "Verify sig info:\n"
                "\tsign data buf    %p\n"
                "\t  length         %d\n"
                "\tsignature buf    %p (in packet)\n"
                "\t  length         %d\n",
                buffer[0].pvBuffer,
                buffer[0].cbBuffer,
                buffer[1].pvBuffer,
                buffer[1].cbBuffer
                ));
            DnsDbg_RawOctets(
                "Signing buffer:",
                NULL,
                buffer[0].pvBuffer,
                buffer[0].cbBuffer
                );
            DnsDbg_RawOctets(
                "Signature:",
                NULL,
                buffer[1].pvBuffer,
                buffer[1].cbBuffer
                );
            DnsDbg_SecurityContext(
                "Verify failed context",
                psecCtxt );
            DnsDbg_MessageNoContext(
                "Message TSIG verify failed on:",
                pmsgHead,
                0 );
            DnsPrint_Unlock();
        }
        SecTsigVerifyFailed++;
        returnExtendedRcode = DNS_RCODE_BADSIG;
        goto Exit;
    }

    SecTsigVerifySuccess++;

Exit:

    //  free signing data buffer

    FREE_HEAP( pbufStart );

    //  if failed with extended RCODE, set for return

    if ( returnExtendedRcode )
    {
        pSecPack->ExtendedRcode = returnExtendedRcode;
        status = DNS_ERROR_FROM_RCODE( returnExtendedRcode );
    }

    DNSDBG( SECURITY, (
        "Leave VerifySignatureOnPacket( %p )\n"
        "\tstatus       %d (%08x)\n"
        "\text RCODE    %d\n",
        pmsgHead,
        status, status,
        pSecPack->ExtendedRcode ));

    return( status );
}




//
//  Secure update client routines
//

DNS_STATUS
Dns_NegotiateTkeyWithServer(
    OUT     PHANDLE         phContext,
    IN      DWORD           dwFlag,
    IN      PWSTR           pszNameServer,
    IN      PDNS_ADDR_ARRAY pServerList,
    IN      PCHAR           pCreds,         OPTIONAL
    IN      PCHAR           pszContext,     OPTIONAL
    IN      DWORD           Version
    )
/*++

Routine Description:

    Negotiate TKEY with a DNS server.

Arguments:

    phContext -- addr to recv context (SEC_CNTXT) negotiated

    dwFlags -- flags

    pszNameServer -- server to update

    apiServer -- server to update

    pCreds -- credentials;  if not given use default process creds

    pszContext -- security context name;  name for unique negotiated security
        session between client and server;  if not given create made up
        server\pid name for context

    Version -- verion

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    DNS_STATUS      status;
    PSEC_CNTXT      psecCtxt = NULL;
    SECPACK         secPack;
    PCHAR           pch;
    PWSTR           pcredKey = NULL;
    DNS_SECCTXT_KEY key;
    DWORD           i;
    BOOL            fdoneNegotiate = FALSE;
    PDNS_MSG_BUF    pmsgSend = NULL;
    PDNS_MSG_BUF    pmsgRecv = NULL;
    WORD            length;
    PDNS_ADDR       pservAddr = &pServerList->AddrArray[0];
    CHAR            defaultContextBuffer[64];
    BOOL            fserverW2K = FALSE;
    DWORD           recvCount;
    PCHAR           pcurrentAfterQuestion;


    DNSDBG( SECURITY, (
        "Enter Dns_NegotiateTkeyWithServer()\n"
        "\tflags        = %08x\n"
        "\tserver IP    = %s\n"
        "\tserver name  = %S\n"
        "\tpCreds       = %p\n"
        "\tcontext      = %s\n",
        dwFlag,
        DNSADDR_STRING( pservAddr ),
        pszNameServer,
        pCreds,
        pszContext
        ));

    DNS_ASSERT( pszNameServer ); // it better be there!

    //  init first so all error paths are safe

    Dns_InitSecurityPacketInfo( &secPack, NULL );

    //  start security

    status = Dns_StartSecurity(
                    FALSE   // not process attach
                    );
    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  build key
    //

    RtlZeroMemory(
        &key,
        sizeof(key) );

    //
    //  if have creds, create a "cred key" to uniquely identify
    //

    if ( pCreds )
    {
        pcredKey = MakeCredKey( pCreds );
        if ( !pcredKey )
        {
            DNSDBG( ANY, (
                "Failed cred key alloc -- failing nego!\n" ));
            status = DNS_ERROR_NO_MEMORY;
            goto Cleanup;
        }
        key.pwsCredKey = pcredKey;
    }

    //
    //  context name
    //      - if no context name, concatentate
    //          - process ID
    //          - current user's domain-relative ID
    //      this makes ID unique to process\security context
    //      (IP handles issue of different machines)
    //
    //  versioning note:
    //      - it is NOT necessary to version using the KEY name
    //      - the point is to allow us to easily interoperate with previous
    //      client versions which may have bugs relative to the final spec
    //
    //  versions so far
    //      - W2K beta2 (-02) included XID
    //      - W2K (-03) sent TKEY in answer and used "gss.microsoft.com"
    //          as algorithm name
    //      - SP1(or2) and whistler beta2 (-MS-04) used "gss-tsig"
    //      - XP post beta 2 (-MS-05) generates unique context name to
    //          avoid client collisions
    //      - XP RC1 (-MS-06) RFC compliant signing with query sig length included
    //      - XP RC2+ canonicalization of TSIG name in signing buffer
    //
    //  server version use:
    //      - the Win2K server does detect version 02 and fixup the XID
    //      signing to match client
    //      - current (whistler) server does NOT use the version field
    //
    //      however to enable server to detect whistler beta2 client --
    //      just in case there's another problem relative to the spec --
    //      i'm maintaining field;
    //      however note that the field will be 04, even if the client
    //      realizes it is talking to a W2K server and falls back to W2K
    //      client behavior;  in other words NEW server will see 04, but
    //      W2K server only knows it is NOT talking to 02 server which is
    //      all it cares about;
    //
    //      key idea:  this can be used to detect a particular MS client
    //          when there's a behavior question ... but it is NOT a spec'd
    //          versioning mechanism and other clients will come in with
    //          no version tag and must be treated per spec
    //
    //  Key string selection: it is important that the key string be
    //  in "canonical" form as per RFC 2535 section 8.1 - basically this
    //  means lower case. Since the key string is canonical it doesn't
    //  matter if the server does or doesn't canonicalize the string
    //  when building the signing buffer.
    //

    if ( Version == 0 )
    {
        Version = TKEY_VERSION_CURRENT;
    }

    if ( !pszContext )
    {
        sprintf(
            defaultContextBuffer,
            "%d-ms-%d",
            //Dns_GetCurrentRid(),
            GetCurrentProcessId(),
            Version );

        pszContext = defaultContextBuffer;

        DNSDBG( SECURITY, (
            "Generated secure update key context %s\n",
            pszContext ));
    }
    key.pszClientContext = pszContext;

    //
    //  check for negotiated security context
    //      - check for context to any of server IPs
    //      - dump, if partially negotiated or forcing renegotiated
    //

    for( i=0; i<pServerList->AddrCount; i++ )
    {
        DnsAddr_Copy( &key.RemoteAddr, &pServerList->AddrArray[i] );

        psecCtxt = Dns_DequeueSecurityContextByKey( key, TRUE );
        if ( psecCtxt )
        {
            if ( !psecCtxt->fNegoComplete ||
                  (dwFlag & DNS_UPDATE_FORCE_SECURITY_NEGO) )
            {
                DNSDBG( ANY, (
                    "Warning:  Deleting context to negotiate a new one.\n"
                    "\tKey: [%s, %s]\n"
                    "\tReason: %s\n",
                    DNSADDR_STRING( &key.RemoteAddr ),
                    key.pszTkeyName,
                    psecCtxt->fNegoComplete
                        ? "User specified FORCE_SECURITY_NEGO flag."
                        : "Incomplete negotiation key exists." ));

                Dns_FreeSecurityContext( psecCtxt );
            }

            //  have valid context -- we're done!
            //      - bump use count (serves as flag for cached context)

            else
            {
                ASSERT( psecCtxt->fNegoComplete );
                psecCtxt->UseCount++;
                DNSDBG( SECURITY, (
                    "Returning existing negotiated context at %p\n",
                    psecCtxt ));
                goto Cleanup;
            }
        }
    }

    //
    //  create new context and security packet info
    //      - use first server IP in key
    //

    pservAddr = &pServerList->AddrArray[0];
    DnsAddr_Copy( &key.RemoteAddr, pservAddr );

    psecCtxt = Dns_FindOrCreateSecurityContext( key );
    if ( !psecCtxt )
    {
        status = DNS_RCODE_SERVER_FAILURE;
        goto Cleanup;
    }
    secPack.pSecContext = psecCtxt;
    psecCtxt->Version = Version;

    //
    //  have creds -- get cred handle
    //

    if ( pCreds )
    {
        status = Dns_AcquireCredHandle(
                    &psecCtxt->CredHandle,
                    FALSE,          // client
                    pCreds );

        if ( status != ERROR_SUCCESS )
        {
            DNSDBG( SECURITY, (
                "Failed AcquireCredHandle -- failing nego!\n" ));
            goto Cleanup;
        }
        psecCtxt->fHaveCredHandle = TRUE;
    }

    //  allocate message buffers

    length = DNS_TCP_DEFAULT_ALLOC_LENGTH;

    pmsgSend= Dns_AllocateMsgBuf( length );
    if ( !pmsgSend)
    {
        DNS_PRINT(( "ERROR:  failed allocation.\n" ));
        status = GetLastError();
        goto Cleanup;
    }
    pmsgRecv = Dns_AllocateMsgBuf( length );
    if ( !pmsgRecv )
    {
        DNS_PRINT(( "ERROR:  failed allocation.\n"));
        status = GetLastError();
        goto Cleanup;
    }

    //
    //  DCR:  modularize all send\recv
    //      - should only have one server anyway
    //

    //
    //  init for TCP
    //      - setup receive buffer for TCP

    pmsgSend->Socket = 0;
    pmsgSend->fTcp = TRUE;

    SET_MESSAGE_FOR_TCP_RECV( pmsgRecv );
    pmsgRecv->Timeout = SECURE_UPDATE_TCP_TIMEOUT;

    //
    //  build packet
    //      - query opcode
    //      - leave non-recursive (so downlevel server doesn't recurse query)
    //      - write TKEY question
    //      - write TKEY itself
    //

    pch = Dns_WriteQuestionToMessage(
                pmsgSend,
                psecCtxt->Key.pszTkeyName,
                DNS_TYPE_TKEY,
                FALSE           // not unicode
                );
    if ( !pch )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Cleanup;
    }

    pcurrentAfterQuestion = pch;

    pmsgSend->MessageHead.RecursionDesired = 0;
    pmsgSend->MessageHead.Opcode = DNS_OPCODE_QUERY;

    //
    //  init XID to something fairly random
    //

    pmsgSend->MessageHead.Xid = Dns_GetRandomXid( pmsgSend );


    //
    //  for given server send in a loop
    //      - write TKEY context to packet
    //      - send \ recv
    //      - may have multiple sends until negotiate a TKEY
    //

    while ( 1 )
    {
        //  setup session context
        //  on first pass this just builds our context,
        //  on second pass we munge in servers response

        status = Dns_InitClientSecurityContext(
                        &secPack,
                        pszNameServer,
                        & fdoneNegotiate
                        );

        //  always recover context pointer, as bad context may be deleted

        psecCtxt = secPack.pSecContext;
        ASSERT( psecCtxt ||
                (status != ERROR_SUCCESS && status != DNS_STATUS_CONTINUE_NEEDED) );

        if ( status == ERROR_SUCCESS )
        {
            DNSDBG( SECURITY, ( "Successfully negotiated TKEY.\n" ));
            ASSERT( psecCtxt->fNegoComplete );

            //
            //  if completed and remote packet had SIG -- verify SIG
            //

            status = Dns_ExtractGssTsigFromMessage(
                        &secPack,
                        & pmsgRecv->MessageHead,
                        DNS_MESSAGE_END( pmsgRecv )
                        );
            if ( status == ERROR_SUCCESS )
            {
                status = Dns_VerifySignatureOnPacket( &secPack );
                if ( status != ERROR_SUCCESS )
                {
                    DNSDBG( SECURITY, (
                        "Verify signature failed on TKEY nego packet %p.\n"
                        "\tserver   = %s\n"
                        "\tstatus   = %d (%08x)\n"
                        "\treturning BADSIG\n",
                        pmsgRecv,
                        DNSADDR_STRING( pservAddr ),
                        status, status ));
                    status = DNS_ERROR_RCODE_BADSIG;
                }
            }
            else if ( status == DNS_STATUS_PACKET_UNSECURE )
            {
                DNSDBG( SECURITY, (
                    "WARNING:  Unsigned final TKEY nego response packet %p.\n"
                    "\tfrom server %s\n",
                    pmsgRecv,
                    DNSADDR_STRING( pservAddr ) ));
                status = ERROR_SUCCESS;
            }

            //  nego is done, break out of nego loop
            //  any other error on TSIG, falls through as failure

            break;
        }

        //
        //  if not complete, then anything other than continue is failure
        //

        else if ( status != DNS_STATUS_CONTINUE_NEEDED )
        {
            goto Cleanup;
        }

        //
        //  loop for sign and send
        //
        //  note this is only in a loop to enable backward compatibility
        //  with "TKEY-in-answer" bug in Win2000 DNS server
        //

        recvCount = 0;

        while ( 1 )
        {
            //
            //  backward compatibility with Win2000 TKEY
            //      - set version to write like W2K
            //      - reset packet to just-wrote-question state
            //

            if ( fserverW2K  &&  recvCount == 0 )
            {
                psecCtxt->Version = TKEY_VERSION_W2K;

                pmsgSend->pCurrent = pcurrentAfterQuestion;
                pmsgSend->MessageHead.AdditionalCount = 0;
                pmsgSend->MessageHead.AnswerCount = 0;

                Socket_CloseMessageSockets( pmsgSend );
            }

            //
            //  write security record with context into packet
            //
            //  note:  fNeedTkeyInAnswer determines whether write
            //          to Answer or Additional section
    
            status = Dns_WriteGssTkeyToMessage(
                        (HANDLE) &secPack,
                        & pmsgSend->MessageHead,
                        pmsgSend->pBufferEnd,
                        & pmsgSend->pCurrent,
                        FALSE                   // client
                        );
            if ( status != ERROR_SUCCESS )
            {
                goto Cleanup;
            }

            //
            //  if finished negotiation -- sign
            //
            
            if ( fdoneNegotiate )
            {
                DNSDBG( SECURITY, (
                    "Signing TKEY packet at %p, after successful nego.\n",
                    pmsgSend ));
            
                status = Dns_SignMessageWithGssTsig(
                            & secPack,
                            & pmsgSend->MessageHead,
                            pmsgSend->pBufferEnd,
                            & pmsgSend->pCurrent
                            );
                if ( status != ERROR_SUCCESS )
                {
                    DNSDBG( SECURITY, (
                        "ERROR:  Failed signing TKEY packet at %p, after successful nego.\n"
                        "\tsending without TSIG ...\n",
                        pmsgSend ));
                }
            }
            
            //
            //  if already connected, send
            //  if first pass, try server IPs, until find one to can connect to
            //
            //  DCR_QUESTION:  are we ok, just dropping IP in context here?
            //
            
            if ( pmsgSend->Socket )
            {
                status = Send_MessagePrivate(
                            pmsgSend,
                            NULL,   // default send IP
                            TRUE    // no OPT
                            );
            }
            else
            {
                for( i=0; i<pServerList->AddrCount; i++ )
                {
                    pservAddr = &pServerList->AddrArray[i];
            
                    status = Send_OpenTcpConnectionAndSend(
                                     pmsgSend,
                                     pservAddr,
                                     TRUE );
                    if ( status != ERROR_SUCCESS )
                    {
                        if ( pmsgSend->Socket )
                        {
                            Socket_CloseMessageSockets( pmsgSend );
                        }
                        continue;
                    }
                    DnsAddr_Copy( &psecCtxt->Key.RemoteAddr, pservAddr );
                    break;
                }
            }
            if ( status != ERROR_SUCCESS )
            {
                goto Done;
            }
            
            //
            //  receive response
            //      - if successful receive, done
            //      - if timeout continue
            //      - other errors indicate some setup or system level
            //          problem
            //
            
            pmsgRecv->Socket = pmsgSend->Socket;
            
            status = Dns_RecvTcp( pmsgRecv );
            if ( status != ERROR_SUCCESS )
            {
                //  W2K server may "eat" bad TKEY packet
                //  if just got a connection, and then timed out, good
                //  chance the problem is W2K server

                if ( status == ERROR_TIMEOUT &&
                     recvCount == 0 &&
                     !fserverW2K )
                {
                    DNS_PRINT(( "Timeout on TKEY nego -- retry with W2K protocol.\n" ));
                    fserverW2K = TRUE;
                    recvCount = 0;
                    continue;
                }

                //  indicate error only with this server by setting RCODE
                pmsgRecv->MessageHead.ResponseCode = DNS_RCODE_SERVER_FAILURE;
                goto Done;
            }
            recvCount++;
            
            //
            //  verify XID match
            //
            
            if ( pmsgRecv->MessageHead.Xid != pmsgSend->MessageHead.Xid )
            {
                DNS_PRINT(( "ERROR:  Incorrect XID in response. Ignoring.\n" ));
                goto Done;
            }

            //
            //  RCODE failure
            //
            //  special case Win2K gold DNS server accepting only TKEY
            //  in Answer section
            //      - rcode FORMERR
            //      - haven't already switched to Additional (prevent looping)
            //      

            if ( pmsgRecv->MessageHead.ResponseCode != DNS_RCODE_NO_ERROR )
            {
                if ( pmsgRecv->MessageHead.ResponseCode == DNS_RCODE_FORMERR &&
                     ! fserverW2K &&
                     recvCount == 1 )
                {
                    DNS_PRINT(( "Formerr TKEY nego -- retry with W2K protocol.\n" ));
                    fserverW2K = TRUE;
                    recvCount = 0;
                    continue;
                }

                //  done with this server, may be able to continue with others
                //  depending on RCODE

                goto Done;
            }

            //  successful send\recv

            break;
        }

        //
        //  not yet finished negotiation
        //  use servers security context to reply to server
        //  if server replied with original context then it is unsecure
        //      => we're done
        //

        status = Dns_ExtractGssTkeyFromMessage(
                    (HANDLE) &secPack,
                    &pmsgRecv->MessageHead,
                    DNS_MESSAGE_END( pmsgRecv ),
                    FALSE               //  fIsServer
                    );
        if ( status != ERROR_SUCCESS )
        {
            if ( status == DNS_STATUS_PACKET_UNSECURE )
            {
                DNSDBG( SECURITY, (
                    "Unsecure update response from server %s.\n"
                    "\tupdate considered successful, quiting.\n",
                    MSG_REMOTE_IPADDR_STRING( pmsgSend ) ));
                status = ERROR_SUCCESS;
                ASSERT( FALSE );
                goto Cleanup;
            }
            break;
        }
    }

Done:

    //
    //  check response code
    //      - consider some response codes
    //

    switch( status )
    {
    case ERROR_SUCCESS:
        status = Dns_MapRcodeToStatus( pmsgRecv->MessageHead.ResponseCode );
        break;

    case ERROR_TIMEOUT:

        DNS_PRINT((
            "ERROR:  connected to server at %s\n"
            "\tbut no response to packet at %p\n",
            MSG_REMOTE_IPADDR_STRING( pmsgSend ),
            pmsgSend
            ));
        break;

    default:

        DNS_PRINT((
            "ERROR:  connected to server at %s to send packet %p\n"
            "\tbut error %d (%08x) encountered on receive.\n",
            MSG_REMOTE_IPADDR_STRING( pmsgSend ),
            pmsgSend,
            status, status
            ));
        break;
    }

Cleanup:

    DNSDBG( SECURITY, (
        "Leaving Dns_NegotiateTkeyWithServer() status = %08x (%d)\n",
        status, status ));

    //
    //  if successful return context handle
    //  if not returned or cached, clean up
    //

    if ( status == ERROR_SUCCESS )
    {
        if ( phContext )
        {
            *phContext = (HANDLE) psecCtxt;
            psecCtxt = NULL;
        }
        else if ( dwFlag & DNS_UPDATE_CACHE_SECURITY_CONTEXT )
        {
            Dns_EnlistSecurityContext( psecCtxt );
            psecCtxt = NULL;
        }
    }

    if ( psecCtxt )
    {
        Dns_FreeSecurityContext( psecCtxt );
    }

    //  cleanup session info

    Dns_CleanupSecurityPacketInfoEx( &secPack, FALSE );

    //  close connection

    if ( pmsgSend )
    {
        Socket_CloseMessageSockets( pmsgSend );
    }

    //
    //  DCR_CLEANUP:  what's the correct screening here for error codes?
    //      possibly should take all security errors to
    //          status = DNS_ERROR_RCODE_BADKEY;
    //      or some to some status that means unsecure server
    //          and leave BADKEY for actual negotiations that yield bad token
    //

    FREE_HEAP( pmsgRecv );
    FREE_HEAP( pmsgSend );
    FREE_HEAP( pcredKey );

    return( status );
}



DNS_STATUS
Dns_DoSecureUpdate(
    IN      PDNS_MSG_BUF        pMsgSend,
    OUT     PDNS_MSG_BUF        pMsgRecv,
    IN OUT  PHANDLE             phContext,
    IN      DWORD               dwFlag,
    IN      PDNS_NETINFO        pNetworkInfo,
    IN      PDNS_ADDR_ARRAY     pServerList,
    IN      PWSTR               pszNameServer,
    IN      PCHAR               pCreds,         OPTIONAL
    IN      PCHAR               pszContext      OPTIONAL
    )
/*++

Routine Description:

    Main client routine to do secure update.

Arguments:

    pMsgSend - message to send

    ppMsgRecv - and reuse

    pServerList -- IP array DNS servers

    pNetworkInfo -- network info blob for update

    pszNameServer -- name server name

    pCreds -- credentials;  if not given use default process creds

    pszContext -- name for security context;  this is unique name for
        session between this process and this server with these creds

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
#define FORCE_VERSION_OLD   ("Force*Version*Old")

    DNS_STATUS      status = ERROR_SUCCESS;
    DNS_STATUS      rcodeStatus = ERROR_SUCCESS;
    PSEC_CNTXT      psecCtxt = NULL;
    PSEC_CNTXT      passedInCtxt = NULL;
    DWORD           i;
    INT             retry;
    PDNS_ADDR       pservAddr;
    SECPACK         secPack;
#if 0
    DWORD           version;
#endif


    DNS_ASSERT( pMsgSend->MessageHead.Opcode == DNS_OPCODE_UPDATE );
    DNS_ASSERT( pServerList && pszNameServer );    // it better be there!

    DNSDBG( SEND, (
        "Enter Dns_DoSecureUpdate()\n"
        "\tsend msg at  %p\n"
        "\tsec context  %p\n"
        "\tserver name  %S\n"
        "\tserver list  %p\n"
        "\tserver addr  %s\n"
        "\tpCreds       %p\n"
        "\tcontext      %s\n",
        pMsgSend,
        phContext ? *phContext : NULL,
        pszNameServer,
        pServerList,
        DNSADDR_STRING( &pServerList->AddrArray[0] ),
        pCreds,
        pszContext
        ));

    //
    //  version setting
    //
    //  note:  to set different version we'd need some sort of tag
    //      like pszContext (see example)
    //  but a better way to do this would be tail recursion in just
    //  NegotiateTkey -- unless there's a reason to believe the nego
    //  would be successful with old version, but the update still fail
    //

#if 0
    iversion = TKEY_CURRENT_VERSION;

    if ( pszContext && strcmp(pszContext, FORCE_VERSION_OLD) == 0 )
    {
        iversion = TKEY_VERSION_OLD;
        pszContext = NULL;
    }
#endif

    //  start security

    status = Dns_StartSecurity(
                    FALSE       // not process attach
                    );
    if ( status != ERROR_SUCCESS )
    {
        return  status;
    }

    //  init security packet info

    Dns_InitSecurityPacketInfo( &secPack, NULL );

    //  passed in security context?

    if ( phContext )
    {
        passedInCtxt = *phContext;
    }

    //  clear send message socket info

    Socket_ClearMessageSockets( pMsgSend );

    //
    //  loop
    //      - get valid security context
    //      - connect to server
    //      - do update
    //
    //  loop to allow retry with new security context if server
    //  rejects existing one
    //

    retry = 0;

    while ( 1 )
    {
        //  clean up any previous connection
        //  cache security context if negotiated one

        if ( retry )
        {
            if ( pMsgSend->fTcp )
            {
                Socket_CloseMessageSockets( pMsgSend );
            }
            if ( psecCtxt != passedInCtxt )
            {
                Dns_EnlistSecurityContext( psecCtxt );
                psecCtxt = NULL;
            }
        }
        retry++;

        //
        //  passed in security context?
        //

        if ( passedInCtxt )
        {
            psecCtxt = passedInCtxt;
        }

        //
        //  no existing security context
        //      - see if one is cached
        //      - otherwise, negotiate one with server
        //

        if ( !psecCtxt )
        {
            status = Dns_NegotiateTkeyWithServer(
                        & psecCtxt,
                        dwFlag,
                        pszNameServer,
                        pServerList,
                        pCreds,
                        pszContext,
                        0                   // use current version
                        //iversion          // if need versioning
                        );
            if ( status != ERROR_SUCCESS )
            {
                //  note:  if failed we could do a version retry here

                goto Cleanup;
            }
            ASSERT( psecCtxt );
        }

        //
        //  init XID to something fairly random
        //

        pMsgSend->MessageHead.Xid = Dns_GetRandomXid( psecCtxt );

        //
        //  send update only to server we have context for
        //

        pservAddr = &psecCtxt->Key.RemoteAddr;

        //
        //  init for TCP
        //      - setup receive buffer to accomodate TCP
        //      - set timeout and receive
        //

        SET_MESSAGE_FOR_TCP_RECV( pMsgRecv );

        if ( pMsgRecv->Timeout == 0 )
        {
            pMsgRecv->Timeout = SECURE_UPDATE_TCP_TIMEOUT;
        }

        //
        //  write security record with context into packet
        //

        Dns_ResetSecurityPacketInfo( &secPack );

        secPack.pSecContext = psecCtxt;

        status = Dns_SignMessageWithGssTsig(
                    & secPack,
                    & pMsgSend->MessageHead,
                    pMsgSend->pBufferEnd,
                    & pMsgSend->pCurrent
                    );
        if ( status != ERROR_SUCCESS )
        {
            goto Cleanup;
        }

        //  DCR:  wrap simple send and recv to address
        //      includes XID verification and whatever
        //      IP verification we do

        //
        //  need TCP
        //

        if ( DNS_MESSAGE_CURRENT_OFFSET(pMsgSend) > DNS_RFC_MAX_UDP_PACKET_LENGTH )
        {
            //
            //  connect and send
            //      - note, once we have a negoed context, there's no point
            //      in sending update anywhere but to that server
            //    

            pMsgSend->fTcp = TRUE;

            status = Send_OpenTcpConnectionAndSend(
                             pMsgSend,
                             pservAddr,
                             TRUE );
            if ( status != ERROR_SUCCESS )
            {
                if ( pMsgSend->Socket )
                {
                    DNS_ASSERT( !pMsgSend->Socket );
                    Socket_CloseMessageSockets( pMsgSend );
                    continue;
                }
            }
            pMsgRecv->Socket = pMsgSend->Socket;

            //  receive response
            //      - if successful receive, done
            //      - if timeout continue
            //      - other errors indicate some setup or system level
            //          problem

            status = Dns_RecvTcp( pMsgRecv );

            if ( status != ERROR_SUCCESS )
            {
                //  indicate error only with this server by setting RCODE
                pMsgRecv->MessageHead.ResponseCode = DNS_RCODE_SERVER_FAILURE;
                goto Cleanup;
            }
        }

        //
        //  use UDP
        //

        else
        {
            DNS_ADDR_ARRAY  addrArray;

            DnsAddrArray_InitSingleWithAddr(
                & addrArray,
                pservAddr );
    
            pMsgSend->fTcp = FALSE;
            SET_MESSAGE_FOR_UDP_RECV( pMsgRecv );

            status = Send_AndRecvUdpWithParam(
                        pMsgSend,
                        pMsgRecv,
                        0,
                        & addrArray,
                        NULL );
            if ( status != ERROR_SUCCESS &&
                 ! Dns_IsStatusRcode( status ) )
            {
                goto Cleanup;
            }
        }

        //
        //  verify XID match
        //

        if ( pMsgRecv->MessageHead.Xid != pMsgSend->MessageHead.Xid )
        {
            DNS_PRINT(( "ERROR:  Incorrect XID in response. Ignoring.\n" ));
            goto Cleanup;
        }

        //
        //  retrieve RCODE status
        //
        //  note:  there's a DOS attack possible in other RCODEs because we don't
        //      know a server SHOULD be able to handle GSS-TSIG so we basically
        //      trust a failure;  however we are protected against FALSE success
        //      or pre-con errors, which are the ones with semantic content
        //

        rcodeStatus = Dns_MapRcodeToStatus( pMsgRecv->MessageHead.ResponseCode );

        //
        //  extract TSIG
        //

        status = Dns_ExtractGssTsigFromMessage(
                    & secPack,
                    & pMsgRecv->MessageHead,
                    DNS_MESSAGE_END(pMsgRecv)
                    );

        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR:  TSIG parse failed on rcode = %d response!\n",
                pMsgRecv->MessageHead.ResponseCode ));

            //
            //  RCODE refused case -- check for possible retry with new key
            //  retry requires:
            //      - refused
            //      - not passed in context
            //      - have TSIG
            //          - with extended error (BADTIME, BADKEY) OR
            //          - dumb echo indicating server didn't have TKEY
            //

            if ( rcodeStatus == DNS_ERROR_RCODE_REFUSED &&
                 psecCtxt->UseCount > 0     &&
                 retry == 1                 &&
                 !phContext                 &&
                 secPack.pTsigRR            &&
                 ( secPack.pTsigRR->Data.TSIG.wError != 0 ||
                   status == DNS_STATUS_PACKET_UNSECURE ) )
            {
                DNSDBG( SECURITY, (
                    "TSIG signed query (%p) rejected with %d and\n"
                    "\textended RCODE = %d\n"
                    "\tretrying rebuilding new TKEY\n",
                    pMsgSend,
                    pMsgRecv->MessageHead.ResponseCode,
                    secPack.pTsigRR->Data.TSIG.wError
                    ));

                pMsgSend->MessageHead.AdditionalCount = 0;
                IF_DNSDBG( SECURITY )
                {
                    DnsDbg_Message(
                        "Update message after reset for retry:",
                        pMsgSend );
                }
                Dns_FreeSecurityContext( psecCtxt );
                psecCtxt = NULL;
                continue;
            }

            //
            //  on RCODE failure -- use RCODE error
            //      - set back to success for case statement below
            //

            if ( rcodeStatus )
            {
                status = NO_ERROR;
            }
            break;
        }

        //
        //  verify server signature
        //

        status = Dns_VerifySignatureOnPacket( &secPack );
        if ( status != ERROR_SUCCESS )
        {
            //
            //  bad signature case
            //  -- most likely out of sequence with the server because we've sent
            //     signed to some non-secure zones or someone has attacked our
            //     connection
            //
            //  retry requires:
            //      - not passed in context
            //      - using cached context, not fresh
            //      - no previous retry
            //      - have TSIG
            //
            //  note that dumb echo is caught above
            //

            if ( psecCtxt->UseCount > 0     &&
                 retry == 1                 &&
                 !phContext                 &&
                 secPack.pTsigRR )
            {
                DNSDBG( SECURITY, (
                    "TSIG on query (%p) failed verify for cached context\n"
                    "\tRCODE            = %d\n"
                    "\textended RCODE   = %d\n"
                    "\tretrying rebuilding new TKEY\n",
                    pMsgSend,
                    pMsgRecv->MessageHead.ResponseCode,
                    secPack.pTsigRR->Data.TSIG.wError
                    ));

                pMsgSend->MessageHead.AdditionalCount = 0;
                IF_DNSDBG( SECURITY )
                {
                    DnsDbg_Message(
                        "Update message after reset for retry:",
                        pMsgSend );
                }
                Dns_FreeSecurityContext( psecCtxt );
                psecCtxt = NULL;
                continue;
            }

            //  DCR_LOG:  log event -- been hacked or misbehaving server
            //      or bad bytes in transit

            DNS_PRINT((
                "ERROR:  signature verification failed on update\n"
                "\tto server %s\n",
                DNSADDR_STRING( pservAddr ) ));
        }
        break;
    }

    //
    //  check response code
    //      - consider some response codes
    //

    switch( status )
    {
    case ERROR_SUCCESS:
        status = rcodeStatus;
        break;

    case ERROR_TIMEOUT:

        DNS_PRINT((
            "ERROR:  connected to server at %s\n"
            "\tbut no response to packet at %p\n",
            MSG_REMOTE_IPADDR_STRING( pMsgSend ),
            pMsgSend
            ));
        break;

    default:

        DNS_PRINT((
            "ERROR:  connected to server at %s to send packet %p\n"
            "\tbut error %d encountered on receive or sig verify.\n",
            MSG_REMOTE_IPADDR_STRING( pMsgSend ),
            pMsgSend,
            status
            ));
        break;
    }

Cleanup:

    //
    //  save security context?
    //

    if ( psecCtxt )
    {
        if ( dwFlag & DNS_UPDATE_CACHE_SECURITY_CONTEXT )
        {
            Dns_EnlistSecurityContext( psecCtxt );
            if ( phContext )
            {
                *phContext = NULL;
            }
        }
        else if ( phContext )
        {
            *phContext = (HANDLE) psecCtxt;
        }
        else
        {
            Dns_FreeSecurityContext( psecCtxt );
        }
    }

    if ( pMsgSend->fTcp )
    {
        Socket_CloseConnection( pMsgSend->Socket );
    }

    //
    //  free security packet session sub-allocations
    //      - structure itself is on the stack

    Dns_CleanupSecurityPacketInfoEx( &secPack, FALSE );

#if 0
    //
    //  versioning failure retry?
    //  if failed, reenter function forcing old version
    //

    if ( status != ERROR_SUCCESS &&
        status != DNS_ERROR_RCODE_NOT_IMPLEMENTED &&
        iversion != TKEY_VERSION_OLD )
    {
        DNS_PRINT((
            "SecureUpdate failed with status == %d\n"
            "\tRetrying forcing version %d signing.\n",
            status,
            TKEY_VERSION_OLD ));

        status = Dns_DoSecureUpdate(
                    pMsgSend,
                    pMsgRecv,
                    phContext,
                    dwFlag,
                    pNetworkInfo,
                    pServerList,
                    pszNameServer,
                    pCreds,
                    FORCE_VERSION_OLD
                    );
    }
#endif

    return( status );
}



//
//  Server security session routines
//

DNS_STATUS
Dns_FindSecurityContextFromAndVerifySignature(
    OUT     PHANDLE         phContext,
    IN      PDNS_ADDR       pRemoteAddr,
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgEnd
    )
/*++

Routine Description:

    Find security context associated with TSIG and verify
    the signature.

Arguments:

    phContext -- addr to receive context handle

    pRemoteAddr -- address of remote machine

    pMsgHead -- ptr to message head

    pMsgEnd -- ptr to message end (byte past end)
    
Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status;
    DNS_SECCTXT_KEY key;
    PSEC_CNTXT      psecCtxt = NULL;
    PSECPACK        psecPack = NULL;

    DNSDBG( SECURITY, (
        "Dns_FindSecurityContextFromAndVerifySignature()\n"
        ));

    //  security must already be running to have negotiated a TKEY

    if ( !g_fSecurityPackageInitialized )
    {
        status = Dns_StartServerSecurity();
        if ( status != ERROR_SUCCESS )
        {
            return( DNS_RCODE_SERVER_FAILURE );
        }
    }

    //
    //  read TSIG from packet
    //

    psecPack = Dns_CreateSecurityPacketInfo();
    if ( !psecPack )
    {
        return( DNS_RCODE_SERVER_FAILURE );
    }
    status = Dns_ExtractGssTsigFromMessage(
                psecPack,
                pMsgHead,
                pMsgEnd
                );
    if ( status != ERROR_SUCCESS )
    {
        goto Cleanup;
    }

    //
    //  find existing security context
    //      - TSIG name node
    //      - client IP
    //  together specify context
    //

    RtlZeroMemory(
        &key,
        sizeof(key) );

    key.pszTkeyName = psecPack->pszContextName;
    DnsAddr_Copy( &key.RemoteAddr, pRemoteAddr );

    psecCtxt = Dns_DequeueSecurityContextByKey( key, TRUE );
    if ( !psecCtxt )
    {
        DNSDBG( SECURITY, (
            "Desired security context %s %s is NOT cached.\n"
            "\treturning BADKEY\n",
            key.pszTkeyName,
            DNSADDR_STRING( &key.RemoteAddr ) ));
        status = DNS_ERROR_RCODE_BADKEY;
        SecTsigBadKey++;
        goto Cleanup;
    }

    //  attach context to session info

    psecPack->pSecContext = psecCtxt;

    //
    //  verify signature
    //

    status = Dns_VerifySignatureOnPacket( psecPack );
    if ( status != ERROR_SUCCESS )
    {
        DNSDBG( SECURITY, (
            "Verify signature failed %08x %d.\n"
            "\treturning BADSIG\n",
            status, status ));
        status = DNS_ERROR_RCODE_BADSIG;
        goto Cleanup;
    }

Cleanup:

    //  return security info blob
    //  if failed delete session info,
    //      - return security context to cache if failure is just TSIG
    //      being invalid

    if ( status == ERROR_SUCCESS )
    {
        *phContext = psecPack;
    }
    else
    {
        Dns_FreeSecurityPacketInfo( psecPack );
        if ( psecCtxt )
        {
            DNSDBG( SECURITY, (
                "Re-enlisting security context at %p after TSIG verify failure.\n",
                psecCtxt ));
            Dns_EnlistSecurityContext( psecCtxt );
        }
    }
    return( status );
}


DNS_STATUS
Dns_FindSecurityContextFromAndVerifySignature_Ip4(
    OUT     PHANDLE         phContext,
    IN      IP4_ADDRESS     IpRemote,
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgEnd
    )
/*++

Routine Description:

    Find security context associated with TSIG and verify
    the signature.

    IP4 shim on real routine above.

--*/
{
    DNS_ADDR    addr;

    DnsAddr_BuildFromIp4(
        &addr,
        IpRemote,
        0 );

    return  Dns_FindSecurityContextFromAndVerifySignature(
                phContext,
                & addr,
                pMsgHead,
                pMsgEnd
                );
}



DNS_STATUS
Dns_ServerNegotiateTkey(
    IN      PDNS_ADDR       pRemoteAddr,
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgEnd,
    IN      PCHAR           pMsgBufEnd,
    IN      BOOL            fBreakOnAscFailure,
    OUT     PCHAR *         ppCurrent
    )
/*++

Routine Description:

    Negotiate TKEY with client.

Arguments:

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

    DCR_CLEANUP:  note this is currently returning RCODEs not status.

--*/
{
    DNS_STATUS      status;
    SECPACK         secPack;
    DNS_SECCTXT_KEY key;
    PSEC_CNTXT      psecCtxt = NULL;
    PSEC_CNTXT      ppreviousContext = NULL;
    WORD            extRcode = 0;


    DNSDBG( SECURITY, (
        "Dns_ServerNegotiateTkey()\n"
        ));

    //  security must already be running to have negotiated a TKEY

    if ( !g_fSecurityPackageInitialized )
    {
        return( DNS_RCODE_REFUSED );
    }

    //
    //  read TKEY from packet
    //

    Dns_InitSecurityPacketInfo( &secPack, NULL );

    status = Dns_ExtractGssTkeyFromMessage(
                & secPack,
                pMsgHead,
                pMsgEnd,
                TRUE );         //  fIsServer

    if ( status != ERROR_SUCCESS )
    {
        DNSDBG( SECURITY, (
            "TKEY Extract failed for msg at %p\n"
            "\tstatus = %d (%08x)\n",
            pMsgHead, status, status ));
        goto Cleanup;
    }

    //
    //  find existing security context from this client
    //      - client IP
    //      - TKEY record
    //  together specify context
    //
    //  if previously negotiated context, doesn't match key length from
    //  new TKEY, then renegotiate
    //

    RtlZeroMemory(
        &key,
        sizeof(key) );

    DnsAddr_Copy( &key.RemoteAddr, pRemoteAddr );
    key.pszTkeyName = secPack.pszContextName;

    psecCtxt = Dns_DequeueSecurityContextByKey( key, FALSE );
    if ( psecCtxt )
    {
        ppreviousContext = psecCtxt;

        DNSDBG( SECURITY, (
            "Found security context matching TKEY %s %s.\n",
            key.pszTkeyName,
            DNSADDR_STRING( &key.RemoteAddr ) ));

        //
        //  previously negotiated key?
        //
        //  DCR_QUESTION:  no client comeback after server side nego complete?
        //      treating client coming back on server side negotiated context
        //      as NEW context -- not sure this is correct, client may complete
        //      and become negotiated and want to echo
        //
        //  to fix we'd need to hold this issue open and see if got "echo"
        //  in accept
        //

        if ( psecCtxt->fNegoComplete )
        {
            DNSDBG( SECURITY, (
               "WARNING:  Client nego request on existing negotiated context:\n"
               "\tTKEY  %s\n"
               "\tIP    %s\n",
               key.pszTkeyName,
               DNSADDR_STRING( &key.RemoteAddr ) ));

            //
            //  for Win2K (through whistler betas) allow clobbering nego
            //
            //  DCR:  pull Whistler Beta support for Win2001 server ship?
            //      against would be JDP deployed whister client\servers
            //      with this?  should be zero by server ship
            //

            if ( psecCtxt->Version == TKEY_VERSION_W2K )
            {
                DNSDBG( SECURITY, (
                   "WIN2K context -- overwriting negotiated security context\n"
                   "\twith new negotiation.\n" ));
                psecCtxt = NULL;
            }

            //  post-Win2K clients should ALWAYS send with a new name
            //  nego attempts on negotiated context are attacks
            //
            //  DCR:  again client echo issue here

            else
            {
                DNSDBG( SECURITY, (
                   "ERROR:  post-Win2K client nego request on existing key.\n"
                   "\terroring with BADKEY!\n" ));

                //
                //  JJW: This assert fires in stress quite a lot. We need to 
                //  figure out why but now is not the time.
                //
                //  DNS_ASSERT( FALSE );

                psecCtxt = NULL;
                status = DNS_ERROR_RCODE_BADKEY;
                extRcode = DNS_RCODE_BADKEY;
                goto Cleanup;
            }
        }
    }

    //
    //  if context not found, create one
    //      - tag it with version of TKEY found
    //

    if ( !psecCtxt )
    {
        psecCtxt = Dns_FindOrCreateSecurityContext( key );
        if ( !psecCtxt )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Cleanup;
        }
        psecCtxt->Version = secPack.TkeyVersion;
    }

    //
    //  have context -- attach to security session
    //

    secPack.pSecContext = psecCtxt;

    //
    //  accept this security context
    //  if continue needed, then write response TKEY using
    //
    //  DCR_ENHANCE:  in COMPLETE_AND_CONTINUE case should be adding TSIG signing
    //      need to break out this response from ServerAcceptSecurityContext
    //

    status = Dns_ServerAcceptSecurityContext(
                    &secPack,
                    fBreakOnAscFailure );

    if ( status != ERROR_SUCCESS )
    {
        if ( status != DNS_STATUS_CONTINUE_NEEDED )
        {
            DNSDBG( ANY, (
                "FAILURE: ServerAcceptSecurityContext failed status=%d\n",
                status ));
            status = DNS_ERROR_RCODE_BADKEY;
            goto Cleanup;
        }
        status = Dns_WriteGssTkeyToMessage(
                    &secPack,
                    pMsgHead,
                    pMsgBufEnd,
                    ppCurrent,
                    TRUE );             //  fIsServer
        if ( status != ERROR_SUCCESS )
        {
            status = DNS_RCODE_SERVER_FAILURE;
            goto Cleanup;
        }

        //
        //  sign packet if we are now completed
        //

        if ( psecCtxt->fNegoComplete )
        {
            goto Sign;
        }
        goto Cleanup;
    }

    //
    //  verify signature, if present
    //

    status = Dns_ExtractGssTsigFromMessage(
                &secPack,
                pMsgHead,
                pMsgEnd
                );
    if ( status == ERROR_SUCCESS )
    {
        status = Dns_VerifySignatureOnPacket( &secPack );
        if ( status != ERROR_SUCCESS )
        {
            DNSDBG( SECURITY, (
                "Verify signature failed on TKEY nego packet %p.\n"
                "\tstatus = %d (%08x)\n"
                "\treturning BADSIG\n",
                pMsgHead,
                status, status ));
            status = DNS_ERROR_RCODE_BADSIG;
            extRcode = DNS_RCODE_BADSIG;
        }
    }
    else if ( status == DNS_STATUS_PACKET_UNSECURE )
    {
        status = ERROR_SUCCESS;
    }
    else
    {
        extRcode = DNS_RCODE_BADSIG;
    }

    //
    //  sign server's response
    //

Sign:

    DNSDBG( SECURITY, (
        "Signing TKEY nego packet at %p after nego complete\n"
        "\tstatus = %d (%08x)\n"
        "\textRcode = %d\n",
        pMsgHead,
        status, status,
        extRcode ));

    pMsgHead->IsResponse = TRUE;

    status = Dns_SignMessageWithGssTsig(
                &secPack,
                pMsgHead,
                pMsgBufEnd,
                ppCurrent );

    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT((
            "ERROR: failed to sign successful TKEY nego packet at %p\n"
            "\tstatus = %d (%08x)\n",
            pMsgHead,
            status, status ));

        status = ERROR_SUCCESS;
    }

Cleanup:

    //
    //  if failed, respond in in TKEY extended error field
    //
    //  if extended RCODE not set above
    //      - default to BADKEY
    //      - unless status is extended RCODE
    //

    if ( status != ERROR_SUCCESS )
    {
        if ( !secPack.pTkeyRR )
        {
            status = DNS_RCODE_FORMERR;
        }
        else
        {
            if ( secPack.ExtendedRcode == 0 )
            {
                if ( extRcode == 0 )
                {
                    extRcode = DNS_RCODE_BADKEY;
                    if ( status > DNS_ERROR_RCODE_BADSIG &&
                        status < DNS_ERROR_RCODE_LAST )
                    {
                        extRcode = (WORD)(status - DNS_ERROR_MASK);
                    }
                }

                //  write extended RCODE directly into TKEY extRCODE field
                //      - it is a DWORD (skipping KeyLength) before Key itself

                INLINE_WRITE_FLIPPED_WORD(
                    ( secPack.pTkeyRR->Data.TKEY.pKey - sizeof(DWORD) ),
                    extRcode );
            }
            status = DNS_RCODE_REFUSED;
        }
    }

    //
    //  if successful
    //      - whack any previous context with new context
    //  if failed
    //      - restore any previous context, if any
    //      - dump any new failed context
    //
    //  this lets us clients retry in any state they like, yet preserves
    //  any existing negotiation, if this attempt was security attack or bad data
    //  but if client successful in this negotiation, then any old context is
    //      dumped
    //

    if ( status == ERROR_SUCCESS )
    {
        ASSERT( secPack.pSecContext == psecCtxt );

        if ( ppreviousContext != psecCtxt )
        {
            Dns_FreeSecurityContext( ppreviousContext );
        }
        DNSDBG( SECURITY, (
            "Re-enlisting security context at %p\n",
            psecCtxt ));
        Dns_EnlistSecurityContext( psecCtxt );
    }
    else
    {
        DNSDBG( SECURITY, (
            "Failed nego context at %p\n"
            "\tstatus           = %d\n"
            "\text RCODE        = %d\n"
            "\tclient IP        = %s\n"
            "\tTKEY name        = %s\n"
            "\tnego complete    = %d\n",
            psecCtxt,
            status,
            extRcode,
            psecCtxt ? DNSADDR_STRING( &psecCtxt->Key.RemoteAddr ) : "NULL",
            psecCtxt ? psecCtxt->Key.pszTkeyName : "NULL",
            psecCtxt ? psecCtxt->fNegoComplete : 0 ));

        //  free any new context that failed in nego -- if any

        if ( psecCtxt )
        {
            Dns_FreeSecurityContext( psecCtxt );
        }

        //
        //  reenlist any previously negotiated context
        //
        //  the reenlistment protects against denial of service attack
        //  that spoofs client and attempts to trash their context,
        //  either during nego or after completed
        //
        //  however, must dump Win2K contexts as clients can reuse
        //  the TKEY name and may NOT have saved the context;  this
        //  produces BADKEY from AcceptSecurityContext() and must
        //  cause server to dump to reopen TKEY name to client
        //

        //  DCR_QUESTION:  is it possible to "reuse" partially nego'd context
        //      that fails further negotiation
        //      in other words can we protect against DOS attack in the middle
        //      of nego that tries to message with nego, by requeuing the context
        //      so real nego can complete?
        

        if ( ppreviousContext &&
             ppreviousContext != psecCtxt )
        {
            DNS_ASSERT( ppreviousContext->fNegoComplete );

            DNSDBG( ANY, (
                "WARNING:  reenlisting security context %p after failed nego\n"
                "\tthis indicates client problem OR security attack!\n"
                "\tclient IP        = %s\n"
                "\tTKEY name        = %s\n"
                "\tnego complete    = %d\n",
                ppreviousContext,
                DNSADDR_STRING( &ppreviousContext->Key.RemoteAddr ),
                ppreviousContext->Key.pszTkeyName,
                ppreviousContext->fNegoComplete ));
    
            Dns_EnlistSecurityContext( ppreviousContext );
        }
    }

    //  cleanup security packet info
    //      - parsed records, buffers, etc
    //      - stack struct, no free

    Dns_CleanupSecurityPacketInfoEx( &secPack, FALSE );

    return( status );
}



DNS_STATUS
Dns_ServerNegotiateTkey_Ip4(
    IN      IP4_ADDRESS     IpRemote,
    IN      PDNS_HEADER     pMsgHead,
    IN      PCHAR           pMsgEnd,
    IN      PCHAR           pMsgBufEnd,
    IN      BOOL            fBreakOnAscFailure,
    OUT     PCHAR *         ppCurrent
    )
/*++

Routine Description:

    Negotiate TKEY with client.

    IP4 shim on real routine.

--*/
{
    DNS_ADDR    addr;

    DnsAddr_BuildFromIp4(
        &addr,
        IpRemote,
        0 );

    return  Dns_ServerNegotiateTkey(
                & addr,
                pMsgHead,
                pMsgEnd,
                pMsgBufEnd,
                fBreakOnAscFailure,
                ppCurrent
                );
}



VOID
Dns_CleanupSessionAndEnlistContext(
    IN OUT  HANDLE          hSession
    )
/*++

Routine Description:

    Cleanup security session and return context to cache.

Arguments:

    hSession -- session handle (security packet info)

Return Value:

    None

--*/
{
    PSECPACK        psecPack = (PSECPACK) hSession;

    DNSDBG( SECURITY, (
        "Dns_CleanupSessionAndEnlistContext( %p )\n", psecPack ));

    //  reenlist security context

    Dns_EnlistSecurityContext( psecPack->pSecContext );

    //  cleanup security packet info
    //      - parsed records, buffers, etc
    //      - since handle based, this is free structure

    Dns_CleanupSecurityPacketInfoEx( psecPack, TRUE );
}


//
//  API calling context
//

HANDLE
Dns_CreateAPIContext(
    IN      DWORD           Flags,
    IN      PVOID           Credentials     OPTIONAL,
    IN      BOOL            fUnicode
    )
/*++

 Routine Description:

    Initializes a DNS API context possibly associated with a
    particular set of credentials.

    Flags - Type of credentials pointed to by Credentials

    Credentials - a pointer to a SEC_WINNT_AUTH_IDENTITY structure
                  that contains the user, domain, and password
                  that is to be associated with update security contexts

    fUnicode - ANSI is FALSE, UNICODE is TRUE to indicate version of
               SEC_WINNT_AUTH_IDENTITY structure in Credentials

 Return Value:

    Returns context handle successful; otherwise NULL is returned.


    Structure defined at top of file looks like:

        typedef struct _DnsAPIContext
        {
            DWORD  Flags;
            PVOID  Credentials;
            struct _DnsSecurityContext * pSecurityContext;
        }
        DNS_API_CONTEXT, *PDNS_API_CONTEXT;

 --*/
{
    PDNS_API_CONTEXT pcontext;

    pcontext = (PDNS_API_CONTEXT) ALLOCATE_HEAP_ZERO( sizeof(DNS_API_CONTEXT) );
    if ( !pcontext )
    {
        return( NULL );
    }

    pcontext->Flags = Flags;
    if ( fUnicode )
    {
        pcontext->Credentials = Dns_AllocateAndInitializeCredentialsW(
                                    (PSEC_WINNT_AUTH_IDENTITY_W)Credentials
                                    );
    }
    else
    {
        pcontext->Credentials = Dns_AllocateAndInitializeCredentialsA(
                                    (PSEC_WINNT_AUTH_IDENTITY_A)Credentials
                                    );
    }
    pcontext->pSecurityContext = NULL;

    return( (HANDLE)pcontext );
}


VOID
Dns_FreeAPIContext(
    IN OUT  HANDLE          hContextHandle
    )
/*++

Routine Description:

    Cleans up DNS API context data.

Arguments:

    hContext -- handle to context to clean up

Return Value:

    TRUE if successful
    FALSE otherwise


    Structure defined at top of file looks like:

        typedef struct _DnsAPIContext
        {
            DWORD  Flags;
            PVOID  Credentials;
            struct _DnsSecurityContext * pSecurityContext;
        }
        DNS_API_CONTEXT, *PDNS_API_CONTEXT;

--*/
{
    PDNS_API_CONTEXT pcontext = (PDNS_API_CONTEXT)hContextHandle;

    if ( !pcontext )
    {
        return;
    }

    if ( pcontext->Credentials )
    {
        Dns_FreeAuthIdentityCredentials( pcontext->Credentials );
    }

    if ( pcontext->pSecurityContext )
    {
        Dns_FreeSecurityContext( pcontext->pSecurityContext );
        pcontext->pSecurityContext = NULL;
    }

    FREE_HEAP( pcontext );
}

PVOID
Dns_GetApiContextCredentials(
    IN      HANDLE          hContextHandle
    )
/*++

Routine Description:

    returns pointer to credentials in context handle

Arguments:

    hContext -- handle to context to clean up

Return Value:

    TRUE if successful
    FALSE otherwise


    Structure defined at top of file looks like:

        typedef struct _DnsAPIContext
        {
            DWORD  Flags;
            PVOID  Credentials;
            struct _DnsSecurityContext * pSecurityContext;
        }
        DNS_API_CONTEXT, *PDNS_API_CONTEXT;

--*/
{
    PDNS_API_CONTEXT pcontext = (PDNS_API_CONTEXT)hContextHandle;

    return pcontext ? pcontext->Credentials : NULL;
}




DWORD
Dns_GetCurrentRid(
    VOID
    )
/*++

Routine Description:

    Get RID.  This is used as unique ID for tagging security context.

Arguments:

    None

Return Value:

    Current RID if successful.
    (-1) on error.

--*/
{
    BOOL        bstatus;
    DNS_STATUS  status = ERROR_SUCCESS;
    HANDLE      hToken = NULL;
    PTOKEN_USER puserToken = NULL;
    DWORD       size;
    UCHAR       SubAuthCount;
    DWORD       rid = (DWORD)-1;

    //
    //  get thread/process token
    //

    bstatus = OpenThreadToken(
                    GetCurrentThread(),   // thread pseudo handle
                    TOKEN_QUERY,          // query info
                    TRUE,                 // open as self
                    & hToken );           // returned handle
    if ( !bstatus )
    {
        DNSDBG( SECURITY, (
            "Note <%lu>: failed to open thread token\n",
            GetLastError()));

        //
        //  attempt to open process token
        //      - if not impersonating, this is fine
        //

        bstatus = OpenProcessToken(
                         GetCurrentProcess(),
                         TOKEN_QUERY,
                         & hToken );
        if ( !bstatus )
        {
            status = GetLastError();
            DNSDBG( SECURITY, (
                "Error <%lu>: failed to open process token\n",
                status ));
            ASSERT( FALSE );
            goto Cleanup;
        }
    }

    //
    //  get length required for TokenUser
    //      - specify buffer length of 0
    //

    bstatus = GetTokenInformation(
                    hToken,
                    TokenUser,
                    NULL,
                    0,
                    & size );

    status = GetLastError();
    if ( bstatus  ||  status != ERROR_INSUFFICIENT_BUFFER )
    {
        DNSDBG( SECURITY, (
                "Error <%lu>: unexpected error for token info\n",
                status ));
        ASSERT( FALSE );
        goto Cleanup;
    }

    //
    //  allocate user token
    //

    puserToken = (PTOKEN_USER) ALLOCATE_HEAP( size );
    if ( !puserToken )
    {
        status = GetLastError();
        DNSDBG( SECURITY, (
            "Error <%lu>: failed to allocate memory\n",
            status ));
        ASSERT( FALSE );
        goto Cleanup;
    }

    //
    //  get SID of process token.
    //

    bstatus = GetTokenInformation(
                    hToken,
                    TokenUser,
                    puserToken,
                    size,
                    & size );
    if ( !bstatus )
    {
        status = GetLastError();
        DNSDBG( SECURITY, (
            "Error <%lu>: failed to get user info\n",
            status));
        ASSERT( FALSE );
        goto Cleanup;
    }

    //
    //  calculate the size of the domain sid
    //

    SubAuthCount = *GetSidSubAuthorityCount( puserToken->User.Sid );

    status = GetLastError();

    if ( status != ERROR_SUCCESS  ||  SubAuthCount < 1 )
    {
        DNSDBG( SECURITY, (
            "Error <%lu>: Invalid sid.\n",
            status));
        ASSERT( FALSE );
        goto Cleanup;
    }
    size = GetLengthSid( puserToken->User.Sid );

    //
    //  get rid from the account sid
    //

    rid = *GetSidSubAuthority(
                   puserToken->User.Sid,
                   SubAuthCount-1 );

    status = GetLastError();
    if ( status != ERROR_SUCCESS )
    {
        DNSDBG( SECURITY, (
            "Error <%lu>: Invalid sid.\n",
             status ));
        ASSERT( FALSE );
        goto Cleanup;
    }

Cleanup:

    if ( hToken )
    {
        CloseHandle( hToken );
    }
    if ( puserToken )
    {
        FREE_HEAP( puserToken );
    }

    return rid;
}



DWORD
Dns_GetKeyVersion(
    IN      PSTR            pszTkeyName
    )
/*++

Routine Description:

    Get TKEY\TSIG version corresponding to a context.

Arguments:

    pszTkeyName -- context (TSIG\TKEY owner name)

Return Value:

    Version if found.
    Zero if unable to read version.

--*/
{
    LONGLONG    clientId = 0;
    DWORD       version = 0;
    INT         iscan;

    if ( !pszTkeyName )
    {
        DNSDBG( ANY, ( "ERROR:  no context to Dns_GetKeyVersion()!\n" ));
        ASSERT( FALSE );
        return( 0 );
    }

    //
    //  Versioned contexts have format <64bits>-ms-<version#>
    //

    iscan = sscanf(
                pszTkeyName,
                "%I64d-ms-%d",
                & clientId,
                & version );
    if ( iscan != 2 )
    {
        //
        //  Clients before Whistler RC2 use "MS" instead of "ms".
        //

        iscan = sscanf(
                    pszTkeyName,
                    "%I64d-MS-%d",
                    & clientId,
                    & version );
    }

    if ( iscan == 2 )
    {
        DNSDBG( SECURITY, (
            "Dns_GetKeyVersion() extracted version %d\n",
            version ));
    }
    else
    {
        DNSDBG( SECURITY, (
            "Dns_GetKeyVersion() unable to extract version from %s\n"
            "\treturning 0 as version\n",
            pszTkeyName ));
        version = 0;
    }

    return version;
}



DNS_STATUS
BuildCredsForPackage(
    OUT     PSEC_WINNT_AUTH_IDENTITY_EXW    pAuthOut,
    IN      PWSTR                           pPackageName,
    IN      PSEC_WINNT_AUTH_IDENTITY_W      pAuthIn
    )
/*++

Description:

    Builds auth identity info blob with specific package.

    The purpose of this is to let us ONLY negotiate kerberos and
    avoid wasting bandwidth negotiating NTLM.

Parameters:

    pAuthOut -- auth identity info

    pPackageName -- name of package

    pAuthIn -- existing package

Return:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNSDBG( SECURITY, (
        "BuildCredsForPackage( %p, %S )\n",
        pAuthOut,
        pPackageName ));

    //
    //  currently don't limit passed in creds to kerberos
    //

    if ( pAuthIn )
    {
        return  ERROR_INVALID_PARAMETER;
    }

    //
    //  auth-id with default creds
    //      - user, domain, password all zero
    //      - set length and version
    //      - set package
    //      - set flag to indicate unicode
    //

    RtlZeroMemory(
        pAuthOut,
        sizeof(*pAuthOut) );

    pAuthOut->Version           = SEC_WINNT_AUTH_IDENTITY_VERSION;
    pAuthOut->Length            = sizeof(*pAuthOut);
    pAuthOut->Flags             = SEC_WINNT_AUTH_IDENTITY_UNICODE;
    pAuthOut->PackageList       = pPackageName;
    pAuthOut->PackageListLength = wcslen( pPackageName );

    return  ERROR_SUCCESS;
}



DNS_STATUS
Dns_AcquireCredHandle(
    OUT     PCredHandle     pCredHandle,
    IN      BOOL            fDnsServer,
    IN      PCHAR           pCreds
    )
/*++

Routine Description:

    Acquire credentials handle.

    Cover to handle issues like kerberos restriction.

Arguments:

    fDnsServer -- TRUE if DNS server process;  FALSE otherwise

    pCreds -- credentials

Return Value:

    success: ERROR_SUCCESS

--*/
{
    SEC_WINNT_AUTH_IDENTITY_EXW clientCreds;
    SECURITY_STATUS             status = ERROR_SUCCESS;
    PVOID                       pauthData = pCreds;


    DNSDBG( SECURITY, (
       "Dns_AcquireCredHandle( %p, server=%d, pcred=%p )\n",
       pCredHandle,
       fDnsServer,
       pCreds ));

    //
    //  kerberos for client
    //
    //  if passed in creds
    //      - just append package (if possible)
    //
    //  DCR:  currently not limiting passed in creds to kerberos
    //
    //  no creds
    //      - build creds with kerb package and all else NULL
    //
    //  evolution note:
    //      Win2K released with default as NULL creds
    //      XP and Win2K SP3 have specify empty creds (gets process default)
    //          except for package explicitly "kerberos"
    //

    if ( !fDnsServer && g_NegoKerberosOnly )
    {
        if ( !pCreds )
        {
            status = BuildCredsForPackage(
                        & clientCreds,
                        L"kerberos",
                        NULL );

            DNS_ASSERT( status == NO_ERROR );
            if ( status == NO_ERROR )
            {
                pauthData = &clientCreds;
            }
        }
    }

    //
    //  acquire cred handle
    //

    status = g_pSecurityFunctionTable->AcquireCredentialsHandleW(
                    NULL,                   // principal
                    PACKAGE_NAME,
                    fDnsServer ?
                        SECPKG_CRED_INBOUND :
                        SECPKG_CRED_OUTBOUND,
                    NULL,                   // LOGON id
                    pauthData,              // auth data
                    NULL,                   // get key fn
                    NULL,                   // get key arg
                    pCredHandle,            // out credentials
                    NULL                    // valid forever
                    );

    if ( !SEC_SUCCESS(status) )
    {
        DNSDBG( ANY, (
            "ERROR:  AcquireCredentialHandle failed!\n"
            "\tstatus   = %08x %d\n"
            "\tpauthId  = %p\n",
            status, status,
            pauthData ));
    }

    DNSDBG( SECURITY, (
       "Leave  Dns_AcquireCredHandle() => %08x\n",
       status ));

    return (DNS_STATUS) status;
}



DNS_STATUS
Dns_RefreshSSpiCredentialsHandle(
    IN      BOOL            fDnsServer,
    IN      PCHAR           pCreds
    )
/*++

Routine Description:

    Refreshes the global credentials handle if it is expired.
    Calls into SSPI to acquire a new handle.

Arguments:

    fDnsServer -- TRUE if DNS server process;  FALSE otherwise

    pCreds -- credentials

Return Value:

    ERROR_SUCCESS

--*/
{
    SECURITY_STATUS status = ERROR_SUCCESS;

    DNSDBG( SECURITY, (
       "Dns_RefreshSSpiCredentialsHandle( %d, pcreds=%p )\n",
       fDnsServer,
       pCreds ));

    EnterCriticalSection( &SecurityContextListCS );

    //
    //  dump previous credentials (if any)
    //
    //  DCR:  need check -- if handle for same credentials and still valid
    //      no need to fix up
    //
    //  Note:  currently this test is always FALSE
    //
    //  DCR_FIX:  default creds not MT safe;
    //      need some lock on default creds so this function will
    //      not overwrite existing creds while in use;  note that
    //      this would only happen when app chooses to call with
    //      its own creds;  and security system may protect against
    //      actual fault -- may just get error in call using creds
    //

    if ( !SSPI_INVALID_HANDLE( &g_hSspiCredentials ) )
    {
        status = g_pSecurityFunctionTable->FreeCredentialsHandle(
                                               &g_hSspiCredentials );
        if ( !SEC_SUCCESS(status) )
        {
            DNSDBG( ANY, (
                "ERROR:  FreeCredentialsHandle failed %08x\n",
                status ));
        }
        SecInvalidateHandle( &g_hSspiCredentials );
    }

    ASSERT( SSPI_INVALID_HANDLE( &g_hSspiCredentials ) );

    //
    //  Acquire credentials
    //

    status = Dns_AcquireCredHandle(
                & g_hSspiCredentials,
                fDnsServer,
                pCreds );

    if ( !SEC_SUCCESS(status) )
    {
        DNS_PRINT((
            "ERROR:  Dns_AcquireCredHandle failed\n" ));
        SecInvalidateHandle( &g_hSspiCredentials );
    }

    LeaveCriticalSection( &SecurityContextListCS );

    DNSDBG( SECURITY, (
       "Leave RefreshSSpiCredentialsHandle() => %08x\n",
       status ));

    return (DNS_STATUS) status;
}



PCredHandle
getDefaultCredentialsHandle(
    IN      BOOL            fDnsServer
    )
/*++

Routine Description:

    Get default cred handle.

    If no default handle has yet been created, AcquireCredentialsHandle()
    is called with default process credentials to create one.

Arguments:

    fDnsServer -- TRUE if DNS server process;  FALSE otherwise

Return Value:

    Ptr to cred handle if successful.
    NULL on error;  GetLastError() then contains error from
    AccquireCredentialsHandle().

--*/
{
    DNS_STATUS  status = NO_ERROR;
    PCredHandle pcredHandle;

    DNSDBG( SECURITY, (
       "getDefaultCredHandle( %d )\n",
       fDnsServer ));

    EnterCriticalSection( &SecurityContextListCS );

    if ( SSPI_INVALID_HANDLE( &g_hSspiCredentials ) )
    {
        status = Dns_RefreshSSpiCredentialsHandle(
                    fDnsServer,
                    NULL        // no creds
                    );
    }

    pcredHandle = &g_hSspiCredentials;

    LeaveCriticalSection( &SecurityContextListCS );

    if ( !pcredHandle )
    {
        ASSERT( status != ERROR_SUCCESS );
        SetLastError( status );
    }
    return  pcredHandle;
}



//
//  Cred utils
//

PWSTR
MakeCredKeyFromStrings(
    IN      PWSTR           pwsUserName,
    IN      PWSTR           pwsDomain,
    IN      PWSTR           pwsPassword
    )
/*++

Description:

    Allocates auth identity info and initializes pAuthIn info

Parameters:

    pwsUserName -- user name

    pwsDomain   -- domain name

    pwsPassword -- password

Return:

    Ptr to newly create credentials.
    NULL on failure.

--*/
{
    DWORD   length;
    PWSTR   pstr;

    DNSDBG( SECURITY, (
        "Enter MakeCredKeyFromStrings()\n"
        "\tuser     = %S\n"
        "\tdomain   = %S\n"
        "\tpassword = %S\n",
        pwsUserName,
        pwsDomain,
        pwsPassword ));

    //
    //  determine length and allocate
    //

    length  = wcslen( pwsUserName );
    length  += wcslen( pwsDomain );
    length  += wcslen( pwsPassword );

    length  += 3;   // two separators and NULL terminator

    pstr = ALLOCATE_HEAP( length * sizeof(WCHAR) );
    if ( ! pstr )
    {
        return  NULL;
    }

    //
    //  build cred info
    //

    _snwprintf(
        pstr,
        length,
        L"%s\\%s\\%s",
        pwsDomain,
        pwsUserName,
        pwsPassword );

    DNSDBG( SECURITY, (
        "Created cred string %S\n",
        pstr ));

    return  pstr;
}



PWSTR
MakeCredKey(
    IN      PCHAR           pCreds
    )
/*++

Description:

    Allocates auth identity info and initializes pAuthIn info

Parameters:

    pCreds  -- credentials

Return:

    Ptr to newly create credentials.
    NULL on failure.

--*/
{
    PSEC_WINNT_AUTH_IDENTITY_EXW    pauth = NULL;
    SEC_WINNT_AUTH_IDENTITY_EXW     dummyAuth;
    PWSTR   pstr = NULL;
    DWORD   length;


    DNSDBG( SECURITY, (
        "MakeCredKey( %p )\n",
        pCreds ));

    //
    //  determine AUTH_EX or old style credentials
    //      - if old style dummy up new version
    //

    pauth = (PSEC_WINNT_AUTH_IDENTITY_EXW) pCreds;

    if ( pauth->Length == sizeof(*pauth) &&
         pauth->Version < 0x10000 )
    {
        DNSDBG( SECURITY, (
            "Creds at %p are new AuthEx creds.\n",
            pCreds ));
    }
    else
    {
        DNSDBG( SECURITY, (
            "Creds at %p are old style.\n",
            pCreds ));

        RtlCopyMemory(
            (PBYTE) &dummyAuth.User,
            pCreds,
            sizeof(SEC_WINNT_AUTH_IDENTITY_W) );

        pauth = &dummyAuth;
    }

    //
    //  sum lengths and allocate string
    //

    length  =   pauth->UserLength;
    length  +=  pauth->DomainLength;
    length  +=  pauth->PasswordLength;
    length  +=  3;

    pstr = ALLOCATE_HEAP( length * sizeof(WCHAR) );
    if ( ! pstr )
    {
        return  NULL;
    }

    //
    //  determine unicode \ ANSI -- write string
    //
    //  note that %S and %s are reversed for wide char printf like functions
    //  the global rule is %s matches the type of function (the format string)
    //  and %S is the other type
    //

    if ( pauth->Flags & SEC_WINNT_AUTH_IDENTITY_UNICODE )
    {
        _snwprintf(
            pstr,
            length,
            L"%s\\%s\\%s",
            pauth->Domain,
            pauth->User,
            pauth->Password );
    
        DNSDBG( SECURITY, (
            "Created cred string %S from unicode\n",
            pstr ));
    }
    else
    {
        _snwprintf(
            pstr,
            length,
            L"%S\\%S\\%S",
            (PSTR) pauth->Domain,
            (PSTR) pauth->User,
            (PSTR) pauth->Password );

        DNSDBG( SECURITY, (
            "Created cred string %S from ANSI\n",
            pstr ));
    }
    return  pstr;
}



BOOL
CompareCredKeys(
    IN      PWSTR           pwsCredKey1,
    IN      PWSTR           pwsCredKey2
    )
/*++

Description:

    Compare cred strings for matching security contexts.

Parameters:

    pwsCredKey1 -- cred string

    pwsCredKey2 -- cred string

Return:

    TRUE if match.
    FALSE if no match.

--*/
{
    DNSDBG( SECURITY, (
        "CompareCredKeys( %S, %S )\n",
        pwsCredKey1,
        pwsCredKey2 ));

    //
    //  most common case -- no creds
    //

    if ( !pwsCredKey1 || !pwsCredKey2 )
    {
        return( pwsCredKey2==pwsCredKey1 );
    }

    //
    //  cred strings are wide character strings
    //      - just string compare
    //

    return( wcscmp( pwsCredKey1, pwsCredKey2 ) == 0 );
}

//
//  End security.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\secutil.c ===
/*++

Copyright (c) 1998-2001 Microsoft Corporation

Module Name:

    secutil.c

Abstract:

    Domain Name System (DNS) Library

    DNS secure update API.

Author:

    Jim Gilroy (jamesg)         January, 1998

Revision History:

--*/

#include "local.h"

//  security headers

//#define SECURITY_WIN32
//#include "sspi.h"
//#include "issperr.h"
//#include "rpc.h"
//#include "rpcndr.h"
//#include "ntdsapi.h"



//
//  Security utilities
//

DNS_STATUS
Dns_CreateSecurityDescriptor(
    OUT     PSECURITY_DESCRIPTOR *  ppSD,
    IN      DWORD                   AclCount,
    IN      PSID *                  SidPtrArray,
    IN      DWORD *                 AccessMaskArray
    )
/*++

Routine Description:

    Build security descriptor.

Arguments:

    ppSD -- addr to receive SD created

    AclCount -- number of ACLs to add

    SidPtrArray -- array of SIDs to create ACLs for

    AccessMaskArray -- array of access masks corresponding to SIDs

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DNS_STATUS              status;
    DWORD                   i;
    DWORD                   lengthAcl;
    PSECURITY_DESCRIPTOR    psd = NULL;
    PACL                    pacl;

    //
    //  calculate space for SD
    //

    lengthAcl = sizeof(ACL);

    for ( i=0;  i<AclCount;  i++ )
    {
        if ( SidPtrArray[i] && AccessMaskArray[i] )
        {
            lengthAcl += GetLengthSid( SidPtrArray[i] ) + sizeof(ACCESS_ALLOWED_ACE);
        }
        ELSE
        {
            DNS_PRINT((
                "ERROR:  SD building with SID (%p) and mask (%p)\n",
                SidPtrArray[i],
                AccessMaskArray[i] ));
        }
    }

    //
    //  allocate SD
    //

    psd = (PSECURITY_DESCRIPTOR) ALLOCATE_HEAP(
                                    SECURITY_DESCRIPTOR_MIN_LENGTH + lengthAcl );
    if ( !psd )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Failed;
    }

    DNSDBG( INIT, (
        "Allocated SecurityDesc at %p of length %d\n",
        psd,
        SECURITY_DESCRIPTOR_MIN_LENGTH + lengthAcl ));

    //
    //  build ACL, adding ACE with desired access for each SID
    //

    pacl = (PACL) ((PBYTE)psd + SECURITY_DESCRIPTOR_MIN_LENGTH);

    if ( !InitializeAcl(
            pacl,
            lengthAcl,
            ACL_REVISION ) )
    {
        status = GetLastError();
        goto Failed;
    }

    for ( i=0;  i<AclCount;  i++ )
    {
        if ( SidPtrArray[i] && AccessMaskArray[i] )
        {
            if ( !AddAccessAllowedAce(
                    pacl,
                    ACL_REVISION,
                    AccessMaskArray[i],
                    SidPtrArray[i] ) )
            {
                status = GetLastError();
                DNSDBG( ANY, (
                    "ERROR:  failed adding ACE for SID %p, mask %p\n",
                    SidPtrArray[i],
                    AccessMaskArray[i] ));
                goto Failed;
            }
        }
    }

    //
    //  setup SD with ACL
    //

    if ( !InitializeSecurityDescriptor(
            psd,
            SECURITY_DESCRIPTOR_REVISION ))
    {
        status = GetLastError();
        goto Failed;
    }

    if ( !SetSecurityDescriptorDacl(
                psd,
                TRUE,       // ACL present
                pacl,
                FALSE       // explicit ACL, not defaulted
                ))
    {
        status = GetLastError();
        goto Failed;
    }

    *ppSD = psd;

    return( ERROR_SUCCESS );


Failed:

    ASSERT( status != ERROR_SUCCESS );
    *ppSD = NULL;
    FREE_HEAP( psd );

    return( status );
}



//
//  Credential utilities
//

PSEC_WINNT_AUTH_IDENTITY_W
Dns_AllocateAndInitializeCredentialsW(
    IN      PSEC_WINNT_AUTH_IDENTITY_W  pAuthIn
    )
/*++

Description:

    Allocates auth identity info and initializes pAuthIn info

Parameters:

    pAuthIn -- auth identity info

Return:

    Ptr to newly create credentials.
    NULL on failure.

--*/
{
    PSEC_WINNT_AUTH_IDENTITY_W pauthCopy = NULL;

    DNSDBG( SECURITY, (
        "Call Dns_AllocateAndInitializeCredentialsW\n" ));

    if ( !pAuthIn )
    {
        return NULL;
    }
    ASSERT( pAuthIn->Flags == SEC_WINNT_AUTH_IDENTITY_UNICODE );

    //
    //  allocate credentials struct
    //      - zero for simple cleanup on subfield alloc failures
    //

    pauthCopy = ALLOCATE_HEAP_ZERO( sizeof(SEC_WINNT_AUTH_IDENTITY_W) );
    if ( !pauthCopy )
    {
        return NULL;
    }

    //
    //  copy subfields
    //

    //  user

    pauthCopy->UserLength = pAuthIn->UserLength;
    if ( pAuthIn->UserLength )
    {
        ASSERT( pAuthIn->UserLength == wcslen(pAuthIn->User) );

        pauthCopy->User = ALLOCATE_HEAP( (pAuthIn->UserLength + 1) * sizeof(WCHAR) );
        if ( ! pauthCopy->User )
        {
            goto Failed;
        }
        wcscpy( pauthCopy->User, pAuthIn->User );
    }

    //  password
    //      - must allow zero length password

    pauthCopy->PasswordLength = pAuthIn->PasswordLength;

    if ( pAuthIn->PasswordLength  ||  pAuthIn->Password )
    {
        ASSERT( pAuthIn->PasswordLength == wcslen(pAuthIn->Password) );

        pauthCopy->Password = ALLOCATE_HEAP( (pAuthIn->PasswordLength + 1) * sizeof(WCHAR) );
        if ( ! pauthCopy->Password )
        {
            goto Failed;
        }
        wcscpy( pauthCopy->Password, pAuthIn->Password );
    }

    //  domain

    pauthCopy->DomainLength = pAuthIn->DomainLength;
    if ( pAuthIn->DomainLength )
    {
        ASSERT( pAuthIn->DomainLength == wcslen(pAuthIn->Domain) );

        pauthCopy->Domain = ALLOCATE_HEAP( (pAuthIn->DomainLength + 1) * sizeof(WCHAR) );
        if ( ! pauthCopy->Domain )
        {
            goto Failed;
        }
        wcscpy( pauthCopy->Domain, pAuthIn->Domain );
    }

    pauthCopy->Flags = pAuthIn->Flags;

    DNSDBG( SECURITY, (
        "Exit Dns_AllocateAndInitializeCredentialsW()\n" ));

    return pauthCopy;


Failed:

    //  allocation failure
    //      - cleanup what was allocated and get out

    Dns_FreeAuthIdentityCredentials( pauthCopy );
    return( NULL );
}



PSEC_WINNT_AUTH_IDENTITY_A
Dns_AllocateAndInitializeCredentialsA(
    IN      PSEC_WINNT_AUTH_IDENTITY_A  pAuthIn
    )
/*++

Description:

    Allocates auth identity info and initializes pAuthIn info

    Note:  it is more work to convert to unicode and call previous
        function than to call this one

Parameters:

    pAuthIn -- auth identity info

Return:

    Ptr to newly create credentials.
    NULL on failure.

--*/
{
    PSEC_WINNT_AUTH_IDENTITY_A pauthCopy = NULL;

    DNSDBG( SECURITY, (
        "Call Dns_AllocateAndInitializeCredentialsA\n" ));

    //
    //  allocate credentials struct
    //      - zero for simple cleanup on subfield alloc failures
    //

    if ( !pAuthIn )
    {
        return NULL;
    }
    ASSERT( pAuthIn->Flags == SEC_WINNT_AUTH_IDENTITY_ANSI );

    //
    //  allocate credentials struct
    //      - zero for simple cleanup on subfield alloc failures
    //

    pauthCopy = ALLOCATE_HEAP_ZERO( sizeof(SEC_WINNT_AUTH_IDENTITY_A) );
    if ( !pauthCopy )
    {
        return NULL;
    }

    //
    //  copy subfields
    //

    //  user

    pauthCopy->UserLength = pAuthIn->UserLength;
    if ( pAuthIn->UserLength )
    {
        ASSERT( pAuthIn->UserLength == strlen(pAuthIn->User) );

        pauthCopy->User = ALLOCATE_HEAP( (pAuthIn->UserLength + 1) * sizeof(CHAR) );
        if ( ! pauthCopy->User )
        {
            goto Failed;
        }
        strcpy( pauthCopy->User, pAuthIn->User );
    }

    //  password
    //      - must allow zero length password

    pauthCopy->PasswordLength = pAuthIn->PasswordLength;

    if ( pAuthIn->PasswordLength  ||  pAuthIn->Password )
    {
        ASSERT( pAuthIn->PasswordLength == strlen(pAuthIn->Password) );

        pauthCopy->Password = ALLOCATE_HEAP( (pAuthIn->PasswordLength + 1) * sizeof(CHAR) );
        if ( ! pauthCopy->Password )
        {
            goto Failed;
        }
        strcpy( pauthCopy->Password, pAuthIn->Password );
    }

    //  domain

    pauthCopy->DomainLength = pAuthIn->DomainLength;
    if ( pAuthIn->DomainLength )
    {
        ASSERT( pAuthIn->DomainLength == strlen(pAuthIn->Domain) );

        pauthCopy->Domain = ALLOCATE_HEAP( (pAuthIn->DomainLength + 1) * sizeof(CHAR) );
        if ( ! pauthCopy->Domain )
        {
            goto Failed;
        }
        strcpy( pauthCopy->Domain, pAuthIn->Domain );
    }

    pauthCopy->Flags = pAuthIn->Flags;

    DNSDBG( SECURITY, (
        "Exit Dns_AllocateAndInitializeCredentialsA()\n" ));

    return pauthCopy;


Failed:

    //  allocation failure
    //      - cleanup what was allocated and get out

    Dns_FreeAuthIdentityCredentials( pauthCopy );
    return( NULL );
}



VOID
Dns_FreeAuthIdentityCredentials(
    IN OUT  PVOID           pAuthIn
    )
/*++

Routine Description (Dns_FreeAuthIdentityCredentials):

    Free's structure given

Arguments:

    pAuthIn -- in param to free

Return Value:

    None

--*/
{
    register PSEC_WINNT_AUTH_IDENTITY_W pauthId;

    pauthId = (PSEC_WINNT_AUTH_IDENTITY_W) pAuthIn;
    if ( !pauthId )
    {
        return;
    }

    //
    //  assuming _W and _A structs are equivalent except
    //      for string types
    //

    ASSERT( sizeof( SEC_WINNT_AUTH_IDENTITY_W ) ==
            sizeof( SEC_WINNT_AUTH_IDENTITY_A ) );

    if ( pauthId->User )
    {
        FREE_HEAP ( pauthId->User );
    }
    if ( pauthId->Password )
    {
        FREE_HEAP ( pauthId->Password );
    }
    if ( pauthId->Domain )
    {
        FREE_HEAP ( pauthId->Domain );
    }

    FREE_HEAP ( pauthId );
}



PSEC_WINNT_AUTH_IDENTITY_W
Dns_AllocateCredentials(
    IN      PWSTR           pwsUserName,
    IN      PWSTR           pwsDomain,
    IN      PWSTR           pwsPassword
    )
/*++

Description:

    Allocates auth identity info and initializes pAuthIn info

Parameters:

    pwsUserName -- user name

    pwsDomain   -- domain name

    pwsPassword -- password

Return:

    Ptr to newly create credentials.
    NULL on failure.

--*/
{
    PSEC_WINNT_AUTH_IDENTITY_W  pauth = NULL;
    DWORD   length;
    PWSTR   pstr;


    DNSDBG( SECURITY, (
        "Enter Dns_AllocateCredentials()\n"
        "\tuser     = %S\n"
        "\tdomain   = %S\n"
        "\tpassword = %S\n",
        pwsUserName,
        pwsDomain,
        pwsPassword ));

    //
    //  allocate credentials struct
    //      - zero for simple cleanup on subfield alloc failures
    //

    pauth = ALLOCATE_HEAP_ZERO( sizeof(SEC_WINNT_AUTH_IDENTITY_W) );
    if ( !pauth )
    {
        return NULL;
    }

    //  copy user

    length = wcslen( pwsUserName );

    pstr = ALLOCATE_HEAP( (length + 1) * sizeof(WCHAR) );
    if ( ! pstr )
    {
        goto Failed;
    }
    wcscpy( pstr, pwsUserName );

    pauth->User = pstr;
    pauth->UserLength = length;

    //  copy domain

    length = wcslen( pwsDomain );

    pstr = ALLOCATE_HEAP( (length + 1) * sizeof(WCHAR) );
    if ( ! pstr )
    {
        goto Failed;
    }
    wcscpy( pstr, pwsDomain );

    pauth->Domain = pstr;
    pauth->DomainLength = length;

    //  copy password

    length = wcslen( pwsPassword );

    pstr = ALLOCATE_HEAP( (length + 1) * sizeof(WCHAR) );
    if ( ! pstr )
    {
        goto Failed;
    }
    wcscpy( pstr, pwsPassword );

    pauth->Password = pstr;
    pauth->PasswordLength = length;

    //  set to unicode

    pauth->Flags = SEC_WINNT_AUTH_IDENTITY_UNICODE;

    DNSDBG( SECURITY, (
        "Exit Dns_AllocateCredentialsW( %p )\n",
        pauth ));

    return pauth;


Failed:

    //  allocation failure
    //      - cleanup what was allocated and get out

    Dns_FreeAuthIdentityCredentials( pauth );
    return( NULL );
}



//
//  DNS Credential utilities (unused)
//

DNS_STATUS
Dns_ImpersonateUser(
    IN      PDNS_CREDENTIALS    pCreds
    )
/*++

Routine Description:

    Impersonate a user.

Arguments:

    pCreds -- credentials of user to impersonate

Return Value:

    ERROR_SUCCESS if successful
    Error code on failure.

--*/
{
    DNS_STATUS  status = NO_ERROR;
    HANDLE      htoken;
    
    //
    //  attempt logon
    //

    if ( ! LogonUserW(
                pCreds->pUserName,
                pCreds->pDomain,
                pCreds->pPassword,
                LOGON32_LOGON_SERVICE,
                LOGON32_PROVIDER_WINNT50,
                &htoken ) )
    {
        status = GetLastError();
        if ( status == NO_ERROR )
        {
            status = ERROR_CANNOT_IMPERSONATE;
            DNS_ASSERT( FALSE );
        }

        DNSDBG( SECURITY, (
            "LogonUser() failed => %d\n"
            "\tuser     = %S\n"
            "\tdomain   = %S\n"
            "\tpassword = %S\n",
            status,
            pCreds->pUserName,
            pCreds->pDomain,
            pCreds->pPassword
            ));

        return status;
    }

    //
    //  impersonate
    //

    if ( !ImpersonateLoggedOnUser( htoken ) )
    {
        status = GetLastError();
        if ( status == NO_ERROR )
        {
            status = ERROR_CANNOT_IMPERSONATE;
            DNS_ASSERT( FALSE );
        }

        DNSDBG( SECURITY, (
            "ImpersonateLoggedOnUser() failed = %d\n",
            status ));
    }
    
    CloseHandle( htoken );

    DNSDBG( SECURITY, (
        "%s\n"
        "\tuser     = %S\n"
        "\tdomain   = %S\n"
        "\tpassword = %S\n",
        (status == NO_ERROR)
            ? "Successfully IMPERSONATING!"
            : "Failed IMPERSONATION!",
        pCreds->pUserName,
        pCreds->pDomain,
        pCreds->pPassword ));

    return  status;
}



VOID
Dns_FreeCredentials(
    IN      PDNS_CREDENTIALS    pCreds
    )
/*++

Routine Description:

    Free DNS credentials.

Arguments:

    pCreds -- credentials to free

Return Value:

    None

--*/
{
    //
    //  free subfields, then credentials
    //

    if ( !pCreds )
    {
        return;
    }

    if ( pCreds->pUserName )
    {
        FREE_HEAP( pCreds->pUserName );
    }
    if ( pCreds->pDomain )
    {
        FREE_HEAP( pCreds->pDomain );
    }
    if ( pCreds->pPassword )
    {
        FREE_HEAP( pCreds->pPassword );
    }
    FREE_HEAP( pCreds );
}



PDNS_CREDENTIALS
Dns_CopyCredentials(
    IN      PDNS_CREDENTIALS    pCreds
    )
/*++

Routine Description:

    Create copy of DNS credentials.

Arguments:

    pCreds -- credentials of user to copy

Return Value:

    Ptr to allocated copy of credentials.

--*/
{
    PDNS_CREDENTIALS    pnewCreds = NULL;
    PWSTR               pfield;

    //
    //  allocate credentials
    //      - copy of subfields
    //

    pnewCreds = (PDNS_CREDENTIALS) ALLOCATE_HEAP_ZERO( sizeof(*pnewCreds) );
    if ( !pnewCreds )
    {
        return( NULL );
    }

    pfield = (PWSTR) Dns_CreateStringCopy_W( pCreds->pUserName );
    if ( !pfield )
    {
        goto Failed;
    }
    pnewCreds->pUserName = pfield;

    pfield = (PWSTR) Dns_CreateStringCopy_W( pCreds->pDomain );
    if ( !pfield )
    {
        goto Failed;
    }
    pnewCreds->pDomain = pfield;

    pfield = (PWSTR) Dns_CreateStringCopy_W( pCreds->pPassword );
    if ( !pfield )
    {
        goto Failed;
    }
    pnewCreds->pPassword = pfield;

    return( pnewCreds );

Failed:

    Dns_FreeCredentials( pnewCreds );
    return( NULL );
}
    
//
//  End secutil.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\sablob.c ===
/*++

Copyright (c) 2002-2002 Microsoft Corporation

Module Name:

    sablob.c

Abstract:

    Domain Name System (DNS) Library

    Sockaddr blob routines.

Author:

    Jim Gilroy (jamesg)     May 25, 2002

Revision History:

--*/


#include "local.h"
#include "ws2atm.h"     // ATM address


//
//  Max number of aliases
//

#define DNS_MAX_ALIAS_COUNT     (8)

//
//  Min size of sablob address buffer
//      - enough for one address of largest type
//

#define MIN_ADDR_BUF_SIZE   (sizeof(ATM_ADDRESS))



//
//  SockaddrResults utilities
//


BOOL
SaBlob_IsSupportedAddrType(
    IN      WORD            wType
    )
/*++

Routine Description:

    Is this a supported address type for sablob.

Arguments:

    wType -- type in question

Return Value:

    TRUE if type supported
    FALSE otherwise

--*/
{
    return ( wType == DNS_TYPE_A ||
             wType == DNS_TYPE_AAAA ||
             wType == DNS_TYPE_ATMA );
}


#if 0

DWORD
SaBlob_WriteLocalIp4Array(
    IN OUT  PSABLOB         pBlob,
    OUT     PCHAR           pAddrBuf,
    IN      DWORD           MaxBufCount,
    IN      PIP4_ARRAY      pIpArray
    )
/*++

Routine Description:

    Write local IP list into sablob.

Arguments:

    pBlob -- sablob

    pAddrBuf -- buffer to hold addresses

    MaxBufCount -- max IPs buffer can hold

    pIpArray -- IP4 array of local addresses

Return Value:

    Count of addresses written

--*/
{
    DWORD   count = 0;

    //
    //  write array
    //

    if ( pIpArray )
    {
        count = SaBlob_WriteIp4Addrs(
                    pBlob,
                    pAddrBuf,
                    MaxBufCount,
                    pIpArray->AddrArray,
                    pIpArray->AddrCount,
                    TRUE        // screen out zeros
                    );
    }

    //
    //  if no addresses written, write loopback
    //

    if ( count==0 )
    {
        pBlob->h_addr_list[0] = pAddrBuf;
        pBlob->h_addr_list[1] = NULL;
        *((IP4_ADDRESS*)pAddrBuf) = DNS_NET_ORDER_LOOPBACK;
        count = 1;
    }

    //  count of addresses written

    return( count );
}



BOOL
SaBlob_SetToSingleAddress(
    IN OUT  PSABLOB         pBlob,
    IN      PDNS_ADDR       pAddr
    )
/*++

Routine Description:

    Set address in sablob.

Arguments:

    pBlob -- sablob to set to addr

    pAddr -- ptr to address

Return Value:

    TRUE if address successfully copied into sablob.
    FALSE otherwise (no sablob, wrong length, sablob empty)

--*/
{
    PCHAR   paddrSockaddrResults;

    //
    //  validate
    //      - must have sablob
    //      - length must match
    //

    if ( !pBlob ||
         AddrLength != (DWORD)pBlob->h_length )
    {
        return FALSE;
    }

    //
    //  slam address in on top of existing
    //      - NULL 2nd addr pointer to terminate list
    //

    paddrSockaddrResults = pBlob->h_addr_list[0];
    if ( !paddrSockaddrResults )
    {
        return FALSE;
    }

    RtlCopyMemory(
        paddrSockaddrResults,
        pAddr,
        AddrLength );

    pBlob->h_addr_list[1] = NULL;

    return  TRUE;
}



BOOL
SaBlob_IsAddressInSockaddrResults(
    IN OUT  PSABLOB         pBlob,
    IN      PCHAR           pAddr,
    IN      DWORD           AddrLength,
    IN      INT             Family          OPTIONAL
    )
/*++

Routine Description:

    Does sablob contain this address.

Arguments:

    pBlob -- sablob to check

    pAddr -- ptr to address to check

    AddrLength -- address length

    Family -- address family

Return Value:

    TRUE if address is in sablob.
    FALSE otherwise.

--*/
{
    BOOL    freturn = FALSE;
    DWORD   i;
    PCHAR   paddrSockaddrResults;

    //
    //  validate
    //      - must have sablob
    //      - must have address
    //      - if family given, must match
    //      - length must match
    //

    if ( !pBlob ||
         !pAddr    ||
         AddrLength != (DWORD)pBlob->h_length ||
         ( Family && Family != pBlob->h_addrtype ) )
    {
        return freturn;
    }

    //
    //  search for address -- if found return TRUE
    //

    i = 0;

    while ( paddrSockaddrResults = pBlob->h_addr_list[i++] )
    {
        freturn = RtlEqualMemory(
                        paddrSockaddrResults,
                        pAddr,
                        AddrLength );
        if ( freturn )
        {
            break;
        }
    }

    return  freturn;
}



BOOL
SaBlob_IsIp4AddressInSockaddrResults(
    IN OUT  PSABLOB        pBlob,
    IN      IP4_ADDRESS     Ip4Addr
    )
/*++

Routine Description:

    Does sablob contain this address.

Arguments:

    pBlob -- sablob to check

    pAddr -- ptr to address to check

    AddrLength -- address length

    Family -- address family

Return Value:

    TRUE if address is in sablob.
    FALSE otherwise.

--*/
{
    DWORD   i;
    PCHAR   paddrSockaddrResults;

    //
    //  validate
    //      - must have sablob
    //      - length must match
    //

    if ( !pBlob ||
         sizeof(IP4_ADDRESS) != (DWORD)pBlob->h_length )
    {
        return FALSE;
    }

    //
    //  search for address -- if found return TRUE
    //

    i = 0;

    while ( paddrSockaddrResults = pBlob->h_addr_list[i++] )
    {
        if ( Ip4Addr == *(PIP4_ADDRESS)paddrSockaddrResults )
        {
            return  TRUE;
        }
    }
    return  FALSE;
}

#endif




//
//  SaBlob routines
//

PSABLOB
SaBlob_Create(
    IN      DWORD           AddrCount
    )
/*++

Routine Description:

    Create sablob, optionally creating DnsAddrArray for it.

Arguments:

    AddrCount -- address count

Return Value:

    Ptr to new sablob.
    NULL on error, GetLastError() contains error.

--*/
{
    PSABLOB     pblob;

    DNSDBG( SABLOB, ( "SaBlob_Create( %d )\n", AddrCount ));

    //
    //  allocate blob
    //

    pblob = (PSABLOB) ALLOCATE_HEAP_ZERO( sizeof(SABLOB) );
    if ( !pblob )
    {
        goto Failed;
    }

    //
    //  alloc addr array
    //

    if ( AddrCount )
    {
        PDNS_ADDR_ARRAY parray = DnsAddrArray_Create( AddrCount );
        if ( !parray )
        {
            goto Failed;
        }
        pblob->pAddrArray = parray;
    }

    DNSDBG( SABLOB, ( "SaBlob_Create() successful.\n" ));

    return( pblob );


Failed:

    SaBlob_Free( pblob );

    DNSDBG( SABLOB, ( "SockaddrResults Blob create failed!\n" ));

    SetLastError( DNS_ERROR_NO_MEMORY );

    return  NULL;
}



VOID
SaBlob_Free(
    IN OUT  PSABLOB         pBlob
    )
/*++

Routine Description:

    Free sablob blob.

Arguments:

    pBlob -- blob to free

Return Value:

    None

--*/
{
    DWORD   i;

    if ( pBlob )
    {
        FREE_HEAP( pBlob->pName );

        //  free every alias as resetting alias count is
        //  used to ignore them

        //for ( i=0; i<pBlob->AliasCount; i++ )
        for ( i=0; i<DNS_MAX_ALIAS_COUNT; i++ )
        {
            FREE_HEAP( pBlob->AliasArray[i] );
        }
    
        DnsAddrArray_Free( pBlob->pAddrArray );
    
        FREE_HEAP( pBlob );
    }
}



PSABLOB
SaBlob_CreateFromIp4(
    IN      PWSTR           pName,
    IN      DWORD           AddrCount,
    IN      PIP4_ADDRESS    pIpArray
    )
/*++

Routine Description:

    Create sablob from IP4 addresses.

    Use this to build from results of non-DNS queries.
    Specifically NBT lookup.

Arguments:

    pName -- name for sablob

    AddrCount -- address count

    pIpArray -- array of addresses

Return Value:

    Ptr to blob if successful.
    NULL on error;  GetLastError() has error.

--*/
{
    DNS_STATUS      status = DNS_ERROR_NO_MEMORY;
    PSABLOB         pblob = NULL;
    DWORD           i;

    DNSDBG( SABLOB, (
        "SaBlob_CreateFromIp4()\n"
        "\tpname    = %S\n"
        "\tcount    = %d\n"
        "\tpArray   = %p\n",
        pName,
        AddrCount,
        pIpArray ));


    //          
    //  create blob
    //

    pblob = SaBlob_Create( AddrCount );
    if ( !pblob )
    {
        goto Done;
    }

    //
    //  copy name
    //

    if ( pName )
    {
        PWSTR   pname = Dns_CreateStringCopy_W( pName );
        if ( !pname )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }
        pblob->pName = pname;
    }

    //
    //  copy addresses
    //

    for ( i=0; i<AddrCount; i++ )
    {
        DnsAddrArray_AddIp4(
            pblob->pAddrArray,
            pIpArray[ i ],
            DNSADDR_MATCH_IP
            );
    }
    status = NO_ERROR;

    IF_DNSDBG( SABLOB )
    {
        DnsDbg_SaBlob(
            "Leaving SaBlob_CreateFromIp4():",
            pblob );
    }

Done:

    if ( status != NO_ERROR )
    {
        SaBlob_Free( pblob );
        pblob = NULL;
        SetLastError( status );
    }

    DNSDBG( SABLOB, (
        "Leave SaBlob_CreateFromIp4() => status = %d\n",
        status ));

    return( pblob );
}



VOID
SaBlob_AttachHostent(
    IN OUT  PSABLOB         pBlob,
    IN      PHOSTENT        pHostent
    )
{
    DNSDBG( SABLOB, ( "SaBlob_AttachHostent()\n" ));

    //
    //  attach existing hostent to sablob
    //

    pBlob->pHostent = pHostent;
}



DNS_STATUS
SaBlob_WriteAddress(
    IN OUT  PSABLOB         pBlob,
    IN      PDNS_ADDR       pAddr
    )
/*++

Routine Description:

    Write address to sablob.

Arguments:

    pBlob -- sablob

    pAddr - address to write

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_MORE_DATA if out of buffer space
    ERROR_INVALID_DATA if address doesn't match sablob

--*/
{
    PDNS_ADDR_ARRAY parray;

    //
    //  if no address array -- create one
    //

    parray = pBlob->pAddrArray;

    if ( !parray )
    {
        parray = DnsAddrArray_Create( 1 );
        if ( !parray )
        {
            return  DNS_ERROR_NO_MEMORY;
        }
        pBlob->pAddrArray = parray;
    }

    //
    //  slap address into array
    //      - fail if array too full
    //

    if ( DnsAddrArray_AddAddr(
            parray,
            pAddr,
            0,      // no family check
            0       // no match flag
            ) )
    {
        return  NO_ERROR;
    }
    return  ERROR_MORE_DATA;
}



#if 0
DNS_STATUS
SaBlob_WriteAddressArray(
    IN OUT  PSABLOB   pBlob,
    IN      PVOID           pAddrArray,
    IN      DWORD           AddrCount,
    IN      DWORD           AddrSize,
    IN      DWORD           AddrType
    )
/*++

Routine Description:

    Write address array to sablob blob.

Arguments:

    pBlob -- sablob build blob

    pAddrArray - address array to write

    AddrCount - address count

    AddrSize - address size

    AddrType - address type (sablob type, e.g. AF_INET)

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_MORE_DATA if out of buffer space
    ERROR_INVALID_DATA if address doesn't match sablob

--*/
{
    DWORD       count = AddrCount;
    PCHAR       pcurrent;
    DWORD       totalSize;
    DWORD       i;
    DWORD       bytesLeft;

    //  verify type
    //      - set if empty or no addresses written

    if ( phost->h_addrtype != (SHORT)AddrType )
    {
        if ( phost->h_addrtype != 0 )
        {
            return( ERROR_INVALID_DATA );
        }
        phost->h_addrtype   = (SHORT) AddrType;
        phost->h_length     = (SHORT) AddrSize;
    }

    //  verify space

    if ( count > pBlob->MaxAddrCount )
    {
        return( ERROR_MORE_DATA );
    }

    //  align - to DWORD
    //
    //  note:  we are assuming that pAddrArray is internally
    //      aligned adequately, otherwise we wouldn't be
    //      getting an intact array and would have to add serially
    
    pcurrent = DWORD_ALIGN( pBlob->pCurrent );
    bytesLeft = pBlob->BytesLeft;
    bytesLeft -= (DWORD)(pcurrent - pBlob->pCurrent);

    totalSize = count * AddrSize;

    if ( bytesLeft < totalSize )
    {
        return( ERROR_MORE_DATA );
    }

    //  copy
    //      - copy address array to buffer
    //      - set pointer to each address in array
    //      - NULL following pointer

    RtlCopyMemory(
        pcurrent,
        pAddrArray,
        totalSize );

    for ( i=0; i<count; i++ )
    {
        phost->h_addr_list[i] = pcurrent;
        pcurrent += AddrSize;
    }
    phost->h_addr_list[count] = NULL;
    pBlob->AddrCount = count;

    pBlob->pCurrent = pcurrent;
    pBlob->BytesLeft = bytesLeft - totalSize;

    return( NO_ERROR );
}
#endif



DNS_STATUS
SaBlob_WriteNameOrAlias(
    IN OUT  PSABLOB         pBlob,
    IN      PWSTR           pszName,
    IN      BOOL            fAlias
    )
/*++

Routine Description:

    Write name or alias to sablob

Arguments:

    pBlob -- sablob build blob

    pszName -- name to write

    fAlias -- TRUE for alias;  FALSE for name

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_MORE_DATA if out of buffer space
    ERROR_INVALID_DATA if address doesn't match sablob

--*/
{
    DWORD   count = pBlob->AliasCount;
    PWSTR   pcopy;

    //
    //  verify space
    //  included ptr space
    //      - skip if already written name
    //      or exhausted alias array
    //      

    if ( fAlias )
    {
        if ( count >= DNS_MAX_ALIAS_COUNT )
        {
            return( ERROR_MORE_DATA );
        }
    }
    else if ( pBlob->pName )
    {
        return( ERROR_MORE_DATA );
    }

    //
    //  copy
    //      - copy name
    //      - set ptr in blob

    pcopy = Dns_CreateStringCopy_W( pszName );
    if ( !pcopy )
    {
        return  GetLastError();
    }

    if ( fAlias )
    {
        pBlob->AliasArray[count++] = pcopy;
        pBlob->AliasCount = count;
    }
    else
    {
        pBlob->pName = pcopy;
    }

    return( NO_ERROR );
}



DNS_STATUS
SaBlob_WriteRecords(
    IN OUT  PSABLOB         pBlob,
    IN      PDNS_RECORD     pRecords,
    IN      BOOL            fWriteName
    )
/*++

Routine Description:

    Write name or alias to sablob

Arguments:

    pBlob -- sablob build blob

    pRecords -- records to convert to sablob

    fWriteName -- write name

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_MORE_DATA if out of buffer space
    ERROR_INVALID_DATA if address doesn't match sablob

--*/
{
    DNS_STATUS  status = NO_ERROR;
    PDNS_RECORD prr = pRecords;
    DNS_ADDR    dnsAddr;
    BOOL        fwroteName = FALSE;


    DNSDBG( SABLOB, (
        "SaBlob_WriteRecords( %p, %p, %d )\n",
        pBlob,
        pRecords,
        fWriteName ));

    //
    //  write each record in turn to sablob
    //

    while ( prr )
    {
        WORD    wtype;

        if ( prr->Flags.S.Section != DNSREC_ANSWER &&
             prr->Flags.S.Section != 0 )
        {
            prr = prr->pNext;
            continue;
        }

        wtype = prr->wType;

        switch( wtype )
        {
        case DNS_TYPE_A:
        case DNS_TYPE_AAAA:
        case DNS_TYPE_ATMA:

            DnsAddr_BuildFromDnsRecord(
                & dnsAddr,
                prr );

            status = SaBlob_WriteAddress(
                            pBlob,
                            & dnsAddr );

            //  write name

            if ( fWriteName &&
                 !fwroteName &&
                 !pBlob->pName &&
                 prr->pName )
            {
                status = SaBlob_WriteNameOrAlias(
                            pBlob,
                            (PWSTR) prr->pName,
                            FALSE       // name
                            );
                fwroteName = TRUE;
            }
            break;

        case DNS_TYPE_CNAME:

            //  record name is an alias

            status = SaBlob_WriteNameOrAlias(
                        pBlob,
                        (PWSTR) prr->pName,
                        TRUE        // alias
                        );
            break;

        case DNS_TYPE_PTR:

            //  target name is the sablob name
            //  but if already wrote name, PTR target becomes alias

            status = SaBlob_WriteNameOrAlias(
                        pBlob,
                        (PWSTR) prr->Data.PTR.pNameHost,
                        (pBlob->pName != NULL)
                        );
            break;

        default:

            DNSDBG( ANY, (
                "Error record of type = %d while building sablob!\n",
                wtype ));
            status = ERROR_INVALID_DATA;
        }

        if ( status != ERROR_SUCCESS )
        {
            DNSDBG( ANY, (
                "ERROR:  failed writing record to sablob!\n"
                "\tprr      = %p\n"
                "\ttype     = %d\n"
                "\tstatus   = %d\n",
                prr,
                wtype,
                status ));
        }

        prr = prr->pNext;
    }

    IF_DNSDBG( SABLOB )
    {
        DnsDbg_SaBlob(
            "SaBlob after WriteRecords():",
            pBlob );
    }

    return( status );
}



PSABLOB
SaBlob_CreateFromRecords(
    IN      PDNS_RECORD     pRecords,
    IN      BOOL            fWriteName,
    IN      WORD            wType           OPTIONAL
    )
/*++

Routine Description:

    Create sablob from records

Arguments:

    pRecords -- records to convert to sablob

    fWriteName -- write name to sablob

    wType  -- query type, if known

Return Value:

    Ptr to blob if successful.
    NULL on error;  GetLastError() has error.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PDNS_RECORD     prrFirstAddr = NULL;
    PDNS_RECORD     prr;
    DWORD           addrCount = 0;
    WORD            addrType = 0;
    PSABLOB         pblob = NULL;

    DNSDBG( SABLOB, (
        "SaBlob_CreateFromRecords()\n"
        "\tpblob    = %p\n"
        "\tprr      = %p\n",
        pblob,
        pRecords ));

    //
    //  count addresses
    //
    //  DCR:  fix up section hack when hosts file records get ANSWER section
    //

    prr = pRecords;

    while ( prr )
    {
        if ( ( prr->Flags.S.Section == 0 ||
               prr->Flags.S.Section == DNSREC_ANSWER )
                &&
             SaBlob_IsSupportedAddrType( prr->wType ) )
        {
            addrCount++;
            if ( !prrFirstAddr )
            {
                prrFirstAddr = prr;
                addrType = prr->wType;
            }
        }
        prr = prr->pNext;
    }

    //
    //  create sa-blob of desired size
    //

    pblob = SaBlob_Create( addrCount );
    if ( !pblob )
    {
        status = GetLastError();
        goto Done;
    }

    //
    //  build sablob from answer records
    //
    //  note:  if manage to extract any useful data => continue
    //  this protects against new unwriteable records breaking us
    //

    status = SaBlob_WriteRecords(
                pblob,
                pRecords,
                TRUE        // write name
                );

    if ( status != NO_ERROR )
    {
        if ( pblob->pName ||
             pblob->AliasCount ||
             ( pblob->pAddrArray &&
               pblob->pAddrArray->AddrCount ) )
        {
            status = NO_ERROR;
        }
        else
        {
            goto Done;
        }
    }

    //
    //  write address from PTR record
    //      - first record PTR
    //      OR
    //      - queried for PTR and got CNAME answer, which can happen
    //      in classless reverse lookup case
    //  
    //  DCR:  add PTR address lookup to SaBlob_WriteRecords()
    //      - natural place
    //      - but would have to figure out handling of multiple PTRs
    //

    if ( pRecords &&
         (  pRecords->wType == DNS_TYPE_PTR ||
            ( wType == DNS_TYPE_PTR &&
              pRecords->wType == DNS_TYPE_CNAME &&
              pRecords->Flags.S.Section == DNSREC_ANSWER ) ) )
    {
        DNS_ADDR    dnsAddr;
    
        DNSDBG( SABLOB, (
            "Writing address for PTR record %S\n",
            pRecords->pName ));
    
        //  convert reverse name to IP
    
        if ( Dns_ReverseNameToDnsAddr_W(
                    & dnsAddr,
                    (PWSTR) pRecords->pName ) )
        {
            status = SaBlob_WriteAddress(
                        pblob,
                        & dnsAddr );

            ASSERT( status == NO_ERROR );
            status = ERROR_SUCCESS;
        }
    }

    //
    //  write name?
    //      - write name from first address record
    // 

    if ( !pblob->pName &&
         fWriteName &&
         prrFirstAddr )
    {
        status = SaBlob_WriteNameOrAlias(
                    pblob,
                    (PWSTR) prrFirstAddr->pName,
                    FALSE           // name
                    );
    }

    IF_DNSDBG( SABLOB )
    {
        DnsDbg_SaBlob(
            "SaBlob after CreateFromRecords():",
            pblob );
    }

Done:

    if ( status != NO_ERROR )
    {
        DNSDBG( SABLOB, (
            "Leave SaBlob_CreateFromRecords() => status=%d\n",
            status ));

        SaBlob_Free( pblob );
        pblob = NULL;
        SetLastError( status );
    }
    else
    {
        DNSDBG( SABLOB, (
            "Leave SaBlob_CreateFromRecords() => %p\n",
            pblob ));
    }

    return( pblob );
}



//
//  SockaddrResults Query
//

PSABLOB
SaBlob_Query(
    IN      PWSTR           pwsName,
    IN      WORD            wType,
    IN      DWORD           Flags,
    IN OUT  PVOID *         ppMsg,      OPTIONAL
    IN      INT             AddrFamily  OPTIONAL
    )
/*++

Routine Description:

    Query DNS to get sockaddr results.

Arguments:

    pwsName -- name to query

    wType -- query type

    Flags -- query flags

    ppResults -- addr to receive pointer to results

    AddrType -- address type (family) to reserve space for if querying
        for PTR records

Return Value:

    Ptr to blob if successful.
    NULL on error;  GetLastError() has error.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PDNS_RECORD     prrQuery = NULL;
    PSABLOB         pblob = NULL;
    PVOID           pmsg = NULL;


    DNSDBG( SABLOB, (
        "SaBlob_Query()\n"
        "\tname         = %S\n"
        "\ttype         = %d\n"
        "\tflags        = %08x\n",
        pwsName,
        wType,
        Flags ));


    //
    //  query
    //      - if fails, dump any message before return
    //

    if ( ppMsg )
    {
        *ppMsg = NULL;
    }

    status = DnsQuery_W(
                pwsName,
                wType,
                Flags,
                NULL,
                & prrQuery,
                ppMsg );

    //  if failed, dump any message

    if ( status != NO_ERROR )
    {
        if ( ppMsg && *ppMsg )
        {
            DnsApiFree( *ppMsg );
            *ppMsg = NULL;
        }
        if ( status == RPC_S_SERVER_UNAVAILABLE )
        {
            status = WSATRY_AGAIN;
        }
        goto Done;
    }

    if ( !prrQuery )
    {
        ASSERT( FALSE );
        status = DNS_ERROR_RCODE_NAME_ERROR;
        goto Done;
    }

    //
    //  build sablob
    //

    pblob = SaBlob_CreateFromRecords(
                prrQuery,
                TRUE,       // write name from first answer
                wType
                );
    if ( !pblob )
    {
        status = GetLastError();
        goto Done;
    }

    //
    //  devnote:  if don't have these checks
    //      -- nameless hostent can blow up gethostbyname()
    //      -- NO_ERROR, no address responses can confuse applications

    //
    //  failed name write
    //      - queries that CNAME but don't find record of query type can hit here
    //  

    if ( !pblob->pName )
    {
        status = DNS_INFO_NO_RECORDS;
        goto Done;
    }

#if 0
    //  note:  because SVCID_HOSTNAME query is currently treated as
    //  simply A record query, we can't do no-address screening here;
    //  this screening can be done at higher level for all GUIDs
    //  except HOSTNAME 

    //
    //  for address query must get answer
    //
    //  DCR:  DnsQuery() should convert to no-records on empty CNAME chain?
    //  DCR:  should we go ahead and build sablob?
    //

    if ( !pblob->pAddrArray  &&  SaBlob_IsSupportedAddrType(wType) )
    {
        status = DNS_INFO_NO_RECORDS;
    }
#endif

    //
    //  set returned name to FQDN for loopback lookups
    //  this is for compatibility with previous OS versions
    //

    if ( DnsNameCompare_W( pblob->pName, L"localhost" ) ||
         DnsNameCompare_W( pblob->pName, L"loopback" ) )
    {
        PWSTR   pname;
        PWSTR   pnameFqdn;

        pname = DnsQueryConfigAlloc(
                        DnsConfigFullHostName_W,
                        NULL );
        if ( pname )
        {
            pnameFqdn = Dns_CreateStringCopy_W( pname );
            if ( pnameFqdn )
            {
                FREE_HEAP( pblob->pName );
                pblob->pName = pnameFqdn;
            }
            DnsApiFree( pname );
        }
    }

Done:

    if ( prrQuery )
    {
        DnsRecordListFree(
            prrQuery,
            DnsFreeRecordListDeep );
    }

    if ( status != NO_ERROR  &&  pblob )
    {
        SaBlob_Free( pblob );
        pblob = NULL;
    }

    DNSDBG( SABLOB, (
        "Leave SaBlob_Query()\n"
        "\tpblob    = %p\n"
        "\tstatus   = %d\n",
        pblob,
        status ));

    SetLastError( status );

    return( pblob );
}




//
//  Special sablobs
//

#if 0
PSABLOB
SaBlob_Localhost(
    IN      INT             Family
    )
/*++

Routine Description:

    Create sablob from records

Arguments:

    AddrFamily -- address family

Return Value:

    Ptr to blob if successful.
    NULL on error;  GetLastError() has error.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PDNS_RECORD     prrFirstAddr = NULL;
    PDNS_RECORD     prr;
    DWORD           addrCount = 0;
    DWORD           addrSize;
    CHAR            addrBuf[ sizeof(IP6_ADDRESS    ) ];
    SABLOB_INIT     request;
    PSABLOB    pblob = NULL;

    DNSDBG( SABLOB, ( "SaBlob_Localhost()\n" ));

    //
    //  create sablob blob
    //

    RtlZeroMemory( &request, sizeof(request) );

    request.AliasCount  = 1;
    request.AddrCount   = 1;
    request.AddrFamily  = Family;
    request.fUnicode    = TRUE;

    status = SaBlob_Create(
                & pblob,
                & request );

    if ( status != NO_ERROR )
    {
        goto Done;
    }

    //
    //  write in loopback address
    //

    if ( Family == AF_INET )
    {
        * (PIP4_ADDRESS) addrBuf = DNS_NET_ORDER_LOOPBACK;
        addrSize = sizeof(IP4_ADDRESS);
    }
    else if ( Family == AF_INET6 )
    {
        IP6_SET_ADDR_LOOPBACK( (PIP6_ADDRESS)addrBuf );
        addrSize = sizeof(IN6_ADDR);
    }
    else
    {
        status = DNS_ERROR_INVALID_DATA;
        goto Done;
    }

    status = SaBlob_WriteAddress(
                pblob,
                addrBuf,
                addrSize,
                Family );

    if ( status != NO_ERROR )
    {
        goto Done;
    }

    //
    //  write localhost
    //

    status = SaBlob_WriteNameOrAlias(
                pblob,
                L"localhost",
                FALSE           // name
                );

    IF_DNSDBG( SABLOB )
    {
        DnsDbg_SaBlob(
            "SaBlob after localhost create:",
            pblob );
    }

Done:

    if ( status != NO_ERROR  &&  pblob )
    {
        SaBlob_Free( pblob );
        pblob = NULL;
    }

    SetLastError( status );

    DNSDBG( SABLOB, (
        "Leave SaBlob_Localhost() => status = %d\n",
        status ));

    return( pblob );
}



PSABLOB
SaBlob_CreateFromIpArray(
    IN      INT             AddrFamily,
    IN      INT             AddrSize,
    IN      INT             AddrCount,
    IN      PCHAR           pArray,
    IN      PSTR            pName,
    IN      BOOL            fUnicode
    )
/*++

Routine Description:

    Create sablob from records

Arguments:

    ppBlob -- ptr with or to recv sablob blob

    AddrFamily -- addr family use if PTR records and no addr

    pArray -- array of addresses

    pName -- name for sablob

    fUnicode --
        TRUE if name is and sablob will be in unicode
        FALSE for narrow name and sablob

Return Value:

    Ptr to blob if successful.
    NULL on error;  GetLastError() has error.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    SABLOB_INIT    request;
    PSABLOB   pblob = *ppBlob;

    DNSDBG( SABLOB, (
        "SaBlob_CreateFromIpArray()\n"
        "\tppBlob   = %p\n"
        "\tfamily   = %d\n"
        "\tsize     = %d\n"
        "\tcount    = %d\n"
        "\tpArray   = %p\n",
        ppBlob,
        AddrFamily,
        AddrSize,
        AddrCount,
        pArray ));


    //          
    //  create or reinit sablob blob
    //

    RtlZeroMemory( &request, sizeof(request) );
    
    request.AliasCount  = DNS_MAX_ALIAS_COUNT;
    request.AddrCount   = AddrCount;
    request.AddrFamily  = AddrFamily;
    request.fUnicode    = fUnicode;
    request.pName       = pName;

    status = SaBlob_Create(
                & pblob,
                & request );
    
    if ( status != NO_ERROR )
    {
        goto Done;
    }

    //
    //  write in array
    //

    if ( AddrCount )
    {
        status = SaBlob_WriteAddressArray(
                    pblob,
                    pArray,
                    AddrCount,
                    AddrSize,
                    AddrFamily
                    );
        if ( status != NO_ERROR )
        {
            goto Done;
        }
    }

    //
    //  write name?
    //

    if ( pName )
    {
        status = SaBlob_WriteNameOrAlias(
                    pblob,
                    pName,
                    FALSE,          // name not alias
                    fUnicode
                    );
    }

    IF_DNSDBG( SABLOB )
    {
        DnsDbg_SaBlob(
            "Leaving SaBlob_CreateFromIpArray():",
            pblob );
    }

Done:

    if ( status != NO_ERROR  &&  pblob )
    {
        SaBlob_Free( pblob );
        pblob = NULL;
    }

    *ppBlob = pblob;

    DNSDBG( SABLOB, (
        "Leave SaBlob_CreateFromIpArray() => status = %d\n",
        status ));

    return( status );
}



PSABLOB
SaBlob_CreateLocal(
    IN      INT             AddrFamily,
    IN      BOOL            fLoopback,
    IN      BOOL            fZero,
    IN      BOOL            fHostnameOnly
    )
/*++

Routine Description:

    Create sablob from records

Arguments:

    ppBlob -- ptr with or to recv sablob blob

    AddrFamily -- addr family use if PTR records and no addr

Return Value:

    Ptr to blob if successful.
    NULL on error;  GetLastError() has error.

--*/
{
    DNS_STATUS      status = NO_ERROR;
    PSABLOB         pblob = NULL;
    WORD            wtype;
    INT             size;
    IP6_ADDRESS     ip;


    DNSDBG( SABLOB, (
        "SaBlob_CreateLocal()\n"
        "\tppBlob       = %p\n"
        "\tfamily       = %d\n"
        "\tfLoopback    = %d\n"
        "\tfZero        = %d\n"
        "\tfHostname    = %d\n",
        ppBlob,
        AddrFamily,
        fLoopback,
        fZero,
        fHostnameOnly
        ));

    //
    //  get family info
    //      - start with override IP = 0
    //      - if loopback switch to appropriate loopback
    //

    RtlZeroMemory(
        &ip,
        sizeof(ip) );

    if ( AddrFamily == AF_INET )
    {
        wtype   = DNS_TYPE_A;
        size    = sizeof(IP4_ADDRESS);

        if ( fLoopback )
        {
            * (PIP4_ADDRESS) &ip = DNS_NET_ORDER_LOOPBACK;
        }
    }
    else if ( AddrFamily == AF_INET6 )
    {
        wtype   = DNS_TYPE_AAAA;
        size    = sizeof(IP6_ADDRESS);

        if ( fLoopback )
        {
            IP6_SET_ADDR_LOOPBACK( &ip );
        }
    }
    else
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    //
    //  query for local host info
    //

    pblob = SaBlob_Query(
                NULL,           // NULL name gets local host data
                wtype,
                0,              // standard query
                NULL,           // no message
                AddrFamily );
    if ( !pblob )
    {
        DNS_ASSERT( FALSE );
        status = GetLastError();
        goto Done;
    }

    //
    //  overwrite with specific address
    //

    if ( fLoopback || fZero )
    {
        if ( ! SaBlob_SetToSingleAddress(
                    pblob->pBlob,
                    (PCHAR) &ip,
                    size ) )
        {
            DNS_ASSERT( pblob->AddrCount == 0 );

            pblob->AddrCount = 0;

            status = SaBlob_WriteAddress(
                        pblob,
                        & ip,
                        size,
                        AddrFamily );
            if ( status != NO_ERROR )
            {
                DNS_ASSERT( status!=NO_ERROR );
                goto Done;
            }
        }
    }

    //
    //  for gethostname()
    //      - chop name down to just hostname
    //      - kill off aliases
    //

    if ( fHostnameOnly )
    {
        PWSTR   pname = (PWSTR) pblob->pName;
        PWSTR   pdomain;

        DNS_ASSERT( pname );
        if ( pname )
        {
            pdomain = Dns_GetDomainNameW( pname );
            if ( pdomain )
            {
                DNS_ASSERT( pdomain > pname+1 );
                DNS_ASSERT( *(pdomain-1) == L'.' );

                *(pdomain-1) = 0;
            }
        }                     
        pblob->AliasCount = 0;
    }

    IF_DNSDBG( SABLOB )
    {
        DnsDbg_SaBlob(
            "Leaving SaBlob_CreateLocal():",
            pblob );
    }

Done:

    if ( status != NO_ERROR  &&  pblob )
    {
        SaBlob_Free( pblob );
        pblob = NULL;
    }

    DNSDBG( SABLOB, (
        "Leave SaBlob_CreateLocal() => %p\n"
        "\tstatus = %d\n",
        pblob,
        status ));

    if ( status != NO_ERROR )
    {
        SetLastError( status );
    }

    return( pblob );
}

#endif



PHOSTENT
SaBlob_CreateHostent(
    IN OUT  PBYTE *         ppBuffer,
    IN OUT  PINT            pBufferSize,
    OUT     PINT            pHostentSize,
    IN      PSABLOB         pBlob,
    IN      DNS_CHARSET     CharSetTarget,
    IN      BOOL            fOffsets,
    IN      BOOL            fAlloc
    )
/*++

Routine Description:

    Copy a hostent.

Arguments:

    ppBuffer -- addr with ptr to buffer to write to;
        if no buffer then hostent is allocated
        updated with ptr to position in buffer after hostent

    pBufferSize -- addr containing size of buffer;
        updated with bytes left after hostent written
        (even if out of space, it contains missing number of
        bytes as negative number)

    pHostentSize -- addr to recv total size of hostent written

    pBlob -- sockaddr blob to create hostent for

    CharSetTarget -- charset of target hostent

    fOffsets -- write hostent with offsets

    fAlloc -- allocate copy

Return Value:

    Ptr to new hostent.
    NULL on error.  See GetLastError().

--*/
{
    PBYTE           pch;
    PHOSTENT        phost = NULL;
    DWORD           sizeTotal;
    DWORD           bytesLeft;
    DWORD           i;
    DWORD           size;
    DWORD           family = 0;
    DWORD           aliasCount;
    DWORD           addrCount = 0;
    DWORD           addrLength = 0;
    PCHAR *         pptrArrayOut;
    DWORD           sizeAliasPtrs;
    DWORD           sizeAddrPtrs;
    DWORD           sizeAddrs;
    DWORD           sizeAliasNames = 0;
    DWORD           sizeName = 0;
    PFAMILY_INFO    pfamilyInfo = NULL;
    PDNS_ADDR_ARRAY paddrArray;


    DNSDBG( HOSTENT, (
        "SaBlob_CreateHostent( %p )\n",
        pBlob ));

    //
    //  get family, count info to size hostent
    //

#if 0
    if ( pBlob->Family != 0 )
    {
        pfamilyInfo = FamilyInfo_GetForFamily( pBlob->Family );
    }
#endif

    aliasCount = pBlob->AliasCount;

    paddrArray = pBlob->pAddrArray;
    if ( paddrArray )
    {
        family = paddrArray->AddrArray[0].Sockaddr.sa_family;

        pfamilyInfo = FamilyInfo_GetForFamily( family );
        if ( !pfamilyInfo )
        {
            DNS_ASSERT( FALSE );
        }
        else
        {
            addrCount = paddrArray->AddrCount;
            addrLength = pfamilyInfo->LengthAddr;
        }
    }

    //
    //  size hostent
    //      - struct
    //      - alias and addr ptr arrays (both NULL terminated)
    //      - addresses
    //      - name
    //      - aliases
    //
    //  note:  only aligning strings to WORD (for unicode) as we'll build
    //      them into buffer AFTER the addresses (which require DWORD)
    //      alignment
    //

    sizeAliasPtrs   = (aliasCount+1) * sizeof(PCHAR);
    sizeAddrPtrs    = (addrCount+1) * sizeof(PCHAR);
    sizeAddrs       = addrCount * addrLength;

    if ( pBlob->pName )
    {
        sizeName = Dns_GetBufferLengthForStringCopy(
                            (PCHAR) pBlob->pName,
                            0,
                            DnsCharSetUnicode,
                            CharSetTarget );
        
        sizeName = WORD_ALIGN_DWORD( sizeName );
    }

    for ( i=0; i<aliasCount; i++ )
    {
        sizeAliasNames += Dns_GetBufferLengthForStringCopy(
                            (PCHAR) pBlob->AliasArray[i],
                            0,
                            DnsCharSetUnicode,
                            CharSetTarget );
        
        sizeAliasNames = WORD_ALIGN_DWORD( sizeAliasNames );
    }

    sizeTotal = POINTER_ALIGN_DWORD( sizeof(HOSTENT) ) +
                sizeAliasPtrs +
                sizeAddrPtrs +
                sizeAddrs +
                sizeName +
                sizeAliasNames;

    DNSDBG( HOSTENT, (
        "SaBlob Hostent create:\n"
        "\tsize             = %d\n"
        "\tsizeAliasPtrs    = %d\n"
        "\tsizeAddrPtrs     = %d\n"
        "\tsizeAddrs        = %d\n"
        "\tsizeName         = %d\n"
        "\tsizeAliasNames   = %d\n",
        sizeTotal,
        sizeAliasPtrs,
        sizeAddrPtrs,
        sizeAddrs,
        sizeName,
        sizeAliasNames ));


    //
    //  alloc or reserve size in buffer
    //

    if ( fAlloc )
    {
        pch = ALLOCATE_HEAP( sizeTotal );
        if ( !pch )
        {
            goto Failed;
        }
    }
    else
    {
        pch = FlatBuf_Arg_ReserveAlignPointer(
                    ppBuffer,
                    pBufferSize,
                    sizeTotal
                    );
        if ( !pch )
        {
            goto Failed;
        }
    }

    //
    //  note:  assuming from here on down that we have adequate space
    //
    //  reason we aren't building with FlatBuf routines is that
    //      a) we believe we have adequate space
    //      b) i haven't built FlatBuf string conversion routines
    //      which we need below (for RnR unicode to ANSI)
    //
    //  we could reset buf pointers here and build directly with FlatBuf
    //  routines;  this isn't directly necessary
    //

    //
    //  init hostent struct 
    //

    phost = Hostent_Init(
                & pch,
                family,
                addrLength,
                addrCount,
                aliasCount );

    DNS_ASSERT( pch > (PBYTE)phost );

    //
    //  copy addresses
    //      - no need to align as previous is address
    //

    pptrArrayOut = phost->h_addr_list;

    if ( paddrArray && pfamilyInfo )
    {
        DWORD   offset = pfamilyInfo->OffsetToAddrInSockaddr;

        for ( i=0; i<paddrArray->AddrCount; i++ )
        {
            *pptrArrayOut++ = pch;

            RtlCopyMemory(
                pch,
                ((PBYTE)&paddrArray->AddrArray[i]) + offset,
                addrLength );

            pch += addrLength;
        }
    }
    *pptrArrayOut = NULL;

    //
    //  copy the name
    //

    if ( pBlob->pName )
    {
        pch = WORD_ALIGN( pch );

        phost->h_name = pch;

        size = Dns_StringCopy(
                    pch,
                    NULL,           // buffer is adequate
                    (PCHAR)pBlob->pName,
                    0,              // unknown length
                    DnsCharSetUnicode,
                    CharSetTarget
                    );
        pch += size;
    }

    //
    //  copy the aliases
    //

    pptrArrayOut = phost->h_aliases;

    if ( aliasCount )
    {
        for ( i=0; i<aliasCount; i++ )
        {
            pch = WORD_ALIGN( pch );

            *pptrArrayOut++ = pch;

            size = Dns_StringCopy(
                        pch,
                        NULL,                   // buffer is adequate
                        (PCHAR) pBlob->AliasArray[i],
                        0,                      // unknown length
                        DnsCharSetUnicode,
                        CharSetTarget
                        );
            pch += size;
        }
    }
    *pptrArrayOut = NULL;

    //
    //  copy is complete
    //      - verify our write functions work
    //

    ASSERT( (DWORD)(pch-(PBYTE)phost) <= sizeTotal );

    if ( pHostentSize )
    {
        *pHostentSize = (INT)( pch - (PBYTE)phost );
    }

    if ( !fAlloc )
    {
        PBYTE   pnext = *ppBuffer;

        //  if we sized too small --
        //  fix up the buf pointer and bytes left

        if ( pnext < pch )
        {
            ASSERT( FALSE );
            *ppBuffer = pch;
            *pBufferSize -= (INT)(pch - pnext);
        }
    }

    IF_DNSDBG( HOSTENT )
    {
        DnsDbg_Hostent(
            "Sablob Hostent:",
            phost,
            (CharSetTarget == DnsCharSetUnicode) );
    }

    //
    //  convert to offsets?
    //

    if ( fOffsets )
    {
        Hostent_ConvertToOffsets( phost );
    }


Failed:

    DNSDBG( TRACE, (
        "Leave SaBlob_CreateHostent() => %p\n",
        phost ));

    return  phost;
}

//
//  End sablob.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\string.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    string.c

Abstract:

    Domain Name System (DNS) Library

    DNS string routines.

Author:

    Jim Gilroy (jamesg)     October 1995

Revision History:

    jamesg  Jan 1997    UTF-8, Unicode conversions

--*/


#include "local.h"



PSTR
Dns_CreateStringCopy(
    IN      PCHAR           pchString,
    IN      DWORD           cchString
    )
/*++

Routine Description:

    Create copy of string.

Arguments:

    pchString -- ptr to string to copy

    cchString -- length of string, if unknown;  if NOT given, then pchString
                    MUST be NULL terminated

Return Value:

    Ptr to string copy, if successful
    NULL on failure.

--*/
{
    LPSTR   pstringNew;

    DNSDBG( TRACE, ( "Dns_CreateStringCopy()\n" ));

    if ( !pchString )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
    }

    //  determine string length, if not given

    if ( !cchString )
    {
        cchString = strlen( pchString );
    }

    //  allocate memory

    pstringNew = (LPSTR) ALLOCATE_HEAP( cchString+1 );
    if ( !pstringNew )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    //  copy and NULL terminate

    RtlCopyMemory(
        pstringNew,
        pchString,
        cchString );

    pstringNew[cchString] = 0;

    return( pstringNew );
}



DWORD
Dns_GetBufferLengthForStringCopy(
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Determing length required for copy of string.

Arguments:

    pchString -- ptr to string to get buffer length for

    cchString -- length of string, if known;
        - if CharSetIn is unicode, then this is length in wide characters
        - if NOT given, then pchString MUST be NULL terminated

    CharSetIn -- incoming character set

    CharSetOut -- result character set

Return Value:

    Buffer length (bytes) required for string, includes space for terminating NULL.
    Zero on invalid\unconvertible string.  GetLastError() set to ERROR_INVALID_DATA.

--*/
{
    INT     length;

    DNSDBG( TRACE, ( "Dns_GetBufferLengthForStringCopy()\n" ));

    if ( !pchString )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( 0 );
    }

    //
    //  incoming Unicode
    //

    if ( CharSetIn == DnsCharSetUnicode )
    {
        if ( !cchString )
        {
            cchString = (WORD) wcslen( (PWCHAR)pchString );
        }

        //  unicode to unicode

        if ( CharSetOut == DnsCharSetUnicode )
        {
            return( (cchString+1) * 2 );
        }

        //  unicode to UTF8
        //
        //  use private unicode\utf8 conversion functions
        //      - superior to public ones (faster, more robust)
        //      - Win95 does not support CP_UTF8
        //
        //  for unicode-UTF8 there's no invalid string possible

        else if ( CharSetOut == DnsCharSetUtf8 )
        {
#if 0
            length = WideCharToMultiByte(
                        CP_UTF8,
                        0,          // no flags
                        (PWCHAR) pchString,
                        (INT) cchString,
                        NULL,
                        0,          // call determines required buffer length
                        NULL,
                        NULL );
#endif
            length = Dns_UnicodeToUtf8(
                         (PWCHAR) pchString,
                         (INT) cchString,
                         NULL,
                         0
                         );
            ASSERT( length != 0 || cchString == 0 );
            return( length + 1 );
        }

        //  unicode to ANSI
        //      - some chars will NOT convert

        else if ( CharSetOut == DnsCharSetAnsi )
        {
            length = WideCharToMultiByte(
                        CP_ACP,
                        0,          // no flags
                        (PWCHAR) pchString,
                        (INT) cchString,
                        NULL,
                        0,          // call determines required buffer length
                        NULL,
                        NULL
                        );
            if ( length == 0 && cchString != 0 )
            {
                goto Failed;
            }
            return( length + 1 );
        }

        //  bad CharSetOut drops to Failed
    }

    //
    //  incoming UTF8
    //

    else if ( CharSetIn == DnsCharSetUtf8 )
    {
        if ( !cchString )
        {
            cchString = strlen( pchString );
        }

        //  UTF8 to UTF8

        if ( CharSetOut == DnsCharSetUtf8 )
        {
            return( cchString + 1 );
        }

        //  UTF8 to unicode
        //
        //  use private unicode\utf8 conversion functions
        //      - superior to public ones (faster, more robust)
        //      - Win95 does not support CP_UTF8
        //
        //  for UTF8 string can be invalid, catch and return error

        else if ( CharSetOut == DnsCharSetUnicode )
        {
#if 0
            length = MultiByteToWideChar(
                        CP_UTF8,
                        0,          // no flags
                        pchString,
                        (INT) cchString,
                        NULL,
                        0           // call determines required buffer length
                        );
#endif
            length = Dns_Utf8ToUnicode(
                         pchString,
                         (INT) cchString,
                         NULL,
                         0
                         );
            if ( length == 0 && cchString != 0 )
            {
                ASSERT( GetLastError() == ERROR_INVALID_DATA );
                return( 0 );
            }
            return( (length+1)*2 );
        }

        //  UTF8 to ANSI
        //      - note, result length here is actually buffer length

        else if ( CharSetOut == DnsCharSetAnsi )
        {
            return Dns_Utf8ToAnsi(
                        pchString,
                        cchString,
                        NULL,
                        0 );
        }

        //  bad CharSetOut drops to Failed
    }

    //
    //  incoming ANSI
    //

    else if ( CharSetIn == DnsCharSetAnsi )
    {
        if ( !cchString )
        {
            cchString = strlen( pchString );
        }

        //  ANSI to ANSI

        if ( CharSetOut == DnsCharSetAnsi )
        {
            return( cchString + 1 );
        }

        //  ANSI to unicode
        //      - should always succeed

        else if ( CharSetOut == DnsCharSetUnicode )
        {
            length = MultiByteToWideChar(
                        CP_ACP,
                        0,          // no flags
                        pchString,
                        (INT) cchString,
                        NULL,
                        0           // call determines required buffer length
                        );
            if ( length == 0 && cchString )
            {
                ASSERT( FALSE );
                ASSERT( GetLastError() == ERROR_INVALID_DATA );
                goto Failed;
            }
            return( (length+1) * 2 );
        }

        //  ANSI to UTF8
        //      - note, result length here is actually buffer length

        else if ( CharSetOut == DnsCharSetUtf8 )
        {
            return Dns_AnsiToUtf8(
                        pchString,
                        cchString,
                        NULL,
                        0 );
        }

        //  bad CharSetOut drops to Failed
    }

    //  all unhandled cases are failures

Failed:

    DNSDBG( ANY, (
        "ERROR:  Dns_GetBufferLengthForStringCopy() failed!\n"
        "\tpchString    = %p (%*s)\n"
        "\tcchString    = %d\n"
        "\tCharSetIn    = %d\n"
        "\tCharSetOut   = %d\n",
        pchString,
        cchString, pchString,
        cchString,
        CharSetIn,
        CharSetOut ));

    SetLastError( ERROR_INVALID_DATA );
    return( 0 );
}



DWORD
Dns_StringCopy(
    OUT     PBYTE           pBuffer,
    IN OUT  PDWORD          pdwBufLength,
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Create copy of DNS string.

Arguments:

    pBuffer -- buffer to copy to

    pdwBufLength -- ptr to length of buffer in bytes;
        if NULL, buffer MUST have adequate length
        if exists, then copy only completed if *pdwBufLength is adequate
            to hold converted result

    pchString -- ptr to string to copy

    cchString -- length of string, if known;
        - if CharSetIn is unicode, then this is length in wide characters
        - if NOT given, then pchString MUST be NULL terminated

    CharSetIn -- incoming character set

    CharSetOut -- result character set

Return Value:

    Count of bytes written to buffer (includes terminating NULL).
    Zero on error.  GetLastError() for status.

--*/
{
    INT     length;
    DWORD   bufLength;

    DNSDBG( TRACE, ( "Dns_StringCopy()\n" ));
    DNSDBG( STRING, (
        "Dns_StringCopy()\n"
        "\tpBuffer      = %p\n"
        "\tpdwBufLen    = %p\n"
        "\tbuf length   = %d\n"
        "\tpchString    = %p\n"
        "\tcchString    = %d\n"
        "\tCharSetIn    = %d\n"
        "\tCharSetOut   = %d\n",
        pBuffer,
        pdwBufLength,
        pdwBufLength ? *pdwBufLength : 0,
        pchString,
        cchString,
        CharSetIn,
        CharSetOut ));

    if ( !pchString )
    {
        DNS_ASSERT( FALSE );
        SetLastError( ERROR_INVALID_PARAMETER );
        return( 0 );
    }

    //
    //  find string length
    //  do this here so don't do it twice if must calculate required buffer length
    //

    if ( cchString == 0 )
    {
        if ( CharSetIn == DnsCharSetUnicode )
        {
            cchString = (WORD) wcslen( (PWCHAR)pchString );
        }
        else
        {
            cchString = strlen( pchString );
        }
    }

    //
    //  verify adequate buffer length
    //
    //  DCR_PERF:  ideally make direct copy to buffer and fail if
    //      over length, rather than effectively having to convert
    //      twice
    //

    if ( pdwBufLength )
    {
        bufLength = Dns_GetBufferLengthForStringCopy(
                        pchString,
                        cchString,
                        CharSetIn,
                        CharSetOut );

        if ( bufLength == 0 )
        {
            SetLastError( ERROR_INVALID_DATA );
            *pdwBufLength = 0;
            return( 0 );
        }
        if ( bufLength > *pdwBufLength )
        {
            SetLastError( ERROR_MORE_DATA );
            *pdwBufLength = bufLength;
            return( 0 );
        }

        *pdwBufLength = bufLength;
    }

    //
    //  incoming unicode string
    //

    if ( CharSetIn == DnsCharSetUnicode )
    {
        //  unicode to unicode straight copy
        //      - correct for length in wide characters

        if ( CharSetOut == DnsCharSetUnicode )
        {
            ((PWORD)pBuffer)[ cchString ] = 0;
            cchString *= 2;
            RtlCopyMemory(
                pBuffer,
                pchString,
                cchString );

            return( cchString+2 );
        }

        //  unicode => UTF8
        //
        //  use private unicode\utf8 conversion functions
        //      - superior to public ones (faster, more robust)
        //      - Win95 does not support CP_UTF8
        //
        //  for unicode-UTF8 there's no invalid string possible

        else if ( CharSetOut == DnsCharSetUtf8 )
        {
#if 0
            length = WideCharToMultiByte(
                        CP_UTF8,
                        0,              // no flags
                        (PWCHAR) pchString,
                        (INT) cchString,
                        pBuffer,
                        MAXWORD,        // assuming adequate length
                        NULL,
                        NULL );
#endif
            length = Dns_UnicodeToUtf8(
                        (LPWSTR) pchString,
                        cchString,
                        pBuffer,
                        MAXWORD        // assuming adequate length
                        );
            ASSERT( length != 0 || cchString == 0 );

            pBuffer[ length ] = 0;
            return( length + 1 );
        }

        //  unicode => ANSI
        //      - this conversion can fail

        else if ( CharSetOut == DnsCharSetAnsi )
        {
            length = WideCharToMultiByte(
                        CP_ACP,
                        0,              // no flags
                        (PWCHAR) pchString,
                        (INT) cchString,
                        pBuffer,
                        MAXWORD,        // assuming adequate length
                        NULL,
                        NULL );

            if ( length == 0 && cchString != 0 )
            {
                goto Failed;
            }
            pBuffer[ length ] = 0;
            return( length + 1 );
        }

        //  bad CharSetOut drops to Failed
    }

    //
    //  incoming UTF8
    //

    if ( CharSetIn == DnsCharSetUtf8 )
    {
        //  UTF8 to UTF8 straight copy

        if ( CharSetOut == DnsCharSetUtf8 )
        {
            memcpy(
                pBuffer,
                pchString,
                cchString );

            pBuffer[cchString] = 0;
            return( cchString + 1 );
        }

        //  UTF8 to unicode conversion
        //
        //  use private unicode\utf8 conversion functions
        //      - superior to public ones (faster, more robust)
        //      - Win95 does not support CP_UTF8
        //
        //  UTF8 strings can be invalid, and since sending in "infinite"
        //      buffer, this is only possible error

        else if ( CharSetOut == DnsCharSetUnicode )
        {
#if 0
            length = MultiByteToWideChar(
                        CP_UTF8,
                        0,                  // no flags
                        (PCHAR) pchString,
                        (INT) cchString,
                        (PWCHAR) pBuffer,
                        MAXWORD             // assuming adequate length
                        );
#endif
            length = Dns_Utf8ToUnicode(
                        pchString,
                        cchString,
                        (LPWSTR) pBuffer,
                        MAXWORD
                        );
            if ( length == 0 && cchString != 0 )
            {
                ASSERT( GetLastError() == ERROR_INVALID_DATA );
                goto Failed;
            }
            ((PWORD)pBuffer)[length] = 0;
            return( (length+1) * 2 );
        }

        //  UTF8 to ANSI
        //      - note, result length here is actually buffer length

        else if ( CharSetOut == DnsCharSetAnsi )
        {
            length = Dns_Utf8ToAnsi(
                        pchString,
                        cchString,
                        pBuffer,
                        MAXWORD );
            if ( length == 0 )
            {
                goto Failed;
            }
            return( length );
        }

        //  bad CharSetOut drops to Failed
    }

    //
    //  incoming ANSI
    //

    if ( CharSetIn == DnsCharSetAnsi )
    {
        //  ANSI to ANSI straight copy

        if ( CharSetOut == DnsCharSetAnsi )
        {
            memcpy(
                pBuffer,
                pchString,
                cchString );

            pBuffer[cchString] = 0;
            return( cchString + 1 );
        }

        //  ANSI to unicode conversion
        //      - ANSI to unicode should not fail

        else if ( CharSetOut == DnsCharSetUnicode )
        {
            length = MultiByteToWideChar(
                        CP_ACP,
                        0,                  // no flags
                        (PCHAR) pchString,
                        (INT) cchString,
                        (PWCHAR) pBuffer,
                        MAXWORD             // assuming adequate length
                        );
            if ( length == 0 && cchString )
            {
                ASSERT( FALSE );
                ASSERT( GetLastError() == ERROR_INVALID_DATA );
                goto Failed;
            }
            ((PWORD)pBuffer)[length] = 0;
            return( (length+1) * 2 );
        }

        //  ANSI to UTF8
        //      - note, result length here is actually buffer length

        else if ( CharSetOut == DnsCharSetUtf8 )
        {
            length = Dns_AnsiToUtf8(
                        pchString,
                        cchString,
                        pBuffer,
                        MAXWORD );
            if ( length == 0 )
            {
                goto Failed;
            }
            return( length );
        }

        //  bad CharSetOut drops to Failed
    }

    //  all unhandled cases are failures

Failed:

    DNSDBG( ANY, (
        "ERROR:  Dns_StringCopy() failed!\n"
        "\tpBuffer      = %p\n"
        "\tpdwBufLen    = %p\n"
        "\tbuf length   = %d\n"
        "\tpchString    = %p (%*s)\n"
        "\tcchString    = %d\n"
        "\tCharSetIn    = %d\n"
        "\tCharSetOut   = %d\n",
        pBuffer,
        pdwBufLength,
        pdwBufLength ? *pdwBufLength : 0,
        pchString,
        cchString, pchString,
        cchString,
        CharSetIn,
        CharSetOut ));

    SetLastError( ERROR_INVALID_DATA );
    return( 0 );
}



PVOID
Dns_StringCopyAllocate(
    IN      PCHAR           pchString,
    IN      DWORD           cchString,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Create copy of DNS string

Arguments:

    pchString -- ptr to string to copy

    cchString -- length of string, if known;
        - if CharSetIn, then this is length in wide characters
        - if NOT given, then pchString MUST be NULL terminated

    CharSetIn -- flag indicates incoming string is unicode

    CharSetOut -- flag indicates copy will be in unicode format

Return Value:

    Ptr to string copy, if successful
    NULL on failure.

--*/
{
    PCHAR   pnew;
    DWORD   length;

    DNSDBG( TRACE, ( "Dns_StringCopyAllocate()\n" ));
    DNSDBG( STRING, (
        "Dns_StringCopyAllocate( %.*s )\n"
        "\tpchString    = %p\n"
        "\tcchString    = %d\n"
        "\tUnicodeIn    = %d\n"
        "\tUnicodeOut   = %d\n",
        cchString,
        pchString,
        pchString,
        cchString,
        CharSetIn,
        CharSetOut ));

    if ( !pchString )
    {
        //  For parity with other string routines, do not treat NULL argument
        //  as an event worth of assert.
        //  DNS_ASSERT( FALSE );
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
    }

    //
    //  determine incoming string length
    //  do this explicitly to avoid doing string length operations twice
    //

    if ( !cchString )
    {
        if ( CharSetIn == DnsCharSetUnicode )
        {
            cchString = (WORD) wcslen( (PWCHAR)pchString );
        }
        else
        {
            cchString = strlen( pchString );
        }
    }

    //
    //  determine required buffer length and allocate
    //

    length = Dns_GetBufferLengthForStringCopy(
                pchString,
                cchString,
                CharSetIn,
                CharSetOut );
    if ( length == 0 )
    {
        ASSERT( CharSetIn && CharSetOut && GetLastError() == ERROR_INVALID_DATA );
        SetLastError( ERROR_INVALID_DATA );
        return( NULL );
    }
    pnew = (PVOID) ALLOCATE_HEAP( length );
    if ( !pnew )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    //
    //  copy \ convert string
    //      - can fail if conversion not valid
    //      (ex. bogus UTF8 string, or attempting
    //      conversion from ANSI to UTF8)
    //

    if ( ! Dns_StringCopy(
                pnew,
                NULL,
                pchString,
                cchString,
                CharSetIn,
                CharSetOut ) )
    {
        FREE_HEAP( pnew );
        return( NULL );
    }

    return( pnew );
}



//
//  Simple create string copy utilities.
//

PSTR
Dns_CreateStringCopy_A(
    IN      PCSTR           pszString
    )
/*++

Routine Description:

    Create copy of string.

    Simple wrapper to handle
        - sizing
        - memory allocation
        - copy of string

Arguments:

    pszString -- ptr to string to copy

Return Value:

    Ptr to string copy, if successful
    NULL on failure.

--*/
{
    PSTR    pnew;
    DWORD   length;

    DNSDBG( TRACE, ( "Dns_CreateStringCopy_A( %s )\n", pszString ));

    if ( !pszString )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
    }

    //  determine string length, if not given

    length = strlen( pszString ) + 1;

    //  allocate memory

    pnew = (LPSTR) ALLOCATE_HEAP( length );
    if ( !pnew )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    //  copy and NULL terminate

    RtlCopyMemory(
        pnew,
        pszString,
        length );

    return( pnew );
}



PWSTR
Dns_CreateStringCopy_W(
    IN      PCWSTR          pwsString
    )
{
    PWSTR   pnew;
    DWORD   length;

    DNSDBG( TRACE, ( "Dns_CreateStringCopy_W( %S )\n", pwsString ));

    if ( !pwsString )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
    }

    //  allocate memory

    length = (wcslen( pwsString ) + 1) * sizeof(WCHAR);

    pnew = (PWSTR) ALLOCATE_HEAP( length );
    if ( !pnew )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    //  copy and NULL terminate

    RtlCopyMemory(
        pnew,
        pwsString,
        length );

    return( pnew );
}



PWSTR
Dns_CreateConcatenatedString_W(
    IN      PCWSTR *        pStringArray
    )
/*++

Routine Description:

    Create concatenated string.

Arguments:

    pStringArray -- array of string pointers to concat
        NULL pointer terminates array

Return Value:

    Ptr to concantenated string copy, if successful
    NULL on failure.

--*/
{
    PWSTR   pnew;
    PCWSTR  pwstr;
    DWORD   length;
    DWORD   iter;


    DNSDBG( TRACE, ( "Dns_CreateConcatenatedString_W()\n" ));

    if ( !pStringArray )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
    }

    //
    //  loop determining required length
    //

    length = 1;
    iter = 0;

    while ( pwstr = pStringArray[iter++] )
    {
        length += wcslen( pwstr );
    }

    //
    //  allocate
    //

    pnew = (PWSTR) ALLOCATE_HEAP( length*sizeof(WCHAR) );
    if ( !pnew )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return  NULL;
    }

    //
    //  write concatented string
    //

    pnew[0] = 0;
    iter = 0;

    while ( pwstr = pStringArray[iter++] )
    {
        wcscat( pnew, pwstr );
    }

    DNSDBG( TRACE, ( "Concatented string = %S\n", pnew ));
    return  pnew;
}



//
//  MULTI_SZ routines
//

DWORD
MultiSz_Size_A(
    IN      PCSTR           pmszString
    )
/*++

Routine Description:

    Determine length (size) of MULTI_SZ string.

Arguments:

    pmszString -- ptr to string to size

Return Value:

    Size of MULTI_SZ string (in bytes).
    Includes terminating double NULL.

--*/
{
    PSTR    pnext;
    DWORD   lengthTotal = 0;
    DWORD   length;

    DNSDBG( TRACE, ( "MultiSz_Size_A( %s )\n", pmszString ));

    //
    //  loop until read at end of strings
    //
    //  when we reach the end, we'll be pointing at the second
    //  zero in the double null terminator;  strlen() will return
    //  zero, and we'll add that to our count as 1 and exit
    //

    pnext = (PSTR) pmszString;

    while ( pnext )
    {
        length = strlen( pnext ) + 1;
        lengthTotal += length;

        if ( length == 1 )
        {
            break;
        }
        pnext += length;
    }

    return  lengthTotal;
}



PSTR
MultiSz_NextString_A(
    IN      PCSTR           pmszString
    )
/*++

Routine Description:

    Find next string in MULTI_SZ string

Arguments:

    pmszString -- ptr to multi string

Return Value:

    Next string in MULTI_SZ string.
    NULL if no strings left.

--*/
{
    PSTR    pnext;
    DWORD   length;

    DNSDBG( TRACE, ( "MultiSz_NextString_A( %s )\n", pmszString ));

    //
    //  find next string in multi-string
    //      - find length of current string
    //      - hop over it (inc. null)
    //      - if pointing at terminating double-null return
    //          NULL to signal end
    //

    pnext = (PSTR) pmszString;
    if ( !pnext )
    {
        return  NULL;
    }

    length = strlen( pnext );
    if ( length == 0 )
    {
        DNSDBG( ANY, (
            "ERROR:  MultiSz_Next(%p) called on terminator!\n",
            pmszString ));
        return  NULL;
    }

    pnext += length + 1;
    if ( *pnext == 0 )
    {
        return  NULL;
    }

    return  pnext;
}



PSTR
MultiSz_Copy_A(
    IN      PCSTR           pmszString
    )
/*++

Routine Description:

    Create copy of MULTI_SZ string.

    Simple wrapper to handle
        - sizing
        - memory allocation
        - copy of string

Arguments:

    pmszString -- ptr to string to copy

Return Value:

    Ptr to string copy, if successful
    NULL on failure.

--*/
{
    PSTR    pnew;
    DWORD   length;

    DNSDBG( TRACE, ( "MultiSz_Copy_A( %s )\n", pmszString ));

    if ( !pmszString )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
    }

    //  determine string length, if not given

    length = MultiSz_Size_A( pmszString );

    //  allocate memory

    pnew = (LPSTR) ALLOCATE_HEAP( length );
    if ( !pnew )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    //  copy and NULL terminate

    RtlCopyMemory(
        pnew,
        pmszString,
        length );

    return( pnew );
}



BOOL
MultiSz_Equal_A(
    IN      PCSTR           pmszString1,
    IN      PCSTR           pmszString2
    )
/*++

Routine Description:

    Compare two MULTI_SZ strings.

Arguments:

    pmszString1 -- ptr to string

    pmszString2 -- ptr to string

Return Value:

    TRUE -- if strings equal
    FALSE -- if strings different

--*/
{
    DWORD   length1;
    DWORD   length2;

    DNSDBG( TRACE, (
        "MultiSz_Equal_A( %s, %s )\n",
        pmszString1,
        pmszString2
        ));

    //
    //  non-existence cases
    //

    if ( !pmszString1 )
    {
        return !pmszString2;      
    }
    if ( !pmszString2 )
    {
        return !pmszString1;      
    }

    //
    //  length check
    //

    length1 = MultiSz_Size_A( pmszString1 );
    length2 = MultiSz_Size_A( pmszString2 );

    if ( length1 != length2 )
    {
        return  FALSE;
    }

    //
    //  memory check
    //

    return  RtlEqualMemory(
                pmszString1,
                pmszString2,
                length1 );
}



//
//  MULTI_SZ routines -- in wide char
//

DWORD
MultiSz_Size_W(
    IN      PCWSTR          pmszString
    )
/*++

Routine Description:

    Determine size of MULTI_SZ string.

Arguments:

    pmszString -- ptr to string to size

Return Value:

    Size of MULTI_SZ string (in bytes).
    Includes terminating double NULL.

--*/
{
    PWSTR   pnext;
    DWORD   lengthTotal = 0;
    DWORD   length;

    DNSDBG( TRACE, ( "MultiSz_Size_W( %S )\n", pmszString ));

    //
    //  loop until read at end of strings
    //
    //  when we reach the end, we'll be pointing at the second
    //  zero in the double null terminator;  strlen() will return
    //  zero, and we'll add that to our count as 1 and exit
    //

    pnext = (PWSTR) pmszString;

    while ( pnext )
    {
        length = wcslen( pnext ) + 1;
        lengthTotal += length;

        if ( length == 1 )
        {
            break;
        }
        pnext += length;
    }

    return  lengthTotal * sizeof(WCHAR);
}



PWSTR
MultiSz_NextString_W(
    IN      PCWSTR          pmszString
    )
/*++

Routine Description:

    Find next string in MULTI_SZ string

Arguments:

    pmszString -- ptr to multi string

Return Value:

    Next string in MULTI_SZ string.
    NULL if no strings left.

--*/
{
    PWSTR   pnext;
    DWORD   length;

    DNSDBG( TRACE, ( "MultiSz_NextString_W( %S )\n", pmszString ));

    //
    //  find next string in multi-string
    //      - find length of current string
    //      - hop over it (inc. null)
    //      - if pointing at terminating double-null return
    //          NULL to signal end
    //

    pnext = (PWSTR) pmszString;
    if ( !pnext )
    {
        return  NULL;
    }

    length = wcslen( pnext );
    if ( length == 0 )
    {
        DNSDBG( ANY, (
            "ERROR:  MultiSz_Next(%p) called on terminator!\n",
            pmszString ));
        return  NULL;
    }

    pnext += length + 1;
    if ( *pnext == 0 )
    {
        return  NULL;
    }

    return  pnext;
}



PWSTR
MultiSz_Copy_W(
    IN      PCWSTR          pmszString
    )
/*++

Routine Description:

    Create copy of MULTI_SZ string.

    Simple wrapper to handle
        - sizing
        - memory allocation
        - copy of string

Arguments:

    pmszString -- ptr to string to copy

Return Value:

    Ptr to string copy, if successful
    NULL on failure.

--*/
{
    PWSTR   pnew;
    DWORD   length;

    DNSDBG( TRACE, ( "MultiSz_Copy_W( %S )\n", pmszString ));

    if ( !pmszString )
    {
        SetLastError( ERROR_INVALID_PARAMETER );
        return( NULL );
    }

    //  determine string length, if not given

    length = MultiSz_Size_W( pmszString );

    //  allocate memory

    pnew = (PWSTR) ALLOCATE_HEAP( length );
    if ( !pnew )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return( NULL );
    }

    //  copy and NULL terminate

    RtlCopyMemory(
        pnew,
        pmszString,
        length );

    return( pnew );
}



BOOL
MultiSz_Equal_W(
    IN      PCWSTR          pmszString1,
    IN      PCWSTR          pmszString2
    )
/*++

Routine Description:

    Compare two MULTI_SZ strings.

Arguments:

    pmszString1 -- ptr to string

    pmszString2 -- ptr to string

Return Value:

    TRUE -- if strings equal
    FALSE -- if strings different

--*/
{
    DWORD   length1;
    DWORD   length2;

    DNSDBG( TRACE, (
        "MultiSz_Equal_W( %s, %s )\n",
        pmszString1,
        pmszString2
        ));

    //
    //  non-existence cases
    //

    if ( !pmszString1 )
    {
        return !pmszString2;      
    }
    if ( !pmszString2 )
    {
        return !pmszString1;      
    }

    //
    //  length check
    //

    length1 = MultiSz_Size_W( pmszString1 );
    length2 = MultiSz_Size_W( pmszString2 );

    if ( length1 != length2 )
    {
        return  FALSE;
    }

    //
    //  memory check
    //

    return  RtlEqualMemory(
                pmszString1,
                pmszString2,
                length1 );
}



BOOL
MultiSz_ContainsName_W(
    IN      PCWSTR          pmszString,
    IN      PCWSTR          pString
    )
/*++

Routine Description:

    Check if MULTISZ string contains a string.

Arguments:

    pmszString -- multisz string

    pString -- string to check

Return Value:

    TRUE if string is in multisz.
    FALSE otherwise.

--*/
{
    PCWSTR  pstr = pmszString;

    //
    //  check each string
    //

    while ( pstr )
    {
        if ( Dns_NameCompare_W(
                pstr,
                pString ) )
        {
            return  TRUE;
        }
        pstr = MultiSz_NextString_W( pstr );
    }

    return  FALSE;
}



//
//  Random
//

INT
wcsicmp_ThatWorks(
    IN      PWSTR           pString1,
    IN      PWSTR           pString2
    )
/*++

Routine Description:

    A version of wcsicmp that actually works.

    This is just a wrapped on CompareStringW, to hide all the detail
    and give an interface identical to wcsicmp().

    It uses US English to standardize the comparison.

Arguments:

    pString1 -- first string;  must be NULL terminated

    pString2 -- first second;  must be NULL terminated

Return Value:

    -1  -- if string 1 less than string 2
    0   -- strings are equal
    1   -- if string 1 greater than string 2

--*/
{
    INT result;

    //
    //  compare
    //      - case conversion done in default DNS locale -- US English
    //      this locale correctly matches most non-locale sensitive
    //      upper-lower characters
    //

    result = CompareStringW(
                DNS_DEFAULT_LOCALE,
                NORM_IGNORECASE,
                pString1,
                (-1),       // NULL terminated
                pString2,
                (-1)        // NULL terminated
                );

    if ( result == CSTR_EQUAL )
    {
        result = 0;
    }
    else if ( result == CSTR_LESS_THAN )
    {
        result = -1;
    }
    else  // greater than or error
    {
        result = 1;
    }

    return( result );
}



LPWSTR
Dns_GetResourceString(
    IN      DWORD           dwStringId,
    IN OUT  LPWSTR          pwszBuffer,
    IN      DWORD           cbBuffer
    )
/*++

Routine Description:

    Loads a string (defined in dnsmsg.mc) from current module

Arguments:

    dwStringId -- The ID of the string to be fetched

Return Value:

    DCR:  kill off eyal function
    DEVNOTE:  don't understand the value of this return
        -- it's essentially a BOOL, we already know what the ptr is
            it's the buffer passed in
        -- ptr to next byte is useful in continuous write situation
            (ugly and useless in others)
        -- better would just be the same return as LoadString, so we
             both get the success\failure indication and also know
             how many bytes forward we must push our buffer ptr if
             we want to write more

    Error: NULL
    Success: a pointer to the loaded string

--*/
{
    LPWSTR  pStr = NULL;
    DWORD   status;
    HANDLE  hMod;

    DNSDBG( TRACE, (
        "Dns_GetStringResource()\n" ));

    // Get module handle-- No need to close handle, it is just a ptr w/o increment on ref count.
    hMod = GetModuleHandle( NULL );
    if ( !hMod )
    {
        ASSERT( hMod );
        return NULL;
    }

    status = LoadStringW(
                 hMod,
                 dwStringId,
                 pwszBuffer,
                 cbBuffer );

    if ( status != 0 )
    {
        pStr = pwszBuffer;
    }
    ELSE
    {
        // LoadString returns # of bytes loaded, convert to error.
        status = GetLastError();
        DNSDBG( TRACE, (
            "Error <%lu>: Failed to load string %d\n",
            status, dwStringId ));
        ASSERT ( FALSE );
    }

    DNSDBG( TRACE, (
        "Exit <0x%p> Dns_GetStringResource\n",
        pStr ));

    return pStr;
}



DWORD
String_ReplaceCharW(
    IN OUT  PWSTR           pString,
    IN      WCHAR           TargetChar,
    IN      WCHAR           ReplaceChar
    )
/*++

Routine Description:

    Replace a characater in the string with another character.

Arguments:

    pString -- string

    TargetChar -- character to replace

    ReplaceChar -- character that replaces TargetChar

Return Value:

    Count of replacements.

--*/
{
    PWCHAR  pch;
    WCHAR   ch;
    DWORD   countReplace= 0;

    //
    //  loop matching and replacing TargetChar
    //

    pch = pString - 1;

    while ( ch = *++pch )
    {
        if ( ch == TargetChar )
        {
            *pch = ReplaceChar;
            countReplace++;
        }
    }

    return  countReplace;
}



DWORD
String_ReplaceCharA(
    IN OUT  PSTR            pString,
    IN      CHAR            TargetChar,
    IN      CHAR            ReplaceChar
    )
/*++

Routine Description:

    Replace a characater in the string with another character.

Arguments:

    pString -- string

    TargetChar -- character to replace

    ReplaceChar -- character that replaces TargetChar

Return Value:

    Count of replacements.

--*/
{
    PCHAR   pch;
    CHAR    ch;
    DWORD   countReplace= 0;

    //
    //  loop matching and replacing TargetChar
    //

    pch = pString - 1;

    while ( ch = *++pch )
    {
        if ( ch == TargetChar )
        {
            *pch = ReplaceChar;
            countReplace++;
        }
    }

    return  countReplace;
}



DWORD
Dns_TokenizeStringA(
    IN OUT  PSTR            pBuffer,
    OUT     PCHAR *         Argv,
    IN      DWORD           MaxArgs
    )
/*++

Routine Description:

    Tokenize buffer Argv/Argc form.

Arguments:

    pBuffer -- string buffer to tokenize

    Argv -- argv array

    MaxArgs -- max size of Argv array

Return Value:

    Response code corresponding to status, if found.
    Zero otherwise.

--*/
{
    DWORD   count = 0;
    PCHAR   pstring = pBuffer;

    //
    //  tokenize string
    //      - note that after the first call strtok
    //      takes NULL ptr to continue tokening same string
    //

    while ( count < MaxArgs )
    {
        PCHAR   pch;

        pch = strtok( pstring, " \t\r\n" );
        if ( !pch )
        {
            break;
        }
        Argv[ count++ ] = pch;
        pstring = NULL;
    }

    return  count;
}
                                    


DWORD
Dns_TokenizeStringW(
    IN OUT  PWSTR           pBuffer,
    OUT     PWCHAR *        Argv,
    IN      DWORD           MaxArgs
    )
/*++

Routine Description:

    Tokenize buffer Argv/Argc form.

Arguments:

    pBuffer -- string buffer to tokenize

    Argv -- argv array

    MaxArgs -- max size of Argv array

Return Value:

    Response code corresponding to status, if found.
    Zero otherwise.

--*/
{
    DWORD   count = 0;
    PWCHAR  pstring = pBuffer;

    //
    //  tokenize string
    //      - note that after the first call strtok
    //      takes NULL ptr to continue tokening same string
    //

    while ( count < MaxArgs )
    {
        PWCHAR   pch;

        pch = wcstok( pstring, L" \t\r\n" );
        if ( !pch )
        {
            break;
        }
        Argv[ count++ ] = pch;
        pstring = NULL;
    }

    return  count;
}



PSTR *
Argv_CopyEx(
    IN      DWORD           Argc,
    IN      PCHAR *         Argv,
    IN      DNS_CHARSET     CharSetIn,
    IN      DNS_CHARSET     CharSetOut
    )
/*++

Routine Description:

    Convert reate ANSI argv from unicode argv.

Arguments:

    Argc -- argc

    Argv -- argv array

    CharSetIn -- char set of existing Argv

    CharSetOut -- char set of desired argv copy

Return Value:

    Ptr to argv.  User can cast appropriately.

--*/
{
    PCHAR *     argvCopy;

    //
    //  allocate Argv
    //

    argvCopy = (PCHAR *) ALLOCATE_HEAP( (Argc+1) * sizeof(PCHAR) );
    if ( !argvCopy )
    {
        return  NULL;
    }

    //
    //  tokenize string
    //      - note that after the first call strtok
    //      takes NULL ptr to continue tokening same string
    //

    argvCopy[ Argc ] = NULL;

    while ( Argc-- )
    {
        argvCopy[ Argc ] = Dns_StringCopyAllocate(
                                Argv[ Argc ],
                                0,                  // null terminated
                                CharSetIn,
                                CharSetOut
                                );
    }

    return  argvCopy;
}



VOID
Argv_Free(
    IN OUT  PSTR *          Argv
    )
/*++

Routine Description:

    Free allocated Argv.

Arguments:

    Argv -- argv array

Return Value:

    None

--*/
{
    DWORD   i = 0;
    PCHAR   parg;

    //  free Argv strings

    while ( parg = Argv[i++] )
    {
        FREE_HEAP( parg );
    }

    //  free Argv itself

    FREE_HEAP( parg );
}


//
//  End string.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\timer.c ===
/*++

Copyright (c) 1995-2000 Microsoft Corporation

Module Name:

    timer.c

Abstract:

    Domain Name System (DNS) Server

    Wrap proof timer routines.

    The purpose of this module is to create a timer function which
    returns a time in seconds and eliminates all timer wrapping issues.

    These routines are non-DNS specific and may be picked up
    cleanly by any module.

    For DNS the added instructions are well worth the cost in that it
    eliminates any issue involving cleaning packet queues or resetting
    cache timeouts when millisecond timer (GetCurrentTime) wraps.

Author:

    Jim Gilroy (jamesg)     9-Sep-1995

Revision History:

--*/


#include "local.h"

//  Note:  this modules requires only windows.h.
//      local.h is included only to allow precompiled header

#include <windows.h>


#if 1

//
//  GetTickCount() timer routines
//

//
//  Timer globals
//

BOOL                g_InitializedTimerCs = FALSE;
BOOL                g_TimerInitInProgress = FALSE;
CRITICAL_SECTION    csTimerWrap;

DWORD   g_WrapTime = 0;
DWORD   g_PreviousTopBit = 0;



VOID
Dns_InitializeSecondsTimer(
    VOID
    )
/*++

Routine Description:

    Initialize DNS timer.

    This will be done automatically, but allow caller to do it explicitly.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  protect CS init with interlock
    //      - first thread through does CS init
    //      - any others racing, are not released until init
    //          completes
    //

    if ( !g_InitializedTimerCs )
    {
        if ( InterlockedIncrement( &g_TimerInitInProgress ) == 1 )
        {
            InitializeCriticalSection( &csTimerWrap );
            g_InitializedTimerCs = TRUE;
        }
        else
        {
            while ( !g_InitializedTimerCs )
            {
                Sleep( 10 );
            }
        }
    }
}



DWORD
Dns_GetCurrentTimeInSeconds(
    VOID
    )
/*++

Routine Description:

    Get current time in seconds.

Arguments:

    None.

Return Value:

    Time since boot in seconds.

--*/
{
    DWORD   currentTime;
    DWORD   topBit;
    DWORD   preWrapTime;
    DWORD   postWrapTime;

    //
    //  get time
    //
    //  read wrap time on either side so we can detect and handle
    //  a wrap occuring (handled by another thread) while we are
    //  in this function
    //

    preWrapTime = g_WrapTime;

    currentTime = GetCurrentTime();

    postWrapTime = g_WrapTime;

    //
    //  check for timer wrap
    //
    //  need to detect when timer flips from large to small DWORD;
    //
    //  i first did this by keeping a previous time global, but
    //  setting this global must also be carefully locked around timer
    //  wrap to avoid race conditions resulting in double wrap
    //
    //  to avoid locking all the time we can set previous time only
    //  when it "substantively" changes for our purposes -- this is
    //  when it changes its top bit;   by saving it twice a wrap
    //  we have enough info to detect the wrap (the change from
    //  top bit set to clear), yet still only need to lock a few
    //  times every wrap
    //
    //  algorithm:
    //      - top bit same as previous => done
    //      - top bit changed
    //          - take lock
    //          - test again
    //              - no change => no-op
    //          - changed to top bit set
    //              - just save new bit setting
    //          - changed to top bit clear
    //              - save new bit setting
    //              - add one cycle to wrap time
    //          

    topBit = currentTime & 0x80000000;

    if ( topBit != g_PreviousTopBit )
    {
        //
        //  possible wrap or "half-wrap"
        //
        //  not intializing lock until actually need it
        //      - lock init is MT safe (see above)
        //

        Dns_InitializeSecondsTimer();

        EnterCriticalSection( &csTimerWrap );

        //
        //  timer wrap
        //      - recheck inequality as another thread might have beaten
        //      us to the lock and handled wrap already
        //      - topBit must be clear (time is now low DWORD)
        //

        if ( topBit != g_PreviousTopBit  &&  topBit == 0 )
        {
            g_WrapTime += (MAXDWORD / 1000);
        }

        //  reset previous top bit
        //      - not necessary in equality case, but a no-op

        g_PreviousTopBit = topBit;

        LeaveCriticalSection( &csTimerWrap );
    }

    //
    //  return time
    //      - current time + any wrap time
    //      - if pre\post wrap times use topBit to determine which is valid
    //          - if our time was snapshot right before wrap, use pre time
    //          - otherwise post time ok
    //
    //  note this is done completely without globals, so no race
    //

    if ( preWrapTime != postWrapTime )
    {
        if ( topBit )
        {
             postWrapTime = preWrapTime;
        }
    }

    return ( currentTime / 1000 + postWrapTime );
}



#else
//
//  FILETIME timer routines
//
//  Unfortunately these don't work because FILETIME moves
//  around when clock reset -- it is not monotonically increasing
//

//
//  Timer globals
//

LONGLONG  g_TimerBaseTime = 0;

//
//  File time timer in 100ns intervals
//      (10 million to second)
//

#define FILE_TIME_INTERVALS_IN_SECOND   (10000000)

//
//  File time base to avoid starting timer at zero
//  Give roughly a day to avoid any startup issues.
//

#define FILE_TIME_BASE_OFFSET           (1000000000000)


DWORD
Dns_GetCurrentTimeInSeconds(
    VOID
    )
/*++

Routine Description:

    Get current time in seconds.
    Time is relative to first call to the timer.

Arguments:

    None.

Return Value:

    Time since first timer call in seconds.

--*/
{
    LONGLONG    time64;

    GetSystemTimeAsFileTime( (PFILETIME) &time64 );

    //
    //  convert to seconds
    //      - file time is in 100ns intervals (since Jan 1, 1601)
    //
    //  if first call, save 64-bit base time;
    //  this allows us to run a DWORD of seconds ~137 years
    //
    //  repeated calls are offset from base time
    //

    if ( g_TimerBaseTime == 0 )
    {
        g_TimerBaseTime = time64 - FILE_TIME_BASE_OFFSET;
    }

    time64 -= g_TimerBaseTime;
    time64 = time64 / FILE_TIME_INTERVALS_IN_SECOND;

    return  (DWORD)time64;
}



VOID
Dns_InitializeSecondsTimer(
    VOID
    )
/*++

Routine Description:

    Initialize DNS timer.

    Note, this is not a reset -- it's just backward compatibility
    for old timer routines.

Arguments:

    None.

Return Value:

    None.

--*/
{
    //
    //  call the timer, for uninitialized timer that makes time
    //      now

    Dns_GetCurrentTimeInSeconds();

    //
    //  note if want a timer reset, then zero base, however
    //  this is NOT MT safe -- thread in function could get
    //  huge bogus time
    //
}

#endif

//
//  End of timer.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\table.c ===
/*++

Copyright (c) 1996-2000 Microsoft Corporation

Module Name:

    table.c

Abstract:

    Domain Name System (DNS) Library

    Routines to handle general table lookup.

Author:

    Jim Gilroy (jamesg)     December 1996

Revision History:

--*/


#include "local.h"

#include "time.h"


//
//  Comparison function
//

typedef INT (__cdecl * COMPARISON_FUNCTION)(
                            const CHAR *,
                            const CHAR *, 
                            size_t );



//
//  Table lookup.
//
//  Many DNS Records have human readable mnemonics for given data values.
//  These are used for data file formats, and display in nslookup or debug
//  output or cmdline tools.
//
//  To simplify this process, have a single mapping functionality that
//  supports DWORD \ LPSTR mapping tables.   Tables for indivual types
//  may then be layered on top of this.
//
//  Support two table types.
//      VALUE_TABLE_ENTRY is simple value-string mapping
//      FLAG_TABLE_ENTRY is designed for bit field flag mappings where
//          several flag strings might be contained in flag;  this table
//          contains additional mask field to allow multi-bit fields
//          within the flag
//

#if 0
//
//  Defined in local.h here only for reference
//
typedef struct
{
    DWORD   dwValue;        //  flag value
    PCHAR   pszString;      //  string representation of value
}
DNS_VALUE_TABLE_ENTRY;

typedef struct
{
    DWORD   dwFlag;         //  flag value
    DWORD   dwMask;         //  flag value mask
    PCHAR   pszString;      //  string representation of value
}
DNS_FLAG_TABLE_ENTRY;

//  Error return on unmatched string

#define DNS_TABLE_LOOKUP_ERROR (-1)

#endif



DWORD
Dns_ValueForString(
    IN      DNS_VALUE_TABLE_ENTRY * Table,
    IN      BOOL                    fIgnoreCase,
    IN      PCHAR                   pchName,
    IN      INT                     cchNameLength
    )
/*++

Routine Description:

    Retrieve value for given string.

Arguments:

    Table           - table with value\string mapping

    fIgnoreCase     - TRUE if case-insensitive string lookup

    pchName         - ptr to string

    cchNameLength   - length of string

Return Value:

    Flag value corresponding to string, if found.
    DNS_TABLE_LOOKUP_ERROR otherwise.

--*/
{
    INT     i = 0;
    //    INT     (* pcompareFunction)( const char *, const char *, size_t );
    COMPARISON_FUNCTION  pcompareFunction;


    //
    //  if not given get string length
    //

    if ( !cchNameLength )
    {
        cchNameLength = strlen( pchName );
    }

    //
    //  determine comparison routine
    //

    if ( fIgnoreCase )
    {
        pcompareFunction = _strnicmp;
    }
    else
    {
        pcompareFunction = strncmp;
    }

    //
    //  find value matching name
    //

    while( Table[i].pszString != NULL )
    {
        if ( pcompareFunction( pchName, Table[i].pszString, cchNameLength ) == 0 )
        {
            return( Table[i].dwValue );
        }
        i++;
    }

    return( (DWORD)DNS_TABLE_LOOKUP_ERROR );
}



DWORD
Dns_ValueForStringEx(
    IN      DNS_VALUE_TABLE_ENTRY * Table,
    IN      BOOL                    fIgnoreCase,
    IN      DNS_CHARSET             InCharSet,
    IN      PCHAR                   pchName,
    IN      INT                     cchNameLength
    )
/*++

Routine Description:

    Retrieve value for given string.

Arguments:

    Table           - table with value\string mapping

    fIgnoreCase     - TRUE if case-insensitive string lookup

    InCharSet       - input string char set

    pchName         - ptr to string

    cchNameLength   - length of string

Return Value:

    Flag value corresponding to string, if found.
    DNS_TABLE_LOOKUP_ERROR otherwise.

--*/
{
    DWORD   result;
    PSTR    pnameAlloc;


    //
    //  convert
    //

#if 0
    if ( InCharSet != 0 &&
         InCharSet != DnsCharSetAnsi )
    {
#endif
    pnameAlloc = Dns_StringCopyAllocate(
                    pchName,
                    cchNameLength,
                    InCharSet,
                    DnsCharSetAnsi );

    //
    //  do the lookup
    //

    result = Dns_ValueForString(
                Table,
                fIgnoreCase,
                pnameAlloc,
                0       // null terminated
                );

    //
    //  cleanup
    //

    FREE_HEAP( pnameAlloc );

    return  result;
}



PCHAR
Dns_GetStringForValue(
    IN      DNS_VALUE_TABLE_ENTRY * Table,
    IN      DWORD                   dwValue
    )
/*++

Routine Description:

    Retrieve string representation of given value.

Arguments:

    Table   - table with value\string mapping

    dwValue - value to map to strings

Return Value:

    Ptr to mapping mneumonic string.
    NULL if unknown mapping type.

--*/
{
    INT i = 0;

    //
    //  check all supported values for match
    //

    while( Table[i].pszString != NULL )
    {
        if ( dwValue == Table[i].dwValue )
        {
            return( Table[i].pszString );
        }
        i++;
    }
    return( NULL );
}



DWORD
Dns_FlagForString(
    IN      DNS_FLAG_TABLE_ENTRY *  Table,
    IN      BOOL                    fIgnoreCase,
    IN      PCHAR                   pchName,
    IN      INT                     cchNameLength
    )
/*++

Routine Description:

    Retrieve flag value for given string.

    This may be called repeatedly with additional strings and OR the result
    together to build flag with independent bit settings.

Arguments:

    Table           - table with value\string mapping

    fIgnoreCase     - TRUE if case-insensitive string lookup

    pchName         - ptr to string

    cchNameLength   - length of string

Return Value:

    Flag value corresponding to string, if found.
    DNS_TABLE_LOOKUP_ERROR otherwise.

--*/
{
    INT i = 0;

    //
    //  if not given get string length
    //

    if ( !cchNameLength )
    {
        cchNameLength = strlen( pchName );
    }

    //
    //  check all supported values for name match
    //

    if ( fIgnoreCase )
    {
        while( Table[i].pszString != NULL )
        {
            if ( cchNameLength == (INT)strlen( Table[i].pszString )
                    &&
                ! _strnicmp( pchName, Table[i].pszString, cchNameLength ) )
            {
                return( Table[i].dwFlag );
            }
            i++;
        }
    }
    else
    {
        while( Table[i].pszString != NULL )
        {
            if ( cchNameLength == (INT)strlen( Table[i].pszString )
                    &&
                ! strncmp( pchName, Table[i].pszString, cchNameLength ) )
            {
                return( Table[i].dwFlag );
            }
            i++;
        }
    }

    return( (DWORD) DNS_TABLE_LOOKUP_ERROR );
}



VOID
DnsPrint_ValueTable(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN      PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_VALUE_TABLE    Table
    )
/*++

Routine Description:

    Print value table.

Arguments:

    PrintRoutine    - routine to print with

    pPrintContext   - print context

    pszHeader       - header to print

    Table           - value table to print

Return Value:

    None

--*/
{
    DWORD   i = 0;

    if ( !pszHeader )
    {
        pszHeader = "Table";
    }

    if ( ! pszHeader )
    {
        PrintRoutine(
            pPrintContext,
            "%s NULL value table to print",
            pszHeader );
    }

    //
    //  print each value in table
    //

    DnsPrint_Lock();

    PrintRoutine(
        pPrintContext,
        "%s\n",
        pszHeader );

    while( Table[i].pszString != NULL )
    {
        PrintRoutine(
            pPrintContext,
            "\t%40s\t\t%08x\n",
            Table[i].pszString,
            Table[i].dwValue );
        i++;
    }

    DnsPrint_Unlock();
}



PCHAR
Dns_WriteStringsForFlag(
    IN      DNS_FLAG_TABLE_ENTRY *  Table,
    IN      DWORD                   dwFlag,
    IN OUT  PCHAR                   pchFlag
    )
/*++

Routine Description:

    Retrieve flag string(s) corresponding to a given flag value.

    This function is specifically for mapping a flag value into the
    corresponding flag mnemonics.

    No attempt is made to insure that every bit of dwValue is mapped,
    nor are bits eliminated as they are mapped.  Every value in table
    that exactly matches bits in the table is returned.

Arguments:

    Table   - table with value\string mapping

    dwFlag  - flag value to map to strings

    pchFlag - buffer to write flag to

Return Value:

    Ptr to next location in pchFlag buffer.
    If this is same as input, then no strings were written.

--*/
{
    INT i = 0;

    //  init buffer for no-match

    DNS_ASSERT( pchFlag != NULL );
    *pchFlag = 0;

    //
    //  check all supported flags types for name match
    //      - note comparing flag within mask to allow match of multi-bit
    //      flags
    //

    while( Table[i].pszString != NULL )
    {
        if ( (dwFlag & Table[i].dwMask) == Table[i].dwFlag )
        {
            pchFlag += sprintf( pchFlag, "%s ", Table[i].pszString );
        }
        i++;
    }
    return( pchFlag );
}





//
//  Specific simple tables
//

//
//  RnR Flag mappings
//

DNS_VALUE_TABLE_ENTRY  RnrLupFlagTable[] =
{
    LUP_DEEP                    ,   "LUP_DEEP"                ,
    LUP_CONTAINERS              ,   "LUP_CONTAINERS"          ,
    LUP_NOCONTAINERS            ,   "LUP_NOCONTAINERS"        ,
    LUP_RETURN_NAME             ,   "LUP_RETURN_NAME"         ,
    LUP_RETURN_TYPE             ,   "LUP_RETURN_TYPE"         ,
    LUP_RETURN_VERSION          ,   "LUP_RETURN_VERSION"      ,
    LUP_RETURN_COMMENT          ,   "LUP_RETURN_COMMENT"      ,
    LUP_RETURN_ADDR             ,   "LUP_RETURN_ADDR"         ,
    LUP_RETURN_BLOB             ,   "LUP_RETURN_BLOB"         ,
    LUP_RETURN_ALIASES          ,   "LUP_RETURN_ALIASES"      ,
    LUP_RETURN_QUERY_STRING     ,   "LUP_RETURN_QUERY_STRING" ,
    LUP_RETURN_ALL              ,   "LUP_RETURN_ALL"          ,
    LUP_RES_SERVICE             ,   "LUP_RES_SERVICE"         ,
    LUP_FLUSHCACHE              ,   "LUP_FLUSHCACHE"          ,
    LUP_FLUSHPREVIOUS           ,   "LUP_FLUSHPREVIOUS"       ,

    0,  NULL,
};                                  



DWORD
Dns_RnrLupFlagForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    )
/*++

Routine Description:

    Retrieve RnR LUP flag corresponding to string.

Arguments:

    pchName - ptr to string
    cchNameLength - length of string

Return Value:

    Flag corresponding to string, if found.
    Zero otherwise.

--*/
{
    return  Dns_ValueForString(
                RnrLupFlagTable,
                FALSE,              // always upper case
                pchName,
                cchNameLength );
}



PCHAR
Dns_GetRnrLupFlagString(
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Get string corresponding to a given RnR LUP flag.

Arguments:

    dwFlag -- flag

Return Value:

    Ptr to flag mneumonic string.
    NULL if unknown flag.

--*/
{
    return  Dns_GetStringForValue(
                RnrLupFlagTable,
                dwFlag );
}


//
//  RnR Name Space ID mappings
//

DNS_VALUE_TABLE_ENTRY  RnrNameSpaceMappingTable[] =
{
    NS_ALL              ,   "NS_ALL"            ,  
    //NS_DEFAULT          ,   "NS_DEFAULT"        ,
    NS_SAP              ,   "NS_SAP"            ,  
    NS_NDS              ,   "NS_NDS"            ,  
    NS_PEER_BROWSE      ,   "NS_PEER_BROWSEE"   ,  
    NS_SLP              ,   "NS_SLP"            ,  
    NS_DHCP             ,   "NS_DHCP"           ,  
    NS_TCPIP_LOCAL      ,   "NS_TCPIP_LOCAL"    ,  
    NS_TCPIP_HOSTS      ,   "NS_TCPIP_HOSTS"    ,  
    NS_DNS              ,   "NS_DNS"            ,  
    NS_NETBT            ,   "NS_NETBT"          ,  
    NS_WINS             ,   "NS_WINS"           ,  
    NS_NLA              ,   "NS_NLA"            ,  
    NS_NBP              ,   "NS_NBP"            ,  
    NS_MS               ,   "NS_MS"             ,  
    NS_STDA             ,   "NS_STDA"           ,  
    NS_NTDS             ,   "NS_NTDS"           ,  
    NS_X500             ,   "NS_X500"           ,  
    NS_NIS              ,   "NS_NIS"            ,  
    NS_NISPLUS          ,   "NS_NISPLUS"        ,  
    NS_WRQ              ,   "NS_WRQ"            ,  
    NS_NETDES           ,   "NS_NETDES"         ,  

    0,  NULL,
};                                  


DWORD
Dns_RnrNameSpaceIdForString(
    IN      PCHAR           pchName,
    IN      INT             cchNameLength
    )
/*++

Routine Description:

    Retrieve RnR Name Space Id corresponding to string.

Arguments:

    pchName - ptr to string
    cchNameLength - length of string

Return Value:

    Name space ID corresponding to string, if found.
    Zero otherwise.

--*/
{
    return  Dns_ValueForString(
                RnrNameSpaceMappingTable,
                FALSE,              // always upper case
                pchName,
                cchNameLength );
}


DWORD
Dns_RnrNameSpaceIdForStringW(
    IN      PWSTR           pwsName
    )
{
    return  Dns_ValueForStringEx(
                RnrNameSpaceMappingTable,
                FALSE,              // always upper case
                DnsCharSetUnicode,
                (PCHAR) pwsName,
                0 );
}



PCHAR
Dns_GetRnrNameSpaceIdString(
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Get string corresponding to a given RnR name space id.

Arguments:

    dwFlag -- flag

Return Value:

    Ptr to name space mneumonic string.
    NULL if unknown flag.

--*/
{
    return  Dns_GetStringForValue(
                RnrNameSpaceMappingTable,
                dwFlag );
}

//
//  End table.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\test\ipleak.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>
#include "..\dnslib.h"


VOID
PrintIpAddress (
    IN  DWORD dwIpAddress )
{
    printf( "%d.%d.%d.%d\n",
            ((BYTE *) &dwIpAddress)[0],
            ((BYTE *) &dwIpAddress)[1],
            ((BYTE *) &dwIpAddress)[2],
            ((BYTE *) &dwIpAddress)[3] );
}

_cdecl
main(int argc, char **argv)
{
    DWORD            sysVersion;
    DWORD            iter;
    DWORD            Count;
    DNS_ADDRESS_INFO ipInfoArray[256];

    system( "pause" );

    for ( iter = 0; iter < 100000; iter++ )
    {
        Count = Dns_GetIpAddresses( ipInfoArray, 256 );
    }

    system( "pause" );

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\verify.c ===
/*++

Copyright (c) 2001-2001  Microsoft Corporation

Module Name:

    verify.c

Abstract:

    Domain Name System (DNS) Library

    Verify records on DNS server.
    Utilities primary for rendom (domain rename) tool.

Author:

    Jim Gilroy (jamesg)     October 2001

Revision History:

--*/


#include "local.h"


//
//  Private prototypes
//




DNS_STATUS
Dns_VerifyRecords(
    IN OUT  PDNS_VERIFY_TABLE   pTable
    )
/*++

Routine Description:

    Verify DNS records on server(s).

Arguments:

    pTable -- table with record and server info

Return Value:

    ERROR_SUCCESS if call successful (regardless of verification result).
    Verification result returned in table.

--*/
{
    return( ERROR_CALL_NOT_IMPLEMENTED );
}



DNS_STATUS
Dns_VerifyRendomDcRecords(
    IN OUT  PDNS_RENDOM_ENTRY       pTable,
    IN      PDNS_ZONE_SERVER_LIST   pZoneServList,  OPTIONAL
    IN      DWORD                   Flag
    )
/*++

Routine Description:

    Verify DC-DNS records on servers from rendom.

Arguments:

    pTable -- table with record and server info

    pZoneServerList -- zone server list

    Flag -- flag

Return Value:

    ERROR_SUCCESS if call successful (regardless of verification result).
    Verification result returned in table.

--*/
{
    return( ERROR_CALL_NOT_IMPLEMENTED );
}

//
//  End verify.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\utf8.c ===
/*++

Copyright (c) 1997-2001 Microsoft Corporation

Module Name:

    utf8.c

Abstract:

    Domain Name System (DNS) Library

    UTF8 to\from unicode and ANSI conversions

    The UTF8\unicode routines are similar to the generic ones floating
    around the NT group, but a heck of a lot cleaner and more robust,
    including catching the invalid UTF8 string case on the utf8 to unicode
    conversion.

    The UTF8\ANSI routines are optimized for the 99% case where all the
    characters are <128 and no conversions is actually required.

Author:

    Jim Gilroy (jamesg)     March 1997

Revision History:

--*/


#include "local.h"


//
//  Macros to simplify UTF8 conversions
//

#define UTF8_1ST_OF_2     0xc0      //  110x xxxx
#define UTF8_1ST_OF_3     0xe0      //  1110 xxxx
#define UTF8_1ST_OF_4     0xf0      //  1111 xxxx
#define UTF8_TRAIL        0x80      //  10xx xxxx

#define UTF8_2_MAX        0x07ff    //  max unicode character representable in
                                    //  in two byte UTF8

#define BIT7(ch)        ((ch) & 0x80)
#define BIT6(ch)        ((ch) & 0x40)
#define BIT5(ch)        ((ch) & 0x20)
#define BIT4(ch)        ((ch) & 0x10)
#define BIT3(ch)        ((ch) & 0x08)

#define LOW6BITS(ch)    ((ch) & 0x3f)
#define LOW5BITS(ch)    ((ch) & 0x1f)
#define LOW4BITS(ch)    ((ch) & 0x0f)

#define HIGHBYTE(wch)   ((wch) & 0xff00)

//
//  Surrogate pair support
//  Two unicode characters may be linked to form a surrogate pair.
//  And for some totally unknown reason, someone thought they
//  should travel in UTF8 as four bytes instead of six.
//  No one has any idea why this is true other than to complicate
//  the code.
//

#define HIGH_SURROGATE_START  0xd800
#define HIGH_SURROGATE_END    0xdbff
#define LOW_SURROGATE_START   0xdc00
#define LOW_SURROGATE_END     0xdfff


//
//  Max "normal conversion", make space for MAX_PATH,
//  this covers all valid DNS names and strings.
//

#define TEMP_BUFFER_LENGTH  (2*MAX_PATH)



DNS_STATUS
_fastcall
Dns_ValidateUtf8Byte(
    IN      BYTE            chUtf8,
    IN OUT  PDWORD          pdwTrailCount
    )
/*++

Routine Description:

    Verifies that byte is valid UTF8 byte.

Arguments:

Return Value:

    ERROR_SUCCESS -- if valid UTF8 given trail count
    ERROR_INVALID_DATA -- if invalid

--*/
{
    DWORD   trailCount = *pdwTrailCount;

    DNSDBG( TRACE, ( "Dns_ValidateUtf8Byte()\n" ));

    //
    //  if ASCII byte, only requirement is no trail count
    //

    if ( (UCHAR)chUtf8 < 0x80 )
    {
        if ( trailCount == 0 )
        {
            return( ERROR_SUCCESS );
        }
        return( ERROR_INVALID_DATA );
    }

    //
    //  trail byte
    //      - must be in multi-byte set
    //

    if ( BIT6(chUtf8) == 0 )
    {
        if ( trailCount == 0 )
        {
            return( ERROR_INVALID_DATA );
        }
        --trailCount;
    }

    //
    //  multi-byte lead byte
    //      - must NOT be in existing multi-byte set
    //      - verify valid lead byte

    else
    {
        if ( trailCount != 0 )
        {
            return( ERROR_INVALID_DATA );
        }

        //  first of two bytes (110xxxxx)

        if ( BIT5(chUtf8) == 0 )
        {
            trailCount = 1;
        }

        //  first of three bytes (1110xxxx)

        else if ( BIT4(chUtf8) == 0 )
        {
            trailCount = 2;
        }

        //  first of four bytes (surrogate character) (11110xxx)

        else if ( BIT3(chUtf8) == 0 )
        {
            trailCount = 3;
        }

        else
        {
            return( ERROR_INVALID_DATA );
        }
    }

    //  reset caller's trail count

    *pdwTrailCount = trailCount;
    return( ERROR_SUCCESS );
}



//
//  UTF8 to unicode conversions
//
//  For some reason UTF8 is not supported in Win9x.
//  AND the implementation itself is not careful about
//  validating UTF8.
//

DWORD
_fastcall
Dns_UnicodeToUtf8(
    IN      PWCHAR          pwUnicode,
    IN      DWORD           cchUnicode,
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult
    )
/*++

Routine Description:

    Convert unicode characters to UTF8.

    Result is NULL terminated if sufficient space in result
    buffer is available.

Arguments:

    pwUnicode   -- ptr to start of unicode buffer

    cchUnicode  -- length of unicode buffer

    pchResult   -- ptr to start of result buffer for UTF8 chars

    cchResult   -- length of result buffer

Return Value:

    Count of UTF8 characters in result, if successful.
    0 on error.  GetLastError() has error code.

--*/
{
    WCHAR   wch;                // current unicode character being converted
    DWORD   lengthUtf8 = 0;     // length of UTF8 result string
    WORD    lowSurrogate;
    DWORD   surrogateDword;


    DNSDBG( TRACE, (
        "Dns_UnicodeToUtf8( %.*S )\n",
        cchUnicode,
        pwUnicode ));

    //
    //  loop converting unicode chars until run out or error
    //

    while ( cchUnicode-- )
    {
        wch = *pwUnicode++;

        //
        //  ASCII character (7 bits or less) -- converts to directly
        //

        if ( wch < 0x80 )
        {
            lengthUtf8++;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                *pchResult++ = (CHAR)wch;
            }
            continue;
        }

        //
        //  wide character less than 0x07ff (11bits) converts to two bytes
        //      - upper 5 bits in first byte
        //      - lower 6 bits in secondar byte
        //

        else if ( wch <= UTF8_2_MAX )
        {
            lengthUtf8 += 2;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                *pchResult++ = UTF8_1ST_OF_2 | wch >> 6;
                *pchResult++ = UTF8_TRAIL    | LOW6BITS( (UCHAR)wch );
            }
            continue;
        }

        //
        //  surrogate pair
        //      - if have high surrogate followed by low surrogate then
        //          process as surrogate pair
        //      - otherwise treat character as ordinary unicode "three-byte"
        //          character, by falling through to below
        //

        else if ( wch >= HIGH_SURROGATE_START &&
                  wch <= HIGH_SURROGATE_END &&
                  cchUnicode &&
                  (lowSurrogate = *pwUnicode) &&
                  lowSurrogate >= LOW_SURROGATE_START &&
                  lowSurrogate <= LOW_SURROGATE_END )
        {
            //  have a surrogate pair
            //      - suck up next unicode character (low surrogate of pair)
            //      - make full DWORD surrogate pair
            //      - then lay out four UTF8 bytes
            //          1st of four, then three trail bytes
            //              0x1111xxxx
            //              0x10xxxxxx
            //              0x10xxxxxx
            //              0x10xxxxxx

            DNSDBG( TRACE, (
                "Have surrogate pair %hx : %hx\n",
                wch,
                lowSurrogate ));

            pwUnicode++;
            cchUnicode--;
            lengthUtf8 += 4;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                surrogateDword = (((wch-0xD800) << 10) + (lowSurrogate - 0xDC00) + 0x10000);

                *pchResult++ = UTF8_1ST_OF_4 | (UCHAR) (surrogateDword >> 18);
                *pchResult++ = UTF8_TRAIL    | (UCHAR) LOW6BITS(surrogateDword >> 12);
                *pchResult++ = UTF8_TRAIL    | (UCHAR) LOW6BITS(surrogateDword >> 6);
                *pchResult++ = UTF8_TRAIL    | (UCHAR) LOW6BITS(surrogateDword);

                DNSDBG( TRACE, (
                    "Converted surrogate -- DWORD = %08x\n"
                    "\tconverted %x %x %x %x\n",
                    surrogateDword,
                    (UCHAR) *(pchResult-3),
                    (UCHAR) *(pchResult-2),
                    (UCHAR) *(pchResult-1),
                    (UCHAR) *pchResult ));
            }
        }

        //
        //  wide character (non-zero in top 5 bits) converts to three bytes
        //      - top 4 bits in first byte
        //      - middle 6 bits in second byte
        //      - low 6 bits in third byte
        //

        else
        {
            lengthUtf8 += 3;

            if ( pchResult )
            {
                if ( lengthUtf8 >= cchResult )
                {
                    goto OutOfBuffer;
                }
                *pchResult++ = UTF8_1ST_OF_3 | (wch >> 12);
                *pchResult++ = UTF8_TRAIL    | LOW6BITS( wch >> 6 );
                *pchResult++ = UTF8_TRAIL    | LOW6BITS( wch );
            }
        }
    }

    //
    //  NULL terminate buffer
    //  return UTF8 character count
    //

    if ( pchResult && lengthUtf8 < cchResult )
    {
        *pchResult = 0;
    }
    return( lengthUtf8 );

OutOfBuffer:

    SetLastError( ERROR_INSUFFICIENT_BUFFER );
    return( 0 );
}




DWORD
_fastcall
Dns_Utf8ToUnicode(
    IN      PCHAR           pchUtf8,
    IN      DWORD           cchUtf8,
    OUT     PWCHAR          pwResult,
    IN      DWORD           cwResult
    )
/*++

Routine Description:

    Convert UTF8 characters to unicode.

    Result is NULL terminated if sufficient space in result
    buffer is available.

Arguments:

    pwResult    -- ptr to start of result buffer for unicode chars

    cwResult    -- length of result buffer in WCHAR

    pwUtf8      -- ptr to start of UTF8 buffer

    cchUtf8     -- length of UTF8 buffer

Return Value:

    Count of unicode characters in result, if successful.
    0 on error.  GetLastError() has error code.

--*/
{
    CHAR    ch;                     // current UTF8 character
    WCHAR   wch;                    // current unicode character
    DWORD   trailCount = 0;         // count of UTF8 trail bytes to follow
    DWORD   lengthUnicode = 0;      // length of unicode result string
    BOOL    bsurrogatePair = FALSE;
    DWORD   surrogateDword;


    //
    //  loop converting UTF8 chars until run out or error
    //

    while ( cchUtf8-- )
    {
        ch = *pchUtf8++;

        //
        //  ASCII character -- just copy
        //

        if ( BIT7(ch) == 0 )
        {
            lengthUnicode++;
            if ( pwResult )
            {
                if ( lengthUnicode >= cwResult )
                {
                    goto OutOfBuffer;
                }
                *pwResult++ = (WCHAR)ch;
            }
            continue;
        }

        //
        //  UTF8 trail byte
        //      - if not expected, error
        //      - otherwise shift unicode character 6 bits and
        //          copy in lower six bits of UTF8
        //      - if last UTF8 byte, copy result to unicode string
        //

        else if ( BIT6(ch) == 0 )
        {
            if ( trailCount == 0 )
            {
                goto InvalidUtf8;
            }

            if ( !bsurrogatePair )
            {
                wch <<= 6;
                wch |= LOW6BITS( ch );

                if ( --trailCount == 0 )
                {
                    lengthUnicode++;
                    if ( pwResult )
                    {
                        if ( lengthUnicode >= cwResult )
                        {
                            goto OutOfBuffer;
                        }
                        *pwResult++ = wch;
                    }
                }
                continue;
            }

            //  surrogate pair
            //      - same as above EXCEPT build two unicode chars
            //      from surrogateDword

            else
            {
                surrogateDword <<= 6;
                surrogateDword |= LOW6BITS( ch );

                if ( --trailCount == 0 )
                {
                    lengthUnicode += 2;

                    if ( pwResult )
                    {
                        if ( lengthUnicode >= cwResult )
                        {
                            goto OutOfBuffer;
                        }
                        surrogateDword -= 0x10000;
                        *pwResult++ = (WCHAR) ((surrogateDword >> 10) + HIGH_SURROGATE_START);
                        *pwResult++ = (WCHAR) ((surrogateDword & 0x3ff) + LOW_SURROGATE_START);
                    }
                    bsurrogatePair = FALSE;
                }
            }

        }

        //
        //  UTF8 lead byte
        //      - if currently in extension, error

        else
        {
            if ( trailCount != 0 )
            {
                goto InvalidUtf8;
            }

            //  first of two byte character (110xxxxx)

            if ( BIT5(ch) == 0 )
            {
                trailCount = 1;
                wch = LOW5BITS(ch);
                continue;
            }

            //  first of three byte character (1110xxxx)

            else if ( BIT4(ch) == 0 )
            {
                trailCount = 2;
                wch = LOW4BITS(ch);
                continue;
            }

            //  first of four byte surrogate pair (11110xxx)

            else if ( BIT3(ch) == 0 )
            {
                trailCount = 3;
                surrogateDword = LOW4BITS(ch);
                bsurrogatePair = TRUE;
            }

            else
            {
                goto InvalidUtf8;
            }
        }
    }

    //  catch if hit end in the middle of UTF8 multi-byte character

    if ( trailCount )
    {
        goto InvalidUtf8;
    }

    //
    //  NULL terminate buffer
    //  return the number of Unicode characters written.
    //

    if ( pwResult  &&  lengthUnicode < cwResult )
    {
        *pwResult = 0;
    }
    return( lengthUnicode );

OutOfBuffer:

    SetLastError( ERROR_INSUFFICIENT_BUFFER );
    return( 0 );

InvalidUtf8:

    SetLastError( ERROR_INVALID_DATA );
    return( 0 );
}




//
//  UTF8 \ ANSI conversions
//

DWORD
Dns_Utf8ToOrFromAnsi(
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult,
    IN      PCHAR           pchIn,
    IN      DWORD           cchIn,
    IN      DNS_CHARSET     InCharSet,
    IN      DNS_CHARSET     OutCharSet
    )
/*++

Routine Description:

    Convert UTF8 characters to ANSI or vice versa.

    Note:  this function appears to call string functions (string.c)
        which call back to it.  However, this calls those functions
        ONLY for conversions to\from unicode which do NOT call back
        to these functions.  Ultimately need to check if LCMapString
        can handle these issues.

Arguments:

    pchResult   -- ptr to start of result buffer for ansi chars

    cchResult   -- length of result buffer

    pchIn       -- ptr to start of input string

    cchIn       -- length of input string

    InCharSet   -- char set of input string (DnsCharSetAnsi or DnsCharSetUtf8)

    OutCharSet  -- char set for result string (DnsCharSetUtf8 or DnsCharSetAnsi)

Return Value:

    Count of bytes in result (including terminating NULL).
    0 on error.  GetLastError() has error code.

--*/
{
    DWORD       unicodeLength;
    DWORD       resultLength;
    CHAR        tempBuffer[ TEMP_BUFFER_LENGTH ];
    PCHAR       ptemp = tempBuffer;
    DNS_STATUS  status;

    DNSDBG( TRACE, (
        "Dns_Utf8ToOrFromAnsi()\n"
        "\tbuffer       = %p\n"
        "\tbuf length   = %d\n"
        "\tpchString    = %p (%*s)\n"
        "\tcchString    = %d\n"
        "\tCharSetIn    = %d\n"
        "\tCharSetOut   = %d\n",
        pchResult,
        cchResult,
        pchIn,
        cchIn, pchIn,
        cchIn,
        InCharSet,
        OutCharSet ));

    //
    //  validate charsets
    //

    ASSERT( InCharSet != OutCharSet );
    ASSERT( InCharSet == DnsCharSetAnsi || InCharSet == DnsCharSetUtf8 );
    ASSERT( OutCharSet == DnsCharSetAnsi || OutCharSet == DnsCharSetUtf8 );

    //
    //  if length not given, calculate
    //

    if ( cchIn == 0 )
    {
        cchIn = strlen( pchIn );
    }

    //
    //  string completely ASCII
    //      - simple memcopy suffices
    //      - note result must have terminating NULL
    //

    if ( Dns_IsStringAsciiEx(
                pchIn,
                cchIn ) )
    {
        if ( !pchResult )
        {
            return( cchIn + 1 );
        }

        if ( cchResult <= cchIn )
        {
            status = ERROR_INSUFFICIENT_BUFFER;
            goto Failed;
        }
        memcpy(
            pchResult,
            pchIn,
            cchIn );

        pchResult[ cchIn ] = 0;

        return( cchIn+1 );
    }

    //
    //  non-ASCII
    //      - convert to unicode, then to result character set
    //
    //  DCR_PERF:  LCMapStringA() might be able to handle all this
    //          haven't figured out how yet
    //

    unicodeLength = Dns_GetBufferLengthForStringCopy(
                        pchIn,
                        cchIn,
                        InCharSet,
                        DnsCharSetUnicode
                        );

    if ( unicodeLength > TEMP_BUFFER_LENGTH )
    {
        //  can't use static buffer, must allocate

        ptemp = Dns_StringCopyAllocate(
                    pchIn,
                    cchIn,
                    InCharSet,
                    DnsCharSetUnicode
                    );
        if ( !ptemp )
        {
            status = ERROR_INVALID_DATA;
            goto Failed;
        }
    }
    else
    {
        if ( unicodeLength == 0 )
        {
            status = ERROR_INVALID_DATA;
            goto Failed;
        }

        //  copy into temporary buffer

        resultLength = Dns_StringCopy(
                        ptemp,
                        NULL,       // adequate buffer length
                        pchIn,
                        cchIn,
                        InCharSet,
                        DnsCharSetUnicode
                        );
        if ( !resultLength )
        {
            status = ERROR_INVALID_DATA;
            goto Failed;
        }
        ASSERT( resultLength == unicodeLength );
    }

    //
    //  conversion to result char set
    //      - if have result buffer, convert into it
    //      - should have at least ONE two byte character
    //          otherwise should have taken fast path above
    //

    if ( pchResult )
    {
        resultLength = Dns_StringCopy(
                            pchResult,
                            & cchResult,        // result buffer length
                            ptemp,
                            0,
                            DnsCharSetUnicode,
                            OutCharSet
                            );
        if ( resultLength == 0 )
        {
            status = ERROR_INSUFFICIENT_BUFFER;
            goto Failed;
        }
        ASSERT( resultLength <= cchResult );
        ASSERT( pchResult[resultLength-1] == 0 );
        ASSERT( resultLength >= unicodeLength/2 );
    }

    else
    {
        resultLength = Dns_GetBufferLengthForStringCopy(
                            ptemp,
                            0,
                            DnsCharSetUnicode,
                            OutCharSet
                            );
        ASSERT( resultLength >= unicodeLength/2 );
    }

    //
    //  final mapping from unicode to result character set
    //

    if ( ptemp != tempBuffer )
    {
        FREE_HEAP( ptemp );
    }

    return( resultLength );


Failed:

    SetLastError( status );

    if ( ptemp != tempBuffer )
    {
        FREE_HEAP( ptemp );
    }

    return( 0 );
}



DWORD
Dns_AnsiToUtf8(
    IN      PCHAR           pchAnsi,
    IN      DWORD           cchAnsi,
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult
    )
/*++

Routine Description:

    Convert ANSI characters to UTF8.

Arguments:

    pchAnsi   -- ptr to start of ansi buffer

    cchAnsi  -- length of ansi buffer

    pchResult   -- ptr to start of result buffer for UTF8 chars

    cchResult   -- length of result buffer

Return Value:

    Count of UTF8 characters in result, if successful.
    0 on error.  GetLastError() has error code.

--*/
{
    return  Dns_Utf8ToOrFromAnsi(
                pchResult,          // result buffer
                cchResult,
                pchAnsi,            // in string
                cchAnsi,
                DnsCharSetAnsi,     // ANSI in
                DnsCharSetUtf8      // UTF8 out
                );
}



DWORD
Dns_Utf8ToAnsi(
    IN      PCHAR           pchUtf8,
    IN      DWORD           cchUtf8,
    OUT     PCHAR           pchResult,
    IN      DWORD           cchResult
    )
/*++

Routine Description:

    Convert UTF8 characters to ANSI.

Arguments:

    pchResult   -- ptr to start of result buffer for ansi chars

    cchResult   -- length of result buffer

    pwUtf8      -- ptr to start of UTF8 buffer

    cchUtf8     -- length of UTF8 buffer

Return Value:

    Count of ansi characters in result, if successful.
    0 on error.  GetLastError() has error code.

--*/
{
    return  Dns_Utf8ToOrFromAnsi(
                pchResult,          // result buffer
                cchResult,
                pchUtf8,            // in string
                cchUtf8,
                DnsCharSetUtf8,     // UTF8 in
                DnsCharSetAnsi      // ANSI out
                );
}



BOOL
_fastcall
Dns_IsStringAscii(
    IN      LPSTR           pszString
    )
/*++

Routine Description:

    Check if string is ASCII.

    This is equivalent to saying
        - is ANSI string already in UTF8
        or
        - is UTF8 string already in ANSI

    This allows you to optimize for the 99% case where just
    passing ASCII strings.

Arguments:

    pszString -- ANSI or UTF8 string to check for ASCIIhood

Return Value:

    TRUE if string is all ASCII (characters all < 128)
    FALSE if non-ASCII characters.

--*/
{
    register UCHAR   ch;

    //
    //  loop through until hit non-ASCII character
    //

    while ( ch = (UCHAR) *pszString++ )
    {
        if ( ch < 0x80 )
        {
            continue;
        }
        return( FALSE );
    }

    return( TRUE );
}



BOOL
_fastcall
Dns_IsStringAsciiEx(
    IN      PCHAR           pchString,
    IN      DWORD           cchString
    )
/*++

Routine Description:

    Check if ANSI (or UTF8) string is ASCII.

    This is equivalent to saying
        - is ANSI string already in UTF8
        or
        - is UTF8 string already in ANSI

    This allows you to optimize for the 99% case where just
    passing ASCII strings.

Arguments:

    pchString   -- ptr to start of ansi buffer

    cchString  -- length of ansi buffer

Return Value:

    TRUE if string is all ASCII (characters all < 128)
    FALSE if non-ASCII characters.

--*/
{
    //
    //  loop through until hit non-ASCII character
    //

    while ( cchString-- )
    {
        if ( (UCHAR)*pchString++ < 0x80 )
        {
            continue;
        }
        return( FALSE );
    }

    return( TRUE );
}



BOOL
_fastcall
Dns_IsWideStringAscii(
    IN      PWCHAR          pwszString
    )
/*++

Routine Description:

    Check if unicode string is ASCII.
    This means all characters < 128.

    Strings without extended characters need NOT be downcased
    on the wire.  This allows us to optimize for the 99% case
    where just passing ASCII strings.

Arguments:

    pwszString -- ptr to unicode string

Return Value:

    TRUE if string is all ASCII (characters all < 128)
    FALSE if non-ASCII characters.

--*/
{
    register USHORT ch;

    //
    //  loop through until hit non-ASCII character
    //

    while ( ch = (USHORT) *pwszString++ )
    {
        if ( ch < 0x80 )
        {
            continue;
        }
        return( FALSE );
    }

    return( TRUE );
}

//
//  End utf8.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\test\adpleak.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>
#include "..\dnslib.h"


VOID
PrintIpAddress (
    IN  DWORD dwIpAddress )
{
    printf( "%d.%d.%d.%d\n",
            ((BYTE *) &dwIpAddress)[0],
            ((BYTE *) &dwIpAddress)[1],
            ((BYTE *) &dwIpAddress)[2],
            ((BYTE *) &dwIpAddress)[3] );
}

VOID
PrintServerInfo (
    IN  DNS_NAME_SERVER_INFO ServerInfo )
{
    printf( "         ipAddress : " );
    PrintIpAddress( ServerInfo.ipAddress );
    printf( "         Priority  : %d\n", ServerInfo.Priority );
    printf( "         Status    : %d\n\n", ServerInfo.Status );
}

VOID
PrintAdapterInfo (
    IN  PDNS_ADAPTER_INFO pAdapterInfo )
{
    DWORD             iter;

    printf( "      pszAdapterDomain : %s\n", pAdapterInfo->pszAdapterDomain );
    printf( "      Status           : 0x%x\n", pAdapterInfo->Status );
    printf( "      ReturnFlags      : 0x%x\n", pAdapterInfo->ReturnFlags );
    printf( "      ipLastSend       : " );
    PrintIpAddress( pAdapterInfo->ipLastSend );
    printf( "      cServerCount     : %d\n", pAdapterInfo->cServerCount );
    printf( "      cTotalListSize   : %d\n\n", pAdapterInfo->cTotalListSize );

    for ( iter = 0; iter < pAdapterInfo->cServerCount; iter++ )
    {
        printf( "      Server Info (%d)\n", iter + 1 );
        printf( "      ___________________\n" );
        PrintServerInfo( pAdapterInfo->aipServers[iter] );
    }

    printf( "\n" );
}

_cdecl
main(int argc, char **argv)
{
    PDNS_NETWORK_INFO pNetworkInfo = NULL;
    DWORD             sysVersion;
    DWORD             iter;

    Dns_InitNetworkInfo();

    sysVersion = GetVersion();

    printf( "System version is : 0x%x\n", sysVersion );

    pNetworkInfo = Dns_GetDnsNetworkInfo( TRUE, TRUE );

    if ( !pNetworkInfo )
    {
        printf( "Dns_GetDnsNetworkInfo call failed\n" );
        return(0);
    }

    printf( "Dns_GetDnsNetworkInfo returned ...\n\n" );
    printf( "   pNetworkInfo->ReturnFlags    : 0x%x\n", pNetworkInfo->ReturnFlags );
    printf( "   pNetworkInfo->pszName        : %s\n", pNetworkInfo->pszName );
    printf( "   pNetworkInfo->cAdapterCount  : %d\n", pNetworkInfo->cAdapterCount );
    printf( "   pNetworkInfo->cTotalListSize : %d\n", pNetworkInfo->cTotalListSize );

    for ( iter = 0; iter < pNetworkInfo->cAdapterCount; iter++ )
    {
        printf( "   Adapter Info (%d)\n", iter + 1 );
        printf( "   ____________________________________\n" );
        PrintAdapterInfo( pNetworkInfo->aAdapterInfoList[iter] );
    }

    system( "pause" );

    for ( iter = 0; iter < 100000; iter++ )
    {
        PDNS_NETWORK_INFO pTempNetworkInfo = pNetworkInfo;

        pNetworkInfo = Dns_CreateNetworkInfoCopy( pTempNetworkInfo );
        Dns_FreeNetworkInfo( pTempNetworkInfo );
    }

    system( "pause" );

    Dns_FreeNetworkInfo( pNetworkInfo );

    system( "pause" );

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\test\listadp.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>
#include "..\dnslib.h"


VOID
PrintIpAddress (
    IN  DWORD dwIpAddress )
{
    printf( "%d.%d.%d.%d\n",
            ((BYTE *) &dwIpAddress)[0],
            ((BYTE *) &dwIpAddress)[1],
            ((BYTE *) &dwIpAddress)[2],
            ((BYTE *) &dwIpAddress)[3] );
}

VOID
PrintSearchList (
    IN PDNS_SEARCH_LIST pSearchList )
{
    DWORD iter;

    printf( "\n   DNS Search List :\n" );

    for ( iter = 0; iter < pSearchList->cNameCount; iter++ )
    {
        printf( "      %s\n", pSearchList->aSearchListNames[iter] );
    }

    printf( "\n" );

    if ( pSearchList->pszDomainOrZoneName )
        printf( "   Primary domain name :\n      %s\n\n",
                pSearchList->pszDomainOrZoneName );
}

VOID
PrintServerInfo (
    IN  DNS_NAME_SERVER_INFO ServerInfo )
{
    printf( "         ipAddress : " );
    PrintIpAddress( ServerInfo.ipAddress );
    printf( "         Priority  : %d\n", ServerInfo.Priority );
    printf( "         Status    : %d\n\n", ServerInfo.Status );
}

VOID
PrintAdapterInfo (
    IN  PDNS_ADAPTER_INFO pAdapter )
{
    DWORD             iter;

    printf( "      %s\n", pAdapter->pszAdapterGuidName );
    printf( "   ----------------------------------------------------\n" );
    printf( "      pszAdapterDomain       : %s\n", pAdapter->pszAdapterDomain );
    if ( pAdapter->pAdapterIPAddresses )
    {
        PIP_ARRAY pIp = pAdapter->pAdapterIPAddresses;

        printf( "      Adapter Ip Address(es) :\n" );
        for ( iter = 0; iter < pIp->cAddrCount; iter++ )
        {
            printf( "                               (%d) \t", iter+1 );
            PrintIpAddress( pIp->aipAddrs[iter] );
        }
    }

    if ( pAdapter->pAdapterIPSubnetMasks )
    {
        PIP_ARRAY pMask = pAdapter->pAdapterIPSubnetMasks;

        printf( "      Adapter Ip Subnet Mask(s) :\n" );
        for ( iter = 0; iter < pMask->cAddrCount; iter++ )
        {
            printf( "                               (%d) \t", iter+1 );
            PrintIpAddress( pMask->aipAddrs[iter] );
        }
    }

    printf( "      Status                 : 0x%x\n", pAdapter->Status );
    printf( "      InfoFlags              : 0x%x\n", pAdapter->InfoFlags );
    printf( "      ReturnFlags            : 0x%x\n", pAdapter->ReturnFlags );
    printf( "      ipLastSend             : " );
    PrintIpAddress( pAdapter->ipLastSend );
    printf( "      cServerCount           : %d\n", pAdapter->cServerCount );
    printf( "      cTotalListSize         : %d\n\n", pAdapter->cTotalListSize );

    for ( iter = 0; iter < pAdapter->cServerCount; iter++ )
    {
        printf( "      ------------------------\n" );
        printf( "        DNS Server Info (%d)\n", iter + 1 );
        printf( "      ------------------------\n" );
        PrintServerInfo( pAdapter->aipServers[iter] );
    }

    printf( "\n" );
}

_cdecl
main(int argc, char **argv)
{
    PDNS_NETWORK_INFO pNetworkInfo = NULL;
    DWORD             sysVersion;
    DWORD             iter;

    DnsStartDebug( 0,
                   "listadp.flag",
                   NULL,
                   NULL,
                   0 );

    Dns_InitNetworkInfo();

    sysVersion = GetVersion();

    printf( "System version is : 0x%x\n", sysVersion );

    pNetworkInfo = Dns_GetDnsNetworkInfo( TRUE, TRUE );

    if ( !pNetworkInfo )
    {
        printf( "Dns_GetDnsNetworkInfo call failed\n" );
        return(0);
    }

    printf( "Dns_GetDnsNetworkInfo returned ...\n\n" );
    printf( "   pNetworkInfo->ReturnFlags    : 0x%x\n", pNetworkInfo->ReturnFlags );
    printf( "   pNetworkInfo->pszName        : %s\n", pNetworkInfo->pszName );

    if ( pNetworkInfo->pSearchList )
        PrintSearchList( pNetworkInfo->pSearchList );

    printf( "   pNetworkInfo->cAdapterCount  : %d\n", pNetworkInfo->cAdapterCount );
    printf( "   pNetworkInfo->cTotalListSize : %d\n\n\n", pNetworkInfo->cTotalListSize );

    for ( iter = 0; iter < pNetworkInfo->cAdapterCount; iter++ )
    {
        printf( "   ----------------------------------------------------\n" );
        printf( "   Adapter Info (%d)\n\n", iter + 1 );
        PrintAdapterInfo( pNetworkInfo->aAdapterInfoList[iter] );
    }


    Dns_FreeNetworkInfo( pNetworkInfo );

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\test\rrbld.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>
#include "..\dnslib.h"

_cdecl
main(int argc, char **argv)
{
    PDNS_RECORD pRRSet1 = NULL;
    PDNS_RECORD pRRSet2 = NULL;

    Dns_StartDebug( DNS_DBG_CONSOLE, NULL, NULL, NULL, 0 );

    pRRSet1 = Dns_RecordBuild_A( NULL,
                                 argv[1],
                                 (WORD) strtoul( argv[2], NULL, 10 ),
                                 0,
                                 0,
                                 argc - 3,
                                 &argv[3] );

    pRRSet2 = Dns_RecordCopyEx( pRRSet1, DnsCharSetUtf8, DnsCharSetUtf8 );

    Dns_RecordCompare( pRRSet1, pRRSet2 );

    DnsDbg_Record( "",
                   pRRSet2 );

    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\lib\dnslib.c ===
#include "windows.h"
#include "dnsapi.h"

DWORD   check;

VOID
OneDummyFunction(
    VOID
    )
{
    check = 1;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\dnslib\test\listip.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsapi.h>
#include "..\dnslib.h"

BOOL DisplaySystemVersion();

VOID
PrintIpAddress (
    IN  DWORD dwIpAddress )
{
    printf( " %d.%d.%d.%d\n",
            ((BYTE *) &dwIpAddress)[0],
            ((BYTE *) &dwIpAddress)[1],
            ((BYTE *) &dwIpAddress)[2],
            ((BYTE *) &dwIpAddress)[3] );
}

VOID
PrintAddressInfo (
    IN  DNS_ADDRESS_INFO AddressInfo )
{
    printf( " ipAddress  : " );
    PrintIpAddress( AddressInfo.ipAddress );
    printf( "      subnetMask : " );
    PrintIpAddress( AddressInfo.subnetMask );
    printf( "\n" );
}

_cdecl
main(int argc, char **argv)
{
    DNS_ADDRESS_INFO AddressInfoList[256];
    DWORD            Count;
    DWORD            sysVersion;
    DWORD            iter;
    PIP_ARRAY        pIp = NULL;

    DisplaySystemVersion();

    DnsStartDebug( 0,
                   "listadp.flag",
                   NULL,
                   NULL,
                   0 );

    Dns_InitNetworkInfo();

    sysVersion = GetVersion();

    printf( "System version is : 0x%x\n", sysVersion );

    printf( "\n   Calling Dns_GetLocalIpAddressArray . . . \n" );
    pIp = Dns_GetLocalIpAddressArray();

    for ( iter = 0; iter < pIp->cAddrCount; iter++ )
    {
        printf( "(%d)  ", iter+1 );
        PrintIpAddress( pIp->aipAddrs[iter] );
    }

    printf( "\n   Calling Dns_GetIpAddresses . . . \n" );
    Count = Dns_GetIpAddresses( AddressInfoList, 256 );

    if ( !Count )
    {
        printf( "\n   Dns_GetIpAddresses call failed\n" );
        return(0);
    }

    for ( iter = 0; iter < Count; iter++ )
    {
        printf( "(%d)  ", iter+1 );
        PrintAddressInfo( AddressInfoList[iter] );
    }

    return(0);
}


BOOL DisplaySystemVersion()
{
    OSVERSIONINFOEX osvi;
    BOOL bOsVersionInfoEx;

    // Try calling GetVersionEx using the OSVERSIONINFOEX structure,
    // which is supported on Windows 2000.
    //
    // If that fails, try using the OSVERSIONINFO structure.

    ZeroMemory(&osvi, sizeof(OSVERSIONINFOEX));
    osvi.dwOSVersionInfoSize = sizeof(OSVERSIONINFOEX);

    if( !(bOsVersionInfoEx = GetVersionEx ((OSVERSIONINFO *) &osvi)) )
    {
        // If OSVERSIONINFOEX doesn't work, try OSVERSIONINFO.

        osvi.dwOSVersionInfoSize = sizeof (OSVERSIONINFO);
        if (! GetVersionEx ( (OSVERSIONINFO *) &osvi) ) 
        { 
            printf( "GetVersionEx function call failed, might be Win9x?\n" );
            return FALSE;
        }
    }

    switch (osvi.dwPlatformId)
    {
       case VER_PLATFORM_WIN32_NT:

       // Test for the product.

          if ( osvi.dwMajorVersion <= 4 )
             printf( "Microsoft Windows NT ");

          if ( osvi.dwMajorVersion == 5 )
             printf ("Microsoft Windows 2000 ");

          if ( osvi.dwMajorVersion > 5 )
             printf ("Microsoft Windows (9x?) ");

       // Test for workstation versus server.

          if( bOsVersionInfoEx )
          {
             printf( "psvi.wPtroductType: %x\n", osvi.wProductType );
             if ( osvi.wProductType == VER_NT_WORKSTATION )
                printf ( "Professional " );

             if ( osvi.wProductType == VER_NT_SERVER )
                printf ( "Server " );

             if ( osvi.wProductType == VER_NT_DOMAIN_CONTROLLER )
                printf ( "Domain Controller " );
          }
          else
          {
             HKEY hKey;
             char szProductType[80];
             DWORD dwBufLen;

             RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                "SYSTEM\\CurrentControlSet\\Control\\ProductOptions",
                0, KEY_QUERY_VALUE, &hKey );
             RegQueryValueEx( hKey, "ProductType", NULL, NULL,
                (LPBYTE) szProductType, &dwBufLen);
             RegCloseKey( hKey );
             if ( lstrcmpi( "WINNT", szProductType) == 0 )
                printf( "Workstation " );
             if ( lstrcmpi( "SERVERNT", szProductType) == 0 )
                printf( "Server " );
          }

       // Display version, service pack (if any), and build number.

          printf ("version %d.%d %s (Build %d)\n",
             osvi.dwMajorVersion,
             osvi.dwMinorVersion,
             osvi.szCSDVersion,
             osvi.dwBuildNumber & 0xFFFF);

          break;

       case VER_PLATFORM_WIN32_WINDOWS:

          if ((osvi.dwMajorVersion > 4) || 
             ((osvi.dwMajorVersion == 4) && (osvi.dwMinorVersion > 0)))
          {
              printf ("Microsoft Windows 98 ");
          } 
          else printf ("Microsoft Windows 95 ");

          break;

       case VER_PLATFORM_WIN32s:

          printf ("Microsoft Win32s ");
          break;
    }
    return TRUE; 
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\client\dnsrslvr_c_stub.c ===
#include "dnsrslvr_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\client\rpcmem.c ===
/*++

Copyright (c) 1997 Microsoft Corporation

Module Name:

    rpcmem.c

Abstract:

    Domain Name System (DNS) Resolver

    Header for RPC interface to resolver.
    Domain Name System (DNS) Library

    Copy resource record routines.

Author:

    Ram Viswanathan(ramv)      April, 1997

Revision History:

    Ram Viswanathan    April 28 Created
    
    Win95 and WinNT unification. Yippee!
    Contains functions that map MIDL_user_allocate
    and MIDL_user_free

--*/
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\client\rslvrcli.h ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    rslvrcli.h

Abstract:

    Common header for Workstation client-side code.

Author:

    Glenn Curtis    (glennc)    01-Mar-1997

Environment:

    User Mode - Win32

Revision History:

--*/

#ifndef _RSLVRCLI_INCLUDED_
#define _RSLVRCLI_INCLUDED_


#endif // _RSLVRCLI_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\idl\imports.h ===
#include <windef.h>

#ifdef MIDL_PASS
#define LPSTR   [string] char *
#define LPCSTR  [string] const char *
#define LPWSTR  [string] wchar_t *

#define LPTSTR  LPWSTR
#define PWSTR   LPWSTR
#define PSTR    LPSTR

#define PVOID   void *
#define VOID    void
#endif

#include <stdarg.h>
#include <winbase.h>
#include <wingdi.h>
#include <winspool.h>
#define _INC_WINDOWS
#include <winsock2.h>
#include <wsipx.h>
#include <nspapi.h>
#include <dnsapi.h>
#include <resrpc.h>
#include "..\..\dnsapi\registry.h"
//#include <rpc.h>
//#include <rpcndr.h>
//#include <rpcasync.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\client\bind.c ===
/*++

Copyright (c) 2001-2001 Microsoft Corporation

Module Name:

    bind.c

Abstract:

    Domain Name System (DNS) Resolver

    Client RPC bind\unbind routines.
    MIDL memory allocation routines.

Author:

    Jim Gilroy      (jamesg)    April 2001

Revision History:

--*/


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>

#include <dnsrslvr.h>
#include "..\..\dnslib\local.h"     // for memory routines


//
//  Bind to remote machine
//
//  Note, there's one obvious problem with binding to a remote
//  resolver -- you have to finding the machine and this is
//  the resolver that finds the machine!!!
//
//  That pretty much suggests this would have to be TCPIP only
//  situation where you specify an IP address which would be
//  resolved in process before RPC'ing to the resolver -- otherwise
//  you're in an infinite loop.
//  Note, that doesn't mean the RPC protocol couldn't be named
//  pipes, only that the string sent in would have to be a TCPIP
//  string, so no name resolution had to take place.
//

LPWSTR  NetworkAddress = NULL;


handle_t
DNS_RPC_HANDLE_bind(
    IN      DNS_RPC_HANDLE      Reserved
    )

/*++

Routine Description:

    This routine is called from the Workstation service client stubs when
    it is necessary create an RPC binding to the server end with
    identification level of impersonation.

Arguments:

    Reserved - RPC string handle;  will be NULL unless allow remote
        access to network name

Return Value:

    The binding handle is returned to the stub routine.  If the bind is
    unsuccessful, a NULL will be returned.

--*/
{
    LPWSTR      binding = NULL;
    handle_t    bindHandle = NULL;
    RPC_STATUS  status = RPC_S_INVALID_NET_ADDR;

    //
    //  default is LPC binding
    //      - allow impersonation
    //

    status = RpcStringBindingComposeW(
                    0,
                    L"ncalrpc",
                    NULL,
                    RESOLVER_RPC_LPC_ENDPOINT_W,
                    L"Security=Impersonation Dynamic False",
                    //  NULL,   // no security
                    //  L"Security=Impersonation Static True",
                    &binding );
    
#if 0
    //  LPC fails -- try named pipe

    if ( status != NO_ERROR )
    {
        DNSDBG( ANY, ( "Binding using named pipes\n" ));

        status = RpcStringBindingComposeW(
                        0,
                        L"ncacn_np",
                        (LPWSTR) NetworkAddress,
                        RESOLVER_RPC_PIPE_NAME_W,
                        NULL,   // no security
                        //L"Security=Impersonation Dynamic False",
                        //L"Security=Impersonation Static True",
                        &binding );
    }
#endif

    if ( status != RPC_S_OK )
    {
        return NULL;
    }

    status = RpcBindingFromStringBindingW(
                binding,
                &bindHandle );

    if ( status != RPC_S_OK )
    {
        bindHandle = NULL;
    }

    if ( binding )
    {
        RpcStringFreeW( &binding );
    }

    return bindHandle;
}


VOID
DNS_RPC_HANDLE_unbind(
    IN      DNS_RPC_HANDLE      Reserved,
    IN OUT  handle_t            BindHandle
    )

/*++

Routine Description:

    This routine unbinds the identification generic handle.

Arguments:

    Reserved - RPC string handle;  will be NULL unless allow remote
        access to network name

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    RpcBindingFree( &BindHandle );
}


//
//  RPC memory routines
//
//  Use dnsapi memory routines.
//

PVOID
WINAPI
MIDL_user_allocate(
    IN      size_t          dwBytes
    )
{
    // return( ALLOCATE_HEAP( dwBytes ) );

    return  DnsApiAlloc( dwBytes );
}

VOID
WINAPI
MIDL_user_free(
    IN OUT  PVOID           pMem
    )
{
    //FREE_HEAP( pMem );

    DnsApiFree( pMem );
}

//
//  End bind.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\client\test\dns_cache.c ===
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <dnsrslvr.h>

extern LPWSTR NetworkAddress;

#define COMPUTE_STRING_HASH_2( _String, _ulHashTableSize, _lpulHash ) \
        {                                           \
            PWCHAR _p = _String;                    \
            PWCHAR _ep = _p + wcslen( _String );    \
            ULONG  h = 0;                           \
                                                    \
            while( _p < _ep )                       \
            {                                       \
                h <<= 1;                            \
                h ^= *_p++;                         \
            }                                       \
                                                    \
            *_lpulHash = h % _ulHashTableSize;      \
        }


VOID
GetStringA( char * );

VOID
GetStringW( WCHAR * );

VOID
PrintMenu( VOID );

VOID
DoFlushCache( VOID );

VOID
DoFlushCacheEntry( VOID );

VOID
DoFlushCacheEntryForType( VOID );

VOID
DoTrimCache( VOID );

VOID
DoReadCacheEntry( VOID );

VOID
DoQuery( VOID );

VOID
DoQueryThenCache( VOID );

VOID
DoDisplayCache( VOID );

VOID
DoGetAdapterInfo( VOID );

VOID
DoGetSearchList( VOID );

VOID
DoGetPrimaryDomainName( VOID );

VOID
DoGetIpAddressList( VOID );

VOID
DoGetHashTableStats( VOID );

VOID
DoGetHashTableIndex( VOID );

VOID
DoUpdateTest( VOID );

VOID
PrintServerInfo( PDNS_RPC_SERVER_INFO );

VOID
PrintIpAddress ( DWORD IpAddress );

VOID
PrintRecords (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintARecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintSOARecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintPTRRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintMINFORecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintMXRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintHINFORecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintNULLRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintWKSRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintAAAARecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintSRVRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintWINSRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
PrintWINSRRecord (
    IN  PDNS_RECORD pDnsRecord );

VOID
GetCachedData(
    IN  LPWSTR Name,
    IN  WORD   Type );

_cdecl
main(int argc, char **argv)
{
    char  String[256];
    WCHAR usNetName[100];
    LONG  cch;
    DWORD Status = NO_ERROR;

    if ( argc == 2 )
    {
        cch = MultiByteToWideChar( CP_ACP,
                                   0L,
                                   argv[1],
                                   -1,
                                   usNetName,
                                   100 );

        if ( !cch )
        {
             Status = GetLastError();
             printf("Error %ux in MultiByteToWideChar\n", Status );
             return (Status);
        }

        NetworkAddress = usNetName;
    }

Menu :

    PrintMenu();
    GetStringA( String );
    printf( "\n" );

    switch( atoi( String ) )
    {
        case 1 :
            DoFlushCache();
            break;

        case 2 :
            DoFlushCacheEntry();
            break;

        case 3 :
            DoFlushCacheEntryForType();
            break;

        case 4 :
            DoTrimCache();
            break;

        case 5 :
            DoReadCacheEntry();
            break;

        case 6 :
            DoQuery();
            break;

        case 7 :
            DoQueryThenCache();
            break;

        case 8 :
            DoDisplayCache();
            break;

        case 9 :
            DoUpdateTest();
            break;

        case 10 :
            DoGetAdapterInfo();
            break;

        case 11 :
            DoGetSearchList();
            break;

        case 12 :
            DoGetPrimaryDomainName();
            break;

        case 13 :
            DoGetIpAddressList();
            break;

        case 14 :
            DoGetHashTableStats();
            break;

        case 15 :
            DoGetHashTableIndex();
            break;

        case 16 :
            return( -1 );

        default :
            printf( "Invalid option\n" );
    }

    goto Menu;
}


VOID
GetStringA( char * String )
{
    WORD iter = 0;
    char ch = getchar();

    while ( ch != 0x0a )
    {
        String[iter] = ch;
        ch = getchar();
        iter++;
    }

    String[iter] = 0;
}


VOID
GetStringW( WCHAR * String )
{
    WORD  iter = 0;
    WCHAR ch = getchar();

    while ( ch != 0x0a )
    {
        String[iter] = ch;
        ch = getchar();
        iter++;
    }

    String[iter] = 0;
}


VOID
PrintMenu( VOID )
{
    printf( "\n" );
    printf( "------------------------------------------------------\n" );
    printf( "|         DNS Caching Resolver Service Client        |\n" );
    printf( "------------------------------------------------------\n" );
    printf( "|                                                    |\n" );
    printf( "| 1)  Flush cache                                    |\n" );
    printf( "| 2)  Flush a specific cache entry                   |\n" );
    printf( "| 3)  Flush a specific record set from a cache entry |\n" );
    printf( "| 4)  Trim cache (gets rid of records with old ttls) |\n" );
    printf( "| 5)  Read a cache entry's record set                |\n" );
    printf( "| 6)  Query records for a DNS name and type          |\n" );
    printf( "| 7)  Query records then CacheRecordSet              |\n" );
    printf( "| 8)  Display cache contents                         |\n" );
    printf( "| 9)  Perform update test with local machine account |\n" );
    printf( "| 10) Get the net adapter info for this machine      |\n" );
    printf( "| 11) Get the DNS search list for this machine       |\n" );
    printf( "| 12) Get the Primary Domain Name for this machine   |\n" );
    printf( "| 13) Get the list of IP addresses for this machine  |\n" );
    printf( "| 14) Get the DNS resolver cache statistics          |\n" );
    printf( "| 15) Compute the hash table index for a name        |\n" );
    printf( "| 16) Quit                                           |\n" );
    printf( "|                                                    |\n" );
    printf( ">>> " );
}


VOID
PrintIpAddress ( DWORD IpAddress )
{
    printf( "   %d.%d.%d.%d\n",
            ((BYTE *) &IpAddress)[0],
            ((BYTE *) &IpAddress)[1],
            ((BYTE *) &IpAddress)[2],
            ((BYTE *) &IpAddress)[3] );
}


VOID
DoFlushCache( VOID )
{
    DWORD Status = NO_ERROR;

    RpcTryExcept
    {
        CRrFlushCache( NULL );
    }
    RpcExcept(1)
    {
        Status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( Status == RPC_S_SERVER_UNAVAILABLE ||
         Status == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }
}


VOID
DoFlushCacheEntry( VOID )
{
    DWORD Status = NO_ERROR;
    WCHAR Name[256];

    printf( "Name: " );
    GetStringW( Name );
    printf( "\n" );

    RpcTryExcept
    {
        CRrFlushCacheEntry( NULL, Name );
    }
    RpcExcept(1)
    {
        Status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( Status == RPC_S_SERVER_UNAVAILABLE ||
         Status == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }
}


VOID
DoFlushCacheEntryForType( VOID )
{
    DWORD Status = NO_ERROR;
    WCHAR Name[256];
    char  TypeStr[25];
    WORD  Type;

    printf( "Name: " );
    GetStringW( Name );
    printf( "\n" );

    printf( "Type (0, 1, 2, etc): " );
    GetStringA( TypeStr );
    printf( "\n" );
    Type = atoi( TypeStr );

    RpcTryExcept
    {
        CRrFlushCacheEntryForType( NULL, Name, Type );
    }
    RpcExcept(1)
    {
        Status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( Status == RPC_S_SERVER_UNAVAILABLE ||
         Status == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }
}


VOID
DoTrimCache( VOID )
{
    DWORD Status = NO_ERROR;

    RpcTryExcept
    {
        CRrTrimCache( NULL );
    }
    RpcExcept(1)
    {
        Status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( Status == RPC_S_SERVER_UNAVAILABLE ||
         Status == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }
}


VOID
DoReadCacheEntry( VOID )
{
    DNS_STATUS  DnsStatus = NO_ERROR;
    WCHAR       Name[256];
    char        TypeStr[25];
    WORD        Type;
    PDNS_RECORD pDNSRecord = NULL;

    printf( "Name: " );
    GetStringW( Name );
    printf( "\n" );

    printf( "Type (0, 1, 2, etc): " );
    GetStringA( TypeStr );
    printf( "\n" );
    Type = atoi( TypeStr );

    RpcTryExcept
    {
        DnsStatus = CRrReadCacheEntry( NULL, Name, Type, &pDNSRecord );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "Error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    PrintRecords ( ( PDNS_RECORD ) pDNSRecord );

    DnsFreeRRSet( (PDNS_RECORD) pDNSRecord, TRUE );
}


VOID
DoQuery( VOID )
{
    DNS_STATUS  DnsStatus = NO_ERROR;
    WCHAR       Name[256];
    char        TypeStr[25];
    WORD        Type;
    PDNS_RECORD pDNSRecord = NULL;

    printf( "Name: " );
    GetStringW( Name );
    printf( "\n" );

    printf( "Type (0, 1, 2, etc): " );
    GetStringA( TypeStr );
    printf( "\n" );
    Type = atoi( TypeStr );

    RpcTryExcept
    {
        DnsStatus = CRrQuery( NULL,
                              Name,
                              Type,
                              0,
                              &pDNSRecord );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "Error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    PrintRecords ( ( PDNS_RECORD ) pDNSRecord );

    DnsFreeRRSet( (PDNS_RECORD) pDNSRecord, TRUE );
}


VOID
DoQueryThenCache( VOID )
{
    DNS_STATUS  DnsStatus = NO_ERROR;
    WCHAR       Name[256];
    char        TypeStr[25];
    WORD        Type;
    PDNS_RECORD pDNSRecord = NULL;

    printf( "Name: " );
    GetStringW( Name );
    printf( "\n" );

    printf( "Type (0, 1, 2, etc): " );
    GetStringA( TypeStr );
    printf( "\n" );
    Type = atoi( TypeStr );

    RpcTryExcept
    {
        DnsStatus = CRrQuery( NULL,
                              Name,
                              Type,
                              0,
                              &pDNSRecord );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "CRrQuery returned error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    PrintRecords ( ( PDNS_RECORD ) pDNSRecord );

    RpcTryExcept
    {
        DnsStatus = CRrCacheRecordSet( NULL,
                                       Name,
                                       Type,
                                       0,
                                       pDNSRecord );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "CRrCacheRecordSet returned error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    DnsFreeRRSet( (PDNS_RECORD) pDNSRecord, TRUE );
}


VOID
DoDisplayCache( VOID )
{
    DNS_STATUS      DnsStatus = NO_ERROR;
    WCHAR           Name[256];
    char            TypeStr[25];
    WORD            Type;
    PDNS_RPC_CACHE_TABLE pDNSCacheTable = NULL;
    PDNS_RPC_CACHE_TABLE pTempDNSCacheTable = NULL;

    RpcTryExcept
    {
        DnsStatus = CRrReadCache( NULL,
                                  &pDNSCacheTable );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "Error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    pTempDNSCacheTable = pDNSCacheTable;

    while ( pTempDNSCacheTable )
    {
        PDNS_RPC_CACHE_TABLE pNext = pTempDNSCacheTable->pNext;

        printf( "   %S\n", pTempDNSCacheTable->Name );
        printf( "   ------------------------------------------------------\n" );

        if ( pTempDNSCacheTable->Type1 != DNS_TYPE_ZERO )
        {
            printf( "      Type: %d\n", pTempDNSCacheTable->Type1 );
            GetCachedData( pTempDNSCacheTable->Name,
                           pTempDNSCacheTable->Type1 );
            printf( "\n" );
        }

        if ( pTempDNSCacheTable->Type2 != DNS_TYPE_ZERO )
        {
            printf( "      Type: %d\n", pTempDNSCacheTable->Type2 );
            GetCachedData( pTempDNSCacheTable->Name,
                           pTempDNSCacheTable->Type2 );
            printf( "\n" );
        }

        if ( pTempDNSCacheTable->Type3 != DNS_TYPE_ZERO )
        {
            printf( "      Type: %d\n", pTempDNSCacheTable->Type3 );
            GetCachedData( pTempDNSCacheTable->Name,
                           pTempDNSCacheTable->Type3 );
            printf( "\n" );
        }

        if ( pTempDNSCacheTable->Name )
            LocalFree( pTempDNSCacheTable->Name );

        LocalFree( pTempDNSCacheTable );

        pTempDNSCacheTable = pNext;
    }
}


VOID
DoUpdateTest( VOID )
{
    DNS_STATUS  DnsStatus = NO_ERROR;
    WCHAR       Name[256];
    char        lpAddress[256];
    char        TypeStr[25];
    WORD        Type;
    PDNS_RECORD pDNSRecord = NULL;
    PDNS_RECORD pTempDNSRecord = NULL;
    BYTE        Part1, Part2, Part3, Part4;
    IP_ADDRESS  Address;
    LPSTR       lpTemp = NULL;

    printf( "Name: " );
    GetStringW( Name );
    printf( "\n" );

    printf( "Server IP: " );
    GetStringA( lpAddress );
    printf( "\n" );

    lpTemp = strtok( lpAddress, "." );
    Part1 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part2 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part3 = atoi( lpTemp );
    lpTemp = strtok( NULL, "." );
    Part4 = atoi( lpTemp );

    ((BYTE *) &Address)[0] = Part1;
    ((BYTE *) &Address)[1] = Part2;
    ((BYTE *) &Address)[2] = Part3;
    ((BYTE *) &Address)[3] = Part4;

    printf( "\n  Sendine update test for name (%S) to server (%d.%d.%d.%d) ...\n\n",
            Name,
            Part1,
            Part2,
            Part3,
            Part4 );

    RpcTryExcept
    {
        DnsStatus = CRrUpdateTest( NULL,
                                   Name,
                                   0,
                                   Address );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "Error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }
}


VOID
DoGetAdapterInfo( VOID )
{
    DNS_STATUS      DnsStatus = NO_ERROR;
    PDNS_RPC_ADAPTER_INFO pAdapterInfo = NULL;
    PDNS_RPC_ADAPTER_INFO pTempAdapterInfo;
    DWORD           iter = 1;

    RpcTryExcept
    {
        CRrGetAdapterInfo( NULL, &pAdapterInfo );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "Error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    pTempAdapterInfo = pAdapterInfo;

    while ( pTempAdapterInfo )
    {
        printf( "   Net Adapter Info (%d):\n", iter );
        printf( "   -------------------------------------\n" );
        printf( "      pszAdapterDomainName : %s\n",
                pTempAdapterInfo->pszAdapterDomainName );
        printf( "      Flags : %d\n",
                pTempAdapterInfo->Flags );
        if ( pTempAdapterInfo->pServerInfo )
            PrintServerInfo( pTempAdapterInfo->pServerInfo );
        pTempAdapterInfo = pTempAdapterInfo->pNext;
        iter++;
    }
}


VOID
DoGetSearchList( VOID )
{
    DNS_STATUS           DnsStatus = NO_ERROR;
    PDNS_RPC_SEARCH_LIST pSearchList = NULL;
    PDNS_RPC_SEARCH_LIST pTempSearchList;

    RpcTryExcept
    {
        CRrGetSearchList( NULL, &pSearchList );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "Error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    pTempSearchList = pSearchList;

    printf( "   Search List:\n" );
    printf( "   -------------------------------------\n" );
    while ( pTempSearchList )
    {
        printf( "       pszName :       %s\n", pTempSearchList->pszName );
        pTempSearchList = pTempSearchList->pNext;
    }
}


VOID
DoGetPrimaryDomainName( VOID )
{
    DNS_STATUS DnsStatus = NO_ERROR;
    LPSTR      PrimaryDomainName = NULL;

    RpcTryExcept
    {
        CRrGetPrimaryDomainName( NULL, &PrimaryDomainName );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "Error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    printf( "   Primary Domain Name : %s\n", PrimaryDomainName );
}


VOID
DoGetIpAddressList( VOID )
{
    DNS_STATUS DnsStatus = NO_ERROR;
    PDNS_IP_ADDR_LIST pIpAddrList = NULL;
    DWORD      Count;
    DWORD      iter;

    RpcTryExcept
    {
        Count = CRrGetIpAddressList( NULL, &pIpAddrList );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "Error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    if ( Count && pIpAddrList )
    {
        printf( "%d Ip Addresses returned :\n", Count );

        for ( iter = 0; iter < Count; iter++ )
        {
            printf( "(%d) \t", iter+1 );
            PrintIpAddress( pIpAddrList->AddressArray[iter].ipAddress );
            printf( "    \t" );
            PrintIpAddress( pIpAddrList->AddressArray[iter].subnetMask );
        }

        LocalFree( pIpAddrList );
    }
    else
    {
        printf( "No Ip Addresses found.\n" );
    }
}


VOID
DoGetHashTableStats( VOID )
{
    DNS_STATUS       Status = NO_ERROR;
    DWORD            CacheHashTableSize;
    DWORD            CacheHashTableBucketSize;
    DWORD            NumberOfCacheEntries;
    DWORD            NumberOfRecords;
    DWORD            NumberOfExpiredRecords;
    PDNS_STATS_TABLE pStatsTable = NULL;
    PDNS_STATS_TABLE pTempRow = NULL;

    RpcTryExcept
    {
        Status = CRrGetHashTableStats( NULL,
                                       &CacheHashTableSize,
                                       &CacheHashTableBucketSize,
                                       &NumberOfCacheEntries,
                                       &NumberOfRecords,
                                       &NumberOfExpiredRecords,
                                       &pStatsTable );
    }
    RpcExcept(1)
    {
        Status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( Status == RPC_S_SERVER_UNAVAILABLE ||
         Status == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( Status )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( Status );

        printf( "Error: 0x%.8x (%s)\n",
                Status, ErrorString );
        return;
    }

    printf( "   DNS Cache Hash Table Statistics\n" );
    printf( "   -------------------------------------\n" );
    printf( "       Cache hash table size        : %d\n",
            CacheHashTableSize );
    printf( "       Cache hash table bucket size : %d\n",
            CacheHashTableBucketSize );
    printf( "       Number of cache entries      : %d\n",
            NumberOfCacheEntries );
    printf( "       Number of RR sets            : %d\n",
            NumberOfRecords );
    printf( "       Number of expired RR sets    : %d\n",
            NumberOfExpiredRecords );
    printf( "\n   DNS Cache Hast Table Histogram\n" );
    printf( "   -------------------------------------\n" );

    pTempRow = pStatsTable;

    while ( pTempRow )
    {
        PDWORD_LIST_ITEM pTempItem = pTempRow->pListItem;
        DWORD            count = 0;
        DWORD            iter;

        printf( "  |" );

        while ( pTempItem )
        {
            for ( iter = 0; iter < pTempItem->Value2; iter++ )
                printf( "x" );

            count += pTempItem->Value1 - pTempItem->Value2;
            pTempItem = pTempItem->pNext;
        }

        for ( iter = 0; iter < count; iter++ )
            printf( "*" );

        printf( "\n" );

        pTempRow = pTempRow->pNext;
    }
}


VOID
DoGetHashTableIndex( VOID )
{
    DWORD            Status = NO_ERROR;
    WCHAR            Name[256];
    DWORD            index;
    DWORD            CacheHashTableSize;
    DWORD            CacheHashTableBucketSize;
    DWORD            NumberOfCacheEntries;
    DWORD            NumberOfRecords;
    DWORD            NumberOfExpiredRecords;
    PDNS_STATS_TABLE pStatsTable = NULL;
    PDNS_STATS_TABLE pTempRow = NULL;

    RpcTryExcept
    {
        Status = CRrGetHashTableStats( NULL,
                                       &CacheHashTableSize,
                                       &CacheHashTableBucketSize,
                                       &NumberOfCacheEntries,
                                       &NumberOfRecords,
                                       &NumberOfExpiredRecords,
                                       &pStatsTable );
    }
    RpcExcept(1)
    {
        Status = RpcExceptionCode();
    }
    RpcEndExcept

    if ( Status == RPC_S_SERVER_UNAVAILABLE ||
         Status == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( Status )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( Status );

        printf( "Error: 0x%.8x (%s)\n",
                Status, ErrorString );
        return;
    }

    printf( "   CacheHashTableSize : %d\n", CacheHashTableSize );
    printf( "   CacheHashTableBucketSize : %d\n", CacheHashTableBucketSize );
    printf( "   NumberOfCacheEntries : %d\n", NumberOfCacheEntries );
    printf( "   NumberOfRecords : %d\n", NumberOfRecords );
    printf( "   NumberOfExpiredRecords : %d\n", NumberOfExpiredRecords );

    printf( "Name: " );
    GetStringW( Name );
    printf( "\n" );

    COMPUTE_STRING_HASH_2( Name, CacheHashTableSize, &index );

    printf( "   Hash table index for %S is : %d\n",
            Name,
            index );

    pTempRow = pStatsTable;
}


VOID
PrintServerInfo( IN  PDNS_RPC_SERVER_INFO pServerInfo )
{
    PDNS_RPC_SERVER_INFO pTempServerInfo = pServerInfo;
    DWORD                iter = 1;

    while ( pTempServerInfo )
    {
        printf( "       Server Info (%d):\n", iter );
        printf( "       -------------------------------------\n" );
        printf( "           ipAddress : %d.%d.%d.%d\n",
                ((BYTE *) &pTempServerInfo->ipAddress)[0],
                ((BYTE *) &pTempServerInfo->ipAddress)[1],
                ((BYTE *) &pTempServerInfo->ipAddress)[2],
                ((BYTE *) &pTempServerInfo->ipAddress)[3] );
        printf( "           Status : 0x%x\n", pTempServerInfo->Status );
        printf( "           Priority : %d\n", pTempServerInfo->Priority );
        pTempServerInfo = pTempServerInfo->pNext;
        iter++;
    }
}


VOID
PrintRecords (
    IN  PDNS_RECORD pDnsRecord )
{
    PDNS_RECORD pTemp = pDnsRecord;

    while ( pTemp )
    {
        PrintRecord( pTemp );
        pTemp = pTemp->pNext;
    }
}


VOID
PrintRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    if ( ! pDnsRecord )
        return;

    printf( "      Record Name :  %S\n", pDnsRecord->pName );
    printf( "      Record Type :  %d\n", pDnsRecord->wType );
    printf( "      Time To Live : %d (seconds)\n", pDnsRecord->dwTtl );
    printf( "      Data Length :  %d\n", pDnsRecord->wDataLength );

    if ( pDnsRecord->Flags.S.Section == DNSREC_QUESTION )
        printf( "      Section :      Question Record\n" );
    else if ( pDnsRecord->Flags.S.Section == DNSREC_ANSWER )
        printf( "      Section :      Answer Record\n" );
    else if ( pDnsRecord->Flags.S.Section == DNSREC_AUTHORITY )
        printf( "      Section :      Authority Record\n" );
    else
        printf( "      Section :      Additional Record\n" );

    switch( pDnsRecord->wType )
    {
        case DNS_TYPE_A :
            PrintARecord( pDnsRecord );
            break;

        case DNS_TYPE_SOA :
            PrintSOARecord( pDnsRecord );
            break;

        case DNS_TYPE_PTR :
        case DNS_TYPE_NS :
        case DNS_TYPE_CNAME :
        case DNS_TYPE_MB :
        case DNS_TYPE_MD :
        case DNS_TYPE_MF :
        case DNS_TYPE_MG :
        case DNS_TYPE_MR :
            PrintPTRRecord( pDnsRecord );
            break;

        case DNS_TYPE_MINFO :
        case DNS_TYPE_RP :
            PrintMINFORecord( pDnsRecord );
            break;

        case DNS_TYPE_MX :
        case DNS_TYPE_AFSDB :
        case DNS_TYPE_RT :
            PrintMXRecord( pDnsRecord );
            break;

        case DNS_TYPE_HINFO :
        case DNS_TYPE_ISDN :
        case DNS_TYPE_TEXT :
        case DNS_TYPE_X25 :
            PrintHINFORecord( pDnsRecord );
            break;

        case DNS_TYPE_NULL :
            PrintNULLRecord( pDnsRecord );
            break;

        case DNS_TYPE_WKS :
            PrintWKSRecord( pDnsRecord );
            break;

        case DNS_TYPE_AAAA :
            PrintAAAARecord( pDnsRecord );
            break;

        case DNS_TYPE_SRV :
            PrintSRVRecord( pDnsRecord );
            break;

        case DNS_TYPE_WINS :
            PrintWINSRecord( pDnsRecord );
            break;

        case DNS_TYPE_NBSTAT :
            PrintWINSRRecord( pDnsRecord );
            break;

        default :
            printf( "Don't know how to print record type %d\n", pDnsRecord->wType );
    }
}


VOID
PrintARecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      A record :\n" );
    printf( "                     ipAddress = %d.%d.%d.%d\n",
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[0],
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[1],
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[2],
            ((BYTE *) &pDnsRecord->Data.A.ipAddress)[3] );
    printf( "\n" );
}


VOID
PrintSOARecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      SOA record :\n" );
    printf( "                     pNamePrimaryServer = %S\n",
            pDnsRecord->Data.SOA.pNamePrimaryServer );
    printf( "                     pNameAdministrator = %S\n",
            pDnsRecord->Data.SOA.pNameAdministrator );
    printf( "                     dwSerialNo        = %d\n",
            pDnsRecord->Data.SOA.dwSerialNo );
    printf( "                     dwRefresh         = %d\n",
            pDnsRecord->Data.SOA.dwRefresh );
    printf( "                     dwRetry           = %d\n",
            pDnsRecord->Data.SOA.dwRetry );
    printf( "                     dwExpire          = %d\n",
            pDnsRecord->Data.SOA.dwExpire );
    printf( "                     dwDefaultTtl      = %d\n",
            pDnsRecord->Data.SOA.dwDefaultTtl );
    printf( "\n" );
}


VOID
PrintPTRRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      PTR, NS, CNAME, MB, MD, MF, MG, MR record :\n" );
    printf( "                     nameHost          = %S\n",
            pDnsRecord->Data.PTR.pNameHost );
    printf( "\n" );
}


VOID
PrintMINFORecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      MINFO, RP record :\n" );
    printf( "                     pNameMailbox       = %S\n",
            pDnsRecord->Data.MINFO.pNameMailbox );
    printf( "                     pNameErrorsMailbox = %S\n",
            pDnsRecord->Data.MINFO.pNameErrorsMailbox );
    printf( "\n" );
}


VOID
PrintMXRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      MX, AFSDB, RT record :\n" );
    printf( "                     pNameExchange      = %S\n",
            pDnsRecord->Data.MX.pNameExchange );
    printf( "                     wPreference       = %d\n",
            pDnsRecord->Data.MX.wPreference );
    printf( "                     Pad               = %d\n",
            pDnsRecord->Data.MX.Pad );
    printf( "\n" );
}


VOID
PrintHINFORecord (
    IN  PDNS_RECORD pDnsRecord )
{
    DWORD iter;

    printf( "      HINFO, ISDN, TEXT, X25 record :\n" );
    printf( "                     dwStringCount     = %d\n",
            pDnsRecord->Data.HINFO.dwStringCount );
    for ( iter = 0; iter < pDnsRecord->Data.HINFO.dwStringCount; iter ++ )
    {
        printf( "                     pStringArray[%d] = %S\n",
                iter,
                pDnsRecord->Data.HINFO.pStringArray[iter] );
    }
    printf( "\n" );
}


VOID
PrintNULLRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      NULL record :\n" );
    printf( "\n" );
}


VOID
PrintWKSRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      WKS record :\n" );
    printf( "                     ipAddress = %d.%d.%d.%d\n",
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[0],
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[1],
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[2],
            ((BYTE *) &pDnsRecord->Data.WKS.ipAddress)[3] );
    printf( "                     chProtocol        = %d\n",
            pDnsRecord->Data.WKS.chProtocol );
    printf( "\n" );
}


VOID
PrintAAAARecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      AAAA record :\n" );
    printf( "                     ipAddress = %d.%d.%d.%d\n",
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[0],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[1],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[2],
            ((BYTE *) &pDnsRecord->Data.AAAA.ipv6Address)[3] );
    printf( "\n" );
}


VOID
PrintSRVRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      SRV record :\n" );
    printf( "                     pNameTarget        = %S\n",
            pDnsRecord->Data.SRV.pNameTarget );
    printf( "                     wPriority         = %d\n",
            pDnsRecord->Data.SRV.wPriority );
    printf( "                     wWeight           = %d\n",
            pDnsRecord->Data.SRV.wWeight );
    printf( "                     wPort             = %d\n",
            pDnsRecord->Data.SRV.wPort );
    printf( "                     Pad               = %d\n",
            pDnsRecord->Data.SRV.Pad );
    printf( "\n" );
}


VOID
PrintWINSRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      WINS record :\n" );
    printf( "                     dwMappingFlag     = %d\n",
            pDnsRecord->Data.WINS.dwMappingFlag );
    printf( "                     dwLookupTimeout   = %d\n",
            pDnsRecord->Data.WINS.dwLookupTimeout );
    printf( "                     dwCacheTimeout    = %d\n",
            pDnsRecord->Data.WINS.dwCacheTimeout );
    printf( "                     cWinsServerCount  = %d\n",
            pDnsRecord->Data.WINS.cWinsServerCount );
    printf( "\n" );
}


VOID
PrintWINSRRecord (
    IN  PDNS_RECORD pDnsRecord )
{
    printf( "      NBSTAT record :\n" );
    printf( "                     dwMappingFlag     = %d\n",
            pDnsRecord->Data.WINSR.dwMappingFlag );
    printf( "                     dwLookupTimeout   = %d\n",
            pDnsRecord->Data.WINSR.dwLookupTimeout );
    printf( "                     dwCacheTimeout    = %d\n",
            pDnsRecord->Data.WINSR.dwCacheTimeout );
    printf( "                     pNameResultDomain  = %S\n",
            pDnsRecord->Data.WINSR.pNameResultDomain );
    printf( "\n" );
}


VOID
GetCachedData(
    IN  LPWSTR Name,
    IN  WORD   Type )
{
    PDNS_RECORD pDNSRecord = NULL;
    DNS_STATUS  DnsStatus = NO_ERROR;

    RpcTryExcept
    {
        DnsStatus = CRrReadCacheEntry( NULL, Name, Type, &pDNSRecord );
    }
    RpcExcept(1)
    {
        DnsStatus = RpcExceptionCode();
    }
    RpcEndExcept

    if ( DnsStatus == RPC_S_SERVER_UNAVAILABLE ||
         DnsStatus == RPC_S_UNKNOWN_IF )
    {
        printf( "Error: DNS Caching Resolver Service is not running\n" );
        return;
    }

    if ( DnsStatus )
    {
        LPSTR ErrorString = DnsStatusToErrorString_A( DnsStatus );

        printf( "Error: 0x%.8x (%s)\n",
                DnsStatus, ErrorString );
        return;
    }

    PrintRecords ( ( PDNS_RECORD ) pDNSRecord );

    DnsFreeRRSet( (PDNS_RECORD) pDNSRecord, TRUE );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\idl\resrpc.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    resrpc.h

Abstract:

    Domain Name System (DNS) Resolver

    Header for RPC interface to resolver.

Author:

    Jim Gilroy (jamesg)         July 2000

Revision History:

--*/


#ifndef _RESRPC_INCLUDED_
#define _RESRPC_INCLUDED_

//#ifndef _DNSAPI_INCLUDED_
#define DNS_INTERNAL
#include <dnsapi.h>
#include <dnslib.h>
#include <dnsip.h>
//#endif

//
//  Resolver service info
//
//  Note:  this stuff is not required for MIDL pass generation
//      but it is a convenient place to put information
//      that will be used on both server and client sides.
//

#define DNS_RESOLVER_SERVICE            L"dnscache"

#define RESOLVER_DLL                    TEXT("dnsrslvr.dll")
#define RESOLVER_INTERFACE_NAME_A       "DNSResolver"
#define RESOLVER_INTERFACE_NAME_W       L"DNSResolver"

#define RESOLVER_RPC_PIPE_NAME_W        (L"\\PIPE\\DNSRESOLVER")
#define RESOLVER_RPC_LPC_ENDPOINT_W     (L"DNSResolver")
#define RESOLVER_RPC_TCP_PORT_W         (L"")

#define RESOLVER_RPC_USE_LPC            0x1
#define RESOLVER_RPC_USE_NAMED_PIPE     0x2
#define RESOLVER_RPC_USE_TCPIP          0x4
#define RESOLVER_RPC_USE_ALL_PROTOCOLS  0xffffffff


//
//  Resolver proxy name (NULL by default).
//
//  This is used in client stuffs for binding and
//  referenced (and settable) in dnsapi.dll caller.
//

#ifndef MIDL_PASS
extern  LPWSTR  NetworkAddress;
#endif



//
//  DNS_RECORD
//
//  Note: defintion in windns.h is not MIDL_PASS compliant
//  because MIDL does not like union with variable lenght types
//

//
//  MIDL is not happy about unions
//  Define the union explicitly with the switch
//

#ifdef MIDL_PASS

typedef [switch_type(WORD)] union _DNS_RECORD_DATA_TYPES
{
    [case(DNS_TYPE_A)]      DNS_A_DATA      A;

    [case(DNS_TYPE_SOA)]    DNS_SOA_DATAW   SOA;

    [case(DNS_TYPE_PTR,
          DNS_TYPE_NS,
          DNS_TYPE_CNAME,
          DNS_TYPE_MB,
          DNS_TYPE_MD,
          DNS_TYPE_MF,
          DNS_TYPE_MG,
          DNS_TYPE_MR)]     DNS_PTR_DATAW   PTR;

    [case(DNS_TYPE_MINFO,
          DNS_TYPE_RP)]     DNS_MINFO_DATAW MINFO;

    [case(DNS_TYPE_MX,
          DNS_TYPE_AFSDB,
          DNS_TYPE_RT)]     DNS_MX_DATAW    MX;

#if 0
    //  RPC is not able to handle a proper TXT record definition
    //  note:  that if other types are needed they are fixed
    //      (or semi-fixed) size and may be accomodated easily
    [case(DNS_TYPE_HINFO,
          DNS_TYPE_ISDN,
          DNS_TYPE_TEXT,
          DNS_TYPE_X25)]    DNS_TXT_DATAW   TXT;

    [case(DNS_TYPE_NULL)]   DNS_NULL_DATA   Null;
    [case(DNS_TYPE_WKS)]    DNS_WKS_DATA    WKS;
    [case(DNS_TYPE_KEY)]    DNS_KEY_DATAW   KEY;
    [case(DNS_TYPE_SIG)]    DNS_SIG_DATAW   SIG;
    [case(DNS_TYPE_TKEY)]   DNS_TKEY_DATAW  TKEY;
    [case(DNS_TYPE_TSIG)]   DNS_TSIG_DATAW  TSIG;
    [case(DNS_TYPE_WINS)]   DNS_WINS_DATA   WINS;
    [case(DNS_TYPE_NBSTAT)] DNS_WINSR_DATAW WINSR;
#endif

    [case(DNS_TYPE_AAAA)]   DNS_AAAA_DATA   AAAA;
    [case(DNS_TYPE_SRV)]    DNS_SRV_DATAW   SRV;
    [case(DNS_TYPE_ATMA)]   DNS_ATMA_DATA   ATMA;

    //
    //  DCR_QUESTION:  need default block in record data def?
    //
    //[default] ;
}
DNS_RECORD_DATA_TYPES;


//
//  Record \ RR set structure
//
//  Note:   The dwReserved flag serves to insure that the substructures
//          start on 64-bit boundaries.  Since adding the LONGLONG to
//          TSIG structure the compiler wants to start them there anyway
//          (to 64-align).  This insures that no matter what data fields
//          are present we are properly 64-aligned.
//
//          Do NOT pack this structure, as the substructures to be 64-aligned
//          for Win64.
//

#undef  DNS_RECORD
#undef  PDNS_RECORD

typedef struct _DnsRecord
{
    struct _DnsRecord * pNext;
    PWSTR               pName;
    WORD                wType;
    WORD                wDataLength; // Not referenced for DNS record types
                                     // defined above.
    DWORD               Flags;
    DWORD               dwTtl;
    DWORD               dwReserved;
    [switch_is(wType)] DNS_RECORD_DATA_TYPES Data;
}
DNS_RECORD, *PDNS_RECORD;

//
//  Header or fixed size of DNS_RECORD
//

#define DNS_RECORD_FIXED_SIZE       FIELD_OFFSET( DNS_RECORD, Data )
#define SIZEOF_DNS_RECORD_HEADER    DNS_RECORD_FIXED_SIZE

#endif  // MIDL_PASS



//
//  RPC-able DNS type definitions
//
//  In addition to windns.h \ dnsapi.h types.
//  See note below, we do have some multiple definition
//  problems with dnslib.h types.
//

//
//  Cache stuff -- left over from Glenn
//

typedef struct _DWORD_LIST_ITEM_
{
    struct _DWORD_LIST_ITEM_ * pNext;
    DWORD                      Value1;
    DWORD                      Value2;
}
DWORD_LIST_ITEM, *PDWORD_LIST_ITEM;


typedef struct _DNS_STATS_TABLE_
{
    struct _DNS_STATS_TABLE_ * pNext;
    PDWORD_LIST_ITEM           pListItem;
}
DNS_STATS_TABLE, *PDNS_STATS_TABLE;


typedef struct _DNS_RPC_CACHE_TABLE_
{
    struct _DNS_RPC_CACHE_TABLE_ * pNext;
    PWSTR                          Name;
    WORD                           Type1;
    WORD                           Type2;
    WORD                           Type3;
}
DNS_RPC_CACHE_TABLE, *PDNS_RPC_CACHE_TABLE;


//
//  Most of the resolver interface is poorly designed or
//  useless.  For instance there is NO reason to have
//  turned any of the above into linked lists.
//
//  We simply need definitions that are MIDL_PASS aware.
//  This should sit in a common header and be picked up
//  by dnslib.h.   This must wait until dnslib.h is
//  private again OR we separate out the private stuff
//  like this in some fashion.
//
//  Note, taking this private should also involve rename,
//  the PUBLIC structs are obviously the one's that should
//  have the "DNS" tag.  (Amazing.)
//

typedef struct _DnsAdapter
{
    PWSTR           pszAdapterGuidName;
    PWSTR           pszAdapterDomain;
    PDNS_ADDR_ARRAY pLocalAddrs;
    PDNS_ADDR_ARRAY pDnsAddrs;
    DWORD           InterfaceIndex;
    DWORD           InterfaceIndex6;
    DWORD           InfoFlags;
    DWORD           Status;
    DWORD           RunFlags;
    DWORD           Site;
}
DNS_ADAPTER, *PDNS_ADAPTER;

typedef struct _SearchName
{
    PWSTR           pszName;
    DWORD           Flags;
}
SEARCH_NAME, *PSEARCH_NAME;

typedef struct _SearchList
{
    DWORD           NameCount;
    DWORD           MaxNameCount;
    DWORD           CurrentNameIndex;
    DWORD           ReservedPad;
#ifdef MIDL_PASS
    [size_is(MaxNameCount)] SEARCH_NAME SearchNameArray[];
#else
    SEARCH_NAME     SearchNameArray[1];
#endif
}
SEARCH_LIST, *PSEARCH_LIST;

typedef struct _DnsNetInfo
{
    PWSTR           pszDomainName;
    PWSTR           pszHostName;
    PSEARCH_LIST    pSearchList;
    DWORD           TimeStamp;
    DWORD           InfoFlags;
    DWORD           ReturnFlags;
    DWORD           Tag;
    DWORD           Reserved;
    DWORD           AdapterIndex;
    DWORD           AdapterCount;
    DWORD           MaxAdapterCount;

#ifdef MIDL_PASS
    [size_is(MaxAdapterCount)] DNS_ADAPTER  AdapterArray[];
#else
    DNS_ADAPTER     AdapterArray[1];
#endif
}
DNS_NETINFO, *PDNS_NETINFO;



//
//  Environment variable reading (dnsapi\envar.c)
//

typedef struct _EnvarDwordInfo
{
    DWORD   Id;
    DWORD   Value;
    BOOL    fFound;
}
ENVAR_DWORD_INFO, *PENVAR_DWORD_INFO;

//
//  Query blob
//

typedef struct _RpcQueryBlob
{
    PWSTR           pName;
    WORD            wType;
    DWORD           Flags;
    DNS_STATUS      Status;
    PDNS_RECORD     pRecords;
}
RPC_QUERY_BLOB, *PRPC_QUERY_BLOB;

//
//  Cache Enumeration
//

typedef struct
{
    DWORD           EnumTag;
    DWORD           MaxCount;
    WORD            Type;
    DWORD           Flags;
    PWSTR           pName;
    PWSTR           pNameFilter;
}
DNS_CACHE_ENUM_REQUEST, *PDNS_CACHE_ENUM_REQUEST;

typedef struct _DnsCacheEntry
{
    PWSTR           pName;
    PDNS_RECORD     pRecords;
    DWORD           Flags;
    WORD            wType;
    WORD            wPad;
}
DNS_CACHE_ENTRY, *PDNS_CACHE_ENTRY;

typedef struct _DnsCacheEnum
{
    DWORD               TotalCount;
    DWORD               EnumTagStart;
    DWORD               EnumTagStop;
    DWORD               EnumCount;
#ifdef MIDL_PASS
    [size_is(EnumCount)]    DNS_CACHE_ENTRY EntryArray[];
#else
    DNS_CACHE_ENTRY     EntryArray[1];
#endif
}
DNS_CACHE_ENUM, *PDNS_CACHE_ENUM;


#endif // _RESRPC_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\server\config.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    config.c

Abstract:

    DNS Resolver Service.

    Network configuration info

Author:

    Jim Gilroy  (jamesg)    March 2000

Revision History:

--*/


#include "local.h"


//
//  Network info
//

PDNS_NETINFO        g_NetworkInfo = NULL;
DWORD               g_TimeOfLastPnPUpdate;
DWORD               g_NetInfoTag = 0;
DWORD               g_ResetServerPriorityTime = 0;

//
//  Network failure caching
//

DWORD               g_NetFailureTime;
DNS_STATUS          g_NetFailureStatus;
DWORD               g_TimedOutAdapterTime;
BOOL                g_fTimedOutAdapter;
DNS_STATUS          g_PreviousNetFailureStatus;
DWORD               g_MessagePopupStrikes;
DWORD               g_NumberOfMessagePopups;

//
//  Config globals
//
//  DCR:  eliminate useless config globals
//

DWORD   g_HashTableSize;
DWORD   g_MaxSOACacheEntryTtlLimit;
DWORD   g_NegativeSOACacheTime;
DWORD   g_NetFailureCacheTime;
DWORD   g_MessagePopupLimit;


//
//  Network Info reread time
//      - currently fifteen minutes
//

#define NETWORK_INFO_REREAD_TIME        (900)


//
//  Locking
//

CRITICAL_SECTION        NetinfoCS;
TIMED_LOCK              NetinfoBuildLock;

#define LOCK_NETINFO()          EnterCriticalSection( &NetinfoCS )
#define UNLOCK_NETINFO()        LeaveCriticalSection( &NetinfoCS )

#define LOCK_NETINFO_BUILD()    TimedLock_Enter( &NetinfoBuildLock, 5000 )
#define UNLOCK_NETINFO_BUILD()  TimedLock_Leave( &NetinfoBuildLock )




//
//  Network info configuration
//

VOID
UpdateNetworkInfo(
    IN      PDNS_NETINFO    pNetInfo     OPTIONAL
    )
/*++

Routine Description:

    Update network info global.

Arguments:

    pNetInfo -- desired network info;  if NULL clear cached copy

Return Value:

    None

--*/
{
    PDNS_NETINFO    poldInfo = NULL;

    DNSDBG( TRACE, (
        "UpdateNetworkInfo( %p )\n",
        pNetInfo ));

    LOCK_NETINFO();

    //
    //  cache previous netinfo to pickup server priority changes
    //      - don't cache if not same version
    //          - kills copy that was created before last build
    //          - kills copy that was before last PnP (cache clear)
    //      - don't cache if never reset priorities
    //

    if ( pNetInfo )
    {
        if ( pNetInfo->Tag != g_NetInfoTag )
        {
            DNSDBG( INIT, (
                "Skip netinfo update -- previous version"
                "\tptr              = %p\n"
                "\tversion          = %d\n"
                "\tcurrent version  = %d\n",
                pNetInfo,
                pNetInfo->Tag,
                g_NetInfoTag ));
            poldInfo = pNetInfo;
            DNS_ASSERT( pNetInfo->Tag < g_NetInfoTag );
            goto Cleanup;
        }

        if ( g_ServerPriorityTimeLimit == 0 )
        {
            DNSDBG( INIT, (
                "Skip netinfo update -- no priority reset!\n" ));
            poldInfo = pNetInfo;
            goto Cleanup;
        }

        NetInfo_Clean(
            pNetInfo,
            CLEAR_LEVEL_QUERY
            );
    }

    //
    //  no netinfo means clear cached copy
    //      - push up tag count, so no copy out for update can
    //      come back and be reused through path above

    else
    {
        g_NetInfoTag++;
    }

    //
    //  swap -- caches copy or clears
    //

    poldInfo = g_NetworkInfo;
    g_NetworkInfo = pNetInfo;


Cleanup:

    UNLOCK_NETINFO();
    
    NetInfo_Free( poldInfo );
}



PDNS_NETINFO         
GrabNetworkInfo(
    VOID
    )
/*++

Routine Description:

    Get copy of network info.

    Named it "Grab" to avoid confusion with GetNetworkInfo()
    in dnsapi.dll.

Arguments:

    None

Return Value:

    Ptr to copy of network info (caller must free).
    NULL on error.

--*/
{
    PDNS_NETINFO    poldInfo = NULL;
    PDNS_NETINFO    pnewInfo = NULL;
    DWORD           currentTime = Dns_GetCurrentTimeInSeconds();
    DWORD           newTag;
    BOOL            fbuildLock = FALSE;
    BOOL            fnetLock = FALSE;

    DNSDBG( TRACE, ( "GrabNetworkInfo()\n" ));

    //
    //  Locking note:
    //
    //  Can not hold a single NET_LIST lock during netinfo build.
    //      - IpHlpApi doing routing info call RPCs to router which can
    //      depend on PnP notifications, which in turn can be causing calls
    //      back into resolver indicating config change;  overall the loss
    //      of control is too large
    //
    //  There are ways to make the config change issue go away (ex setting
    //  some sort of "invalid" flag under interlock), but they basically boil
    //  down to introducing some other sort of lock. 
    //
    //  The bottom line is there are TWO SEPARATE issues here:
    //
    //      1)  Access to cache netinfo, which may be invalidated.
    //      2)  Single build of netinfo for perf.
    //
    //  Implementation wise, you can have the invalidation\clear under a
    //  separate interlock, and thus have a single lock for copy-access\build,
    //  but the reality is the same.
    //
    //
    //  Algorithm:
    //      - check for valid cached copy
    //          => found, out
    //      - get build lock
    //      - check again for valid cached copy
    //          => found, out
    //      - build
    //      - cache new netinfo
    //      - release build lock
    //
    //  Where the check and cache work are independently locked with the shorter
    //  duration NET_LIST lock, which simply protects access to the cached global
    //  (and hence is also used in invalidation and update).
    //



    //
    //  check for valid cached netinfo
    //      - within forced reread time
    //      - reset server priorities if 
    //
    //  DCR:  priority reset time should move into netinfo blob
    //
    //  for perf we do this BEFORE entering build lock
    //  then again once have build lock
    //

    while ( 1 )
    {
        LOCK_NETINFO();
        fnetLock = TRUE;
    
        if ( g_NetworkInfo &&
             g_NetworkInfo->TimeStamp + NETWORK_INFO_REREAD_TIME > currentTime )
        {
            if ( g_ResetServerPriorityTime < currentTime )
            {
                NetInfo_ResetServerPriorities( g_NetworkInfo, TRUE );
                g_ResetServerPriorityTime = currentTime + g_ServerPriorityTimeLimit;
            }
            goto Copy;
        }

        //
        //  if no cached info
        //      - get build lock
        //      - loop back and recheck cache
        //

        if ( fbuildLock )
        {
            goto Build;
        }

        UNLOCK_NETINFO();
        fnetLock = FALSE;
        
        fbuildLock = LOCK_NETINFO_BUILD();
        if ( fbuildLock )
        {
            continue;
        }
        goto Unlock;
    }

    //
    //  current global expired
    //      - build new netinfo
    //      - tag it with unique monotonically increasing id
    //          this makes sure we never use older version
    //      - push forward priorities reset time
    //      - make newinfo the global copy
    //

Build:

    DNS_ASSERT( fnetLock && fbuildLock );

    newTag = ++g_NetInfoTag;
    
    UNLOCK_NETINFO();
    fnetLock = FALSE;

    pnewInfo = NetInfo_Build( TRUE );
    if ( !pnewInfo )
    {
        DNSDBG( ANY, ( "ERROR:  GrabNetworkInfo() failed -- no netinfo blob!\n" ));
        goto Unlock;
    }

    LOCK_NETINFO();
    fnetLock = TRUE;
    
    pnewInfo->Tag = newTag;
    if ( newTag != g_NetInfoTag )
    {
        DNS_ASSERT( newTag < g_NetInfoTag );
        DNSDBG( ANY, (
            "WARNING:  New netinfo uncacheable -- tag is old!\n"
            "\tour tag      = %d\n"
            "\tcurrent tag  = %d\n",
            newTag,
            g_NetInfoTag ));
        goto Unlock;
    }
    
    //  if tag still current cache this new netinfo
    
    g_ResetServerPriorityTime = currentTime + g_ServerPriorityTimeLimit;
    g_TimedOutAdapterTime = 0;
    g_fTimedOutAdapter = FALSE;
    
    poldInfo = g_NetworkInfo;
    g_NetworkInfo = pnewInfo;
    

Copy:

    //
    //  make copy of global (new or reset)
    //

    pnewInfo = NetInfo_Copy( g_NetworkInfo );

Unlock:

    if ( fnetLock )
    {
        UNLOCK_NETINFO();
    }
    if ( fbuildLock )
    {
        UNLOCK_NETINFO_BUILD();
    }
    NetInfo_Free( poldInfo );

    return pnewInfo;
}



VOID
ZeroNetworkConfigGlobals(
    VOID
    )
/*++

Routine Description:

    Zero init network globals.

Arguments:

    None

Return Value:

    None

--*/
{
    //  net failure

    g_NetFailureTime = 0;
    g_NetFailureStatus = NO_ERROR;
    g_PreviousNetFailureStatus = NO_ERROR;

    g_fTimedOutAdapter = FALSE;
    g_TimedOutAdapterTime = 0;

    g_MessagePopupStrikes = 0;
    g_NumberOfMessagePopups = 0;

    //  network info

    g_TimeOfLastPnPUpdate = 0;
    g_NetworkInfo = NULL;
}



VOID
CleanupNetworkInfo(
    VOID
    )
/*++

Routine Description:

    Cleanup network info.

Arguments:

    None

Return Value:

    None

--*/
{
    LOCK_NETINFO();

    if ( g_NetworkInfo )
    {
        NetInfo_Free( g_NetworkInfo );
        g_NetworkInfo = NULL;
    }

    UNLOCK_NETINFO();
}



//
//  General configuration
//

VOID
ReadRegistryConfig(
    VOID
    )
{
    //
    //  re-read full DNS registry info
    //

    Reg_ReadGlobalsEx( 0, NULL );

    //
    //  set "we are the resolver" global
    //

    g_InResolver = TRUE;

    //
    //  just default old config globals until remove
    //
    //  DCR:  status of old config globals?
    //

    g_MaxSOACacheEntryTtlLimit  = DNS_DEFAULT_MAX_SOA_TTL_LIMIT;
    g_NegativeSOACacheTime      = DNS_DEFAULT_NEGATIVE_SOA_CACHE_TIME;

    g_NetFailureCacheTime       = DNS_DEFAULT_NET_FAILURE_CACHE_TIME;
    g_HashTableSize             = DNS_DEFAULT_HASH_TABLE_SIZE;
    g_MessagePopupLimit         = DNS_DEFAULT_MESSAGE_POPUP_LIMIT;
}



VOID
HandleConfigChange(
    IN      PSTR            pszReason,
    IN      BOOL            fCacheFlush
    )
/*++

Routine Description:

    Response to configuration change.

Arguments:

    pszReason -- config change cause (informational only)

    fCache_Flush -- flush if config change requires cache flush

Return Value:

    None

--*/
{
    DNSDBG( INIT, (
        "\n"
        "HandleConfigChange() => %s\n"
        "\tflush = %d\n",
        pszReason,
        fCacheFlush ));

    //
    //  lock out all work while tear down everything
    //      - lock with no start option so if we are already torn
    //          down we don't rebuild
    //      - optionally flush cache
    //      - dump IP list
    //      - dump network info
    //

    LOCK_CACHE_NO_START();

    //
    //  cache flush?
    //  
    //  all config changes don't necessarily require cache flush;
    //  if not required just rebuild local list and config
    //

    if ( fCacheFlush )
    {
        Cache_Flush();
    }
#if 0
    //  FIX6:  no separate local addr info now
    //  UpdateNetworkInfo() handles freshness issue
    else
    {
        ClearLocalAddrArray();
    }
#endif

    //
    //  clear network info
    //  save PnP time
    //  clear net failure flags
    //

    UpdateNetworkInfo( NULL );
    g_TimeOfLastPnPUpdate = Dns_GetCurrentTimeInSeconds();
    g_NetFailureTime = 0;
    g_NetFailureStatus = NO_ERROR;

    DNSDBG( INIT, (
        "Leave HandleConfigChange() => %s\n"
        "\tflush = %d\n\n",
        pszReason,
        fCacheFlush ));

    UNLOCK_CACHE();
}




//
//  Remote APIs
//

VOID
R_ResolverGetConfig(
    IN      DNS_RPC_HANDLE      Handle,
    IN      DWORD               Cookie,
    OUT     PDNS_NETINFO *      ppNetInfo,
    OUT     PDNS_GLOBALS_BLOB * ppGlobals
    )
/*++

Routine Description:

    Make the query to remote DNS server.

Arguments:

    Handle -- RPC handle

    Cookie -- cookie of last succesful config transfer
        zero indicates no previous successful transfer

    ppNetInfo -- addr to receive ptr to network info

    ppGlobals -- addr to receive ptr to globals blob

Return Value:

    None

--*/
{
    PDNS_GLOBALS_BLOB   pblob;

    DNSLOG_F1( "R_ResolverGetConfig" );

    DNSDBG( RPC, (
        "R_ResolverGetConfig\n"
        "\tcookie   = %p\n",
        Cookie ));

    if ( !ppNetInfo || !ppGlobals )
    {
        return;
    }

    //
    //  DCR:  config cookie check
    //      - no need to get data if client has current copy
    //

    //
    //  copy network info global
    //
    //  note:  currently RPC is using same allocator (dnslib)
    //          as GrabNetworkInfo();  so we are ok just passing
    //          NETINFO blob as is
    //
    //  note:  could build on "no-global" but since we create on
    //         cache start we should always have global or be
    //         just starting
    //

    *ppNetInfo = (PDNS_NETINFO) GrabNetworkInfo();

    pblob = (PDNS_GLOBALS_BLOB) RPC_HEAP_ALLOC( sizeof(*pblob) );
    if ( pblob )
    {
        RtlCopyMemory(
            pblob,
            & DnsGlobals,
            sizeof(DnsGlobals) );

        //  clear "in resolver" flag

        pblob->InResolver = FALSE;
    }
    *ppGlobals = pblob;

    DNSDBG( RPC, ( "Leave R_ResolverGetConfig\n\n" ));
}



VOID
R_ResolverPoke(
    IN      DNS_RPC_HANDLE      Handle,
    IN      DWORD               Cookie,
    IN      DWORD               Id
    )
/*++

Routine Description:

    Test interface to poke resolver to update.

Arguments:

    Handle -- RPC handle

    Cookie -- cookie

    Id -- operation Id

Return Value:

    None

--*/
{
    DNSLOG_F1( "R_ResolverPoke" );

    DNSDBG( RPC, (
        "R_ResolverPoke\n"
        "\tcookie = %08x\n"
        "\tid     = %d\n",
        Cookie,
        Id ));

    if ( !Rpc_AccessCheck( RESOLVER_ACCESS_FLUSH ) )
    {
        DNSLOG_F1( "R_ResolverPoke - ERROR_ACCESS_DENIED" );
        return;
    }

    //
    //  do operation for particular id
    //      - update netinfo clears cached copy

    if ( Id == POKE_OP_UPDATE_NETINFO )
    {
        if ( Cookie == POKE_COOKIE_UPDATE_NETINFO )
        {
            UpdateNetworkInfo( NULL );
        }
    }
}



//
//  Net failure stuff -- of dubious value
//

#if 0
BOOL
IsKnownNetFailure(
    VOID
    )
/*++

Routine Description:

    Determine if we are in known net failure window.

Arguments:

    None

Return Value:

    TRUE if in known net failure
    FALSE otherwise

--*/
{
    BOOL flag = FALSE;

    DNSDBG( TRACE, ( "IsKnownNetFailure()\n" ));

    //
    //  DCR:  should have NetFailure check outside of lock for perf
    //

    LOCK_NET_FAILURE();

    if ( g_NetFailureStatus )
    {
        if ( g_NetFailureTime < Dns_GetCurrentTimeInSeconds() )
        {
            g_NetFailureTime = 0;
            g_NetFailureStatus = ERROR_SUCCESS;
            flag = FALSE;
        }
        else
        {
            SetLastError( g_NetFailureStatus );
            flag = TRUE;
        }
    }

    UNLOCK_NET_FAILURE();

    return flag;
}



VOID
SetKnownNetFailure(
    IN      DNS_STATUS      Status
    )
/*++

Routine Description:

    Set cause of net failure.

Arguments:

    Status -- status code for cause of net failure

Return Value:

    None

--*/
{
    LPSTR  DnsString = NULL;
    LPWSTR InsertStrings[3];
    WCHAR  String1[25];
    WCHAR  String2[256];
    WCHAR  String3[25];

    DNSDBG( TRACE, ( "SetKnownNetFailure()\n" ));

    //
    //  don't indicate failure during boot
    //

    if ( Dns_GetCurrentTimeInSeconds() < THREE_MINUTES_FROM_SYSTEM_BOOT )
    {
        return;
    }

    //
    //  DCR:  need to detect no-net
    //
    //  FIX6:  should detect no-net and skip this
    //

    if ( g_NetFailureCacheTime == 0 )
    {
        //
        // We are in a no-net configuration, there is no need
        // to display the pop-up message. No point warning
        // of DNS configuration problems when the system is
        // off the net.
        // - or -
        // We are on a NT server, and therefore don't do poor network
        // performance caching.
        //
        return;
    }


    LOCK_NET_FAILURE();

    g_NetFailureTime = Dns_GetCurrentTimeInSeconds() + g_NetFailureCacheTime;
    g_NetFailureStatus = Status;

    wsprintfW( String1, L"0x%.8X", Status );

    DnsString = DnsStatusString( Status );

    if ( DnsString )
    {
        Dns_StringCopy( (PBYTE) String2,
                        NULL,
                        (PCHAR) DnsString,
                        (WORD) strlen( DnsString ),
                        DnsCharSetAnsi,
                        DnsCharSetUnicode );
        //
        // No need to free this since the string is just a pointer
        // to a global table entry.
        //
        // FREE_HEAP( DnsString );
    }
    else
    {
        wsprintfW( String2, L"<?>" );
    }

    wsprintfW( String3, L"%d", g_NetFailureCacheTime );

    if ( g_MessagePopupStrikes < 3 )
    {
        g_MessagePopupStrikes++;
    }
    else
    {
        if ( Status != g_PreviousNetFailureStatus )
        {
            //
            //  DCR_PERF:  should remove logging from inside lock
            //

            InsertStrings[0] = String1;
            InsertStrings[1] = String2;
            InsertStrings[2] = String3;
        
            ResolverLogEvent(
                EVENT_DNS_CACHE_NETWORK_PERF_WARNING,
                EVENTLOG_WARNING_TYPE,
                3,
                InsertStrings,
                Status );
            g_PreviousNetFailureStatus = Status;
        }

        g_MessagePopupStrikes = 0;
    }

    UNLOCK_NET_FAILURE();
}
#endif

//
//  End config.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\server\dnsmsg.h ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    dnsmsg.h

Abstract:

    DNS Resolver Service

    Message box string identifier definitions.

Author:

    Glenn Curtis (glennc)   April 1997

Revision History:

--*/


#ifndef _DNSMSG_INCLUDED_
#define _DNSMSG_INCLUDED_

//
// Message box string identifiers
//

#define DNS_CACHE_MSG_SERVICE           0x00001001
#define DNS_CACHE_MSG_NETSLOW           0x00001002
#define DNS_CACHE_MSG_DESCRIPTION       0x00001003


#endif // _DNSMSG_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\server\dnsrslvr_s_stub.c ===
#include "local.h"
#include "dnsrslvr_s.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\server\local.h ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    local.h

Abstract:

    DNS Resolver.

    DNS Resolver service local include file.

Author:

    Jim Gilroy  (jamesg)        March 2000

Revision History:

--*/


#ifndef _LOCAL_INCLUDED_
#define _LOCAL_INCLUDED_


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntseapi.h>
#include <stdio.h>
#include <stdlib.h>
#ifndef _WINSOCK2API_
#include <winsock2.h>
#endif
#include <sockreg.h>
#include <windns.h>
#include <netevent.h>       // DNS events

//#define  DNSAPI_INTERNAL
#define  DNS_NEW_DEFS 1     // QFE builds use new definitions

#include "dnsrslvr.h"
#include <dnslibp.h>
#include "registry.h"
#include <dnsapip.h>

#define  ENABLE_DEBUG_LOGGING 1
#include "logit.h"
#include "dnsmsg.h"
#include "heapdbg.h"


//
//  Resolver debug flags
//

#define DNS_DBG_CACHE       DNS_DBG_QUERY


//
//  Cache definitions
//

#define NO_LOCK                 0
#define LOCKED                  1

#define ONE_YEAR_IN_SECONDS     60*60*24*365


//
//  Bypassing cache completely check
//

#define COMBINED_BYPASS_CACHE_FLAG  (DNS_QUERY_BYPASS_CACHE | DNS_QUERY_NO_HOSTS_FILE)

#define SKIP_CACHE_LOOKUP(Flags)    \
        ( ((Flags) & COMBINED_BYPASS_CACHE_FLAG) == COMBINED_BYPASS_CACHE_FLAG )


//
//  Cache defintion
//
//  Should be private to cache but is currently
//  exposed in enum routines
//

typedef struct _CacheEntry
{
    struct _CacheEntry *    pNext;
    PWSTR                   pName;
    DWORD                   Reserved;
    DWORD                   MaxCount;
    PDNS_RECORD             Records[ 1 ];
}
CACHE_ENTRY, *PCACHE_ENTRY;

        

#if 1
//
//  Config
//
//  Saved NT5 registry stuff.
//  In typical fashsion this was packed away in a few different places.
//  Keeping around until all of this is properly put to bed.
//
//
//  Registry value routine prototypes
//
#define DNS_DEFAULT_HASH_TABLE_SIZE                211      // A prime number
#define DNS_DEFAULT_NEGATIVE_SOA_CACHE_TIME        10       // 10 seconds
#define DNS_DEFAULT_NET_FAILURE_CACHE_TIME         30       // 30 seconds
#define DNS_DEFAULT_ADAPTER_TIMEOUT_CACHE_TIME     2*60     // 2 minutes
#define DNS_DEFAULT_MESSAGE_POPUP_LIMIT            0        // Don't allow!
#define DNS_DEFAULT_MAX_SOA_TTL_LIMIT              5*60     // 5 minutes
#define DNS_DEFAULT_RESET_SERVER_PRIORITIES_TIME   5*60     // 5 minutes
#endif


//
//  Event tags
//  Make recognizable DWORD tags for in memory log.
//

#define FOUR_CHARACTER_CONSTANT(a,b,c,d) \
        ((((DWORD)d) << 24) + (((DWORD)c) << 16) + (((DWORD)b) << 8) + ((DWORD)a))

#define RES_EVENT_INITNET_START         FOUR_CHARACTER_CONSTANT('N','e','t','+')
#define RES_EVENT_INITNET_END           FOUR_CHARACTER_CONSTANT('N','e','t','-')
#define RES_EVENT_REGISTER_SCH          FOUR_CHARACTER_CONSTANT('S','c','h','+')
#define RES_EVENT_CREATE_EVENT          FOUR_CHARACTER_CONSTANT('E','v','t','+')
#define RES_EVENT_START_RPC             FOUR_CHARACTER_CONSTANT('R','p','c','+')
#define RES_EVENT_STOP_RPC              FOUR_CHARACTER_CONSTANT('R','p','c','-')
#define RES_EVENT_STATUS                FOUR_CHARACTER_CONSTANT('S','t','a','t')
#define RES_EVENT_UPDATE_STATE          FOUR_CHARACTER_CONSTANT('U','p','d',' ')
#define RES_EVENT_UPDATE_STATUS         FOUR_CHARACTER_CONSTANT('U','p','d','-')
#define RES_EVENT_INITCRIT_START        FOUR_CHARACTER_CONSTANT('I','C','S','+')
#define RES_EVENT_INITCRIT_END          FOUR_CHARACTER_CONSTANT('I','C','S','-')
#define RES_EVENT_DELCRIT_START         FOUR_CHARACTER_CONSTANT('D','C','S','+')
#define RES_EVENT_DELCRIT_END           FOUR_CHARACTER_CONSTANT('D','C','S','-')
#define RES_EVENT_STARTED               FOUR_CHARACTER_CONSTANT('S','t','a','r')
#define RES_EVENT_STOPPING              FOUR_CHARACTER_CONSTANT('S','t','o','p')
#define RES_EVENT_SHUTDOWN              FOUR_CHARACTER_CONSTANT('S','h','u','t')

#define RES_EVENT_SERVICE_CONTROL       FOUR_CHARACTER_CONSTANT('S','v','c',' ')
#define RES_EVENT_INIT_CACHE            FOUR_CHARACTER_CONSTANT('C','c','h','+')
#define RES_EVENT_FLUSH_CACHE           FOUR_CHARACTER_CONSTANT('F','l','s','h')
#define RES_EVENT_PNP_START             FOUR_CHARACTER_CONSTANT('P','n','P','+')
#define RES_EVENT_PNP_END               FOUR_CHARACTER_CONSTANT('P','n','P','-')


//
//  Service
//

extern  HANDLE      g_hStopEvent;
extern  BOOL        g_StopFlag;
extern  BOOL        g_WakeFlag;
extern  BOOL        g_GarbageCollectFlag;

extern  BOOL        g_LogTraceInfo;

//
//  Config (config.c) 
//

extern  DWORD       g_MaxSOACacheEntryTtlLimit;
extern  DWORD       g_NegativeSOACacheTime;
extern  DWORD       g_MessagePopupLimit;
extern  DWORD       g_NetFailureCacheTime;

//
//  Config info (config.c)
//

extern  PDNS_NETINFO    g_NetworkInfo;
extern  DWORD           g_TimeOfLastPnPUpdate;

//
//  Cache (cache.c)
//

extern  PCACHE_ENTRY *  g_HashTable;
extern  DWORD           g_HashTableSize;
extern  DWORD           g_EntryCount;
extern  DWORD           g_RecordSetCount;


//
//  Network failure caching
//

extern  DWORD       g_NetFailureTime;
extern  DNS_STATUS  g_NetFailureStatus;
extern  DWORD       g_TimedOutAdapterTime;
extern  DWORD       g_ResetServerPrioritiesTime;
extern  BOOL        g_fTimedOutAdapter;
extern  DNS_STATUS  g_PreviousNetFailureStatus;
extern  DWORD       g_MessagePopupStrikes;
extern  DWORD       g_NumberOfMessagePopups;


//
//  Locking
//

extern  CRITICAL_SECTION        CacheCS;
extern  CRITICAL_SECTION        NetworkFailureCS;
extern  CRITICAL_SECTION        NetinfoCS;
extern  TIMED_LOCK              NetinfoBuildLock;


#define LOCK_CACHE()            Cache_Lock( 0 )
#define LOCK_CACHE_NO_START()   Cache_Lock( 1 )
#define UNLOCK_CACHE()          Cache_Unlock()

#define LOCK_NET_FAILURE()      EnterCriticalSection( &NetworkFailureCS )
#define UNLOCK_NET_FAILURE()    LeaveCriticalSection( &NetworkFailureCS )


//
//  Cache flush levels
//
//  Note, these aren't bit flags, just made them that way for
//  easy reading.
//

#define FLUSH_LEVEL_NORMAL      (0)
#define FLUSH_LEVEL_INVALID     (1)
#define FLUSH_LEVEL_WIRE        (2)
#define FLUSH_LEVEL_STRONG      (4)
#define FLUSH_LEVEL_CLEANUP     (8)

#define FLUSH_LEVEL_GARBAGE     (FLUSH_LEVEL_WIRE)



//
//  Resolver RPC access control
//

#define RESOLVER_ACCESS_READ        0x00000001
#define RESOLVER_ACCESS_ENUM        0x00000002
#define RESOLVER_ACCESS_QUERY       0x00000010
#define RESOLVER_ACCESS_FLUSH       0x00000020
#define RESOLVER_ACCESS_REGISTER    0x00000100

//
//  Generic mapping for resolver
//
//  note:  not using generic bits for access control,
//         but still must provide mapping
//

#define RESOLVER_GENERIC_READ       ((STANDARD_RIGHTS_READ)     | \
                                    (RESOLVER_ACCESS_READ)      | \
                                    (RESOLVER_ACCESS_QUERY)     | \
                                    (RESOLVER_ACCESS_ENUM))

#define RESOLVER_GENERIC_EXECUTE    RESOLVER_GENERIC_READ

#define RESOLVER_GENERIC_WRITE      ((RESOLVER_GENERIC_READ)    | \
                                    (RESOLVER_ACCESS_FLUSH))

#define RESOLVER_GENERIC_ALL        ((RESOLVER_GENERIC_WRITE)   | \
                                    (RESOLVER_ACCESS_REGISTER))


//
//  Cache memory
//
//  Note, heap global doesn't need exposure if functionalize
//

extern  HANDLE g_CacheHeap;

#define CACHE_HEAP_ALLOC_ZERO(size) \
        HeapAlloc( g_CacheHeap, HEAP_ZERO_MEMORY, (size) )

#define CACHE_HEAP_ALLOC(size) \
        HeapAlloc( g_CacheHeap, 0, (size) )

#define CACHE_HEAP_FREE(p) \
        HeapFree( g_CacheHeap, 0, (p) )


//
//  Record and RPC memory:
//
//  Note:  most records are created by dnsapi heap -- from
//  query or hosts file routines.  However, we do create
//  name error caching records ourselves using dnslib routines.
//
//  This means -- until we either
//      - extend query or dnslib record creation interfaces to
//        include heap parameter
//      - explicitly free and recreate
//      - tag records (dnsapi\not) somehow (flags field)
//  that
//  dnsapi and dnslib heaps MUST be the same.
//  With dnsapi now potentially having it's own heap, this means
//  dnslib should use dnsapi heap.
//
//  So we'll put off using the debug heap for dnslib.
//

//
//  Resolver allocators
//

PVOID
Res_Alloc(
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      PSTR            pszFile,
    IN      DWORD           LineNo
    );

PVOID
Res_AllocZero(
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      PSTR            pszFile,
    IN      DWORD           LineNo
    );

VOID
Res_Free(
    IN OUT  PVOID           pMemory,
    IN      DWORD           Tag
    );

#define RESHEAP_TAG_GENERAL     0
#define RESHEAP_TAG_RECORD      1
#define RESHEAP_TAG_RPC         2
#define RESHEAP_TAG_MCAST       3


//
//  General memory
//

#define GENERAL_HEAP_ALLOC(Size)    \
        Res_Alloc(                  \
            Size,                   \
            RESHEAP_TAG_GENERAL,    \
            __FILE__,               \
            __LINE__ )

#define GENERAL_HEAP_ALLOC_ZERO(Size)   \
        Res_AllocZero(              \
            Size,                   \
            RESHEAP_TAG_GENERAL,    \
            __FILE__,               \
            __LINE__ )

#define GENERAL_HEAP_FREE(pMem)     \
        Res_Free(                   \
            pMem,                   \
            RESHEAP_TAG_GENERAL )


//
//  RPC allocs
//

#define RPC_HEAP_ALLOC(Size)        \
        Res_Alloc(                  \
            Size,                   \
            RESHEAP_TAG_RPC,        \
            __FILE__,               \
            __LINE__ )

#define RPC_HEAP_ALLOC_ZERO(Size)   \
        Res_AllocZero(              \
            Size,                   \
            RESHEAP_TAG_RPC,        \
            __FILE__,               \
            __LINE__ )

#define RPC_HEAP_FREE(pMem)         \
        Res_Free(                   \
            pMem,                   \
            RESHEAP_TAG_RPC )


//
//  Record heap routines
//

#define RECORD_HEAP_ALLOC(Size)     \
        Res_Alloc(                  \
            Size,                   \
            RESHEAP_TAG_RECORD,     \
            __FILE__,               \
            __LINE__ )

#define RECORD_HEAP_ALLOC_ZERO(Size)    \
        Res_AllocZero(              \
            Size,                   \
            RESHEAP_TAG_RECORD,     \
            __FILE__,               \
            __LINE__ )

#define RECORD_HEAP_FREE(pMem)      \
        Res_Free(                   \
            pMem,                   \
            RESHEAP_TAG_RECORD )

//
//  Mcast heap routines
//

#define MCAST_HEAP_ALLOC(Size)      \
        Res_Alloc(                  \
            Size,                   \
            RESHEAP_TAG_MCAST,      \
            __FILE__,               \
            __LINE__ )

#define MCAST_HEAP_ALLOC_ZERO(Size)    \
        Res_AllocZero(              \
            Size,                   \
            RESHEAP_TAG_MCAST,      \
            __FILE__,               \
            __LINE__ )

#define MCAST_HEAP_FREE(pMem)       \
        Res_Free(                   \
            pMem,                   \
            RESHEAP_TAG_MCAST )


//
//  Cache routines (ncache.c)
//

DNS_STATUS
Cache_Lock(
    IN      BOOL            fNoStart
    );

VOID
Cache_Unlock(
    VOID
    );

DNS_STATUS
Cache_Initialize(
    VOID
    );

DNS_STATUS
Cache_Shutdown(
    VOID
    );

DNS_STATUS
Cache_Flush(
    VOID
    );

VOID
Cache_FlushRecords(
    IN      PWSTR           pName,
    IN      DWORD           FlushLevel,
    IN      WORD            Type
    );

BOOL
Cache_IsRecordTtlValid(
    IN      PDNS_RECORD     pRecord
    );

//
//  Cache operations routines (ncache.c)
//

BOOL
Cache_ReadResults(
    OUT     PDNS_RESULTS    pResults,
    IN      PWSTR           pwsName,
    IN      WORD            wType
    );

VOID
Cache_PrepareRecordList(
    IN OUT  PDNS_RECORD     pRecordList
    );

VOID
Cache_RestoreRecordListForRpc(
    IN OUT  PDNS_RECORD     pRecordList
    );

VOID
Cache_RecordList(
    IN OUT  PDNS_RECORD     pRecordList
    );

VOID
Cache_RecordSetAtomic(
    IN      PWSTR           pwsName,
    IN      WORD            wType,
    IN      PDNS_RECORD     pRecordSet
    );

VOID
Cache_GarbageCollect(
    IN      DWORD           Flag
    );

DNS_STATUS
Cache_QueryResponse(
    IN OUT  PQUERY_BLOB     pBlob
    );

BOOL
Cache_GetRecordsForRpc(
    OUT     PDNS_RECORD *   ppRecordList,
    OUT     PDNS_STATUS     pStatus,
    IN      PWSTR           pwsName,
    IN      WORD            wType,
    IN      DWORD           Flags
    );

VOID
Cache_DeleteMatchingRecords(
    IN      PDNS_RECORD     pRecords
    );

//
//  Host file routines (notify.c)
//

VOID
InitCacheWithHostFile(
    VOID
    );


//
//  Notification (notify.c)
//

VOID
ThreadShutdownWait(
    IN      HANDLE          hThread
    );

HANDLE
CreateHostsFileChangeHandle(
    VOID
    );

VOID
NotifyThread(
    VOID
    );

VOID
StartNotify(
    VOID
    );

VOID
ShutdownNotify(
    VOID
    );


//
//  Config -- Network info (config.c)
//

VOID
UpdateNetworkInfo(
    IN OUT  PDNS_NETINFO    pNetworkInfo
    );

PDNS_NETINFO         
GrabNetworkInfo(
    VOID
    );

VOID
ZeroNetworkConfigGlobals(
    VOID
    );

VOID
CleanupNetworkInfo(
    VOID
    );

VOID
ReadRegistryConfig(
    VOID
    );

VOID
HandleConfigChange(
    IN      PSTR            pszReason,
    IN      BOOL            fCache_Flush
    );

#if 0
//
//  Currently ignoring all bogus net failure stuff
//
BOOL
IsKnownNetFailure(
    VOID
    );

VOID
SetKnownNetFailure(
    IN      DNS_STATUS      Status
    );

#endif

#define IsKnownNetFailure()     (FALSE)


//
//  Net config (still remote.c)
//

#define THREE_MINUTES_FROM_SYSTEM_BOOT  180
#define MAX_DNS_NOTIFICATION_LIST_SIZE  1000
#define PNP_REFRESH_UPDATE_WINDOW       60

BOOL
IsTimeToResetServerPriorities(
    VOID
    );


//
//  Service notification (notesrv.c)
//

VOID
SendServiceNotifications(
    VOID
    );

VOID
CleanupServiceNotification(
    VOID
    );

//
//  In memory logging (memlog.c)
//

VOID
LogEventInMemory(
    IN      DWORD           Checkpoint,
    IN      DWORD           Data
    );

//
//  Event logging (dnsrslvr.c)
//

VOID
ResolverLogEvent (
    IN      DWORD           MessageId,
    IN      WORD            EventType,
    IN      DWORD           StringCount,
    IN      PWSTR *         StringArray,
    IN      DWORD           ErrorCode
    );

//
//  IP list and notification (ip.c)
//

DNS_STATUS
IpNotifyThread(
    IN      LPVOID  pvDummy
    );

VOID
ZeroInitIpListGlobals(
    VOID
    );

DNS_STATUS
InitIpListAndNotification(
    VOID
    );

VOID
ShutdownIpListAndNotify(
    VOID
    );


//
//  Resolver log (logit.c)
//
//  Special type routines for resolver logging.
//  General log open\print routines defined in logit.h.
//

VOID
PrintNetworkInfoToLog(
    IN      PDNS_NETINFO    pNetworkInfo
    );


//
//  RPC server and access checking (rpc.c)
//

DNS_STATUS
Rpc_Initialize(
    VOID
    );

VOID
Rpc_Shutdown(
    VOID
    );

BOOL
Rpc_AccessCheck(
    IN      DWORD           DesiredAccess
    );


//
//  Multicast (mcast.c)
//

DNS_STATUS
Mcast_Startup(
    VOID
    );

VOID
Mcast_SignalShutdown(
    VOID
    );

VOID
Mcast_ShutdownWait(
    VOID
    );

#endif // _LOCAL_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\server\ip.c ===
/*++

Copyright (c) 2000-2000  Microsoft Corporation

Module Name:

    ip.c

Abstract:

    DNS Resolver Service.

    IP list and change notification.

Author:

    Jim Gilroy  (jamesg)    November 2000

Revision History:

--*/


#include "local.h"
#include "iphlpapi.h"


//
//  IP notify thread globals
//

HANDLE          g_IpNotifyThread;
DWORD           g_IpNotifyThreadId;

HANDLE          g_IpNotifyEvent;
HANDLE          g_IpNotifyHandle;
OVERLAPPED      g_IpNotifyOverlapped;


//
//  Cluster record TTLs -- use max TTL
//

#define CLUSTER_RECORD_TTL  (g_MaxCacheTtl)


//
//  Shutdown\close locking
//
//  Since GQCS and GetOverlappedResult() don't directly wait
//  on StopEvent, we need to be able to close notification handle
//  and port in two different threads.
//
//  Note:  this should probably be some general CS that is
//  overloaded to do service control stuff.
//  I'm not using the server control CS because it's not clear
//  that the functions it does in dnsrslvr.c even need locking.
//

#define LOCK_IP_NOTIFY_HANDLE()     EnterCriticalSection( &NetworkFailureCS )
#define UNLOCK_IP_NOTIFY_HANDLE()   LeaveCriticalSection( &NetworkFailureCS )

CRITICAL_SECTION        g_IpListCS;

#define LOCK_IP_LIST()     EnterCriticalSection( &g_IpListCS );
#define UNLOCK_IP_LIST()   LeaveCriticalSection( &g_IpListCS );



//
//  Cluster Tag
//

#define CLUSTER_TAG     0xd734453d



VOID
CloseIpNotifyHandle(
    VOID
    )
/*++

Routine Description:

    Close IP notify handle.

    Wrapping up code since this close must be MT
    safe and is done in several places.

Arguments:

    None

Return Value:

    None

--*/
{
    LOCK_IP_NOTIFY_HANDLE();
    if ( g_IpNotifyHandle )
    {
        //CloseHandle( g_IpNotifyHandle );
        PostQueuedCompletionStatus(
            g_IpNotifyHandle,
            0,      // no bytes
            0,      // no key
            & g_IpNotifyOverlapped );

        g_IpNotifyHandle = NULL;
    }
    UNLOCK_IP_NOTIFY_HANDLE();
}



DNS_STATUS
IpNotifyThread(
    IN      LPVOID  pvDummy
    )
/*++

Routine Description:

    IP notification thread.

Arguments:

    pvDummy -- unused

Return Value:

    NO_ERROR on normal service shutdown
    Win32 error on abnormal termination

--*/
{
    DNS_STATUS      status = NO_ERROR;
    DWORD           bytesRecvd;
    BOOL            fstartedNotify;
    BOOL            fhaveIpChange = FALSE;
    BOOL            fsleep = FALSE;
    HANDLE          notifyHandle;


    DNSDBG( INIT, ( "\nStart IpNotifyThread.\n" ));

    g_IpNotifyHandle = NULL;

    //
    //  wait in loop on notifications
    //

    while ( !g_StopFlag )
    {
        //
        //  spin protect
        //      - if error in previous NotifyAddrChange or
        //      GetOverlappedResult do short sleep to avoid
        //      chance of hard spin
        //

        if ( fsleep )
        {
            WaitForSingleObject(
               g_hStopEvent,
               60000 );
            fsleep = FALSE;
            continue;
        }

        //
        //  start notification
        //
        //  do this before checking result as we want notification
        //  down BEFORE we read so we don't leave window where
        //  IP change is not picked up
        //
    
        RtlZeroMemory(
            &g_IpNotifyOverlapped,
            sizeof(OVERLAPPED) );

        if ( g_IpNotifyEvent )
        {
            g_IpNotifyOverlapped.hEvent = g_IpNotifyEvent;
            ResetEvent( g_IpNotifyEvent );
        }
        notifyHandle = 0;
        fstartedNotify = FALSE;

        status = NotifyAddrChange(
                    & notifyHandle,
                    & g_IpNotifyOverlapped );

        if ( status == ERROR_IO_PENDING )
        {
            DNSDBG( INIT, (
                "NotifyAddrChange()\n"
                "\tstatus           = %d\n"
                "\thandle           = %d\n"
                "\toverlapped event = %d\n",
                status,
                notifyHandle,
                g_IpNotifyOverlapped.hEvent ));

            g_IpNotifyHandle = notifyHandle;
            fstartedNotify = TRUE;
        }
        else
        {
            DNSDBG( ANY, (
                "NotifyAddrChange() FAILED\n"
                "\tstatus           = %d\n"
                "\thandle           = %d\n"
                "\toverlapped event = %d\n",
                status,
                notifyHandle,
                g_IpNotifyOverlapped.hEvent ));

            fsleep = TRUE;
        }

        if ( g_StopFlag )
        {
            goto Done;
        }

        //
        //  previous notification -- refresh data
        //
        //  FlushCache currently include local IP list
        //  sleep keeps us from spinning in this loop
        //
        //  DCR:  better spin protection;
        //      if hit X times then sleep longer?
        //
    
        if ( fhaveIpChange )
        {
            DNSDBG( ANY, ( "\nIP notification, flushing cache and restarting.\n" ));
            HandleConfigChange(
                "IP-notification",
                TRUE        // flush cache
                );
            fhaveIpChange = FALSE;
        }

        //
        //  starting --
        //  clear list to force rebuild of IP list AFTER starting notify
        //  so we can know that we don't miss any changes;
        //  need this on startup, but also to protect against any
        //  NotifyAddrChange failues
        //
        //  FIX6:  should invalidate netinfo on notify start?
        //      same reasoning as for IP list -- make sure we have fresh data?
        //

        else if ( fstartedNotify )
        {
            //  local addr now carried in netinfo
            //ClearLocalAddrArray();
        }

        //
        //  anti-spin protection
        //      - 15 second sleep between any notifications
        //

        WaitForSingleObject(
           g_hStopEvent,
           15000 );

        if ( g_StopFlag )
        {
            goto Done;
        }

        //
        //  wait on notification
        //      - save notification result
        //      - sleep on error, but never if notification
        //

        if ( fstartedNotify )
        {
            fhaveIpChange = GetOverlappedResult(
                                g_IpNotifyHandle,
                                & g_IpNotifyOverlapped,
                                & bytesRecvd,
                                TRUE        // wait
                                );
            fsleep = !fhaveIpChange;

            status = NO_ERROR;
            if ( !fhaveIpChange )
            {
                status = GetLastError();
            }
            DNSDBG( ANY, (
                "GetOverlappedResult() => %d.\n"
                "\t\tstatus = %d\n",
                fhaveIpChange,
                status ));
        }
    }

Done:

    DNSDBG( ANY, ( "Stop IP Notify thread on service shutdown.\n" ));

    CloseIpNotifyHandle();

    return( status );
}



VOID
ZeroInitIpListGlobals(
    VOID
    )
/*++

Routine Description:

    Zero-init IP globals just for failure protection.

    The reason to have this is there is some interaction with
    the cache from the notify thread.  To avoid that being a
    problem we start the cache first.

    But just for safety we should at least zero init these
    globals first to protect us from cache touching them.

Arguments:

Return Value:

    NO_ERROR on normal service shutdown
    Win32 error on abnormal termination

--*/
{
    //
    //  clear out globals to smoothly handle failure cases
    //

    g_IpNotifyThread    = NULL;
    g_IpNotifyThreadId  = 0;
    g_IpNotifyEvent     = NULL;
    g_IpNotifyHandle    = NULL;
}



DNS_STATUS
InitIpListAndNotification(
    VOID
    )
/*++

Routine Description:

    Start IP notification thread.

Arguments:

    None

Globals:

    Initializes IP list and notify thread globals.

Return Value:

    NO_ERROR on normal service shutdown
    Win32 error on abnormal termination

--*/
{
    DNS_STATUS  status = NO_ERROR;

    DNSDBG( TRACE, ( "InitIpListAndNotification()\n" ));

    //
    //  CS for IP list access
    //

    InitializeCriticalSection( &g_IpListCS );

    //
    //  create event for overlapped I/O
    //

    g_IpNotifyEvent = CreateEvent(
                        NULL,       //  no security descriptor
                        TRUE,       //  manual reset event
                        FALSE,      //  start not signalled
                        NULL        //  no name
                        );
    if ( !g_IpNotifyEvent )
    {
        status = GetLastError();
        DNSDBG( ANY, ( "\nFAILED IpNotifyEvent create.\n" ));
        goto Done;
    }

    //
    //  fire up IP notify thread
    //

    g_IpNotifyThread = CreateThread(
                            NULL,
                            0,
                            (LPTHREAD_START_ROUTINE) IpNotifyThread,
                            NULL,
                            0,
                            & g_IpNotifyThreadId
                            );
    if ( !g_IpNotifyThread )
    {
        status = GetLastError();
        DNSDBG( ANY, (
            "FAILED to create IP notify thread = %d\n",
            status ));
    }

Done:

    //  not currently stopping on init failure

    return( ERROR_SUCCESS );
}



VOID
ShutdownIpListAndNotify(
    VOID
    )
/*++

Routine Description:

    Stop IP notify thread.

    Note:  currently this is blocking call, we'll wait until
        thread shuts down.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNSDBG( TRACE, ( "ShutdownIpListAndNotify()\n" ));

    //
    //  MUST be stopping
    //      - if not thread won't wake
    //

    ASSERT( g_StopFlag );

    g_StopFlag = TRUE;

    //
    //  close IP notify handles -- waking thread if still running
    //

    if ( g_IpNotifyEvent )
    {
        SetEvent( g_IpNotifyEvent );
    }
    CloseIpNotifyHandle();

    //
    //  wait for thread to stop
    //

    ThreadShutdownWait( g_IpNotifyThread );
    g_IpNotifyThread = NULL;

    //
    //  close event
    //

    CloseHandle( g_IpNotifyEvent );
    g_IpNotifyEvent = NULL;

    //
    //  kill off CS
    //

    DeleteCriticalSection( &g_IpListCS );
}




//
//  Cluster registration
//

DNS_STATUS
R_ResolverRegisterCluster(
    IN      DNS_RPC_HANDLE  Handle,
    IN      DWORD           Tag,
    IN      PWSTR           pwsName,
    IN      PDNS_ADDR       pAddr,
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Make the query to remote DNS server.

Arguments:

    Handle -- RPC handle

    Tag -- RPC API tag

    pwsName -- name of cluster

    pIpUnion -- IP union

    Flag -- registration flag
        DNS_CLUSTER_ADD
        DNS_CLUSTER_DELETE_NAME
        DNS_CLUSTER_DELETE_IP

Return Value:

    None

--*/
{
    PDNS_RECORD     prrAddr = NULL;
    PDNS_RECORD     prrPtr = NULL;
    DNS_STATUS      status = NO_ERROR;


    DNSLOG_F1( "R_ResolverRegisterCluster" );

    DNSDBG( RPC, (
        "R_ResolverRegisterCluster()\n"
        "\tpName        = %s\n"
        "\tpAddr        = %p\n"
        "\tFlag         = %08x\n",
        pwsName,
        pAddr,
        Flag ));

    //
    //  DCR:  cluster not doing local registration
    //      removed for .net to avoid any possible security hole
    //

#if 0
    if ( !Rpc_AccessCheck( RESOLVER_ACCESS_REGISTER ) )
    {
        DNSLOG_F1( "R_ResolverRegisterClusterIp - ERROR_ACCESS_DENIED" );
        return  ERROR_ACCESS_DENIED;
    }
    if ( Tag != CLUSTER_TAG )
    {
        return  ERROR_ACCESS_DENIED;
    }

    //
    //  validate address
    //

    if ( Flag != DNS_CLUSTER_DELETE_NAME &&
         !DnsAddr_IsIp4(pAddr) &&
         !DnsAddr_IsIp6(pAddr) )
    {
        DNS_ASSERT( FALSE );
        return  ERROR_INVALID_PARAMETER;
    }

    //
    //  cluster add -- cache cluster records
    //      - forward and reverse
    //

    if ( !pwsName )
    {
        DNSDBG( ANY, ( "WARNING:  no cluster name given!\n" ));
        return  ERROR_INVALID_PARAMETER;
    }

    //
    //  build records
    //      - address and corresponding PTR
    //

    if ( Flag != DNS_CLUSTER_DELETE_NAME )
    {
        prrAddr = Dns_CreateForwardRecord(
                        pwsName,
                        0,      // type for addr
                        pAddr,
                        CLUSTER_RECORD_TTL,
                        DnsCharSetUnicode,
                        DnsCharSetUnicode );
    
        if ( !prrAddr )
        {
            goto Failed;
        }
        SET_RR_CLUSTER( prrAddr );
    
        prrPtr = Dns_CreatePtrRecordEx(
                        pAddr,
                        pwsName,
                        CLUSTER_RECORD_TTL,
                        DnsCharSetUnicode,
                        DnsCharSetUnicode );
        if ( !prrPtr )
        {
            goto Failed;
        }
        SET_RR_CLUSTER( prrPtr );
    }

    //
    //  add records to cache
    //

    if ( Flag == DNS_CLUSTER_ADD )
    {
        Cache_RecordSetAtomic(
            NULL,       // record name
            0,          // record type
            prrAddr );

        if ( prrPtr )
        {
            Cache_RecordSetAtomic(
                NULL,       // record name
                0,          // record type
                prrPtr );
        }
        prrAddr = NULL;
        prrPtr = NULL;
    }

    //
    //  if delete cluster, flush cache entries for name\type
    //
    //  DCR:  not deleting PTR for CLUSTER_DELETE_NAME
    //      would need to extract and reverse existing A\AAAA records
    //
    //  DCR:  build reverse name independently so whack works
    //      even without cluster name
    //

    if ( Flag == DNS_CLUSTER_DELETE_NAME )
    {
        Cache_FlushRecords(
            pwsName,
            FLUSH_LEVEL_STRONG,
            0 );

        //  delete record matching PTR
        //      need to flush JUST PTR pointing to this name
        //      this may be optional -- whether we're given an IP
        //      with the name or not

        goto Done;
    }

    //
    //  delete specific cluster IP (name\addr pair)
    //

    if ( Flag == DNS_CLUSTER_DELETE_IP )
    {
        Cache_DeleteMatchingRecords( prrAddr );
        Cache_DeleteMatchingRecords( prrPtr );
        goto Done;
    }

    DNSDBG( ANY, (
        "ERROR:  invalid cluster flag %d!\n",
        Flag ));
    status = ERROR_INVALID_PARAMETER;
    

Failed:

    if ( status == NO_ERROR )
    {
        status = GetLastError();
        if ( status == NO_ERROR )
        {
            status = ERROR_INVALID_DATA;
        }
    }

Done:

    //  cleanup uncached records

    Dns_RecordFree( prrAddr );
    Dns_RecordFree( prrPtr );

    DNSDBG( RPC, (
        "Leave R_ResolverRegisterCluster() => %d\n",
        status ));
#endif

    return  status;
}

//
//  End ip.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\server\logit.h ===
/*
 -  L O G I T . H
 -
 *  Purpose:
 *      Function and Macro definitions for logging module activity.
 *
 *  Author: Glenn A. Curtis
 *
 *  Comments:
 *      10/28/93    glennc     original file.
 *
 */

#ifndef LOGIT_H
#define LOGIT_H

#include <stdio.h>
#include <string.h>
#include <stdarg.h>
#include <time.h>

// #if DBG
   void  LogInit(void);
   void  CDECL LogIt( char *, ... );
   void  LogTime(void);
   DWORD LogIn( char * );
   void  LogOut( char *, DWORD );
// #else
// #undef ENABLE_DEBUG_LOGGING
// #endif // DBG

#ifdef ENABLE_DEBUG_LOGGING
#define DNSLOG_INIT() LogInit()
#else
#define DNSLOG_INIT() 
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DNSLOG_TIME() LogTime()
#else
#define DNSLOG_TIME() 
#endif

#ifdef ENABLE_DEBUG_LOGGING
#define DNSLOG_F1( a ) LogIt( a )
#else
#define DNSLOG_F1( a )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSLOG_F2( a, b ) LogIt( a, b )
#else
#define DNSLOG_F2( a, b )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSLOG_F3( a, b, c ) LogIt( a, b, c )
#else
#define DNSLOG_F3( a, b, c )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSLOG_F4( a, b, c, d ) LogIt( a, b, c, d )
#else
#define DNSLOG_F4( a, b, c, d ) 
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSLOG_F5( a, b, c, d, e ) LogIt( a, b, c, d, e )
#else
#define DNSLOG_F5( a, b, c, d, e ) 
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define DNSLOG_F6( a, b, c, d, e, f ) LogIt( a, b, c, d, e, f )
#else
#define DNSLOG_F6( a, b, c, d, e, f )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define LOG_IN( a ) LogIn( a )
#else
#define LOG_IN( a )
#endif                 

#ifdef ENABLE_DEBUG_LOGGING
#define LOG_OUT( a, b ) LogOut( a, b )
#else
#define LOG_OUT( a, b )
#endif                 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\server\logit.c ===
/*****************************************\
 *        Data Logging -- Debug only      *
\*****************************************/

//
//  Need local header ONLY to allow precompiled header.
//  Nothing in this module depends on specific DNS resolver
//  definitions.
//
#include "local.h"

//
// NT Headers
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

//
// Windows Headers
//
#include <windows.h>

#pragma  hdrstop

#include "logit.h"


// #if DBG

int LoggingMode;
time_t  long_time;      // has to be in DS, assumed by time() funcs
int LineCount;

char * month[] =
{
    "January",
    "February",
    "March",
    "April",
    "May",
    "June",
    "July",
    "August",
    "September",
    "October",
    "November",
    "December"
} ;


/*
 -  LogInit
 -
 *  Purpose:
 *  Determines if logging is desired and if so, adds a header to log file.
 *
 *  Parameters:
 *
 */
void LogInit()
{
    FILE    *fp;
    struct  tm  *newtime;
    char    am_pm[] = "a.m.";

    LoggingMode = 0;
    LineCount = 0;

    if ( fp = fopen( "dnsrslvr.log", "r+" ) )
    {
        LoggingMode = 1;
        fclose( fp );

        // Get time and date information

        long_time = time( NULL);        /* Get time as long integer. */
        newtime = localtime( &long_time ); /* Convert to local time. */

        if( newtime->tm_hour > 12 )    /* Set up extension. */
            am_pm[0] = 'p';
        if( newtime->tm_hour > 12 )    /* Convert from 24-hour */
            newtime->tm_hour -= 12;    /*   to 12-hour clock.  */
        if( newtime->tm_hour == 0 )    /*Set hour to 12 if midnight. */
            newtime->tm_hour = 12;

        // Write out a header to file

        fp = fopen("dnsrslvr.log", "w" );
        if ( !fp )
        {
            return;
        }

        fprintf( fp, "Logging information for DNS Caching Resolver service\n" );
        fprintf( fp, "****************************************************\n" );
        fprintf( fp, "\tTime: %d:%02d %s\n\tDate: %s %d, 19%d\n", 
                 newtime->tm_hour, newtime->tm_min, am_pm,
                 month[newtime->tm_mon], newtime->tm_mday,
                 newtime->tm_year );
        fprintf( fp, "****************************************************\n\n" );
        fclose( fp );
    }
}


/*
 -  LogIt
 -
 *  Purpose:
 *  Formats a string and prints it to a log file with handle hLog.
 *
 *  Parameters:
 *  LPSTR - Pointer to string to format
 *  ...   - variable argument list
 */

#ifdef WIN32
#define S16
#else
#define S16 static
#endif

void CDECL LogIt( char * lpszFormat, ... )
{
    FILE *fp;
#ifndef _ALPHA_
    va_list pArgs = NULL;       // reference to quiet compiler
#else
    va_list pArgs = {NULL,0};
#endif
    S16 char    szLogStr[1024];    
    int     i;

    if ( !LoggingMode )
        return;
    
#ifdef WIN32        // parse parameters and insert in string
    va_start( pArgs, lpszFormat);
    vsprintf(szLogStr, lpszFormat, pArgs);
    va_end(pArgs);

    i = lstrlenA( szLogStr);
#else              // parsing doesn't work, just give them string.
    _fstrcpy( szLogStr, lpszFormat);
    i = _fstrlen( szLogStr);
#endif
    szLogStr[i] = '\n';
    szLogStr[i+1] = '\0';


    if ( LineCount > 50000 )
    {
        fp = fopen( "dnsrslvr.log", "w" );
        LineCount = 0;
    }
    else
    {
        fp = fopen( "dnsrslvr.log", "a" );
    }
    if( fp )
    {
        fputs( szLogStr, fp );
        LineCount++;
        fclose( fp );
    }
}


void LogTime()
{
    struct  tm  *newtime;
    char    am_pm[] = "a.m.";

    if ( !LoggingMode )
        return;

    // Get time and date information

    long_time = time( NULL);        /* Get time as long integer. */
    newtime = localtime( &long_time ); /* Convert to local time. */

    if ( !newtime )
        return;

    if( newtime->tm_hour > 12 )    /* Set up extension. */
        am_pm[0] = 'p';
    if( newtime->tm_hour > 12 )    /* Convert from 24-hour */
        newtime->tm_hour -= 12;    /*   to 12-hour clock.  */
    if( newtime->tm_hour == 0 )    /*Set hour to 12 if midnight. */
        newtime->tm_hour = 12;

    // Write out a header to file

    LogIt( "DNS Caching Resolver service" );
    LogIt( "System Time Information" );
    LogIt( "****************************************************" );
    LogIt( "\tTime: %d:%02d %s\n\tDate: %s %d, 19%d",
           newtime->tm_hour, newtime->tm_min, am_pm,
           month[newtime->tm_mon], newtime->tm_mday,
           newtime->tm_year );
    LogIt( "****************************************************" );
    LogIt( "" );
}


DWORD LogIn( char * string )
{
    LogIt( "%s", string );
    return GetTickCount();
}


void LogOut( char * string, DWORD InTime )
{
    LogIt( "%s  ---  Duration: %ld milliseconds", string, GetTickCount() - InTime );
}


// #endif




//
//  Special logging routines
//

//
//  ENHANCE:  print routines here are really log routines
//      - they are really log routines
//      - should print generically so can be hooked to any print duty
//      - and have macros to log desired structure
//

VOID
PrintIpAddress(
    IN      DWORD           dwIpAddress
    )
{
    DNSLOG_F5(
        "                %d.%d.%d.%d",
        ((BYTE *) &dwIpAddress)[0],
        ((BYTE *) &dwIpAddress)[1],
        ((BYTE *) &dwIpAddress)[2],
        ((BYTE *) &dwIpAddress)[3] );
}


VOID
PrintSearchList(
    IN      PSEARCH_LIST    pSearchList
    )
{
    DWORD iter;

    DNSLOG_F1( "" );
    DNSLOG_F1( "    DNS Search List :" );

    for ( iter = 0; iter < pSearchList->NameCount; iter++ )
    {
        DNSLOG_F3( "        %s (Flags: 0x%X)",
                   pSearchList->SearchNameArray[iter].pszName,
                   pSearchList->SearchNameArray[iter].Flags );
    }

    DNSLOG_F1( "" );
}


VOID
PrintServerInfo(
    IN      PDNS_ADDR       pServer
    )
{
    //  FIX6:  DCR:  PrintServerInfo not IP6 safe

    DNSLOG_F1( "            IpAddress : " );
    PrintIpAddress( *(PIP4_ADDRESS)&pServer->SockaddrIn.sin_addr );
    DNSLOG_F2( "            Priority  : %d", pServer->Priority );
    DNSLOG_F2( "            status    : %d", pServer->Status );
    DNSLOG_F1( "" );
}


VOID
PrintAdapterInfo(
    IN      PDNS_ADAPTER    pAdapter
    )
{
    PDNS_ADDR_ARRAY pserverArray;
    DWORD           iter;

    DNSLOG_F2( "        %s", pAdapter->pszAdapterGuidName );
    DNSLOG_F1( "    ----------------------------------------------------" );
    DNSLOG_F2( "        pszAdapterDomain       : %s", pAdapter->pszAdapterDomain );

    if ( pAdapter->pLocalAddrs )
    {
        PDNS_ADDR_ARRAY pIp = pAdapter->pLocalAddrs;

        DNSLOG_F1( "        Adapter Ip Address(es) :" );
        for ( iter = 0; iter < pIp->AddrCount; iter++ )
        {
            PrintIpAddress( DnsAddr_GetIp4( &pIp->AddrArray[iter] ) );
        }
    }

    DNSLOG_F2( "        Status                 : 0x%x", pAdapter->Status );
    DNSLOG_F2( "        InfoFlags              : 0x%x", pAdapter->InfoFlags );
    DNSLOG_F2( "        ReturnFlags            : 0x%x", pAdapter->RunFlags );
    DNSLOG_F1( "" );

    pserverArray = pAdapter->pDnsAddrs;
    if ( pserverArray )
    {
        for ( iter = 0; iter < pserverArray->AddrCount; iter++ )
        {
            DNSLOG_F1( "        ------------------------" );
            DNSLOG_F2( "          DNS Server Info (%d)", iter + 1 );
            DNSLOG_F1( "        ------------------------" );
            PrintServerInfo( &pserverArray->AddrArray[iter] );
        }
    }

    DNSLOG_F1( "" );
}


VOID
PrintNetworkInfoToLog(
    IN      PDNS_NETINFO    pNetworkInfo
    )
{
    DWORD iter;

    if ( pNetworkInfo )
    {
        DNSLOG_F1( "Current network adapter information is :" );
        DNSLOG_F1( "" );
        DNSLOG_F2( "    pNetworkInfo->ReturnFlags    : 0x%x", pNetworkInfo->ReturnFlags );

        if ( pNetworkInfo->pSearchList )
            PrintSearchList( pNetworkInfo->pSearchList );

        DNSLOG_F2( "    pNetworkInfo->AdapterCount   : %d", pNetworkInfo->AdapterCount );
        DNSLOG_F2( "    pNetworkInfo->TotalListSize  : %d", pNetworkInfo->MaxAdapterCount );
        DNSLOG_F1( "" );

        for ( iter = 0; iter < pNetworkInfo->AdapterCount; iter++ )
        {
            DNSLOG_F1( "    ----------------------------------------------------" );
            DNSLOG_F2( "      Adapter Info (%d)", iter + 1 );
            DNSLOG_F1( "" );
            PrintAdapterInfo( &pNetworkInfo->AdapterArray[iter] );
        }
    }
    else
    {
        DNSLOG_F1( "Current network adapter information is empty" );
        DNSLOG_F1( "" );
    }
}

//
//  End of logit.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\server\mcast.c ===
/*++

Copyright (c) 2001-2002  Microsoft Corporation

Module Name:

    mcast.c

Abstract:

    DNS Resolver Service

    Multicast routines.

Author:

    James Gilroy (jamesg)       December 2001

Revision History:

--*/


#include "local.h"


//
//  Socket context 
//

typedef struct _McastSocketContext
{
    struct _SocketContext * pNext;
    SOCKET                  Socket;
    PDNS_MSG_BUF            pMsg;
    BOOL                    fRecvDown;

    OVERLAPPED              Overlapped;
}
MCSOCK_CONTEXT, *PMCSOCK_CONTEXT;


//
//  Globals
//

HANDLE              g_hMcastThread = NULL;
DWORD               g_McastThreadId = 0;

BOOL                g_McastStop = FALSE;
BOOL                g_McastConfigChange = TRUE;

HANDLE              g_McastCompletionPort = NULL;

PMCSOCK_CONTEXT     g_pMcastContext4 = NULL;
PMCSOCK_CONTEXT     g_pMcastContext6 = NULL;

PDNS_NETINFO        g_pMcastNetInfo = NULL;

PWSTR               g_pwsMcastHostName = NULL;


//
//  Mcast config globals
//

#define MCAST_RECORD_TTL  60        // 1 minute

DWORD   g_McastRecordTTL = MCAST_RECORD_TTL;



//
//  Private prototypes
//

VOID
mcast_ProcessRecv(
    IN OUT  PMCSOCK_CONTEXT pContext,
    IN      DWORD           BytesRecvd
    );




VOID
mcast_FreeIoContext(
    IN OUT  PMCSOCK_CONTEXT pContext
    )
/*++

Routine Description:

    Cleanup i/o context.

    Includes socket close.

Arguments:

    pContext -- context for socket being recieved

Return Value:

    None

--*/
{
    DNSDBG( TRACE, (
        "mcast_FreeIoContext( %p )\n",
        pContext ));

    //
    //  cleanup context list
    //      - close socket
    //      - free message buffer
    //      - free context
    //

    if ( pContext )
    {
        Socket_Close( pContext->Socket );

        MCAST_HEAP_FREE( pContext->pMsg );
        MCAST_HEAP_FREE( pContext );
    }
}



PMCSOCK_CONTEXT
mcast_CreateIoContext(
    IN      INT             Family,
    IN      PWSTR           pName
    )
/*++

Routine Description:

    Create and init a i/o context for a protocol.

Arguments:

    Family -- address family

    pName -- name to be published

Return Value:

    NO_ERROR if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS          status = NO_ERROR;
    PMCSOCK_CONTEXT     pcontext = NULL;
    SOCKET              sock = 0;
    DNS_ADDR            addr;
    HANDLE              hport;

    //
    //  setup mcast address
    //

    status = DnsAddr_BuildMcast(
                &addr,
                Family,
                pName
                );
    if ( status != NO_ERROR )
    {
        goto Failed;
    }

    //
    //  create multicast socket
    //      - bound to this address and DNS port
    //

    sock = Socket_CreateMulticast(
                SOCK_DGRAM,
                &addr,
                MCAST_PORT_NET_ORDER,
                FALSE,      // not send
                TRUE        // receive
                );

    if ( sock == 0 )
    {
        goto Failed;
    }

    //
    //  DCR:  mcast context could include message buffer
    //          (or even just reassign some fields in context
    //

    //  allocate and clear context

    pcontext = MCAST_HEAP_ALLOC_ZERO( sizeof(MCSOCK_CONTEXT) );
    if ( !pcontext )
    {
        goto Failed;
    }

    //  create message buffer for socket

    pcontext->pMsg = Dns_AllocateMsgBuf( 0 );
    if ( !pcontext->pMsg )
    {
        DNSDBG( ANY, ( "Error: Failed to allocate message buffer." ));
        goto Failed;
    }

    //  attach to completion port

    hport = CreateIoCompletionPort(
                (HANDLE) sock,
                g_McastCompletionPort,
                (UINT_PTR) pcontext,
                0 );

    if ( !hport )
    {
        DNSDBG( INIT, (
           "Failed to add socket to io completion port." ));
        goto Failed;
    }

    //  fill in context

    pcontext->Socket = sock;
    sock = 0;
    pcontext->pMsg->fTcp = FALSE;

#if 0
    //  not handling contexts in list yet

    //  insert into list

    InsertTailList( (PLIST_ENTRY)pcontext );
#endif
    
    return  pcontext;

Failed:

    Socket_Close( sock );
    mcast_FreeIoContext( pcontext );
    return  NULL;
}



VOID
mcast_DropReceive(
    IN OUT  PMCSOCK_CONTEXT pContext
    )
/*++

Routine Description:

    Drop down UDP receive request.

Arguments:

    pContext -- context for socket being recieved

Return Value:

    None

--*/
{
    DNS_STATUS      status;
    WSABUF          wsaBuf;
    DWORD           bytesRecvd;
    DWORD           flags = 0;
    INT             retry = 0;


    DNSDBG( TRACE, (
        "mcast_DropReceive( %p )\n",
        pContext ));


    if ( !pContext || !pContext->pMsg )
    {
        DNS_ASSERT( FALSE );
        return;
    }

    //
    //  DCR:  could support larger MCAST packets
    //

    wsaBuf.len = DNS_MAX_UDP_PACKET_BUFFER_LENGTH;
    wsaBuf.buf = (PCHAR) (&pContext->pMsg->MessageHead);

    pContext->pMsg->Socket = pContext->Socket;

    //
    //  loop until successful WSARecvFrom() is down
    //
    //  this loop is only active while we continue to recv
    //  WSAECONNRESET or WSAEMSGSIZE errors, both of which
    //  cause us to dump data and retry;
    //
    //  note loop rather than recursion (to this function) is
    //  required to avoid possible stack overflow from malicious
    //  send
    //
    //  normal returns from WSARecvFrom() are
    //      SUCCESS -- packet was waiting, GQCS will fire immediately
    //      WSA_IO_PENDING -- no data yet, GQCS will fire when ready
    //

    while ( 1 )
    {
        retry++;

        status = WSARecvFrom(
                    pContext->Socket,
                    & wsaBuf,
                    1,
                    & bytesRecvd,
                    & flags,
                    & pContext->pMsg->RemoteAddress.Sockaddr,
                    & pContext->pMsg->RemoteAddress.SockaddrLength,
                    & pContext->Overlapped,
                    NULL );

        if ( status == ERROR_SUCCESS )
        {
            pContext->fRecvDown = TRUE;
            return;
        }

        status = GetLastError();
        if ( status == WSA_IO_PENDING )
        {
            pContext->fRecvDown = TRUE;
            return;
        }

        //
        //  when last send ICMP'd
        //      - set flag to indicate retry and repost send
        //      - if over some reasonable number of retries, assume error
        //          and fall through recv failure code
        //

        if ( status == WSAECONNRESET ||
             status == WSAEMSGSIZE )
        {
            if ( retry > 10 )
            {
                Sleep( retry );
            }
            continue;
        }

        return;
    }
}



VOID
mcast_CreateIoContexts(
    VOID
    )
/*++

Routine Description:

    Create any uncreated i/o contexts.

    This is run dynamically -- after every mcast recv -- and creates
    any missing contexts, hence handling either previous failure or
    change in config (name change, protocol change).

Arguments:

    None

Return Value:

    None

--*/
{
    PDNS_NETINFO    pnetInfo;

    //
    //  get current netinfo
    //
    //  DCR:  should have "do we need new" netinfo check
    //

    pnetInfo = GrabNetworkInfo();
    if ( pnetInfo )
    {
        NetInfo_Free( g_pMcastNetInfo );
        g_pMcastNetInfo = pnetInfo;
    }
    else
    {
        pnetInfo = g_pMcastNetInfo;
    }

    //
    //  try\retry context setup, to handle dynamic IP\name
    //

    if ( !g_pMcastContext6 ||
         !Dns_NameCompare_W(
            g_pwsMcastHostName,
            pnetInfo->pszHostName ) )
    {
        g_pMcastContext6 = mcast_CreateIoContext( AF_INET6, pnetInfo->pszHostName );

        Dns_Free( g_pwsMcastHostName );
        g_pwsMcastHostName = Dns_CreateStringCopy_W( pnetInfo->pszHostName );
    }
    if ( !g_pMcastContext4 )
    {
        g_pMcastContext4 = mcast_CreateIoContext( AF_INET, NULL );
    }

    //
    //  redrop receives if not outstanding
    //

    mcast_DropReceive( g_pMcastContext6 );
    mcast_DropReceive( g_pMcastContext4 );
}




VOID
mcast_CleanupIoContexts(
    VOID
    )
/*++

Routine Description:

    Cleanup mcast i/o contexts created.

Arguments:

    None

Return Value:

    None

--*/
{
    mcast_FreeIoContext( g_pMcastContext6 );
    mcast_FreeIoContext( g_pMcastContext4 );

    g_pMcastContext6 = NULL;
    g_pMcastContext4 = NULL;
}



VOID
Mcast_Thread(
    VOID
    )
/*++

Routine Description:

    Mcast response thread.

    Runs while cache is running, responding to multicast queries.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNS_STATUS          status = NO_ERROR;
    PMCSOCK_CONTEXT     pcontext;
    DWORD               bytesRecvd;
    LPOVERLAPPED        poverlapped;
    BOOL                bresult;


    DNSDBG( MCAST, ( "Mcast_Thread() start!\n" ));

    //
    //  init mcast globals
    //

    g_McastStop = FALSE;
    g_McastCompletionPort = NULL;

    //
    //  create mcast completion port
    //

    g_McastCompletionPort = CreateIoCompletionPort(
                                    INVALID_HANDLE_VALUE,
                                    NULL,
                                    0,
                                    0 );
    if ( ! g_McastCompletionPort )
    {
        DNSDBG( ANY, (
            "Error:  Failed to create mcast completion port.\n" ));
        goto Cleanup;
    }

    //
    //  main listen loop
    //

    while ( 1 )
    {
        DNSDBG( MCAST, ( "Top of loop!\n" ));

        if ( g_McastStop )
        {
            DNSDBG( MCAST, ( "Terminating mcast loop.\n" ));
            break;
        }

        //
        //  wait
        //

        pcontext = NULL;

        bresult = GetQueuedCompletionStatus(
                        g_McastCompletionPort,
                        & bytesRecvd,
                        & (ULONG_PTR) pcontext,
                        & poverlapped,
                        INFINITE );

        if ( g_McastStop )
        {
            DNSDBG( MCAST, (
                "Terminating mcast loop after GQCS!\n" ));
            break;
        }

        if ( pcontext )
        {
            pcontext->fRecvDown = FALSE;
        }

        if ( bresult )
        {
            if ( pcontext && bytesRecvd )
            {
                mcast_ProcessRecv( pcontext, bytesRecvd );
            }
            else
            {
                status = GetLastError();

                DNSDBG( ANY, (
                    "Mcast GQCS() success without context!!!\n"
                    "\terror = %d\n",
                    status ));
                Sleep( 100 );
                continue;
            }
        }
        else
        {
            status = GetLastError();

            DNSDBG( ANY, (
                "Mcast GQCS() failed %d\n"
                "\terror = %d\n",
                status ));
            // Sleep( 100 );
            continue;
        }
    }


Cleanup:

    //
    //  cleanup multicast stuff
    //      - contexts, i/o completion port
    //      - note thread handle is closed by main thread as it is used
    //      for shutdown wait
    //      

    mcast_CleanupIoContexts();

    if ( g_McastCompletionPort )
    {
        CloseHandle( g_McastCompletionPort );
        g_McastCompletionPort = 0;
    }

    //NetInfo_Free( g_pMcastNetinfo );

    DNSDBG( TRACE, (
        "Mcast thread %d exit!\n\n",
        g_hMcastThread ));

    g_hMcastThread = NULL;
}



//
//  Public start\stop
//

DNS_STATUS
Mcast_Startup(
    VOID
    )
/*++

Routine Description:

    Startup multicast listen.

Arguments:

    None

Return Value:

    None

--*/
{
    DNS_STATUS  status;
    HANDLE      hthread;

    //
    //  screen
    //      - already started
    //      - no listen allowed
    //      - no IP4 listen and no IP6
    //

    if ( g_hMcastThread )
    {
        DNSDBG( ANY, (
            "ERROR:  called mcast listen with existing thread!\n" ));
        return  ERROR_ALREADY_EXISTS;
    }

    if ( g_MulticastListenLevel == MCAST_LISTEN_OFF )
    {
        DNSDBG( ANY, (
            "No mcast listen -- mcast list disabled.\n" ));
        return  ERROR_NOT_SUPPORTED;
    }
    if ( ! (g_MulticastListenLevel & MCAST_LISTEN_IP4)
            &&
         ! Util_IsIp6Running() )
    {
        DNSDBG( ANY, (
            "No mcast listen -- no IP4 mcast listen.\n" ));
        return  ERROR_NOT_SUPPORTED;
    }

    //
    //  fire up IP notify thread
    //

    g_McastStop = FALSE;
    status = NO_ERROR;

    hthread = CreateThread(
                    NULL,
                    0,
                    (LPTHREAD_START_ROUTINE) Mcast_Thread,
                    NULL,
                    0,
                    & g_McastThreadId
                    );
    if ( !hthread )
    {
        status = GetLastError();
        DNSDBG( ANY, (
            "FAILED to create IP notify thread = %d\n",
            status ));
    }

    g_hMcastThread = hthread;

    return  status;
}



VOID
Mcast_SignalShutdown(
    VOID
    )
/*++

Routine Description:

    Signal service shutdown to multicast thread.

Arguments:

    None

Return Value:

    None

--*/
{
    g_McastStop = TRUE;

    //
    //  shutdown recv
    //

    if ( g_McastCompletionPort )
    {
        PostQueuedCompletionStatus(
            g_McastCompletionPort,
            0,
            0,
            NULL );
    }
}




VOID
Mcast_ShutdownWait(
    VOID
    )
/*++

Routine Description:

    Wait for mcast shutdown.

    This is for service stop routine.

Arguments:

    None

Return Value:

    None

--*/
{
    HANDLE  mcastThread = g_hMcastThread;

    if ( ! mcastThread )
    {
        return;
    }

    //
    //  signal shutdown and wait
    //
    //  note, local copy of thread handle, as mcast thread clears
    //      global when it exits to serve as flag
    //

    Mcast_SignalShutdown();

    ThreadShutdownWait( mcastThread );
}



VOID
mcast_ProcessRecv(
    IN OUT  PMCSOCK_CONTEXT pContext,
    IN      DWORD           BytesRecvd
    )
/*++

Routine Description:

    Process received packet.

Arguments:

    pContext -- context for socket being recieved

    BytesRecvd -- bytes received

Return Value:

    None

--*/
{
    PDNS_RECORD     prr = NULL;
    PDNS_HEADER     phead;
    CHAR            nameQuestion[ DNS_MAX_NAME_BUFFER_LENGTH + 4 ];
    WORD            wtype;
    WORD            class;
    PDNS_MSG_BUF    pmsg;
    PCHAR           pnext;
    WORD            nameLength;
    DNS_STATUS      status;

    //
    //  need new network info?
    //

    if ( g_McastConfigChange ||
         ! g_pMcastNetInfo )
    {
        NetInfo_Free( g_pMcastNetInfo );

        DNSDBG( MCAST, ( "Mcast netinfo stale -- refreshing.\n" ));
        g_pMcastNetInfo = GrabNetworkInfo();
        if ( ! g_pMcastNetInfo )
        {
            DNSDBG( MCAST, ( "ERROR:  failed to get netinfo for mcast!!!\n" ));
            return;
        }
    }

    //
    //  check packet, extract question info
    //
    //      - flip header fields
    //      - opcode question
    //      - good format (Question==1, no Answer or Authority sections)
    //      - extract question
    //

    pmsg = pContext->pMsg;
    if ( !pmsg )
    {
        ASSERT( FALSE );
        return;
    }

    pmsg->MessageLength = (WORD)BytesRecvd;
    phead = &pmsg->MessageHead;
    DNS_BYTE_FLIP_HEADER_COUNTS( phead );

    if ( phead->IsResponse                  ||
         phead->Opcode != DNS_OPCODE_QUERY  ||
         phead->QuestionCount != 1          ||
         phead->AnswerCount != 0            ||
         phead->NameServerCount != 0 )
    {
        DNSDBG( ANY, (
            "WARNING:  invalid message recv'd by mcast listen!\n" ));
        return;
    }

    //  read question name

    pnext = Dns_ReadPacketName(
                nameQuestion,
                & nameLength,
                NULL,                       // no offset       
                NULL,                       // no previous name
                (PCHAR) (phead + 1),        // question name start
                (PCHAR) phead,              // message start
                (PCHAR)phead + BytesRecvd   // message end
                );
    if ( !pnext )
    {
        DNSDBG( ANY, (
            "WARNING:  invalid message question name recv'd by mcast!\n" ));
        return;
    }

    //  read question

    wtype = InlineFlipUnalignedWord( pnext );
    pnext += sizeof(WORD);
    class = InlineFlipUnalignedWord( pnext );
    pnext += sizeof(WORD);

    if ( pnext < (PCHAR)phead+BytesRecvd ||
         class != DNS_CLASS_INTERNET )
    {
        DNSDBG( ANY, (
            "WARNING:  invalid message question recv'd by mcast!\n" ));
        return;
    }

    DNSDBG( MCAST, (
        "Mcast recv msg (%p) qtype = %d, qname = %s\n",
        pmsg,
        wtype,
        nameQuestion ));

    //
    //  check query type
    //

    //
    //  for address\PTR types do local name check
    //
    //  note:  global mcast-netinfo valid, assumes this called only in single
    //      mcast response thread
    //
    //  note:  mcast query match no-data issue
    //      could have query match (name and no-ip of type) or (ip and
    //      unconfigured hostname) that could plausibly generate no-data
    //      response;  not worrying about this as it doesn't add value;
    //      and hard to get (no-address -- how'd packet get here)
    //

    if ( wtype == DNS_TYPE_AAAA ||
         wtype == DNS_TYPE_A ||
         wtype == DNS_TYPE_PTR )
    {
        QUERY_BLOB  blob;
        WCHAR       nameBuf[ DNS_MAX_NAME_BUFFER_LENGTH ];

        if ( !Dns_NameCopyWireToUnicode(
                nameBuf,
                nameQuestion ) )
        {
            DNSDBG( ANY, (
                "ERROR:  invalid mcast name %s -- unable to convert to unicode!\n",
                nameQuestion ));
            return;
        }

        RtlZeroMemory( &blob, sizeof(blob) );

        blob.pNameOrig = nameBuf;
        blob.wType = wtype;
        blob.Flags |= DNSP_QUERY_NO_GENERIC_NAMES;
        blob.pNetInfo = g_pMcastNetInfo;

        status = Local_GetRecordsForLocalName( &blob );
        prr = blob.pRecords;
        if ( status == NO_ERROR && prr )
        {
            goto Respond;
        }

        DNSDBG( MCAST, (
            "Mcast name %S, no match against local data.!\n",
            nameBuf ));

        prr = blob.pRecords;
        goto Cleanup;
    }

    //
    //  unsupported types
    //

    else
    {
        DNSDBG( MCAST, (
            "WARNING:  recv'd mcast type %d query -- currently unsupported.\n",
            wtype ));

        return;
    }


Respond:

    //
    //  write packet
    //      - records
    //      - set header bits

    status = Dns_AddRecordsToMessage(
                pmsg,
                prr,
                FALSE           // not an update
                );
    if ( status != NO_ERROR )
    {
        DNSDBG( MCAST, (
            "Failed mcast packet write!!!\n"
            "\tstatus = %d\n",
            status ));
        goto Cleanup;
    }

    pmsg->MessageHead.IsResponse = TRUE;
    pmsg->MessageHead.Authoritative = TRUE;

    //
    //  send -- unicast back to client
    //
    //  DCR:  mcast OPT, could consider assuming all mcast
    //      are OPT aware (WinCE?)
    //

    Socket_ClearMessageSockets( pmsg );

    status = Send_MessagePrivate(
                    pmsg,
                    & pmsg->RemoteAddress,
                    TRUE        // no OPT
                    );      

    DNSDBG( MCAST, (
        "Sent mcast response, status = %d\n",
        status ));

Cleanup:

    Dns_RecordListFree( prr );
    return;
}


//
//  End mcast.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\server\dnsrslvr.c ===
/*++

Copyright (c) 1997-2001  Microsoft Corporation

Module Name:

    dnsrslvr.c

Abstract:

    DNS Resolver Service

    Main service module.

Author:

    Glenn Curtis    (glennc)    25-Feb-1997

Revision History:

    Jim Gilroy  (jamesg)        March 2000      cleanup
    Jim Gilroy  (jamesg)        Nov 2000        rewrite

--*/


#include "local.h"

#ifdef  BUILD_W2K
#include <services.h>
#else
#include <svcs.h>
#endif


//
//  Service control
//

SERVICE_STATUS              ServiceStatus;
SERVICE_STATUS_HANDLE       ServiceStatusHandle = (SERVICE_STATUS_HANDLE) 0;

PSVCHOST_GLOBAL_DATA        g_pSvchostData;


HANDLE      g_hStopEvent;
BOOL        g_StopFlag;

BOOL        g_fServiceControlHandled;

//
//  Service state
//

#define RES_STATUS_BEGIN                0x0cc00000
#define RES_STATUS_ZERO_INIT            0x0cc00001
#define RES_STATUS_CREATED_CS           0x0cc00002
#define RES_STATUS_CREATED_EVENT        0x0cc00003
#define RES_STATUS_READ_REGISTRY        0x0cc00004
#define RES_STATUS_ALLOC_CACHE          0x0cc00005
#define RES_STATUS_START_NOTIFY         0x0cc00006
#define RES_STATUS_START_IP_LIST        0x0cc00007
#define RES_STATUS_START_RPC            0x0cc00008
#define RES_STATUS_REG_CONTROL          0x0cc00009
#define RES_STATUS_RUNNING              0x0cc00100
                                        
#define RES_STATUS_STOPPING             0x0cc00300
#define RES_STATUS_SIGNALED_STOP        0x0cc00301
#define RES_STATUS_STOP_RPC             0x0cc00302
#define RES_STATUS_STOP_NOTIFY          0x0cc00303
#define RES_STATUS_STOP_IP_LIST         0x0cc00304
#define RES_STATUS_FREE_CACHE           0x0cc00305
#define RES_STATUS_FREE_NET_INFO        0x0cc00306
#define RES_STATUS_FREE_IP_LIST         0x0cc00307
#define RES_STATUS_FREE_SERVICE_NOTIFY  0x0cc00308
#define RES_STATUS_DEL_EVENT            0x0cc00309
#define RES_STATUS_DEL_CS               0x0cc00310
#define RES_STATUS_END                  0x0cc00400

DWORD       g_ResolverStatus = RES_STATUS_BEGIN;

//
//  Initialization cleanup\state
//
//  Track what we intialized for safer\faster cleanup
//

#define INITFLAG_CACHE_CS               0x00000001
#define INITFLAG_NETINFO_CS             0x00000002
#define INITFLAG_NETINFO_BUILD_LOCK     0x00000004
#define INITFLAG_NETFAIL_CS             0x00000008
#define INITFLAG_WINSOCK                0x00000010
#define INITFLAG_EVENTS_CREATED         0x00000020
#define INITFLAG_CACHE_CREATED          0x00000100
#define INITFLAG_NOTIFY_STARTED         0x00001000
#define INITFLAG_IP_LIST_CREATED        0x00002000
#define INITFLAG_RPC_SERVER_STARTED     0x00010000

DWORD       g_InitState;


//
//  Critical sections used
//

CRITICAL_SECTION    CacheCS;
CRITICAL_SECTION    NetworkFailureCS;


//
//  Logging control
//

BOOL        g_LogTraceInfo = TRUE;


//
//  Private protos
//

DWORD
ResolverInitialize(
    VOID
    );

VOID
ResolverShutdown(
    IN      DWORD           ErrorCode
    );

VOID
ResolverControlHandler(
    IN      DWORD           Opcode
    );

DWORD
ResolverUpdateStatus(
    VOID
    );



//
//  Service routines
//

VOID
SvchostPushServiceGlobals(
    PSVCHOST_GLOBAL_DATA    pGlobals
    )
{
    g_pSvchostData = pGlobals;
}


VOID
ServiceMain(
    IN      DWORD           NumArgs,
    IN      LPTSTR *        ArgsArray
    )
/*++

Routine Description:

    Main entry point of resolver service.

Arguments:

    NumArgs - number of strings specified in ArgsArray.

    ArgsArray - array of ptrs to arguments in service start call

Return Value:

    None

--*/
{
    //
    //  Make sure svchost.exe gave us global data
    //

    ASSERT( g_pSvchostData != NULL );

    //
    //  Startup service, then exit
    //

    ResolverInitialize();
}



VOID
ResolverInitFailure(
    IN      DNS_STATUS      Status,
    IN      DWORD           EventId,
    IN      DWORD           MemEventId,
    IN      PSTR            pszDebugString
    )
/*++

Routine Description:

    Handle resolver init failure.

    Function exists to avoid duplicate code.

Arguments:

Return Value:

    None

--*/
{
    WCHAR   numberString[16];
    PWSTR   eventStrings[1];

    DNSLOG_TIME();
    DNSLOG_F1( "Resolver Init Failure" );
    DNSLOG_F2( "    Failure = %s", pszDebugString );
    DNSLOG_F2( "    Status  = %d", Status );
    DNSLOG_F1( "" );

    DNSDBG( ANY, (
        "Resolver Init FAILED!\n"
        "\tname         = %s\n"
        "\tstatus       = %d\n"
        "\tevent id     = %d\n"
        "\tmem event    = %08x\n",
        pszDebugString,
        Status,
        EventId,
        MemEventId ));

    DnsDbg_PrintfToDebugger(
        "ResolverInitialize - Returning status %d 0x%08x\n"
        "\tname = %s\n",
        Status, Status,
        pszDebugString );

    //
    //  log in memory event
    //
            
    LogEventInMemory( MemEventId, Status );

    //
    //  log event
    //      - convert status to string
    //

    wsprintfW( numberString, L"0x%.8X", Status );
    eventStrings[0] = numberString;

    ResolverLogEvent(
        EventId,
        EVENTLOG_ERROR_TYPE,
        1,
        eventStrings,
        Status );

    //  clean up

    ResolverShutdown( Status );
}



DWORD
ResolverInitialize(
    VOID
    )
/*++

Routine Description:

    This function initializes the DNS Caching Resolver service.

Arguments:

    InitState - Returns a flag to indicate how far we got with
                        initializing the service before an error occurred.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status = NO_ERROR;

    //
    //  init service state
    //

    g_ResolverStatus = RES_STATUS_BEGIN;
    g_InitState = 0;
    g_StopFlag = FALSE;
    g_hStopEvent = NULL;
    g_fServiceControlHandled = FALSE;

    //
    //  initialize logging
    //

    DNSLOG_INIT();
    DNSLOG_F1( "DNS Caching Resolver Service - ResolverInitialize" );

#if DBG
    Dns_StartDebugEx(
        0,                  //  no flag value
        "dnsres.flag",
        NULL,               //  no external flag
        "dnsres.log",
        0,                  //  no wrap limit
        FALSE,              //  don't use existing global
        FALSE,
        TRUE                //  make this file global
        );
#endif

    DNSDBG( INIT, ( "DNS resolver startup.\n" ));
    IF_DNSDBG( START_BREAK )
    {
        //  since resolver moved to NetworkServices permissions do
        //  not properly bring up ntsd;  instead just give time
        //  to attach debugger

        Sleep( 20000 );
    }

    //
    //  initialize service status block
    //      

    ServiceStatusHandle = (SERVICE_STATUS_HANDLE) 0;

    ServiceStatus.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    ServiceStatus.dwControlsAccepted = 0;
    ServiceStatus.dwCheckPoint = 0;
    ServiceStatus.dwWaitHint = 5000;
    ServiceStatus.dwWin32ExitCode = NO_ERROR;
    ServiceStatus.dwServiceSpecificExitCode = 0;

    ResolverUpdateStatus();

    //
    //  init globals to zero
    //

    ZeroInitIpListGlobals();
    ZeroNetworkConfigGlobals();
    g_ResolverStatus = RES_STATUS_ZERO_INIT;

    //
    //  initialize all our critical sections as soon as we can
    //

    LogEventInMemory( RES_EVENT_INITCRIT_START, 0 );

    if ( RtlInitializeCriticalSection( &CacheCS ) != NO_ERROR )
    {
        goto Failed;
    }
    g_InitState |= INITFLAG_CACHE_CS;
    if ( RtlInitializeCriticalSection( &NetworkFailureCS ) != NO_ERROR )
    {
        goto Failed;
    }
    g_InitState |= INITFLAG_NETFAIL_CS;
    if ( RtlInitializeCriticalSection( &NetinfoCS ) != NO_ERROR )
    {
        goto Failed;
    }
    g_InitState |= INITFLAG_NETINFO_CS;
    if ( TimedLock_Initialize( &NetinfoBuildLock, 5000 ) != NO_ERROR )
    {
        goto Failed;
    }
    g_InitState |= INITFLAG_NETINFO_BUILD_LOCK;

    LogEventInMemory( RES_EVENT_INITCRIT_END,0  );

    //
    //  init our dnslib heap to use dnsapi heap
    //
    //  this is important because we currently mix and match records
    //  created inside dnsapi (hosts file and query) with a few that
    //  we roll on our own;  need this to be common
    //

    Dns_LibHeapReset( DnsApiAlloc, DnsApiRealloc, DnsApiFree );

    //
    //  init winsock
    //

    Socket_InitWinsock();
    g_InitState |= INITFLAG_WINSOCK;

    //
    //  shutdown event
    //

    g_hStopEvent = CreateEvent(
                        NULL,       // no security descriptor
                        TRUE,       // do not use automatic reset
                        FALSE,      // initial state: not signalled
                        NULL        // no name
                        );
    if ( !g_hStopEvent )
    {
        status = GetLastError();

        ResolverInitFailure(
            status,
            0,
            0,
            "CreateEvent() failed" );
        return status;
    }
    g_InitState |= INITFLAG_EVENTS_CREATED;
    g_ResolverStatus = RES_STATUS_CREATED_EVENT;

    ResolverUpdateStatus();

    //
    //  initialize our global registry values
    //      - force this just once on startup so we have the
    //      relevant cache params;  after that read only on
    //      demand when building netinfo blobs

    ReadRegistryConfig();

    //
    //  Set the query timeouts to be used from defaults or registry
    //

    Dns_InitQueryTimeouts();

    //
    //  init socket caching
    //      - improves perf and prevents socket DOS attack
    //      - default cache to 10 sockets
    //
    //  DCR:  create global for socket caching
    //
    
    Socket_CacheInit( 10 );

    //
    //  notification thread (host file and registry)
    //

    StartNotify();
    g_InitState |= INITFLAG_NOTIFY_STARTED;
    g_ResolverStatus = RES_STATUS_START_NOTIFY;
    ResolverUpdateStatus();

    //
    //  IP notification thread
    //

    status = InitIpListAndNotification();
    if ( status != ERROR_SUCCESS )
    {
        ResolverInitFailure(
            status,
            0,
            0,
            "IP list init failed" );
        return status;
    }
    g_InitState |= INITFLAG_IP_LIST_CREATED;
    g_ResolverStatus = RES_STATUS_START_IP_LIST;
    ResolverUpdateStatus();

    //
    //  register control handler
    //  allows us to receive service requests
    //

    ServiceStatusHandle = RegisterServiceCtrlHandlerW(
                                DNS_RESOLVER_SERVICE,
                                ResolverControlHandler
                                );
    if ( !ServiceStatusHandle )
    {
        status = GetLastError();
        ResolverInitFailure(
            status,
            EVENT_DNS_CACHE_START_FAILURE_LOW_MEMORY,
            RES_EVENT_REGISTER_SCH,
            "Call to RegisterServiceCtrlHandlerW failed!"
            );
        return status;
    }
    g_ResolverStatus = RES_STATUS_REG_CONTROL;
    ResolverUpdateStatus();

    //
    //  initialize RPC interfaces
    //      - bump our requested stack size up to 8K
    //      (RPC uses 1800 bytes before we get the stack,
    //      the new() operator followed by the heap code uses
    //      another 1200 -- leaving only about a 1000 for
    //      DNS)
    //

    LogEventInMemory( RES_EVENT_START_RPC, 0 );

#if 0
    //  should not be necessary
    //  default for all svchost instances has been increased
    if ( status != NO_ERROR )
    {
        DNSDBG( ANY, (
            "RpcMgmtSetServerStackSize( 2000 ) = %d\n",
            status ));
    }
#endif

    status = Rpc_Initialize();
#if 0
    status = g_pSvchostData->StartRpcServer(
                                SERVER_INTERFACE_NAME_W,
                                DnsResolver_ServerIfHandle );
#endif
    if ( status != NO_ERROR )
    {
        LogEventInMemory( RES_EVENT_STATUS, status );

        if ( status == RPC_S_TYPE_ALREADY_REGISTERED ||
             status == RPC_NT_TYPE_ALREADY_REGISTERED )
        {
            DNSLOG_TIME();
            DNSLOG_F1( "   Call to StartRpcServer returned warning that" );
            DNSLOG_F1( "   the service is already running!" );
            DNSLOG_F2( "   RpcPipeName : %S", RESOLVER_INTERFACE_NAME_W );
            DNSLOG_F1( "   Going to just continue running . . ." );
            DNSLOG_F1( "" );

            DnsDbg_PrintfToDebugger(
                "DNS Client (dnsrslvr.dll) - Call to StartRpcServer\n"
                "returned warning that the service is already running!\n"
                "RpcPipeName : %S"
                "Going to just continue running . . .\n",
                RESOLVER_INTERFACE_NAME_W );

            status = NO_ERROR;
        }
        else
        {
            DNSDBG( ANY, (
                "RPC init FAILED!  status = %d\n"
                "\tpipe name = %s\n",
                status,
                RESOLVER_INTERFACE_NAME_W ));

            ResolverInitFailure(
                status,
                EVENT_DNS_CACHE_START_FAILURE_NO_RPC,
                0,
                "Call to StartRpcServer failed!"
                );
            return status;
        }
    }

    g_ResolverStatus = RES_STATUS_START_RPC;
    g_InitState |= INITFLAG_RPC_SERVER_STARTED;

    //
    //  successful startup
    //      - indicate running
    //      - indicate what service control messages we want to get
    //

    ServiceStatus.dwCurrentState = SERVICE_RUNNING;
    ServiceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP |
                                        SERVICE_ACCEPT_PARAMCHANGE |
                                        SERVICE_ACCEPT_NETBINDCHANGE;
    ServiceStatus.dwWaitHint = 0;
    ServiceStatus.dwWin32ExitCode = NO_ERROR;

    ResolverUpdateStatus();

    g_ResolverStatus = RES_STATUS_RUNNING;
    LogEventInMemory( RES_EVENT_STARTED, 0 );

    DNSLOG_F1( "ResolverInitialize - Successful" );
    DNSLOG_F1( "" );
    return NO_ERROR;

Failed:

    if ( status == NO_ERROR )
    {
        status = DNS_ERROR_NO_MEMORY;
    }
    return  status;
}



VOID
ResolverShutdown(
    IN      DWORD           ErrorCode
    )
/*++

Routine Description:

    This function shuts down the DNS cache service.

Arguments:

    ErrorCode - Supplies the error code of the failure

Return Value:

    None.

--*/
{
    DWORD   status = NO_ERROR;
    LONG    existingStopFlag;

    DNSLOG_TIME();
    DNSLOG_F1( "DNS Caching Resolver Service - ResolverShutdown" );
    DnsDbg_PrintfToDebugger( "DNS Client - ResolverShutdown!\n" );

    //
    //  indicate shutdown
    //      - but interlock to avoid dual shutdown
    //

    existingStopFlag = InterlockedExchange(
                            &g_StopFlag,
                            (LONG) TRUE );
    if ( existingStopFlag )
    {
        DNS_ASSERT( FALSE );
        return;
    }
    DNS_ASSERT( g_StopFlag );

    //
    //  indicate stop in progress
    //

    ServiceStatus.dwCurrentState = SERVICE_STOP_PENDING;
    ServiceStatus.dwCheckPoint = 1;
    ServiceStatus.dwWaitHint = 60000;
    ResolverUpdateStatus();

    g_ResolverStatus = RES_STATUS_STOPPING;


    //
    //  wakeup threads to shut down
    //

    LogEventInMemory( RES_EVENT_STOPPING, 0 );

    g_StopFlag = TRUE;
    if ( g_hStopEvent )
    {
        if ( !SetEvent(g_hStopEvent) )
        {
            DnsDbg_PrintfToDebugger(
                "DNSCACHE: Error setting g_hStopEvent %lu\n",
                GetLastError());
            DNS_ASSERT( FALSE );
        }
    }
    g_ResolverStatus = RES_STATUS_SIGNALED_STOP;

    //
    //  cleanup RPC
    //

    if ( g_InitState & INITFLAG_RPC_SERVER_STARTED )
    {
        LogEventInMemory( RES_EVENT_STOP_RPC, 0 );

        Rpc_Shutdown();
#if 0
        //status = g_pSvchostData->StopRpcServer( DnsResolver_ServerIfHandle );
#endif
    }
    g_ResolverStatus = RES_STATUS_STOP_RPC;

    //
    //  re-signal stop within lock
    //

    LOCK_CACHE_NO_START();
    g_StopFlag = TRUE;
    if ( g_hStopEvent )
    {
        if ( !SetEvent(g_hStopEvent) )
        {
            DnsDbg_PrintfToDebugger(
                "DNSCACHE: Error setting g_hStopEvent %lu\n",
                GetLastError());
            DNS_ASSERT( FALSE );
        }
    }
    UNLOCK_CACHE();

    //
    //  stop notify thread
    //

    if ( g_InitState & INITFLAG_NOTIFY_STARTED )
    {
        ShutdownNotify();
    }
    g_ResolverStatus = RES_STATUS_STOP_NOTIFY;

    //
    //  stop IP notify thread
    //

    if ( g_InitState & INITFLAG_IP_LIST_CREATED )
    {
        ShutdownIpListAndNotify();
    }
    g_ResolverStatus = RES_STATUS_STOP_IP_LIST;

    //
    //  cleanup cache
    //

    Cache_Shutdown();
    g_ResolverStatus = RES_STATUS_FREE_CACHE;

    //
    //  cleanup service notification list
    //

    //CleanupServiceNotification();
    //g_ResolverStatus = RES_STATUS_FREE_SERVICE_NOTIFY;

    //
    //  cleanup network info globals
    //

    CleanupNetworkInfo();
    g_ResolverStatus = RES_STATUS_FREE_NET_INFO;

    //
    //  cleanup winsock
    //  cleanup socket caching also
    //      - this is irrelevant for other services running in
    //      our process so we shouldn't leave the handles open
    //  

    if ( g_InitState & INITFLAG_WINSOCK )
    {
        Socket_CacheCleanup();
        Socket_CleanupWinsock();
    }

    //
    //  cleanup main shutdown event
    //

    if ( g_InitState & INITFLAG_EVENTS_CREATED )
    {
        if ( g_hStopEvent )
        {
            CloseHandle(g_hStopEvent);
            g_hStopEvent = NULL;
        }
    }
    g_ResolverStatus = RES_STATUS_DEL_EVENT;

    //
    //  delete critical sections\locks
    //

    if ( g_InitState & INITFLAG_CACHE_CS )
    {
        DeleteCriticalSection( &CacheCS );
    }
    if ( g_InitState & INITFLAG_NETFAIL_CS )
    {
        DeleteCriticalSection( &NetworkFailureCS );
    }
    if ( g_InitState & INITFLAG_NETINFO_CS )
    {
        DeleteCriticalSection( &NetinfoCS );
    }
    if ( g_InitState & INITFLAG_NETINFO_BUILD_LOCK )
    {
        TimedLock_Cleanup( &NetinfoBuildLock );
    }
    g_ResolverStatus = RES_STATUS_DEL_CS;

    //
    //  cleanup complete
    //  tell Service Controller that we are stopped
    //

    ServiceStatus.dwCurrentState = SERVICE_STOPPED;
    ServiceStatus.dwControlsAccepted = 0;
    ServiceStatus.dwWin32ExitCode = ErrorCode;
    ServiceStatus.dwServiceSpecificExitCode = 0;
    ServiceStatus.dwCheckPoint = 0;
    ServiceStatus.dwWaitHint = 0;

    ResolverUpdateStatus();

    g_ResolverStatus = RES_STATUS_END;

    DNSLOG_F1( "ResolverShutdown - Finished" );
    DNSLOG_F1( "" );
}



BOOL
GetServiceControlLock(
    VOID
    )
/*++

Routine Description:

    Get exclusive access handling service control message.

Arguments:

    None

Return Value:

    TRUE -- have exclusive access to handle SCM, other threads locked out
    FALSE -- another thread still handling SCM

--*/
{
    BOOL    fresult;

    //
    //  set handled flag, if not previously set
    //  if not previous set -> we have exclusive access
    //

    fresult = InterlockedCompareExchange(
                    &g_fServiceControlHandled,
                    (LONG) TRUE,    // new value
                    (LONG) 0        // previous value to do exchange
                    );

    return  !fresult;
}


VOID
ReleaseServiceControlLock(
    VOID
    )
/*++

Routine Description:

    Release service control exclusive access.

Arguments:

    None

Return Value:

    None

--*/
{
    //
    //  clear handled flag
    //      - since GetServiceControlLock() uses CompareExchange
    //      we can just clear without interlock
    //  

    DNS_ASSERT( g_fServiceControlHandled );
    g_fServiceControlHandled = FALSE;
}




VOID
ResolverControlHandler(
    IN      DWORD           Opcode
    )
/*++

Routine Description:

    Service control handler for DNS cache service.

Arguments:

    Opcode - specifies service action

Return Value:

    None.

--*/
{
    LogEventInMemory( RES_EVENT_SERVICE_CONTROL, Opcode );

    DNSLOG_TIME();
    DNSLOG_F2( "ResolverControlHandler - Recieved opcode %d", Opcode );

    DNSDBG( ANY, (
        "\n\n"
        "ResolverControlHandler()  Opcode = %d\n",
        Opcode ));

    //
    //  handle various service control codes
    //

    switch( Opcode )
    {

    case SERVICE_CONTROL_STOP:

        //
        //  shutdown
        //      - ResolverShutdown() updates status with SCM, so we don't update
        //      status here (as SCM will start invalidating stuff on stop)
        //      but jump directly to exit
        //      

        ResolverShutdown( NO_ERROR );
        goto Done;

    case SERVICE_CONTROL_PARAMCHANGE :

        DNSLOG_F1( "  Handle Paramchange" );
        DNSLOG_F1( "" );

        if ( !GetServiceControlLock() )
        {
            return;
        }

        //
        //  rebuild -- with cache flush
        //

        HandleConfigChange(
            "SC -- ParamChange",
            TRUE        // flush cache
            );

        //
        //  signal other services about PnP
        //
        // SendServiceNotifications();

        ReleaseServiceControlLock();
        break;

    case SERVICE_CONTROL_NETBINDENABLE:
    case SERVICE_CONTROL_NETBINDDISABLE:

        DNSLOG_F1( "  Handle NetBindEnable\\Disable" );
        DNSLOG_F1( "" );

        if ( !GetServiceControlLock() )
        {
            return;
        }

        //
        //  rebuild -- with cache flush
        //

        HandleConfigChange(
            "SC -- NetBind",
            TRUE        // flush cache
            );

        ReleaseServiceControlLock();
        break;

    case SERVICE_CONTROL_INTERROGATE:
    case SERVICE_CONTROL_NETBINDADD:
    case SERVICE_CONTROL_NETBINDREMOVE:
    default:

        DNSLOG_F1( "    This is an unknown opcode, ignoring ..." );
        DNSLOG_F1( "" );
        break;
    }

    //
    //  update service status
    //

    ResolverUpdateStatus();

Done:

    DNSLOG_F2( "Resolver Controll Handler (opcode = %d) -- returning", Opcode );

    DNSDBG( ANY, (
        "Leaving ResolverControlHandler( %d )\n\n\n",
        Opcode ));
}



DWORD
ResolverUpdateStatus(
    VOID
    )
/*++

Routine Description:

    Update service controller with current service status.

Arguments:

    None.

Return Value:

    Return code from SetServiceStatus.

--*/
{
    DWORD   status;
    DWORD   logStatus;

    DNSDBG( TRACE, ( "ResolverUpdateStatus()\n" ));

    //
    //  bump the checkpoint
    //

    ServiceStatus.dwCheckPoint++;

    if ( ServiceStatusHandle == (SERVICE_STATUS_HANDLE) 0 )
    {
        LogEventInMemory( RES_EVENT_UPDATE_STATUS, ERROR_INVALID_HANDLE );
        return ERROR_INVALID_HANDLE;
    }

    //
    //  log memory event
    //      - the current state
    //      - the error, if exists

    LogEventInMemory( RES_EVENT_UPDATE_STATE, ServiceStatus.dwCurrentState );

    status = ServiceStatus.dwWin32ExitCode;
    if ( status != NO_ERROR )
    {
        LogEventInMemory( RES_EVENT_UPDATE_STATUS, status );
    }

    //
    //  update service controller
    //

    if ( ! SetServiceStatus( ServiceStatusHandle, &ServiceStatus ) )
    {
        status = GetLastError();
        LogEventInMemory( RES_EVENT_UPDATE_STATUS, status );
    }

    return status;
}



//
//  Event logging
//

VOID
ResolverLogEvent(
    IN      DWORD           MessageId,
    IN      WORD            EventType,
    IN      DWORD           StringCount,
    IN      PWSTR *         StringArray,
    IN      DWORD           ErrorCode
    )
/*++

Routine Description:

    Log to eventlog.

Arguments:

    MessageId -- event message id

    EventType -- event type (error, warning, info, etc.)

    StringCount -- string arg count

    StringArray -- imbedded strings

    ErrorCode -- error code for data section of event

Return Value:

    None

--*/
{
    HANDLE  hlog;
    PVOID   pdata = NULL;

    //
    //  open resolver as event source
    //
    //  note:  we don't keep log open because events are few
    //

    hlog = RegisterEventSourceW(
                    NULL,
                    DNS_RESOLVER_SERVICE );

    if ( hlog == NULL )
    {
        return;
    }

    if ( ErrorCode != NO_ERROR )
    {
        pdata = &ErrorCode;
    }

    //
    //  Write to event log
    //
    //  DCR:  should get suppression technology here
    //

    ReportEventW(
        hlog,
        EventType,
        0,            // event category
        MessageId,
        (PSID) NULL,
        (WORD) StringCount,
        sizeof(DWORD),
        StringArray,
        (PVOID) pdata );
    
    DeregisterEventSource( hlog );
}


//
//  End dnsrslvr.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\server\memlog.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    memlog.c

Abstract:

    DNS Resolver Service

    In memory logging.

Author:

    Glenn Curtis    (glennc)    Feb 1998

Revision History:

    Jim Gilroy  (jamesg)        March 2000      cleanup
    Jim Gilroy  (jamesg)        Nov 2000        create this module

--*/


#include "local.h"


//
//  Memory event array
//

typedef struct _InMemoryEvent
{
    DWORD           Thread;
    DWORD           Ticks;
    DWORD           Checkpoint;
    DWORD           Data;
}
MEM_EVENT, *PMEM_EVENT;


#define MEM_EVENT_ARRAY_SIZE    200

PMEM_EVENT  g_pEventArray = NULL;

LONG        g_EventArrayLength = MEM_EVENT_ARRAY_SIZE;
LONG        g_EventIndex = 0;



VOID
LogEventInMemory(
    IN      DWORD           Checkpoint,
    IN      DWORD           Data
    )
{
    DWORD   index;

    //
    //  allocate event table
    //      - use interlock to insure only done once
    //

    if ( !g_pEventArray )
    {
        PMEM_EVENT  ptemp = (PMEM_EVENT)
                                HeapAlloc(
                                    GetProcessHeap(),
                                    HEAP_ZERO_MEMORY,
                                    g_EventArrayLength * sizeof(MEM_EVENT) );
        if ( !ptemp )
        {
            return;
        }
        if ( InterlockedCompareExchangePointer(
                (PVOID *) &g_pEventArray,
                ptemp,
                0) != 0 )
        {
            HeapFree(GetProcessHeap(), 0, ptemp);
        }
    }

    //
    //  write event to memory
    //

    index = InterlockedIncrement( &g_EventIndex );

    index %= g_EventArrayLength;

    g_pEventArray[index].Ticks      = GetTickCount();
    g_pEventArray[index].Checkpoint = Checkpoint;
    g_pEventArray[index].Thread     = (short) GetCurrentThreadId();
    g_pEventArray[index].Data       = Data;
}

//
//  memlog.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\server\memory.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    memory.c

Abstract:

    DNS Resolver Service

    Memory management.

Author:

    James Gilroy (jamesg)       March 2000

Revision History:

--*/


#include "local.h"


//
//  Note:  most records are created by dnsapi heap -- from
//  query or hosts file routines.  However, we do create
//  name error caching records ourselves using dnslib routines.
//
//  This means -- until we either
//      - extend query or dnslib record creation interfaces to
//        include heap parameter
//      - explicitly free and recreate
//      - tag records (dnsapi\not) somehow (flags field)
//  that
//  dnsapi and dnslib heaps MUST be the same.
//  With dnsapi now potentially having it's own heap, this means
//  dnslib should use dnsapi heap.
//
//  So we'll put off using the debug heap for dnslib.
//
//
//  Note the ideal solution:
//      - dnsapi (query and hosts file) creates records in
//          the cache heap (by passed heap handle)
//      - we create our NAME_ERROR records locally in that
//          heap also (our functionalize to dnsapi)
//      - copy for RPC can be in separate heap used only by MIDL
//      - we have a separate heap for other random crap in the process
//          


//
//  Counters for heap debugging
//

DWORD   g_ResAllocCount     = 0;
DWORD   g_ResAllocMemory    = 0;
DWORD   g_ResFreeCount      = 0;

DWORD   g_MidlAllocCount    = 0;
DWORD   g_MidlAllocMemory   = 0;
DWORD   g_MidlFreeCount     = 0;




//
//  RPC memory routines
//
//  These are called by the stub code generated by MIDL.
//

PVOID
WINAPI
MIDL_user_allocate(
    IN      size_t          Size
    )
{
    DNSDBG( HEAP, (
        "MIDL_user_allocate( %d )\n",
        Size ));

    g_MidlAllocCount++;
    g_MidlAllocMemory += Size;

    // return( ALLOCATE_HEAP( Size ) );
    // return  DnsApiAlloc( Size );

    return  Dns_Alloc( Size );
}

VOID
WINAPI
MIDL_user_free(
    IN OUT  PVOID           pMem
    )
{
    DNSDBG( HEAP, (
        "MIDL_user_free( %p )\n",
        pMem ));

    g_MidlFreeCount++;

    // FREE_HEAP( pMem );
    // DnsApiFree( pMem );

    Dns_Free( pMem );
}



//
//  Resolver heap routines
//
//  Currently (see note above) everything RPC, record allocs
//  and general allocs are in the same heap.
//  However the Tag field sets us up to dispatch to different
//  heaps.  The file and line info allow us to later use
//  debug heap routines.
//  

PVOID
Res_Alloc(
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      PSTR            pszFile,
    IN      DWORD           LineNo
    )
{
    DNSDBG( HEAP, (
        "Res_Alloc( %d, tag=%d )\n",
        Length,
        Tag ));

    g_ResAllocCount++;
    g_ResAllocMemory += Length;

    return  Dns_Alloc( Length );
}


PVOID
Res_AllocZero(
    IN      DWORD           Length,
    IN      DWORD           Tag,
    IN      PSTR            pszFile,
    IN      DWORD           LineNo
    )
{
    return  Dns_AllocZero( Length );
}


VOID
Res_Free(
    IN OUT  PVOID           pMemory,
    IN      DWORD           Tag
    )
{
    DNSDBG( HEAP, (
        "Res_Free( %p, tag=%d )\n",
        pMemory,
        Tag ));

    g_ResFreeCount++;

    Dns_Free( pMemory );
}

//
//  End memory.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\server\ncache.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    ncache.c

Abstract:

    DNS Resolver Service

    Cache routines

Author:

    Jim Gilroy (jamesg)     April 2001

Revision History:

--*/


#include "local.h"


//
//  Heap corruption tracking
//

#define HEAPPROB    1

#define BAD_PTR     (PVOID)(-1)


//
//  Cache entry definitions
//
//  Starting cache record count
//

#define CACHE_DEFAULT_SET_COUNT  3

#if 0
//  Should be private but is exposed in remote
//  cache enum routines.

typedef struct _CacheEntry
{
    struct _CacheEntry *    pNext;
    PWSTR                   pName;
    DWORD                   Reserved;
    DWORD                   MaxCount;
    PDNS_RECORD             Records[ 1 ];
}
CACHE_ENTRY, *PCACHE_ENTRY;
#endif

//
//  Cache heap
//

HANDLE  g_CacheHeap = NULL;

//
//  Cache hash table
//

PCACHE_ENTRY *  g_HashTable = NULL;

#define INITIAL_CACHE_HEAP_SIZE     (16*1024)


//
//  Runtime globals
//

DWORD   g_CurrentCacheTime;

DWORD   g_RecordSetCount;
DWORD   g_RecordSetCountLimit;
DWORD   g_RecordSetCountThreshold;

DWORD   g_RecordSetCache;
DWORD   g_RecordSetFree;

DWORD   g_EntryCount;
DWORD   g_EntryAlloc;
DWORD   g_EntryFree;

BOOL    g_fLoadingHostsFile;

//
//  Garbage collection
//

BOOL    g_GarbageCollectFlag = FALSE;

DWORD   g_NextGarbageIndex = 0;
DWORD   g_NextGarbageTime = 0;

#define GARBAGE_LOCKOUT_INTERVAL    (600)   // no more then every ten minutes


//
//  Wakeup flag
//

BOOL    g_WakeFlag = FALSE;

//
//  Cache limits
//      - min count of records to hold
//      - size of band in which garbage collection occurs
//

#if DBG
#define MIN_DYNAMIC_RECORD_COUNT        (20)
#define CLEANUP_RECORD_COUNT_BAND       (5)
#else
#define MIN_DYNAMIC_RECORD_COUNT        (50)
#define CLEANUP_RECORD_COUNT_BAND       (30)
#endif


//
//  Static records (hosts file)
//

#define IS_STATIC_RR(prr)   (IS_HOSTS_FILE_RR(prr) || IS_CLUSTER_RR(prr))



//
// Compute a hash table index value for a string
//

#define EOS     (L'\0')

#define COMPUTE_STRING_HASH_1( _String, _ulHashTableSize, _lpulHash ) \
        {                                               \
            PWCHAR p;                                   \
            ULOND  h = 0, g;                            \
                                                        \
            for ( p = _String; *p != EOS; p = p + 1 )   \
            {                                           \
                h = ( h << 4 ) + (DWORD) (*p);          \
                if ( g = h&0xf0000000 )                 \
                {                                       \
                    h = h ^ ( g >> 24 );                \
                    h = h ^ g;                          \
                }                                       \
            }                                           \
            *_lpulHash = h % _ulHashTableSize;          \
        }


//
// Compute a hash table index value for a string
// which is invairant to case
//
#define COMPUTE_STRING_HASH_2( _String, _ulHashTableSize, _lpulHash ) \
        {                                           \
            PWCHAR _p = _String;                    \
            PWCHAR _ep = _p + wcslen( _String );    \
            ULONG  h = 0;                           \
                                                    \
            while( _p < _ep )                       \
            {                                       \
                h <<= 1;                            \
                h ^= *_p++;                         \
            }                                       \
                                                    \
            *_lpulHash = h % _ulHashTableSize;      \
        }


//
//  Private prototypes
//

BOOL
Cache_FlushEntryRecords(
    IN OUT  PCACHE_ENTRY    pEntry,
    IN      DWORD           Level,
    IN      WORD            wType
    );

VOID
Cache_FlushBucket(
    IN      ULONG           Index,
    IN      WORD            FlushLevel
    );

//
//  Cache Implementation
//
//  Cache is implemented as a hash on name, with chaining in the individual
//  buckets.  Individual name entries are blocks with name pointer and array
//  of up to 3 RR set pointers.  The new names\entries are put at the front of
//  the bucket chain, so the oldest are at the rear.
//
//
//  Cleanup:
//
//  The cleanup strategy is to time out all RR sets and cleanup everything
//  possible as a result.  Then entries beyond a max bucket size (a resizable
//  global) are deleted, the oldest queries deleted first.
//
//  Ideally, we'd like to keep the most useful entries in the cache while
//  being able to limit the overall cache size.
//
//  A few observations:
//
//  1) max bucket size is worthless;  if sufficient for pruning, it would be
//  too small to allow non-uniform distributions
//
//  2) LRU should be required;  on busy cache shouldn't prune something queried
//  "a while" ago that is being used all the time;  that adds much more traffic
//  than something recently queried but then unused;
//
//  3) if necessary an LRU index could be kept;  but probably some time bucket
//  counting to know how "deep" pruning must be is adequate
//
//
//  Memory:
//
//  Currently hash itself and hash entries come from private resolver heap.
//  However, RR sets are built by record parsing of messages received in dnsapi.dll
//  and hence are built by the default dnsapi.dll allocator.  We must match it.
//
//  The downside of this is twofold:
//  1) By being in process heap, we are exposed (debug wise) to any poor code
//  in services.exe.  Hopefully, there are getting better, but anything that
//  trashes memory is likely to cause us to have to debug, because we are the highest
//  use service.
//  2) Flush \ cleanup is easy.  Just kill the heap.
//
//  There are several choices:
//
//  0) Copy the records.  We are still susceptible to memory corruption ... but the
//  interval is shorter, since we don't keep anything in process heap.
//
//  1) Query can directly call dnslib.lib query routines.  Since dnslib.lib is
//  explicitly compiled in, it's global for holding the allocators is modules, rather
//  than process specific.
//
//  2) Add some parameter to query routines that allows pass of allocator down to
//  lowest level.  At high level this is straightforward.  At lower level it maybe
//  problematic.   There may be a way to do it with a flag where the allocator is
//  "optional" and used only when a flag is set.
//




//
//  Cache functions
//

DNS_STATUS
Cache_Lock(
    IN      BOOL            fNoStart
    )
/*++

Routine Description:

    Lock the cache

Arguments:

    None.

Return Value:

    NO_ERROR if successful -- cache is locked.
    ErrorCode on init if cache init failed.

--*/
{
    DNSDBG( LOCK, ( "Enter Cache_Lock() ..." ));

    EnterCriticalSection( &CacheCS );

    DNSDBG( LOCK, (
        "through lock  (r=%d)\n",
        CacheCS.RecursionCount ));

    //  update global time (for TTL set and timeout)
    //
    //  this allows us to eliminate multiple time calls
    //  within cache

    g_CurrentCacheTime = Dns_GetCurrentTimeInSeconds();

    //
    //  if cache not loaded -- load
    //  this allows us to avoid load on every PnP until we
    //      are actually queried
    //

    if ( !fNoStart && !g_HashTable )
    {
        DNS_STATUS  status;

        DNSDBG( ANY, (
            "No hash table when took lock -- initializing!\n" ));

        status = Cache_Initialize();
        if ( status != NO_ERROR )
        {
            Cache_Unlock();
            return  status;
        }
    }

    return  NO_ERROR;
}


VOID
Cache_Unlock(
    VOID
    )
/*++

Routine Description:

    Unlock the cache

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNSDBG( LOCK, (
        "Cache_Unlock() r=%d\n",
        CacheCS.RecursionCount ));

    LeaveCriticalSection( &CacheCS );
}



DNS_STATUS
Cache_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize the cache.
    Create events and locks and setup basic hash.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status;
    DWORD       carryCount;

    DNSDBG( INIT, ( "Cache_Initialize()\n" ));

    //
    //  lock -- with "no-start" set to avoid recursion
    // 

    LOCK_CACHE_NO_START();

    //
    //  create cache heap
    //
    //  want to have own heap
    //      1) to simplify flush\shutdown
    //      2) keep us from "entanglements" with poor services
    //

    g_CacheHeap = HeapCreate( 0, INITIAL_CACHE_HEAP_SIZE, 0 );
    if ( !g_CacheHeap )
    {
        status = ERROR_NOT_ENOUGH_MEMORY;
        g_HashTable = NULL;
        goto Done;
    }

    g_HashTable = CACHE_HEAP_ALLOC_ZERO(
                                    sizeof(PCACHE_ENTRY) * g_HashTableSize );
    if ( !g_HashTable )
    {
        status = ERROR_NOT_ENOUGH_MEMORY;
        HeapDestroy( g_CacheHeap );
        g_CacheHeap = NULL;
        goto Done;
    }

    g_WakeFlag      = FALSE;

    g_EntryCount    = 0;
    g_EntryAlloc    = 0;
    g_EntryFree     = 0;

    g_RecordSetCount = 0;
    g_RecordSetCache = 0;
    g_RecordSetFree  = 0;

    //  eliminate cache size checks during hosts file load

    g_RecordSetCountLimit       = MAXDWORD;
    g_RecordSetCountThreshold   = MAXDWORD;

    //
    //  load hosts file into cache
    //

    g_fLoadingHostsFile = TRUE;
    InitCacheWithHostFile();
    g_fLoadingHostsFile = FALSE;

    //
    //  set cache size limit
    //      - above what loaded from hosts file
    //      - always allow some dynamic space regardless of
    //          g_MaxCacheSize
    //      - create slightly higher threshold value for kicking
    //          off cleanup so cleanup not running all the time
    //

    carryCount = g_MaxCacheSize;
    if ( carryCount < MIN_DYNAMIC_RECORD_COUNT )
    {
        carryCount = MIN_DYNAMIC_RECORD_COUNT;
    }
    g_RecordSetCountLimit     = g_RecordSetCount + carryCount;
    g_RecordSetCountThreshold = g_RecordSetCountLimit + CLEANUP_RECORD_COUNT_BAND;

    status = NO_ERROR;

Done:

    UNLOCK_CACHE();

    return status;
}



DNS_STATUS
Cache_Shutdown(
    VOID
    )
/*++

Routine Description:

    Shutdown the cache.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNSDBG( INIT, ( "Cache_Shutdown()\n" ));

    //
    //  clean out cache and delete cache heap
    //       - currently Cache_Flush() does just this
    //

    return Cache_Flush();
}



DNS_STATUS
Cache_Flush(
    VOID
    )
/*++

Routine Description:

    Flush the cache.

    This flushes all the cache data and rereads host file but does NOT
    shut down and restart cache threads (host file monitor or multicast).

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on rebuild failure.

--*/
{
    DWORD   status = ERROR_SUCCESS;
    WORD    ihash;
    WORD    RecordIter;

    DNSDBG( ANY, ( "\nCache_Flush()\n" ));

    //
    //  wake\stop garbage collection
    //

    g_WakeFlag = TRUE;

    //
    //  lock with "no start" flag
    //      - avoids creating cache structs if they don't exist
    //

    LOCK_CACHE_NO_START();

    DNSLOG_F1( "Flushing DNS Cache" );
    DNSLOG_F3(
        "   Before Cache_Flush():  entries %d, record %d",
        g_EntryCount,
        g_RecordSetCount );

    //
    //  clear entries in each hash bucket
    //

    if ( g_HashTable )
    {
        for ( ihash = 0;
              ihash < g_HashTableSize;
              ihash++ )
        {
            Cache_FlushBucket(
                ihash,
                FLUSH_LEVEL_CLEANUP );
        }
    }

    DNSDBG( CACHE, (
        "After flushing cache:\n"
        "\trecord count  = %d\n"
        "\tentry count   = %d\n",
        g_RecordSetCount,
        g_EntryCount ));

    DNSLOG_F3(
        "   After Cache_Flush() flush:  entries %d, record %d",
        g_EntryCount,
        g_RecordSetCount );

    //DNS_ASSERT( g_RecordSetCount == 0 );
    //DNS_ASSERT( g_EntryCount == 0 );

    g_RecordSetCount = 0;
    g_EntryCount = 0;

    //
    //  Note:  can NOT delete the cache without stopping mcast
    //      thread which currently uses cache heap

    //
    //  DCR:  have all data in cache in single heap
    //          - protected
    //          - single destroy cleans up
      
    //  once cleaned up, delete heap

    if ( g_CacheHeap )
    {
        HeapDestroy( g_CacheHeap );
        g_CacheHeap = NULL;
    }
    g_HashTable = NULL;

    //
    //  dump local IP list
    //      - not dumping on shutdown as the IP cleanup happens
    //      first and takes away the CS;
    //
    //  note to reviewer:
    //      this is equivalent to the previous behavior where
    //      Cache_Flush() FALSE was shutdown and
    //      everything else used TRUE (for restart) which did a
    //      RefreshLocalAddrArray() to rebuild IP list
    //      now we simply dump the IP list rather than rebuilding
    //      

    if ( !g_StopFlag )
    {
        //  FIX6:  no longer keep separate addr array separate from netinfo
        //ClearLocalAddrArray();
    }

    DNSDBG( ANY, ( "Leave Cache_Flush()\n\n" ));

    UNLOCK_CACHE();

    return( status );
}



//
//  Cache utilities
//

BOOL
Cache_IsRecordTtlValid(
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Check if TTL is still valid (or has timed out).

Arguments:

    pRecord -- record to check

Return Value:

    TRUE -- if TTL is still valid
    FALSE -- if TTL has timed out

--*/
{
    //
    //  static or TTL not timed out => valid
    //
    //  note:  currently flushing all records on PnP, but this is
    //      not strickly necessary;  if stop this then MUST change
    //      this to whack negative cache entries that are older
    //      than last PnP time
    //

    if ( IS_STATIC_RR(pRecord) )
    {
        return( TRUE );
    }
    else
    {
        return( (LONG)(pRecord->dwTtl - g_CurrentCacheTime) > 0 );
    }
}



//
//  Cache entry routines
//

DWORD
getHashIndex(
    IN      PWSTR           pName,
    IN      DWORD           NameLength  OPTIONAL
    )
/*++

Routine Description:

    Create cannonical cache form of name.

    Note:  no test for adequacy of buffer is done.

Arguments:

    pName -- name

    NameLength -- NameLength, OPTIONAL

Return Value:

    None

--*/
{
    register PWCHAR     pstring;
    register WCHAR      wch;
    register DWORD      hash = 0;

    //
    //  build hash by XORing characters
    //

    pstring = pName;

    while ( wch = *pstring++ )
    {
        hash <<= 1;
        hash ^= wch;
    }

    //
    //  mod over hash table size
    //

    return( hash % g_HashTableSize );
}



BOOL
makeCannonicalCacheName(
    OUT     PWCHAR          pNameBuffer,
    IN      DWORD           BufferLength,
    IN      PWSTR           pName,
    IN      DWORD           NameLength      OPTIONAL
    )
/*++

Routine Description:

    Create cannonical cache form of name.

Arguments:

    pNameBuffer -- buffer to hold cache name

    BufferLength -- length of buffer

    pName -- ptr to name string

    NameLength -- optional, saves wsclen() call if known

Return Value:

    TRUE if successful.
    FALSE on bogus name.

--*/
{
    INT count;

    DNSDBG( TRACE, (
        "makeCannonicalCacheName( %S )\n",
        pName ));

    //
    //  get length if not specified
    //

    if ( NameLength == 0 )
    {
        NameLength = wcslen( pName );
    }

    //
    //  copy and downcase string
    //      - "empty" buffer for prefix happiness
    //

    *pNameBuffer = (WCHAR) 0;

    count = Dns_MakeCanonicalNameW(
                pNameBuffer,
                BufferLength,
                pName,
                NameLength+1    // convert null terminator
                );
    if ( count == 0 )
    {
        ASSERT( GetLastError() == ERROR_INSUFFICIENT_BUFFER );
        return( FALSE );
    }

    ASSERT( count == (INT)NameLength+1 );

    //
    //  whack any trailing dot
    //      - except for root node
    //

    count--;    //  account for null terminator
    DNS_ASSERT( count == NameLength );

    if ( count > 1 &&
         pNameBuffer[count - 1] == L'.' )
    {
        pNameBuffer[count - 1] = 0;
    }

    return( TRUE );
}



PCACHE_ENTRY
Cache_CreateEntry(
    IN      PWSTR           pName,
    IN      BOOL            fCanonical
    )
/*++

Routine Description:

    Create cache entry, including allocation.

Arguments:

    pName -- name

    fCanonical -- TRUE if name already in cannonical form

Return Value:

    Ptr to newly allocated cache entry.
    NULL on error.

--*/
{
    ULONG           index = 0;
    PCACHE_ENTRY    pentry = NULL;
    DWORD           nameLength;
    DWORD           fixedLength;
    PWCHAR          pnameCache = NULL;

    DNSDBG( TRACE, (
        "Cache_CreateEntry( %S )\n",
        pName ));

    if ( !pName || !g_HashTable )
    {
        return NULL;
    }

    //
    //  alloc
    //

    nameLength = wcslen( pName );

    fixedLength = sizeof(CACHE_ENTRY) +
                    (sizeof(PDNS_RECORD) * (CACHE_DEFAULT_SET_COUNT-1));

    pentry = (PCACHE_ENTRY) CACHE_HEAP_ALLOC_ZERO(
                                fixedLength +
                                sizeof(WCHAR) * (nameLength+1) );
    if ( !pentry )
    {
        goto Fail;
    }
    pentry->MaxCount = CACHE_DEFAULT_SET_COUNT;

    pnameCache = (PWSTR) ((PBYTE)pentry + fixedLength);

    //
    //  build the name
    //

    if ( fCanonical )
    {
        wcscpy( pnameCache, pName );
    }
    else
    {
        if ( !makeCannonicalCacheName(
                pnameCache,
                nameLength+1,
                pName,
                nameLength ) )
        {
            goto Fail;
        }
    }
    pentry->pName = pnameCache;

    //
    //  insert cache entry into cache -- first entry in bucket
    //

    index = getHashIndex( pnameCache, nameLength );
    pentry->pNext = g_HashTable[ index ];
    g_HashTable[ index ] = pentry;
    g_EntryCount++;
    g_EntryAlloc++;

    //
    //  DCR:  need overload detection
    //

    return pentry;

Fail:

    //  dump entry

    if ( pentry )
    {
        CACHE_HEAP_FREE( pentry );
    }
    return NULL;
}



VOID
Cache_FreeEntry(
    IN OUT  PCACHE_ENTRY    pEntry
    )
/*++

Routine Description:

    Free cache entry.

Arguments:

    pEntry -- cache entry to free

Globals:

    g_EntryCount -- decremented appropriately

    g_NumberOfRecordsInCache -- decremented appropriately

Return Value:

    None

--*/
{
    INT iter;

    DNSDBG( TRACE, (
        "Cache_FreeEntry( %p )\n",
        pEntry ));

    //
    //  free entry
    //      - records
    //      - name
    //      - entry itself
    //

    if ( pEntry )
    {
        Cache_FlushEntryRecords(
            pEntry,
            FLUSH_LEVEL_CLEANUP,
            0 );

#if 0
        if ( pEntry->pNext )
        {
            DNSLOG_F1( "Cache_FreeEntry is deleting an entry that still points to other entries!" );
        }
#endif
#if HEAPPROB
        pEntry->pNext = DNS_BAD_PTR;
#endif
        CACHE_HEAP_FREE( pEntry );
        g_EntryFree--;
        g_EntryCount--;
    }
}



PCACHE_ENTRY
Cache_FindEntry(
    IN      PWSTR           pName,
    IN      BOOL            fCreate
    )
/*++

Routine Description:

    Find or create entry for name in cache.

Arguments:

    pName -- name to find

    fCreate -- TRUE to create if not found

Return Value:

    Ptr to cache entry -- if successful.
    NULL on failure.

--*/
{
    ULONG           index;
    PCACHE_ENTRY    pentry;
    PCACHE_ENTRY    pprevEntry = NULL;
    WCHAR           hashName[ DNS_MAX_NAME_BUFFER_LENGTH+4 ];

    if ( !g_HashTable )
    {
        return NULL;
    }
    if ( !pName )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }

    DNSDBG( TRACE, (
        "Cache_FindEntry( %S, create=%d )\n",
        pName,
        fCreate ));

    //
    //  build cache name
    //      - if invalid (too long) bail
    //

    if ( !makeCannonicalCacheName(
            hashName,
            DNS_MAX_NAME_BUFFER_LENGTH,
            pName,
            0 ) )
    {
        return  NULL;
    }

    //
    //  find entry in cache
    //

    if ( LOCK_CACHE() != NO_ERROR )
    {
        return  NULL;
    }

    index = getHashIndex( hashName, 0 );

    pentry = g_HashTable[ index ];

    DNSDBG( OFF, (
        "in Cache_FindEntry\n"
        "\tname     = %S\n"
        "\tindex    = %d\n"
        "\tpentry   = %p\n",
        hashName,
        index,
        pentry ));

    while( pentry )
    {
        if ( DnsNameCompare_W( hashName, pentry->pName ) )
        {
            //
            //  found entry
            //      - move to front, if not already there

            if ( pprevEntry )
            {
                pprevEntry->pNext = pentry->pNext;
                pentry->pNext = g_HashTable[ index ];
                g_HashTable[ index ] = pentry;
            }
            break;
        }
        ELSE
        {
            DNSDBG( OFF, (
                "in Cache_FindEntry -- failed name compare\n"
                "\tout name = %S\n"
                "\tpentry   = %p\n"
                "\tname     = %S\n",
                hashName,
                pentry,
                pentry->pName ));
        }

        pprevEntry = pentry;
        pentry = pentry->pNext;
    }

    //
    //  if not found -- create? 
    //
    //  DCR:  optimize for create
    //

    if ( !pentry && fCreate )
    {
        pentry = Cache_CreateEntry(
                    hashName,
                    TRUE        // name already canonical
                    );
    }

    DNS_ASSERT( !pentry || g_HashTable[ index ] == pentry );
    UNLOCK_CACHE();

    DNSDBG( TRACE, (
        "Leave Cache_FindEntry\n"
        "\tname     = %S\n"
        "\tindex    = %d\n"
        "\tpentry   = %p\n",
        hashName,
        index,
        pentry ));

    return pentry;
}



PDNS_RECORD
Cache_FindEntryRecords(
    OUT     PDNS_RECORD **  pppRRList,
    IN      PCACHE_ENTRY    pEntry,
    IN      WORD            wType
    )
/*++

Routine Description:

    Find entry in cache.

Arguments:

    pppRRList -- addr to recv addr of entry's ptr to RR list

    pEntry -- cache entry to check

    Type -- record type to find

Return Value:

    Ptr to record set of desired type -- if found.
    NULL if not found.

--*/
{
    WORD            iter;
    PDNS_RECORD     prr;
    PDNS_RECORD *   prrAddr = NULL;

    DNSDBG( TRACE, (
        "Cache_FindEntryRecords( %p, e=%p, type=%d )\n",
        pppRRList,
        pEntry,
        wType ));

    //
    //  check all the records at the cache entry  
    //

    for ( iter = 0;
          iter < pEntry->MaxCount;
          iter++ )
    {
        prrAddr = &pEntry->Records[iter];
        prr = *prrAddr;

        if ( !prr )
        {
            continue;
        }
        if ( !Cache_IsRecordTtlValid( prr ) )
        {
            DNSDBG( TRACE, (
                "Whacking timed out record %p at cache entry %p\n",
                prr,
                pEntry ));
            Dns_RecordListFree( prr );
            pEntry->Records[iter] = NULL;
            g_RecordSetCount--;
            g_RecordSetFree--;
            continue;
        }

        //  
        //  find matching type
        //      - direct type match
        //      - NAME_ERROR
        //

        if ( prr->wType == wType ||
            ( prr->wType == DNS_TYPE_ANY &&
              prr->wDataLength == 0 ) )
        {
            goto Done;
        }

        //
        //  CNAME match
        //      - walk list and determine if for matching type

        if ( prr->wType == DNS_TYPE_CNAME &&
             wType != DNS_TYPE_CNAME )
        {
            PDNS_RECORD prrChain = prr->pNext;

            while ( prrChain )
            {
                if ( prrChain->wType == wType )
                {
                    //  chain to desired type -- take RR set
                    goto Done;
                }
                prrChain = prrChain->pNext;
            }
        }

        //  records for another type -- continue
    }

    //  type not found

    prr = NULL;

Done:

    if ( pppRRList )
    {
        *pppRRList = prrAddr;
    }

    DNSDBG( TRACE, (
        "Leave Cache_FindEntryRecords => %p\n",
        prr ));

    return prr;
}



BOOL
Cache_FlushEntryRecords(
    IN OUT  PCACHE_ENTRY    pEntry,
    IN      DWORD           Level,
    IN      WORD            wType
    )
/*++

Routine Description:

    Free cache entry.

Arguments:

    pEntry -- cache entry to flush

    FlushLevel -- flush level
        FLUSH_LEVEL_NORMAL  -- flush matching type, invalid, NAME_ERROR
        FLUSH_LEVEL_WIRE    -- to flush all wire data, but leave hosts and cluster
        FLUSH_LEVEL_INVALID -- flush only invalid records
        FLUSH_LEVEL_STRONG  -- to flush all but hosts file
        FLUSH_LEVEL_CLEANUP -- to flush all records for full cache flush

    wType -- flush type for levels with type
        DNS type -- to flush specifically this type

Globals:

    g_EntryCount -- decremented appropriately

    g_NumberOfRecordsInCache -- decremented appropriately

Return Value:

    TRUE if entry flushed completely.
    FALSE if records left.

--*/
{
    INT     iter;
    BOOL    recordsLeft = FALSE;

    DNSDBG( TRACE, (
        "Cache_FlushEntryRecords( %p, %08x, %d )\n",
        pEntry,
        Level,
        wType ));

    //
    //  loop through records sets -- flush where appropriate
    //
    //  CLEANUP flush
    //      - everything
    //
    //  STRONG (user initiated) flush
    //      - all cached records, including cluster
    //      but hostsfile saved
    //
    //  WIRE flush
    //      - all wire cached records
    //      hosts file AND cluster saved
    //
    //  INVALID flush
    //      - timedout only
    //
    //  NORMAL flush (regular flush done on caching)
    //      - timed out records
    //      - records of desired type
    //      - NAME_ERROR
    //

    for ( iter = 0;
          iter < (INT)pEntry->MaxCount;
          iter++ )
    {
        PDNS_RECORD prr = pEntry->Records[iter];
        BOOL        flush;

        if ( !prr )
        {
            continue;
        }

        //
        //  switch on flush type
        //      yes there are optimizations, but this is simple
        //

        if ( Level == FLUSH_LEVEL_NORMAL )
        {
            flush = ( !IS_STATIC_RR(prr)
                            &&
                      ( prr->wType == wType ||
                        ( prr->wType == DNS_TYPE_ANY &&
                          prr->wDataLength == 0 ) ) );
        }
        else if ( Level == FLUSH_LEVEL_WIRE )
        {
            flush = !IS_STATIC_RR(prr);
        }
        else if ( Level == FLUSH_LEVEL_INVALID )
        {
            flush = !Cache_IsRecordTtlValid(prr);
        }
        else if ( Level == FLUSH_LEVEL_CLEANUP )
        {
            flush = TRUE;
        }
        else
        {
            DNS_ASSERT( Level == FLUSH_LEVEL_STRONG );
            flush = !IS_HOSTS_FILE_RR(prr);
        }

        if ( flush )
        {
            pEntry->Records[iter] = NULL;
            Dns_RecordListFree( prr );
            g_RecordSetCount--;
            g_RecordSetFree--;
        }
        else
        {
            recordsLeft = TRUE;
        }
    }

    return  !recordsLeft;
}
            


VOID
Cache_FlushBucket(
    IN      ULONG           Index,
    IN      WORD            FlushLevel
    )
/*++

Routine Description:

    Cleanup cache bucket.

Arguments:

    Index -- Index of hash bucket to trim.

    FlushLevel -- level of flush desired
        see Cache_FlushEntryRecords() for description of
        flush levels

Return Value:

    None

--*/
{
    PCACHE_ENTRY    pentry;
    PCACHE_ENTRY    pprev;
    INT             countCompleted;

    DNSDBG( CACHE, (
        "Cache_FlushBucket( %d, %08x )\n",
        Index,
        FlushLevel ));

    //
    //  flush entries in this bucket
    //
    //  note:  using hack here that hash table pointer can
    //      be treated as cache entry for purposes of accessing
    //      it's next pointer (since it's the first field in
    //      a CACHE_ENTRY)
    //      if this changes, must explicitly fix up "first entry"
    //      case or move to double-linked list that can free
    //      empty penty without regard to it's location
    //

    if ( !g_HashTable )
    {
        return;
    }

    //
    //  flush entries
    //
    //  avoid holding lock too long by handling no more then
    //  fifty entries at a time
    //  note:  generally 50 entries will cover entire bucket but
    //  can still be completed in reasonable time;
    //
    //  DCR:  smarter flush -- avoid lock\unlock
    //          peer into CS and don't unlock when no one waiting
    //          if waiting unlock and give up timeslice
    //  DCR:  some LRU flush for garbage collection
    //

    countCompleted = 0;

    while ( 1 )
    {
        INT count = 0;
        INT countStop = countCompleted + 50;

        LOCK_CACHE_NO_START();
        if ( !g_HashTable )
        {
            UNLOCK_CACHE();
            break;
        }
    
        DNSDBG( CACHE, (
            "locked for bucket flush -- completed=%d, stop=%d\n",
            count,
            countStop ));

        pprev = (PCACHE_ENTRY) &g_HashTable[ Index ];
    
        while ( pentry = pprev->pNext )
        {
            //  bypass any previously checked entries

            if ( count++ < countCompleted )
            {
                pprev = pentry;
                continue;
            }
            if ( count > countStop )
            {
                break;
            }

            //  flush -- if successful cut from list and
            //      drop counts so countCompleted used in bypass
            //      will be correct and won't skip anyone

            if ( Cache_FlushEntryRecords(
                    pentry,
                    FlushLevel,
                    0 ) )
            {
                pprev->pNext = pentry->pNext;
                Cache_FreeEntry( pentry );
                count--;
                countStop--;
                continue;
            }
            pprev = pentry;
        }

        UNLOCK_CACHE();
        countCompleted = count;

        //  stop when
        //      - cleared all the entries in the bucket
        //      - shutdown, except exempt the shutdown flush itself

        if ( !pentry ||
             (g_StopFlag && FlushLevel != FLUSH_LEVEL_CLEANUP) )
        {
            break;
        }
    }

    DNSDBG( CACHE, (
        "Leave Cache_FlushBucket( %d, %08x )\n"
        "\trecord count  = %d\n"
        "\tentry count   = %d\n",
        Index,
        FlushLevel,
        g_RecordSetCount,
        g_EntryCount ));
}



//
//  Cache interface routines
//

VOID
Cache_PrepareRecordList(
    IN OUT  PDNS_RECORD     pRecordList
    )
/*++

Routine Description:

    Prepare record list for cache.

Arguments:

    pRecordList - record list to put in cache

Return Value:

    Ptr to screened, prepared record list.

--*/
{
    PDNS_RECORD     prr = pRecordList;
    PDNS_RECORD     pnext;
    DWORD           ttl;
    DWORD           maxTtl;

    DNSDBG( TRACE, (
        "Cache_PrepareRecordList( rr=%p )\n",
        prr ));

    if ( !prr )
    {
        return;
    }

    //
    //  static (currently host file) TTL records
    //
    //  currently no action required -- records come one
    //  at a time and no capability to even to the pName=NULL
    //  step
    //

    if ( IS_STATIC_RR(prr) )
    {
        return;
    }

    //
    //  wire records get relative TTL
    //      - compute minimum TTL for set
    //      - save TTL as timeout (offset by TTL from current time)
    //
    //  DCR:  TTL still not per set
    //      - but this is at least better than Win2K where
    //      multiple sets and did NOT find minimum
    //

    maxTtl = g_MaxCacheTtl;
    if ( prr->wType == DNS_TYPE_SOA )
    {
        maxTtl = g_MaxSOACacheEntryTtlLimit;
    }

    //
    //  get caching TTL
    //      - minimum TTL in set
    //      - offset from current time

    ttl = Dns_RecordListGetMinimumTtl( prr );
    if ( ttl > maxTtl )
    {
        ttl = maxTtl;
    }

    ttl += g_CurrentCacheTime;

#if 0
    //  screening done at higher level now
    //
    //  screen records
    //      - no non-RPCable types
    //      - no Authority records
    //

    if ( prr->wType != 0 )
    {
        prr = Dns_RecordListScreen(
                prr,
                SCREEN_OUT_AUTHORITY | SCREEN_OUT_NON_RPC );
    
        DNS_ASSERT( prr );
    }
#endif

    //
    //  set timeout on all records in set
    //
    //  note:  FreeOwner handling depends on leading record
    //      in having owner name set, otherwise this produces
    //      bogus name owner fields
    //
    //  DCR:  set record list TTL function in dnslib
    //

    pnext = prr;

    while ( pnext )
    {
        pnext->dwTtl = ttl;

        if ( !FLAG_FreeOwner( pnext ) )
        {
            pnext->pName = NULL;
        }
        pnext = pnext->pNext;
    }
}



VOID
Cache_RestoreRecordListForRpc(
    IN OUT  PDNS_RECORD     pRecordList
    )
/*++

Routine Description:

    Restore cache record list for RPC.

Arguments:

    pRecordList - record list to put in cache

Return Value:

    None

--*/
{
    PDNS_RECORD prr = pRecordList;
    DWORD       currentTime;

    DNSDBG( TRACE, (
        "Cache_RestoreRecordListForRpc( rr=%p )\n",
        prr ));

    if ( !prr )
    {
        DNS_ASSERT( FALSE );
        return;
    }

    //
    //  static TTL records need no action
    //

    if ( IS_STATIC_RR(prr) )
    {
        return;
    }

    //
    //  turn timeouts back into TTLs
    //

    currentTime = g_CurrentCacheTime;

    while ( prr )
    {
        DWORD   ttl = prr->dwTtl - currentTime;

        if ( (LONG)ttl < 0 )
        {
            ttl = 0;
        }
        prr->dwTtl = ttl;
        prr = prr->pNext;
    }
}



VOID
Cache_RecordSetAtomic(
    IN      PWSTR           pwsName,
    IN      WORD            wType,
    IN      PDNS_RECORD     pRecordSet
    )                
/*++

Routine Description:

    Cache record set atomically at entry.

    Cache_RecordList() handles breakup of record list
    and appropriate placing of records.  This does caching
    of single blob at particular location.

Arguments:

    pRecordSet -- record list to add

Globals:

    g_EntryCount -- decremented appropriately

    g_NumberOfRecordsInCache -- decremented appropriately

Return Value:

    None

--*/
{
    INT             iter;
    WORD            wtype;
    PWSTR           pname;
    BOOL            fstatic;
    PCACHE_ENTRY    pentry;
    BOOL            fretry;
    WORD            flushLevel;


    DNSDBG( TRACE, (
        "Cache_RecordSetAtomic( %S, type=%d, rr=%p )\n",
        pwsName,
        wType,
        pRecordSet ));

    if ( !pRecordSet )
    {
        return;
    }
    fstatic = IS_STATIC_RR(pRecordSet);

    DNS_ASSERT( !fstatic ||
                pRecordSet->pNext == NULL ||
                (pRecordSet->wType==DNS_TYPE_CNAME) )

    //
    //  determine caching type
    //      - specified OR from records
    //      CNAMEs will be at the head of a lookup from another type
    //

    wtype = wType;
    if ( !wtype )
    {
        wtype = pRecordSet->wType;
    }

    //
    //  if name specified use it, otherwise use from records
    //

    pname = pwsName;
    if ( !pname )
    {
        pname = pRecordSet->pName;
    }

    //
    //  prepare RR set for cache
    //

    Cache_PrepareRecordList( pRecordSet );

    //
    //  find\create cache entry and cache
    //

    if ( LOCK_CACHE() != NO_ERROR )
    {
        LOCK_CACHE_NO_START();
        goto Failed;
    }

    pentry = Cache_FindEntry(
                pname,
                TRUE    // create
                );
    if ( !pentry )
    {
        goto Failed;
    }

    //
    //  clean up existing records at node
    //      - remove stale records
    //      - remove records of same type
    //      - if NAME_ERROR caching remove everything
    //      from wire
    //

    flushLevel = FLUSH_LEVEL_NORMAL;

    if ( wtype == DNS_TYPE_ALL &&
         pRecordSet->wDataLength == 0 )
    {
        flushLevel = FLUSH_LEVEL_WIRE;
    }

    Cache_FlushEntryRecords(
        pentry,
        flushLevel,
        wtype );

    //
    //  check for matching record type still there
    //

    for ( iter = 0;
          iter < (INT)pentry->MaxCount;
          iter++ )
    {
        PDNS_RECORD     prrExist = pentry->Records[iter];

        if ( !prrExist ||
             prrExist->wType != wtype )
        {
            continue;
        }

        //  matching type still there after flush
        //      - if trying to cache wire set at hostfile entry, fail

        DNS_ASSERT( IS_STATIC_RR(prrExist) );

        if ( !fstatic )
        {
            DNSDBG( ANY, (
                "ERROR:  attempted caching at static (hosts file) record data!\n"
                "\tpRecord  = %p\n"
                "\tName     = %S\n"
                "\tType     = %d\n"
                "\t-- Dumping new cache record list.\n",
                pRecordSet,
                pRecordSet->pName,
                pRecordSet->wType ));
            goto Failed;
        }

        //
        //  append host file records
        //      - start at "record" which is addr of record ptr entry
        //      making pNext field the actual pointer
        //      - delete duplicates
        //      - tack new RR on end
        //      - blow away new RR name if existing record
        //
        //  DCR:  should have simple "make cache RR set" function that
        //      handles name and TTL issues
        //
        //  DCR:  broken if non-flush load hits wire data;  wire data
        //      may have multiple RR sets
        //

        else
        {
            PDNS_RECORD prr;
            PDNS_RECORD prrPrev = (PDNS_RECORD) &pentry->Records[iter];

            while ( prr = prrPrev->pNext )
            {
                //  matches existing record?
                //      - cut existing record from list and free

                if ( Dns_RecordCompare( prr, pRecordSet ) )
                {
                    prrPrev->pNext = prr->pNext;
                    Dns_RecordFree( prr );
                }
                else
                {
                    prrPrev = prr;    
                }
            }

            //
            //  tack entry on to end
            //      - if existing records of type delete name
            //

            if ( prrPrev != (PDNS_RECORD)&pentry->Records[iter] )
            {
                if ( IS_FREE_OWNER(pRecordSet) )
                {
                    RECORD_HEAP_FREE( pRecordSet->pName );
                    pRecordSet->pName = NULL;
                }
            }
            prrPrev->pNext = pRecordSet;
            goto Done;
        }
    }

    //
    //  put record into cache entry
    //
    //  if no slot is available, switch to a harder scrub
    //
    //  DCR:  realloc if out of slots
    //

    fretry = FALSE;

    while ( 1 )
    {
        for ( iter = 0;
              iter < (INT)pentry->MaxCount;
              iter++ )
        {
            if ( pentry->Records[iter] == NULL )
            {
                pentry->Records[iter] = pRecordSet;
                g_RecordSetCount++;
                g_RecordSetCache++;
                goto Done;
            }
        }

        if ( !fretry )
        {
            DNSDBG( QUERY, (
                "No slots caching RR set %p at entry %p\n"
                "\tdoing strong flush to free slot.\n",
                pRecordSet,
                pentry ));
    
            Cache_FlushEntryRecords(
                pentry,
                FLUSH_LEVEL_WIRE,
                0 );
    
            fretry = TRUE;
            continue;
        }

        DNSDBG( ANY, (
            "ERROR:  Failed to cache set %p at entry %p\n",
            pRecordSet,
            pentry ));
        goto Failed;
    }

Failed:

    DNSDBG( TRACE, ( "Cache_RecordSetAtomic() => failed\n" ));
    Dns_RecordListFree( pRecordSet );

Done:

    UNLOCK_CACHE();
    DNSDBG( TRACE, ( "Leave Cache_RecordSetAtomic()\n" ));
    return;
}



VOID
Cache_RecordList(
    IN OUT  PDNS_RECORD     pRecordList
    )
/*++

Routine Description:

    Cache record list.

    This is cache routine for "oddball" records -- not caching under
    queried name.
        - hostfile
        - answer records at CNAME
        - additional data at additional name

Arguments:

    pRecordList -- record list to cache

Return Value:

    None

--*/
{
    BOOL            fcnameAnswer = FALSE;
    PDNS_RECORD     pnextRR = pRecordList;
    PDNS_RECORD     prr;
    BOOL            fstatic;


    DNSDBG( TRACE, (
        "Cache_RecordList( rr=%p )\n",
        pRecordList ));

    if ( !pRecordList )
    {
        return;
    }
    fstatic = IS_STATIC_RR(pRecordList);

    //
    //  cache records:
    //      - cache additional records in query
    //      - cache CNAME data from query
    //      - cache host file data
    //
    //  background:  Glenn's caching paradigm was to cache all answer
    //  data at the queried name in the API call (name might be short).
    //  However, not caching the CNAME data can cause problems, so this
    //  was tacked on.
    //
    //  For CNAME caching we throw away the CNAMEs themselves and just
    //  cache the actually data (address) records at the CNAME node.
    //

    //
    //  cache additional records
    //  

    while ( prr = pnextRR )
    {
        BOOL    fcacheSet = FALSE;

        pnextRR = Dns_RecordSetDetach( prr );

        //
        //  host file data -- always cache
        //
        //  for CNAME want CNAME AND associated answer data
        //      - detach to get new next set
        //      - append answer data back on to CNAME for caching
        //      - next RR set (if exists) will be another CNAME
        //          to the same address data
        //
        //  DCR:  follow CNAMEs in cache
        //      then could pull this hack
        //      and avoid double building of answer data in dnsapi
        //

        if ( fstatic )
        {
            fcacheSet = TRUE;

            if ( prr->wType == DNS_TYPE_CNAME &&
                 pnextRR &&
                 pnextRR->wType != DNS_TYPE_CNAME )
            {
                PDNS_RECORD panswer = pnextRR;

                pnextRR = Dns_RecordSetDetach( panswer );

                Dns_RecordListAppend( prr, panswer );
            }
        }

        //
        //  wire data -- do NOT cache:
        //      - answer records for queried name (not CNAME)
        //      - CNAME records when doing caching of answer data under CNAME
        //      - authority section records (NS, SOA, etc)
        //      - OPT records
        //

        else if ( prr->Flags.S.Section == DNSREC_ANSWER )
        {
            if ( prr->wType == DNS_TYPE_CNAME )
            {
                fcnameAnswer = TRUE;
            }
            else if ( fcnameAnswer )
            {
                fcacheSet = TRUE;
            }
        }
        else if ( prr->Flags.S.Section == DNSREC_ADDITIONAL )
        {
            if ( prr->wType != DNS_TYPE_OPT )
            {
                fcacheSet = TRUE;
            }
        }

        if ( !fcacheSet )
        {
            Dns_RecordListFree( prr );
            continue;
        }

        //
        //  cache the set
        //
        //  flip the section field to "Answer" section
        //
        //  DCR:  section caching?
        //
        //  note:  section fields in cache indicate whether
        //      answer data (or additional) once out of
        //      cache;
        //      this is necessary since we cache everything
        //      at node and return it in one RR list;  we'd
        //      to change must
        //          - return in different lists with some indication
        //              in cache of what's what
        //          OR
        //          - another indication of what's what
        //

        //if ( !fstatic )
        //  currently HostFile entries get answer too
        {
            PDNS_RECORD ptemp = prr;
            while ( ptemp )
            {
                ptemp->Flags.S.Section = DNSREC_ANSWER;
                ptemp = ptemp->pNext;
            }
        }

        Cache_RecordSetAtomic(
            NULL,
            0,
            prr );
    }

    DNSDBG( TRACE, ( "Leave Cache_RecordList()\n" ));
}



VOID
Cache_FlushRecords(
    IN      PWSTR           pName,
    IN      DWORD           Level,
    IN      WORD            Type
    )
/*++

Routine Description:

    Flush cached records corresponding to a name and type.

Arguments:

    pName -- name of records to delete

    Level -- flush level

    Type -- type of records to delete;
        0 to flush all records at name

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    WORD            iter;
    PCACHE_ENTRY    pentry = NULL;
    PCACHE_ENTRY    pprevEntry = NULL;


    DNSDBG( TRACE, (
        "Cache_FlushRecords( %S, %d )\n",
        pName,
        Type ));

    //
    //  lock with no-start
    //      - bail if no cache
    //
    //  need this as PnP release notifications will attempt to
    //  flush local cache entries;  this avoids rebuilding when
    //  already down
    //

    LOCK_CACHE_NO_START();
    if ( !g_HashTable )
    {
        goto Done;
    }

    //
    //  find entry in cache
    //
    pentry = Cache_FindEntry(
                pName,
                FALSE       // no create
                );
    if ( !pentry )
    {
        goto Done;
    }

    //
    //  flush records of type
    //      - zero type will flush all
    //
    //  note:  Cache_FindEntry() always moves the found entry
    //      to the front of the hash bucket list;  this allows
    //      us to directly whack the entry
    //

    if ( Cache_FlushEntryRecords(
            pentry,
            Level,
            Type ) )
    {
        DWORD   index = getHashIndex(
                            pentry->pName,
                            0 );

        DNS_ASSERT( pentry == g_HashTable[index] );
        if ( pentry == g_HashTable[index] )
        {
            g_HashTable[ index ] = pentry->pNext;
            Cache_FreeEntry( pentry );
        }
    }

Done:

    UNLOCK_CACHE();
}



#if 0
BOOL
ReadCachedResults(
    OUT     PDNS_RESULTS    pResults,
    IN      PWSTR           pwsName,
    IN      WORD            wType
    )
/*++

Routine Description:

    Find records of given name and type in cache.

Arguments:

    pResults -- addr to receive results

    pwsName -- name

    wType -- record type to find

Return Value:

    TRUE if results found.
    FALSE if no cached data for name and type.

--*/
{
    PDNS_RECORD     prr;
    DNS_STATUS      status;
    BOOL            found = FALSE;

    //
    //  clear results
    //

    RtlZeroMemory( pResults, sizeof(*pResults) );

    //  get cache results


    //  break out into results buffer

    if ( found )
    {
        BreakRecordsIntoBlob(
            pResults,
            prr,
            wType );
    
        pResults->Status = status;
    }

    return( found );
}
#endif



//
//  Cache utilities for remote routines
//

PDNS_RECORD
Cache_FindRecordsPrivate(
    IN      PWSTR           pwsName,
    IN      WORD            wType
    )
/*++

Routine Description:

    Find records of given name and type in cache.

Arguments:

    pwsName -- name

    Type -- record type to find

Return Value:

    Ptr to record set of desired type -- if found.
    NULL if not found.

--*/
{
    PCACHE_ENTRY    pentry;
    PDNS_RECORD     prr = NULL;

    DNSDBG( TRACE, (
        "Cache_FindRecordsPrivate( %S, type=%d )\n",
        pwsName,
        wType ));

    if ( LOCK_CACHE() != NO_ERROR )
    {
        goto Done;
    }

    pentry = Cache_FindEntry(
                pwsName,
                FALSE );
    if ( pentry )
    {
        prr = Cache_FindEntryRecords(
                    NULL,           // don't need RR list ptr
                    pentry,
                    wType );
    }

    UNLOCK_CACHE();

Done:

    DNSDBG( TRACE, (
        "Leave Cache_FindRecordsPrivate( %S, type=%d ) => %p\n",
        pwsName,
        wType,
        prr ));

    return  prr;
}



BOOL
Cache_GetRecordsForRpc(
    OUT     PDNS_RECORD *   ppRecordList,
    OUT     PDNS_STATUS     pStatus,
    IN      PWSTR           pwsName,
    IN      WORD            wType,
    IN      DWORD           Flags
    )
/*++

Routine Description:

    Find records of given name and type in cache.

Arguments:

    ppRecordList -- addr to receive pointer to record list

    pStatus -- addr to get status return

    pwsName -- name

    Type -- record type to find

    Flags -- query flags

Return Value:

    TRUE if cache hit.  OUT params are valid.
    FALSE if cache miss.  OUT params are unset.

--*/
{
    PDNS_RECORD prr;
    PDNS_RECORD prrResult = NULL;
    DNS_STATUS  status = NO_ERROR;

    DNSDBG( RPC, (
        "Cache_GetRecordsForRpc( %S, t=%d )\n",
        pwsName,
        wType ));

    if ( (Flags & DNS_QUERY_BYPASS_CACHE) &&
         (Flags & DNS_QUERY_NO_HOSTS_FILE) )
    {
        return  FALSE;
    }
    if ( LOCK_CACHE() != NO_ERROR )
    {
        return  FALSE;
    }

    //
    //  check cache for name and type
    //      - if name or type missing, jump to wire lookup
    //

    prr = Cache_FindRecordsPrivate(
                pwsName,
                wType );
    if ( !prr )
    {
        goto Failed;
    }

    //
    //  cache hit
    //
    //  if only interested in host file data ignore
    //

    if ( IS_HOSTS_FILE_RR(prr) )
    {
        if ( Flags & DNS_QUERY_NO_HOSTS_FILE )
        {
            goto Failed;
        }
    }
    else    // cache data
    {
        if ( Flags & DNS_QUERY_BYPASS_CACHE )
        {
            goto Failed;
        }
    }

    //
    //  build response from cache data
    //      - cached NAME_ERROR or empty
    //      - cached records
    //
    
    if ( prr->wDataLength == 0 )
    {
        status = (prr->wType == DNS_TYPE_ANY)
                    ? DNS_ERROR_RCODE_NAME_ERROR
                    : DNS_INFO_NO_RECORDS;
    }
    else
    {
        //  for CNAME query, get only the CNAME record itself
        //      not the data at the CNAME
        //
        //  DCR:  CNAME handling should be optional -- not given
        //      for cache display purposes
        //
    
        if ( wType == DNS_TYPE_CNAME &&
             prr->wType == DNS_TYPE_CNAME &&
             prr->Flags.S.Section == DNSREC_ANSWER )
        {
            prrResult = Dns_RecordCopyEx(
                                prr,
                                DnsCharSetUnicode,
                                DnsCharSetUnicode );
        }
        else
        {
            prrResult = Dns_RecordSetCopyEx(
                                prr,
                                DnsCharSetUnicode,
                                DnsCharSetUnicode );
        }

        if ( prrResult )
        {
            Cache_RestoreRecordListForRpc( prrResult );
            status = ERROR_SUCCESS;
        }
        else
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
        }
    }

    UNLOCK_CACHE();

    //  set return values

    *ppRecordList = prrResult;
    *pStatus = status;

    return  TRUE;


Failed:

    UNLOCK_CACHE();
    return  FALSE;
}



VOID
Cache_DeleteMatchingRecords(
    IN      PDNS_RECORD     pRecords
    )
/*++

Routine Description:

    Delete particular records from the cache.

    This is used to delete cluster records.

Arguments:

    pRecords -- records to remove from cache

Return Value:

    None

--*/
{
    PCACHE_ENTRY    pentry = NULL;
    PDNS_RECORD *   prrListAddr;
    PDNS_RECORD     prr;
    PDNS_RECORD     pnextRR;


    DNSDBG( TRACE, (
        "Cache_DeleteMatchingRecords( %p )\n",
        pRecords ));


    //
    //  lock with no-start
    //      - bail if no cache
    //
    //  need this as PnP release notifications will attempt to
    //  flush local cache entries;  this avoids rebuilding when
    //  already down
    //

    LOCK_CACHE_NO_START();
    if ( !g_HashTable )
    {
        goto Done;
    }

    //
    //  check all records
    //

    pnextRR = pRecords;

    while ( prr = pnextRR )
    {
        pnextRR = prr->pNext;

        //
        //  find entry in cache
        //
    
        pentry = Cache_FindEntry(
                    prr->pName,
                    FALSE       // no create
                    );
        if ( !pentry )
        {
            DNSDBG( TRACE, (
                "No cache entry for record %p (n=%S)\n",
                prr,
                prr->pName ));
            continue;
        }

        //
        //  find matching records for type
        //

        prrListAddr = NULL;

        Cache_FindEntryRecords(
              &prrListAddr,
              pentry,
              prr->wType );

        if ( !prrListAddr )
        {
            DNSDBG( TRACE, (
                "No cache record matching type for record %p (n=%S)\n",
                prr,
                prr->pName ));
            continue;
        }

        //
        //  delete matching record from list
        //

        Dns_DeleteRecordFromList(
            prrListAddr,    // addr of list
            prr             // record to delete
            );
    }

Done:

    UNLOCK_CACHE();
}



//
//  Garbage collection
//

VOID
Cache_SizeCheck(
    VOID
    )
/*++

Routine Description:

    Check cache size.

Arguments:

    Flag -- flag, currently unused

Return Value:

    None

--*/
{
    //
    //  ok -- don't signal for garbage collect
    //
    //      - below threshold
    //      - already in garbage collection
    //      - collected recently
    //

    if ( g_RecordSetCount < g_RecordSetCountThreshold ||
         g_GarbageCollectFlag ||
         g_NextGarbageTime > GetCurrentTimeInSeconds() )
    {
        return;
    }

    DNSDBG( CACHE, (
        "Cache_SizeCheck() over threshold!\n"
        "\tRecordSetCount       = %d\n"
        "\tRecordSetCountLimit  = %d\n"
        "\tStarting garbage collection ...\n",
        g_RecordSetCount,
        g_RecordSetCountThreshold ));

    //
    //  signal within lock, so that service thread
    //      can do signal within lock and avoid race on StopFlag check
    //      obviously better to simply not overload lock
    //

    LOCK_CACHE_NO_START();
    if ( !g_StopFlag )
    {
        g_GarbageCollectFlag = TRUE;
        SetEvent( g_hStopEvent );
    }
    UNLOCK_CACHE();
}



VOID
Cache_GarbageCollect(
    IN      DWORD           Flag
    )
/*++

Routine Description:

    Garbage collect cache.

Arguments:

    Flag -- flag, currently unused

Return Value:

    None

--*/
{
    DWORD   iter;
    DWORD   index;
    WORD    flushLevel;
    DWORD   passCount;

    DNSDBG( CACHE, (
        "Cache_GarbageCollect()\n"
        "\tNextIndex            = %d\n"
        "\tRecordSetCount       = %d\n"
        "\tRecordSetLimit       = %d\n"
        "\tRecordSetThreshold   = %d\n",
        g_NextGarbageIndex,
        g_RecordSetCount,
        g_RecordSetCountLimit,
        g_RecordSetCountThreshold
        ));

    if ( !g_HashTable )
    {
        return;
    }

    //
    //  collect timed out data in cache
    //
    //  DCR:  smart garbage detect
    //      - cleans until below limit
    //      - first pass invalid
    //      - then the hard stuff
    //  use restartable index so get through the cach
    //

    passCount = 0;
    while ( 1 )
    {
        if ( passCount == 0 )
        {
            flushLevel = FLUSH_LEVEL_INVALID;
        }
        else if ( passCount == 1 )
        {
            flushLevel = FLUSH_LEVEL_GARBAGE;
        }
        else
        {
            break;
        }
        passCount++;

        //
        //  flush all hash bins at current flush level
        //  until
        //      - service stop
        //      - push cache size below limit
        //

        for ( iter = 0;
              iter < g_HashTableSize;
              iter++ )
        {
            index = (iter + g_NextGarbageIndex) % g_HashTableSize;

            if ( g_StopFlag ||
                 g_WakeFlag ||
                 g_RecordSetCount < g_RecordSetCountLimit )
            {
                passCount = MAXDWORD;
                break;
            }

            Cache_FlushBucket(
                index,
                flushLevel );
        }
    
        index++;
        if ( index >= g_HashTableSize )
        {
            index = 0;
        }
        g_NextGarbageIndex = index;
    }

    //
    //  reset garbage globals
    //      - lockout for interval
    //      - clear signal flag
    //      - reset event (if not shuttting down)
    //
    //  note:  reset signal within lock, so that service thread
    //  can do signal within lock and avoid race on StopFlag check
    //  obviously better to simply not overload lock
    //

    g_NextGarbageTime = GetCurrentTimeInSeconds() + GARBAGE_LOCKOUT_INTERVAL;

    LOCK_CACHE_NO_START();
    if ( !g_StopFlag )
    {
        g_GarbageCollectFlag = FALSE;
        ResetEvent( g_hStopEvent );
    }
    UNLOCK_CACHE();

    DNSDBG( CACHE, (
        "Leave Cache_GarbageCollect()\n"
        "\tNextIndex            = %d\n"
        "\tNextTime             = %d\n"
        "\tRecordSetCount       = %d\n"
        "\tRecordSetLimit       = %d\n"
        "\tRecordSetThreshold   = %d\n",
        g_NextGarbageIndex,
        g_NextGarbageTime,
        g_RecordSetCount,
        g_RecordSetCountLimit,
        g_RecordSetCountThreshold
        ));
}



//
//  Hostfile load stuff
//

VOID
LoadHostFileIntoCache(
    IN      PSTR            pszFileName
    )
/*++

Routine Description:

    Read hosts file into cache.

Arguments:

    pFileName -- file name to load

Return Value:

    None.

--*/
{
    HOST_FILE_INFO  hostInfo;

    DNSDBG( INIT, ( "Enter  LoadHostFileIntoCache\n" ));

    //
    //  read entries from host file until exhausted
    //      - cache A record for each name and alias
    //      - cache PTR to name
    //

    RtlZeroMemory(
        &hostInfo,
        sizeof(hostInfo) );

    hostInfo.pszFileName = pszFileName;

    if ( !HostsFile_Open( &hostInfo ) )
    {
        return;
    }
    hostInfo.fBuildRecords = TRUE;

    while ( HostsFile_ReadLine( &hostInfo ) )
    {
        //  cache all the records we sucked out

        Cache_RecordList( hostInfo.pForwardRR );
        Cache_RecordList( hostInfo.pReverseRR );
        Cache_RecordList( hostInfo.pAliasRR );
    }

    HostsFile_Close( &hostInfo );

    DNSDBG( INIT, ( "Leave  LoadHostFileIntoCache\n" ));
}



VOID
InitCacheWithHostFile(
    VOID
    )
/*++

Routine Description:

    Initialize cache with host(s) file.

    This handles regular cache file and ICS file if it
    exists.

Arguments:

    None

Return Value:

    None.

--*/
{
    DNSDBG( INIT, ( "Enter  InitCacheWithHostFile\n" ));

    //
    //  load host file into cache
    //

    LoadHostFileIntoCache( NULL );

    //
    //  if running ICS, load it's file also
    //

    LoadHostFileIntoCache( "hosts.ics" );

    DNSDBG( INIT, ( "Leave  InitCacheWithHostFile\n\n\n" ));
}



DNS_STATUS
Cache_QueryResponse(
    IN OUT  PQUERY_BLOB     pBlob
    )
/*++

Routine Description:

    Find records of given name and type in cache.

Arguments:

    pBlob -- query blob

    Uses:
        pwsName
        wType
        Status
        pRecords
        fCacheNegativeResponse

    Sets:
        pRecords - may be reset to exclude non-RPCable records

Return Value:

    ErrorStatus -- same as query status, unless processing error during caching

--*/
{
    DNS_STATUS      status = pBlob->Status;
    PWSTR           pname = pBlob->pNameOrig;
    WORD            wtype = pBlob->wType;
    PDNS_RECORD     presultRR = pBlob->pRecords;


    DNSDBG( RPC, (
        "\nCache_QueryResponse( %S, type %d )\n",
        pname,
        wtype ));

    //
    //  successful response
    //      - make copy of records to return to caller
    //      - cache actual query record set
    //      - make copy to cache any additional data
    //

    if ( status == ERROR_SUCCESS  &&  presultRR )
    {
        DWORD           copyFlag;
        PDNS_RECORD     prrCache;

        //  cleanup for RPC and caching

        prrCache = Dns_RecordListScreen(
                        presultRR,
                        SCREEN_OUT_AUTHORITY | SCREEN_OUT_NON_RPC );

        //
        //  make copy for return
        //      - don't include authority records
        //
        //  NOTE:  IMPORTANT
        //  we return (RPC) a COPY of the wire set and cache the
        //  wire set;  this is because the wire set has imbedded data
        //  (the data pointers are not actual heap allocations) and
        //  and hence can not be RPC'd (without changing the RPC
        //  definition to flat data)
        //
        //  if we later want to return authority data on first query,
        //  then
        //      - clean non-RPC only
        //          - including owner name fixups
        //      - copy for result set
        //      - clean original for authority -- cache
        //      - clean any additional -- cache
        //  
        //  note:  do name pointer fixup by making round trip into cache format
        //
        //  DCR:  shouldn't have external name pointers anywhere
        //  DCR:  do RPC-able cleanup on original set before copy
        //      OR
        //  DCR:  have "cache state" on record
        //      then could move original results to cache state and caching
        //      routines could detect state and avoid double TTLing

        presultRR = Dns_RecordListCopyEx(
                        prrCache,
                        0,
                        // SCREEN_OUT_AUTHORITY
                        DnsCharSetUnicode,
                        DnsCharSetUnicode );

        pBlob->pRecords = presultRR;
        if ( !presultRR )
        {
            Dns_RecordListFree( prrCache );
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }

        //  name pointer fixup

        Cache_PrepareRecordList( presultRR );
        Cache_RestoreRecordListForRpc( presultRR );

        //
        //  do NOT cache local records
        //
        //  note:  we went through this function only to get
        //      PTR records and CNAME records in RPC format
        //      (no imbedded pointers)
        //

        if ( pBlob->pLocalRecords )
        {
            Dns_RecordListFree( prrCache );
            goto Done;
        }

        //
        //  cache original data
        //

        if ( prrCache )
        {
            Cache_RecordSetAtomic(
                pname,
                wtype,
                prrCache );
        }

        //
        //  extra records
        //      - additional data
        //      - CNAME answer data to cache at CNAME itself
        //      in CNAME case must include ANSWER data, but
        //      skip the CNAME itself
        //
        //  Cache_RecordList() breaks records into RR sets before caching
        //  

        prrCache = presultRR;
        copyFlag = SCREEN_OUT_ANSWER | SCREEN_OUT_AUTHORITY;

        if ( prrCache->wType == DNS_TYPE_CNAME )
        {
            prrCache = prrCache->pNext;
            copyFlag = SCREEN_OUT_AUTHORITY;
        }

        prrCache = Dns_RecordListCopyEx(
                        prrCache,
                        copyFlag,
                        DnsCharSetUnicode,
                        DnsCharSetUnicode );
        if ( prrCache )
        {
            Cache_RecordList( prrCache );
        }
    }

    //
    //  negative response
    //

    else if ( status == DNS_ERROR_RCODE_NAME_ERROR ||
              status == DNS_INFO_NO_RECORDS )
    {
        DWORD           ttl;
        PDNS_RECORD     prr;

        if ( !pBlob->fCacheNegative )
        {
            DNSDBG( QUERY, (
                "No negative caching for %S, type=%d\n",
                pname, wtype ));
            goto Done;
        }

        //
        //  create negative cache entry
        //
        //  DCR:  should use TTL returned in SOA
        //

        prr = Dns_AllocateRecord( 0 );
        if ( !prr )
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto Done;
        }

        prr->pName = (PWSTR) Dns_StringCopyAllocate(
                                (PCHAR) pname,
                                0,      // NULL terminated
                                DnsCharSetUnicode,
                                DnsCharSetUnicode );
        if ( prr->pName )
        {
            SET_FREE_OWNER( prr );
        }

        prr->wDataLength = 0;
        ttl = g_MaxNegativeCacheTtl;

        if ( wtype == DNS_TYPE_SOA
                &&
             ttl > g_NegativeSOACacheTime )
        {
            ttl = g_NegativeSOACacheTime;
        }
        prr->dwTtl = ttl;
        prr->Flags.S.CharSet = DnsCharSetUnicode;
        prr->Flags.S.Section = DNSREC_ANSWER;
        prr->Flags.DW |= DNSREC_NOEXIST;

        if ( status == DNS_ERROR_RCODE_NAME_ERROR )
        {
            prr->wType = DNS_TYPE_ANY;
        }
        else
        {
            prr->wType = wtype;
        }

        Cache_RecordSetAtomic(
            NULL,   // default name
            0,      // default type
            prr );
    }

    //  failure return from query
    //      - nothing to cache

    else
    {
        DNSDBG( QUERY, (
            "Uncacheable error code %d -- no caching for %S, type=%d\n",
            status,
            pname,
            wtype ));
    }

Done:

    //
    //  check cache size to see if garbage collect necessary
    //
    //  note we do this only on query caching;  this avoids
    //      - jamming ourselves in hosts file load
    //      - wakeup and grabbing lock between separate sets of query response
    //

    Cache_SizeCheck();

    return  status;
}

//
//  End ncache.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\server\notify.c ===
/*++

Copyright (c) 2000-2002  Microsoft Corporation

Module Name:

    notify.c

Abstract:

    DNS Resolver Service.

    Notification thread
        - host file changes
        - registry config changes

Author:

    Jim Gilroy  (jamesg)    November 2000

Revision History:

    jamesg  Nov 2001    -- IP6

--*/


#include "local.h"

//
//  DHCP refresh call
//

extern
DWORD
DhcpStaticRefreshParams(
    IN  LPWSTR  Adapter
    );

//
//  Host file directory
//

#define HOSTS_FILE_DIRECTORY            L"\\drivers\\etc"

//
//  Notify globals
//

DWORD   g_NotifyThreadId = 0;
HANDLE  g_hNotifyThread = NULL;

HANDLE  g_hHostFileChange = NULL;
HANDLE  g_hRegistryChange = NULL;

HKEY    g_hCacheKey = NULL;
PSTR    g_pmszAlternateNames = NULL;


//
//  Private protos
//

VOID
CleanupRegistryMonitoring(
    VOID
    );



HANDLE
CreateHostsFileChangeHandle(
    VOID
    )
/*++

Routine Description:

    Create hosts file change handle.

Arguments:

    None.

Return Value:

    None.

--*/
{
    HANDLE      changeHandle;
    PWSTR       psystemDirectory = NULL;
    UINT        len;
    WCHAR       hostDirectory[ MAX_PATH*2 ];

    DNSDBG( INIT, ( "CreateHostsFileChangeHandle\n" ));

    //
    //  build host file name
    //

    len = GetSystemDirectory( hostDirectory, MAX_PATH );
    if ( !len || len>MAX_PATH )
    {
        DNSLOG_F1( "Error:  Failed to get system directory" );
        DNSLOG_F1( "NotifyThread exiting." );
        return( NULL );
    }

    wcscat( hostDirectory, HOSTS_FILE_DIRECTORY );

    //
    //  drop change notify on host file directory
    //

    changeHandle = FindFirstChangeNotification(
                        hostDirectory,
                        FALSE,
                        FILE_NOTIFY_CHANGE_FILE_NAME |
                            FILE_NOTIFY_CHANGE_LAST_WRITE );

    if ( changeHandle == INVALID_HANDLE_VALUE )
    {
        DNSLOG_F1( "NotifyThread failed to get handle from" );
        DNSLOG_F2(
            "Failed to get hosts file change handle.\n"
            "Error code: <0x%.8X>",
            GetLastError() );
        return( NULL );
    }

    return( changeHandle );
}



//
//  Registry change monitoring
//

DNS_STATUS
InitializeRegistryMonitoring(
    VOID
    )
/*++

Routine Description:

    Setup registry change monitoring.

Arguments:

    None

Globals:

    g_pmszAlternateNames -- set with current alternate names value

    g_hCacheKey -- cache reg key is opened

    g_hRegistryChange -- creates event to be signalled on change notify

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS          status;

    DNSDBG( TRACE, (
        "InitializeRegistryMonitoring()\n" ));

    //
    //  open monitoring regkey at DnsCache\Parameters
    //      set on parameters key which always exists rather than
    //      explicitly on alternate names key, which may not
    //

    status = RegOpenKeyExW(
                HKEY_LOCAL_MACHINE,
                DNS_CACHE_KEY,
                0,
                KEY_READ,
                & g_hCacheKey );
    if ( status != NO_ERROR )
    {
        goto Failed;
    }

    g_hRegistryChange = CreateEvent(
                            NULL,       // no security
                            FALSE,      // auto-reset
                            FALSE,      // start non-signalled
                            NULL        // no name
                            );
    if ( !g_hRegistryChange )
    {
        status = GetLastError();
        goto Failed;
    }

    //
    //  set change notify
    //

    status = RegNotifyChangeKeyValue(
                g_hCacheKey,
                TRUE,       // watch subtree
                REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                g_hRegistryChange,
                TRUE        // async, func doesn't block
                );
    if ( status != NO_ERROR )
    {
        goto Failed;
    }

    //
    //  read alternate computer names
    //      - need value to compare when we get a hit on change-notify
    //      - read can fail -- value stays NULL
    //

    Reg_GetValue(
       NULL,           // no session
       g_hCacheKey,      // cache key
       RegIdAlternateNames,
       REGTYPE_ALTERNATE_NAMES,
       & g_pmszAlternateNames
       );

    goto Done;

Failed:

    //
    //  cleanup
    //

    CleanupRegistryMonitoring();

Done:

    DNSDBG( TRACE, (
        "Leave InitializeRegistryMonitoring() => %d\n"
        "\tpAlternateNames  = %p\n"
        "\thChangeEvent     = %p\n"
        "\thCacheKey        = %p\n",
        status,
        g_pmszAlternateNames,
        g_hRegistryChange,
        g_hCacheKey
        ));

    return  status;
}



DNS_STATUS
RestartRegistryMonitoring(
    VOID
    )
/*++

Routine Description:

    Check for change in alternate names.

Arguments:

    None

Globals:

    g_pmszAlternateNames -- read

    g_hCacheKey -- used for read

    g_hRegistryChange -- used to restart change-notify

Return Value:

    TRUE if alternate names has changed.
    FALSE otherwise.

--*/
{
    DNS_STATUS  status;

    DNSDBG( TRACE, (
        "RestartRegistryMonitoring()\n" ));

    //
    //  sanity check
    //

    if ( !g_hCacheKey || !g_hRegistryChange )
    {
        ASSERT( g_hCacheKey && g_hRegistryChange );
        return  ERROR_INVALID_PARAMETER;
    }

    //
    //  restart change notify
    //

    status = RegNotifyChangeKeyValue(
                g_hCacheKey,
                TRUE,       // watch subtree
                REG_NOTIFY_CHANGE_NAME | REG_NOTIFY_CHANGE_LAST_SET,
                g_hRegistryChange,
                TRUE        // async, func doesn't block
                );
    if ( status != NO_ERROR )
    {
        DNSDBG( ANY, (
            "RegChangeNotify failed! %d\n",
            status ));
        ASSERT( FALSE );
    }

    return  status;
}



VOID
CleanupRegistryMonitoring(
    VOID
    )
/*++

Routine Description:

    Cleanup registry monitoring.

Arguments:

    None

Globals:

    g_pmszAlternateNames -- is freed

    g_hCacheKey -- cache reg key is closed

    g_hRegistryChange -- is closed

Return Value:

    None

--*/
{
    DNS_STATUS  status;

    DNSDBG( TRACE, (
        "CleanupRegistryMonitoring()\n" ));

    if ( g_hHostFileChange )
    {
        CloseHandle( g_hHostFileChange );
        g_hHostFileChange = NULL;
    }

    //  cleanup registry change stuff

    DnsApiFree( g_pmszAlternateNames );
    g_pmszAlternateNames = NULL;

    RegCloseKey( g_hCacheKey );
    g_hCacheKey = NULL;
}



BOOL
CheckForAlternateNamesChange(
    VOID
    )
/*++

Routine Description:

    Check for change in alternate names.

Arguments:

    None

Globals:

    g_pmszAlternateNames -- read

    g_hCacheKey -- used for read

Return Value:

    TRUE if alternate names has changed.
    FALSE otherwise.

--*/
{
    DNS_STATUS  status;
    BOOL        fcheck = TRUE;
    PCHAR       palternateNames = NULL;

    DNSDBG( TRACE, (
        "CheckForAlternateNamesChange()\n" ));

    //
    //  sanity check
    //

    if ( !g_hCacheKey || !g_hRegistryChange )
    {
        ASSERT( g_hCacheKey && g_hRegistryChange );
        return  FALSE;
    }

    //
    //  read alternate computer names
    //      - need value to compare when we get a hit on change-notify
    //      - read can fail -- value stays NULL
    //

    Reg_GetValue(
       NULL,            // no session
       g_hCacheKey,     // cache key
       RegIdAlternateNames,
       REGTYPE_ALTERNATE_NAMES,
       & palternateNames
       );

    //
    //  detect alternate names change
    //

    if ( palternateNames || g_pmszAlternateNames )
    {
        if ( !palternateNames || !g_pmszAlternateNames )
        {
            goto Cleanup;
        }
        if ( !MultiSz_Equal_A(
                palternateNames,
                g_pmszAlternateNames ) )
        {
            goto Cleanup;
        }
    }

    fcheck = FALSE;


Cleanup:

    DnsApiFree( palternateNames );

    DNSDBG( TRACE, (
        "Leave CheckForAlternateNamesChange() => %d\n",
        fcheck ));

    return  fcheck;
}




//
//  Notify thread routines
//

VOID
ThreadShutdownWait(
    IN      HANDLE          hThread
    )
/*++

Routine Description:

    Wait on thread shutdown.

Arguments:

    hThread -- thread handle that is shutting down

Return Value:

    None.

--*/
{
    DWORD   waitResult;

    if ( !hThread )
    {
        return;
    }

    DNSDBG( ANY, (
        "Waiting on shutdown of thread %d (%p)\n",
        hThread, hThread ));

    waitResult = WaitForSingleObject(
                    hThread,
                    10000 );

    switch( waitResult )
    {
    case WAIT_OBJECT_0:

        break;

    default:

        //  thread didn't stop -- need to kill it

        ASSERT( waitResult == WAIT_TIMEOUT );

        DNSLOG_F2( "Shutdown:  thread %d not stopped, terminating", hThread );
        TerminateThread( hThread, 1 );
        break;
    }

    //  close thread handle

    CloseHandle( hThread );
}



VOID
NotifyThread(
    VOID
    )
/*++

Routine Description:

    Main notify thread.

Arguments:

    None.

Globals:

    g_hStopEvent -- waits on shutdown even

Return Value:

    None.

--*/
{
    DWORD       handleCount;
    DWORD       waitResult;
    HANDLE      handleArray[3];

    DNSDBG( INIT, (
        "\nStart NotifyThread\n" ));

    //
    //  get file change handle
    //

    g_hHostFileChange = CreateHostsFileChangeHandle();

    //
    //  init registry change-notify
    //

    InitializeRegistryMonitoring();

    //
    //  wait on
    //      - host file change => flush+rebuild cache
    //      - registry change => reread config info
    //      - shutdown => exit
    //

    handleArray[0] = g_hStopEvent;
    handleCount = 1;

    if ( g_hHostFileChange )
    {
        handleArray[handleCount++] = g_hHostFileChange;
    }
    if ( g_hRegistryChange )
    {
        handleArray[handleCount++] = g_hRegistryChange;
    }

    if ( handleCount == 1 )
    {
        DNSDBG( ANY, (
            "No change handles -- exit notify thread.\n" ));
        goto ThreadExit;
    }

    //
    //  DCR:  notify init failure handling
    //      right now this loop is toast if eventing fails during any cycle
    //
    //      should handle notify init failures
    //      - have check-n-reinit (for each notification) in the loop
    //      - when one fails, loop goes to timed wait (10m) and
    //          then retries init in next cycle;  timeout just cycles
    //          loop 
    //

    while( 1 )
    {
        waitResult = WaitForMultipleObjects(
                            handleCount,
                            handleArray,
                            FALSE,
                            INFINITE );

        switch( waitResult )
        {
        case WAIT_OBJECT_0:

            //  shutdown event
            //      - if stopping exit
            //      - do garbage collection if required
            //      - otherwise short wait to avoid spin if screwup
            //      and not get thrashed by failed garbage collection

            DNSLOG_F1( "NotifyThread:  Shutdown Event" );
            if ( g_StopFlag )
            {
                goto ThreadExit;
            }
            else if ( g_GarbageCollectFlag )
            {
                Cache_GarbageCollect( 0 );
            }
            ELSE_ASSERT_FALSE;

            Sleep( 1000 );
            if ( g_StopFlag )
            {
                goto ThreadExit;
            }
            continue;

        case WAIT_OBJECT_0 + 1:

            //  host file change -- flush cache

            DNSLOG_F1( "NotifyThread:  Host file change event" );

            //  reset notification -- BEFORE reload

            if ( !FindNextChangeNotification( g_hHostFileChange ) )
            {
                DNSLOG_F1( "NotifyThread failed to get handle" );
                DNSLOG_F1( "from FindNextChangeNotification." );
                DNSLOG_F2( "Error code: <0x%.8X>", GetLastError() );
                goto ThreadExit;
            }

            Cache_Flush();
            break;

        case WAIT_OBJECT_0 + 2:

            //  registry change notification -- flush cache and reload

            DNSLOG_F1( "NotifyThread:  Registry change event" );

            //  restart notification -- BEFORE reload

            RestartRegistryMonitoring();

            //  rebuild config

            DNSDBG( ANY, ( "\nRegistry notification, rebuilding config.\n" ));
            HandleConfigChange(
                "Registry-notification",
                FALSE           // no cache flush required
                );

            //  check if alternate name change (to notify registrations)
            //
            //  DCR:  should notify on ordinary name change
            //          - save old netinfo, get new, compare
            //          - could wrap this into HandleConfigChange

            if ( CheckForAlternateNamesChange() )
            {
                DNSDBG( ANY, ( "\nAlternate name change, notify for reregistration!\n" ));
                DhcpStaticRefreshParams(
                    NULL    // global refresh, no particular adapter
                    );
            }
            break;

        default:

            ASSERT( g_StopFlag );
            if ( g_StopFlag )
            {
                goto ThreadExit;
            }
            Sleep( 5000 );
            continue;
        }
    }

ThreadExit:

    DNSDBG( INIT, (
        "NotifyThread exit\n" ));
    DNSLOG_F1( "NotifyThread exiting." );
}



VOID
StartNotify(
    VOID
    )
/*++

Routine Description:

    Start notify thread.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    //
    //  clear
    //

    g_NotifyThreadId = 0;
    g_hNotifyThread = NULL;
    
    g_hHostFileChange = NULL;
    g_hRegistryChange = NULL;


    //
    //  host file write monitor thread
    //  keeps cache in sync when write made to host file
    //

    g_hNotifyThread = CreateThread(
                            NULL,
                            0,
                            (LPTHREAD_START_ROUTINE) NotifyThread,
                            NULL,
                            0,
                            &g_NotifyThreadId );
    if ( !g_hNotifyThread )
    {
        DNS_STATUS  status = GetLastError();

        DNSLOG_F1( "ERROR: InitializeCache function failed to create" );
        DNSLOG_F1( "       HOSTS file monitor thread." );
        DNSLOG_F2( "       Error code: <0x%.8X>", status );
        DNSLOG_F1( "       NOTE: Resolver service will continue to run." );

        DNSDBG( ANY, (
            "FAILED Notify thread start!\n"
            "\tstatus = %d\n",
            status ));
    }
}



VOID
ShutdownNotify(
    VOID
    )
/*++

Routine Description:

    Shutdown notify thread.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DWORD waitResult;

    DNSDBG( INIT, ( "NotifyShutdown()\n" ));

    //
    //  wait for notify thread to stop
    //
    
    ThreadShutdownWait( g_hNotifyThread );
    g_hNotifyThread = NULL;

    //
    //  close notification handles
    //

    if ( g_hRegistryChange )
    {
        CloseHandle( g_hRegistryChange );
        g_hRegistryChange = NULL;
    }

    //  registry monitoring cleanup

    CleanupRegistryMonitoring();

    //  clear globals

    g_NotifyThreadId = 0;
    g_hNotifyThread = NULL;
}

//
//  End notify.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\server\remote.c ===
/*++

Copyright (c) 1997-2002  Microsoft Corporation

Module Name:

    remote.c

Abstract:

    DNS Resolver Service.

    Remote APIs to resolver service.

Author:

    Glenn Curtis  (glennc)  Feb 1997

Revision History:

    Jim Gilroy (jamesg)     March 2000      cleanup

--*/


#include "local.h"


//
//  Private protos
//

PDNS_RPC_CACHE_TABLE
CreateCacheTableEntry(
    IN  LPWSTR Name
    );

VOID
FreeCacheTableEntryList(
    IN  PDNS_RPC_CACHE_TABLE pCacheTableList
    );


//
//  Operations
//

DNS_STATUS
CRrReadCache(
    IN      DNS_RPC_HANDLE          Reserved,
    OUT     PDNS_RPC_CACHE_TABLE *  ppCacheTable
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/ // CRrReadCache
{
    DNS_STATUS           status = ERROR_SUCCESS;
    PDNS_RPC_CACHE_TABLE pprevRpcEntry = NULL;
    DWORD                iter;
    DWORD                countEntries = 0;

#define MAX_RPC_CACHE_ENTRY_COUNT   (300)


    UNREFERENCED_PARAMETER(Reserved);

    DNSDBG( RPC, ( "CRrReadCache\n" ));

    if ( !ppCacheTable )
    {
        return ERROR_INVALID_PARAMETER;
    }

    *ppCacheTable = NULL;

    DNSLOG_F1( "DNS Caching Resolver Service - CRrReadCache" );

    if ( ! Rpc_AccessCheck( RESOLVER_ACCESS_ENUM ) )
    {
        DNSLOG_F1( "CRrReadCache - ERROR_ACCESS_DENIED" );
        return ERROR_ACCESS_DENIED;
    }

    status = LOCK_CACHE();
    if ( status != NO_ERROR )
    {
        return  status;
    }

    DNSLOG_F2( "   Current number of entries in cache : %d",
               g_EntryCount );
    DNSLOG_F2( "   Current number of RR sets in cache : %d",
               g_RecordSetCount );

    //
    // Loop through all hash table slots looking for cache entries
    // to return.
    //

    for ( iter = 0; iter < g_HashTableSize; iter++ )
    {
        PCACHE_ENTRY    pentry = g_HashTable[iter];
        DWORD           iter2;

        while ( pentry &&
                countEntries < MAX_RPC_CACHE_ENTRY_COUNT )
        {
            PDNS_RPC_CACHE_TABLE prpcEntry;

            prpcEntry = CreateCacheTableEntry( pentry->pName );
            if ( ! prpcEntry )
            {
                //  only failure is memory alloc

                FreeCacheTableEntryList( *ppCacheTable );
                *ppCacheTable = NULL;
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto ErrorExit;
            }

            //
            // insert new entry at end of current list
            //

            if ( pprevRpcEntry )
                pprevRpcEntry->pNext = prpcEntry;
            else
                *ppCacheTable = prpcEntry;

            pprevRpcEntry = prpcEntry;

            countEntries++;

            //
            //  fill in entry with current cached types
            //

            for ( iter2 = 0; iter2 < pentry->MaxCount; iter2++ )
            {
                PDNS_RECORD prr = pentry->Records[iter2];
                WORD        type;

                if ( !prr )
                {
                    continue;
                }

                //  DCR -- goofy, just make sure the same and index (or limit?)

                type = prr->wType;

                if ( ! prpcEntry->Type1 )
                    prpcEntry->Type1 = type;
                else if ( ! prpcEntry->Type2 )
                    prpcEntry->Type2 = type;
                else
                    prpcEntry->Type3 = type;
            }
            
            pentry = pentry->pNext;
        }

        if ( countEntries > MAX_RPC_CACHE_ENTRY_COUNT )
        {
            break;
        }
    }

ErrorExit:

    UNLOCK_CACHE();

    DNSLOG_F3( "   CRrReadCache - Returning status : 0x%.8X\n\t%s",
               status,
               Dns_StatusString( status ) );
    DNSLOG_F1( "" );

    return status;
}


DNS_STATUS
CRrReadCacheEntry(
    IN      DNS_RPC_HANDLE  Reserved,
    IN      LPWSTR          pwsName,
    IN      WORD            wType,
    OUT     PDNS_RECORD *   ppRRSet
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/ // CRrReadCacheEntry
{
    DNS_STATUS      status;
    PCACHE_ENTRY    pentry;
    PDNS_RECORD     prr;

    UNREFERENCED_PARAMETER(Reserved);

    DNSLOG_F1( "DNS Caching Resolver Service - CRrReadCacheEntry" );
    DNSLOG_F1( "   Arguments:" );
    DNSLOG_F2( "      Name             : %S", pwsName );
    DNSLOG_F2( "      Type             : %d", wType );
    DNSLOG_F1( "" );

    DNSDBG( RPC, (
        "\nCRrReadCacheEntry( %S, %d )\n",
        pwsName,
        wType ));

    if ( !ppRRSet )
        return ERROR_INVALID_PARAMETER;

    if ( ! Rpc_AccessCheck( RESOLVER_ACCESS_READ ) )
    {
        DNSLOG_F1( "CRrReadCacheEntry - ERROR_ACCESS_DENIED" );
        return ERROR_ACCESS_DENIED;
    }

    //
    //  find record in cache
    //      - copy if not NAME_ERROR or EMPTY
    //      - default to not-found error
    //      (DOES_NOT_EXIST error)
    //

    *ppRRSet = NULL;
    status = DNS_ERROR_RECORD_DOES_NOT_EXIST;

    Cache_GetRecordsForRpc(
       ppRRSet,
       & status,
       pwsName,
       wType,
       0        //  no screening flags
       );

    DNSLOG_F3( "   CRrReadCacheEntry - Returning status : 0x%.8X\n\t%s",
               status,
               Dns_StatusString( status ) );
    DNSLOG_F1( "" );

    DNSDBG( RPC, (
        "Leave CRrReadCacheEntry( %S, %d ) => %d\n\n",
        pwsName,
        wType,
        status ));

    return status;
}


DNS_STATUS
CRrGetHashTableStats(
    IN      DNS_RPC_HANDLE      Reserved,
    OUT     LPDWORD             pdwCacheHashTableSize,
    OUT     LPDWORD             pdwCacheHashTableBucketSize,
    OUT     LPDWORD             pdwNumberOfCacheEntries,
    OUT     LPDWORD             pdwNumberOfRecords,
    OUT     LPDWORD             pdwNumberOfExpiredRecords,
    OUT     PDNS_STATS_TABLE *  ppStatsTable
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PDNS_STATS_TABLE    pprevRow = NULL;
    PDWORD_LIST_ITEM    pprevItem = NULL;
    DWORD               rowIter;
    DWORD               itemIter;
    DWORD               countExpiredRecords = 0;
    DWORD               status = ERROR_SUCCESS;

    UNREFERENCED_PARAMETER(Reserved);

    if ( !pdwCacheHashTableSize ||
         !pdwCacheHashTableBucketSize ||
         !pdwNumberOfCacheEntries ||
         !pdwNumberOfRecords ||
         !pdwNumberOfExpiredRecords ||
         !ppStatsTable )
    {
        return ERROR_INVALID_PARAMETER;
    }

    DNSLOG_F1( "CRrGetHashTableStats" );
    DNSDBG( RPC, ( "CRrGetHashTableStats\n" ));

    if ( ! Rpc_AccessCheck( RESOLVER_ACCESS_READ ) )
    {
        DNSLOG_F1( "CRrGetHashTableStats - ERROR_ACCESS_DENIED" );
        return ERROR_ACCESS_DENIED;
    }

    status = LOCK_CACHE();
    if ( status != NO_ERROR )
    {
        return  status;
    }

    *pdwCacheHashTableSize = g_HashTableSize;
    //*pdwCacheHashTableBucketSize = g_CacheHashTableBucketSize;
    *pdwCacheHashTableBucketSize = 0;
    *pdwNumberOfCacheEntries = g_EntryCount;
    *pdwNumberOfRecords = g_RecordSetCount;
    *pdwNumberOfExpiredRecords = 0;

    //
    //  read entire hash table
    //

    for ( rowIter = 0;
          rowIter < g_HashTableSize;
          rowIter++ )
    {
        PCACHE_ENTRY        pentry = g_HashTable[rowIter];
        PDNS_STATS_TABLE    pnewRow;

        //
        //  create table for each new row
        //

        pnewRow = RPC_HEAP_ALLOC_ZERO( sizeof(DNS_STATS_TABLE) );
        if ( !pnewRow )
        {
            status = ERROR_NOT_ENOUGH_MEMORY;
            goto Done;
        }

        if ( pprevRow )
        {
            pprevRow->pNext = pnewRow;
        }
        else
        {
            *ppStatsTable = pnewRow;
        }
        pprevRow = pnewRow;

        //
        //  fill in row data (if any)
        //

        while ( pentry )
        {
            PDWORD_LIST_ITEM pnewItem;

            pnewItem = RPC_HEAP_ALLOC_ZERO( sizeof( DWORD_LIST_ITEM ) );
            if ( !pnewItem )
            {
                status = ERROR_NOT_ENOUGH_MEMORY;
                goto Done;
            }

            for ( itemIter = 0;
                  itemIter < pentry->MaxCount;
                  itemIter++ )
            {
                PDNS_RECORD prr = pentry->Records[itemIter];
                if ( prr )
                {
                    pnewItem->Value1++;

                    if ( !Cache_IsRecordTtlValid( prr ) )
                    {
                        pnewItem->Value2++;
                        countExpiredRecords++;
                    }
                }
            }

            if ( !pnewRow->pListItem )
            {
                pnewRow->pListItem = pnewItem;
            }
            else
            {
                pprevItem->pNext = pnewItem;
            }

            pprevItem = pnewItem;
            pentry = pentry->pNext;
        }
    }

Done:

    UNLOCK_CACHE();
    *pdwNumberOfExpiredRecords = countExpiredRecords;
    return status;
}



PDNS_RPC_CACHE_TABLE
CreateCacheTableEntry(
    IN      LPWSTR          pwsName
    )
{
    PDNS_RPC_CACHE_TABLE prpcEntry = NULL;

    if ( ! pwsName )
        return NULL;

    prpcEntry = (PDNS_RPC_CACHE_TABLE)
                    RPC_HEAP_ALLOC_ZERO( sizeof(DNS_RPC_CACHE_TABLE) );

    if ( prpcEntry == NULL )
        return NULL;

    prpcEntry->Name = RPC_HEAP_ALLOC( sizeof(WCHAR) * (wcslen(pwsName) + 1) );
    if ( ! prpcEntry->Name )
    {
        RPC_HEAP_FREE( prpcEntry );
        return NULL;
    }

    wcscpy( prpcEntry->Name, pwsName );

    return prpcEntry;
}



VOID
FreeCacheTableEntryList(
    IN  PDNS_RPC_CACHE_TABLE pCacheTableList )
{
    while ( pCacheTableList )
    {
        PDNS_RPC_CACHE_TABLE pNext = pCacheTableList->pNext;

        if ( pCacheTableList->Name )
        {
            RPC_HEAP_FREE( pCacheTableList->Name );
            pCacheTableList->Name = NULL;
        }

        RPC_HEAP_FREE( pCacheTableList );

        pCacheTableList = pNext;
    }
}

//
//  End remote.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\client\dconvert.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    dconvert.c

Abstract:

    Domain Name System (DNS) Server -- Admin Client Library

    RPC record conversion routines.
    Convert DNS_RECORD records into RPC buffer.

Author:

    Jing Chen (t-jingc)     June, 1998
    reverse functions of rconvert.c

Revision History:

--*/


#include "dnsclip.h"


//
//  size of string in RPC format
//

#define STRING_UTF8_BUF_SIZE( string, fUnicode ) \
        Dns_GetBufferLengthForStringCopy( \
            (string),   \
            0,          \
            ((fUnicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \
            DnsCharSetUtf8 )


//
//  Writing strings to RPC buffer format
//

#define WRITE_STRING_TO_RPC_BUF(buf, psz, len, funicode) \
        Dns_StringCopy(     \
            (buf),          \
            NULL,           \
            (psz),          \
            (len),          \
            ((funicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \
            DnsCharSetUtf8 )


//
//  size of name in RPC format
//

#define NAME_UTF8_BUF_SIZE( string, fUnicode ) \
        Dns_GetBufferLengthForStringCopy( \
            (string),   \
            0,          \
            ((fUnicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \
            DnsCharSetUtf8 )


//
//  Writing names to RPC buffer format
//

#define WRITE_NAME_TO_RPC_BUF(buf, psz, len, funicode) \
        Dns_StringCopy(     \
            (buf),          \
            NULL,           \
            (psz),          \
            (len),          \
            ((funicode) ? DnsCharSetUnicode : DnsCharSetUtf8), \
            DnsCharSetUtf8 )


//
//  Private protos
//

PDNS_RPC_RECORD
Rpc_AllocateRecord(
    IN      DWORD           BufferLength
    );



//
//  RPC buffer conversion functions
//

PDNS_RPC_RECORD
ADnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Convert A record from DNS Record to RPC buffer.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;

    DNS_ASSERT( pRR->wDataLength == sizeof( IP_ADDRESS ) );

    prpcRR = Rpc_AllocateRecord( sizeof( IP_ADDRESS ) );
    if ( !prpcRR )
    {
        return NULL;
    }
    prpcRR->Data.A.ipAddress = pRR->Data.A.IpAddress;

    return prpcRR;
}



PDNS_RPC_RECORD
PtrDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Process PTR compatible record from wire.
    Includes: NS, PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    DWORD           length;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );

    //
    //  PTR data is another domain name
    //
    //  determine required buffer length and allocate
    //

    length = NAME_UTF8_BUF_SIZE(pRR->Data.PTR.pNameHost, funicode);

    prpcRR = Rpc_AllocateRecord( sizeof( DNS_RPC_NAME ) + length );
    if ( !prpcRR )
    {
        return NULL;
    }

    //
    //  write hostname into buffer, immediately following PTR data struct
    //

    prpcRR->Data.PTR.nameNode.cchNameLength = (UCHAR)length;

    WRITE_NAME_TO_RPC_BUF(
        prpcRR->Data.PTR.nameNode.achName,      // buffer
        pRR->Data.PTR.pNameHost,
        0,
        funicode );

    return prpcRR;
}



PDNS_RPC_RECORD
SoaDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Convert SOA record from DNS Record to RPC buffer.

Arguments:

    pRR - ptr to record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD     prpcRR;
    DWORD               length1;
    DWORD               length2;
    PDNS_RPC_NAME       pnamePrimary;
    PDNS_RPC_NAME       pnameAdmin;
    BOOL                funicode = IS_UNICODE_RECORD( pRR );


    //
    //  determine required buffer length and allocate
    //

    length1 = NAME_UTF8_BUF_SIZE( pRR->Data.SOA.pNamePrimaryServer, funicode );

    length2 = NAME_UTF8_BUF_SIZE( pRR->Data.SOA.pNameAdministrator, funicode );

    prpcRR = Rpc_AllocateRecord(
                    SIZEOF_SOA_FIXED_DATA +
                    sizeof( DNS_RPC_NAME ) * 2 +
                    length1 + length2 );
    if ( !prpcRR )
    {
        return NULL;
    }

    //
    //  copy fixed fields
    //

    RtlCopyMemory(
        (PCHAR) & prpcRR->Data.SOA.dwSerialNo,
        (PCHAR) & pRR->Data.SOA.dwSerialNo,
        SIZEOF_SOA_FIXED_DATA );

    //
    //  copy names into RR buffer
    //      - primary server immediately follows SOA data struct
    //      - responsible party follows primary server
    //

    pnamePrimary = &prpcRR->Data.SOA.namePrimaryServer;
    pnamePrimary->cchNameLength = (UCHAR) length1;

    pnameAdmin = DNS_GET_NEXT_NAME( pnamePrimary );
    pnameAdmin->cchNameLength = (UCHAR) length2;

    WRITE_NAME_TO_RPC_BUF(
        pnamePrimary->achName,
        pRR->Data.Soa.pNamePrimaryServer,
        0,
        funicode );

    WRITE_NAME_TO_RPC_BUF(
        pnameAdmin->achName,
        pRR->Data.Soa.pNameAdministrator,
        0,
        funicode );

    return prpcRR;
}



PDNS_RPC_RECORD
TxtDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Read TXT compatible record from wire.
    Includes: TXT, X25, HINFO, ISDN

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    DWORD           bufLength;
    DWORD           length;
    INT             count;
    PCHAR           pch;
    PCHAR *         ppstring;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );

    //
    //  determine required buffer length and allocate
    //      - allocate space for each string
    //      - and ptr for each string
    //

    bufLength = 0;
    count = pRR->Data.TXT.dwStringCount;
    ppstring = pRR->Data.TXT.pStringArray;

    while ( count-- )
    {
        //
        //  Note: sizeof(DNS_RPC_NAME) is two: 1 char for the length value
        //  and 1 char for the first char in the name. The max string length
        //  is 255 because we store the string length in a single byte.
        //
        length = STRING_UTF8_BUF_SIZE( *ppstring++, funicode );
        if ( length > 255 )
        {
            return NULL;
        }
        bufLength += sizeof(DNS_RPC_NAME) + length - 1;
    }

    //  allocate

    prpcRR = Rpc_AllocateRecord( bufLength );
    if ( !prpcRR )
    {
        return NULL;
    }

    //
    //  go back through list copying strings to buffer
    //      - ptrs to strings are saved to argv like data section
    //          ppstring walks through this section
    //      - first string written immediately following data section
    //      - each subsequent string immediately follows predecessor
    //          pchbuffer keeps ptr to position to write strings
    //
    //  DEVNOTE: this is a mess
    //

    pch = (PCHAR) &prpcRR->Data.TXT;
    ppstring = pRR->Data.TXT.pStringArray;
    count =  pRR->Data.TXT.dwStringCount;

    while ( count-- )
    {
        length = STRING_UTF8_BUF_SIZE( *ppstring, funicode );
        (UCHAR) *pch++ += (UCHAR) length;    //+1 for TXT type only

        length = WRITE_STRING_TO_RPC_BUF(
                    pch,
                    *ppstring++,
                    0,
                    funicode );
        pch += length;
#if DBG
        DNS_PRINT((
            "Read text string %s\n",
            *( ppstring - 1 ) ));
#endif
    }

    return prpcRR;
}



PDNS_RPC_RECORD
MinfoDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Read MINFO record from wire.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    DWORD           length1;
    DWORD           length2;
    PDNS_RPC_NAME   prpcName1;
    PDNS_RPC_NAME   prpcName2;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );

    //
    //  determine required buffer length and allocate
    //

    length1 = NAME_UTF8_BUF_SIZE( pRR->Data.MINFO.pNameMailbox, funicode );
    length2 = NAME_UTF8_BUF_SIZE( pRR->Data.MINFO.pNameErrorsMailbox, funicode );

    prpcRR = Rpc_AllocateRecord( sizeof( DNS_RPC_NAME ) * 2 + length1 + length2 );
    if ( !prpcRR )
    {
        return NULL;
    }

    //
    //  copy names into RR buffer
    //      - mailbox immediately follows MINFO data struct
    //      - errors mailbox immediately follows primary server
    //

    prpcName1 = &prpcRR->Data.MINFO.nameMailBox;
    prpcName1->cchNameLength = (UCHAR) length1;

    prpcName2 = DNS_GET_NEXT_NAME( prpcName1);
    prpcName2->cchNameLength = (UCHAR) length2;

    WRITE_NAME_TO_RPC_BUF(
        prpcName1->achName,
        pRR->Data.MINFO.pNameMailbox,
        0,
        funicode );

    WRITE_NAME_TO_RPC_BUF(
        prpcName2->achName,
        pRR->Data.MINFO.pNameErrorsMailbox,
        0,
        funicode );

    return prpcRR;
}



PDNS_RPC_RECORD
MxDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    convert MX compatible record.
    Includes: MX, RT, AFSDB

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    PDNS_RPC_NAME   prpcName;
    DWORD           length;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );


    //
    //  determine required buffer length and allocate
    //

    length = NAME_UTF8_BUF_SIZE( pRR->Data.MX.pNameExchange, funicode );

    prpcRR = Rpc_AllocateRecord(
                    SIZEOF_MX_FIXED_DATA + sizeof( DNS_RPC_NAME ) + length );
    if ( !prpcRR )
    {
        return NULL;
    }

    //
    //  copy preference
    //

    prpcRR->Data.MX.wPreference = pRR->Data.MX.wPreference;

    //
    //  write hostname into buffer, immediately following MX struct
    //

    prpcName = &prpcRR->Data.MX.nameExchange;
    prpcName->cchNameLength = (UCHAR) length;

    WRITE_NAME_TO_RPC_BUF(
        prpcName->achName,
        pRR->Data.MX.pNameExchange,
        0,
        funicode );

    return prpcRR;
}



PDNS_RPC_RECORD
SigDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Convert SIG record.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD     prpcRR;
    PDNS_RPC_NAME       prpcName;
    DWORD               nameLength;
    DWORD               sigLength;
    BOOL                funicode = IS_UNICODE_RECORD( pRR );
    PBYTE               pSig;

    nameLength = NAME_UTF8_BUF_SIZE( pRR->Data.SIG.pNameSigner, funicode );

    sigLength = pRR->wDataLength -
                ( DWORD ) ( pRR->Data.SIG.Signature - ( PBYTE ) &pRR->Data.SIG );

    prpcRR = Rpc_AllocateRecord(
                    SIZEOF_SIG_FIXED_DATA + 1 + nameLength + sigLength );
    if ( !prpcRR )
    {
        return NULL;
    }

    prpcRR->Data.SIG.wTypeCovered = pRR->Data.SIG.wTypeCovered;
    prpcRR->Data.SIG.chAlgorithm = pRR->Data.SIG.chAlgorithm;
    prpcRR->Data.SIG.chLabelCount = pRR->Data.SIG.chLabelCount;
    prpcRR->Data.SIG.dwOriginalTtl = pRR->Data.SIG.dwOriginalTtl;
    prpcRR->Data.SIG.dwSigExpiration = pRR->Data.SIG.dwExpiration;
    prpcRR->Data.SIG.dwSigInception = pRR->Data.SIG.dwTimeSigned;
    prpcRR->Data.SIG.wKeyTag = pRR->Data.SIG.wKeyTag;

    prpcName = &prpcRR->Data.SIG.nameSigner;
    prpcName->cchNameLength = ( UCHAR ) nameLength;

    WRITE_NAME_TO_RPC_BUF(
        prpcName->achName,
        pRR->Data.SIG.pNameSigner,
        0,
        funicode );

    pSig = ( PBYTE ) DNS_GET_NEXT_NAME( prpcName );

    RtlCopyMemory( pSig, pRR->Data.SIG.Signature, sigLength );

    return prpcRR;
}   //  SigDnsRecordConvert



PDNS_RPC_RECORD
NxtDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Convert NXT record.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD     prpcRR;
    PDNS_RPC_NAME       prpcName;
    DWORD               nameLength;
    BOOL                funicode = IS_UNICODE_RECORD( pRR );

    //
    //  Allocate the RPC record.
    //

    nameLength = NAME_UTF8_BUF_SIZE( pRR->Data.NXT.pNameNext, funicode );

    prpcRR = Rpc_AllocateRecord(
                nameLength + 1 +
                ( pRR->Data.NXT.wNumTypes + 1 ) * sizeof( WORD ) );
    if ( !prpcRR )
    {
        return NULL;
    }

    //
    //  Copy the type array.
    //

    prpcRR->Data.Nxt.wNumTypeWords = pRR->Data.NXT.wNumTypes;
   
    RtlCopyMemory(
        prpcRR->Data.Nxt.wTypeWords,
        pRR->Data.NXT.wTypes,
        pRR->Data.NXT.wNumTypes * sizeof( WORD ) );

    //
    //  Write the next name.
    //

    prpcName = ( PDNS_RPC_NAME ) (
        ( PBYTE ) &prpcRR->Data.NXT.wTypeWords +
        prpcRR->Data.Nxt.wNumTypeWords * sizeof( WORD ) );
    prpcName->cchNameLength = ( UCHAR ) nameLength;
    WRITE_NAME_TO_RPC_BUF(
        prpcName->achName,
        pRR->Data.NXT.pNameNext,
        0,
        funicode );

    return prpcRR;
}   //  NxtDnsRecordConvert



PDNS_RPC_RECORD
FlatDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Convert memory copy compatible record.
    Includes AAAA and WINS types.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    DWORD           bufLength;

    //
    //  determine required buffer length and allocate
    //

    bufLength = pRR->wDataLength;

    prpcRR = Rpc_AllocateRecord( bufLength );
    if ( !prpcRR )
    {
        return NULL;
    }

    //
    //  copy packet data to record
    //

    RtlCopyMemory(
        & prpcRR->Data,
        & pRR->Data,
        bufLength );

    return prpcRR;
}



PDNS_RPC_RECORD
SrvDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    convert SRV record.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    PDNS_RPC_NAME   prpcName;
    DWORD           length;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );

    //
    //  determine required buffer length and allocate
    //

    length = NAME_UTF8_BUF_SIZE( pRR->Data.SRV.pNameTarget, funicode );

    prpcRR = Rpc_AllocateRecord(
                    SIZEOF_SRV_FIXED_DATA + sizeof(DNS_RPC_NAME) + length );
    if ( !prpcRR )
    {
        return NULL;
    }

    //
    //  copy SRV fixed fields
    //

    prpcRR->Data.SRV.wPriority = pRR->Data.SRV.wPriority;
    prpcRR->Data.SRV.wWeight   = pRR->Data.SRV.wWeight;
    prpcRR->Data.SRV.wPort     = pRR->Data.SRV.wPort;

    //
    //  write hostname into buffer, immediately following SRV struct
    //

    prpcName = &prpcRR->Data.SRV.nameTarget;
    prpcName->cchNameLength = (UCHAR) length;

    WRITE_NAME_TO_RPC_BUF(
        prpcName->achName,
        pRR->Data.SRV.pNameTarget,
        0,
        funicode );

    return prpcRR;
}



PDNS_RPC_RECORD
NbstatDnsRecordConvert(
    IN      PDNS_RECORD     pRR
    )
/*++

Routine Description:

    Read WINSR record from wire.

Arguments:

    pRR - record being read

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRR;
    PDNS_RPC_NAME   prpcName;
    DWORD           length;
    BOOL            funicode = IS_UNICODE_RECORD( pRR );


    //
    //  determine required buffer length and allocate
    //

    length = NAME_UTF8_BUF_SIZE( pRR->Data.WINSR.pNameResultDomain, funicode );

    prpcRR = Rpc_AllocateRecord(
                SIZEOF_NBSTAT_FIXED_DATA + sizeof(DNS_RPC_NAME) + length );
    if ( !prpcRR )
    {
        return NULL;
    }

    //
    //  copy WINSR fixed fields
    //

    prpcRR->Data.WINSR.dwMappingFlag   = pRR->Data.WINSR.dwMappingFlag;
    prpcRR->Data.WINSR.dwLookupTimeout = pRR->Data.WINSR.dwLookupTimeout;
    prpcRR->Data.WINSR.dwCacheTimeout  = pRR->Data.WINSR.dwCacheTimeout;

    //
    //  write hostname into buffer, immediately following WINSR struct
    //

    prpcName = &prpcRR->Data.WINSR.nameResultDomain;
    prpcName->cchNameLength = (UCHAR) length;

    WRITE_NAME_TO_RPC_BUF(
        prpcName->achName,
        pRR->Data.WINSR.pNameResultDomain,
        0,
        funicode );

    return prpcRR;
}



//
//  Jump table for DNS_RECORD => RPC buffer conversion.
//

typedef PDNS_RPC_RECORD (* RECORD_TO_RPC_CONVERT_FUNCTION)( PDNS_RECORD );

RECORD_TO_RPC_CONVERT_FUNCTION   RecordToRpcConvertTable[] =
{
    NULL,                       //  ZERO
    ADnsRecordConvert,          //  A
    PtrDnsRecordConvert,        //  NS
    PtrDnsRecordConvert,        //  MD
    PtrDnsRecordConvert,        //  MF
    PtrDnsRecordConvert,        //  CNAME
    SoaDnsRecordConvert,        //  SOA
    PtrDnsRecordConvert,        //  MB
    PtrDnsRecordConvert,        //  MG
    PtrDnsRecordConvert,        //  MR
    NULL,                       //  NULL
    FlatDnsRecordConvert,       //  WKS
    PtrDnsRecordConvert,        //  PTR
    TxtDnsRecordConvert,        //  HINFO
    MinfoDnsRecordConvert,      //  MINFO
    MxDnsRecordConvert,         //  MX
    TxtDnsRecordConvert,        //  TXT
    MinfoDnsRecordConvert,      //  RP
    MxDnsRecordConvert,         //  AFSDB
    TxtDnsRecordConvert,        //  X25
    TxtDnsRecordConvert,        //  ISDN
    MxDnsRecordConvert,         //  RT
    NULL,                       //  NSAP
    NULL,                       //  NSAPPTR
    SigDnsRecordConvert,        //  SIG
    NULL,                       //  KEY
    NULL,                       //  PX
    NULL,                       //  GPOS
    FlatDnsRecordConvert,       //  AAAA
    NULL,                       //  29
    NxtDnsRecordConvert,        //  30
    NULL,                       //  31
    NULL,                       //  32
    SrvDnsRecordConvert,        //  SRV
    NULL,                       //  ATMA
    NULL,                       //  35
    NULL,                       //  36
    NULL,                       //  37
    NULL,                       //  38
    NULL,                       //  39
    NULL,                       //  40
    NULL,                       //  OPT
    NULL,                       //  42
    NULL,                       //  43
    NULL,                       //  44
    NULL,                       //  45
    NULL,                       //  46
    NULL,                       //  47
    NULL,                       //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    NULL,                       //  TKEY
    NULL,                       //  TSIG
    FlatDnsRecordConvert,       //  WINS
    NbstatDnsRecordConvert      //  WINS-R
};



PDNS_RPC_RECORD
Rpc_AllocateRecord(
    IN      DWORD           BufferLength
    )
/*++

Routine Description:

    Allocate RPC record structure.

Arguments:

    wBufferLength - desired buffer length (beyond structure header)

Return Value:

    Ptr to buffer.
    NULL on error.

--*/
{
    PDNS_RPC_RECORD prr;

    if ( BufferLength > MAXWORD )
    {
        return NULL;
    }

    prr = ALLOCATE_HEAP( SIZEOF_DNS_RPC_RECORD_HEADER + BufferLength );
    if ( !prr )
    {
        SetLastError( ERROR_NOT_ENOUGH_MEMORY );
        return NULL;
    }

    // set datalength to buffer length

    prr->wDataLength = (WORD) BufferLength;

    return prr;
}




PDNS_RPC_RECORD
DnsConvertRecordToRpcBuffer(
    IN      PDNS_RECORD     pRecord
    )
/*++

Routine Description:

    Convert standard DNS record to RPC buffer.

Arguments:

    pRecord  -- DNS Record to be converted.

    //fUnicode -- flag, write records into unicode

Return Value:

    Ptr to new RPC buffer if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD                 prpcRecord;
    WORD                            index;
    WORD                            type;
    RECORD_TO_RPC_CONVERT_FUNCTION  pFunc;


    DNS_ASSERT( DNS_IS_DWORD_ALIGNED( pRecord ) );
    IF_DNSDBG( RPC2 )
    {
        DNS_PRINT((
            "Enter DnsConvertRecordToRpcBuffer()\n"
            "    pRecord   = %p\n",
            pRecord ));
    }

    //
    //  convert record
    //      set unicode flag if converting
    //

    type = pRecord->wType;
    index = INDEX_FOR_TYPE( type );
    DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

    if ( !index || !(pFunc = RecordToRpcConvertTable[ index ]) )
    {
        //  if unknown type try flat record copy -- best we can
        //  do to protect if server added new types since admin built

        DNS_PRINT((
            "ERROR:  no DNS_RECORD to RPC conversion routine for type %d\n"
            "    using flat conversion routine\n",
            type ));
        pFunc = FlatDnsRecordConvert;
    }

    prpcRecord = (*pFunc)( pRecord );
    if ( ! prpcRecord )
    {
        DNS_PRINT((
            "ERROR:  Record build routine failure for record type %d\n"
            "    status = %p\n\n",
            type,
            GetLastError() ));
        return NULL;
    }

    //
    //  fill out record structure
    //

    prpcRecord->wType = type;
    prpcRecord->dwTtlSeconds = pRecord->dwTtl;

    IF_DNSDBG( INIT )
    {
        DNS_PRINT((
            "New RPC buffer built\n"
            ));
    }

    IF_DNSDBG( RPC2 )
    {
        DNS_PRINT(( "Finished DnsConvertRpcBufferToRecords() " ));
    }

    return prpcRecord;
}

//
//  End dconvert.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\server\ops.c ===
/*++

Copyright (c) 2000-2001  Microsoft Corporation

Module Name:

    ops.c

Abstract:

    DNS Resolver Service.

    Remote APIs to resolver service.

Author:

    Jim Gilroy (jamesg)     November 2000

Revision History:

--*/


#include "local.h"


//
//  Max number to enum at a time
//

#define MAX_CACHE_ENUM_COUNT    (500)



//
//  Enum operations
//
//  Tag is DWORD with
//      - high word the hash bucket index
//      - low word the entry count
//

#define MakeEnumTag(h,e)            MAKEDWORD( (WORD)e, (WORD)h )

#define HashBucketFromEnumTag(t)    HIWORD(t)
#define EntryIndexFromEnumTag(t)    LOWORD(t)

#define GetRpcRecords(p,t,pi)       (NULL)
#define AllocRpcName( s )           Dns_StringCopyAllocate_W( (s), 0 )



DNS_STATUS
R_ResolverEnumCache(
    IN      DNS_RPC_HANDLE          Handle,
    IN      PDNS_CACHE_ENUM_REQUEST pRequest,
    OUT     PDNS_CACHE_ENUM *       ppEnum
    )
/*++

Routine Description:

    Enumerate entries in cache.

Arguments:

    RpcHandle -- RPC handle

    pRequest -- ptr to Enum request

    ppEnum -- addr to recv pointer to enumeration

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure to enum.

--*/
{
    DNS_STATUS          status      = ERROR_SUCCESS;
    PDNS_CACHE_ENUM     penum       = NULL;
    BOOL                flocked     = FALSE;
    DWORD               count       = 0;
    DWORD               maxCount    = 0;
    DWORD               entryCount  = 0;
    DWORD               entryStart;
    WORD                typeRequest = 0;
    DWORD               hashStart;
    DWORD               ihash;
    PDNS_RECORD         prr;
    PDNS_CACHE_ENTRY    prpcEntry;


    DNSDBG( RPC, ( "\nR_ResolverEnumCache\n" ));
    DNSLOG_F1( "Resolver - R_ResolverEnumCache" );

    if ( !ppEnum || !pRequest )
    {
        return ERROR_INVALID_PARAMETER;
    }
    *ppEnum = NULL;

    if ( ! Rpc_AccessCheck( RESOLVER_ACCESS_ENUM ) )
    {
        status = ERROR_ACCESS_DENIED;
        goto Done;
    }

    //
    //  allocate desired space
    //

    maxCount = pRequest->MaxCount;
    if ( maxCount > MAX_CACHE_ENUM_COUNT )
    {
        maxCount = MAX_CACHE_ENUM_COUNT;
    }

    penum = (PDNS_CACHE_ENUM)
                RPC_HEAP_ALLOC_ZERO(
                    sizeof(DNS_CACHE_ENUM) +
                    (maxCount * sizeof(DNS_CACHE_ENTRY)) );
    if ( !penum )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  read entries starting from EnumTag
    //

    status = LOCK_CACHE();
    if ( status != NO_ERROR )
    {
        return  status;
    }
    flocked = TRUE;
    count = 0;
    typeRequest = pRequest->Type;

    hashStart = HashBucketFromEnumTag( pRequest->EnumTag );
    entryStart = EntryIndexFromEnumTag( pRequest->EnumTag );

    //
    //  enum next DCR:  issue of CNAME here?
    //

    for ( ihash = hashStart; ihash < g_HashTableSize; ihash++ )
    {
        PCACHE_ENTRY    pentry = g_HashTable[ihash];
        entryCount = 0;

        while ( pentry )
        {
            DWORD   index = 0;

            //  skip any entries in previous enum

            if ( ihash == hashStart &&
                 entryCount < entryStart )
            {
                pentry = pentry->pNext;
                entryCount++;
                continue;
            }

            //  write enum entries matching criteria

            while( count < maxCount )
            {
                prr = GetRpcRecords(
                            pentry,
                            typeRequest,
                            & index );
                if ( !prr )
                {
                    break;
                }

                prpcEntry = &penum->EntryArray[count];

                prpcEntry->pName = AllocRpcName( pentry->pName );
                prpcEntry->wType = typeRequest;
                count++;
            }

            pentry = pentry->pNext;
            entryCount++;
        }
    }

    //
    //  set return params
    //      if exhaust cache -- success
    //      if more data, set termination tag to restart
    //

    penum->TotalCount = g_EntryCount;
    penum->EnumCount = count;
    penum->EnumTagStart = pRequest->EnumTag;

    if ( ihash == g_HashTableSize )
    {
        status = ERROR_SUCCESS;
    }
    else
    {
        status = ERROR_MORE_DATA;
        penum->EnumTagStop = (DWORD) MAKELONG( entryCount, ihash );
    }

    *ppEnum = penum;

Done:

    UNLOCK_CACHE();

    DNSDBG( RPC, (
        "Leave R_ResolverEnumCache()\n"
        "\tstatus       = %d\n"
        "\ttotal count  = %d\n"
        "\ttag start    = %p\n"
        "\ttag end      = %p\n"
        "\tcount        = %d\n\n",
        status,
        penum->TotalCount,
        penum->EnumTagStart,
        penum->EnumTagStop,
        penum->EnumCount ));

    return( status );
}



//
//  Cache operations
//

DNS_STATUS
R_ResolverFlushCache(
    IN      DNS_RPC_HANDLE  Handle
    )
/*++

Routine Description:

    Flush resolver cache.

Arguments:

    Handle -- RPC handle

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_ACCESS_DENIED if unable to flush.

--*/
{
    DNSDBG( RPC, ( "\nR_ResolverFlushCache\n" ));

    //
    //  DCR:  flush should have security
    //

    if ( ! Rpc_AccessCheck( RESOLVER_ACCESS_FLUSH ) )
    {
        DNSLOG_F1( "R_ResolverFlushCache - ERROR_ACCESS_DENIED" );
        return  ERROR_ACCESS_DENIED;
    }

    //
    //  flush cache
    //
    
    Cache_Flush();

    DNSDBG( RPC, ( "Leave R_ResolverFlushCache\n\n" ));
    return  ERROR_SUCCESS;
}



DNS_STATUS
R_ResolverFlushCacheEntry(
    IN      DNS_RPC_HANDLE  Handle,
    IN      PWSTR           pwsName,
    IN      WORD            wType
    )
/*++

Routine Description:

    Flush data from resolver cache.

Arguments:

    Handle -- RPC handle

    pwsName -- name to flush (if NULL flush entire cache)

    wType -- type to flush; if zero, flush entire entry for name

Return Value:

    ERROR_SUCCESS if successful.
    ERROR_ACCESS_DENIED if unable to flush.

--*/
{
    DNSLOG_F1( "R_ResolverFlushCacheEntry" );
    DNSLOG_F2( "    Name  : %S", pwsName );
    DNSLOG_F2( "    Type  : %d", wType );

    DNSDBG( RPC, (
        "R_ResolverFlushCacheEntry\n"
        "\tName = %p %S\n"
        "\tType = %d\n",
        pwsName, pwsName,
        wType ));

    if ( !pwsName )
    {
        return  ERROR_INVALID_PARAMETER;
    }

    //
    //  two levels
    //      1) - no type => flush the whole name entry
    //      2) - name and type => flush on particular RR set
    //

    Cache_FlushRecords(
        pwsName,
        wType
            ? FLUSH_LEVEL_NORMAL
            : FLUSH_LEVEL_WIRE,
        wType
        );

    DNSDBG( RPC, ( "Leave R_ResolverFlushCacheEntry\n\n" ));

    return  ERROR_SUCCESS;
}



//
//  Query API utilities
//

DNS_STATUS
ResolverQuery(
    IN OUT  PQUERY_BLOB     pBlob
    )
/*++

Routine Description:

    Make the query to DNS server.

Arguments:

    pBlob -- query blob

Return Value:

    ERROR_SUCCESS if successful response.
    DNS_INFO_NO_RECORDS on no records for type response.
    DNS_ERROR_RCODE_NAME_ERROR on name error.
    DNS_ERROR_INVALID_NAME on bad name.
    None

--*/
{
    DNS_STATUS          status = ERROR_SUCCESS;
    PDNS_NETINFO        pnetInfo = NULL;
    BOOL                fadapterTimedOut = FALSE;
    DNS_STATUS          statusNetFailure = ERROR_SUCCESS;


    DNSDBG( TRACE, (
        "ResolverQuery( %S, type=%d, f=%08x )\n",
        pBlob->pNameOrig,
        pBlob->wType,
        pBlob->Flags ));

    //
    //  skip query -- timeouts -- entirely if net down
    //

    if ( IsKnownNetFailure() )
    {
        status = GetLastError();
        DNSLOG_F2(
            "Not going query since there is a known net failure: 0x%.8X",
            status );
        DNSDBG( ANY, (
            "WARNING:  known net failure %d, suppressing queries!\n",
            status ));
        return status;
    }

    //
    //  get valid network info
    //

    pnetInfo = GrabNetworkInfo();
    if ( ! pnetInfo )
    {
        DNSDBG( ANY, ( "ERROR:  GrabNetworkInfo() failed!\n" ));
        return DNS_ERROR_NO_DNS_SERVERS;
    }
    pBlob->pNetInfo = pnetInfo;

    //
    //  cluster filtering an issue only on server builds
    //

    pBlob->fFilterCluster = g_IsServer;

    //
    //  query
    //  includes
    //      - local name check
    //      - wire query
    //

    status = Query_Main( pBlob );

    statusNetFailure = pBlob->NetFailureStatus;

#if 0
    //
    //  DCR:  missing catching intermediate failures
    //

        //
        //  reset server priorities on failures
        //  do here to avoid washing out info in retry with new name
        //

        if ( status != ERROR_SUCCESS &&
             pnetInfo->ReturnFlags & DNS_FLAG_RESET_SERVER_PRIORITY )
        {
            if ( g_AdapterTimeoutCacheTime &&
                 Dns_DisableTimedOutAdapters( pnetInfo ) )
            {
                fadapterTimedOut = TRUE;
                SetKnownTimedOutAdapter();
            }
        }
#endif

#if 0
    //
    //  success
    //      - drop message popup count
    //

    if ( status == ERROR_SUCCESS )
    {
        g_MessagePopupStrikes = 0;
    }

    //
    //  network failure condition
    //      - anything but ERROR_TIMEOUT is net failure
    //
    //  timeout error indicates possible net down condition
    //      - ping DNS servers
    //      if down shutdown queries for short interval; this
    //      eliminates long timeouts in boot up during netdown
    //      condition
    //
    //  DCR:  this is stupid -- ping especially
    //
    //      should just keep a count, if count rises back off;
    //      why we should do useless query (ping) is beyond me
    //      rather than just doing another query;  only advantage
    //      of ping is that it should succeed immediately
    //
    //      furthermore any tracking for this that we do do should
    //      be in single routine saving the network info
    //

    else if ( statusNetFailure )
    {
        if ( statusNetFailure == ERROR_TIMEOUT )
        {
            SetKnownNetFailure( status );
        }
    }
#endif

    //
    //  save change in adapter priority
    //

    if ( pnetInfo->ReturnFlags & RUN_FLAG_RESET_SERVER_PRIORITY )
    {
        UpdateNetworkInfo( pnetInfo );
    }
    else
    {
        NetInfo_Free( pnetInfo );
    }
    pBlob->pNetInfo = NULL;

    DNSDBG( QUERY, (
        "Leave ResolverQuery() => %d\n",
        status ));

    IF_DNSDBG( QUERY )
    {
        DnsDbg_QueryBlob(
            "Blob leaving ResolverQuery()",
            pBlob );
    }
    return status;
}



//
//  Query API
//  

#ifdef DNS_TRY_ASYNC
VOID
R_ResolverQueryAsync(
    IN      PRPC_ASYNC_STATE    AsyncHandle,
    IN      DNS_RPC_HANDLE      Handle,
    IN OUT  PRPC_QUERY_BLOB     pBlob
    )
/*++

Routine Description:

    Query the resolver.

Arguments:

    pBlob -- ptr to query info and results buffer

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode (including DNS RCODE) on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDNS_RECORD     prr = NULL;
    PDNS_RECORD     prrQuery = NULL;
    PDNS_RECORD     presultRR = NULL;
    PCACHE_ENTRY    pentry = NULL;
    BOOL            locked = FALSE;
    BOOL            fcacheNegativeResponse = FALSE;
    CHAR            nameUtf8[ DNS_MAX_NAME_BUFFER_LENGTH+1 ];
    DWORD           nameBufLength = DNS_MAX_NAME_BUFFER_LENGTH;

    //  DCR_CLEANUP:  make local
    //  quickie define to old args
    PWSTR           pwsName = pBlob->pName;
    WORD            Type = pBlob->wType;
    DWORD           Flags = pBlob->Flags;


    DNSLOG_F1( "R_ResolverQuery" );
    DNSLOG_F1( "   Arguments:" );
    DNSLOG_F2( "      Name             : %S", pwsName );
    DNSLOG_F2( "      Type             : %d", Type );
    DNSLOG_F2( "      Flags            : 0x%x", Flags );

    DNSDBG( RPC, (
        "\nR_ResolverQuery( %S, t=%d, f=%08x )\n",
        pwsName,
        Type,
        Flags ));


    //
    //  cacheable response
    //

Done:

    //
    //  put results in blob
    //

    pBlob->pRecords = presultRR;
    pBlob->Status = status;

    DNSLOG_F3(
        "R_ResolverQuery - status    : 0x%.8X\n\t%s",
        status,
        Dns_StatusString( status ) );
    DNSLOG_F1( "" );

    DNSDBG( RPC, (
        "Leave R_ResolverQuery( %S, t=%d, f=%08x )\n\n",
        pwsName,
        Type,
        Flags ));
}
#endif



BOOL
ResolverCacheQueryCallback(
    IN OUT  PQUERY_BLOB     pBlob
    )
/*++

Routine Description:

    Check cache for name.

    This is callback to check appended names.

Arguments:

    pBlob -- query blob

Return Value:

    TRUE if name and type found.
    FALSE otherwise.

--*/
{
    //
    //  check cache for name and type
    //

    if ( SKIP_CACHE_LOOKUP(pBlob->Flags) )
    {
        return  FALSE;
    }

    //
    //  lookup full query name in cache
    //

    if ( !pBlob->pNameQuery )
    {
        DNSDBG( ANY, (
            "Invalid name %s.\n",
            pBlob->pNameQuery ));
        DNS_ASSERT( FALSE );
        return  FALSE;
    }

    return  Cache_GetRecordsForRpc(
                & pBlob->pRecords,
                & pBlob->Status,
                pBlob->pNameQuery,
                pBlob->wType,
                pBlob->Flags
                );
}



DNS_STATUS
R_ResolverQuery(
    IN      DNS_RPC_HANDLE  Handle,
    IN      PWSTR           pwsName,
    IN      WORD            wType,
    IN      DWORD           Flags,
    OUT     PDNS_RECORD *   ppResultRecords
    )
/*++

Routine Description:

    Simple query to resolver.

Arguments:


Return Value:

    ERROR_SUCCESS if query successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDNS_RECORD     prrReturn = NULL;
    QUERY_BLOB      blob;


    DNSLOG_F1( "DNS Caching Resolver Service - R_ResolverQuery" );
    DNSLOG_F1( "   Arguments:" );
    DNSLOG_F2( "      Name             : %S", pwsName );
    DNSLOG_F2( "      Type             : %d", wType );
    DNSLOG_F2( "      Flags            : 0x%x", Flags );

    DNSDBG( RPC, (
        "\nR_ResolverQuery( %S, t=%d, f=%08x )\n",
        pwsName,
        wType,
        Flags ));

    if ( !ppResultRecords )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //  DCR:  should allow NULL name as local name lookup

    if ( !pwsName )
    {
        return ERROR_INVALID_NAME;
    }

    //
    //  note:  no access check on query -- all processes allowed to query
    //

#if 0
    if ( ! Rpc_AccessCheck( RESOLVER_ACCESS_QUERY ) )
    {
        DNSLOG_F1( "R_ResolverQuery - ERROR_ACCESS_DENIED" );
        status = ERROR_ACCESS_DENIED;
        goto Done;
    }
#endif

    //
    //  check cache for name and type
    //
    //  DCR:  functionalize to take QUERY_BLOB
    //

    if ( !(Flags & DNS_QUERY_BYPASS_CACHE) )
    {
        if ( Cache_GetRecordsForRpc(
                & prrReturn,
                & status,
                pwsName,
                wType,
                Flags ) )
        {
            goto Done;
        }
    }

    //
    //  setup query blob
    //

    RtlZeroMemory(
        & blob,
        sizeof(blob) );

    blob.pNameOrig      = pwsName;
    blob.wType          = wType;
    blob.Flags          = Flags | DNSQUERY_UNICODE_OUT;

    //  callbacks
    //      - address info func for prioritize
    //      - cache query for intermediate names

    //  FIX6:  now get this from netinfo blob itself
    //blob.pfnGetAddrArray = GetLocalAddrArray;
    blob.pfnQueryCache   = ResolverCacheQueryCallback;

    //
    //  do query
    //      - local lookup
    //      - then wire query
    //

    status = ResolverQuery( &blob );

    if ( status != ERROR_SUCCESS &&
         status != DNS_ERROR_RCODE_NAME_ERROR &&
         status != DNS_INFO_NO_RECORDS )
    {
        goto Done;
    }
    prrReturn = blob.pRecords;

    //
    //  local results
    //      - not cached
    //      but note that still going through Cache_QueryResponse()
    //      to get proper RPC preparation

#if 0
    if ( blob.pLocalRecords )
    {
    }
#endif

    //
    //  cache results
    //      - don't cache local lookup records
    //
    //  DCR:  should have simple "CacheResults" flag
    //
    //  note:  even local records are going through here
    //      now to clean them up for RPC;  they are not
    //      cached
    //

    status = Cache_QueryResponse( &blob );
    prrReturn = blob.pRecords;
    

Done:

    //  dump any unused query records

    if ( prrReturn && status != ERROR_SUCCESS )
    {
        Dns_RecordListFree( prrReturn );
        prrReturn = NULL;
    }

    //  set out pointer

    *ppResultRecords = prrReturn;

    DNSLOG_F3(
        "   R_ResolverQuery - Returning status    : 0x%.8X\n\t%s",
        status,
        Dns_StatusString(status) );
    DNSLOG_F1( "" );

    IF_DNSDBG( RPC )
    {
        DnsDbg_RecordSet(
            "R_ResolverQuery Result List:",
            prrReturn );
    }
    DNSDBG( RPC, (
        "Leave R_ResolverQuery( %S, t=%d, f=%08x )\n\n"
        "\tstatus = %d\n\n",
        pwsName,
        wType,
        Flags,
        status ));

    return status;
}

//
//  End ops.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\client\dnsclip.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    dnsclip.h

Abstract:

    Domain Name System (DNS) Server -- Admin Client API

    Main header file for DNS client API library.

Author:

    Jim Gilroy (jamesg)     September 1995

Revision History:

--*/


#ifndef _DNSCLIP_INCLUDED_
#define _DNSCLIP_INCLUDED_

#pragma warning(disable:4214)
#pragma warning(disable:4514)
#pragma warning(disable:4152)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>

//  headers are messed up
//  if you bring in nt.h, then don't bring in winnt.h and
//  then you miss these

#ifndef MAXWORD
#define MINCHAR     0x80
#define MAXCHAR     0x7f
#define MINSHORT    0x8000
#define MAXSHORT    0x7fff
#define MINLONG     0x80000000
#define MAXLONG     0x7fffffff
#define MAXBYTE     0xff
#define MAXWORD     0xffff
#define MAXDWORD    0xffffffff
#endif

#include <winsock2.h>
#include "dnsrpc_c.h"   //  MIDL generated RPC interface definitions
#include <dnsrpc.h>

#include <stdio.h>
#include <stdlib.h>

#include <ntdsapi.h>

#define STRSAFE_NO_DEPRECATE    //  Do not deprecate strcpy, etc.
#include <strsafe.h>            //  safe string functions

#define  NO_DNSAPI_DLL
#include "dnslib.h"


//
//  Internal routines
//
#ifdef __cplusplus
extern "C"
{
#endif

VOID
DnssrvCopyRpcNameToBuffer(
    IN      PSTR            pResult,
    IN      PDNS_RPC_NAME   pName
    );

PDNS_RPC_RECORD
DnsConvertRecordToRpcBuffer(
    IN      PDNS_RECORD     pRecord
    );

PVOID
DnssrvMidlAllocZero(
    IN      DWORD           dwSize
    );

PDNS_NODE
DnsConvertRpcBuffer(
    OUT     PDNS_NODE *     ppNodeLast,
    IN      DWORD           dwBufferLength,
    IN      BYTE            abBuffer[],
    IN      BOOLEAN         fUnicode
    );

DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumRecordsStub(
    IN      LPCSTR      Server,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszStartChild,
    IN      WORD        wRecordType,
    IN      DWORD       dwSelectFlag,
    IN OUT  PDWORD      pdwBufferLength,
    OUT     PBYTE *     ppBuffer
    );

#ifdef __cplusplus
}
#endif  // __cplusplus
//
//  Heap routines
//  Use dnsapi.dll memory routines
//

#define ALLOCATE_HEAP(iSize)            Dns_Alloc(iSize)
#define ALLOCATE_HEAP_ZERO(iSize)       Dns_AllocZero(iSize)
#define REALLOCATE_HEAP(pMem,iSize)     Dns_Realloc((pMem),(iSize))
#define FREE_HEAP(pMem)                 Dns_Free(pMem)


//
//  Debug stuff
//

#if DBG

#undef  ASSERT
#define ASSERT( expr )          DNS_ASSERT( expr )

#define DNSRPC_DEBUG_FLAG_FILE  ("dnsrpc.flag")
#define DNSRPC_DEBUG_FILE_NAME  ("dnsrpc.log")

#define DNS_DEBUG_EVENTLOG      0x00000010
#define DNS_DEBUG_RPC           0x00000020
#define DNS_DEBUG_STUB          0x00000040

#define DNS_DEBUG_HEAP          0x00010000
#define DNS_DEBUG_HEAP_CHECK    0x00020000
#define DNS_DEBUG_REGISTRY      0x00080000

#endif


//
//  If you like having a local variable in functions to hold the function 
//  name so that you can include it in debug logs without worrying about 
//  changing all the occurences when the function is renamed, use this 
//  at the top of the function:
//      DBG_FN( "MyFunction" )      <--- NOTE: no semi-colon!!
//


#if DBG
#define DBG_FN( funcName ) static const char * fn = (funcName);
#else
#define DBG_FN( funcName )
#endif


//
//  Miscellaneous
//


#define sizeofarray( _ArrayName ) ( sizeof( _ArrayName ) / sizeof( ( _ArrayName ) [ 0 ] ) )


//
//  Functions to get/set thread local W2K RPC bind retry flag.
//


VOID
dnsrpcSetW2KBindFlag(
    BOOL        newFlagValue
    );

BOOL
dnsrpcGetW2KBindFlag(
    VOID
    );


#endif //   _DNSCLIP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\resolver\server\rpc.c ===
/*++

Copyright (c) 2001-2001 Microsoft Corporation

Module Name:

    rpc.c

Abstract:

    DNS Resolver Service

    RPC intialization, shutdown and utility routines.

Author:

    Jim Gilroy (jamesg)     April 19, 2001

Revision History:

--*/


#include "local.h"
#include <rpc.h>
#include "rpcdce.h"
#include "secobj.h"

#undef UNICODE


//
//  RPC globals
//

BOOL    g_fRpcInitialized = FALSE;

DWORD   g_RpcProtocol = RESOLVER_RPC_USE_LPC;

PSECURITY_DESCRIPTOR g_pRpcSecurityDescriptor;


#define AUTO_BIND


//
//  Resolver access control
//

PSECURITY_DESCRIPTOR    g_pAccessSecurityDescriptor = NULL;
PACL                    g_pAccessAcl = NULL;
PSID                    g_pAccessOwnerSid = NULL;

GENERIC_MAPPING         g_AccessGenericMapping =
{
    RESOLVER_GENERIC_READ,
    RESOLVER_GENERIC_WRITE,
    RESOLVER_GENERIC_EXECUTE,
    RESOLVER_GENERIC_ALL
};

#define SECURITY_LOCK()     EnterCriticalSection( &CacheCS )
#define SECURITY_UNLOCK()   LeaveCriticalSection( &CacheCS )

//  
//  Privileges
//

#if 0
#define RESOLVER_PRIV_READ          1
#define RESOLVER_PRIV_ENUM          2
#define RESOLVER_PRIV_FLUSH         3
#define RESOLVER_PRIV_REGISTER      4
#endif



DNS_STATUS
Rpc_InitAccessChecking(
    VOID
    );

VOID
Rpc_CleanupAccessChecking(
    VOID
    );





BOOL
Rpc_IsProtoLpcA(
    IN      PVOID           pContext
    )
/*++

Routine Description:

    Check if access if over LPC

Arguments:

    pContext -- client RPC context

Return Value:

    TRUE if protocol is LPC
    FALSE otherwise

--*/
{
    DNS_STATUS  status;
    BOOL        fisLpc = FALSE;
    PSTR        pbinding = NULL;
    PSTR        pprotoString = NULL;


    DNSDBG( RPC, (
        "Rpc_IsAccessOverLpc( context=%p )\n",
        pContext ));

    //
    //  get string binding
    //

    status = RpcBindingToStringBindingA(
                pContext,
                & pbinding );

    if ( status != NO_ERROR )
    {
        goto Cleanup;
    }

    //
    //  get protocol as string
    //

    status = RpcStringBindingParseA(
                pbinding,
                NULL,
                & pprotoString,
                NULL,
                NULL,
                NULL );

    if ( status != NO_ERROR )
    {
        goto Cleanup;
    }

    //
    //  check for LPC
    //

    fisLpc = ( _stricmp( pprotoString, "ncalrpc" ) == 0 );

    RpcStringFreeA( &pprotoString );

Cleanup:

    if ( pbinding )
    {
        RpcStringFreeA( &pbinding );
    }

    return( fisLpc );
}



BOOL
Rpc_IsProtoLpc(
    IN      PVOID           pContext
    )
/*++

Routine Description:

    Check if access if over LPC

Arguments:

    pContext -- client RPC context

Return Value:

    TRUE if protocol is LPC
    FALSE otherwise

--*/
{
    DNS_STATUS  status;
    BOOL        fisLpc = FALSE;
    PWSTR       pbinding = NULL;
    PWSTR       pprotoString = NULL;


    DNSDBG( RPC, (
        "Rpc_IsAccessOverLpc( context=%p )\n",
        pContext ));

    //
    //  get string binding
    //

    status = RpcBindingToStringBinding(
                pContext,
                & pbinding );

    if ( status != NO_ERROR )
    {
        goto Cleanup;
    }

    //
    //  get protocol as string
    //

    status = RpcStringBindingParse(
                pbinding,
                NULL,
                & pprotoString,
                NULL,
                NULL,
                NULL );

    if ( status != NO_ERROR )
    {
        goto Cleanup;
    }

    //
    //  check for LPC
    //

    fisLpc = ( _wcsicmp( pprotoString, L"ncalrpc" ) == 0 );

    RpcStringFree( &pprotoString );

Cleanup:

    if ( pbinding )
    {
        RpcStringFree( &pbinding );
    }

    return( fisLpc );
}



RPC_STATUS
RPC_ENTRY
Rpc_SecurityCallback(
    IN      RPC_IF_HANDLE   IfHandle,
    IN      PVOID           pContext
    )
/*++

Routine Description:

    RPC callback security check.

Arguments:

    IfHandle -- interface handle

    pContext -- client RPC context

Return Value:

    NO_ERROR if security check allows access.
    ErrorCode on security failure.

--*/
{
    DNSDBG( RPC, (
        "Rpc_SecurityCallback( context=%p )\n",
        pContext ));

    //
    //  check if connection over LPC
    //

    if ( !Rpc_IsProtoLpc(pContext) )
    {
        return  ERROR_ACCESS_DENIED;
    }

    return  NO_ERROR;
}



DNS_STATUS
Rpc_Initialize(
    VOID
    )
/*++

Routine Description:

    Initialize server side RPC.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    Error status on failure.

--*/
{
    RPC_STATUS  status;
    BOOL        fusingTcpip = FALSE;


    DNSDBG( RPC, (
        "Rpc_Initialize()\n"
        "\tIF handle    = %p\n"
        "\tprotocol     = %d\n",
        DnsResolver_ServerIfHandle,
        g_RpcProtocol
        ));

    //
    //  RPC disabled?
    //

    if ( ! g_RpcProtocol )
    {
        g_RpcProtocol = RESOLVER_RPC_USE_LPC;
    }

#if 0
    //
    //  Create security for RPC API
    //

    status = NetpCreateWellKnownSids( NULL );
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT(( "ERROR:  Creating well known SIDs.\n" ));
        return( status );
    }

    status = RpcUtil_CreateSecurityObjects();
    if ( status != ERROR_SUCCESS )
    {
        DNS_PRINT(( "ERROR:  Creating DNS security object.\n" ));
        return( status );
    }
#endif

    //
    //  build security descriptor
    //
    //  NULL security descriptor gives some sort of default security
    //  on the interface
    //      - owner is this service (currently "Network Service")
    //      - read access for everyone
    //
    //  note:  if roll your own, remember to avoid NULL DACL, this
    //      puts NO security on interface including the right to
    //      change security, so any app can hijack the ACL and
    //      deny access to folks;  the default SD==NULL security
    //      doesn't give everyone WRITE_DACL
    //

    g_pRpcSecurityDescriptor = NULL;

    //
    //  RPC over LPC
    //

    if( g_RpcProtocol & RESOLVER_RPC_USE_LPC )
    {
        status = RpcServerUseProtseqEpW(
                        L"ncalrpc",                     // protocol string.
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT, // maximum concurrent calls
                        RESOLVER_RPC_LPC_ENDPOINT_W,    // endpoint
                        g_pRpcSecurityDescriptor        // security
                        );

        //  duplicate endpoint is ok

        if ( status == RPC_S_DUPLICATE_ENDPOINT )
        {
            status = RPC_S_OK;
        }
        if ( status != RPC_S_OK )
        {
            DNSDBG( INIT, (
                "ERROR:  RpcServerUseProtseqEp() for LPC failed.]n"
                "\tstatus = %d 0x%08lx.\n",
                status, status ));
            return( status );
        }
    }

#if 0       // use use LPC interface
    //
    //  RCP over TCP/IP
    //

    if( g_RpcProtocol & RESOLVER_RPC_USE_TCPIP )
    {
#ifdef AUTO_BIND

        RPC_BINDING_VECTOR * bindingVector;

        status = RpcServerUseProtseqW(
                        L"ncacn_ip_tcp",                // protocol string.
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT, // max concurrent calls
                        g_pRpcSecurityDescriptor
                        );

        if ( status != RPC_S_OK )
        {
            DNSDBG( INIT, (
                "ERROR:  RpcServerUseProtseq() for TCP/IP failed.]n"
                "\tstatus = %d 0x%08lx.\n",
                status, status ));
            return( status );
        }

        status = RpcServerInqBindings( &bindingVector );

        if ( status != RPC_S_OK )
        {
            DNSDBG( INIT, (
                "ERROR:  RpcServerInqBindings failed.\n"
                "\tstatus = %d 0x%08lx.\n",
                status, status ));
            return( status );
        }

        //
        //  register interface(s)
        //  since only one DNS server on a host can use
        //      RpcEpRegister() rather than RpcEpRegisterNoReplace()
        //

        status = RpcEpRegisterW(
                    DnsResolver_ServerIfHandle,
                    bindingVector,
                    NULL,
                    L"" );
        if ( status != RPC_S_OK )
        {
            DNSDBG( ANY, (
                "ERROR:  RpcEpRegisterNoReplace() failed.\n"
                "\tstatus = %d %p.\n",
                status, status ));
            return( status );
        }

        //
        //  free binding vector
        //

        status = RpcBindingVectorFree( &bindingVector );
        ASSERT( status == RPC_S_OK );
        status = RPC_S_OK;

#else  // not AUTO_BIND
        status = RpcServerUseProtseqEpW(
                        L"ncacn_ip_tcp",                // protocol string.
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT, // maximum concurrent calls
                        RESOLVER_RPC_SERVER_PORT_W,     // endpoint
                        g_pRpcSecurityDescriptor        // security
                        );

        if ( status != RPC_S_OK )
        {
            DNSDBG( ANY, (
                "ERROR:  RpcServerUseProtseqEp() for TCP/IP failed.]n"
                "\tstatus = %d 0x%08lx.\n",
                status, status ));
            return( status );
        }

#endif // AUTO_BIND

        fusingTcpip = TRUE;
    }

    //
    //  RPC over named pipes
    //

    if ( g_RpcProtocol & RESOLVER_RPC_USE_NAMED_PIPE )
    {
        status = RpcServerUseProtseqEpW(
                        L"ncacn_np",                        // protocol string.
                        RPC_C_PROTSEQ_MAX_REQS_DEFAULT,     // maximum concurrent calls
                        RESOLVER_RPC_PIPE_NAME_W,           // endpoint
                        g_pRpcSecurityDescriptor
                        );

        //  duplicate endpoint is ok

        if ( status == RPC_S_DUPLICATE_ENDPOINT )
        {
            status = RPC_S_OK;
        }
        if ( status != RPC_S_OK )
        {
            DNSDBG( INIT, (
                "ERROR:  RpcServerUseProtseqEp() for named pipe failed.]n"
                "\tstatus = %d 0x%08lx.\n",
                status,
                status ));
            return( status );
        }
    }
#endif      // only LPC interface


    //
    //  register DNS RPC interface(s)
    //

    status = RpcServerRegisterIfEx(
                DnsResolver_ServerIfHandle,
                NULL,
                NULL,
                0,
                RPC_C_LISTEN_MAX_CALLS_DEFAULT,
                Rpc_SecurityCallback
                );
    if ( status != RPC_S_OK )
    {
        DNSDBG( INIT, (
            "ERROR:  RpcServerRegisterIfEx() failed.]n"
            "\tstatus = %d 0x%08lx.\n",
            status, status ));
        return(status);
    }

#if 0
    //
    //  for TCP/IP setup authentication
    //

    if ( fuseTcpip )
    {
        status = RpcServerRegisterAuthInfoW(
                    RESOLVER_RPC_SECURITY_W,        // app name to security provider.
                    RESOLVER_RPC_SECURITY_AUTH_ID,  // Auth package ID.
                    NULL,                           // Encryption function handle.
                    NULL );                         // argment pointer to Encrypt function.
        if ( status != RPC_S_OK )
        {
            DNSDBG( INIT, (
                "ERROR:  RpcServerRegisterAuthInfo() failed.]n"
                "\tstatus = %d 0x%08lx.\n",
                status, status ));
            return( status );
        }
    }
#endif

    //
    //  Listen on RPC
    //

    status = RpcServerListen(
                1,                              // min threads
                RPC_C_PROTSEQ_MAX_REQS_DEFAULT, // max concurrent calls
                TRUE );                         // return on completion

    if ( status != RPC_S_OK )
    {
        if ( status != RPC_S_ALREADY_LISTENING )
        {
            DNS_PRINT((
                "ERROR:  RpcServerListen() failed\n"
                "\tstatus = %d 0x%p\n",
                status, status ));
            return( status );
        }
        status = NO_ERROR;
    }

    g_fRpcInitialized = TRUE;
    return( status );

}   //  Rpc_Initialize



VOID
Rpc_Shutdown(
    VOID
    )
/*++

Routine Description:

    Shutdown RPC on the server.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DWORD   status;
    RPC_BINDING_VECTOR * bindingVector = NULL;

    DNSDBG( RPC, ( "Rpc_Shutdown().\n" ));

    if( ! g_fRpcInitialized )
    {
        DNSDBG( RPC, (
            "RPC not active, no shutdown necessary.\n" ));
        return;
    }

#if 0
    //  can not stop server as another service may share this process

    //
    //  stop server listen
    //  then wait for all RPC threads to go away
    //

    status = RpcMgmtStopServerListening(
                NULL        // this app
                );
    if ( status == RPC_S_OK )
    {
        status = RpcMgmtWaitServerListen();
    }
#endif

    //
    //  unbind / unregister endpoints
    //

    status = RpcServerInqBindings( &bindingVector );
    ASSERT( status == RPC_S_OK );

    if ( status == RPC_S_OK )
    {
        status = RpcEpUnregister(
                    DnsResolver_ServerIfHandle,
                    bindingVector,
                    NULL );               // Uuid vector.
        if ( status != RPC_S_OK )
        {
            DNSDBG( ANY, (
                "ERROR:  RpcEpUnregister, status = %d.\n", status ));
        }
    }

    //
    //  free binding vector
    //

    if ( bindingVector )
    {
        status = RpcBindingVectorFree( &bindingVector );
        ASSERT( status == RPC_S_OK );
    }

    //
    //  wait for all calls to complete
    //

    status = RpcServerUnregisterIf(
                DnsResolver_ServerIfHandle,
                0,
                TRUE );
    ASSERT( status == ERROR_SUCCESS );

    g_fRpcInitialized = FALSE;

    //
    //  dump resolver access checking security structs
    //

    Rpc_CleanupAccessChecking();

    DNSDBG( RPC, (
        "RPC shutdown completed.\n" ));
}




//
//  RPC access control
//
//  The RPC interface, by design, must be open to basically every
//  process for query.   So the RPC interface itself uses just
//  default security (above).
//
//  To get more detailed call-by-call access checking for special
//  operations -- enum, flush, cluster registrations -- we need
//  separate access checking.
//

DNS_STATUS
Rpc_InitAccessChecking(
    VOID
    )
/*++

Routine Description:

    Initialize resolver security.

Arguments:

    None

Return Value:

    NO_ERROR if successful.
    ErrorCode on failure.

--*/
{
    PSECURITY_DESCRIPTOR        psd = NULL;
    SID_IDENTIFIER_AUTHORITY    authority = SECURITY_NT_AUTHORITY;
    PACL        pacl = NULL;
    PSID        psidAdmin = NULL;
    PSID        psidPowerUser = NULL;
    PSID        psidLocalService = NULL;
    PSID        psidNetworkService = NULL;
    PSID        psidNetworkConfigOps = NULL;
    DWORD       lengthAcl;
    DNS_STATUS  status = NO_ERROR;
    BOOL        bresult;


    DNSDBG( INIT, ( "Rpc_InitAccessChecking()\n" ));

    //
    //  check if already have SD
    //
    //  explicitly "create once" semantics;  once
    //  created SD is read-only and not destroyed until
    //  shutdown
    //

    if ( g_pAccessSecurityDescriptor )
    {
        return  NO_ERROR;
    }

    //  lock and retest

    SECURITY_LOCK();
    if ( g_pAccessSecurityDescriptor )
    {
        status = NO_ERROR;
        goto Unlock;
    }

    //
    //  build SIDs that will be allowed access
    //

    bresult = AllocateAndInitializeSid(
                    &authority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_ADMINS,
                    0, 0, 0, 0, 0, 0,
                    & psidAdmin
                    );

    bresult = bresult &&
                AllocateAndInitializeSid(
                    &authority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_POWER_USERS,
                    0, 0, 0, 0, 0, 0,
                    & psidPowerUser
                    );
    
    bresult = bresult &&
                AllocateAndInitializeSid(
                    &authority,
                    1,
                    SECURITY_LOCAL_SERVICE_RID,
                    0,
                    0, 0, 0, 0, 0, 0,
                    &psidLocalService
                    );
                    
    bresult = bresult &&
                AllocateAndInitializeSid(
                    &authority,
                    1,
                    SECURITY_NETWORK_SERVICE_RID,
                    0,
                    0, 0, 0, 0, 0, 0,
                    &psidNetworkService
                    );
                    
    bresult = bresult &&
                AllocateAndInitializeSid(
                    &authority,
                    2,
                    SECURITY_BUILTIN_DOMAIN_RID,
                    DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS,
                    0, 0, 0, 0, 0, 0,
                    &psidNetworkConfigOps
                    );
                    
    if ( !bresult )
    {
        status = GetLastError();
        if ( status == NO_ERROR )
        {
            status = DNS_ERROR_NO_MEMORY;
        }
        DNSDBG( ANY, (
            "Failed building resolver ACEs!\n" ));
        goto Cleanup;
    }

    //
    //  allocate ACL
    //

    lengthAcl = ( (ULONG)sizeof(ACL)
               + 5*((ULONG)sizeof(ACCESS_ALLOWED_ACE) - (ULONG)sizeof(ULONG)) +
               + GetLengthSid( psidAdmin )
               + GetLengthSid( psidPowerUser )
               + GetLengthSid( psidLocalService )
               + GetLengthSid( psidNetworkService )
               + GetLengthSid( psidNetworkConfigOps ) );
    
    pacl = GENERAL_HEAP_ALLOC( lengthAcl );
    if ( !pacl )
    {
        status = GetLastError();
        goto Cleanup;
    }
    
    bresult = InitializeAcl( pacl, lengthAcl, ACL_REVISION2 );
    
    //
    //  init ACLs
    //
    //  - default to generic READ\WRITE
    //  - local service GENERIC_ALL to include registration
    //  - admin gets GENERIC_ALL on debug to test registration
    //
    //  DCR:  GENERIC_ALL on admin subject to test flag
    //
    //  note:  the masks for the individual SIDs need not be
    //      GENERIC bits, they can be made completely with
    //      with individual bits or mixed\matched with GENERIC
    //      bits as desired
    //

    bresult = bresult &&
                AddAccessAllowedAce(
                    pacl,
                    ACL_REVISION2,
                    GENERIC_ALL,
                    psidLocalService );

    bresult = bresult &&
                AddAccessAllowedAce(
                    pacl,
                    ACL_REVISION2,
#ifdef DBG
                    GENERIC_ALL,
#else
                    GENERIC_READ | GENERIC_WRITE,
#endif
                    psidAdmin );
    
    bresult = bresult &&
                AddAccessAllowedAce(
                    pacl,
                    ACL_REVISION2,
                    GENERIC_READ | GENERIC_WRITE,
                    psidPowerUser );

    bresult = bresult &&
                AddAccessAllowedAce(
                    pacl,
                    ACL_REVISION2,
                    GENERIC_READ | GENERIC_WRITE,
                    psidNetworkService );

    bresult = bresult &&
                AddAccessAllowedAce(
                    pacl,
                    ACL_REVISION2,
                    GENERIC_READ | GENERIC_WRITE,
                    psidNetworkConfigOps );

    if ( !bresult )
    {
        status = GetLastError();
        DNSDBG( ANY, (
            "Failed building resolver ACEs!\n" ));
        goto Cleanup;
    }

    //
    //  allocate security descriptor
    //  then init with ACL
    //

    psd = GENERAL_HEAP_ALLOC( SECURITY_DESCRIPTOR_MIN_LENGTH );
    if ( !psd )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Cleanup;
    }
    
    bresult = InitializeSecurityDescriptor(
                    psd,
                    SECURITY_DESCRIPTOR_REVISION );
    
    bresult = bresult &&
                SetSecurityDescriptorDacl(
                    psd,
                    TRUE,       // have DACL
                    pacl,       // DACL
                    FALSE       // DACL not defaulted, explicit
                    );

    //  security folks indicate need owner to do AccessCheck
    
    bresult = bresult &&
                SetSecurityDescriptorOwner(
                    psd,
                    psidNetworkService,
                    FALSE       // owner not defaulted, explicit
                    );

#if 0
    //  adding group seemed to make it worse
    bresult = bresult &&
                SetSecurityDescriptorGroup(
                    psd,
                    psidNetworkService,
                    FALSE       // group not defaulted, explicit
                    );
#endif

    if ( !bresult )
    {
        status = GetLastError();
        DNSDBG( ANY, (
            "Failed setting security descriptor!\n" ));
        goto Cleanup;
    }

Cleanup:

    if ( psidAdmin )
    {
        FreeSid( psidAdmin );
    }
    if ( psidPowerUser )
    {
        FreeSid( psidPowerUser );
    }
    if ( psidLocalService )
    {
        FreeSid( psidLocalService );
    }
    if ( psidNetworkConfigOps )
    {
        FreeSid( psidNetworkConfigOps );
    }

    //  validate SD

    if ( status == NO_ERROR )
    {
        if ( psd &&
            IsValidSecurityDescriptor(psd) )
        {
            g_pAccessSecurityDescriptor = psd;
            g_pAccessAcl = pacl;
            g_pAccessOwnerSid = psidNetworkService;
            goto Unlock;
        }

        status = GetLastError();
        DNSDBG( RPC, (
            "Invalid security descriptor\n",
            status ));
        ASSERT( FALSE );
    }

    //  failed

    if ( status == NO_ERROR )
    {
        status = DNS_ERROR_NO_MEMORY;
    }
    GENERAL_HEAP_FREE( psd );
    GENERAL_HEAP_FREE( pacl );
    
    if ( psidNetworkService )
    {
        FreeSid( psidNetworkService );
    }

Unlock:

    SECURITY_UNLOCK();

    DNSDBG( INIT, (
        "Leave Rpc_InitAccessChecking() = %d\n",
        status ));

    return( status );
}



VOID
Rpc_CleanupAccessChecking(
    VOID
    )
/*++

Routine Description:

    Cleanup resolver security allocations for shutdown.

Arguments:

    None

Return Value:

    None

--*/
{
    GENERAL_HEAP_FREE( g_pAccessSecurityDescriptor );
    GENERAL_HEAP_FREE( g_pAccessAcl );

    if ( g_pAccessOwnerSid )
    {
        FreeSid( g_pAccessOwnerSid );
        g_pAccessOwnerSid = NULL;
    }

    g_pAccessSecurityDescriptor = NULL;
    g_pAccessAcl = NULL;
}



BOOL
Rpc_AccessCheck(
    IN      DWORD           DesiredAccess
    )
/*++

Routine Description:

    Access check on resolver operations.

    Note, we do NOT do this on common operations -- query.
    This is pointless and way too expensive.   We only protect 

Arguments:

    DesiredAccess -- access desired
    
Return Value:

    None

--*/
{
    DNS_STATUS  status;
    BOOL        bstatus;
    HANDLE      hthread = NULL;
    HANDLE      htoken = NULL;
    BOOL        fimpersonating = FALSE;
    DWORD       desiredAccess = DesiredAccess;

    PRIVILEGE_SET   privilegeSet;
    DWORD           grantedAccess;
    DWORD           privilegeSetLength;


    DNSDBG( RPC, (
        "Rpc_AccessCheck( priv=%08x )\n",
        DesiredAccess ));

    //
    //  create security descriptor if not created yet
    //

    if ( !g_pAccessSecurityDescriptor )
    {
        status = Rpc_InitAccessChecking();
        if ( status != NO_ERROR )
        {
            goto Failed;
        }
        DNS_ASSERT( g_pAccessSecurityDescriptor );
    }

    if ( !IsValidSecurityDescriptor( g_pAccessSecurityDescriptor ) )
    {
        status = GetLastError();
        DNSDBG( RPC, (
            "ERROR Invalid access check SD %p => %u\n",
            g_pAccessSecurityDescriptor,
            status ));
        goto Failed;
    }

    //
    //  impersonate and test access against mapping
    //

    status = RpcImpersonateClient( 0 );
    if ( status != NO_ERROR )
    {
        DNSDBG( RPC, (
            "ERROR <%u>: failed RpcImpersonateClient()\n",
             status ));
        DNS_ASSERT( FALSE );
        goto Failed;
    }
    fimpersonating = TRUE;

    //
    //  get thread token
    //

    hthread = GetCurrentThread();
    if ( !hthread )
    {
        goto Failed;
    }

    bstatus = OpenThreadToken(
                    hthread,
                    TOKEN_QUERY,
                    TRUE,
                    &htoken );
    if ( !bstatus )
    {
        status = GetLastError();
        DNSDBG( RPC, (
            "\nERROR <%lu>: failed to open thread token!\n",
             status ));
        ASSERT( FALSE );
        goto Failed;
    }

    //
    //  map generic bits
    //      - we should NOT be called with generic bits
    //      only bits for specific resolver operations
    //

    if ( (desiredAccess & SPECIFIC_RIGHTS_ALL) != desiredAccess )
    {
        DNS_ASSERT( FALSE );

        DNSDBG( RPC, (
            "desiredAccess before MapGenericMask() = %p\n",
            desiredAccess ));
    
        MapGenericMask(
            & desiredAccess,
            & g_AccessGenericMapping );
    
        DNSDBG( RPC, (
            "desiredAccess after MapGenericMask() = %p\n",
            desiredAccess ));
    }

    //
    //  do access check
    //

    privilegeSetLength = sizeof(privilegeSet);

    if ( ! AccessCheck(
                    g_pAccessSecurityDescriptor,
                    htoken,
                    desiredAccess,
                    & g_AccessGenericMapping,
                    & privilegeSet,
                    & privilegeSetLength,
                    & grantedAccess,
                    & bstatus ) )
    {
        status = GetLastError();
        DNSDBG( RPC, (
            "AccessCheck() Failed => %u\n"
            "\tsec descp        = %p\n"
            "\thtoken           = %p\n"
            "\tdesired access   = %08x\n"
            "\tgeneric mapping  = %p\n"
            "\tpriv set ptr     = %p\n"
            "\tpriv set length  = %p\n"
            "\tgranted ptr      = %p\n"
            "\tbstatus ptr      = %p\n",
            status,
            g_pAccessSecurityDescriptor,
            htoken,
            desiredAccess,
            & g_AccessGenericMapping,
            & privilegeSet,
            & privilegeSetLength,
            & grantedAccess,
            & bstatus ));

        goto Failed;
    }

    //
    //  access check successful
    //      - access is either granted or denied

    if ( bstatus )
    {
        DNSDBG( RPC, (
            "RPC Client GRANTED access (%08x) by AccessCheck\n",
            DesiredAccess ));
        goto Cleanup;
    }
    else
    {
        DNSDBG( RPC, (
            "Warning:  Client DENIED by AccessCheck\n"
            "\trequested access = %08x\n",
            desiredAccess ));
        goto Cleanup;
    }


Failed:

    //
    //  failure to do access check
    //
    //  note again:  NOT ACCESS_DENIED, but failure to be able to complete
    //  the test
    //
    //  note:  since we aren't in general protecting anything interesting,
    //  the we grant most access on failure --as admins may want the info
    //  for diagnostic purposes, the current lone exception is cluster
    //  registrations
    //
    //  privilege:
    //      - enum => allow access
    //      - flush => allow access
    //      - cluster registration => deny access
    //

    DNSDBG( ANY, (
        "ERROR:  Failed to execute RPC access check status = %d\n",
        status ));
#if 0
    //  DCR:  FIX:  can't screen REGISTER until AccessCheck() works
    bstatus = !( desiredAccess & RESOLVER_ACCESS_REGISTER );
#else
    bstatus = TRUE;
#endif


Cleanup:

    if ( htoken )
    {
        CloseHandle( htoken );
    }
    if ( hthread )
    {
        CloseHandle( hthread );
    }
    if ( fimpersonating )
    {
        RpcRevertToSelf();
    }

    return( bstatus );
}




//
//  End rpc.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\client\dnsc_wmi.cpp ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    dnsc_wmi.c

Abstract:

    WMI functions for DNSCMD

Author:

    Jeff Westhead (jwesth)      November 2000

Revision History:

--*/


#include "dnsclip.h"
#include "dnsc_wmi.h"


#define DNSCMD_CHECK_WMI_ENABLED()                          \
    if ( !g_UseWmi )                                        \
    {                                                       \
        ASSERT( g_UseWmi );                                 \
        printf( "Internal error: WMI is not enabled!\n" );  \
        return ERROR_NOT_SUPPORTED;                         \
    }

#define HRES_TO_STATUS( hres )      ( hres )

#define DNS_WMI_NAMESPACE           L"ROOT\\MicrosoftDNS"
#define DNS_WMI_RELPATH             L"__RELPATH"
#define DNS_WMI_TIMEOUT             20000               //  timeout in msecs

#define DNS_WMI_BLANK_STRING \
    L"                                                                       "

#define MYTEXT2(str)     L##str
#define MYTEXT(str)      MYTEXT2(str)


#define wmiRelease( pWmiObject )        \
    if ( pWmiObject )                   \
    {                                   \
        pWmiObject->Release();          \
        pWmiObject = NULL;              \
    }


//
//  Globals
//


IWbemServices *     g_pIWbemServices = NULL;


//
//  Static functions
//



static DNS_STATUS
getEnumerator( 
    IN      PSTR                    pszZoneName,
    OUT     IEnumWbemClassObject ** ppEnum
    )
/*++

Routine Description:

    Retrieves WMI object enumerator. The caller must call Release on
    the enum object when done.

Arguments:

    pszZoneName - zone name or NULL for server object

    ppEnum - ptr to ptr to WMI enumerator

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    WCHAR           wsz[ 1024 ];
    BSTR            bstrWQL = NULL;
    BSTR            bstrQuery = NULL;
	HRESULT         hres = 0;

    if ( pszZoneName )
    {
        status = StringCchPrintfW(
                        wsz,
                        sizeofarray( wsz ),
                        L"select * from MicrosoftDNS_Zone where Name='%S'",
                        pszZoneName );
    }
    else
    {
        status = StringCchPrintfW(
                        wsz,
                        sizeofarray( wsz ),
                        L"select * from MicrosoftDNS_Server" );
    }
    
    if ( FAILED( status ) )
    {
        return status;
    }
    
    bstrWQL = SysAllocString( L"WQL" );
    bstrQuery = SysAllocString( wsz );
    if ( !bstrWQL || !bstrQuery )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    hres = g_pIWbemServices->ExecQuery(
                bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                NULL,
                ppEnum );
    if ( FAILED( hres ) )
    {
        status = hres;
        goto Done;
    }

    Done:

    SysFreeString( bstrWQL );
    SysFreeString( bstrQuery );

    return status;
}   //  getEnumerator



static DNS_STATUS
getRelpath( 
    IN      IWbemClassObject  *     pObj,
    OUT     VARIANT *               pVar
    )
/*++

Routine Description:

    Loads a VARIANT with the WMI __RELPATH of the object.

Arguments:

    pObj - object to retrieve relpath for

    pVar - ptr to variant - caller must VariantClear() it later

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;

    if ( pObj == NULL || pVar == NULL )
    {
        status = ERROR_INVALID_PARAMETER;
    }
    else
    {
        VariantClear( pVar );
        HRESULT hres = pObj->Get( DNS_WMI_RELPATH, 0, pVar, NULL, NULL );
        status = hres;
    }
    return status;
}   //  getRelpath



static DNS_STATUS
getNextObjectInEnum( 
    IN      IEnumWbemClassObject *  pEnum,
    OUT     IWbemClassObject **     ppObj,
    IN      bool                    fPrintRelpath = TRUE
    )
/*++

Routine Description:

    Retrieves WMI object enumerator. The caller must call Release
    on the class object.

    When there are no more objects to enumerate this function will
    return a NULL pObj and ERROR_SUCCESS.

Arguments:

    pszZoneName - zone name or NULL for server object

    ppEnum - ptr to ptr to WMI enumerator

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    ULONG           returnedCount = 0;
	HRESULT         hres = 0;

    if ( !pEnum || !ppObj )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    hres = pEnum->Next(
                DNS_WMI_TIMEOUT,
                1,                  //  requested instance count
                ppObj,
                &returnedCount );
    if ( FAILED( hres ) )
    {
        status = ERROR_SUCCESS;
        *ppObj = NULL;
    }

    if ( *ppObj && fPrintRelpath )
    {
        //
        //  Print RELPATH for this object.
        //

        VARIANT var;

        status = getRelpath( *ppObj, &var );
        if ( status == ERROR_SUCCESS )
        {
            printf( "%S\n", V_BSTR( &var ) );
        }
        else
        {
            printf( "WMI error 0x%08X getting RELPATH\n", hres );
        }
        VariantClear( &var );
    }

    Done:

    return status;
}   //  getNextObjectInEnum



static SAFEARRAY *
createSafeArrayForIpList( 
    IN      DWORD               dwIpCount,
    IN      PIP_ADDRESS         pIpList
    )
/*++

Routine Description:

    Creates a SAFEARRAY of strings representing a list of IP addresses.

Arguments:

    pIpList - array of IP address DWORDs

    dwIpCount - number of elements in pIpList

Return Value:

    Safe array on success or NULL or failure.

--*/
{
    if ( !pIpList )
    {
        return NULL;
    }

    SAFEARRAYBOUND sabound = { dwIpCount, 0 };
    SAFEARRAY * psa = SafeArrayCreate( VT_BSTR, 1, &sabound );
    for ( ULONG i = 0; i < dwIpCount; ++i )
    {
        PWSTR pwsz = ( PWSTR ) Dns_NameCopyAllocate(
                                inet_ntoa(
                                    *( struct in_addr * )
                                    &pIpList[ i ] ),
                                0,
                                DnsCharSetUtf8,
                                DnsCharSetUnicode );
        BSTR bstr = SysAllocString( pwsz );
        if ( FAILED( SafeArrayPutElement(
                        psa,
                        ( PLONG ) &i,
                        bstr ) ) )
        {
            SafeArrayDestroy( psa );
            psa = NULL;
        }
        SysFreeString( bstr );
        FREE_HEAP( pwsz );
    }
    return psa;
}



static SAFEARRAY *
createSafeArrayForIpArray( 
    IN      PIP_ARRAY       pIpArray
    )
/*++

Routine Description:

    Creates a SAFEARRAY of strings representing the IP addresses
    in pIpArray. 

Arguments:

    pIpArray - IP array to create string SAFEARRAY for

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    if ( !pIpArray )
    {
        return NULL;
    }
    return createSafeArrayForIpList(
                pIpArray->AddrCount,
                pIpArray->AddrArray );
}



PWCHAR 
valueToString(
    CIMTYPE dwType,
    VARIANT *pValue,
    WCHAR **pbuf )
/*++

Routine Description:

    Convert VARIANT to string. Stole this code from WMI\Samples\VC\UtilLib.

Arguments:

    dwType - value CIMTYPE

    pValue - value to convert to string

    **pbuf - ptr to allocated string buffer - caller must free() it

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    #define BLOCKSIZE                   ( 32 * sizeof( WCHAR ) )
    #define CVTBUFSIZE                  ( 309 + 40 )
    
    DWORD iTotBufSize, iLen;
    
    WCHAR *vbuf = NULL;
    WCHAR *buf = NULL;
    
    WCHAR lbuf[BLOCKSIZE];
    
    switch (pValue->vt) 
    {
        
    case VT_EMPTY:
        buf = (WCHAR *)malloc(BLOCKSIZE);
        if ( !buf ) goto AllocFailed;
        wcscpy(buf, L"<empty>");
        break;
        
    case VT_NULL:
        buf = (WCHAR *)malloc(BLOCKSIZE);
        if ( !buf ) goto AllocFailed;
        wcscpy(buf, L"<null>");
        break;
        
    case VT_BOOL: 
        {
            VARIANT_BOOL b = pValue->boolVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            if (!b) {
                wcscpy(buf, L"FALSE");
            } else {
                wcscpy(buf, L"TRUE");
            }
            break;
        }
        
    case VT_I1: 
        {
            char b = pValue->bVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            if (b >= 32) {
                swprintf(buf, L"'%c' (%hd, 0x%hX)", b, (signed char)b, b);
            } else {
                swprintf(buf, L"%hd (0x%hX)", (signed char)b, b);
            }
            break;
        }
        
    case VT_UI1: 
        {
            unsigned char b = pValue->bVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            if (b >= 32) {
                swprintf(buf, L"'%c' (%hu, 0x%hX)", b, (unsigned char)b, b);
            } else {
                swprintf(buf, L"%hu (0x%hX)", (unsigned char)b, b);
            }
            break;
        }
        
    case VT_I2:
        {
            SHORT i = pValue->iVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            swprintf(buf, L"%hd (0x%hX)", i, i);
            break;
        }
        
    case VT_UI2:
        {
            USHORT i = pValue->uiVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            swprintf(buf, L"%hu (0x%hX)", i, i);
            break;
        }
        
    case VT_I4: 
        {
            LONG l = pValue->lVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            swprintf(buf, L"%d (0x%X)", l, l);
            break;
        }
        
    case VT_UI4: 
        {
            ULONG l = pValue->ulVal;
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            swprintf(buf, L"%u (0x%X)", l, l);
            break;
        }
        
    case VT_R4: 
        {
            float f = pValue->fltVal;
            buf = (WCHAR *)malloc(CVTBUFSIZE * sizeof(WCHAR));
            if ( !buf ) goto AllocFailed;
            swprintf(buf, L"%10.4f", f);
            break;
        }
        
    case VT_R8: 
        {
            double d = pValue->dblVal;
            buf = (WCHAR *)malloc(CVTBUFSIZE * sizeof(WCHAR));
            if ( !buf ) goto AllocFailed;
            swprintf(buf, L"%10.4f", d);
            break;
        }
        
    case VT_BSTR: 
        {
            if (dwType == CIM_SINT64)
            {
                // a little redundant, but it makes me feel better
                LPWSTR pWStr = pValue->bstrVal;
                __int64 l = _wtoi64(pWStr);
                
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                swprintf(buf, L"%I64d", l);
            } 
            else if (dwType == CIM_UINT64)
            {
                // a little redundant, but it makes me feel better
                LPWSTR pWStr = pValue->bstrVal;
                __int64 l = _wtoi64(pWStr);
                
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                swprintf(buf, L"%I64u", l);
            }
            else // string, datetime, reference
            {
                LPWSTR pWStr = pValue->bstrVal;
                buf = (WCHAR *)malloc((wcslen(pWStr) * sizeof(WCHAR)) + sizeof(WCHAR) + (2 * sizeof(WCHAR)));
                if ( !buf ) goto AllocFailed;
                swprintf(buf, L"%wS", pWStr);
            }
            break;
        }
        
    case VT_BOOL|VT_ARRAY: 
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;
            
            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0) {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"<empty array>");
                break;
            }
            
            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            wcscpy(buf, L"");
            
            for (long i = iLBound; i <= iUBound; i++) {
                if (!bFirst) {
                    wcscat(buf, L",");
                } else {
                    bFirst = FALSE;
                }
                
                VARIANT_BOOL v;
                SafeArrayGetElement(pVec, &i, &v);
                if (v) {
                    wcscat(buf, L"TRUE");
                } else {
                    wcscat(buf, L"FALSE");
                }
            }
            
            break;
        }
        
    case VT_I1|VT_ARRAY: 
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;
            
            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0) {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"<empty array>");
                break;
            }
            
            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            wcscpy(buf, L"");
            WCHAR *pos = buf;
            DWORD len;
            
            BYTE *pbstr;
            SafeArrayAccessData(pVec, (void HUGEP* FAR*)&pbstr);
            
            for (long i = iLBound; i <= iUBound; i++) {
                if (!bFirst) {
                    wcscpy(pos, L",");
                    pos += 1;
                } else {
                    bFirst = FALSE;
                }
                
                char v;
                //            SafeArrayGetElement(pVec, &i, &v);
                v = pbstr[i];
                
                if (v < 32) {
                    len = swprintf(lbuf, L"%hd (0x%X)", v, v);
                } else {
                    len = swprintf(lbuf, L"'%c' %hd (0x%X)", v, v, v);
                }
                
                wcscpy(pos, lbuf);
                pos += len;
                
            }
            
            SafeArrayUnaccessData(pVec);
            
            break;
        }
        
    case VT_UI1|VT_ARRAY: 
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;
            
            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0) {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"<empty array>");
                break;
            }
            
            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            wcscpy(buf, L"");
            WCHAR *pos = buf;
            DWORD len;
            
            BYTE *pbstr;
            SafeArrayAccessData(pVec, (void HUGEP* FAR*)&pbstr);
            
            for (long i = iLBound; i <= iUBound; i++) {
                if (!bFirst) {
                    wcscpy(pos, L",");
                    pos += 1;
                } else {
                    bFirst = FALSE;
                }
                
                unsigned char v;
                //            SafeArrayGetElement(pVec, &i, &v);
                v = pbstr[i];
                
                if (v < 32) {
                    len = swprintf(lbuf, L"%hu (0x%X)", v, v);
                } else {
                    len = swprintf(lbuf, L"'%c' %hu (0x%X)", v, v, v);
                }
                
                wcscpy(pos, lbuf);
                pos += len;
                
            }
            
            SafeArrayUnaccessData(pVec);
            
            break;
        }
        
    case VT_I2|VT_ARRAY: 
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;
            
            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0) {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"<empty array>");
                break;
            }
            
            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            wcscpy(buf, L"");
            
            for (long i = iLBound; i <= iUBound; i++) {
                if (!bFirst) {
                    wcscat(buf, L",");
                } else {
                    bFirst = FALSE;
                }
                
                SHORT v;
                SafeArrayGetElement(pVec, &i, &v);
                swprintf(lbuf, L"%hd", v);
                wcscat(buf, lbuf);
            }
            
            break;
        }
        
    case VT_UI2|VT_ARRAY: 
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;
            
            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0) {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"<empty array>");
                break;
            }
            
            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            wcscpy(buf, L"");
            
            for (long i = iLBound; i <= iUBound; i++) {
                if (!bFirst) {
                    wcscat(buf, L",");
                } else {
                    bFirst = FALSE;
                }
                
                USHORT v;
                SafeArrayGetElement(pVec, &i, &v);
                swprintf(lbuf, L"%hu", v);
                wcscat(buf, lbuf);
            }
            
            break;
        }
        
    case VT_I4|VT_ARRAY: 
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;
            
            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0) {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"<empty array>");
                break;
            }
            
            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            wcscpy(buf, L"");
            
            for (long i = iLBound; i <= iUBound; i++) {
                if (!bFirst) {
                    wcscat(buf, L",");
                } else {
                    bFirst = FALSE;
                }
                
                LONG v;
                SafeArrayGetElement(pVec, &i, &v);
                _ltow(v, lbuf, 10);
                wcscat(buf, lbuf);
            }
            
            break;
        }
        
    case VT_UI4|VT_ARRAY: 
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;
            
            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0) {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"<empty array>");
                break;
            }
            
            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            wcscpy(buf, L"");
            
            for (long i = iLBound; i <= iUBound; i++) {
                if (!bFirst) {
                    wcscat(buf, L",");
                } else {
                    bFirst = FALSE;
                }
                
                ULONG v;
                SafeArrayGetElement(pVec, &i, &v);
                _ultow(v, lbuf, 10);
                wcscat(buf, lbuf);
            }
            
            break;
        }
        
    case CIM_REAL32|VT_ARRAY: 
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;
            
            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0) {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"<empty array>");
                break;
            }
            
            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * (CVTBUFSIZE * sizeof(WCHAR)));
            if ( !buf ) goto AllocFailed;
            wcscpy(buf, L"");
            
            for (long i = iLBound; i <= iUBound; i++) {
                if (!bFirst) {
                    wcscat(buf, L",");
                } else {
                    bFirst = FALSE;
                }
                
                FLOAT v;
                SafeArrayGetElement(pVec, &i, &v);
                swprintf(lbuf, L"%10.4f", v);
                wcscat(buf, lbuf);
            }
            
            break;
        }
        
    case CIM_REAL64|VT_ARRAY: 
        {
            SAFEARRAY *pVec = pValue->parray;
            long iLBound, iUBound;
            BOOL bFirst = TRUE;
            
            SafeArrayGetLBound(pVec, 1, &iLBound);
            SafeArrayGetUBound(pVec, 1, &iUBound);
            if ((iUBound - iLBound + 1) == 0) {
                buf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"<empty array>");
                break;
            }
            
            buf = (WCHAR *)malloc((iUBound - iLBound + 1) * (CVTBUFSIZE * sizeof(WCHAR)));
            if ( !buf ) goto AllocFailed;
            wcscpy(buf, L"");
            
            for (long i = iLBound; i <= iUBound; i++) {
                if (!bFirst) {
                    wcscat(buf, L",");
                } else {
                    bFirst = FALSE;
                }
                
                double v;
                SafeArrayGetElement(pVec, &i, &v);
                swprintf(lbuf, L"%10.4f", v);
                wcscat(buf, lbuf);
            }
            
            break;
        }
        
    case VT_BSTR|VT_ARRAY: 
        {
            
            if (dwType == (CIM_UINT64|VT_ARRAY))
            {
                SAFEARRAY *pVec = pValue->parray;
                long iLBound, iUBound;
                BOOL bFirst = TRUE;
                
                SafeArrayGetLBound(pVec, 1, &iLBound);
                SafeArrayGetUBound(pVec, 1, &iUBound);
                if ((iUBound - iLBound + 1) == 0) {
                    buf = (WCHAR *)malloc(BLOCKSIZE);
                    if ( !buf ) goto AllocFailed;
                    wcscpy(buf, L"<empty array>");
                    break;
                }
                
                buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"");
                
                for (long i = iLBound; i <= iUBound; i++) {
                    if (!bFirst) {
                        wcscat(buf, L",");
                    } else {
                        bFirst = FALSE;
                    }
                    
                    BSTR v = NULL;
                    
                    SafeArrayGetElement(pVec, &i, &v);
                    
                    swprintf(lbuf, L"%I64u", _wtoi64(v));
                    wcscat(buf, lbuf);
                }
            }
            else if (dwType == (CIM_SINT64|VT_ARRAY))
            {
                SAFEARRAY *pVec = pValue->parray;
                long iLBound, iUBound;
                BOOL bFirst = TRUE;
                
                SafeArrayGetLBound(pVec, 1, &iLBound);
                SafeArrayGetUBound(pVec, 1, &iUBound);
                if ((iUBound - iLBound + 1) == 0) {
                    buf = (WCHAR *)malloc(BLOCKSIZE);
                    if ( !buf ) goto AllocFailed;
                    wcscpy(buf, L"<empty array>");
                    break;
                }
                
                buf = (WCHAR *)malloc((iUBound - iLBound + 1) * BLOCKSIZE);
                if ( !buf ) goto AllocFailed;
                wcscpy(buf, L"");
                
                for (long i = iLBound; i <= iUBound; i++) {
                    if (!bFirst) {
                        wcscat(buf, L",");
                    } else {
                        bFirst = FALSE;
                    }
                    
                    BSTR v = NULL;
                    
                    SafeArrayGetElement(pVec, &i, &v);
                    
                    swprintf(lbuf, L"%I64d", _wtoi64(v));
                    wcscat(buf, lbuf);
                }
            }
            else // string, datetime, reference
            {
                
                SAFEARRAY *pVec = pValue->parray;
                long iLBound, iUBound;
                DWORD iNeed;
                DWORD iVSize;
                DWORD iCurBufSize;
                
                SafeArrayGetLBound(pVec, 1, &iLBound);
                SafeArrayGetUBound(pVec, 1, &iUBound);
                if ((iUBound - iLBound + 1) == 0) {
                    buf = (WCHAR *)malloc(BLOCKSIZE);
                    if ( !buf ) goto AllocFailed;
                    wcscpy(buf, L"<empty array>");
                    break;
                }
                
                iTotBufSize = (iUBound - iLBound + 1) * BLOCKSIZE;
                buf = (WCHAR *)malloc(iTotBufSize);
                if ( !buf ) goto AllocFailed;
                buf[0] = L'\0';
                iCurBufSize = 0;
                iVSize = BLOCKSIZE;
                vbuf = (WCHAR *)malloc(BLOCKSIZE);
                if ( !vbuf ) goto AllocFailed;
                
                for (long i = iLBound; i <= iUBound; i++) {
                    BSTR v = NULL;
                    WCHAR * newbuf = NULL;

                    SafeArrayGetElement(pVec, &i, &v);
                    iLen = (wcslen(v) + 1) * sizeof(WCHAR);
                    if (iLen > iVSize) {
                        newbuf = (WCHAR *)realloc(vbuf, iLen + sizeof(WCHAR));
                        if ( !newbuf ) goto AllocFailed;
                        vbuf = newbuf;
                        iVSize = iLen;
                    }
                    
                    // String size + (quotes + comma + null)
                    iNeed = (swprintf(vbuf, L"%wS", v) + 4) * sizeof(WCHAR);
                    if (iNeed + iCurBufSize > iTotBufSize) {
                        iTotBufSize += (iNeed * 2);  // Room enough for 2 more entries
                        newbuf = (WCHAR *)realloc(buf, iTotBufSize);
                        if ( !newbuf ) goto AllocFailed;
                        buf = newbuf;
                    }
                    wcscat(buf, L"\"");
                    wcscat(buf, vbuf);
                    if (i + 1 <= iUBound)
                    {
                        wcscat(buf, L"\",");
                    } else
                    {
                        wcscat(buf, L"\"");
                    }
                    iCurBufSize += iNeed;
                    SysFreeString(v);
                }
            }
            
            break;
        }
      
        default: 
        {
            buf = (WCHAR *)malloc(BLOCKSIZE);
            if ( !buf ) goto AllocFailed;
            wcscpy(buf, L"<conversion error>");
            break;
        }
    }
   
   AllocFailed:

    if ( vbuf )
    {
        free( vbuf );
    }

    *pbuf = buf;   
    return buf;
}   //  valueToString


DNS_STATUS
printWmiObjectProperties(
    IWbemClassObject *      pObj
    )
{
    DNS_STATUS          status = ERROR_SUCCESS;
	HRESULT             hres = 0;
    SAFEARRAY *         pNames = NULL;
    BSTR                bstrPropName = NULL;
    VARIANT             var;
    BSTR                bstrCimType = SysAllocString( L"CIMTYPE" );
    PWSTR               pwszVal = NULL;

    if ( !bstrCimType )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    VariantClear( &var );

    //
    //  Get the RELPATH for this object.
    //

    status = getRelpath( pObj, &var );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }
    printf( "%S\n\n", V_BSTR( &var ) );

    //
    //  Enumerate all properties of this object.
    //

    hres = pObj->GetNames(
                    NULL,               //  qualifier
                    WBEM_FLAG_ALWAYS | WBEM_FLAG_NONSYSTEM_ONLY,
                    NULL,               //  qualifier value
                    &pNames );
    if ( FAILED( hres ) )
    {
        goto Done;
    }
    ASSERT( pNames );

    long lowerBound;
    long upperBound; 
    SafeArrayGetLBound( pNames, 1, &lowerBound );
    SafeArrayGetUBound( pNames, 1, &upperBound );

    for ( long i = lowerBound; i <= upperBound; ++i )
    {
        //
        //  Print the name and type of this property value.
        //

        hres = SafeArrayGetElement( pNames, &i, &bstrPropName );
        if ( !SUCCEEDED( hres ) )
        {
            ASSERT( SUCCEEDED( hres ) );
            continue;
        }

        IWbemQualifierSet * pQualSet = NULL;
        hres = pObj->GetPropertyQualifierSet( bstrPropName, &pQualSet );
        if ( !SUCCEEDED( hres ) )
        {
            ASSERT( SUCCEEDED( hres ) );
            continue;
        }

        VariantClear( &var );
        pQualSet->Get( bstrCimType, 0, &var, NULL );
        if ( !SUCCEEDED( hres ) )
        {
            ASSERT( SUCCEEDED( hres ) );
            continue;
        }

        int padlen = 30 - wcslen( bstrPropName ) - wcslen( V_BSTR( &var ) );
        printf(
            "%S (%S) %.*S = ",
            bstrPropName,
            V_BSTR( &var ),
            padlen > 0 ? padlen : 0,
            DNS_WMI_BLANK_STRING );

        //
        //  Print the property value.
        //

        VariantClear( &var );
        CIMTYPE cimType = 0;
        hres = pObj->Get( bstrPropName, 0, &var, &cimType, NULL );
        if ( !SUCCEEDED( hres ) )
        {
            ASSERT( SUCCEEDED( hres ) );
            continue;
        }

        printf( "%S\n", valueToString( cimType, &var, &pwszVal ) );
        free( pwszVal );
        pwszVal = NULL;
    }

    Done:

    free( pwszVal );
    SysFreeString( bstrCimType );
    SafeArrayDestroy( pNames );

    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = HRES_TO_STATUS( hres );
    }

    return status;
}   //  printWmiObjectProperties


//
//  External functions
//



DNS_STATUS
DnscmdWmi_Initialize(
    IN      PWSTR       pwszServerName
    )
/*++

Routine Description:

    Setup mod buffer for max count of items.

Arguments:

    pwszServerName -- IP address or name of target server

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    static const char * fn = "DnscmdWmi_Initialize";

    DNS_STATUS          status = ERROR_SUCCESS;
	HRESULT             hres = 0;
	IWbemLocator *      pIWbemLocator = NULL;
    BSTR                bstrNamespace = NULL;
    IWbemServices *     pIWbemServices = NULL;
    WCHAR               wsz[ 1024 ];

    DNSCMD_CHECK_WMI_ENABLED();

    //
    //  Initialize COM.
    //

    if ( FAILED( hres = CoInitialize( NULL ) ) )
    {
        printf( "%s: CoInitialize returned 0x%08X\n", fn, hres );
        goto Done;
    }

    //
    //  Initialize security.
    //

    hres = CoInitializeSecurity(
                NULL,                   //  permissions
                -1,                     //  auth service count
                NULL,                   //  auth services
                NULL,                   //  reserved
                RPC_C_AUTHZ_NONE,
                RPC_C_IMP_LEVEL_IMPERSONATE,
                NULL,                   //  auth list
                0,                      //  capabilities
                0 );                    //  reserved
    if ( FAILED( hres ) )
    {
        printf(
            "%s: CoInitializeSecurity() returned 0x%08X\n",
            fn,
            hres );
        goto Done;
    }

    //
    //  Create instance of WbemLocator interface.
    //

    hres = CoCreateInstance(
                    CLSID_WbemLocator,
                    NULL,
                    CLSCTX_INPROC_SERVER,
                    IID_IWbemLocator,
                    ( LPVOID * ) &pIWbemLocator );
    if ( FAILED( hres ) )
    {
        printf(
            "%s: CoCreateInstance( CLSID_WbemLocator ) returned 0x%08X\n",
            fn,
            hres );
        goto Done;
    }

    //
    //  Connect to MicrosoftDNS namespace on server.
    //

    wsprintfW(
        wsz,
        L"\\\\%s\\%s",
        pwszServerName,
        DNS_WMI_NAMESPACE );
    bstrNamespace = SysAllocString( wsz );
    if ( !bstrNamespace )
    {
        ASSERT( bstrNamespace );
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
        
    hres = pIWbemLocator->ConnectServer(
                                bstrNamespace,
                                NULL,               //  user id
                                NULL,               //  password
                                NULL,               //  locale
                                0,                  //  security flags
                                NULL,               //  domain
                                NULL,               //  context
                                &pIWbemServices );
    if ( FAILED( hres ) )
    {
        printf(
            "%s: ConnectServer( %S ) returned 0x%08X\n",
            fn,
            DNS_WMI_NAMESPACE,
            hres );
        goto Done;
    }

    if ( !pIWbemServices )
    {
        ASSERT( pIWbemServices );
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  Set security.
    //

    hres = CoSetProxyBlanket(
                pIWbemServices,
                RPC_C_AUTHN_WINNT,
                RPC_C_AUTHZ_NONE,
                NULL,                           //  principal name
                RPC_C_AUTHN_LEVEL_CALL,
                RPC_C_IMP_LEVEL_IMPERSONATE,
                NULL,                           //  client identify
                EOAC_NONE );
    if ( FAILED( hres ) )
    {
        printf(
            "%s: CoSetProxyBlanket() returned 0x%08X\n",
            fn,
            hres );
        goto Done;
    }

    //
    //  Cleanup and return.
    //

    Done:
    
    SysFreeString( bstrNamespace );

    if ( pIWbemLocator )
    {
        pIWbemLocator->Release();
    }

    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = HRES_TO_STATUS( hres );
    }

    if ( status == ERROR_SUCCESS )
    {
        g_pIWbemServices = pIWbemServices;
    }

    return status;
}   //  DnscmdWmi_Initialize



DNS_STATUS
DnscmdWmi_Free(
    VOID
    )
/*++

Routine Description:

    Close WMI session and free globals.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DBG_FN( "DnscmdWmi_Free" )

    DNSCMD_CHECK_WMI_ENABLED();

    if ( g_pIWbemServices )
    {
        g_pIWbemServices->Release();
        g_pIWbemServices = NULL;
    }

    CoUninitialize();

    return ERROR_SUCCESS;
}   //  DnscmdWmi_Free



DNS_STATUS
DnscmdWmi_ProcessDnssrvQuery(
    IN      PSTR        pszZoneName,
    IN      PCSTR       pszQuery
    )
/*++

Routine Description:

    Perform query.

Arguments:

    pszZoneName -- zone name or NULL for server level query

    pszQuery -- query name

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS              status = ERROR_SUCCESS;
    BSTR                    bstrClassName = NULL;
    IEnumWbemClassObject *  pEnum = NULL;
    IWbemClassObject *      pObj = NULL;
    ULONG                   returnedCount = 1;

    DNSCMD_CHECK_WMI_ENABLED();

    //
    //  Get WMI object.
    //

    status = getEnumerator( pszZoneName, &pEnum );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    status = getNextObjectInEnum( pEnum, &pObj );
    if ( status != ERROR_SUCCESS || !pObj )
    {
        goto Done;
    }

    printWmiObjectProperties( pObj );

    //
    //  Cleanup and return.
    //

    Done:

    SysFreeString( bstrClassName );

    if ( pObj )
    {
        pObj->Release();
    }

    if ( pEnum )
    {
        pEnum->Release();
    }
    
    return status;
}   //  DnscmdWmi_ProcessDnssrvQuery



DNS_STATUS
DnscmdWmi_ProcessEnumZones(
    IN      DWORD                   dwFilter
    )
/*++

Routine Description:

    Enumerate zones.

Arguments:

    dwFilter -- filter

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS              status = ERROR_SUCCESS;
    BSTR                    bstrClassName = NULL;
    IEnumWbemClassObject *  pEnum = NULL;
    IWbemClassObject *      pObj = NULL;
    HRESULT                 hres = 0;
    ULONG                   returnedCount = 1;

    DNSCMD_CHECK_WMI_ENABLED();

    //
    //  Create zone enumerator.
    //

    bstrClassName = SysAllocString( L"MicrosoftDNS_Zone" );
    if ( !bstrClassName )
    {
        ASSERT( bstrClassName );
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    hres = g_pIWbemServices->CreateInstanceEnum(
                                bstrClassName,
                                0,                  //  flags
                                NULL,               //  context
                                &pEnum );
    if ( FAILED( hres ) )
    {
        goto Done;
    }
    ASSERT( pEnum );

    //
    //  Enumerate zones.
    //

    while ( returnedCount == 1 )
    {
        VARIANT             val;
        CIMTYPE             cimtype = 0;
        PWSTR               pwszVal = NULL;

        VariantInit( &val );

        status = getNextObjectInEnum( pEnum, &pObj, FALSE );
        if ( status != ERROR_SUCCESS || !pObj )
        {
            goto Done;
        }

        //
        //  Print properties for this zone.
        //

        #define CHECK_HRES( hresult, propname )                             \
        if ( FAILED( hresult ) )                                            \
            {                                                               \
            printf( "\n\nWMI error 0x%08X reading property %S!\n",          \
                    hresult, propname );                                    \
            goto Done;                                                      \
            }

        hres = pObj->Get( L"Name", 0, &val, &cimtype, NULL );
        CHECK_HRES( hres, L"Name" );
        printf( " %-29S", valueToString( cimtype, &val, &pwszVal ) );
        free( pwszVal );
        VariantClear( &val );

        hres = pObj->Get( L"ZoneType", 0, &val, &cimtype, NULL );
        CHECK_HRES( hres, L"ZoneType" );
        ASSERT( val.vt == VT_I4 );
        printf( "%3d  ", val.lVal );
        VariantClear( &val );

        hres = pObj->Get( L"DsIntegrated", 0, &val, &cimtype, NULL );
        CHECK_HRES( hres, L"DsIntegrated" );
        ASSERT( val.vt == VT_BOOL );
        printf( "%-4S  ", val.boolVal ? L"DS" : L"file" );
        VariantClear( &val );

        hres = pObj->Get( L"Reverse", 0, &val, &cimtype, NULL );
        CHECK_HRES( hres, L"Reverse" );
        ASSERT( val.vt == VT_BOOL );
        printf( "%-3S  ", val.boolVal ? L"Rev" : L"" );
        VariantClear( &val );

        hres = pObj->Get( L"AutoCreated", 0, &val, &cimtype, NULL );
        CHECK_HRES( hres, L"AutoCreated" );
        ASSERT( val.vt == VT_BOOL );
        printf( "%-4S  ", val.boolVal ? L"Auto" : L"" );
        VariantClear( &val );

        hres = pObj->Get( L"AllowUpdate", 0, &val, &cimtype, NULL );
        CHECK_HRES( hres, L"AllowUpdate" );
        ASSERT( val.vt == VT_BOOL );
        printf( "Up=%d ", val.boolVal ? 1 : 0 );
        VariantClear( &val );

        hres = pObj->Get( L"Aging", 0, &val, &cimtype, NULL );
        CHECK_HRES( hres, L"Aging" );
        ASSERT( val.vt == VT_BOOL );
        printf( "%-5S ", val.boolVal ? L"Aging" : L"" );
        VariantClear( &val );

        hres = pObj->Get( L"Paused", 0, &val, &cimtype, NULL );
        CHECK_HRES( hres, L"Paused" );
        ASSERT( val.vt == VT_BOOL );
        printf( "%-6S ", val.boolVal ? L"Paused" : L"" );
        VariantClear( &val );

        hres = pObj->Get( L"Shutdown", 0, &val, &cimtype, NULL );
        CHECK_HRES( hres, L"Shutdown" );
        ASSERT( val.vt == VT_BOOL );
        printf( "%-6S", val.boolVal ? L"Shutdn" : L"" );
        VariantClear( &val );

        printf( "\n\n" );
    }

    //
    //  Cleanup and return.
    //

    Done:

    SysFreeString( bstrClassName );

    if ( pObj )
    {
        pObj->Release();
    }

    if ( pEnum )
    {
        pEnum->Release();
    }
    
    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = HRES_TO_STATUS( hres );
    }

    return status;
}   //  DnscmdWmi_ProcessEnumZones



DNS_STATUS
DnscmdWmi_ProcessZoneInfo(
    IN      LPSTR                   pszZone
    )
/*++

Routine Description:

    Enumerate zones.

Arguments:

    dwFilter -- filter

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS              status = ERROR_SUCCESS;
    IWbemClassObject *      pObj = NULL;
    IEnumWbemClassObject *  pEnum = NULL;
    ULONG                   returnedCount = 1;
    WCHAR                   wsz[ 1024 ];

    DNSCMD_CHECK_WMI_ENABLED();

    //
    //  Get WMI object.
    //

    status = getEnumerator( pszZone, &pEnum );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    status = getNextObjectInEnum( pEnum, &pObj, FALSE );
    if ( status != ERROR_SUCCESS || !pObj )
    {
        goto Done;
    }

    printWmiObjectProperties( pObj );

    //
    //  Cleanup and return.
    //

    Done:

    if ( pObj )
    {
        pObj->Release();
    }

    if ( pEnum )
    {
        pEnum->Release();
    }
    
    return status;
}   //  DnscmdWmi_ProcessZoneInfo



DNS_STATUS
DnscmdWmi_ProcessEnumRecords(
    IN      LPSTR                   pszZone,
    IN      LPSTR                   pszNode,
    IN      BOOL                    fDetail,
    IN      DWORD                   dwFlags
    )
/*++

Routine Description:

    Enumerate Records.

Arguments:

    pszZone -- zone name

    pszNode -- name of root node to at which to enumerate records

    fDetail -- print summary or full detail

    dwFlags -- search flags

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS              status = ERROR_SUCCESS;
    BSTR                    bstrWQL = NULL;
    BSTR                    bstrQuery = NULL;
    IWbemClassObject *      pObj = NULL;
    IEnumWbemClassObject *  pEnum = NULL;
    HRESULT                 hres = 0;
    ULONG                   returnedCount = 1;
    WCHAR                   wsz[ 1024 ];

    DNSCMD_CHECK_WMI_ENABLED();

    //
    //  Query for zone.
    //

    if ( pszNode == NULL || strcmp( pszNode, "@" ) == 0 )
    {
        wsprintfW(
            wsz, 
            L"select * from MicrosoftDNS_ResourceRecord "
                L"where ContainerName='%S'",
            pszZone );
    }
    else
    {
        wsprintfW(
            wsz, 
            L"select * from MicrosoftDNS_ResourceRecord "
                L"where DomainName='%S'",
            pszNode );
    }
    bstrWQL = SysAllocString( L"WQL" );
    bstrQuery = SysAllocString( wsz );
    if ( !bstrWQL || !bstrQuery )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    hres = g_pIWbemServices->ExecQuery(
                bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                NULL,
                &pEnum );
    if ( FAILED( hres ) )
    {
        goto Done;
    }
    ASSERT( pEnum );

    //
    //  Dump results.
    //

    while ( 1 )
    {
        status = getNextObjectInEnum( pEnum, &pObj );
        if ( status != ERROR_SUCCESS || !pObj )
        {
            break;
        }

        if ( fDetail )
        {
            printWmiObjectProperties( pObj );
        }
        else
        {
            VARIANT             val;
            CIMTYPE             cimtype = 0;
            PWSTR               pwszVal = NULL;

            VariantInit( &val );
            hres = pObj->Get( L"TextRepresentation", 0, &val, &cimtype, NULL );
            CHECK_HRES( hres, L"TextRepresentation" );
            printf( "%S", valueToString( cimtype, &val, &pwszVal ) );
            free( pwszVal );
            VariantClear( &val );

            printf( "\n" );
        }
    }

    //
    //  Cleanup and return.
    //

    Done:

    SysFreeString( bstrWQL );
    SysFreeString( bstrQuery );

    if ( pObj )
    {
        pObj->Release();
    }

    if ( pEnum )
    {
        pEnum->Release();
    }
    
    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = HRES_TO_STATUS( hres );
    }

    return status;
}   //  DnscmdWmi_ProcessEnumRecords



DNS_STATUS
DnscmdWmi_ResetProperty(
    IN      LPSTR                   pszZone,
    IN      LPSTR                   pszProperty,
    IN      DWORD                   cimType,
    IN      PVOID                   value
    )
/*++

Routine Description:

    Reset a server or zone property.

Arguments:

    pszZone -- zone name - NULL for server property

    pszProperty -- name of property to set

    cimType -- variant type of the property, use one of:
        VT_I4 - DWORD
        VT_BSTR - string
        ? - IP list

    value -- new value for property, interpreted based on cimtype:
        VT_I4 - cast pointer directly DWORD
        VT_BSTR - pointer to UTF-8 string
        ? - pointer to IP list

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS              status = ERROR_SUCCESS;
    BSTR                    bstrWQL = NULL;
    BSTR                    bstrQuery = NULL;
    BSTR                    bstrPropName = NULL;
    IWbemClassObject *      pObj = NULL;
    IEnumWbemClassObject *  pEnum = NULL;
    HRESULT                 hres = 0;
    ULONG                   returnedCount = 1;
    WCHAR                   wsz[ 1024 ];
    PWSTR                   pwszPropertyName = NULL;
    PWSTR                   pwszPropertyValue = NULL;

    DNSCMD_CHECK_WMI_ENABLED();

    //
    //  Get WMI object.
    //

    status = getEnumerator( pszZone, &pEnum );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    status = getNextObjectInEnum( pEnum, &pObj );
    if ( status != ERROR_SUCCESS || !pObj )
    {
        goto Done;
    }

    //
    //  Print the object's RELPATH (warm fuzzy).
    //

    VARIANT var;

    status = getRelpath( pObj, &var );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }
    printf( "%S\n\n", V_BSTR( &var) );

    //
    //  Set the property.
    //

    pwszPropertyName = ( PWSTR ) Dns_NameCopyAllocate(
                                        pszProperty,
                                        0,
                                        DnsCharSetUtf8,
                                        DnsCharSetUnicode );
    bstrPropName = SysAllocString( pwszPropertyName );

    VariantClear( &var );

    switch ( cimType )
    {
        case VT_BSTR:
            pwszPropertyValue = ( PWSTR ) Dns_NameCopyAllocate(
                                                ( PCHAR ) value,
                                                0,
                                                DnsCharSetUtf8,
                                                DnsCharSetUnicode );
            V_VT( &var ) = VT_BSTR;
            V_BSTR( &var ) = pwszPropertyValue;
            break;

        case PRIVATE_VT_IPARRAY:
        {
            SAFEARRAY * psa = createSafeArrayForIpArray(
                                    ( PIP_ARRAY ) value );
            V_VT( &var ) = VT_ARRAY | VT_BSTR;
            V_ARRAY( &var ) = psa;
            break;
        }

        default:        //  Assume this is DWORD property.
            V_VT( &var ) = VT_I4;
            V_I4( &var ) = ( DWORD ) ( DWORD_PTR ) value;
            break;
    }

    hres = pObj->Put( bstrPropName, 0, &var, 0 );
    VariantClear( &var );
    if ( !SUCCEEDED( hres ) )
    {
        printf( "WMI: unable to Put property error=0x%08X\n", hres );
        goto Done;
    }

    //
    //  Commit the change back to WMI.
    //

    hres = g_pIWbemServices->PutInstance( pObj, 0, NULL, NULL );
    if ( !SUCCEEDED( hres ) )
    {
        printf( "WMI: unable to commit property error=0x%08X\n", hres );
        goto Done;
    }
    
    //
    //  Cleanup and return.
    //

    Done:

    FREE_HEAP( pwszPropertyName );
    FREE_HEAP( pwszPropertyValue );
    SysFreeString( bstrPropName );

    if ( pObj )
    {
        pObj->Release();
    }

    if ( pEnum )
    {
        pEnum->Release();
    }
    
    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = HRES_TO_STATUS( hres );
    }

    return status;
}   //  DnscmdWmi_ResetDwordProperty



/*++

Routine Description:

    Reset server level forwarders.

Arguments:

    cForwarders -- number of forwarder IP addresses

    aipForwarders -- array of forwarder IP addresses

    dwForwardTimeout -- timeout

    fSlave -- slave flag

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
DNS_STATUS
DnscmdWmi_ProcessResetForwarders(
    IN      DWORD               cForwarders,
    IN      PIP_ADDRESS         aipForwarders,
    IN      DWORD               dwForwardTimeout,
    IN      DWORD               fSlave
    )
{
    DNS_STATUS              status = ERROR_SUCCESS;
    IEnumWbemClassObject *  pEnum = NULL;
    IWbemClassObject *      pObj = NULL;
    SAFEARRAY *             psa = NULL;
    HRESULT                 hres = 0;
    VARIANT                 var;

    VariantInit( &var );

    //
    //  Get WMI object for server.
    //

    status = getEnumerator( NULL, &pEnum );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    status = getNextObjectInEnum( pEnum, &pObj );
    if ( status != ERROR_SUCCESS || !pObj )
    {
        goto Done;
    }

    //
    //  Set up parameters.
    //

    psa = createSafeArrayForIpList( cForwarders, aipForwarders );
    if ( !psa )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }
    V_VT( &var ) = VT_ARRAY | VT_BSTR;
    V_ARRAY( &var ) = psa;
    hres = pObj->Put( MYTEXT( DNS_REGKEY_FORWARDERS ), 0, &var, 0 );
    VariantClear( &var );
    if ( !SUCCEEDED( hres ) )
    {
        printf(
            "WMI: unable to Put property %S error=0x%08X\n",
            MYTEXT( DNS_REGKEY_FORWARDERS ),
            hres );
        goto Done;
    }

    V_VT( &var ) = VT_I4;
    V_I4( &var ) = dwForwardTimeout;
    hres = pObj->Put( MYTEXT( DNS_REGKEY_FORWARD_TIMEOUT ), 0, &var, 0 );
    VariantClear( &var );
    if ( !SUCCEEDED( hres ) )
    {
        printf(
            "WMI: unable to Put property %S error=0x%08X\n",
            MYTEXT( DNS_REGKEY_FORWARD_TIMEOUT ),
            hres );
        goto Done;
    }

    V_VT( &var ) = VT_BOOL;
    V_BOOL( &var ) = ( VARIANT_BOOL ) fSlave;
    hres = pObj->Put( MYTEXT( DNS_REGKEY_SLAVE ), 0, &var, 0 );
    VariantClear( &var );
    if ( !SUCCEEDED( hres ) )
    {
        printf(
            "WMI: unable to Put property %S error=0x%08X\n",
            MYTEXT( DNS_REGKEY_SLAVE ),
            hres );
        goto Done;
    }

    //
    //  Commit the change back to WMI.
    //

    hres = g_pIWbemServices->PutInstance( pObj, 0, NULL, NULL );
    if ( !SUCCEEDED( hres ) )
    {
        printf( "WMI: unable to commit property error=0x%08X\n", hres );
        goto Done;
    }
    
    //
    //  Cleanup and return.
    //

    Done:

    if ( pObj )
    {
        pObj->Release();
    }
    if ( pEnum )
    {
        pEnum->Release();
    }
    VariantClear( &var );

    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = hres;
    }

    return status;
}



/*++

Routine Description:

    Send generic operation to server.

Arguments:

    pszZone -- zone name or NULL for server level operation

    pszOperation -- string identifying operation

    dwTypeId -- DNS RPC data type of data at pvData

    pvData -- DNS RPC data in DNS RPC union format

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
DNS_STATUS
DnscmdWmi_ProcessDnssrvOperation(
    IN      LPSTR               pszZoneName,
    IN      LPSTR               pszOperation,
    IN      DWORD               dwTypeId,
    IN      PVOID               pvData
    )
{
    DNS_STATUS              status = ERROR_SUCCESS;
    HRESULT                 hres = 0;
    IEnumWbemClassObject *  pEnum = NULL;
    IWbemClassObject *      pObj = NULL;
    SAFEARRAY *             psa = NULL;
    PWSTR                   pwszOperation = NULL;
    VARIANT                 var;

    VariantInit( &var );

    //
    //  Get WMI object.
    //

    status = getEnumerator( pszZoneName, &pEnum );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    status = getNextObjectInEnum( pEnum, &pObj );
    if ( status != ERROR_SUCCESS || !pObj )
    {
        goto Done;
    }

    //
    //  Process operation.
    //

    pwszOperation = ( PWSTR ) Dns_NameCopyAllocate(
                                    pszOperation,
                                    0,
                                    DnsCharSetUtf8,
                                    DnsCharSetUnicode );
    if ( !pwszOperation )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    if ( _stricmp( pszOperation, DNS_REGKEY_ZONE_MASTERS ) == 0 ||
        _stricmp( pszOperation, DNS_REGKEY_ZONE_LOCAL_MASTERS ) == 0 )
    {
        //
        //  For these properties do a simple Put operation by converting
        //  the DNS RPC data into VARIANT format and calling Put.
        //

        switch ( dwTypeId )
        {
            case DNSSRV_TYPEID_IPARRAY:
            {
                PIP_ARRAY       pip = ( PIP_ARRAY ) pvData;

                psa = createSafeArrayForIpList(
                            pip ? pip->AddrCount : 0,
                            pip ? pip->AddrArray : NULL );
                if ( !psa )
                {
                    status = ERROR_INVALID_PARAMETER;
                    goto Done;
                }
                V_VT( &var ) = VT_ARRAY | VT_BSTR;
                V_ARRAY( &var ) = psa;
                hres = pObj->Put( pwszOperation, 0, &var, 0 );
                break;
            }

            default:
                status = ERROR_NOT_SUPPORTED;
                break;
        }

        //
        //  Commit the Put operation.
        //

        if ( status == ERROR_SUCCESS && SUCCEEDED( hres ) )
        {
            hres = g_pIWbemServices->PutInstance( pObj, 0, NULL, NULL );
            if ( FAILED( hres ) )
            {
                printf(
                    "WMI: unable to commit property %s error=0x%08X\n",
                        pszOperation,
                        hres );
                goto Done;
            }
        }
    }
    else if ( _stricmp( pszOperation, DNSSRV_OP_ZONE_DELETE ) == 0 ||
        _stricmp( pszOperation, DNSSRV_OP_ZONE_DELETE_FROM_DS ) == 0 )
    {
        //
        //  Delete the zone.
        //

        VARIANT     relpath;

        status = getRelpath( pObj, &relpath );
        if ( status == ERROR_SUCCESS )
        {
            hres = g_pIWbemServices->DeleteInstance(
                                        V_BSTR( &relpath ),
                                        0,
                                        NULL,
                                        NULL );
        }
        VariantClear( &relpath );
    }
    else
    {
        status = ERROR_NOT_SUPPORTED;
    }

    //
    //  Cleanup and return.
    //

    Done:

    if ( psa )
    {
        SafeArrayDestroy( psa );
    }
    if ( pwszOperation )
    {
        FREE_HEAP( pwszOperation );
    }
    if ( pObj )
    {
        pObj->Release();
    }
    if ( pEnum )
    {
        pEnum->Release();
    }
    VariantClear( &var );

    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = hres;
    }

    return status;
}   //  DnscmdWmi_ProcessDnssrvOperation



DNS_STATUS
DnscmdWmi_ProcessRecordAdd(
    IN      LPSTR               pszZoneName,
    IN      LPSTR               pszNodeName,
    IN      PDNS_RPC_RECORD     prrRpc,
    IN      DWORD               Argc,
    IN      LPSTR *             Argv
    )
/*++

Routine Description:

    Add or delete a resource record. This function will take
    of the necessary some data from the RPC record and some from 
    the argument list.

Arguments:

    pszZoneName -- zone name

    pszNodeName -- name of property to set

    prrRpc -- RPC record

    Argc -- count of arguments used to create RPC record

    Argv -- arguments used to create RPC record

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS              status = ERROR_SUCCESS;
    PWSTR                   pwszZoneName = NULL;
    PWSTR                   pwszArgs = NULL;
    PWSTR                   pwszCurrent;
    IWbemClassObject *      pClassObj = NULL;
    IWbemClassObject *      pServerObj = NULL;
    IWbemClassObject *      pInSig = NULL;
    IWbemClassObject *      pOutSig = NULL;
    IWbemClassObject *      pInParams = NULL;
    IEnumWbemClassObject *  pEnum = NULL;
    HRESULT                 hres = 0;
    BSTR                    bstrClassName;
    BSTR                    bstrMethodName;
    VARIANT                 var;
    int                     len;
    int                     i;
    
    DNSCMD_CHECK_WMI_ENABLED();

    //
    //  Allocate and initialize various stuff.
    //

    VariantInit( &var );

    bstrClassName = SysAllocString( L"MicrosoftDNS_ResourceRecord" );
    bstrMethodName = SysAllocString( L"CreateInstanceFromTextRepresentation" );
    if ( !bstrClassName || !bstrMethodName )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    pwszZoneName = ( PWSTR ) Dns_NameCopyAllocate(
                                    pszZoneName,
                                    0,
                                    DnsCharSetUtf8,
                                    DnsCharSetUnicode );
    if ( !pwszZoneName )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  Get WMI class object for Resource Record class.
    //

    hres = g_pIWbemServices->GetObject(
                bstrClassName,
                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                NULL,
                &pClassObj,
                NULL );
    if ( FAILED( hres ) )
    {
        goto Done;
    }
    ASSERT( pClassObj );

    //
    //  Get WMI object for server.
    //

    status = getEnumerator( NULL, &pEnum );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }
    ASSERT( pEnum );

    status = getNextObjectInEnum( pEnum, &pServerObj );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }
    ASSERT( pServerObj );

    //
    //  Get WMI method signature for CreateInstanceFromTextRepresentation.
    //

    hres = pClassObj->GetMethod(
                bstrMethodName,
                0,
                &pInSig,
                &pOutSig );
    if ( FAILED( hres ) )
    {
        goto Done;
    }
    if ( pInSig == NULL )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    //
    //  Create an instance of the method input parameters.
    //

    hres = pInSig->SpawnInstance( 0, &pInParams );
    if ( FAILED( hres ) )
    {
        goto Done;
    }
    ASSERT( pInParams );

    //
    //  Collect the arguments into one big string
    //      ->  owner name
    //      ->  record class
    //      ->  record type
    //      ->  Argv array (space separated)
    //

    len = Argc * 2 +                //  for spaces
            30 +                    //  for record type
            strlen( pszNodeName );
    for ( i = 0; i < ( int ) Argc; ++i )
    {
        len += strlen( Argv[ i ] );
    }
    pwszCurrent = pwszArgs = new WCHAR [ len * sizeof( WCHAR ) ];
    if ( !pwszArgs )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    for ( i = -3; i < ( int ) Argc; ++i )
    {
        CHAR szBuff[ 40 ];
        PSTR psz;
        if ( i == -3 )
        {
            psz = pszNodeName;
        }
        else if ( i == -2 )
        {
            psz = "IN";
        }
        else if ( i == -1 )
        {
            psz = Dns_RecordStringForType( prrRpc->wType );
        }
        else
        {
            psz = Argv[ i ];
        }

        PWSTR pwsz = ( PWSTR ) Dns_NameCopyAllocate(
                                        psz,
                                        0,
                                        DnsCharSetUtf8,
                                        DnsCharSetUnicode );
        if ( !pwsz )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }

        if ( pwszCurrent != pwszArgs )
        {
            wcscpy( pwszCurrent++, L" " );
        }
        wcscpy( pwszCurrent, pwsz );
        pwszCurrent += wcslen( pwsz );
    }

    //
    //  Set method input parameters.
    //

    getRelpath( pServerObj, &var );
    hres = pInParams->Put( L"DnsServerName", 0, &var, 0 );
    VariantClear( &var );

    V_VT( &var ) = VT_BSTR;
    V_BSTR( &var ) = SysAllocString( pwszZoneName );
    hres = pInParams->Put( L"ContainerName", 0, &var, 0 );
    VariantClear( &var );

    V_VT( &var ) = VT_BSTR;
    V_BSTR( &var ) = SysAllocString( pwszArgs );
    hres = pInParams->Put( L"TextRepresentation", 0, &var, 0 );
    VariantClear( &var );

    //
    //  Execute the method (finally!)
    //

    hres = g_pIWbemServices->ExecMethod(
                bstrClassName,
                bstrMethodName,
                0,                      //  flags
                NULL,                   //  context
                pInParams,              //  input params
                NULL,                   //  output params
                NULL );                 //  call result
    if ( FAILED( hres ) )
    {
        goto Done;
    }

    //
    //  Cleanup and return.
    //

    Done:

    VariantClear( &var );
    FREE_HEAP( pwszZoneName );
    delete [] pwszArgs;
    SysFreeString( bstrMethodName );
    SysFreeString( bstrClassName );
    wmiRelease( pEnum );
    wmiRelease( pClassObj );
    wmiRelease( pServerObj );
    wmiRelease( pInSig );
    wmiRelease( pOutSig );
    wmiRelease( pInParams );

    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = HRES_TO_STATUS( hres );
    }
    return status;
}   //  DnscmdWmi_ProcessRecordAdd



DNS_STATUS
DnscmdWmi_GetStatistics(
    IN      DWORD               dwStatId
    )
/*++

Routine Description:

    Retrieves and dumps all statistics matching the dwStatId mask.

Arguments:

    dwStatId -- statistic filter

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS                  status = ERROR_SUCCESS;
    WCHAR                       wsz[ 1024 ];
    BSTR                        bstrWQL = NULL;
    BSTR                        bstrQuery = NULL;
	HRESULT                     hres = 0;
    IEnumWbemClassObject *      pEnum = NULL;
    IWbemClassObject *          pObj = NULL;

    //
    //  Execute query for statistics.
    //

    wsprintfW(
        wsz, 
        L"select * from MicrosoftDNS_Statistic" );

    bstrWQL = SysAllocString( L"WQL" );
    bstrQuery = SysAllocString( wsz );
    if ( !bstrWQL || !bstrQuery )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    hres = g_pIWbemServices->ExecQuery(
                bstrWQL,
                bstrQuery,
                WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY,
                NULL,
                &pEnum );
    if ( FAILED( hres ) )
    {
        status = hres;
        goto Done;
    }

    //
    //  Dump query results.
    //

    VARIANT varLastColl;
    VariantInit( &varLastColl );

    while ( 1 )
    {
        status = getNextObjectInEnum( pEnum, &pObj, FALSE );
        if ( status != ERROR_SUCCESS || !pObj )
        {
            break;
        }

        CIMTYPE cimColl = 0;
        CIMTYPE cimName = 0;
        CIMTYPE cimValue = 0;
        CIMTYPE cimStringValue = 0;

        VARIANT varColl;
        VARIANT varName;
        VARIANT varValue;
        VARIANT varStringValue;
        VariantInit( &varColl );
        VariantInit( &varName );
        VariantInit( &varValue );
        VariantInit( &varStringValue );

        hres = pObj->Get( L"CollectionName", 0, &varColl, &cimColl, NULL );
        CHECK_HRES( hres, L"CollectionName" );
        hres = pObj->Get( L"Name", 0, &varName, &cimName, NULL );
        CHECK_HRES( hres, L"Name" );
        hres = pObj->Get( L"Value", 0, &varValue, &cimValue, NULL );
        CHECK_HRES( hres, L"Value" );
        hres = pObj->Get( L"StringValue", 0, &varStringValue, &cimValue, NULL );
        CHECK_HRES( hres, L"StringValue" );

        if ( V_VT( &varLastColl ) == VT_EMPTY ||
            wcscmp( V_BSTR( &varLastColl ), V_BSTR( &varColl ) ) != 0 )
        {
            //
            //  Entering new collection. NOTE: this assumes that stats
            //  are ordered by collection. Probably not a great assumption
            //  but it works for now.
            //

            printf( "\n%S:\n", V_BSTR( &varColl ) );
            hres = VariantCopy( &varLastColl, &varColl );
            if ( FAILED( hres ) )
            {
                goto Done;
            }
        }

        printf(
            "  %-35S = ",
            V_BSTR( &varName ) );

        if ( V_VT( &varValue ) != VT_NULL )
        {
            printf( "%lu", V_UI4( &varValue ) );
            //  printf( "%lu  (0x%08X)", V_UI4( &varValue ), V_UI4( &varValue ) );
        }
        else if ( V_VT( &varStringValue ) == VT_BSTR )
        {
            printf( "%S", V_BSTR( &varStringValue ) );
        }
        else
        {
            printf( "invalid value!" );
        }
        printf( "\n" );

        VariantClear( &varColl );
        VariantClear( &varName );
        VariantClear( &varValue );
        VariantClear( &varStringValue );
    }
    VariantClear( &varLastColl );

    //
    //  Cleanup and return
    //

    Done:

    SysFreeString( bstrWQL );
    SysFreeString( bstrQuery );
    if ( pEnum )
    {
        pEnum->Release();
    }
    if ( pObj )
    {
        pObj->Release();
    }

    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = HRES_TO_STATUS( hres );
    }
    return status;
}



DNS_STATUS
DnscmdWmi_ProcessResetZoneSecondaries(
    IN      LPSTR           pszZoneName,
    IN      DWORD           fSecureSecondaries,
    IN      DWORD           cSecondaries,
    IN      PIP_ADDRESS     aipSecondaries,
    IN      DWORD           fNotifyLevel,
    IN      DWORD           cNotify,
    IN      PIP_ADDRESS     aipNotify
    )
/*++

Routine Description:

    Send "zone reset secondaries" command to the server to reset
    the zone secondary and notify list parameters.

Arguments:

    pszZoneName -- zone name

    fSecureSecondaries -- secondary directive (ZONE_SECSECURE_XXX)

    cSecondaries -- count of IP addresses in aipSecondaries

    aipSecondaries -- secondary server IP address array

    fNotifyLevel -- notify directive (ZONE_NOTIFY_XXX)

    cNotify -- count of IP addresses in aipNotify

    aipNotify -- notify server IP address array

Return Value:

    ERROR_SUCCESS if successful or error code on failure.

--*/
{
    DNS_STATUS              status = ERROR_SUCCESS;
    BSTR                    bstrClassName;
    BSTR                    bstrMethodName;
    PWSTR                   pwszZoneName = NULL;
    IWbemClassObject *      pObj = NULL;
    IWbemClassObject *      pClassObj = NULL;
    IWbemClassObject *      pInSig = NULL;
    IWbemClassObject *      pOutSig = NULL;
    IWbemClassObject *      pInParams = NULL;
    IEnumWbemClassObject *  pEnum = NULL;
    VARIANT                 var;
    HRESULT                 hres;
    SAFEARRAY *             psa;
    
    DNSCMD_CHECK_WMI_ENABLED();

    //
    //  Allocate and initialize various stuff.
    //

    VariantInit( &var );

    bstrClassName = SysAllocString( L"MicrosoftDNS_Zone" );
    bstrMethodName = SysAllocString( L"ResetSecondaries" );
    if ( !bstrClassName || !bstrMethodName )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  Get WMI class object for the Zone class.
    //

    hres = g_pIWbemServices->GetObject(
                bstrClassName,
                WBEM_FLAG_RETURN_WBEM_COMPLETE,
                NULL,
                &pClassObj,
                NULL );
    if ( FAILED( hres ) )
    {
        goto Done;
    }
    ASSERT( pClassObj );

    //
    //  Get WMI object for specified zone.
    //

    status = getEnumerator( pszZoneName, &pEnum );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    status = getNextObjectInEnum( pEnum, &pObj );
    if ( status != ERROR_SUCCESS || !pObj )
    {
        goto Done;
    }

    //
    //  Get WMI method signature for ResetSecondaries.
    //

    hres = pClassObj->GetMethod(
                bstrMethodName,
                0,
                &pInSig,
                &pOutSig );
    if ( FAILED( hres ) )
    {
        goto Done;
    }
    if ( pInSig == NULL )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    //
    //  Create an instance of the method input parameters.
    //

    hres = pInSig->SpawnInstance( 0, &pInParams );
    if ( FAILED( hres ) )
    {
        goto Done;
    }
    ASSERT( pInParams );

    //
    //  Set method input parameters.
    //

    printWmiObjectProperties( pInParams );

{
    BSTR b = NULL;
    pInParams->GetObjectText( 0, &b );
    printf( "\nObjectText:\n%S\n", b );
}

    VariantClear( &var );

{
    BSTR bstr = SysAllocString( L"SecureSecondaries" );
    V_VT( &var ) = VT_UI4;
    V_UI4( &var ) = fSecureSecondaries;
    hres = pInParams->Put( bstr, 0, &var, 0 );
    VariantClear( &var );
}

#if 0
    V_VT( &var ) = VT_UI4;
    V_UI4( &var ) = fSecureSecondaries;
    hres = pInParams->Put( L"SecureSecondaries", 0, &var, 0 );
    VariantClear( &var );
#endif

    V_VT( &var ) = VT_UI4;
    V_UI4( &var ) = fNotifyLevel;
    hres = pInParams->Put( L"Notify", 0, &var, 0 );
    VariantClear( &var );

    psa = createSafeArrayForIpList( cSecondaries, aipSecondaries );
    if ( !psa )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
    V_VT( &var ) = VT_ARRAY | VT_BSTR;
    V_ARRAY( &var ) = psa;
    hres = pInParams->Put( L"SecondaryServers", 0, &var, 0 );
    VariantClear( &var );

    psa = createSafeArrayForIpList( cNotify, aipNotify );
    if ( !psa )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
    V_VT( &var ) = VT_ARRAY | VT_BSTR;
    V_ARRAY( &var ) = psa;
    hres = pInParams->Put( L"NotifyServers", 0, &var, 0 );
    VariantClear( &var );

    //
    //  Execute the method.
    //

    hres = g_pIWbemServices->ExecMethod(
                bstrClassName,
                bstrMethodName,
                0,                      //  flags
                NULL,                   //  context
                pInParams,              //  input params
                NULL,                   //  output params
                NULL );                 //  call result
    if ( FAILED( hres ) )
    {
        goto Done;
    }

    //
    //  Cleanup and return.
    //

    Done:

    VariantClear( &var );
    FREE_HEAP( pwszZoneName );
    SysFreeString( bstrMethodName );
    SysFreeString( bstrClassName );
    wmiRelease( pEnum );
    wmiRelease( pClassObj );
    wmiRelease( pInSig );
    wmiRelease( pOutSig );
    wmiRelease( pInParams );

    if ( status == ERROR_SUCCESS && FAILED( hres ) )
    {
        status = HRES_TO_STATUS( hres );
    }
    return status;
}   //  DnscmdWmi_ProcessResetZoneSecondaries


//
//  End dnsc_wmi.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\client\dnsrpc_c_stub.c ===
#include "dnsrpc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\client\dnsc_wmi.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    dnsc_wmi.h

Abstract:

    DNSCMD - header file for dnsc_wmi.c

    Include dnsclip.h to get basic stuff.

Author:

    Jeff Westhead (jwesth)  Novermber 2000

Revision History:

--*/


#ifndef _DNSCMD_WMI_INCLUDED_
#define _DNSCMD_WMI_INCLUDED_


#ifdef __cplusplus
extern "C" {
#endif


#include <wbemcli.h>        //  wmi interface declarations


extern BOOL     g_UseWmi;


DNS_STATUS
DnscmdWmi_Initialize(
    IN      PWSTR       pwszServerName
    );

DNS_STATUS
DnscmdWmi_Free(
    VOID
    );

DNS_STATUS
DnscmdWmi_ProcessDnssrvQuery(
    IN      PSTR        pszZoneName,
    IN      PCSTR       pszQuery
    );

DNS_STATUS
DnscmdWmi_ProcessEnumZones(
    IN      DWORD                   dwFilter
    );

DNS_STATUS
DnscmdWmi_ProcessZoneInfo(
    IN      LPSTR                   pszZone
    );

DNS_STATUS
DnscmdWmi_ProcessZoneDelete(
    IN      LPSTR                   pszZone
    );

DNS_STATUS
DnscmdWmi_ProcessEnumRecords(
    IN      LPSTR                   pszZone,
    IN      LPSTR                   pszNode,
    IN      BOOL                    fDetail,
    IN      DWORD                   dwFlags
    );

#define PRIVATE_VT_IPARRAY          ( 120 )

DNS_STATUS
DnscmdWmi_ResetProperty(
    IN      LPSTR                   pszZone,
    IN      LPSTR                   pszProperty,
    IN      DWORD                   cimType,
    IN      PVOID                   value
    );

DNS_STATUS
DnscmdWmi_ProcessResetForwarders(
    IN      DWORD               cForwarders,
    IN      PIP_ADDRESS         aipForwarders,
    IN      DWORD               dwForwardTimeout,
    IN      DWORD               fSlave
    );

DNS_STATUS
DnscmdWmi_ProcessDnssrvOperation(
    IN      LPSTR               pszZoneName,
    IN      LPSTR               pszOperation,
    IN      DWORD               dwTypeId,
    IN      PVOID               pvData
    );

DNS_STATUS
DnscmdWmi_ProcessRecordAdd(
    IN      LPSTR               pszZoneName,
    IN      LPSTR               pszNodeName,
    IN      PDNS_RPC_RECORD     prrRpc,
    IN      DWORD               Argc,
    IN      LPSTR *             Argv
    );

DNS_STATUS
DnscmdWmi_GetStatistics(
    IN      DWORD               dwStatId
    );

DNS_STATUS
DnscmdWmi_ProcessResetZoneSecondaries(
    IN      LPSTR           pszZoneName,
    IN      DWORD           fSecureSecondaries,
    IN      DWORD           cSecondaries,
    IN      PIP_ADDRESS     aipSecondaries,
    IN      DWORD           fNotifyLevel,
    IN      DWORD           cNotify,
    IN      PIP_ADDRESS     aipNotify
    );


#ifdef __cplusplus
}   //  extern "C"
#endif

#endif  //  _DNSCMD_WMI_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\client\local.c ===
/*++

Copyright (c) 1995  Microsoft Corporation

Module Name:

    local.c

Abstract:

    Domain Name System (DNS) Server -- Admin Client API

    DNS Admin API calls that do not use RPC.
    Completely executed in client library.

Author:

    Jim Gilroy (jamesg)     14-Oct-1995

Environment:

    User Mode - Win32

Revision History:

--*/


#include "dnsclip.h"

//
//  Debug globals
//

DWORD  LocalDebugFlag;

//
//  Buffer size for building WKS services string
//

#define WKS_SERVICES_BUFFER_SIZE    (0x1000)    // 4k




VOID
DNS_API_FUNCTION
DnssrvInitializeDebug(
    VOID
    )
/*++

Routine Description:

    Initialize debugging -- use dnslib debugging.

    Only purpose is generic interface that hides file flag
    and name info so no need to put in header.

--*/
{
#if DBG
    Dns_StartDebug(
        0,
        DNSRPC_DEBUG_FLAG_FILE,
        & LocalDebugFlag,
        DNSRPC_DEBUG_FILE_NAME,
        1000000 );                  //  1mb wrap

    DNS_PRINT(( "LocalDebugFlag = %p\n", LocalDebugFlag ));
#endif
}



PVOID
DnssrvMidlAllocZero(
    IN      DWORD           dwSize
    )
/*++

Routine Description:

    MIDL allocate and zero memory.

Arguments:

Return Value:

    Ptr to allocated and zeroed memory.

--*/
{
    PVOID   ptr;

    ptr = MIDL_user_allocate( dwSize );
    if ( !ptr )
    {
        return NULL;
    }
    RtlZeroMemory(
        ptr,
        dwSize );
    return ptr;
}



VOID
DNS_API_FUNCTION
DnssrvFreeRpcBuffer(
    IN OUT  PDNS_RPC_BUFFER pBuf
    )
/*++

Routine Description:

    Free generic (no substructures) RPC buffer.

Arguments:

    pBuf -- ptr to buf to free

Return Value:

    None

--*/
{
    if ( pBuf )
    {
        MIDL_user_free( pBuf );
    }
}



VOID
DNS_API_FUNCTION
DnssrvFreeServerInfo(
    IN OUT  PDNS_RPC_SERVER_INFO    pServerInfo
    )
/*++

Routine Description:

    Deep free of DNS_SERVER_INFO structure.

Arguments:

    pServerInfo -- ptr to server info to free

Return Value:

    None

--*/
{
    if ( !pServerInfo )
    {
        return;
    }

    //
    //  free allocated items inside the server info blob
    //

    if ( pServerInfo->pszServerName )
    {
        MIDL_user_free( pServerInfo->pszServerName );
    }
    if ( pServerInfo->aipServerAddrs )
    {
        MIDL_user_free( pServerInfo->aipServerAddrs );
    }
    if ( pServerInfo->aipListenAddrs )
    {
        MIDL_user_free( pServerInfo->aipListenAddrs );
    }
    if ( pServerInfo->aipForwarders )
    {
        MIDL_user_free( pServerInfo->aipForwarders );
    }
    if ( pServerInfo->aipLogFilter )
    {
        MIDL_user_free( pServerInfo->aipLogFilter );
    }
    if ( pServerInfo->pwszLogFilePath )
    {
        MIDL_user_free( pServerInfo->pwszLogFilePath );
    }
    if ( pServerInfo->pszDsContainer )
    {
        MIDL_user_free( pServerInfo->pszDsContainer );
    }
    if ( pServerInfo->pszDomainName )
    {
        MIDL_user_free( pServerInfo->pszDomainName );
    }
    if ( pServerInfo->pszForestName )
    {
        MIDL_user_free( pServerInfo->pszForestName );
    }
    if ( pServerInfo->pszDomainDirectoryPartition )
    {
        MIDL_user_free( pServerInfo->pszDomainDirectoryPartition );
    }
    if ( pServerInfo->pszForestDirectoryPartition )
    {
        MIDL_user_free( pServerInfo->pszForestDirectoryPartition );
    }

    //
    //  free DNS_SERVER_INFO struct itself
    //

    MIDL_user_free( pServerInfo );
}



VOID
DNS_API_FUNCTION
DnssrvFreeZoneInfo(
    IN OUT  PDNS_RPC_ZONE_INFO  pZoneInfo
    )
/*++

Routine Description:

    Deep free of DNS_ZONE_INFO structure.

Arguments:

    pZoneInfo -- ptr to zone info to free

Return Value:

    None

--*/
{
    if ( !pZoneInfo )
    {
        return;
    }

    //
    //  free substructures
    //      - name string
    //      - data file string
    //      - secondary IP array
    //      - WINS server array
    //

    if ( pZoneInfo->pszZoneName )
    {
        MIDL_user_free( pZoneInfo->pszZoneName );
    }
    if ( pZoneInfo->pszDataFile )
    {
        MIDL_user_free( pZoneInfo->pszDataFile );
    }
    if ( pZoneInfo->aipMasters )
    {
        MIDL_user_free( pZoneInfo->aipMasters );
    }
    if ( pZoneInfo->aipSecondaries )
    {
        MIDL_user_free( pZoneInfo->aipSecondaries );
    }
    if ( pZoneInfo->pszDpFqdn )
    {
        MIDL_user_free( pZoneInfo->pszDpFqdn );
    }
    if ( pZoneInfo->pwszZoneDn )
    {
        MIDL_user_free( pZoneInfo->pwszZoneDn );
    }

    //
    //  free DNS_ZONE_INFO struct itself
    //

    MIDL_user_free( pZoneInfo );
}



VOID
DNS_API_FUNCTION
DnssrvFreeNode(
    IN OUT  PDNS_NODE   pNode,
    IN      BOOLEAN     fFreeRecords
    )
{
    if ( pNode )
    {
        if ( pNode->pRecord )
        {
            Dns_RecordListFree(
                pNode->pRecord,
                TRUE );
        }

        if ( pNode->Flags.S.FreeOwner )
        {
            FREE_HEAP( pNode->pName );
        }
        FREE_HEAP( pNode );
    }
}



VOID
DNS_API_FUNCTION
DnssrvFreeNodeList(
    IN OUT  PDNS_NODE   pNode,
    IN      BOOLEAN     fFreeRecords
    )
{
    PDNS_NODE   pnext;

    while ( pNode )
    {
        pnext = pNode->pNext;
        DnssrvFreeNode(
            pNode,
            fFreeRecords );
        pNode = pnext;
    }
}



VOID
DNS_API_FUNCTION
DnssrvFreeZone(
    IN OUT  PDNS_RPC_ZONE   pZone
    )
/*++

Routine Description:

    Deep free of DNS_RPC_ZONE structure.

Arguments:

    pZone -- ptr to zone to free

Return Value:

    None

--*/
{
    if ( !pZone )
    {
        return;
    }

    //  free zone name, then zone itself

    if ( pZone->pszZoneName )
    {
        MIDL_user_free( pZone->pszZoneName );
    }
    if ( pZone->pszDpFqdn )
    {
        MIDL_user_free( pZone->pszDpFqdn );
    }
    MIDL_user_free( pZone );
}



VOID
DNS_API_FUNCTION
DnssrvFreeZoneList(
    IN OUT  PDNS_RPC_ZONE_LIST  pZoneList
    )
/*++

Routine Description:

    Deep free of list of DNS_RPC_ZONE structures.

Arguments:

    pZoneList -- ptr RPC_ZONE_LIST structure to free

Return Value:

    None

--*/
{
    DWORD           i;
    PDNS_RPC_ZONE   pzone;

    if ( pZoneList )
    {
        for( i = 0; i< pZoneList->dwZoneCount; ++i )
        {
            pzone = pZoneList->ZoneArray[i];
            MIDL_user_free( pzone->pszZoneName );
            MIDL_user_free( pzone->pszDpFqdn );
            MIDL_user_free( pzone );
        }

        MIDL_user_free( pZoneList );
    }
}



VOID
DNS_API_FUNCTION
DnssrvFreeDirectoryPartitionEnum(
    IN OUT  PDNS_RPC_DP_ENUM    pDp
    )
/*++

Routine Description:

    Deep free of PDNS_RPC_DP_ENUM structure.

Arguments:

    pDp -- ptr to directory partition to free

Return Value:

    None

--*/
{
    if ( pDp )
    {
        if ( pDp->pszDpFqdn )
        {
            MIDL_user_free( pDp->pszDpFqdn );
        }
        MIDL_user_free( pDp );
    }
}



VOID
DNS_API_FUNCTION
DnssrvFreeDirectoryPartitionInfo(
    IN OUT  PDNS_RPC_DP_INFO    pDp
    )
/*++

Routine Description:

    Deep free of PDNS_RPC_DP_INFO structure.

Arguments:

    pDp -- ptr to directory partition to free

Return Value:

    None

--*/
{
    DWORD   i;

    if ( !pDp )
    {
        return;
    }

    if ( pDp->pszDpFqdn )
    {
        MIDL_user_free( pDp->pszDpFqdn );
    }
    if ( pDp->pszDpDn )
    {
        MIDL_user_free( pDp->pszDpDn );
    }
    if ( pDp->pszCrDn )
    {
        MIDL_user_free( pDp->pszCrDn );
    }
    for( i = 0; i < pDp->dwReplicaCount; i++ )
    {
        PDNS_RPC_DP_REPLICA     p = pDp->ReplicaArray[ i ];

        if ( p )
        {
            if ( p->pszReplicaDn )
            {
                MIDL_user_free( p->pszReplicaDn );
            }
            MIDL_user_free( p );
        }
    }
    MIDL_user_free( pDp );
}



VOID
DNS_API_FUNCTION
DnssrvFreeDirectoryPartitionList(
    IN OUT  PDNS_RPC_DP_LIST        pDpList
    )
/*++

Routine Description:

    Deep free of list of PDNS_RPC_DP_LIST structures.

Arguments:

    pZoneList -- ptr PDNS_RPC_DP_LIST structure to free

Return Value:

    None

--*/
{
    DWORD               i;
    PDNS_RPC_DP_ENUM    pDp;

    if ( pDpList )
    {
        for( i = 0; i < pDpList->dwDpCount; ++i )
        {
            pDp = pDpList->DpArray[ i ];
            DnssrvFreeDirectoryPartitionEnum( pDp );
        }
        MIDL_user_free( pDpList );
    }
}



PCHAR
DnssrvGetWksServicesInRecord(
    IN      PDNS_FLAT_RECORD    pRR
    )
/*++

Routine Description:

    Get list of services in WKS record.

Arguments:

    pRR - flat WKS record being written

Return Value:

    Ptr to services string, caller MUST free.
    NULL on error.

--*/
{
    struct servent *    pServent;
    struct protoent *   pProtoent;
    INT         i;
    DWORD       length;
    USHORT      port;
    UCHAR       bBitmask;
    CHAR        buffer[ WKS_SERVICES_BUFFER_SIZE ];
    PCHAR       pch = buffer;
    PCHAR       pchstart;
    PCHAR       pchstop;

    //  protocol

    pProtoent = getprotobynumber( (INT) pRR->Data.WKS.chProtocol );
    if ( ! pProtoent )
    {
        DNS_PRINT((
            "ERROR:  Unable to find protocol %d, writing WKS record.\n",
            (INT) pRR->Data.WKS.chProtocol ));
        return NULL;
    }

    //
    //  services
    //
    //  find each bit set in bitmask, lookup and write service
    //  corresponding to that port
    //
    //  note, that since that port zero is the front of port bitmask,
    //  lowest ports are the highest bits in each byte
    //

    pchstart = pch;
    pchstop = pch + WKS_SERVICES_BUFFER_SIZE;

    for ( i = 0;
            i < (INT)(pRR->wDataLength - SIZEOF_WKS_FIXED_DATA);
                i++ )
    {
        bBitmask = (UCHAR) pRR->Data.WKS.bBitMask[i];

        port = i * 8;

        //  write service name for each bit set in byte
        //      - get out as soon byte is empty of ports
        //      - terminate each name with blank (until last)

        while ( bBitmask )
        {
            if ( bBitmask & 0x80 )
            {
                pServent = getservbyport(
                                (INT) htons(port),
                                pProtoent->p_name );

                if ( pServent )
                {
                    INT copyCount = strlen(pServent->s_name);

                    pch++;
                    if ( pchstop - pch <= copyCount+1 )
                    {
                        return NULL;
                    }
                    RtlCopyMemory(
                        pch,
                        pServent->s_name,
                        copyCount );
                    pch += copyCount;
                    *pch = ' ';
                }
                else
                {
                    DNS_PRINT((
                        "ERROR:  Unable to find service for port %d, "
                        "writing WKS record.\n",
                        port
                        ));
                    pch += sprintf( pch, "%d", port );
                }
            }
            port++;           // next service port
            bBitmask <<= 1;     // shift mask up to read next port
        }
    }

    //  NULL terminate services string
    //  and determine length

    *pch++ = 0;
    length = (DWORD) (pch - pchstart);

    //  allocate copy of this string

    pch = ALLOCATE_HEAP( length );
    if ( !pch )
    {
        SetLastError( DNS_ERROR_NO_MEMORY );
        return NULL;
    }

    RtlCopyMemory(
        pch,
        pchstart,
        length );

    return pch;
}



//
//  Build LDAP \ DS names for objects
//

//
//  Build Unicode LDAP paths
//

#define DN_TEXT(string) (L##string)


LPWSTR
DNS_API_FUNCTION
DnssrvCreateDsNodeName(
    IN      PDNS_RPC_SERVER_INFO    pServerInfo,
    IN      LPWSTR                  pszZone,
    IN      LPWSTR                  pszNode
    )
/*++

Routine Description:

    Build node DS name.

Arguments:

    pServerInfo -- server info for server

    pszZone -- zone name

    pszNode -- node name RELATIVE to zone root

Return Value:

    Ptr to node's DS name.  Caller must free.
    NULL on error.

--*/
{
    PWCHAR  psznodeDN;
    DWORD   length;

    //  if not DS integrated, bail

    if ( !pServerInfo->pszDsContainer )
    {
        return NULL;
    }

    //  special case zone root

    if ( !pszNode )
    {
        pszNode = DN_TEXT("@");
    }

    //  allocate required space

    length = sizeof(DN_TEXT("dc=,dc=, "));
    length += sizeof(WCHAR) * wcslen( pszNode );
    length += sizeof(WCHAR) * wcslen( pszZone );
    length += sizeof(WCHAR) * wcslen( (LPWSTR)pServerInfo->pszDsContainer );

    psznodeDN = ( PWCHAR ) ALLOCATE_HEAP( length );
    if ( !psznodeDN )
    {
        return NULL;
    }

    //  build DN

    wcscpy( psznodeDN, DN_TEXT("dc=") );
    wcscat( psznodeDN, pszNode );
    length = wcslen(psznodeDN);
    ASSERT ( length > 3 );

    if (  length != 4 &&                     // "dc=."  case
          psznodeDN[ length - 1 ] == '.' )
    {
        //
        // we have a dot terminated node name, strip it out
        //
        psznodeDN[ length - 1 ] = '\0';
    }
    wcscat( psznodeDN, DN_TEXT(",dc=") );
    wcscat( psznodeDN, pszZone );
    length = wcslen(psznodeDN);
    ASSERT ( length > 1 );

    if (  1 != wcslen ( pszZone ) &&            // zone = "." case
          psznodeDN[ length - 1 ] == '.' )
    {
        //
        // we have a dot terminated zone name, strip it out
        //
        psznodeDN[ length - 1 ] = '\0';
    }
    wcscat( psznodeDN, DN_TEXT(",") );
    wcscat( psznodeDN, (LPWSTR)pServerInfo->pszDsContainer );

    DNSDBG( STUB, (
        "Node DN built:  %s\n",
        psznodeDN ));

    return psznodeDN;
}



LPWSTR
DNS_API_FUNCTION
DnssrvCreateDsZoneName(
    IN      PDNS_RPC_SERVER_INFO    pServerInfo,
    IN      LPWSTR                  pszZone
    )
/*++

Routine Description:

    Build zone DS name.

    This routine should only be used for legacy zones on W2K servers.
    For Whistler+ servers the zone info structure has the zone object DN.

Arguments:

    pServerInfo -- server info for server

    pszZone -- zone name

Return Value:

    Ptr to zone's DS name.  Caller must free.
    NULL on error.

--*/
{

    PWCHAR  pszzoneDN;
    DWORD   length;

    //  if not DS integrated, bail

    if ( !(LPWSTR)pServerInfo->pszDsContainer )
    {
        return NULL;
    }

    //  allocate required space

    length = sizeof(DN_TEXT("dc=, "));
    length += sizeof(WCHAR) * wcslen( pszZone );
    length += sizeof(WCHAR) * wcslen( (LPWSTR)pServerInfo->pszDsContainer );

    pszzoneDN = (PWCHAR) ALLOCATE_HEAP( length );
    if ( !pszzoneDN )
    {
        return NULL;
    }

    //  build DN

    wcscpy( pszzoneDN, DN_TEXT("dc=") );
    wcscat( pszzoneDN, pszZone );
    length = wcslen(pszzoneDN);
    ASSERT ( length > 1 );

    if ( length != 4 &&                     // "dc=."  case
         pszzoneDN[ length - 1 ] == '.' )
    {
        //
        // we have a dot terminated zone name, strip it out
        //
        pszzoneDN[ length - 1 ] = '\0';
    }
    wcscat( pszzoneDN, DN_TEXT(",") );
    wcscat( pszzoneDN, (LPWSTR)pServerInfo->pszDsContainer );

    DNSDBG( STUB, (
        "Zone DN built:  %s\n",
        pszzoneDN ));

    return pszzoneDN;
}



LPWSTR
DNS_API_FUNCTION
DnssrvCreateDsServerName(
    IN      PDNS_RPC_SERVER_INFO    pServerInfo
    )
/*++

Routine Description:

    Build zone DS name.

Arguments:

    pServerInfo -- server info for server

Return Value:

    Ptr to server's DS name.  Caller must free.
    NULL on error.

--*/
{
    PWCHAR  pszserverDN;
    DWORD   length;

    //
    //  DEVNOTE: need investigation here,
    //           may just be able to use DNS folder in DS
    //

    //  if not DS integrated, bail

    if ( !(LPWSTR)pServerInfo->pszDsContainer )
    {
        return NULL;
    }

    //  allocate space

    length = sizeof(DN_TEXT(" "));
    length += sizeof(WCHAR) * wcslen( (LPWSTR)pServerInfo->pszDsContainer );

    pszserverDN = (PWCHAR) ALLOCATE_HEAP( length );
    if ( !pszserverDN )
    {
        return NULL;
    }

    //  build DN

    wcscpy( pszserverDN, (LPWSTR)pServerInfo->pszDsContainer );

    DNSDBG( STUB, (
        "Server DN built:  %s\n",
        pszserverDN ));

    return pszserverDN;
}

//
//  End local.c
//


#if 0


VOID
convertRpcUnionTypeToUnicode(
    IN      DWORD           dwTypeId,
    IN OUT  DNS_RPC_UNION   pData
    )
/*++

Routine Description:

    Convert RPC union types to unicode.

Arguments:

Return Value:

    None

--*/
{
    switch ( dwTypeId )
    {
    case DNSSRV_TYPEID_LPSTR:

        pwideString = DnsStringCopyAllocateEx(
                        pData.String,
                        0,
                        FALSE,      // UTF8 in
                        TRUE        // Unicode out
                        );
        if ( !pwideString )
        {
            ASSERT( FALSE );
            return;
        }
        MIDL_user_free( pData.String );
        pData.String = (LPSTR) pwideString;

    case DNSSRV_TYPEID_SERVER_INFO:

        DnsPrint_RpcServerInfo(
            PrintRoutine,
            pszHeader,
            (PDNS_RPC_SERVER_INFO) pData );
        break;

    case DNSSRV_TYPEID_ZONE:

        DnsPrint_RpcZone(
            PrintRoutine,
            pszHeader,
            (PDNS_RPC_ZONE) pData );
        break;

    case DNSSRV_TYPEID_ZONE_INFO:

        DnsPrint_RpcZoneInfo(
            PrintRoutine,
            pszHeader,
            (PDNS_RPC_ZONE_INFO) pData );
        break;

    case DNSSRV_TYPEID_ZONE_DBASE_INFO:

        PrintRoutine(
            "%sZone Dbase Info:\n"
            "    DS Integrated    = %d\n"
            "    File Name        = %s\n",
            pszHeader,
            ((PDNS_RPC_ZONE_DBASE_INFO)pData)->fDsIntegrated,
            ((PDNS_RPC_ZONE_DBASE_INFO)pData)->pszFileName );
        break;
}


VOID
convertStringToUnicodeInPlace(
    IN      LPSTR *         ppszString
    )
/*++

Routine Description:

    Convert string to unicode and return it to its current
    position in structure.

Arguments:

Return Value:

    None

--*/
{
    switch ( dwTypeId )
    {
        case DNSSRV_TYPEID_LPSTR:

            pwideString = Dns_StringCopyAllocateEx(
                            pData.String,
                            0,
                            FALSE,      // UTF8 in
                            TRUE        // Unicode out
                            );
            if ( !pwideString )
            {
                ASSERT( FALSE );
                return;
            }
            MIDL_user_free( pData.String );
            pData.String = (LPSTR) pwideString;

        case DNSSRV_TYPEID_SERVER_INFO:

            DnsPrint_RpcServerInfo(
                PrintRoutine,
                pszHeader,
                (PDNS_RPC_SERVER_INFO) pData );
            break;

        case DNSSRV_TYPEID_STATS:

            DnsPrint_RpcStatistics(
                PrintRoutine,
                pszHeader,
                (PDNS_RPC_STATISTICS) pData );
            break;

        case DNSSRV_TYPEID_ZONE:

            DnsPrint_RpcZone(
                PrintRoutine,
                pszHeader,
                (PDNS_RPC_ZONE) pData );
            break;

        case DNSSRV_TYPEID_FORWARDERS:

            DnsPrint_RpcIpArrayPlusParameters(
                PrintRoutine,
                pszHeader,
                "Forwarders Info:",
                "Slave",
                ((PDNS_RPC_FORWARDERS)pData)->fSlave,
                "Timeout",
                ((PDNS_RPC_FORWARDERS)pData)->dwForwardTimeout,
                "    Forwarders:\n",
                ((PDNS_RPC_FORWARDERS)pData)->aipForwarders );
            break;

        case DNSSRV_TYPEID_ZONE_INFO:

            DnsPrint_RpcZoneInfo(
                PrintRoutine,
                pszHeader,
                (PDNS_RPC_ZONE_INFO) pData );
            break;

        case DNSSRV_TYPEID_ZONE_SECONDARIES:

            DnsPrint_RpcIpArrayPlusParameters(
                PrintRoutine,
                pszHeader,
                "Zone Secondary Info:",
                "Secure Secondaries",
                ((PDNS_RPC_ZONE_SECONDARIES)pData)->fSecureSecondaries,
                NULL,
                0,
                "    Secondaries:\n",
                ((PDNS_RPC_ZONE_SECONDARIES)pData)->aipSecondaries );
            break;

        case DNSSRV_TYPEID_ZONE_TYPE_RESET:

            DnsPrint_RpcIpArrayPlusParameters(
                PrintRoutine,
                pszHeader,
                "Zone Type Reset Info:",
                "ZoneType",
                ((PDNS_RPC_ZONE_TYPE_RESET)pData)->dwZoneType,
                NULL,
                0,
                "    Masters:\n",
                ((PDNS_RPC_ZONE_TYPE_RESET)pData)->aipMasters );
            break;

        case DNSSRV_TYPEID_ZONE_DBASE_INFO:

            PrintRoutine(
                "%sZone Dbase Info:\n"
                "    DS Integrated    = %d\n"
                "    File Name        = %s\n",
                pszHeader,
                ((PDNS_RPC_ZONE_DBASE_INFO)pData)->fDsIntegrated,
                ((PDNS_RPC_ZONE_DBASE_INFO)pData)->pszFileName );
            break;

        default:

            PrintRoutine(
                "%s\n"
                "WARNING:  Unknown RPC structure typeid = %d at %p\n",
                dwTypeId,
                pData );
            break;
    }
}

#endif




PDNSSRV_STAT
DNS_API_FUNCTION
DnssrvFindStatisticsInBuffer(
    IN      PDNS_RPC_BUFFER     pBuffer,
    IN      DWORD               StatId
    )
/*++

Routine Description:

    Finds desired statistics in stats buffer.

Arguments:

    pStatsBuf -- stats buffer

    StatId -- ID of desired stats

Return Value:

    Ptr to desired stats in buffer.

--*/
{
    PDNSSRV_STAT    pstat;
    PCHAR           pch;
    PCHAR           pchstop;

    pch = pBuffer->Buffer;
    pchstop = pch + pBuffer->dwLength;

    //
    //  check all stat blobs within buffer
    //

    while ( pch < pchstop )
    {
        pstat = (PDNSSRV_STAT) pch;
        pch = (PCHAR) GET_NEXT_STAT_IN_BUFFER( pstat );
        if ( pch > pchstop )
        {
            DNS_PRINT(( "ERROR:  invalid stats buffer\n" ));
            break;
        }

        //  found matching stats
        //      - verify correct length
        //      - return

        if ( pstat->Header.StatId == StatId )
        {
            if ( DnssrvValidityCheckStatistic(pstat) != ERROR_SUCCESS )
            {
                DNS_PRINT(( "WARNING:  Mismatched stats length.\n" ));
                break;
            }
            return pstat;
        }
    }

    return NULL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\client\print.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    print.c

Abstract:

    Domain Name System (DNS) Server RPC Library

    Print routines for RPC types

Author:

    Jim Gilroy (jamesg)     September 1995

Revision History:

--*/


#include "dnsclip.h"

#include <time.h>


#define DNS_NOT_APPLICABLE      "N/A"
#define DNS_NOT_APPLICABLE_W    L"N/A"

#define DNS_NOT_PERFORMED       "not since restart"



//
//  Winsock version: copied from socket.c
//

#ifndef DNS_WINSOCK2

#define DNS_WINSOCK_VERSION (0x0101)    //  Winsock 1.1

#else   // Winsock2

#define DNS_WINSOCK_VERSION (0x0002)    //  Winsock 2.0

#endif


//
//  Tagged memory stat strings
//
//  NT5 shipped version
//

LPSTR   MemTagStringsNT5[] =
{
    MEMTAG_NAME_NONE         ,
    MEMTAG_NAME_RECORD       ,
    MEMTAG_NAME_NODE         ,
    MEMTAG_NAME_NAME         ,
    MEMTAG_NAME_ZONE         ,
    MEMTAG_NAME_UPDATE       ,
    MEMTAG_NAME_TIMEOUT      ,
    MEMTAG_NAME_STUFF        ,
    MEMTAG_NAME_NODEHASH     ,
    MEMTAG_NAME_DS_DN        ,
    MEMTAG_NAME_DS_MOD       ,
    MEMTAG_NAME_DS_RECORD    ,
    MEMTAG_NAME_NODE_COPY    ,
    MEMTAG_NAME_PACKET_UDP   ,
    MEMTAG_NAME_PACKET_TCP   ,
    MEMTAG_NAME_DNSLIB       ,
    MEMTAG_NAME_TABLE        ,
    MEMTAG_NAME_SOCKET       ,
    MEMTAG_NAME_CONNECTION   ,
    MEMTAG_NAME_REGISTRY     ,
    MEMTAG_NAME_RPC          ,
    MEMTAG_NAME_NBSTAT       ,
    MEMTAG_NAME_FILEBUF      ,
    MEMTAG_NAME_DS_OTHER     ,
    MEMTAG_NAME_THREAD       ,
    MEMTAG_NAME_UPDATE_LIST  ,
    MEMTAG_NAME_SAFE         ,

    NULL,       // safety
    NULL,
    NULL,
    NULL
};

//  NT5 SP1 version

LPSTR   MemTagStrings[] =
{
    MEMTAG_NAME_NONE            ,
    MEMTAG_NAME_PACKET_UDP      ,
    MEMTAG_NAME_PACKET_TCP      ,
    MEMTAG_NAME_NAME            ,
    MEMTAG_NAME_ZONE            ,
    MEMTAG_NAME_UPDATE          ,
    MEMTAG_NAME_UPDATE_LIST     ,
    MEMTAG_NAME_TIMEOUT         ,
    MEMTAG_NAME_NODEHASH        ,
    MEMTAG_NAME_DS_DN           ,
    MEMTAG_NAME_DS_MOD          ,   //  10
    MEMTAG_NAME_DS_RECORD       ,
    MEMTAG_NAME_DS_OTHER        ,
    MEMTAG_NAME_THREAD          ,
    MEMTAG_NAME_NBSTAT          ,
    MEMTAG_NAME_DNSLIB          ,
    MEMTAG_NAME_TABLE           ,
    MEMTAG_NAME_SOCKET          ,
    MEMTAG_NAME_CONNECTION      ,
    MEMTAG_NAME_REGISTRY        ,
    MEMTAG_NAME_RPC             ,   //  20
    MEMTAG_NAME_STUFF           ,
    MEMTAG_NAME_FILEBUF         ,
    MEMTAG_NAME_REMOTE          ,
    MEMTAG_NAME_SAFE            ,

    MEMTAG_NAME_RECORD          ,
    MEMTAG_NAME_RECORD_FILE     ,
    MEMTAG_NAME_RECORD_DS       ,
    MEMTAG_NAME_RECORD_AXFR     ,
    MEMTAG_NAME_RECORD_IXFR     ,
    MEMTAG_NAME_RECORD_DYNUP    ,   //  30
    MEMTAG_NAME_RECORD_ADMIN    ,
    MEMTAG_NAME_RECORD_AUTO     ,
    MEMTAG_NAME_RECORD_CACHE    ,
    MEMTAG_NAME_RECORD_NOEXIST  ,
    MEMTAG_NAME_RECORD_WINS     ,
    MEMTAG_NAME_RECORD_WINSPTR  ,
    MEMTAG_NAME_RECORD_COPY     ,

    MEMTAG_NAME_NODE            ,
    MEMTAG_NAME_NODE_FILE       ,
    MEMTAG_NAME_NODE_DS         ,   //  40
    MEMTAG_NAME_NODE_AXFR       ,
    MEMTAG_NAME_NODE_IXFR       ,
    MEMTAG_NAME_NODE_DYNUP      ,
    MEMTAG_NAME_NODE_ADMIN      ,
    MEMTAG_NAME_NODE_AUTO       ,
    MEMTAG_NAME_NODE_CACHE      ,
    MEMTAG_NAME_NODE_NOEXIST    ,
    MEMTAG_NAME_NODE_WINS       ,
    MEMTAG_NAME_NODE_WINSPTR    ,
    MEMTAG_NAME_NODE_COPY       ,

    NULL,       // safety
    NULL,
    NULL,
    NULL
};



VOID
Dns_SystemHourToSystemTime(
    IN      DWORD           dwHourTime,
    IN OUT  PSYSTEMTIME     pSystemTime
    )
/*++

Routine Description:

    Converts system time in hours to SYSTEMTIME format.

Arguments:

    dwHourTime  -- system time in hours (hours since 1601)

    pSystemTime -- ptr to SYSTEMTIME to set

Return Value:

    None

--*/
{
#define FILE_TIME_INTERVALS_IN_HOUR (36000000000)

    LONGLONG    fileTime;

    fileTime = (LONGLONG)dwHourTime * FILE_TIME_INTERVALS_IN_HOUR;

    FileTimeToSystemTime( (PFILETIME)&fileTime, pSystemTime );
}



PWSTR
utf8ToUnicode(
    IN      PSTR            pszInputStr,
    IN      DWORD           dwInputLength
    )
/*++

Routine Description:

    Takes a UTF-8 string and allocates a Unicode copy of the string.

    The caller must call use FREE_HEAP to deallocate the Unicode string.

Arguments:

    pszInputStr -- input string, optionally NULL terminated

    dwInputLength -- pass zero if pszInputStr is NULL terminated

Return Value:

    NULL-terminated Unicode output string

--*/
{
    PWSTR       pwszoutput;

    if ( pszInputStr == NULL )
    {
        pszInputStr = "";
        dwInputLength = 0;
    }

    pwszoutput = Dns_StringCopyAllocate(
                        pszInputStr,
                        dwInputLength,
                        DnsCharSetUtf8,     // UTF8 in
                        DnsCharSetUnicode   // unicode out
                        );
    return pwszoutput;
}   //  utf8ToUnicode



PWSTR
getUnicodeForUtf8(
    IN      PSTR            pUtf8
    )
/*++

Routine Description:

    Takes a UTF-8 string and allocates a Unicode copy of the string.

    Caller must free resulting unicode string.

Arguments:

    pUtf8 -- UTF8 string

Return Value:

    Ptr to unicode string.
    NULL on alloc failure or invalid UTF8 string.

--*/
{
    return Dns_StringCopyAllocate(
                pUtf8,
                0,                  // NULL terminated
                DnsCharSetUtf8,     // UTF8 in
                DnsCharSetUnicode   // unicode out
                );
}




//
//  Print server info
//

VOID
DnsPrint_RpcServerInfo(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pPrintContext,
    IN      LPSTR                   pszHeader,
    IN      PDNS_RPC_SERVER_INFO    pServerInfo
    )
{
    char    szTime[ 80 ] = DNS_NOT_PERFORMED;
    PWSTR   pnameServer = NULL;
    PWSTR   pnameForest = NULL;
    PWSTR   pnameDomain = NULL;
    PWSTR   pnameForestDp = NULL;
    PWSTR   pnameDomainDp = NULL;

    DnsPrint_Lock();
    if ( pszHeader )
    {
        PrintRoutine( pPrintContext, pszHeader );
    }

    if ( ! pServerInfo )
    {
        PrintRoutine( pPrintContext, "NULL server info ptr.\n" );
    }
    else
    {
        int     majorVer = pServerInfo->dwVersion & 0x000000FF;
        int     minorVer = ( pServerInfo->dwVersion & 0x0000FF00 ) >> 8;
        int     buildNum = pServerInfo->dwVersion >> 16;

        pnameServer =   getUnicodeForUtf8( pServerInfo->pszServerName );
        pnameForest =   getUnicodeForUtf8( pServerInfo->pszForestName );
        pnameDomain =   getUnicodeForUtf8( pServerInfo->pszDomainName );
        pnameForestDp = getUnicodeForUtf8( pServerInfo->pszForestDirectoryPartition );
        pnameDomainDp = getUnicodeForUtf8( pServerInfo->pszDomainDirectoryPartition );

        PrintRoutine( pPrintContext,
            "Server info\n"
            "\tserver name              = %S\n",
            pnameServer );

        //
        //  Sanitize build number for older versions where build number is wacked.
        //

        if ( buildNum < 1 || buildNum > 5000 )
        {
            PrintRoutine( pPrintContext,
                "\tversion                  = %08lX (%d.%d)\n",
                pServerInfo->dwVersion,
                majorVer,
                minorVer );
        }
        else
        {
            PrintRoutine( pPrintContext,
                "\tversion                  = %08lX (%d.%d build %d)\n",
                pServerInfo->dwVersion,
                majorVer,
                minorVer,
                buildNum );
        }

        PrintRoutine( pPrintContext,
            "\tDS container             = %S\n"
            "\tforest name              = %S\n"
            "\tdomain name              = %S\n"
            "\tbuiltin domain partition = %S\n"
            "\tbuiltin forest partition = %S\n",
            pServerInfo->pszDsContainer ?
                pServerInfo->pszDsContainer : DNS_NOT_APPLICABLE_W,
            pnameForest     ? pnameForest   : DNS_NOT_APPLICABLE_W,
            pnameDomain     ? pnameDomain   : DNS_NOT_APPLICABLE_W,
            pnameForestDp   ? pnameForestDp : DNS_NOT_APPLICABLE_W,
            pnameDomainDp   ? pnameDomainDp : DNS_NOT_APPLICABLE_W
            );

        #if DBG
        PrintRoutine( pPrintContext,
            "\tAD forest behavior ver   = %2d   (DBG only)\n"
            "\tAD domain behavior ver   = %2d   (DBG only)\n"
            "\tAD DSA behavior ver      = %2d   (DBG only)\n",
            pServerInfo->dwDsForestVersion,
            pServerInfo->dwDsDomainVersion,
            pServerInfo->dwDsDsaVersion );
        #endif

        if ( pServerInfo->dwLastScavengeTime )
        {
            time_t t = pServerInfo->dwLastScavengeTime;
            strcpy( szTime, ctime( &t ) );
            szTime[ strlen( szTime ) - 1 ] = '\0';
        }
        PrintRoutine( pPrintContext,
            "\tlast scavenge cycle      = %s (%d)\n",
            szTime,
            pServerInfo->dwLastScavengeTime );


        PrintRoutine( pPrintContext,
            "  Configuration:\n"
            "\tdwLogLevel               = %p\n"
            "\tdwDebugLevel             = %p\n"
            "\tdwRpcProtocol            = %p\n"
            "\tdwNameCheckFlag          = %p\n"
            "\tcAddressAnswerLimit      = %d\n"
            "\tdwRecursionRetry         = %d\n"
            "\tdwRecursionTimeout       = %d\n"
            "\tdwDsPollingInterval      = %d\n",
            pServerInfo->dwLogLevel,
            pServerInfo->dwDebugLevel,
            pServerInfo->dwRpcProtocol,
            pServerInfo->dwNameCheckFlag,
            pServerInfo->cAddressAnswerLimit,
            pServerInfo->dwRecursionRetry,
            pServerInfo->dwRecursionTimeout,
            pServerInfo->dwDsPollingInterval );

        PrintRoutine( pPrintContext,
            "  Configuration Flags:\n"
            "\tfBootMethod                  = %d\n"
            "\tfAdminConfigured             = %d\n"
            "\tfAllowUpdate                 = %d\n"
            "\tfDsAvailable                 = %d\n"
            "\tfAutoReverseZones            = %d\n"
            "\tfAutoCacheUpdate             = %d\n"
            "\tfSlave                       = %d\n"
            "\tfNoRecursion                 = %d\n"
            "\tfRoundRobin                  = %d\n"
            "\tfStrictFileParsing           = %d\n"
            "\tfLooseWildcarding            = %d\n"
            "\tfBindSecondaries             = %d\n"
            "\tfWriteAuthorityNs            = %d\n"
            "\tfLocalNetPriority            = %d\n",
            pServerInfo->fBootMethod,
            pServerInfo->fAdminConfigured,
            pServerInfo->fAllowUpdate,
            pServerInfo->fDsAvailable,
            pServerInfo->fAutoReverseZones,
            pServerInfo->fAutoCacheUpdate,
            pServerInfo->fSlave,
            pServerInfo->fNoRecursion,
            pServerInfo->fRoundRobin,
            pServerInfo->fStrictFileParsing,
            pServerInfo->fLooseWildcarding,
            pServerInfo->fBindSecondaries,
            pServerInfo->fWriteAuthorityNs,
            pServerInfo->fLocalNetPriority );

        PrintRoutine(
            pPrintContext,
            "  Aging Configuration:\n"
            "\tScavengingInterval           = %d\n"
            "\tDefaultAgingState            = %d\n"
            "\tDefaultRefreshInterval       = %d\n"
            "\tDefaultNoRefreshInterval     = %d\n",
            pServerInfo->dwScavengingInterval,
            pServerInfo->fDefaultAgingState,
            pServerInfo->dwDefaultRefreshInterval,
            pServerInfo->dwDefaultNoRefreshInterval
            );

        DnsPrint_Ip4Array(
            PrintRoutine,
            pPrintContext,
            "  ServerAddresses:\n",
            "\tAddr",
            pServerInfo->aipServerAddrs );

        DnsPrint_Ip4Array(
            PrintRoutine,
            pPrintContext,
            "  ListenAddresses:\n",
            "\tAddr",
            pServerInfo->aipListenAddrs );

        DnsPrint_Ip4Array(
            PrintRoutine,
            pPrintContext,
            "  Forwarders:\n",
            "\tAddr",
            pServerInfo->aipForwarders );

        PrintRoutine(
            pPrintContext,
            "\tforward timeout  = %d\n"
            "\tslave            = %d\n",
            pServerInfo->dwForwardTimeout,
            pServerInfo->fSlave );
    }
    DnsPrint_Unlock();

    FREE_HEAP( pnameServer );
    FREE_HEAP( pnameForest );
    FREE_HEAP( pnameDomain );
    FREE_HEAP( pnameForestDp );
    FREE_HEAP( pnameDomainDp );
}



//
//  Print zone Zone debug utilities
//

PSTR
truncateStringA(
    PSTR        pszSource,
    PSTR        pszDest,
    int         iDestLength )
{
    if ( pszSource )
    {
        int     len = strlen( pszSource );

        if ( len < iDestLength )
        {
            strcpy( pszDest, pszSource );
        }
        else
        {
            strncpy( pszDest, pszSource, iDestLength - 4 );
            strcpy( pszDest + iDestLength - 4, "..." );
        }
    }
    else
    {
        *pszDest = '\0';
    }
    return pszDest;
}


PWSTR
truncateStringW(
    PWSTR       pwszSource,
    PWSTR       pwszDest,
    int         iDestLength )
{
    if ( pwszSource )
    {
        int     len = wcslen( pwszSource );

        if ( len < iDestLength )
        {
            wcscpy( pwszDest, pwszSource );
        }
        else
        {
            wcsncpy( pwszDest, pwszSource, iDestLength - 4 );
            wcscpy( pwszDest + iDestLength - 4, L"..." );
            pwszDest[ iDestLength - 1 ] = '\0';
        }
    }
    else
    {
        *pwszDest = L'\0';
    }
    return pwszDest;
}


#define DNS_DPDISP_REAL_CUSTOM_NAME         0x0001
#define DNS_DPDISP_BLANK_STRING_FOR_LEGACY  0x0002


LPSTR
partitionDisplayName(
    IN      DWORD           dwPartitionFlags,
    IN      LPSTR           pszPartitionFqdn,
    IN      DWORD           dwNameBuffLen,
    OUT     LPSTR           pszNameBuff,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Formats directory partition for display. If the flags indicate that
    the partition is a built-in partition, the name will be substituted
    for a descriptive string.

Arguments:
    
    dwPartitionFlags -- DP flags from the DNS server

    pszPartitionFqdn -- FQDN of the partition

    dwNameBuffLen -- length of the output name buffer

    pszNameBuff -- pointer to the output name buffer

    dwFlags - use DNS_DPDISP_XXX constants

Return Value:

    Pointer to pszNameBuff

--*/
{
    //
    //  Substitute name if this is a built-in partition.
    //

    if ( dwPartitionFlags & DNS_DP_DOMAIN_DEFAULT )
    {
        pszPartitionFqdn = "AD-Domain";
    }
    else if ( dwPartitionFlags & DNS_DP_FOREST_DEFAULT )
    {
        pszPartitionFqdn = "AD-Forest";
    }
    else if ( dwPartitionFlags & DNS_DP_LEGACY || !pszPartitionFqdn )
    {
        pszPartitionFqdn =
            ( dwFlags & DNS_DPDISP_BLANK_STRING_FOR_LEGACY ) ? "" : "AD-Legacy";
    }
    else if ( !( dwFlags & DNS_DPDISP_REAL_CUSTOM_NAME ) )
    {
        pszPartitionFqdn = "AD-Custom";
    }

    truncateStringA( pszPartitionFqdn, pszNameBuff, dwNameBuffLen );

    return pszNameBuff;
}   //  partitionDisplayName



LPSTR
zoneTypeString(
    IN      DWORD           dwZoneType,
    IN      DWORD           dwOutBuffLen,
    OUT     LPSTR           pszOutBuff
    )
/*++

Routine Description:

    Convert DWORD zone type into display string.

Arguments:
    
    dwZoneType -- zone type

    dwOutBuffLen -- length of the output name buffer

    pszOutBuff -- pointer to the output name buffer

Return Value:

    Pointer to pszOutBuff

--*/
{
    PSTR        pszZoneType = NULL;
    CHAR        szBuff[ 10 ];

    switch ( dwZoneType )
    {
        case DNS_ZONE_TYPE_CACHE:
            pszZoneType = "Cache";
            break;
        case DNS_ZONE_TYPE_PRIMARY:
            pszZoneType = "Primary";
            break;
        case DNS_ZONE_TYPE_SECONDARY:
            pszZoneType = "Secondary";
            break;
        case DNS_ZONE_TYPE_STUB:
            pszZoneType = "Stub";
            break;
        case DNS_ZONE_TYPE_FORWARDER:
            pszZoneType = "Forwarder";
            break;
        default:
            _itoa( dwZoneType, szBuff, 10 );
            pszZoneType = szBuff;
            break;
    }

    truncateStringA( pszZoneType, pszOutBuff, dwOutBuffLen );

    return pszOutBuff;
}   //  zoneTypeString


VOID
DnsPrint_RpcZone(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_RPC_ZONE   pZone
    )
{
    PWSTR   pnamePartition = NULL;

    DnsPrint_Lock();

    if ( ! pZone )
    {
        PrintRoutine( pPrintContext,
            "%sNULL zone info ptr.\n",
            ( pszHeader ? pszHeader : "" ) );
    }
    else
    {
        CHAR        szpartition[ 15 ];
        CHAR        sztype[ 10 ];


        //  print zone per line

        if ( pszHeader && *pszHeader )
        {
            PrintRoutine( pPrintContext,
                "%s\n",
                pszHeader ? pszHeader : "" );
        }

        PrintRoutine( pPrintContext, " %-30S", pZone->pszZoneName );

        if ( pZone->Flags.DsIntegrated )
        {
            partitionDisplayName(
                pZone->dwDpFlags,
                pZone->pszDpFqdn,
                sizeof( szpartition ),
                szpartition,
                0 );
        }
        else
        {
            strcpy( szpartition, "File" );
        }

        pnamePartition = getUnicodeForUtf8( szpartition );

        PrintRoutine( pPrintContext,
            " %-9s  %-14S  %s%s%s%s%s%s\n",
            zoneTypeString(
                pZone->ZoneType,
                sizeof( sztype ),
                sztype ),
            pnamePartition,     // szpartition,
            pZone->Flags.Update == 2 ?
                "Secure " :
                ( pZone->Flags.Update == 1 ?
                    "Update " : "" ),
            pZone->Flags.Reverse        ? "Rev "     : "",
            pZone->Flags.AutoCreated    ? "Auto "    : "",
            pZone->Flags.Aging          ? "Aging "   : "",
            pZone->Flags.Paused         ? "Paused "  : "",
            pZone->Flags.Shutdown       ? "Down "    : "" );
    }

    DnsPrint_Unlock();

    FREE_HEAP( pnamePartition );
}



VOID
DNS_API_FUNCTION
DnsPrint_RpcZoneList(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_ZONE_LIST  pZoneList
    )
{
    DWORD   i;

    DnsPrint_Lock();
    if ( pszHeader )
    {
        PrintRoutine( pPrintContext, "%s\n", pszHeader );
    }

    if ( !pZoneList )
    {
        PrintRoutine( pPrintContext, "NULL zone list pointer.\n" );
    }
    else
    {
        PrintRoutine( pPrintContext, "\tZone count = %d\n\n", pZoneList->dwZoneCount );

        PrintRoutine( pPrintContext,
            " Zone name                      Type       Storage         Properties\n\n" );

        if ( pZoneList->dwZoneCount )
        {
            DnsPrint_RpcZone(
                PrintRoutine, pPrintContext,
                NULL,   //  print default header
                pZoneList->ZoneArray[0] );
        }

        for ( i=1; i<pZoneList->dwZoneCount; i++ )
        {
            DnsPrint_RpcZone(
                PrintRoutine, pPrintContext,
                NULL,   //  print default header
                pZoneList->ZoneArray[i] );
        }
        PrintRoutine( pPrintContext, "\n" );
    }
    DnsPrint_Unlock();
}



//
//  Directory parition debug utilities
//


VOID
DnsPrint_RpcDpEnum(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_DP_ENUM    pDp
    )
{
    PWSTR   pnameDpFqdn = NULL;

    if ( !pDp )
    {
        PrintRoutine( pPrintContext, "NULL DP enum ptr\n" );
    }
    else
    {
        pnameDpFqdn = getUnicodeForUtf8( pDp->pszDpFqdn );

        PrintRoutine( pPrintContext,
            " %-40S  %s%s%s%s%s%s\n",
            pnameDpFqdn,    // pDp->pszDpFqdn,
            pDp->dwFlags & DNS_DP_ENLISTED            ? "Enlisted "   : "Not-Enlisted ",
            pDp->dwFlags & DNS_DP_DELETED             ? "Deleted "    : "",
            pDp->dwFlags & DNS_DP_AUTOCREATED         ? "Auto "       : "",
            pDp->dwFlags & DNS_DP_LEGACY              ? "Legacy "     : "",
            pDp->dwFlags & DNS_DP_DOMAIN_DEFAULT      ? "Domain "     : "",
            pDp->dwFlags & DNS_DP_FOREST_DEFAULT      ? "Forest " : "" );
    }

    FREE_HEAP( pnameDpFqdn );
}   //  DnsPrint_RpcDpEnum


VOID
DnsPrint_RpcDpInfo(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_DP_INFO    pDp,
    IN      BOOL                fTruncateLongStrings
    )
{
    PWSTR   pnameDpFqdn = NULL;

    DnsPrint_Lock();
    if ( !pDp )
    {
        PrintRoutine( pPrintContext,
            "%sNULL DP info ptr.\n",
            ( pszHeader ? pszHeader : "" ) );
    }
    else
    {
        WCHAR   wsz[ 80 ];

        pnameDpFqdn = getUnicodeForUtf8( pDp->pszDpFqdn );

        PrintRoutine( pPrintContext,
            "%s\n"
            "  DNS root:   %S\n"
            "  Flags:      0x%X %s%s%s%s%s%s\n"
            "  State:      %d\n"
            "  Zone count: %d\n"
            "  DP head:    %S\n"
            "  Crossref:   ",
            pszHeader ? pszHeader : "",
            pnameDpFqdn,    // pDp->pszDpFqdn,
            pDp->dwFlags,
            pDp->dwFlags & DNS_DP_ENLISTED            ? "Enlisted "   : "Not-Enlisted ",
            pDp->dwFlags & DNS_DP_DELETED             ? "Deleted "    : "",
            pDp->dwFlags & DNS_DP_AUTOCREATED         ? "Auto "       : "",
            pDp->dwFlags & DNS_DP_LEGACY              ? "Legacy "     : "",
            pDp->dwFlags & DNS_DP_DOMAIN_DEFAULT      ? "Domain "     : "",
            pDp->dwFlags & DNS_DP_FOREST_DEFAULT      ? "Forest " : "",
            pDp->dwState,
            pDp->dwZoneCount,
            pDp->pszDpDn,
            pDp->pszCrDn );

        if ( fTruncateLongStrings )
        {
            truncateStringW( pDp->pszCrDn, wsz, 64 );
            PrintRoutine( pPrintContext, "%S", wsz );
        }
        else
        {
            PrintRoutine( pPrintContext, "%S", pDp->pszCrDn );
        }

        PrintRoutine( pPrintContext,
            "\n  Replicas:   %d\n",
            pDp->dwReplicaCount );

        if ( pDp->dwReplicaCount && pDp->ReplicaArray )
        {
            DWORD   i;
            
            for ( i = 0;
                i < pDp->dwReplicaCount && pDp->ReplicaArray[ i ];
                ++i )
            {
                if ( fTruncateLongStrings )
                {
                    truncateStringW(
                        pDp->ReplicaArray[ i ]->pszReplicaDn,
                        wsz,
                        74 );
                    PrintRoutine( pPrintContext, "    %S\n", wsz );
                }
                else
                {
                    PrintRoutine( pPrintContext, "    %S\n", 
                        pDp->ReplicaArray[ i ]->pszReplicaDn ?
                            pDp->ReplicaArray[ i ]->pszReplicaDn : L"NULL" );
                }
            }
        }
    }
    DnsPrint_Unlock();

    FREE_HEAP( pnameDpFqdn );
}   //  DnsPrint_RpcDpInfo



VOID
DNS_API_FUNCTION
DnsPrint_RpcDpList(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pPrintContext,
    IN      LPSTR                   pszHeader,
    IN      PDNS_RPC_DP_LIST        pDpList
    )
{
    DWORD   i;

    DnsPrint_Lock();
    if ( pszHeader )
    {
        PrintRoutine( pPrintContext, "%s\n", pszHeader );
    }

    if ( !pDpList )
    {
        PrintRoutine( pPrintContext, "NULL directory partition list pointer.\n" );
    }
    else
    {
        PrintRoutine( pPrintContext, "\tDirectory partition count = %d\n\n", pDpList->dwDpCount );

        for ( i = 0; i < pDpList->dwDpCount && pDpList->DpArray[ i ]; ++i )
        {
            DnsPrint_RpcDpEnum(
                PrintRoutine, pPrintContext,
                NULL,   //  print default header
                pDpList->DpArray[ i ] );
        }

        PrintRoutine( pPrintContext, "\n" );
    }
    DnsPrint_Unlock();
}   //  DnsPrint_RpcDpList



VOID
DnsPrint_RpcZoneInfo(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_ZONE_INFO  pZoneInfo
    )
{
    CHAR    szdpName[ 300 ];        //  don't want truncation
    PWSTR   pnameZone = NULL;
    PWSTR   pnameFile = NULL;
    PWSTR   pnameDp = NULL;

    DnsPrint_Lock();
    PrintRoutine( pPrintContext, (pszHeader ? pszHeader : "") );

    if ( ! pZoneInfo )
    {
        PrintRoutine( pPrintContext, "NULL zone info ptr.\n" );
    }
    else
    {
        pnameZone = getUnicodeForUtf8( pZoneInfo->pszZoneName );
        pnameFile = getUnicodeForUtf8( pZoneInfo->pszDataFile );

        PrintRoutine( pPrintContext,
            "Zone info:\n"
            "\tptr                   = %p\n"
            "\tzone name             = %S\n"
            "\tzone type             = %d\n"
            "\tupdate                = %d\n"
            "\tDS integrated         = %d\n"
            "\tdata file             = %S\n"
            "\tusing WINS            = %d\n"
            "\tusing Nbstat          = %d\n"
            "\taging                 = %d\n"
            "\t  refresh interval    = %lu\n"
            "\t  no refresh          = %lu\n"
            "\t  scavenge available  = %lu\n",
            pZoneInfo,
            pnameZone,  // pZoneInfo->pszZoneName,
            pZoneInfo->dwZoneType,
            pZoneInfo->fAllowUpdate,
            pZoneInfo->fUseDatabase,
            pnameFile,  // pZoneInfo->pszDataFile,
            pZoneInfo->fUseWins,
            pZoneInfo->fUseNbstat,
            pZoneInfo->fAging,
            pZoneInfo->dwRefreshInterval,
            pZoneInfo->dwNoRefreshInterval,
            pZoneInfo->dwAvailForScavengeTime
            );

        DnsPrint_Ip4Array(
            PrintRoutine, pPrintContext,
            "\tZone Masters\n",
            "\tMaster",
            pZoneInfo->aipMasters );

        if ( pZoneInfo->dwZoneType == DNS_ZONE_TYPE_STUB )
        {
            DnsPrint_Ip4Array(
                PrintRoutine, pPrintContext,
                "\tZone Local Masters\n",
                "\tLocal Master",
                pZoneInfo->aipLocalMasters );
        }

        DnsPrint_Ip4Array(
            PrintRoutine, pPrintContext,
            "\tZone Secondaries\n",
            "\tSecondary",
            pZoneInfo->aipSecondaries );

        PrintRoutine( pPrintContext,
            "\tsecure secs           = %d\n",
            pZoneInfo->fSecureSecondaries );

        if ( pZoneInfo->fUseDatabase )
        {
            partitionDisplayName(
                pZoneInfo->dwDpFlags,
                pZoneInfo->pszDpFqdn,
                sizeof( szdpName ),
                szdpName,
                DNS_DPDISP_REAL_CUSTOM_NAME ),

            pnameDp = getUnicodeForUtf8( szdpName );

            PrintRoutine( pPrintContext,
                "\tdirectory partition   = %S     flags %08X\n"
                "\tzone DN               = %S\n",
                pnameDp,
                pZoneInfo->dwDpFlags,
                pZoneInfo->pwszZoneDn );
        }

        if ( pZoneInfo->aipScavengeServers )
        {
            DnsPrint_Ip4Array(
                PrintRoutine, pPrintContext,
                "\tScavenge Servers\n",
                "\tServer",
                pZoneInfo->aipScavengeServers );
        }

        if ( pZoneInfo->dwZoneType == DNS_ZONE_TYPE_FORWARDER )
        {
            PrintRoutine( pPrintContext,
                "\tforwarder timeout  = %d\n"
                "\tforwarder slave    = %d\n",
                pZoneInfo->dwForwarderTimeout,
                pZoneInfo->fForwarderSlave );
        }

        if ( pZoneInfo->dwZoneType == DNS_ZONE_TYPE_SECONDARY ||
            pZoneInfo->dwZoneType == DNS_ZONE_TYPE_STUB )
        {
            char        szTime1[ 60 ] = DNS_NOT_PERFORMED;
            char        szTime2[ 60 ] = DNS_NOT_PERFORMED;

            if ( pZoneInfo->dwLastSuccessfulXfr )
            {
                time_t t = pZoneInfo->dwLastSuccessfulXfr;
                strcpy( szTime1, ctime( &t ) );
                szTime1[ strlen( szTime1 ) - 1 ] = '\0';
            }
            if ( pZoneInfo->dwLastSuccessfulSoaCheck )
            {
                time_t t = pZoneInfo->dwLastSuccessfulSoaCheck;
                strcpy( szTime2, ctime( &t ) );
                szTime2[ strlen( szTime2 ) - 1 ] = '\0';
            }
            PrintRoutine( pPrintContext,
                "\tlast successful xfr   = %s (%d)\n"
                "\tlast SOA check        = %s (%d)\n",
                szTime1,
                pZoneInfo->dwLastSuccessfulXfr,
                szTime2,
                pZoneInfo->dwLastSuccessfulSoaCheck );
        }
    }
    DnsPrint_Unlock();

    FREE_HEAP( pnameZone );
    FREE_HEAP( pnameFile );
    FREE_HEAP( pnameDp );
}



VOID
DnsPrint_RpcZoneInfoList(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      DWORD               dwZoneCount,
    IN      PDNS_RPC_ZONE_INFO  apZoneInfo[]
    )
{
    DWORD i;

    DnsPrint_Lock();
    PrintRoutine( pPrintContext, (pszHeader ? pszHeader : "") );
    PrintRoutine( pPrintContext, "Zone Count = %d\n", dwZoneCount );

    if ( dwZoneCount != 0  &&  apZoneInfo != NULL )
    {
        for (i=0; i<dwZoneCount; i++)
        {
            DnsPrint_RpcZoneInfo(
                PrintRoutine, pPrintContext,
                NULL,
                apZoneInfo[i] );
        }
    }
    DnsPrint_Unlock();
}



//
//  Print domain node and record buffers
//

VOID
DnssrvCopyRpcNameToBuffer(
    IN      PSTR            pResult,
    IN      PDNS_RPC_NAME   pName
    )
/*++

Routine Description:

    Copy RPC name to buffer.

Arguments:

    pResult -- result buffer;  assumed to be at least DNS_MAX_NAME_LENGTH

    pName -- RPC name

Return Value:

    None

--*/
{
    DWORD length = pName->cchNameLength;

    strncpy( pResult, pName->achName, length );

    pResult[ length ] = 0;
}



VOID
DnsPrint_RpcName(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_RPC_NAME   pName,
    IN      LPSTR           pszTrailer
    )
/*++

Routine Description:

    Prints RPC name.

Arguments:

    PrintRoutine -- printf like routine to print with

    pszHeader -- header string

    pName -- RPC name

    pszTrailer -- trailer string

Return Value:

    None

--*/
{
    PWSTR       pname = NULL;
    PWSTR       pnameAlloc = NULL;

    //
    //  print name to given length
    //

    if ( !pszHeader )
    {
        pszHeader = "";
    }
    if ( !pszTrailer )
    {
        pszTrailer = "";
    }

    if ( ! pName )
    {
        pname = L"(NULL DNS name ptr)";
    }
    else if ( pName->cchNameLength > 0 )
    {
        pname = pnameAlloc = utf8ToUnicode( pName->achName, pName->cchNameLength );
        if ( !pname )
        {
            pname = L"<OUT OF MEMORY>";
        }
    }
    else    // @ for empty node name
    {
        pname = L"@";
    }

    PrintRoutine( pPrintContext,
        "%s%S%s",
        pszHeader,
        pname,
        pszTrailer );

    FREE_HEAP( pnameAlloc );
}



VOID
DnsPrint_RpcNode(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_RPC_NODE   pNode
    )
/*++

Routine Description:

    Prints RPC node.

Arguments:

    PrintRoutine -- printf like routine to print with

    pszHeader -- header string

    pNode -- RPC node to print

Return Value:

    None

--*/
{
    DnsPrint_Lock();

    PrintRoutine( pPrintContext, (pszHeader ? pszHeader : "RPC Node:") );

    if ( ! pNode )
    {
        PrintRoutine( pPrintContext, "NULL RPC node ptr.\n" );
    }
    else
    {
        PrintRoutine( pPrintContext,
            "\n"
            "\tptr          = %p\n"
            "\twLength      = %d\n"
            "\twRecordCount = %d\n"
            "\tdwChildCount = %d\n"
            "\tdwFlags      = %p\n",
            pNode,
            pNode->wLength,
            pNode->wRecordCount,
            pNode->dwChildCount,
            pNode->dwFlags );

        DnsPrint_RpcName(
            PrintRoutine,
            pPrintContext,
            "\tNode Name    = ",
            & pNode->dnsNodeName,
            "\n" );
    }

    DnsPrint_Unlock();
}

VOID
DnsPrint_RpcRecord(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      BOOL                fDetail,
    IN      PDNS_FLAT_RECORD    pRecord
    )
/*++

Routine Description:

    Prints RPC record.

Arguments:

    PrintRoutine -- printf like routine to print with

    pszHeader -- header string

    fDetail -- if TRUE print detailed record info

    pRecord -- RPC record to print

Return Value:

    None

--*/
{
    PCHAR                   ptypeString;
    PDNS_RPC_RECORD_DATA    pdata;
    WORD                    type;
    WORD                    dataLength;
    SYSTEMTIME              sysTime;
    CHAR                    szBuff[ 5000 ];

    DnsPrint_Lock();
    PrintRoutine( pPrintContext, (pszHeader ? pszHeader : "" ) );

    if ( ! pRecord )
    {
        PrintRoutine( pPrintContext, "NULL record ptr.\n" );
        goto Done;
    }

    //
    //  record fixed fields
    //

    type = pRecord->wType;
    ptypeString = Dns_RecordStringForType( type );
    if ( !ptypeString )
    {
        ptypeString = "UNKNOWN";
    }
    pdata = &pRecord->Data;
    dataLength = pRecord->wDataLength;

    if ( fDetail )
    {
        Dns_SystemHourToSystemTime(
             pRecord->dwTimeStamp,
             &sysTime );

        PrintRoutine( pPrintContext,
            "  %s Record info:\n"
            "\tptr          = %p\n"
            "\twType        = %s (%u)\n"
            "\twDataLength  = %u\n"
            "\tdwFlags      = %lx\n"
            "\trank         = %x\n"
            "\tdwSerial     = %p\n"
            "\tdwTtlSeconds = %u\n"
            "\tdwTimeStamp  = %lu ([%2d:%2d:%2d] [%2d/%2d/%2d])\n",
            ptypeString,
            pRecord,
            ptypeString,
            type,
            pRecord->wDataLength,
            pRecord->dwFlags,
            (UCHAR)(pRecord->dwFlags & DNS_RPC_FLAG_RANK),
            pRecord->dwSerial,
            pRecord->dwTtlSeconds,
            pRecord->dwTimeStamp,
            sysTime.wHour,
            sysTime.wMinute,
            sysTime.wSecond,
            sysTime.wMonth,
            sysTime.wDay,
            sysTime.wYear
            );
    }
    
    //
    //  print record type and data
    //      - as single line data where possible

    if ( !fDetail )
    {
        if ( pRecord->dwTimeStamp )
        {
            PrintRoutine( pPrintContext,
                " [Aging:%lu]",
                pRecord->dwTimeStamp );
        }
        PrintRoutine( pPrintContext,
            " %lu",
            pRecord->dwTtlSeconds );
    }

    PrintRoutine( pPrintContext,
        " %s\t",
        ptypeString );

    //
    //  print type data
    //

    switch ( type )
    {
    case DNS_TYPE_A:

        PrintRoutine( pPrintContext,
            "%d.%d.%d.%d\n",
            * ( (PUCHAR) &(pdata->A) + 0 ),
            * ( (PUCHAR) &(pdata->A) + 1 ),
            * ( (PUCHAR) &(pdata->A) + 2 ),
            * ( (PUCHAR) &(pdata->A) + 3 )
            );
        break;

    case DNS_TYPE_PTR:
    case DNS_TYPE_NS:
    case DNS_TYPE_CNAME:
    case DNS_TYPE_MD:
    case DNS_TYPE_MB:
    case DNS_TYPE_MF:
    case DNS_TYPE_MG:
    case DNS_TYPE_MR:

        //
        //  these RRs contain single indirection
        //

        DnsPrint_RpcName(
            PrintRoutine, pPrintContext,
            NULL,
            & pdata->NS.nameNode,
            "\n" );
        break;

    case DNS_TYPE_MX:
    case DNS_TYPE_RT:
    case DNS_TYPE_AFSDB:

        //
        //  these RR contain
        //      - one preference value
        //      - one domain name
        //

        PrintRoutine( pPrintContext,
            "%d ",
            pdata->MX.wPreference
            );
        DnsPrint_RpcName(
            PrintRoutine, pPrintContext,
            NULL,
            & pdata->MX.nameExchange,
            "\n" );
        break;

    case DNS_TYPE_SOA:

        if ( fDetail )
        {
            DnsPrint_RpcName(
                PrintRoutine, pPrintContext,
                "\n\tPrimaryNameServer: ",
                & pdata->SOA.namePrimaryServer,
                "\n" );

            //  responsible party name, immediately follows primary server name

            DnsPrint_RpcName(
                PrintRoutine, pPrintContext,
                "\tResponsibleParty: ",
                (PDNS_RPC_NAME)
                    (pdata->SOA.namePrimaryServer.achName
                    + pdata->SOA.namePrimaryServer.cchNameLength),
                "\n" );

            PrintRoutine( pPrintContext,
                "\tSerialNo     = %lu\n"
                "\tRefresh      = %lu\n"
                "\tRetry        = %lu\n"
                "\tExpire       = %lu\n"
                "\tMinimumTTL   = %lu\n",
                pdata->SOA.dwSerialNo,
                pdata->SOA.dwRefresh,
                pdata->SOA.dwRetry,
                pdata->SOA.dwExpire,
                pdata->SOA.dwMinimumTtl );
            break;
        }
        else
        {
            DnsPrint_RpcName(
                PrintRoutine, pPrintContext,
                NULL,
                & pdata->SOA.namePrimaryServer,
                NULL );

            //  responsible party name, immediately follows primary server name

            DnsPrint_RpcName(
                PrintRoutine, pPrintContext,
                " ",
                (PDNS_RPC_NAME)
                    (pdata->SOA.namePrimaryServer.achName
                    + pdata->SOA.namePrimaryServer.cchNameLength),
                NULL );

            PrintRoutine( pPrintContext,
                " %lu"
                " %lu"
                " %lu"
                " %lu"
                " %lu\n",
                pdata->SOA.dwSerialNo,
                pdata->SOA.dwRefresh,
                pdata->SOA.dwRetry,
                pdata->SOA.dwExpire,
                pdata->SOA.dwMinimumTtl );
            break;
        }

    case DNS_TYPE_AAAA:

        {
            CHAR    ip6String[ IP6_ADDRESS_STRING_LENGTH+1 ];

            Dns_Ip6AddressToString_A(
                ip6String,
                &pdata->AAAA.ipv6Address
                );

            PrintRoutine( pPrintContext,
                "%s\n",
                ip6String );
        }
        break;

    case DNS_TYPE_HINFO:
    case DNS_TYPE_ISDN:
    case DNS_TYPE_X25:
    case DNS_TYPE_TEXT:
    {
        //
        //  all these are simply text string(s)
        //
        //  TXT strings will be printed one per line
        //

        PCHAR   pch = (PCHAR) &pdata->TXT.stringData;
        PCHAR   pchStop = pch + dataLength;
        UCHAR   cch;

        while ( pch < pchStop )
        {
            cch = (UCHAR) *pch++;

            if ( type == DNS_TYPE_TEXT )
            {
                PrintRoutine( pPrintContext,
                    "\t%.*s\n",
                     cch,
                     pch );
            }
            else
            {
                PrintRoutine( pPrintContext,
                    "\"%.*s\" ",
                     cch,
                     pch );
            }
            pch += cch;
        }

        if ( type != DNS_TYPE_TEXT )
        {
            PrintRoutine( pPrintContext,"\n");
        }

        ASSERT( pch == pchStop );
        break;
    }

    case DNS_TYPE_MINFO:
    case DNS_TYPE_RP:

        //
        //  these RRs contain two domain names
        //

        DnsPrint_RpcName(
            PrintRoutine, pPrintContext,
            NULL,
            & pdata->MINFO.nameMailBox,
            NULL );

        //  errors to mailbox name, immediately follows mail box

        DnsPrint_RpcName(
            PrintRoutine, pPrintContext,
            " ",
            (PDNS_RPC_NAME)
            ( pdata->MINFO.nameMailBox.achName
                + pdata->MINFO.nameMailBox.cchNameLength ),
            "\n" );
        break;


    case DNS_TYPE_WKS:
    {
        INT i;

        if ( fDetail )
        {
            PrintRoutine( pPrintContext,
                "WKS: Address %d.%d.%d.%d\n"
                "\tProtocol %d\n"
                "\tBitmask\n",
                * ( (PUCHAR) &(pdata->WKS.ipAddress) + 0 ),
                * ( (PUCHAR) &(pdata->WKS.ipAddress) + 1 ),
                * ( (PUCHAR) &(pdata->WKS.ipAddress) + 2 ),
                * ( (PUCHAR) &(pdata->WKS.ipAddress) + 3 ),
                pdata->WKS.chProtocol
                );

            for ( i = 0;
                    i < (INT)( dataLength
                                 - sizeof( pdata->WKS.ipAddress )
                                 - sizeof( pdata->WKS.chProtocol ) );
                        i++ )
            {
                PrintRoutine( pPrintContext,
                    "\t\tbyte[%d] = %x\n",
                    i,
                    (UCHAR) pdata->WKS.bBitMask[i] );
            }
            break;
        }

        else
        {
            DNS_STATUS              status;
            struct protoent *       pProtoent;
            WSADATA                 wsaData;

            PrintRoutine( pPrintContext,
                "%d.%d.%d.%d ",
                * ( (PUCHAR) &(pdata->WKS.ipAddress) + 0 ),
                * ( (PUCHAR) &(pdata->WKS.ipAddress) + 1 ),
                * ( (PUCHAR) &(pdata->WKS.ipAddress) + 2 ),
                * ( (PUCHAR) &(pdata->WKS.ipAddress) + 3 )
                );

            //
            //  get protocol number:
            //

            //  start winsock:
            status = WSAStartup( DNS_WINSOCK_VERSION, &wsaData );
            if ( status == SOCKET_ERROR )
            {
                status = WSAGetLastError();
                SetLastError( status );
                PrintRoutine( pPrintContext,
                    "ERROR: WSAGetLastError()\n"
                    );

                ASSERT(FALSE);
            }

            pProtoent = getprotobynumber( pdata->WKS.chProtocol );

            if ( ! pProtoent || pProtoent->p_proto >= MAXUCHAR )
            {
                status = WSAGetLastError();
                SetLastError( status );
                PrintRoutine( pPrintContext, "ERROR: getprotobyname()\n" );
                ASSERT(FALSE);
            }

            PrintRoutine( pPrintContext,
                "%s\t",
                pProtoent->p_name
                );

            //bBitMask[0] : string length, not printed:
            for ( i = 1;
                    i < (INT)( dataLength
                                 - sizeof( pdata->WKS.ipAddress )
                                 - sizeof( pdata->WKS.chProtocol ) );
                        i++ )
            {
                PrintRoutine( pPrintContext,
                    "%c",
                    (UCHAR) pdata->WKS.bBitMask[i] );
            }
            PrintRoutine( pPrintContext,"\n");
            break;
        }
    }

    case DNS_TYPE_NULL:
    {
        INT i;

        for ( i = 0; i < dataLength; i++ )
        {
            //  print one DWORD per line

            if ( !(i%16) )
            {
                PrintRoutine( pPrintContext, "\n\t" );
            }
            PrintRoutine( pPrintContext,
                "%02x ",
                (UCHAR) pdata->Null.bData[i] );
        }
        PrintRoutine( pPrintContext, "\n" );
        break;
    }

    case DNS_TYPE_SRV:

        //
        //  SRV <priority> <weight> <port> <target host>
        //

        PrintRoutine( pPrintContext,
            "%d %d %d ",
            pdata->SRV.wPriority,
            pdata->SRV.wWeight,
            pdata->SRV.wPort
            );
        DnsPrint_RpcName(
            PrintRoutine, pPrintContext,
            NULL,
            & pdata->SRV.nameTarget,
            "\n" );
        break;

    case DNS_TYPE_WINS:
    {
        DWORD   i;
        CHAR    flagName[ WINS_FLAG_MAX_LENGTH ];

        //
        //  WINS
        //      - scope/domain mapping flag
        //      - WINS server list
        //

        Dns_WinsRecordFlagString(
            pdata->WINS.dwMappingFlag,
            flagName );

        PrintRoutine( pPrintContext,
            "%s %d %d ",
            flagName,
            //pdata->WINS.dwMappingFlag,
            pdata->WINS.dwLookupTimeout,
            pdata->WINS.dwCacheTimeout
            );

        if ( fDetail )
        {
            PrintRoutine( pPrintContext, "  WINS Servers:\n" );
        }

        for( i=0; i<pdata->WINS.cWinsServerCount; i++ )
        {
            PrintRoutine( pPrintContext,
                "%d.%d.%d.%d%c",
                * ( (PUCHAR) &(pdata->WINS.aipWinsServers[i]) + 0 ),
                * ( (PUCHAR) &(pdata->WINS.aipWinsServers[i]) + 1 ),
                * ( (PUCHAR) &(pdata->WINS.aipWinsServers[i]) + 2 ),
                * ( (PUCHAR) &(pdata->WINS.aipWinsServers[i]) + 3 ),
                fDetail ? '\n' : ' '
                );
        }
        if ( !fDetail )
        {
            PrintRoutine( pPrintContext, "\n" );
        }
        break;
    }

    case DNS_TYPE_NBSTAT:
    {
        CHAR    flagName[ WINS_FLAG_MAX_LENGTH ];

        //
        //  NBSTAT
        //      - scope/domain mapping flag
        //      - optionally a result domain
        //

        Dns_WinsRecordFlagString(
            pdata->WINS.dwMappingFlag,
            flagName );

        PrintRoutine( pPrintContext,
            "%s %d %d ",
            flagName,
            //pdata->WINS.dwMappingFlag,
            pdata->NBSTAT.dwLookupTimeout,
            pdata->NBSTAT.dwCacheTimeout
            );

        if ( dataLength > sizeof(pdata->NBSTAT.dwMappingFlag) )
        {
            DnsPrint_RpcName(
                PrintRoutine, pPrintContext,
                NULL,
                & pdata->NBSTAT.nameResultDomain,
                "\n" );
        }
        break;
    }

    case DNS_TYPE_KEY: 
    {
        int keyLength = dataLength - SIZEOF_KEY_FIXED_DATA;
    
        PrintRoutine( pPrintContext,
            "0x%04X %d %d ",
            ( int ) pdata->KEY.wFlags,
            ( int ) pdata->KEY.chProtocol,
            ( int ) pdata->KEY.chAlgorithm );

        if ( keyLength > 0 && keyLength < sizeof( szBuff ) / 2 )
        {
            PCHAR p = Dns_SecurityKeyToBase64String(
                            ( PBYTE ) pdata + SIZEOF_KEY_FIXED_DATA,
                            keyLength,
                            szBuff );
            if ( p )
            {
                *p = '\0';      // NULL terminate key string
            }
            PrintRoutine( pPrintContext, szBuff );
        }
        else
        {
            PrintRoutine( pPrintContext, "KEY = %d bytes", keyLength );
        }

        PrintRoutine( pPrintContext, "\n" );
        break;
    }

    case DNS_TYPE_SIG: 
    {
        CHAR        szSigExp[ 30 ];
        CHAR        szSigInc[ 30 ];
        INT         sigOffset =
                        SIZEOF_SIG_FIXED_DATA +
                        pdata->SIG.nameSigner.cchNameLength +
                        sizeof( pdata->SIG.nameSigner.cchNameLength );
        INT         sigLength = dataLength - sigOffset;

        ptypeString = Dns_RecordStringForType( pdata->SIG.wTypeCovered );
        if ( !ptypeString )
        {
            ptypeString = "UNKNOWN-TYPE";
        }

        PrintRoutine( pPrintContext,
            "%s %d %d %d %s %s %d ",
            ptypeString,
            ( int ) pdata->SIG.chAlgorithm,
            ( int ) pdata->SIG.chLabelCount,
            ( int ) pdata->SIG.dwOriginalTtl,
            Dns_SigTimeString(
                pdata->SIG.dwSigExpiration,
                szSigExp ),
            Dns_SigTimeString(
                pdata->SIG.dwSigInception,
                szSigInc ),
            ( int ) pdata->SIG.wKeyTag );

        DnsPrint_RpcName(
            PrintRoutine, pPrintContext,
            NULL,
            &pdata->SIG.nameSigner,
            " " );

        if ( sigLength > 0 && sigLength < sizeof( szBuff ) / 2 )
        {
            PCHAR p = Dns_SecurityKeyToBase64String(
                            ( PBYTE ) pdata + sigOffset,
                            sigLength,
                            szBuff );
            if ( p )
            {
                *p = '\0';      // NULL terminate key string
            }
            PrintRoutine( pPrintContext, szBuff );
        }
        else
        {
            PrintRoutine( pPrintContext, "SIG = %d bytes", sigLength );
        }

        PrintRoutine( pPrintContext, "\n" );
        break;
    }

    case DNS_TYPE_NXT: 
    {
        INT     typeIdx;

        DnsPrint_RpcName(
            PrintRoutine, pPrintContext,
            NULL,
            ( PDNS_RPC_NAME ) ( ( PBYTE ) &pdata->NXT +
                ( pdata->NXT.wNumTypeWords + 1 ) * sizeof( WORD ) ),
            NULL );

        for ( typeIdx = 0; typeIdx < pdata->NXT.wNumTypeWords; ++typeIdx )
        {
            ptypeString =
                Dns_RecordStringForType( pdata->NXT.wTypeWords[ typeIdx ] );
            if ( !ptypeString )
            {
                ptypeString = "UNKNOWN-TYPE";
            }
            PrintRoutine( pPrintContext,
                " %s",
                ptypeString );
        }

        PrintRoutine( pPrintContext, "\n" );
        break;
    }

    default:

        PrintRoutine( pPrintContext,
            "Unknown resource record type (%d) at %p.\n",
            type,
            pRecord );
        break;
    }

Done:
    DnsPrint_Unlock();
}



PDNS_RPC_NAME
DNS_API_FUNCTION
DnsPrint_RpcRecordsInBuffer(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      BOOL            fDetail,
    IN      DWORD           dwBufferLength,
    IN      BYTE            abBuffer[]
    )
/*++

Routine Description:

    Prints RPC buffer.

Arguments:

    PrintRoutine -- printf like routine to print with

    pszHeader -- header string

    fDetail -- if TRUE print detailed record info

    dwBufferLength -- buffer length

    abBuffer -- ptr to RPC buffer

Return Value:

    Ptr to last RPC node name in buffer.
    NULL on error.

--*/
{
    PBYTE           pcurrent;
    PBYTE           pstop;
    PDNS_RPC_NAME   plastName = NULL;
    INT             recordCount;
    PCHAR           precordHeader;

    DnsPrint_Lock();

    PrintRoutine( pPrintContext, (pszHeader ? pszHeader : "") );

    if ( !abBuffer )
    {
        PrintRoutine( pPrintContext, "NULL record buffer ptr.\n" );
        goto Done;
    }

#if 0
    else
    {
        PrintRoutine( pPrintContext,
            "Record buffer of length %d at %p:\n",
            dwBufferLength,
            abBuffer );
    }
#endif

    //
    //  find stop byte
    //

    ASSERT( DNS_IS_DWORD_ALIGNED(abBuffer) );

    pstop = abBuffer + dwBufferLength;
    pcurrent = abBuffer;

    //
    //  loop until out of nodes
    //

    while ( pcurrent < pstop )
    {
        //
        //  print owner node
        //      - if NOT printing detail and no records
        //      (essentially domain nodes) then no node print
        //

        plastName = &((PDNS_RPC_NODE)pcurrent)->dnsNodeName;

        recordCount = ((PDNS_RPC_NODE)pcurrent)->wRecordCount;

        if ( fDetail )
        {
            DnsPrint_RpcNode(
                PrintRoutine, pPrintContext,
                NULL,
                (PDNS_RPC_NODE)pcurrent );
            if ( recordCount == 0 )
            {
                PrintRoutine( pPrintContext,"\n");
            }
        }
        else
        {
            #ifndef DBG
            if ( recordCount != 0 )
            #endif
            {
                DnsPrint_RpcName(
                    PrintRoutine, pPrintContext,
                    NULL,
                    plastName,
                    NULL );
                #ifdef DBG
                if ( recordCount == 0 )
                {
                    PrintRoutine( pPrintContext, "\t\t(node)\n" );
                }
                #endif
            }
        }

        pcurrent += ((PDNS_RPC_NODE)pcurrent)->wLength;
        pcurrent = DNS_NEXT_DWORD_PTR(pcurrent);

        //
        //  for each node, print all records in list
        //

        if ( !recordCount )
        {
            continue;
        }

        precordHeader = "";

        while( recordCount-- )
        {
            if ( pcurrent >= pstop )
            {
                PrintRoutine( pPrintContext,
                    "ERROR:  Bogus buffer at %p\n"
                    "\tExpect record at %p past buffer end at %p\n"
                    "\twith %d records remaining.\n",
                    abBuffer,
                    (PDNS_RPC_RECORD) pcurrent,
                    pstop,
                    recordCount+1 );

                ASSERT( FALSE );
                break;
            }

            DnsPrint_RpcRecord(
                PrintRoutine, pPrintContext,
                precordHeader,
                fDetail,
                (PDNS_RPC_RECORD)pcurrent );

            precordHeader = "\t\t";

            pcurrent += ((PDNS_RPC_RECORD)pcurrent)->wDataLength
                            + SIZEOF_DNS_RPC_RECORD_HEADER;
            
            pcurrent = DNS_NEXT_DWORD_PTR(pcurrent);
        }
    }

Done:

    DnsPrint_Unlock();

    return( plastName );
}



VOID
DNS_API_FUNCTION
DnsPrint_Node(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_NODE       pNode,
    IN      BOOLEAN         fPrintRecords
    )
{
    DnsPrint_Lock();
    PrintRoutine( pPrintContext, (pszHeader ? pszHeader : "") );

    if ( !pNode )
    {
        PrintRoutine( pPrintContext, " NULL DNS node ptr.\n" );
        goto Unlock;
    }
    else
    {
        //  DCR:  WARNING:  char set on RPC name print -- it's probably UTF8 if not unicode

        PrintRoutine( pPrintContext,
            "%s\n"
            "\tName     = %s%S\n"
            "\tPtr      = %p, pNext = %p\n"
            "\tFlags    = %p\n"
            "\tRec ptr  = %p\n",
            pszHeader ? "" : "DNS node",
            (PSTR)  (pNode->Flags.S.Unicode ? "" : (PSTR) pNode->pName),
            (PWSTR) (pNode->Flags.S.Unicode ? pNode->pName : L""),
            pNode,
            pNode->pNext,
            pNode->Flags.W,
            pNode->pRecord );
    }

    //
    //  if desired print record list
    //

    if ( pNode->pRecord && fPrintRecords )
    {
        DnsPrint_RecordSet(
            PrintRoutine, pPrintContext,
            "\trecords:\n",
            pNode->pRecord );
    }

Unlock:

    DnsPrint_Unlock();
}



VOID
DNS_API_FUNCTION
DnsPrint_NodeList(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNS_NODE       pNode,
    IN      BOOLEAN         fPrintRecords
    )
{
    DnsPrint_Lock();
    PrintRoutine( pPrintContext, (pszHeader ? pszHeader : "") );

    if ( !pNode )
    {
        PrintRoutine( pPrintContext, " NULL node list pointer.\n" );
    }
    else
    {
        do
        {
            DnsPrint_Node(
                PrintRoutine, pPrintContext,
                NULL,
                pNode,
                fPrintRecords );
        }
        while ( pNode = pNode->pNext );
    }
    DnsPrint_Unlock();
}



//
//  RPC Type union printing
//

VOID
DnsPrint_RpcIpArrayPlusParameters(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      LPSTR           pszStructureName,
    IN      LPSTR           pszParam1Name,
    IN      DWORD           dwParam1,
    IN      LPSTR           pszParam2Name,
    IN      DWORD           dwParam2,
    IN      LPSTR           pszIpArrayHeader,
    IN      PIP4_ARRAY      pIpArray
    )
/*++

Routine Description:

    Print info that contains up to two params and IP_ARRAY.

    This is kludgy, but there are several RPC types that contain an
    IP array and some flags.  This does the right thing for all those
    cases.

Arguments:

    pszParam1Name -- name of parameter;

    pszParam2Name -- name of parameter;  serves as flag as to whether
        param2 is printed

    pszIpArrayHeader -- name of IP array, passed to DnsPrint_Ip4Array
        as header;  should be full header line

        ex. "\tMasters:\n"

Return Value:

    None.

--*/
{
    if ( !pszHeader )
    {
        pszHeader = "";
    }

    DnsPrint_Lock();

    PrintRoutine( pPrintContext,
        "%s%s\n"
        "\t%s = %d (%p)\n",
        pszHeader,
        pszStructureName,
        pszParam1Name,
        dwParam1, dwParam1 );

    if ( pszParam2Name )
    {
        PrintRoutine( pPrintContext,
            "\t%s = %d (%p)\n",
            pszParam2Name,
            dwParam2, dwParam2 );
    }
    DnsPrint_Ip4Array(
        PrintRoutine, pPrintContext,
        pszIpArrayHeader,
        "\t\t",
        pIpArray );

    DnsPrint_Unlock();
}



VOID
DnsPrint_RpcUnion(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      DWORD           dwTypeId,
    IN      PVOID           pData
    )
{
    PWSTR   pstr1 = NULL;
    PWSTR   pstr2 = NULL;
    PWSTR   pstr3 = NULL;
    PWSTR   pstr4 = NULL;


    if ( !pszHeader )
    {
        pszHeader = "";
    }
    if ( !pData &&
        dwTypeId != DNSSRV_TYPEID_NULL &&
        dwTypeId != DNSSRV_TYPEID_DWORD )
    {
        PrintRoutine( pPrintContext,
            "%sNull RPC data ptr of type %d.\n",
            pszHeader,
            dwTypeId );
        return;
    }

    switch ( dwTypeId )
    {
    case DNSSRV_TYPEID_NULL:

        PrintRoutine( pPrintContext,
            "%sPointer:  %p\n",
            pszHeader,
            pData );
        break;

    case DNSSRV_TYPEID_DWORD:

        PrintRoutine( pPrintContext,
            "%sDword:  %d (%p)\n",
            pszHeader,
            (DWORD)(UINT_PTR)pData, pData );
        break;

    case DNSSRV_TYPEID_LPSTR:

        //  note:  all TYPEID_LPSTRs i see are UTF8 strings

        pstr1 = getUnicodeForUtf8( pData );

        PrintRoutine( pPrintContext,
            "%sString:  %S\n",
            pszHeader,
            pstr1 );

        break;

    case DNSSRV_TYPEID_LPWSTR:

        PrintRoutine( pPrintContext,
            "%sWideString:  %S\n",
            pszHeader,
            (PWSTR)pData );
        break;

    case DNSSRV_TYPEID_IPARRAY:

        DnsPrint_Ip4Array(
            PrintRoutine, pPrintContext,
            pszHeader,
            NULL,
            (PIP4_ARRAY) pData );
        break;

    case DNSSRV_TYPEID_BUFFER:

        PrintRoutine( pPrintContext,
            "%sBuffer:  length = %d, data ptr = %p\n",
            pszHeader,
            ((PDNS_RPC_BUFFER) pData)->dwLength,
            ((PDNS_RPC_BUFFER) pData)->Buffer );
        break;

    case DNSSRV_TYPEID_SERVER_INFO:

        DnsPrint_RpcServerInfo(
            PrintRoutine, pPrintContext,
            pszHeader,
            (PDNS_RPC_SERVER_INFO) pData );
        break;

    case DNSSRV_TYPEID_STATS:

        DnsPrint_RpcSingleStat(
            PrintRoutine, pPrintContext,
            pszHeader,
            (PDNSSRV_STAT) pData );
        break;

    case DNSSRV_TYPEID_ZONE:

        PrintRoutine( pPrintContext,
            "%s\n",
            pszHeader);

        DnsPrint_RpcZone(
            PrintRoutine, pPrintContext,
            NULL,   //print default header
            (PDNS_RPC_ZONE) pData );
        break;

    case DNSSRV_TYPEID_FORWARDERS:

        DnsPrint_RpcIpArrayPlusParameters(
            PrintRoutine, pPrintContext,
            pszHeader,
            "Forwarders Info:",
            "Slave",
            ((PDNS_RPC_FORWARDERS)pData)->fSlave,
            "Timeout",
            ((PDNS_RPC_FORWARDERS)pData)->dwForwardTimeout,
            "\tForwarders:\n",
            ((PDNS_RPC_FORWARDERS)pData)->aipForwarders );
        break;

    case DNSSRV_TYPEID_ZONE_INFO:

        DnsPrint_RpcZoneInfo(
            PrintRoutine, pPrintContext,
            pszHeader,
            (PDNS_RPC_ZONE_INFO) pData );
        break;

    case DNSSRV_TYPEID_ZONE_SECONDARIES:

        DnsPrint_RpcIpArrayPlusParameters(
            PrintRoutine, pPrintContext,
            pszHeader,
            "Zone Secondary Info:",
            "Secure Secondaries",
            ((PDNS_RPC_ZONE_SECONDARIES)pData)->fSecureSecondaries,
            NULL,
            0,
            "\tSecondaries:\n",
            ((PDNS_RPC_ZONE_SECONDARIES)pData)->aipSecondaries );
        break;

    case DNSSRV_TYPEID_ZONE_TYPE_RESET:

        DnsPrint_RpcIpArrayPlusParameters(
            PrintRoutine, pPrintContext,
            pszHeader,
            "Zone Type Reset Info:",
            "ZoneType",
            ((PDNS_RPC_ZONE_TYPE_RESET)pData)->dwZoneType,
            NULL,
            0,
            "\tMasters:\n",
            ((PDNS_RPC_ZONE_TYPE_RESET)pData)->aipMasters );
        break;

    case DNSSRV_TYPEID_ZONE_DATABASE:

        pstr1 = getUnicodeForUtf8( ((PDNS_RPC_ZONE_DATABASE)pData)->pszFileName );

        PrintRoutine( pPrintContext,
            "%sZone Dbase Info:\n"
            "\tDS Integrated    = %d\n"
            "\tFile Name        = %S\n",
            pszHeader,
            ((PDNS_RPC_ZONE_DATABASE)pData)->fDsIntegrated,
            pstr1   // ((PDNS_RPC_ZONE_DATABASE)pData)->pszFileName
            );
        break;

    case DNSSRV_TYPEID_ZONE_CREATE:

        pstr1 = getUnicodeForUtf8( ((PDNS_RPC_ZONE_CREATE_INFO)pData)->pszZoneName );
        pstr2 = getUnicodeForUtf8( ((PDNS_RPC_ZONE_CREATE_INFO)pData)->pszDataFile );
        pstr3 = getUnicodeForUtf8( ((PDNS_RPC_ZONE_CREATE_INFO)pData)->pszAdmin );
        pstr4 = getUnicodeForUtf8( ((PDNS_RPC_ZONE_CREATE_INFO)pData)->pszDpFqdn );

        PrintRoutine( pPrintContext,
            "%sZone Create Info:\n"
            "\tZone Name        = %S\n"
            "\tType             = %d\n"
            "\tAllow Update     = %d\n"
            "\tDS Integrated    = %d\n"
            "\tFile Name        = %S\n"
            "\tLoad Existing    = %d\n"
            "\tFlags            = 0x%08X\n"
            "\tAdmin Name       = %S\n"
            "\tDirPart Flags    = 0x%08X\n"
            "\tDirPart FQDN     = %S\n",
            pszHeader,
            pstr1,  // ((PDNS_RPC_ZONE_CREATE_INFO)pData)->pszZoneName,
            ((PDNS_RPC_ZONE_CREATE_INFO)pData)->dwZoneType,
            ((PDNS_RPC_ZONE_CREATE_INFO)pData)->fAllowUpdate,
            ((PDNS_RPC_ZONE_CREATE_INFO)pData)->fDsIntegrated,
            pstr2,  // ((PDNS_RPC_ZONE_CREATE_INFO)pData)->pszDataFile,
            ((PDNS_RPC_ZONE_CREATE_INFO)pData)->fLoadExisting,
            ((PDNS_RPC_ZONE_CREATE_INFO)pData)->dwFlags,
            pstr3,  // ((PDNS_RPC_ZONE_CREATE_INFO)pData)->pszAdmin,
            ((PDNS_RPC_ZONE_CREATE_INFO)pData)->dwDpFlags,
            pstr4   // ((PDNS_RPC_ZONE_CREATE_INFO)pData)->pszDpFqdn
            );

        break;
        

    case DNSSRV_TYPEID_NAME_AND_PARAM:

        //  DCR:  WARNING:  not sure of name char set in NAME_AND_PARAM type

        pstr1 = getUnicodeForUtf8( ((PDNS_RPC_NAME_AND_PARAM)pData)->pszNodeName );

        PrintRoutine( pPrintContext,
            "%sName and Parameter:\n"
            "\tParam    = %d (%p)\n"
            "\tName     = %S\n",
            pszHeader,
            ((PDNS_RPC_NAME_AND_PARAM)pData)->dwParam,
            ((PDNS_RPC_NAME_AND_PARAM)pData)->dwParam,
            pstr1   // ((PDNS_RPC_NAME_AND_PARAM)pData)->pszNodeName
            );
        break;

    case DNSSRV_TYPEID_ZONE_LIST:

        DnsPrint_RpcZoneList(
            PrintRoutine, pPrintContext,
            NULL,
            (PDNS_RPC_ZONE_LIST)pData );
        break;

    default:

        PrintRoutine( pPrintContext,
            "%s\n"
            "WARNING:  Unknown RPC structure typeid = %d at %p\n",
            pszHeader,
            dwTypeId,
            pData );
        break;
    }

    FREE_HEAP( pstr1 );
    FREE_HEAP( pstr2 );
    FREE_HEAP( pstr3 );
    FREE_HEAP( pstr4 );
}



//
//  Stat validity table.
//
//  Contains match of stat ID and lengths as of this build of RPC client.
//

typedef struct StatsValidityTableEntry
{
    DWORD       Id;
    WORD        wLength;
};

struct StatsValidityTableEntry StatsValidityTable[] =
{
    DNSSRV_STATID_TIME,             sizeof(DNSSRV_TIME_STATS),
    DNSSRV_STATID_QUERY,            sizeof(DNSSRV_QUERY_STATS),
    DNSSRV_STATID_QUERY2,           sizeof(DNSSRV_QUERY2_STATS),
    DNSSRV_STATID_RECURSE,          sizeof(DNSSRV_RECURSE_STATS),
    DNSSRV_STATID_MASTER,           sizeof(DNSSRV_MASTER_STATS),
    DNSSRV_STATID_SECONDARY,        sizeof(DNSSRV_SECONDARY_STATS),
    DNSSRV_STATID_WINS,             sizeof(DNSSRV_WINS_STATS),
    DNSSRV_STATID_NBSTAT,           sizeof(DNSSRV_NBSTAT_STATS),
    DNSSRV_STATID_WIRE_UPDATE,      sizeof(DNSSRV_UPDATE_STATS),
    DNSSRV_STATID_NONWIRE_UPDATE,   sizeof(DNSSRV_UPDATE_STATS),
    DNSSRV_STATID_SKWANSEC,         sizeof(DNSSRV_SKWANSEC_STATS),
    DNSSRV_STATID_DS,               sizeof(DNSSRV_DS_STATS),
    DNSSRV_STATID_MEMORY,           sizeof(DNSSRV_MEMORY_STATS),
    DNSSRV_STATID_PACKET,           sizeof(DNSSRV_PACKET_STATS),
    DNSSRV_STATID_DBASE,            sizeof(DNSSRV_DBASE_STATS),
    DNSSRV_STATID_RECORD,           sizeof(DNSSRV_RECORD_STATS),
    DNSSRV_STATID_TIMEOUT,          sizeof(DNSSRV_TIMEOUT_STATS),
    DNSSRV_STATID_ERRORS,           sizeof(DNSSRV_ERROR_STATS),
    DNSSRV_STATID_CACHE,            sizeof(DNSSRV_CACHE_STATS),
    DNSSRV_STATID_PRIVATE,          sizeof(DNSSRV_PRIVATE_STATS),

    0, 0,   // termination
};



DNS_STATUS
DNS_API_FUNCTION
DnssrvValidityCheckStatistic(
    IN      PDNSSRV_STAT        pStat
    )
/*++

Routine Description:

    Validity check stat struct received from server.

Arguments:

    pStat -- ptr to stat buffer

Return Value:

    ERROR_SUCCESS           if valid.
    DNS_ERROR_INVALID_TYPE  if unknown stat id.
    ERROR_INVALID_DATA      if invalid data.

--*/
{
    DWORD   i;
    DWORD   id;

    //
    //  find stat ID in table, and verify length match
    //

    i = 0;

    while ( id = StatsValidityTable[i].Id )
    {
        if ( pStat->Header.StatId == id )
        {
            if ( pStat->Header.wLength ==
                    StatsValidityTable[i].wLength - sizeof(DNSSRV_STAT_HEADER) )
            {
                return( ERROR_SUCCESS );
            }
            return( ERROR_INVALID_DATA );
        }
        i++;
    }
    return( DNS_ERROR_INVALID_TYPE );
}



//
//  Stat printing.
//

VOID
DnsPrint_RpcStatRaw(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNSSRV_STAT    pStat,
    IN      DNS_STATUS      Status
    )
/*++

Routine Description:

    Debug print flat stat structure.

Arguments:

    PrintRoutine    -- printf like print routine to use

    pszHeader       -- header message to print

    pStat           -- ptr to stat buffer

    Status          -- status result of validity check;  if not ERROR_SUCCESS,
                        appropriate error message is printed

Return Value:

    None.

--*/
{
    PDWORD  pdword;
    INT     i;
    PCHAR   pstatEnd;

    DnsPrint_Lock();

    if ( pszHeader )
    {
        PrintRoutine( pPrintContext, pszHeader );
    }

    //
    //  validity check stat
    //

    if ( Status != ERROR_SUCCESS )
    {
        if ( Status == DNS_ERROR_INVALID_TYPE )
        {
            PrintRoutine( pPrintContext,
                "Stat ID = %p, is not valid for version of the DNS RPC client.\n",
                pStat->Header.StatId );
        }
        else if ( Status == ERROR_INVALID_DATA )
        {
            PrintRoutine( pPrintContext,
                "Stat data length %d is invalid for stat ID = %p\n",
                pStat->Header.wLength,
                pStat->Header.StatId );
        }

        PrintRoutine( pPrintContext,
            "WARNING:  DNS RPC client must match version of server for statistics\n"
            "\tprinting to be formatted appropriately.\n"
            "Update this tool or the DNS server as necessary to match versions.\n" );
    }

    //
    //  print stat buffer raw
    //

    PrintRoutine( pPrintContext,
        "Stat ID %p:\n",
        pStat->Header.StatId );

    pdword = (PDWORD) pStat->Buffer;
    pstatEnd = pStat->Header.wLength + (PCHAR)pdword;
    i = 0;

    while ( (PCHAR)pdword < pstatEnd )
    {
        PrintRoutine( pPrintContext,
            "   stat[%d]  = %10lu\n",
            i,
            *pdword );

        pdword++;
        i++;
    }

    DnsPrint_Unlock();
}



VOID
DnsPrint_RpcStatsBuffer(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_BUFFER     pBuffer
    )
/*++

Routine Description:

    Debug print stats buffer.

Arguments:

    pBuffer -- buffer containing stats to print

Return Value:

    None.

--*/
{
    PDNSSRV_STAT    pstat;
    PCHAR           pch;
    PCHAR           pchstop;

    DnsPrint_Lock();
    if ( pszHeader )
    {
        PrintRoutine( pPrintContext, pszHeader );
    }

    pch = pBuffer->Buffer;
    pchstop = pch + pBuffer->dwLength;

    while ( pch < pchstop )
    {
        pstat = (PDNSSRV_STAT) pch;

        pch = (PCHAR) GET_NEXT_STAT_IN_BUFFER( pstat );
        if ( pch > pchstop )
        {
            PrintRoutine( pPrintContext, "ERROR:  invalid stats buffer!!!\n" );
            break;
        }
        DnsPrint_RpcSingleStat(
            PrintRoutine, pPrintContext,
            NULL,
            pstat );
    }
    PrintRoutine( pPrintContext, "\n\n" );
    DnsPrint_Unlock();
}



VOID
printStatTypeArray(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDWORD          pArray
    )
/*++

Routine Description:

    Debug print stats type array.

Arguments:

Return Value:

    None.

--*/
{
    register DWORD i;

    PrintRoutine( pPrintContext,
        "%s\n",
        pszHeader );

    //
    //  print counts for all types
    //      - skip mixed and unknown bins until end
    //

    for ( i=0; i<STATS_TYPE_MAX; i++ )
    {
        if ( i == STATS_TYPE_MIXED || i == STATS_TYPE_UNKNOWN )
        {
            continue;
        }

        PrintRoutine( pPrintContext,
            "    %-10s = %d\n",
            Dns_RecordStringForType( (WORD)i ),
            pArray[i] );
    }

    PrintRoutine( pPrintContext,
        "    %-10s = %d\n",
        "Unknown",
        pArray[STATS_TYPE_UNKNOWN] );

    PrintRoutine( pPrintContext,
        "    %-10s = %d\n"
        "\n",
        "Mixed",
        pArray[STATS_TYPE_MIXED] );
}



VOID
DnsPrint_RpcSingleStat(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pszHeader,
    IN      PDNSSRV_STAT    pStat
    )
/*++

Routine Description:

    Debug print stats structure.

Arguments:

    None.

Return Value:

    None.

--*/
{
    DNS_STATUS  status;

    //
    //  validity check stat
    //

    status = DnssrvValidityCheckStatistic( pStat );
    if ( status != ERROR_SUCCESS )
    {
        DnsPrint_RpcStatRaw(
            PrintRoutine, pPrintContext,
            pszHeader,
            pStat,
            status );
        return;
    }

    DnsPrint_Lock();
    if ( pszHeader )
    {
        PrintRoutine( pPrintContext, pszHeader );
    }

    //
    //  switch on stats type
    //

    switch ( pStat->Header.StatId )
    {

    case DNSSRV_STATID_TIME:
    {
        PDNSSRV_TIME_STATS  pstat = (PDNSSRV_TIME_STATS)pStat;
        SYSTEMTIME  localTime;
        CHAR        szdate[30];
        CHAR        sztime[20];

        SystemTimeToTzSpecificLocalTime(
            NULL,       // use local time
            (PSYSTEMTIME) & pstat->ServerStartTime,
            & localTime );

        GetDateFormat(
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            // (PSYSTEMTIME) &pstat->ServerStartTime,
            & localTime,
            NULL,
            szdate,
            30 );
        GetTimeFormat(
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            // (PSYSTEMTIME) &pstat->ServerStartTime,
            & localTime,
            NULL,
            sztime,
            20 );
        PrintRoutine( pPrintContext,
            "\n"
            "DNS Server Time Statistics\n"
            "--------------------------\n"
            "Server start time    %s %s\n"
            "Seconds since start  %10lu\n",
            szdate,
            sztime,
            pstat->SecondsSinceServerStart
            );

        SystemTimeToTzSpecificLocalTime(
            NULL,       // use local time
            (PSYSTEMTIME) & pstat->LastClearTime,
            & localTime );

        GetDateFormat(
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            // (PSYSTEMTIME) &pstat->LastClearTime,
            & localTime,
            NULL,
            szdate,
            30 );
        GetTimeFormat(
            LOCALE_SYSTEM_DEFAULT,
            LOCALE_NOUSEROVERRIDE,
            // (PSYSTEMTIME) &pstat->LastClearTime,
            & localTime,
            NULL,
            sztime,
            20 );
        PrintRoutine( pPrintContext,
            "Stats last cleared   %s %s\n"
            "Seconds since clear  %10lu\n",
            szdate,
            sztime,
            pstat->SecondsSinceLastClear
            );
        break;
    }

    case DNSSRV_STATID_QUERY:
    {
        PDNSSRV_QUERY_STATS  pstat = (PDNSSRV_QUERY_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Queries and Responses:\n"
            "----------------------\n"
            "Total:\n"
            "    Queries Received = %10lu\n"
            "    Responses Sent   = %10lu\n"
            "UDP:\n"
            "    Queries Recvd    = %10lu\n"
            "    Responses Sent   = %10lu\n"
            "    Queries Sent     = %10lu\n"
            "    Responses Recvd  = %10lu\n"
            "TCP:\n"
            "    Client Connects  = %10lu\n"
            "    Queries Recvd    = %10lu\n"
            "    Responses Sent   = %10lu\n"
            "    Queries Sent     = %10lu\n"
            "    Responses Recvd  = %10lu\n",
            pstat->UdpQueries + pstat->TcpQueries,
            pstat->UdpResponses + pstat->TcpResponses,
            pstat->UdpQueries,
            pstat->UdpResponses,
            pstat->UdpQueriesSent,
            pstat->UdpResponsesReceived,
            pstat->TcpClientConnections,
            pstat->TcpQueries,
            pstat->TcpResponses,
            pstat->TcpQueriesSent,
            pstat->TcpResponsesReceived
            );
        break;
    }

    case DNSSRV_STATID_QUERY2:
    {
        PDNSSRV_QUERY2_STATS  pstat = (PDNSSRV_QUERY2_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Queries:\n"
            "--------\n"
            "Total          = %10lu\n"
            "    Notify     = %10lu\n"
            "    Update     = %10lu\n"
            "    TKeyNego   = %10lu\n"
            "    Standard   = %10lu\n"
            "       A       = %10lu\n"
            "       NS      = %10lu\n"
            "       SOA     = %10lu\n"
            "       MX      = %10lu\n"
            "       PTR     = %10lu\n"
            "       SRV     = %10lu\n"
            "       ALL     = %10lu\n"
            "       IXFR    = %10lu\n"
            "       AXFR    = %10lu\n"
            "       OTHER   = %10lu\n",
            pstat->TotalQueries,
            pstat->Notify,
            pstat->Update,
            pstat->TKeyNego,
            pstat->Standard,
            pstat->TypeA,
            pstat->TypeNs,
            pstat->TypeSoa,
            pstat->TypeMx,
            pstat->TypePtr,
            pstat->TypeSrv,
            pstat->TypeAll,
            pstat->TypeIxfr,
            pstat->TypeAxfr,
            pstat->TypeOther
            );
        break;
    }

    case DNSSRV_STATID_RECURSE:
    {
        PDNSSRV_RECURSE_STATS  pstat = (PDNSSRV_RECURSE_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Recursion:\n"
            "----------\n"
            "Query:\n"
            "  Queries Recursed     = %10lu\n"
            "  Original Questions   = %10lu\n"
            "  Additional Question  = %10lu\n"
            "  Total Questions      = %10lu\n"
            "  Retries              = %10lu\n"
            "  Total Passes         = %10lu\n"
            "  ToForwarders         = %10lu\n"
            "  Sends                = %10lu\n",
            pstat->QueriesRecursed,
            pstat->OriginalQuestionRecursed,
            pstat->AdditionalRecursed,
            pstat->TotalQuestionsRecursed,
            pstat->Retries,
            pstat->LookupPasses,
            pstat->Forwards,
            pstat->Sends );

        PrintRoutine( pPrintContext,
            "\n"
            "Response:\n"
            "  TotalResponses       = %10lu\n"
            "  Unmatched            = %10lu\n"
            "  Mismatched           = %10lu\n"
            "  FromForwarder        = %10lu\n"
            "  Authoritative        = %10lu\n"
            "  NotAuthoritative     = %10lu\n"
            "  Answer               = %10lu\n"
            "  Empty                = %10lu\n"
            "  NameError            = %10lu\n"
            "  Rcode                = %10lu\n"
            "  Delegation           = %10lu\n"
            "  NonZoneData          = %10lu\n"
            "  Unsecure             = %10lu\n"
            "  BadPacket            = %10lu\n"
            "Process Response:\n"
            "  Forward Response     = %10lu\n"
            "  Continue Recursion   = %10lu\n"
            "  Continue Lookup      = %10lu\n"
            "  Next Lookup          = %10lu\n",
            pstat->Responses,
            pstat->ResponseUnmatched,
            pstat->ResponseMismatched,
            pstat->ResponseFromForwarder,
            pstat->ResponseAuthoritative,
            pstat->ResponseNotAuth,
            pstat->ResponseAnswer,
            pstat->ResponseEmpty,
            pstat->ResponseNameError,
            pstat->ResponseRcode,
            pstat->ResponseDelegation,
            pstat->ResponseNonZoneData,
            pstat->ResponseUnsecure,
            pstat->ResponseBadPacket,
            pstat->SendResponseDirect,
            pstat->ContinueCurrentRecursion,
            pstat->ContinueCurrentLookup,
            pstat->ContinueNextLookup );

        PrintRoutine( pPrintContext,
            "\n"
            "Timeouts:\n"
            "  Send Timeouts        = %10lu\n"
            "  Final Queued         = %10lu\n"
            "  Final Expired        = %10lu\n"
            "\n"
            "Failures:\n"
            "  Recurse Failures     = %10lu\n"
            "    Into Authority     = %10lu\n"
            "    Previous Zone      = %10lu\n"
            "    Retry Limit        = %10lu\n"
            "  Partial (HaveAnswer) = %10lu\n"
            "  Cache Update         = %10lu\n"
            "  Server Failure Resp  = %10lu\n"
            "  Total Failures       = %10lu\n",

            pstat->PacketTimeout,
            pstat->FinalTimeoutQueued,
            pstat->FinalTimeoutExpired,
            pstat->RecursePassFailure,
            pstat->FailureReachAuthority,
            pstat->FailureReachPreviousResponse,
            pstat->FailureRetryCount,
            pstat->PartialFailure,
            pstat->CacheUpdateFailure,
            pstat->ServerFailure,
            pstat->Failures
            );

        PrintRoutine( pPrintContext,
            "\n"
            "TCP Recursion:\n"
            "  Try                  = %10lu\n"
            "  Query                = %10lu\n"
            "  Response             = %10lu\n"
            "  Disconnects          = %10lu\n"
            "\n"
            "Cache Update Queries:\n"
            "  Query                = %10lu\n"
            "  Response             = %10lu\n"
            "  Retry                = %10lu\n"
            "  Free                 = %10lu\n"
            "  Root NS Query        = %10lu\n"
            "  Root NS Response     = %10lu\n"
            "  Suspended Query      = %10lu\n"
            "  Resume Suspended     = %10lu\n"
            "\n",
            pstat->TcpTry,
            pstat->TcpQuery,
            pstat->TcpResponse,
            pstat->TcpDisconnect,
            pstat->CacheUpdateAlloc,
            pstat->CacheUpdateResponse,
            pstat->CacheUpdateRetry,
            pstat->CacheUpdateFree,
            pstat->RootNsQuery,
            pstat->RootNsResponse,
            pstat->SuspendedQuery,
            pstat->ResumeSuspendedQuery );

        PrintRoutine( pPrintContext,
            "\n"
            "Other:\n"
            "  Discarded duplicates = %10lu\n"
            "\n",
            pstat->DiscardedDuplicateQueries );

        break;
    }

    case DNSSRV_STATID_MASTER:
    {
        PDNSSRV_MASTER_STATS pstat = (PDNSSRV_MASTER_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Master Stats:\n"
            "-------------\n"
            "Notifies Sent          = %10lu\n"
            "\n"
            "Requests               = %10lu\n"
            "    NameError          = %10lu\n"
            "    FormError          = %10lu\n"
            "    Refused            = %10lu\n"
            "       AxfrLimit       = %10lu\n"
            "       Security        = %10lu\n"
            "       Shutdown        = %10lu\n"
            "       ZoneLocked      = %10lu\n"
            "       ServerFailure   = %10lu\n"
            "    Failure            = %10lu\n"
            "    Success            = %10lu\n"
            "\n"
            "AXFR Request           = %10lu\n"
            "    Success            = %10lu\n"
            "    In IXFR            = %10lu\n"
            "\n"
            "IXFR Request           = %10lu\n"
            "    Success Update     = %10lu\n"
            "    UDP Request        = %10lu\n"
            "       Success         = %10lu\n"
            "       Force TCP       = %10lu\n"
            "       Force Full      = %10lu\n"
            "    TCP Request        = %10lu\n"
            "       Success         = %10lu\n"
            "       Do Full         = %10lu\n"
            "\n",

            pstat->NotifySent,
            pstat->Request,
            pstat->NameError,
            pstat->FormError,
            pstat->Refused,
            pstat->AxfrLimit,
            pstat->RefuseSecurity,
            pstat->RefuseShutdown,
            pstat->RefuseZoneLocked,
            pstat->RefuseServerFailure,
            pstat->Failure,
            (pstat->AxfrSuccess + pstat->IxfrUpdateSuccess),

            pstat->AxfrRequest,
            pstat->AxfrSuccess,
            pstat->IxfrAxfr,

            pstat->IxfrRequest,
            pstat->IxfrUpdateSuccess,

            pstat->IxfrUdpRequest,
            pstat->IxfrUdpSuccess,
            pstat->IxfrUdpForceTcp,
            pstat->IxfrUdpForceAxfr,

            pstat->IxfrTcpRequest,
            pstat->IxfrTcpSuccess,
            pstat->IxfrAxfr
            );
        break;
    }

    case DNSSRV_STATID_SECONDARY:
    {
        PDNSSRV_SECONDARY_STATS pstat = (PDNSSRV_SECONDARY_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Secondary Stats:\n"
            "----------------\n"
            "NOTIFY:\n"
            "    Received           = %10lu\n"
            "       Invalid         = %10lu\n"
            "       Primary         = %10lu\n"
            "       No Version      = %10lu\n"
            "       New Version     = %10lu\n"
            "       Current Version = %10lu\n"
            "       Old Version     = %10lu\n"
            "       Master Unknown  = %10lu\n"
            "\n"
            "SOA Query:\n"
            "    Request            = %10lu\n"
            "    Response           = %10lu\n"
            "       Invalid         = %10lu\n"
            "       NameError       = %10lu\n"
            "\n"
            "AXFR:\n"
            "    AXFR Request       = %10lu\n"
            "    AXFR in IXFR       = %10lu\n"
            "    Response           = %10lu\n"
            "       Success         = %10lu\n"
            "       Refused         = %10lu\n"
            "       Invalid         = %10lu\n"
            "\n"
            "Stub zone AXFR:\n"
            "    Stub AXFR Request  = %10lu\n"
            "    Response           = %10lu\n"
            "       Success         = %10lu\n"
            "       Refused         = %10lu\n"
            "       Invalid         = %10lu\n"
            "\n"
            "IXFR UDP:\n"
            "    Request            = %10lu\n"
            "    Response           = %10lu\n"
            "       Success         = %10lu\n"
            "       UseTcp          = %10lu\n"
            "       UseAxfr         = %10lu\n"
            "       New Primary     = %10lu\n"
            "       Refused         = %10lu\n"
            "       Wrong Server    = %10lu\n"
            "       FormError       = %10lu\n"
            "       Invalid         = %10lu\n"
            "\n"
            "IXFR TCP:\n"
            "    Request            = %10lu\n"
            "    Response           = %10lu\n"
            "       Success         = %10lu\n"
            "       AXFR            = %10lu\n"
            "       FormError       = %10lu\n"
            "       Refused         = %10lu\n"
            "       Invalid         = %10lu\n"
            "\n",
            pstat->NotifyReceived,
            pstat->NotifyInvalid,
            pstat->NotifyPrimary,
            pstat->NotifyNoVersion,
            pstat->NotifyNewVersion,
            pstat->NotifyCurrentVersion,
            pstat->NotifyOldVersion,
            pstat->NotifyMasterUnknown,

            pstat->SoaRequest,
            pstat->SoaResponse,
            pstat->SoaResponseInvalid,
            pstat->SoaResponseNameError,

            pstat->AxfrRequest,
            pstat->IxfrTcpAxfr,
            pstat->AxfrResponse,
            pstat->AxfrSuccess,
            pstat->AxfrRefused,
            pstat->AxfrInvalid,

            pstat->StubAxfrRequest,
            pstat->StubAxfrResponse,
            pstat->StubAxfrSuccess,
            pstat->StubAxfrRefused,
            pstat->StubAxfrInvalid,

            pstat->IxfrUdpRequest,
            pstat->IxfrUdpResponse,
            pstat->IxfrUdpSuccess,
            pstat->IxfrUdpUseTcp,
            pstat->IxfrUdpUseAxfr,
            pstat->IxfrUdpNewPrimary,
            pstat->IxfrUdpRefused,
            pstat->IxfrUdpWrongServer,
            pstat->IxfrUdpFormerr,
            pstat->IxfrUdpInvalid,

            pstat->IxfrTcpRequest,
            pstat->IxfrTcpResponse,
            pstat->IxfrTcpSuccess,
            pstat->IxfrTcpAxfr,
            pstat->IxfrTcpFormerr,
            pstat->IxfrTcpRefused,
            pstat->IxfrTcpInvalid
            );
        break;
    }

    case DNSSRV_STATID_WINS:
    {
        PDNSSRV_WINS_STATS  pstat = (PDNSSRV_WINS_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "WINS Referrals:\n"
            "---------------\n"
            "Forward:\n"
            "    Lookups    = %10lu\n"
            "    Responses  = %10lu\n"
            "Reverse:\n"
            "    Lookups    = %10lu\n"
            "    Responses  = %10lu\n",
            pstat->WinsLookups,
            pstat->WinsResponses,
            pstat->WinsReverseLookups,
            pstat->WinsReverseResponses
            );
        break;
    }

    case DNSSRV_STATID_NBSTAT:
    {
        PDNSSRV_NBSTAT_STATS  pstat = (PDNSSRV_NBSTAT_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Nbstat Memory Usage:\n"
            "--------------------\n"
            "Nbstat Buffers:\n"
            "    Alloc      = %10lu\n"
            "    Free       = %10lu\n"
            "    NetAllocs  = %10lu\n"
            "    Memory     = %10lu\n"
            "    Used       = %10lu\n"
            "    Returned   = %10lu\n"
            "    InUse      = %10lu\n"
            "    InFreeList = %10lu\n"
            "\n",
            pstat->NbstatAlloc,
            pstat->NbstatFree,
            pstat->NbstatNetAllocs,
            pstat->NbstatMemory,
            pstat->NbstatUsed,
            pstat->NbstatReturn,
            pstat->NbstatInUse,
            pstat->NbstatInFreeList
            );
        break;
    }

    case DNSSRV_STATID_WIRE_UPDATE:
    case DNSSRV_STATID_NONWIRE_UPDATE:
    {
        PDNSSRV_UPDATE_STATS  pstat = (PDNSSRV_UPDATE_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "%s:\n"
            "--------------------------\n"
            "Updates Received         = %10lu\n"
            "    Forwarded            = %10lu\n"
            "    Empty (PreCon Only)  = %10lu\n"
            "    NoOps (Dups)         = %10lu\n"
            "    Rejected             = %10lu\n"
            "    Completed            = %10lu\n"
            "    Timed Out            = %10lu\n"
            "    In Queue             = %10lu\n"
            "\n"
            "Updates Rejected         = %10lu\n"
            "    FormError            = %10lu\n"
            "    NameError            = %10lu\n"
            "    NotImpl              = %10lu  (Non-Update Zone)\n"
            "    Refused              = %10lu\n"
            "      NonSecure Packet   = %10lu\n"
            "      AccessDenied       = %10lu\n"
            "    YxDomain             = %10lu\n"
            "    YxRRSet              = %10lu\n"
            "    NxRRSet              = %10lu\n"
            "    NotAuth              = %10lu\n"
            "    NotZone              = %10lu\n"
            "\n"
            #if 0   //  unused counters
            "Update Collisions        = %10lu\n"
            "    Read                 = %10lu\n"
            "    Write                = %10lu\n"
            "      In LDAP            = %10lu\n"
            "\n"
            #endif
            "Queue\n"
            "    Queued               = %10lu\n"
            "    Retried              = %10lu\n"
            "    Timeout              = %10lu\n"
            "    In Queue             = %10lu\n"
            "\n"
            "Secure Update\n"
            "    Success              = %10lu\n"
            "    Continue             = %10lu\n"
            "    Failure              = %10lu\n"
            "      DS Write Failure   = %10lu\n"
            "\n"
            "Update Forwarding\n"
            "    Forwards             = %10lu\n"
            "    TCP Forwards         = %10lu\n"
            "    Responses            = %10lu\n"
            "    Timed Out            = %10lu\n"
            "    In Queue             = %10lu\n"
            "\n",

            pStat->Header.StatId == DNSSRV_STATID_WIRE_UPDATE ?
                "Packet Dynamic Update" :
                "Internal Dynamic Update",

            pstat->Received,
            pstat->Forwards,
            pstat->Empty,
            pstat->NoOps,
            pstat->Rejected,
            pstat->Completed,
            pstat->Timeout,
            pstat->InQueue,

            pstat->Rejected,
            pstat->FormErr,
            pstat->NxDomain,
            pstat->NotImpl,
            pstat->Refused,
            pstat->RefusedNonSecure,
            pstat->RefusedAccessDenied,
            pstat->YxDomain,
            pstat->YxRrset,
            pstat->NxRrset,
            pstat->NotAuth,
            pstat->NotZone,

            #if 0   //  unused counters
            pstat->Collisions,
            pstat->CollisionsRead,
            pstat->CollisionsWrite,
            pstat->CollisionsDsWrite,
            #endif

            pstat->Queued,
            pstat->Retry,
            pstat->Timeout,
            pstat->InQueue,

            pstat->SecureSuccess,
            pstat->SecureContinue,
            pstat->SecureFailure,
            pstat->SecureDsWriteFailure,

            pstat->Forwards,
            pstat->TcpForwards,
            pstat->ForwardResponses,
            pstat->ForwardTimeouts,
            pstat->ForwardInQueue
            );

        printStatTypeArray(
            PrintRoutine, pPrintContext,
            "Update Types:",
            pstat->UpdateType );
        break;
    }

    case DNSSRV_STATID_DS:
    {
        PDNSSRV_DS_STATS  pstat = (PDNSSRV_DS_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "DS Integration:\n"
            "---------------\n"
            "DS Reads:\n"
            "   Nodes Read Total        = %10lu\n"
            "   Records Read Total      = %10lu\n"
            "   Nodes Loaded            = %10lu\n"
            "   Records Loaded          = %10lu\n"
            "\n"
            "   Update Searches         = %10lu\n"
            "   Update Nodes Read       = %10lu\n"
            "   Update Records Read     = %10lu\n"
            "\n"
            "DS Writes:\n"
            "   Nodes Added             = %10lu\n"
            "   Nodes Modified          = %10lu\n"
            "   Nodes Tombstoned        = %10lu\n"
            "   Nodes Final Delete      = %10lu\n"
            "   Node Write Suppressed   = %10lu\n"
            "   RR Sets Added           = %10lu\n"
            "   RR Sets Replaced        = %10lu\n"
            "   Serial Writes           = %10lu\n"
            "\n"
            "   Update Lists            = %10lu\n"
            "   Update Nodes            = %10lu\n"
            "       Suppressed          = %10lu\n"
            "       Writes              = %10lu\n"
            "       Tombstones          = %10lu\n"
            "   Write causes:\n"
            "       Record Change       = %10lu\n"
            "       Aging Refresh       = %10lu\n"
            "       Aging On            = %10lu\n"
            "       Aging Off           = %10lu\n"
            "   Write sources:\n"
            "       Packet              = %10lu\n"
            "         Precon Only       = %10lu\n"
            "       Admin               = %10lu\n"
            "       Auto Config         = %10lu\n"
            "       Scavenge            = %10lu\n",

            pstat->DsTotalNodesRead,
            pstat->DsTotalRecordsRead,
            pstat->DsNodesLoaded,
            pstat->DsRecordsLoaded,
            pstat->DsUpdateSearches,
            pstat->DsUpdateNodesRead,
            pstat->DsUpdateRecordsRead,

            pstat->DsNodesAdded,
            pstat->DsNodesModified,
            pstat->DsNodesTombstoned,
            pstat->DsNodesDeleted,
            pstat->DsWriteSuppressed,
            pstat->DsRecordsAdded,
            pstat->DsRecordsReplaced,
            pstat->DsSerialWrites,

            pstat->UpdateLists,
            pstat->UpdateNodes,
            pstat->UpdateSuppressed,
            pstat->UpdateWrites,
            pstat->UpdateTombstones,
            pstat->UpdateRecordChange,
            pstat->UpdateAgingRefresh,
            pstat->UpdateAgingOn,
            pstat->UpdateAgingOff,
            pstat->UpdatePacket,
            pstat->UpdatePacketPrecon,
            pstat->UpdateAdmin,
            pstat->UpdateAutoConfig,
            pstat->UpdateScavenge
            );

         PrintRoutine( pPrintContext,
            "\n"
            "Tombstones:\n"
            "   Written                 = %10lu\n"
            "   Read                    = %10lu\n"
            "   Deleted                 = %10lu\n"
            "\n"
            "Write Performance:\n"
            "   Total                   = %10lu\n"
            "   Total Time              = %10lu\n"
            "   Average                 = %10lu\n"
            "   < 10ms                  = %10lu\n"
            "   < 100ms                 = %10lu\n"
            "   < 1s                    = %10lu\n"
            "   < 10s                   = %10lu\n"
            "   < 100s                  = %10lu\n"
            "   > 100s                  = %10lu\n"
            "   Max                     = %10lu\n"
            "Search Performance:\n"
            "   Total (ms)              = %10lu\n"
            "\n"
            "Failures:\n"
            "   FailedDeleteDsEntries   = %10lu\n"
            "   FailedReadRecords       = %10lu\n"
            "   FailedLdapModify        = %10lu\n"
            "   FailedLdapAdd           = %10lu\n"
            "\n"
            "Polling:\n"
            "   PollingPassesWithErrors = %10lu\n"
            "\n"
            "LDAP:\n"
            "   Reconnects              = %10lu\n"
            "\n",
            pstat->DsNodesTombstoned,
            pstat->DsTombstonesRead,
            pstat->DsNodesDeleted,

            pstat->LdapTimedWrites,
            pstat->LdapWriteTimeTotal,
            pstat->LdapWriteAverage,
            pstat->LdapWriteBucket0,
            pstat->LdapWriteBucket1,
            pstat->LdapWriteBucket2,
            pstat->LdapWriteBucket3,
            pstat->LdapWriteBucket4,
            pstat->LdapWriteBucket5,
            pstat->LdapWriteMax,

            pstat->LdapSearchTime,

            pstat->FailedDeleteDsEntries,
            pstat->FailedReadRecords,
            pstat->FailedLdapModify,
            pstat->FailedLdapAdd,

            pstat->PollingPassesWithDsErrors,

            pstat->LdapReconnects );

        printStatTypeArray(
            PrintRoutine, pPrintContext,
            "DS Write Types:",
            pstat->DsWriteType );

        break;
    }

    case DNSSRV_STATID_SKWANSEC:
    {
        PDNSSRV_SKWANSEC_STATS pstat = (PDNSSRV_SKWANSEC_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Security Stats:\n"
            "---------------\n"
            "\n"
            "Security Context:\n"
            "   Create              = %10lu\n"
            "   Free                = %10lu\n"
            "       Timeout         = %10lu\n"
            "   Queue Length        = %10lu\n"
            "   Queued              = %10lu\n"
            "       In Nego         = %10lu\n"
            "       Nego Complete   = %10lu\n"
            "   DeQueued            = %10lu\n"
            "\n"
            "Security Packet Contexts:\n"
            "   Alloc               = %10lu\n"
            "   Free                = %10lu\n"
            "\n"
            "TKEY:\n"
            "   Invalid             = %10lu\n"
            "   BadTime             = %10lu\n"
            "\n"
            "TSIG:\n"
            "   Formerr             = %10lu\n"
            "   Echo                = %10lu\n"
            "   BadKey              = %10lu\n"
            "   Verify Success      = %10lu\n"
            "   Verify Failed       = %10lu\n"
            "\n",
            pstat->SecContextCreate,
            pstat->SecContextFree,
            pstat->SecContextTimeout,
            pstat->SecContextQueueLength,
            pstat->SecContextQueue,
            pstat->SecContextQueueInNego,
            pstat->SecContextQueueNegoComplete,
            pstat->SecContextDequeue,
            pstat->SecPackAlloc,
            pstat->SecPackFree,

            pstat->SecTkeyInvalid,
            pstat->SecTkeyBadTime,
            pstat->SecTsigFormerr,
            pstat->SecTsigEcho,
            pstat->SecTsigBadKey,
            pstat->SecTsigVerifySuccess,
            pstat->SecTsigVerifyFailed
            );
        break;
    }

    case DNSSRV_STATID_MEMORY:
    {
        PDNSSRV_MEMORY_STATS pstat = (PDNSSRV_MEMORY_STATS) pStat;
        DWORD   i;
        LPSTR * pnameArray;
        DWORD   count;

        pnameArray = MemTagStrings;
        count = MEMTAG_COUNT;

        PrintRoutine( pPrintContext,
            "\n"
            "Memory Stats:\n"
            "-------------\n"
            "Memory:\n"
            "   Total Memory    = %10lu\n"
            "   Alloc Count     = %10lu\n"
            "   Free Count      = %10lu\n"
            "\n"
            "Standard Allocs:\n"
            "   Used            = %10lu\n"
            "   Returned        = %10lu\n"
            "   InUse           = %10lu\n"
            "   Memory          = %10lu\n"
            "\n"
            "Standard To Heap:\n"
            "   Alloc           = %10lu\n"
            "   Free            = %10lu\n"
            "   InUse           = %10lu\n"
            "   Memory          = %10lu\n"
            "\n"
            "Standard Blocks:\n"
            "   Alloc           = %10lu\n"
            "   Used            = %10lu\n"
            "   Returned        = %10lu\n"
            "   InUse           = %10lu\n"
            "   FreeList        = %10lu\n"
            "   FreeList Memory = %10lu\n"
            "   Total Memory    = %10lu\n"
            "\n"
            "Tagged Allocations:\n",

            pstat->Memory,
            pstat->Alloc,
            pstat->Free,

            pstat->StdUsed,
            pstat->StdReturn,
            pstat->StdInUse,
            pstat->StdMemory,

            pstat->StdToHeapAlloc,
            pstat->StdToHeapFree,
            pstat->StdToHeapInUse,
            pstat->StdToHeapMemory,

            pstat->StdBlockAlloc,
            pstat->StdBlockUsed,
            pstat->StdBlockReturn,
            pstat->StdBlockInUse,
            pstat->StdBlockFreeList,
            pstat->StdBlockFreeListMemory,
            pstat->StdBlockMemory
            );

        for ( i=0; i<count; i++ )
        {
            PrintRoutine( pPrintContext,
                "   %s\n"
                "       Alloc       = %10lu\n"
                "       Free        = %10lu\n"
                "       InUse       = %10lu\n"
                "       Mem         = %10lu\n",
                pnameArray[ i ],
                pstat->MemTags[ i ].Alloc,
                pstat->MemTags[ i ].Free,
                pstat->MemTags[ i ].Alloc - pstat->MemTags[i].Free,
                pstat->MemTags[ i ].Memory );
        }
        break;
    }

    case DNSSRV_STATID_DBASE:
    {
        PDNSSRV_DBASE_STATS  pstat = (PDNSSRV_DBASE_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Database Nodes:\n"
            "---------------\n"
            "Nodes:\n"
            "    Used       = %10lu\n"
            "    Returned   = %10lu\n"
            "    InUse      = %10lu\n"
            "    Memory     = %10lu\n"
            "\n",
            pstat->NodeUsed,
            pstat->NodeReturn,
            pstat->NodeInUse,
            pstat->NodeMemory
            );
        break;
    }

    case DNSSRV_STATID_RECORD:
    {
        PDNSSRV_RECORD_STATS  pstat = (PDNSSRV_RECORD_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Records:\n"
            "--------\n"
            "Flow:\n"
            "   Used                = %10lu\n"
            "   Returned            = %10lu\n"
            "   InUse               = %10lu\n"
            "   SlowFree Queued     = %10lu\n"
            "   SlowFree Completed  = %10lu\n"
            "   Memory              = %10lu\n"
            "\n"
            "Caching:\n"
            "   Total               = %10lu\n"
            "   Timeouts            = %10lu\n"
            "   In Use              = %10lu\n"
            "\n",
            pstat->Used,
            pstat->Return,
            pstat->InUse,
            pstat->SlowFreeQueued,
            pstat->SlowFreeFinished,
            pstat->Memory,
            pstat->CacheTotal,
            pstat->CacheTimeouts,
            pstat->CacheCurrent );
        break;
    }

    case DNSSRV_STATID_PACKET:
    {
        PDNSSRV_PACKET_STATS  pstat = (PDNSSRV_PACKET_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Packet Memory Usage:\n"
            "--------------------\n"
            "UDP Messages:\n"
            "    Alloc           = %10lu\n"
            "    Free            = %10lu\n"
            "    NetAllocs       = %10lu\n"
            "    Memory          = %10lu\n"
            "    Used            = %10lu\n"
            "    Returned        = %10lu\n"
            "    InUse           = %10lu\n"
            "    InFreeList      = %10lu\n",
            pstat->UdpAlloc,
            pstat->UdpFree,
            pstat->UdpNetAllocs,
            pstat->UdpMemory,
            pstat->UdpUsed,
            pstat->UdpReturn,
            pstat->UdpInUse,
            pstat->UdpInFreeList
            );

        //
        //  NS List stats added after Whistler beta 2.
        //

        PrintRoutine( pPrintContext,
            "    NsListUsed      = %10lu\n"
            "    NsListReturned  = %10lu\n"
            "    NsListInUse     = %10lu\n",
            pstat->PacketsForNsListUsed,
            pstat->PacketsForNsListReturned,
            pstat->PacketsForNsListInUse );

        PrintRoutine( pPrintContext,
            "\n"
            "TCP Messages:\n"
            "    Alloc           = %10lu\n"
            "    Realloc         = %10lu\n"
            "    Free            = %10lu\n"
            "    NetAllocs       = %10lu\n"
            "    Memory          = %10lu\n"
            "\n"
            "Recursion Messages:\n"
            "    Used            = %10lu\n"
            "    Returned        = %10lu\n"
            "\n",
            pstat->TcpAlloc,
            pstat->TcpRealloc,
            pstat->TcpFree,
            pstat->TcpNetAllocs,
            pstat->TcpMemory,
            pstat->RecursePacketUsed,
            pstat->RecursePacketReturn
            );
        break;
    }

    case DNSSRV_STATID_TIMEOUT:
    {
        PDNSSRV_TIMEOUT_STATS  pstat = (PDNSSRV_TIMEOUT_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Timeout:\n"
            "--------\n"
            "Nodes Queued\n"
            "    Total              = %10lu\n"
            "    Direct             = %10lu\n"
            "    FromReference      = %10lu\n"
            "    FromChildDelete    = %10lu\n"
            "    Dup Already Queued = %10lu\n"
            "Nodes Checked\n"
            "    Total              = %10lu\n"
            "    RecentAccess       = %10lu\n"
            "    ActiveRecord       = %10lu\n"
            "    CanNotDelete       = %10lu\n"
            "    Deleted            = %10lu\n"
            "TimeoutBlocks\n"
            "    Created            = %10lu\n"
            "    Deleted            = %10lu\n"
            "Delayed Frees\n"
            "    Queued             = %10lu\n"
            "      WithFunction     = %10lu\n"
            "    Executed           = %10lu\n"
            "      WithFunction     = %10lu\n",

            pstat->SetTotal,
            pstat->SetDirect,
            pstat->SetFromDereference,
            pstat->SetFromChildDelete,
            pstat->AlreadyInSystem,

            pstat->Checks,
            pstat->RecentAccess,
            pstat->ActiveRecord,
            pstat->CanNotDelete,
            pstat->Deleted,

            pstat->ArrayBlocksCreated,
            pstat->ArrayBlocksDeleted,
            pstat->DelayedFreesQueued,
            pstat->DelayedFreesQueuedWithFunction,
            pstat->DelayedFreesExecuted,
            pstat->DelayedFreesExecutedWithFunction
            );
        break;
    }

    case DNSSRV_STATID_ERRORS:
    {
        PDNSSRV_ERROR_STATS pstat = (PDNSSRV_ERROR_STATS)pStat;
        PrintRoutine( pPrintContext,
            "\n"
            "Error Stats:\n"
            "--------------\n"
            "\n"
            "   NoError             = %10lu\n"
            "   FormError           = %10lu\n"
            "   ServFail            = %10lu\n"
            "   NxDomain            = %10lu\n"
            "   NotImpl             = %10lu\n"
            "   Refused             = %10lu\n"
            "   YxDomain            = %10lu\n"
            "   YxRRSet             = %10lu\n"
            "   NxRRSet             = %10lu\n"
            "   NotAuth             = %10lu\n"
            "   NotZone             = %10lu\n"
            "   Max                 = %10lu\n"
            "   BadSig              = %10lu\n"
            "   BadKey              = %10lu\n"
            "   BadTime             = %10lu\n"
            "   UnknownError        = %10lu\n"
            "\n",
            pstat->NoError,
            pstat->FormError,
            pstat->ServFail,
            pstat->NxDomain,
            pstat->NotImpl,
            pstat->Refused,
            pstat->YxDomain,
            pstat->YxRRSet,
            pstat->NxRRSet,
            pstat->NotAuth,
            pstat->NotZone,
            pstat->Max,
            pstat->BadSig,
            pstat->BadKey,
            pstat->BadTime,
            pstat->UnknownError
            );
        break;
    }

    case DNSSRV_STATID_CACHE:
    {
        PDNSSRV_CACHE_STATS pstat = ( PDNSSRV_CACHE_STATS ) pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Cache Stats:\n"
            "------------\n"
            "   Checks where cache exceeded limit       = %10lu\n"
            "   Successful cache enforcement passes     = %10lu\n"
            "   Failed cache enforcement passes         = %10lu\n"
            "   Passes that required aggressive free    = %10lu\n"
            "   Passes where nothing was freed          = %10lu\n\n",
            pstat->CacheExceededLimitChecks,
            pstat->SuccessfulFreePasses,
            pstat->FailedFreePasses,
            pstat->PassesRequiringAggressiveFree,
            pstat->PassesWithNoFrees );
        break;
    }

    case DNSSRV_STATID_PRIVATE:
    {
        PDNSSRV_PRIVATE_STATS pstat = (PDNSSRV_PRIVATE_STATS)pStat;

        PrintRoutine( pPrintContext,
            "\n"
            "Private Stats:\n"
            "--------------\n"
            "\n"
            "Record Sources:\n"
            "   RR File             = %10lu\n"
            "   RR File Free        = %10lu\n"
            "   RR DS               = %10lu\n"
            "   RR DS Free          = %10lu\n"
            "   RR Admin            = %10lu\n"
            "   RR Admin Free       = %10lu\n"
            "   RR DynUp            = %10lu\n"
            "   RR DynUp Free       = %10lu\n"
            "   RR Axfr             = %10lu\n"
            "   RR Axfr Free        = %10lu\n"
            "   RR Ixfr             = %10lu\n"
            "   RR Ixfr Free        = %10lu\n"
            "   RR Copy             = %10lu\n"
            "   RR Copy Free        = %10lu\n"
            "   RR Cache            = %10lu\n"
            "   RR Cache Free       = %10lu\n"
#if 0
            "   RR NoExist          = %10lu\n"
            "   RR NoExist Free     = %10lu\n"
            "   RR Wins             = %10lu\n"
            "   RR Wins Free        = %10lu\n"
            "   RR WinsPtr          = %10lu\n"
            "   RR WinsPtr Free     = %10lu\n"
            "   RR Auto             = %10lu\n"
            "   RR Auto Free        = %10lu\n"
            "   RR Unknown          = %10lu\n"
            "   RR Unknown Free     = %10lu\n"
#endif
            "\n"
            "UDP Sockets:\n"
            "   PnP Socket Delete   = %10lu\n"
            "   Recvfrom Failure    = %10lu\n"
            "   ConnResets          = %10lu\n"
            "   ConnReset Overflow  = %10lu\n"
            "   GQCS Failure        = %10lu\n"
            "   GQCS Failure wCntxt = %10lu\n"
            "   GQCS ConnReset      = %10lu\n"
            "   Indicate Recv Fail  = %10lu\n"
            "   Restart Recv Pass   = %10lu\n"
            "\n"
            "TCP Connections:\n"
            "   ConnectAttempt      = %10lu\n"
            "   ConnectFailure      = %10lu\n"
            "   Connect             = %10lu\n"
            "   Query               = %10lu\n"
            "   Disconnect          = %10lu\n"
            "\n"
            "Security stats:\n"
            "   Verified Old Sig    = %10lu\n"
            "   Failed Old Sig      = %10lu\n"
            "   Big TimeSkew Bypass = %10lu\n"
            "\n",
            pstat->RecordFile,
            pstat->RecordFileFree,
            pstat->RecordDs,
            pstat->RecordDsFree,
            pstat->RecordAdmin,
            pstat->RecordAdminFree,
            pstat->RecordDynUp,
            pstat->RecordDynUpFree,
            pstat->RecordAxfr,
            pstat->RecordAxfrFree,
            pstat->RecordIxfr,
            pstat->RecordIxfrFree,
            pstat->RecordCopy,
            pstat->RecordCopyFree,
            pstat->RecordCache,
            pstat->RecordCacheFree,
#if 0
            pstat->RecordNoExist,
            pstat->RecordNoExistFree,
            pstat->RecordWins,
            pstat->RecordWinsFree,
            pstat->RecordWinsPtr,
            pstat->RecordWinsPtrFree,
            pstat->RecordAuto,
            pstat->RecordAutoFree,
            pstat->RecordUnknown,
            pstat->RecordUnknownFree,
#endif
            pstat->UdpSocketPnpDelete,
            pstat->UdpRecvFailure,
            pstat->UdpConnResets,
            pstat->UdpConnResetRetryOverflow,
            pstat->UdpGQCSFailure,
            pstat->UdpGQCSFailureWithContext,
            pstat->UdpGQCSConnReset,
            pstat->UdpIndicateRecvFailures,
            pstat->UdpRestartRecvOnSockets,

            pstat->TcpConnectAttempt,
            pstat->TcpConnectFailure,
            pstat->TcpConnect,
            pstat->TcpQuery,
            pstat->TcpDisconnect,

            pstat->SecTsigVerifyOldSig,
            pstat->SecTsigVerifyOldFailed,
            pstat->SecBigTimeSkewBypass
            );
        break;
    }

    default:

        DnsPrint_RpcStatRaw(
            PrintRoutine, pPrintContext,
            NULL,
            pStat,
            DNS_ERROR_INVALID_TYPE );
        break;

    }   //  end switch

    DnsPrint_Unlock();
}

//
//  End of print.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\client\dnscmd.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    DnsCmd.c

Abstract:

    Command line management for DNS Server.

Author:

    Jim Gilroy (jamesg)     September 1995

Revision History:

    Jing Chen (t-jingc)     June 1998
    Jim Gilroy (jamesg)     September 1998      cleanup

--*/


#include "dnsclip.h"
#include "dnsc_wmi.h"

#include <string.h>         //  strtoul()
#include <time.h>
#include <locale.h>


#define DNSCMD_UNICODE      1       //  unicode argv interface


extern PWSTR
getUnicodeForUtf8(
    IN      PSTR            pUtf8
    );

extern PWSTR
utf8ToUnicode(
    IN      PSTR            pszInputStr,
    IN      DWORD           dwInputLength
    );
    

//
//  Static IP array counts
//      values beyond any reasonable value anyone would send
//

#define MAX_IP_PROPERTY_COUNT       (200)


//
//  Globals -- allow these to be viewable in processing functions
//

LPSTR   pszServerName = NULL;
LPWSTR  pwszServerName = NULL;

LPSTR   pszCommandName = NULL;

extern DWORD   g_dwViewFlag;

BOOL    g_UseWmi = FALSE;


//
//  Printing
//

#define dnscmd_PrintRoutine     ((PRINT_ROUTINE) fprintf)

#define dnscmd_PrintContext     ((PPRINT_CONTEXT) stdout)


//
//  Command table setup
//

typedef DNS_STATUS ( * COMMAND_FUNCTION )(
    DWORD       argc,
    PSTR *      argv,
    PWSTR *     unicodeArgv );

typedef struct _COMMAND_INFO
{
    LPSTR               pszCommandName;
    COMMAND_FUNCTION    pCommandFunction;
    LPSTR               pComments;
}
COMMAND_INFO, *LPCOMMAND_INFO;

//
//  Command table
//

extern COMMAND_INFO GlobalCommandInfo[];

//
//  Dummy Argc to command function to indicate help requested
//

#define NEED_HELP_ARGC      (MAXDWORD)



//
//  Private utilites
//

COMMAND_FUNCTION
getCommandFunction(
    IN      LPSTR           pszCommandName
    )
/*++

Routine Description:

    Get function corresponding to command name.

Arguments:

    pszCommandName  -- command string

Return Value:

    Ptr to command function corresponding to command name.
    NULL if unrecognized command.

--*/
{
    DWORD i;

    //
    //  find command in list matching string
    //

    i = 0;
    while( GlobalCommandInfo[i].pszCommandName )
    {
        if( _stricmp(
                pszCommandName,
                GlobalCommandInfo[i].pszCommandName ) == 0 )
        {
            return( GlobalCommandInfo[i].pCommandFunction );
        }
        i++;
    }
    return NULL;
}



VOID
printCommands(
    VOID
    )
{
    DWORD i = 0;

    //
    //  display commands
    //  but stop display at "command barrier" (NULL function)
    //  commands below are duplicates or hidden
    //

    while( GlobalCommandInfo[i].pszCommandName &&
            GlobalCommandInfo[i].pCommandFunction )
    {
        printf( "  %-26s -- %s\n",
                GlobalCommandInfo[i].pszCommandName,
                GlobalCommandInfo[i].pComments );
        i++;
    }
}



LPSTR
getCommandName(
    IN      LPSTR           pszCmd
    )
/*++

Routine Description:

    Get command name.

    Remove "/" from begining of command.

Arguments:

    pszCmd  -- command string

Return Value:

    Ptr to command string (with no leading "/")
    NULL if not a command.

--*/
{
    if ( pszCmd && ( pszCmd[ 0 ] == '/' || pszCmd[ 0 ] == '-' ) )
    {
        return pszCmd + 1;
    }
    return NULL;
}



BOOL
getUserConfirmation(
    IN      LPSTR           pszString
    )
/*++

Routine Description:

    Get user's confirmation on a command.

Arguments:

    pszString -- configmation string

Return Value:

    TRUE if confirmed.
    FALSE if cancelled.

--*/
{
    int     ch;

    printf( "Are you sure you want to %s? (y/n) ", pszString );

    if ( ( (ch=getchar()) != EOF ) &&
         ( (ch == 'y') || (ch == 'Y') ) )
    {
        printf("\n");
        return( TRUE );
    }
    else
    {
        printf("\nCommand cancelled!\n");
        return( FALSE );
    }
}



DWORD
convertDwordParameterUnknownBase(
    IN      LPSTR           pszParam
    )
{
    INT base = 10;

    if ( *pszParam > '9'  ||  (*pszParam == '0' && *(pszParam+1) > '9') )
    {
        //  hex conversion
        base = 16;
    }
    return strtoul(
                pszParam,
                NULL,
                base );
}



DWORD
readIpAddressArray(
    OUT     PIP_ADDRESS     pAddrArray,
    IN      DWORD           ArraySize,
    IN      DWORD           Argc,
    IN      LPSTR *         Argv,
    IN      BOOL            fInaddrNoneAllowed
    )
/*++

Routine Description:

    Read IP array.

Arguments:

    pIpArray -- IP array buffer

    ArraySize -- IPs array can handle

    Argc -- remaining Argc

    Argv -- remaining Argv

    fInaddrNoneAllowed -- if TRUE, 255.255.255.255 is a valid input

Return Value:

    Count of IP in array.

--*/
{
    DWORD       count = 0;
    IP_ADDRESS  ip;

    while ( Argc && count < ArraySize )
    {
        ip = inet_addr( Argv[0] );

        //
        //  Allow INADDR_NONE if that address really was specified
        //  and it is allowed as a valid input.
        //

        if ( ip == INADDR_NONE &&
            ( !fInaddrNoneAllowed ||
                strcmp( Argv[ 0 ], "255.255.255.255" ) != 0 ) )
        {
            break;
        }

        pAddrArray[ count ] = ip;
        count++;

        Argc--;
        Argv++;
    }

    return count;
}



INT
ReadArgsIntoDnsTypeArray(
    OUT     PWORD           pTypeArray,
    IN      INT             ArraySize,
    IN      INT             Argc,
    IN      LPSTR *         Argv
    )
/*++

Routine Description:

    Read list of DNS type strings into a WORD array, one type value
    per word. The DNS types can be in numeric form or alpha form.
    e.g. "6" or "SOA"

    If the types are in alpha form, type strings that cannot be interpreted
    are not added to the array.

    DEVNOTE: This is for setting the NoRoundRobin type list, which I have
    not yet implemented via RPC.

Arguments:

    pIpArray -- IP array buffer

    ArraySize -- IPs array can handle

    Argc -- number of arguments

    Argv -- pointer to arguments

Return Value:

    Number of types successfully processed into array.

--*/
{
    INT         typeIdx;

    for ( typeIdx = 0; Argc && typeIdx < ArraySize; --Argc, ++Argv )
    {
        if ( isdigit( *Argv[ 0 ] ) )
        {
            pTypeArray[ typeIdx++ ] = ( WORD ) atoi( *Argv );
        }
        else
        {
            WORD    wType;
            
            wType = Dns_RecordTypeForName(
                        *Argv,
                        0 );        //  null-terminated
            if ( wType != 0 )
            {
                pTypeArray[ typeIdx++ ] = wType;
            }
        }
    }

    return typeIdx;
}   //  ReadArgsIntoDnsTypeArray



DWORD
parseZoneTypeString(
    IN      LPSTR           pszZoneType,
    OUT     BOOL *          pfDsIntegrated
    )
/*++

Routine Description:

    Get command name.

    Remove "/" from beggining of command.
    NULL if error (no "/")

Arguments:

    pszZoneType -- zone type string, e.g. "Secondary" or "2"

    pfDsIntegrated -- does type indicate zone should be DS integrated?

Return Value:

    DNS_ZONE_TYPE_XXX constant matching zone type or -1 if the type
    cannot be matched.

--*/
{
    DWORD zoneType = -1;

    ASSERT( pfDsIntegrated && pszZoneType );

    *pfDsIntegrated = FALSE;

    if ( *pszZoneType == '//' )
    {
        ++pszZoneType;
    }

    if ( !_stricmp( pszZoneType, "Primary" ) ||
                !_stricmp( pszZoneType, "1" ) )
    {
        zoneType = DNS_ZONE_TYPE_PRIMARY;
    }
    else if ( !_stricmp( pszZoneType, "DsPrimary" ) )
    {
        zoneType = DNS_ZONE_TYPE_PRIMARY;
        *pfDsIntegrated = TRUE;
    }
    else if ( !_stricmp( pszZoneType, "Secondary" ) ||
                !_stricmp( pszZoneType, "2" ) )
    {
        zoneType = DNS_ZONE_TYPE_SECONDARY;
    }
    else if ( !_stricmp( pszZoneType, "Stub" ) ||
                !_stricmp( pszZoneType, "3" ) )
    {
        zoneType = DNS_ZONE_TYPE_STUB;
    }
    else if ( !_stricmp( pszZoneType, "DsStub" ) )
    {
        zoneType = DNS_ZONE_TYPE_STUB;
        *pfDsIntegrated = TRUE;
    }
    else if ( !_stricmp( pszZoneType, "Forwarder" ) ||
                !_stricmp( pszZoneType, "4" ) )
    {
        zoneType = DNS_ZONE_TYPE_FORWARDER;
    }
    else if ( !_stricmp( pszZoneType, "DsForwarder" ) )
    {
        zoneType = DNS_ZONE_TYPE_FORWARDER;
        *pfDsIntegrated = TRUE;
    }

    return zoneType;
}



BOOL
parseDpSpecifier(
    IN      LPSTR           pszDpName,
    OUT     DWORD *         pdwDpFlag,          OPTIONAL
    OUT     LPSTR *         ppszCustomDpName
    )
/*++

Routine Description:

    Parses a directory partition name. Valid specifiers:

    /DomainDefault
    /ForestDefault
    /Legacy
    
    Anything that does not start with "/" is assumed to be the
    name of a custom DP. 

    If pdwDpFlag is non-NULL, then for a built-in partition
    ppszCustomDpName will be NULL and the appropriate DWORD flag
    value will be set at pdwDpFlag. If pdwDpFlag is NULL, then
    for built-in partitions ppszCustomDpName will be pointed to
    a static string such as DNS_DP_LEGACY_STR.

Arguments:

    pszDpName - name to be parsed - must be NULL-terminated

    pdwDpFlag - flag if DP is builtin, zero if custom

    ppszCustomDpName - set to ptr within pszDpName for customer

Return Value:

    FALSE if the specifier does not appear to be valid (e.g. is empty).

--*/
{
    BOOL rc = TRUE;
    
    static const LPSTR pszStaticLegacy = DNS_DP_LEGACY_STR;
    static const LPSTR pszStaticDomain = DNS_DP_DOMAIN_STR;
    static const LPSTR pszStaticForest = DNS_DP_FOREST_STR;

    if ( !ppszCustomDpName || !pszDpName || !*pszDpName )
    {
        rc = FALSE;
    }
    else
    {
        if ( pdwDpFlag )
        {
            *pdwDpFlag = 0;
        }
        *ppszCustomDpName = NULL;

        if ( *pszDpName == '/' || strncmp( pszDpName, "..", 2 ) == 0 )
        {
            //  Skip over preamble character(s).
            ++pszDpName;
            if ( *pszDpName == '.' )
            {
                ++pszDpName;
            }

            if ( toupper( *pszDpName ) == 'F' )
            {
                if ( pdwDpFlag )
                    *pdwDpFlag |= DNS_DP_FOREST_DEFAULT;
                else
                    *ppszCustomDpName = pszStaticForest;
            }
            else if ( toupper( *pszDpName ) == 'D' )
            {
                if ( pdwDpFlag )
                    *pdwDpFlag |= DNS_DP_DOMAIN_DEFAULT;
                else
                    *ppszCustomDpName = pszStaticDomain;

            }
            else if ( toupper( *pszDpName ) == 'L' )
            {
                if ( pdwDpFlag )
                    *pdwDpFlag |= DNS_DP_LEGACY;
                else
                    *ppszCustomDpName = pszStaticLegacy;
            }
            else
            {
                rc = FALSE;
            }
        }
        else
        {
            *ppszCustomDpName = pszDpName;
        }
    }
    return rc;
}   //  parseDpSpecifier



DWORD
readIpArray(
    OUT     PIP_ARRAY       pIpArray,
    IN      DWORD           ArraySize,
    IN      DWORD           Argc,
    IN      LPSTR *         Argv
    )
/*++

Routine Description:

    Read IP array.

    Wrapper around readIpAddressArray, to build IP_ARRAY structure.

Arguments:

    pIpArray -- IP array to write into

    ArraySize -- IPs array can handle

    Argc -- remaining Argc

    Argv -- remaining Argv

Return Value:

    Count of IP in array.

--*/
{
    DWORD   count;

    count = readIpAddressArray(
                pIpArray->AddrArray,
                ArraySize,
                Argc,
                Argv,
                FALSE );

    pIpArray->AddrCount = count;

    return count;
}



BOOL
readZoneAndDomainName(
    IN      LPSTR *         Argv,
    OUT     LPSTR *         ppZoneName,
    OUT     LPSTR *         ppNodeName,
    OUT     PBOOL           pbAllocatedNode,
    OUT     LPSTR *         ppZoneArg,          OPTIONAL
    OUT     LPSTR *         ppNodeArg           OPTIONAL
    )
/*++

Routine Description:

    Read zone and domain name.
    Build node FQDN if required.

Arguments:

    Argv -- argv with zone and node names

    ppZoneName -- addr to receive ptr to zone name

    ppNodeName -- addr to receive ptr to node name

    pbAllocatedNode -- ptr to bool set TRUE if allocate node name

    ppZoneArg -- addr to receive ptr to zone argument

    ppNodeArg -- addr to receive ptr to node argument

Return Value:

    TRUE -- if in authoritative zone
    FALSE -- if cache or root hints

--*/
{
    LPSTR           pzoneName;
    LPSTR           pnodeName;
    LPSTR           pzoneArg;
    LPSTR           pnodeArg;
    BOOL            ballocated = FALSE;
    BOOL            bauthZone = TRUE;

    //
    //  read zone name
    //      - special case RootHints and Cache
    //      setting zone to special string
    //

    pzoneName = pzoneArg = *Argv;
    if ( *pzoneArg == '/' )
    {
        if ( _stricmp( pzoneArg, "/RootHints" ) == 0 )
        {
            pzoneName = DNS_ZONE_ROOT_HINTS_A;
            bauthZone = FALSE;
        }
        else if ( _stricmp( pzoneArg, "/Cache" ) == 0 )
        {
            pzoneName = DNS_ZONE_CACHE_A;
            bauthZone = FALSE;
        }
    }
    else if ( *pzoneArg == '.' )
    {
        if ( _stricmp( pzoneArg, "..RootHints" ) == 0 )
        {
            pzoneName = DNS_ZONE_ROOT_HINTS_A;
            bauthZone = FALSE;
        }
        else if ( _stricmp( pzoneArg, "..Cache" ) == 0 )
        {
            pzoneName = DNS_ZONE_CACHE_A;
            bauthZone = FALSE;
        }
    }
    Argv++;

    //
    //  Node name
    //      - for zones, accept file format and append zone name
    //      - root hints or cache must be FQDN
    //

    pnodeArg = *Argv;

    if ( bauthZone )
    {
        if ( strcmp( pnodeArg, "@" ) == 0 )
        {
            pnodeName = pzoneName;
        }
        else if ( Dns_IsNameFQDN( pnodeArg ) )
        {
            // input pnodeName is FQDN, with a trailing dot
            pnodeName = pnodeArg;
        }
        else
        {
            //append zone name to the end of pnodeName
            pnodeName = malloc( 2 +  strlen(pzoneName) + strlen(pnodeArg) );
            if ( pnodeName )
            {
                strcpy ( pnodeName, pnodeArg );
                strcat ( pnodeName, "." );
                strcat ( pnodeName, pzoneName );
                ballocated = TRUE;
            }
        }
    }
    else
    {
        pnodeName = *Argv;
    }

    //
    //  set out params
    //

    if ( ppZoneName )
    {
        *ppZoneName = pzoneName;
    }
    if ( ppNodeName )
    {
        *ppNodeName = pnodeName;
    }
    if ( pbAllocatedNode )
    {
        *pbAllocatedNode = ballocated;
    }
    if ( ppZoneArg )
    {
        *ppZoneArg = pzoneArg;
    }
    if ( ppNodeArg )
    {
        *ppNodeArg = pnodeArg;
    }

    return bauthZone;
}



DNS_STATUS
getServerVersion(
    IN      LPWSTR      pwszServerName,
    IN      BOOL        fPrintVersion,
    OUT     PDWORD      pdwMajorVersion,        OPTIONAL
    OUT     PDWORD      pdwMinorVersion,        OPTIONAL
    OUT     PDWORD      pdwBuildNum,            OPTIONAL
    OUT     PDWORD      pdwDomainVersion
    )
/*++

Routine Description:

    Query server for version information.

Arguments:
    
    pwszServerName -- name of DNS server

    fPrintVersion -- if TRUE this function will print one-line server version

    pdwMajorVersion -- ptr to DWORD to receive major version or NULL

    pdwMinorVersion -- ptr to DWORD to receive minor version or NULL

    pdwBuildNum -- ptr to DWORD to receive build number or NULL
    
    pdwDomainVersion -- ptr to DWORD to receive domain behavior version or NULL

Return Value:

    Status code.
--*/
{
    DNS_STATUS              status = ERROR_SUCCESS;
    DWORD                   dataType;
    PDNS_RPC_SERVER_INFO    pServerInfo = NULL;
    DWORD                   dwMajorVersion = 0;
    DWORD                   dwMinorVersion = 0;
    DWORD                   dwBuildNum = 0;
    DWORD                   dwDomainVersion = 0;

    //
    //  Retrieve server info.
    //

    status = DnssrvQuery(
                pwszServerName,
                NULL,                       //  zone
                DNSSRV_QUERY_SERVER_INFO,
                &dataType,
                &pServerInfo );

    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }

    if ( !pServerInfo || dataType != DNSSRV_TYPEID_SERVER_INFO )
    {
        status = ERROR_NOT_FOUND;
        goto Done;
    }

    //
    //  Parse version.
    //

    dwMajorVersion =    pServerInfo->dwVersion & 0x000000FF;
    dwMinorVersion =    ( pServerInfo->dwVersion & 0x0000FF00 ) >> 8;
    dwBuildNum =        pServerInfo->dwVersion >> 16;
    dwDomainVersion =   pServerInfo->dwDsDomainVersion;

    //
    //  Optionally print version.
    //

    if ( fPrintVersion )
    {
        printf( "DNS server %S version is %d.%d.%d",
            pwszServerName,
            dwMajorVersion,
            dwMinorVersion,
            dwBuildNum );

        #if DBG
        printf( ", domain version is %d",
            dwDomainVersion );
        #endif

        printf( "\n\n" );
    }

    //
    //  Store version numbers to output destinations.
    //

    Done:

    if ( pdwMajorVersion )
    {
        *pdwMajorVersion = dwMajorVersion;
    }
    if ( pdwMinorVersion )
    {
        *pdwMinorVersion = dwMinorVersion;
    }
    if ( pdwBuildNum )
    {
        *pdwBuildNum = dwBuildNum;
    }
    if ( pdwDomainVersion )
    {
        *pdwDomainVersion = dwDomainVersion;
    }

    return status;
}   //  getServerVersion



DNS_STATUS
processCacheSizeQuery(
    LPWSTR      pwszServerName
    )
/*++

Routine Description:

    Query server and print current cache usage.

Arguments:
    
    pwszServerName -- name of DNS server

Return Value:

    Status code.
--*/
{
    DNS_STATUS              status = ERROR_SUCCESS;
    PDNS_RPC_BUFFER         pStatBuff = NULL;
    PDNSSRV_MEMORY_STATS    pMemStats = NULL;
    PDNSSRV_STAT            pStat;
    PCHAR                   pch;
    PCHAR                   pchstop;

    //
    //  Print server version
    //

    getServerVersion(
        pwszServerName,
        TRUE,
        NULL, NULL, NULL, NULL );

    //
    //  Retrieve statistics from server.
    //

    status = DnssrvGetStatistics(
                pwszServerName,
                DNSSRV_STATID_MEMORY,
                &pStatBuff );
    if ( status != ERROR_SUCCESS )
    {
        goto Done;
    }
    if ( !pStatBuff )
    {
        printf( "Error: statistics buffer missing\n" );
        goto Done;
    }

    //
    //  Loop through returned stats to find memory stats.
    //

    pch = pStatBuff->Buffer;
    pchstop = pch + pStatBuff->dwLength;
    while ( pch < pchstop )
    {
        pStat = ( PDNSSRV_STAT ) pch;
        pch = ( PCHAR ) GET_NEXT_STAT_IN_BUFFER( pStat );
        if ( pch > pchstop )
        {
            printf( "Error: invalid stats buffer\n" );
            goto Done;
        }

        //  printf( "Found stat ID %08X\n", pStat->Header.StatId );

        if ( pStat->Header.StatId == DNSSRV_STATID_MEMORY )
        {
            pMemStats = ( PDNSSRV_MEMORY_STATS ) pStat;
            break;
        }
    }

    if ( pMemStats == NULL )
    {
        printf( "Error: unable to retrieve memory statistics\n" );
        status = ERROR_NOT_SUPPORTED;
        goto Done;
    }

    //
    //  Print results.
    //

    printf( "Cache usage for server %S is %d bytes:\n"
        "  Nodes: %d (%d bytes)\n"
        "  RRs: %d (%d bytes)\n",
        pwszServerName,
        pMemStats->MemTags[ MEMTAG_NODE_CACHE ].Memory +
            pMemStats->MemTags[ MEMTAG_RECORD_CACHE ].Memory,
        pMemStats->MemTags[ MEMTAG_NODE_CACHE ].Alloc -
            pMemStats->MemTags[ MEMTAG_NODE_CACHE ].Free,
        pMemStats->MemTags[ MEMTAG_NODE_CACHE ].Memory,
        pMemStats->MemTags[ MEMTAG_RECORD_CACHE ].Alloc -
            pMemStats->MemTags[ MEMTAG_RECORD_CACHE ].Free,
        pMemStats->MemTags[ MEMTAG_RECORD_CACHE ].Memory);

    Done:

    return status;
}   //  processCacheSizeQuery


//
//  Prototypes for forward references.
//

DNS_STATUS
ProcessDisplayAllZoneRecords(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    );



//
//  DnsCmd entry point
//

INT
__cdecl
wmain(
    IN      int             argc,
    IN      PWSTR *         Argv
    )
/*++

Routine Description:

    DnsCmd program entry point.

    Executes specified command corresponding to a DNS Server API
    call, using the specified server name.

Arguments:

    argc -- arg count

    argv -- argument list
        argv[1] -- DNS ServerName
        argv[2] -- Command to execute
        argv[3...] -- arguments to command

Return Value:

    Return from the desired command.  Usually a pass through of the return
    code from DNS API call.

--*/
{
    DNS_STATUS          status = ERROR_SUCCESS;
    COMMAND_FUNCTION    pcommandFunc;
    DWORD               commandArgc;
    LPSTR *             commandArgv;
    LPSTR               parg1;
    WSADATA             wsadata;
    PSTR *              argv = NULL;
    PWSTR *             unicodeArgv = Argv;
    int                 i;

    UINT                codepage;
    char                achCodepage[12] = ".OCP";

    //
    //  Initialize localization stuff - so that printf() of non-US characters
    //  will work properly. I stole this code from dcdiag.
    //
    
    if ( codepage = GetConsoleOutputCP() )
    {
        sprintf( achCodepage, ".%u", codepage );
        setlocale( LC_ALL, achCodepage );
    }
    else
    {
        //
        //  We do this because LC_ALL sets the LC_CTYPE as well, and we're
        //  not supposed to do that, say the experts if we're setting the
        //  locale to ".OCP".
        //
        
        setlocale( LC_COLLATE, achCodepage );   //  sets the sort order 
        setlocale( LC_MONETARY, achCodepage );  //  sets the currency formatting rules
        setlocale( LC_NUMERIC, achCodepage );   //  sets the formatting of numerals
        setlocale( LC_TIME, achCodepage );      //  defines the date/time formatting
    }

    //
    //  Initialize debug logging.
    //

    DnssrvInitializeDebug();
    
    //
    //  Initialize Winsock in case we want to call any Winsock functions.
    //

    WSAStartup( MAKEWORD( 2, 0 ), &wsadata );

    //
    //  Convert Unicode arguments to UTF8.
    //

    argv = ALLOCATE_HEAP( ( argc + 1 ) * sizeof( PCHAR ) );

    for ( i = 0; i < argc; ++i )
    {
        argv[ i ] = Dns_NameCopyAllocate(
                            ( PCHAR ) Argv[ i ],
                            0,          // no given length (use strlen)
                            DnsCharSetUnicode,
                            DnsCharSetUtf8 );
    }
    argv[ i ] = NULL;

    //
    //  DnsCmd <ServerName> [/WMI] <Command> [<Command Parameters>]
    //
    //  Skip EXE name parameter.
    //

    if ( argc < 2 )
    {
        goto Help;
    }
    --argc;
    ++argv;
    ++unicodeArgv;
    
    //
    //  DNS server IP address/name parameter
    //

    pszServerName = argv[ 0 ];
    if ( *pszServerName == '/' )
    {
        pszServerName = ".";
    }
    else
    {
        argc--;
        argv++;
        unicodeArgv++;
    }

    pwszServerName = Dns_NameCopyAllocate(
                        pszServerName,
                        0,          // no given length (use strlen)
                        DnsCharSetUtf8,
                        DnsCharSetUnicode );

    //
    //  Check for optional WMI parameter.
    //

    if ( argc && argv[ 0 ] && _stricmp( argv[ 0 ], "/WMI" ) == 0 )
    {
        g_UseWmi = TRUE;
        --argc;
        ++argv;
        ++unicodeArgv;
        if ( argc < 1 )
        {
            goto Help;
        }

        status = DnscmdWmi_Initialize( pwszServerName );
        if ( status != ERROR_SUCCESS )
        {
            printf(
                "Fatal error 0x%08X during WMI initialization to server \"%S\"\n",
                status,
                pwszServerName );
            goto Done;
        }
        printf(
            "Opened WMI connection to server \"%S\"\n\n",
            pwszServerName );
    }

    //
    //  next parameter is command name, retrieve associated function
    //

    if ( argc == 0 )
    {
        status = ERROR_SUCCESS;
        goto Help;
    }
    pszCommandName = argv[0];
    pcommandFunc = getCommandFunction( pszCommandName );
    if( !pcommandFunc )
    {
        if ( _stricmp( pszCommandName, "/?" ) == 0 ||
             _stricmp( pszCommandName, "/help" ) == 0 )
        {
            status = ERROR_SUCCESS;
        }
        else
        {
            status = ERROR_INVALID_PARAMETER;
            printf(
                "Unknown Command \"%s\" Specified -- type DnsCmd -?.\n",
                pszCommandName );
        }
        goto Help;
    }

    //
    //  set argc, argv for rest of parameters
    //

    commandArgc = (DWORD)(argc - 1);
    commandArgv = &argv[1];

    //
    //  test for help request on specific command
    //      - if found, dispatch with Argc=0, to force help
    //

    if ( commandArgc > 0 )
    {
        parg1 = commandArgv[0];
        if ( *parg1 == '?' ||
            _stricmp( parg1, "/?" ) == 0 ||
            _stricmp( parg1, "/help" ) == 0 )
        {
            commandArgc = NEED_HELP_ARGC;
        }
    }

    //
    //  dispatch to processor for this command
    //

    status = pcommandFunc( commandArgc, commandArgv, &unicodeArgv[ 1 ] );

    Dns_EndDebug();

    if ( commandArgc != NEED_HELP_ARGC && status != ERROR_SUCCESS )
    {
        printf( "\nCommand failed:  %s     %ld  (%08lx)\n",
            Dns_StatusString( status ),
            status, status );
        if ( status == ERROR_INVALID_PARAMETER )
        {
            printf( "\nCheck the required arguments and format of your command.\n" );
        }
    }
    else
    {
        //
        //  Do not output success message for commands where the output
        //  may be piped to file for a specific use (e.g. zone file output).

        if ( pcommandFunc != ProcessDisplayAllZoneRecords &&
             commandArgc != NEED_HELP_ARGC )
        {
            printf( "Command completed successfully.\n" );
        }
    }


    goto Done;

    //
    //  Output help text.
    //

    Help:

    printf(
        "\nUsage: DnsCmd <ServerName> <Command> [<Command Parameters>]\n\n"
        "<ServerName>:\n"
        "  IP address or host name    -- remote or local DNS server\n"
        "  .                          -- DNS server on local machine\n"
        "<Command>:\n" );

    printCommands();

    printf(
        "\n<Command Parameters>:\n"
        "  DnsCmd <CommandName> /? -- For help info on specific Command\n" );

    //
    //  Cleanup and return.
    //

    Done:

    if ( g_UseWmi )
    {
        DnscmdWmi_Free();
    }

    WSACleanup();

    return status;
}




//
//  Command Functions
//


//
//  Info Query  --  for Server or Zone
//

DNS_STATUS
ProcessInfo(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       typeid;
    PVOID       pdata;
    LPCSTR      pszQueryName;

    //
    //  /Info [<PropertyName>]
    //
    //  get specific property to query -- if given
    //  if not specific query, default to ZONE_INFO
    //

    if ( Argc == 0 )
    {
        pszQueryName = DNSSRV_QUERY_SERVER_INFO;
    }
    else if ( Argc == 1 )
    {
        //
        //  Allow property name to be bare or preceded by command char.
        //

        pszQueryName = getCommandName( Argv[0] );
        if ( !pszQueryName )
        {
            pszQueryName = Argv[ 0 ];
        }
    }
    else
    {
        goto Help;
    }

    //
    //  Handle meta-queries: queries that involve client-side parsing
    //

    if ( _stricmp( pszQueryName, "CacheSize" ) == 0 )
    {
        status = processCacheSizeQuery( pwszServerName );
    }
    else
    {
        //
        //  query, print result on success
        //

        if ( g_UseWmi )
        {
            status = DnscmdWmi_ProcessDnssrvQuery(
                        NULL,               //  zone
                        pszQueryName );
        }
        else
        {
            status = DnssrvQuery(
                        pwszServerName,
                        NULL,               //  no zone
                        pszQueryName,       //  query name
                        & typeid,
                        & pdata );

            if ( status == ERROR_SUCCESS )
            {
                printf( "Query result:\n" );
                DnsPrint_RpcUnion(
                    dnscmd_PrintRoutine,
                    dnscmd_PrintContext,
                    NULL,
                    typeid,
                    pdata );
            }
        }

        if ( status != ERROR_SUCCESS )
        {
            printf(
                "Info query failed\n"
                "    status = %d (0x%08lx)\n",
                status, status );
        }
    }

    return status;

Help:
    printf(
        "Usage: DnsCmd <Server> /Info [<Property>]\n"
        "  <Property> -- server property to view\n"
        "  Examples:\n"
        "    BootMethod\n"
        "    RpcProtocol\n"
        "    LogLevel\n"
        "    EventlogLevel\n"
        "    NoRecursion\n"
        "    ForwardDelegations\n"
        "    ForwardingTimeout\n"
        "    IsSlave\n"
        "    SecureResponses\n"
        "    RecursionRetry\n"
        "    RecursionTimeout\n"
        "    " DNS_REGKEY_ADDITIONAL_RECURSION_TIMEOUT "\n"
        "    MaxCacheTtl\n"
        "    MaxNegativeCacheTtl\n"
        "    RoundRobin\n"
        "    LocalNetPriority\n"
        "    AddressAnswerLimit\n"
        "    BindSecondaries\n"
        "    WriteAuthorityNs\n"
        "    NameCheckFlag\n"
        "    StrictFileParsing\n"
        "    UpdateOptions\n"
        "    DisableAutoReverseZones\n"
        "    SendPort\n"
        "    NoTcp\n"
        "    XfrConnectTimeout\n"
        "    DsPollingInterval\n"
        "    ScavengingInterval\n"
        "    DefaultAgingState\n"
        "    DefaultNoRefreshInterval\n"
        "    DefaultRefreshInterval\n" );

    return ERROR_INVALID_PARAMETER;
}



DNS_STATUS
ProcessZoneInfo(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       typeid;
    PVOID       pdata;
    LPCSTR      pqueryName;

    //
    //  /ZoneInfo <ZoneName> [<PropertyName>]
    //
    //  get specific query -- if given
    //  if not specific query, default to ZONE_INFO
    //

    if ( Argc == 1 )
    {
        pqueryName = DNSSRV_QUERY_ZONE_INFO;
    }
    else if ( Argc == 2 )
    {
        pqueryName = getCommandName( Argv[1] );
        if ( !pqueryName )
        {
            pqueryName = Argv[1];
        }
    }
    else
    {
        goto Help;
    }

    //
    //  query, print result on success
    //

    if ( g_UseWmi )
    {
        status = DnscmdWmi_ProcessZoneInfo(
                    Argv[ 0 ] );
    }
    else
    {
        status = DnssrvQuery(
                    pwszServerName,
                    Argv[0],        // zone name
                    pqueryName,     // query name
                    &typeid,
                    &pdata );

        if ( status == ERROR_SUCCESS )
        {
            printf( "Zone query result:\n" );
            DnsPrint_RpcUnion(
                dnscmd_PrintRoutine,
                dnscmd_PrintContext,
                NULL,
                typeid,
                pdata );
        }
        else
        {
            printf(
                "Zone info query failed\n"
                "    status = %d (0x%08lx)\n",
                status, status );
        }
    }
    return status;

Help:
    printf(
        "Usage: DnsCmd <Server> /ZoneInfo <ZoneName> [<Property>]\n"
        "  <Property> -- zone property to view\n"
        "  Examples:\n"
        "    AllowUpdate\n"
        "    DsIntegrated\n"
        "    Aging\n"
        "    RefreshInterval\n"
        "    NoRefreshInterval\n" );

    return ERROR_INVALID_PARAMETER;
}



//
//  Simple server operations
//

DNS_STATUS
ProcessSimpleServerOperation(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       cmd;

    //
    //  <Simple Server Command>  no parameters
    //  Commands:
    //      - DebugBreak
    //      - ClearDebugLog
    //      - Restart
    //      - DisplayCache
    //      - Reload
    //

    if ( Argc != 0 )
    {
        printf( "Usage: DnsCmd <ServerName> %s%s\n",
            ( pszCommandName && *pszCommandName != '/' ) ? "/" : "",
            pszCommandName );
        return ERROR_INVALID_PARAMETER;
    }

    if ( g_UseWmi )
    {
        status = DnscmdWmi_ProcessDnssrvOperation(
                    NULL,
                    getCommandName( pszCommandName ),
                    DNSSRV_TYPEID_NULL,
                    ( PVOID ) NULL );
    }
    else
    {
        status = DnssrvOperation(
                    pwszServerName,
                    NULL,
                    getCommandName( pszCommandName ),
                    DNSSRV_TYPEID_NULL,
                    NULL );
    }

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "%s completed successfully.\n",
            pszServerName );
    }
    else
    {
        printf(
            "%s failed:  status = %d (0x%08lx).\n",
            pszServerName,
            status, status );
    }
    return status;
}


DNS_STATUS
ProcessAutoConfigure(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       cmd;
    DWORD       iarg = 0;
    DWORD       dwflag = 0;

    while ( iarg < Argc )
    {
        cmd = getCommandName( Argv[ iarg ] );

        if ( cmd )
        {
            if ( !_strnicmp( cmd, "For", 3 ) )
            {
                dwflag |= DNS_RPC_AUTOCONFIG_FORWARDERS;
            }
            else if ( !_strnicmp( cmd, "Roo", 3 ) )
            {
                dwflag |= DNS_RPC_AUTOCONFIG_ROOTHINTS;
            }
            else if ( !_strnicmp( cmd, "Sel", 3 ) )
            {
                dwflag |= DNS_RPC_AUTOCONFIG_SELFPOINTCLIENT;
            }
            else
            {
                goto Help;
            }
            ++iarg;
        }
        else
        {
            goto Help;
        }
    }

    if ( !dwflag )
    {
        dwflag = DNS_RPC_AUTOCONFIG_SELFPOINTCLIENT |
                 DNS_RPC_AUTOCONFIG_ROOTHINTS |
                 DNS_RPC_AUTOCONFIG_FORWARDERS;
    }
    
    status = DnssrvOperation(
                pwszServerName,
                NULL,
                DNSSRV_OP_AUTO_CONFIGURE,
                DNSSRV_TYPEID_DWORD,
                ( PVOID ) ( DWORD_PTR ) dwflag );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "%s completed successfully.\n",
            pszServerName );
    }
    else
    {
        printf(
            "%s failed:  status = %d (0x%08lx).\n",
            pszServerName,
            status, status );
    }
    return status;

Help:

    printf(
        "Usage: DnsCmd <ServerName> /" DNSSRV_OP_AUTO_CONFIGURE " [Options]\n"
        "  Configures DNS server and client using the current DNS client settings\n"
        "  Options can be on or more of:\n"
        "    /Forwarders -- configure DNS server with forwarders\n"
        "    /RootHints -- configure DNS server with root hints\n"
        "    /SelfPoint -- configure DNS client to point to local DNS server\n"
        "  If no options are specified, default is all options\n" );
    return ERROR_INVALID_PARAMETER;
}   //  ProcessAutoConfigure



DNS_STATUS
ProcessStatistics(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS          status = ERROR_SUCCESS;
    DWORD               statid = DNSSRV_STATID_ALL;   // default to all
    PDNS_RPC_BUFFER     pstatsBuf = NULL;
    LPSTR               cmd;

    //
    //  Statistics [/<StatId> | /Clear]
    //

    if ( Argc > 1 )
    {
        goto Help;
    }

    //
    //  if command -- execute command
    //      /Clear is only supported command
    //
    //

    cmd = getCommandName( Argv[0] );
    if ( cmd )
    {
        if ( !_stricmp(cmd, "Clear" ) )
        {
            status = DnssrvOperation(
                        pwszServerName,
                        NULL,
                        "ClearStatistics",
                        DNSSRV_TYPEID_NULL,
                        NULL );
            if ( status == ERROR_SUCCESS )
            {
                printf("DNS Server %S statistics cleared.\n", pwszServerName );
            }
            return status;
        }
        goto Help;
    }

    //
    //  view statistics
    //      - if specific statid given, read it

    if ( Argc > 0 )
    {
        statid = strtoul(
                    Argv[0],
                    NULL,
                    16 );
        if ( statid == 0 )
        {
            statid = (-1);
        }
    }

    if ( g_UseWmi )
    {
        status = DnscmdWmi_GetStatistics(
                    statid );
    }
    else
    {
        status = DnssrvGetStatistics(
                    pwszServerName,
                    statid,
                    & pstatsBuf );
        if ( status == ERROR_SUCCESS )
        {
            printf( "DNS Server %S statistics:\n", pwszServerName );
            DnsPrint_RpcStatsBuffer(
                dnscmd_PrintRoutine,
                dnscmd_PrintContext,
                NULL,
                pstatsBuf );
        }
    }

    return status;

Help:
    printf(
        "Usage: DnsCmd <ServerName> /Statistics [<StatId> | /Clear]\n"
        "  <StatId> -- ID of particular stat desired. (ALL is the default)\n"
        "    %08lx    -- Time       \n"
        "    %08lx    -- Query      \n"
        "    %08lx    -- Query2     \n"
        "    %08lx    -- Recurse    \n"
        "    %08lx    -- Master     \n"
        "    %08lx    -- Secondary  \n"
        "    %08lx    -- Wins       \n"
        "    %08lx    -- Wire Update\n"
        "    %08lx    -- Security   \n"
        "    %08lx    -- Ds         \n"
        "    %08lx    -- Internal Update\n"
        "    %08lx    -- Memory     \n"
        "    %08lx    -- Dbase      \n"
        "    %08lx    -- Records    \n"
        "    %08lx    -- PacketMem  \n"
        "  /Clear   -- clear statistics data\n",
        DNSSRV_STATID_TIME,
        DNSSRV_STATID_QUERY,
        DNSSRV_STATID_QUERY2,
        DNSSRV_STATID_RECURSE,
        DNSSRV_STATID_MASTER,
        DNSSRV_STATID_SECONDARY,
        DNSSRV_STATID_WINS,
        DNSSRV_STATID_WIRE_UPDATE,
        DNSSRV_STATID_SKWANSEC,
        DNSSRV_STATID_DS,
        DNSSRV_STATID_NONWIRE_UPDATE,
        DNSSRV_STATID_MEMORY,
        DNSSRV_STATID_DBASE,
        DNSSRV_STATID_RECORD,
        DNSSRV_STATID_PACKET );
    return ERROR_INVALID_PARAMETER;
}

//
//  Update server data file(s)
//    for one zone, when <zonename> specified
//    all files: no <zonename> specified
//

DNS_STATUS
ProcessWriteBackFiles(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       zonename = NULL;
    LPSTR       cmd;

    //
    //  WriteBackFiles [ZoneName]
    //

    if ( Argc > 1 )
    {
        goto Help;
    }

    if ( Argc == 0 )
    {
        cmd = "WriteDirtyZones";
    }
    else
    {
        zonename = Argv[0];
        cmd = "WriteBackFile";
    }

    status = DnssrvOperation(
                pwszServerName,     //server
                zonename,           //zone
                cmd,                //cmd
                DNSSRV_TYPEID_NULL,
                (PVOID) NULL );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "Sever data file(s) updated. \n"
            );
    }
    return status;

Help:

    printf(
        "Usage: DnsCmd <ServerName> /WriteBackFiles [<ZoneName>]\n"
        "  <ZoneName> -- FQDN of a zone whose datafile to be written back\n"
        "    Default: write back datafile for all dirty zones\n"
        );
    return ERROR_INVALID_PARAMETER;
}



DNS_STATUS
ProcessRecordAdd(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDNS_RECORD     prr;
    PDNS_RPC_RECORD prrRpc;
    LPSTR           pzoneName;
    LPSTR           pnodeName;
    BOOL            ballocatedNode;
    LPSTR           pzoneArg;
    WORD            wType;
    DWORD           ttl = 0;
    DWORD           ttlFlag = 0;
    CHAR            buf[33];
    DWORD           baging = 0;
    DWORD           bopenAcl = 0;


    //
    //  RecordAdd <Zone> <Node> [/AgeOn | /AgeOff] [/AdminAcl] [<TTL>] <RRType> <RRData>
    //

    if ( Argc < 4 || Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    //
    //  read zone and domain name
    //

    readZoneAndDomainName(
        Argv,
        & pzoneName,
        & pnodeName,
        & ballocatedNode,
        & pzoneArg,
        NULL );

    Argv++;
    Argc--;
    Argv++;
    Argc--;

    //
    //  Aging ON\OFF
    //

    if ( Argc )
    {
        if ( _stricmp( *Argv, "/Aging" ) == 0 ||
             _stricmp( *Argv, "/AgeOn" ) == 0 )
        {
            baging = 1;
            Argv++;
            Argc--;
        }
#if 0
        else if ( _stricmp( *Argv, "/AgeOff" ) == 0 )
        {
            baging = 0;
            Argv++;
            Argc--;
        }
#endif
    }

    if ( Argc && _stricmp( *Argv, "/OpenAcl" ) == 0 )
    {
        bopenAcl = TRUE;
        Argv++;
        Argc--;
    }

    //
    //  TTL -- optional
    //      - use default if none given
    //

    ttl = strtoul(
                *Argv,
                NULL,
                10 );

    if ( ttl == 0  &&  strcmp(*Argv, "0") != 0  )
    {
        ttlFlag = DNS_RPC_RECORD_FLAG_DEFAULT_TTL;
    }
    else    //  read TTL
    {
        Argv++;
        Argc--;
        if ( Argc < 1 )
        {
            goto Help;
        }
    }

    //
    //  record type
    //

    wType = Dns_RecordTypeForName( *Argv, 0 );
    if ( !wType )
    {
        printf( "Invalid RRType: <%s>!\n", *Argv );
        goto Help;
    }
    Argv++;
    Argc--;

    //
    //  build DNS_RECORD
    //      - if no record data, then type delete
    //      - otherwise build record
    //

    if ( !Argc )
    {
        prrRpc = ALLOCATE_HEAP( SIZEOF_DNS_RPC_RECORD_HEADER );
        if ( !prrRpc )
        {
            printf( "Not enough memory!\n" );
            return ERROR_SUCCESS;
        }
        prrRpc->wDataLength = 0;
        prrRpc->wType = wType;
    }

    else
    {
        prr = Dns_RecordBuild_A(
                    NULL,           // ptr to RRSet
                    pnodeName,    // nameOwner
                    wType,          // RR type in WORD
                    FALSE,          // ! S.Delete
                    0,              // S.section
                    Argc,           // count of strings
                    Argv            // strings to fill into RR
                    );
        if ( ! prr )
        {
            printf( "\nInvalid Data!\n" );
            goto Help;
        }

        //  convert DNS_RECORD to RPC buffer

        prrRpc = DnsConvertRecordToRpcBuffer( prr );
        if ( ! prrRpc )
        {
#if DBG
            printf("DnsConvertRecordToRpcBuffer() failed\n");
#endif
            status = GetLastError();
            goto Help;
        }
        //  prr and prrRpc freed by process termination
    }

    //
    //  set TTL and flags for the RR
    //

    prrRpc->dwTtlSeconds = ttl;
    prrRpc->dwFlags = ttlFlag;

    if ( baging )
    {
        prrRpc->dwFlags |= DNS_RPC_RECORD_FLAG_AGING_ON;
    }
    if ( bopenAcl )
    {
        prrRpc->dwFlags |= DNS_RPC_FLAG_OPEN_ACL;
    }

    if ( g_UseWmi )
    {
        status = DnscmdWmi_ProcessRecordAdd(
                    pzoneName,
                    pnodeName,
                    prrRpc,
                    Argc,
                    Argv );
    }
    else
    {
        status = DnssrvUpdateRecord(
                     pwszServerName,    // server
                     pzoneName,         // zone
                     pnodeName,         // node
                     prrRpc,            // RR to add
                     NULL );
    }

    if ( status == ERROR_SUCCESS )
    {
        PWSTR   pwsznode = getUnicodeForUtf8( pnodeName );
        PWSTR   pwszzone = getUnicodeForUtf8( pzoneArg );

        printf(
            "Add %s Record for %S at %S\n",
            *( Argv - 1 ),          //  RR type
            pwsznode,               //  owner name
            pwszzone );             //  zone name
        FREE_HEAP( pwsznode );
        FREE_HEAP( pwszzone );
    }

    //  free node name if allocated

    if ( ballocatedNode )
    {
        free( pnodeName );
    }

    return status;

Help:
    printf(
        "Usage: DnsCmd <ServerName> /RecordAdd <Zone> <NodeName> [/Aging] [/OpenAcl]\n"
        "              [<Ttl>] <RRType> <RRData>\n\n"
        "  <RRType>          <RRData>\n"
        "    A               <IPAddress>\n"
        "    NS,CNAME,MB,MD  <HostName|DomainName>\n"
        "    PTR,MF,MG,MR    <HostName|DomainName>\n"
        "    MX,RT,AFSDB     <Preference> <ServerName>\n"
        "    SRV             <Priority> <Weight> <Port> <HostName>\n"
        "    SOA             <PrimaryServer> <AdminEmail> <Serial#>\n"
        "                      <Refresh> <Retry> <Expire> <MinTTL>\n"
        "    AAAA            <Ipv6Address>\n"
        "    TXT             <String> [<String>]\n"
        "    X25,HINFO,ISDN  <String> [<String>]\n"
        "    MINFO,RP        <MailboxName> <ErrMailboxName>\n"
        "    WKS             <Protocol> <IPAddress> <Service> [<Service>]..]\n"
        "    KEY             <Flags> <KeyProtocol> <CryptoAlgorithm> <Base64Data>\n"
        "    SIG             <TypeCovered> <CryptoAlgorithm> <LabelCount>\n"
        "                      <OriginalTTL> <SigExpiration> <SigInception>\n"
        "                      <KeyTag> <Signer's Name> <Base64Data>\n"
        "    NXT             <NextName> <Type> [<Type>...]\n"
        "    WINS            <MapFlag> <LookupTimeout>\n"
        "                      <CacheTimeout> <IPAddress> [<IPAddress>]\n"
        "    WINSR           <MapFlag> <LookupTimeout>\n"
        "                     <CacheTimeout> <RstDomainName>\n"
        "  <Zone>            -- <ZoneName> | /RootHints\n"
        "  <ZoneName>        -- FQDN of a zone\n"
        "  <NodeName>        -- name of node for which a record will be added\n"
        "                       - FQDN of a node  (name with a '.' at the end) OR\n"
        "                       - node name relative to the ZoneName           OR\n"
        "                       - \"@\" for zone root node                       OR\n"
        "                       - service name for SRV only (e.g. _ftp._tcp)\n"
        "  <Ttl>             -- TTL for the RR  (Default: TTL defined in SOA)\n"
        "  <HostName>        -- FQDN of a host\n"
        "  <IPAddress>       -- e.g.  255.255.255.255\n"
        "  <ipv6Address>     -- e.g.  1:2:3:4:5:6:7:8\n"
        "  <Protocol>        -- UDP | TCP \n"
        "  <Service>         -- e.g.  domain, smtp\n"
        "  <TypeCovered>     -- type of the RRset signed by this SIG\n"
        "  <CryptoAlgorithm> -- 1=RSA/MD5, 2=Diffie-Hellman, 3=DSA\n"
        "  <SigExpiration>   -- yyyymmddhhmmss - GMT\n"
        "  <SigInception>    -- yyyymmddhhmmss - GMT\n"
        "  <KeyTag>          -- used to discriminate between multiple SIGs\n"
        "  <Signer's Name>   -- domain name of signer\n"
        "  <KeyProtocol>     -- 1=TLS, 2=email, 3=DNSSEC, 4=IPSEC\n"
        "  <Base64Data>      -- KEY or SIG binary data in base64 notation\n"
        "  <NextName>        -- domain name of next RRSet in zone\n" );
    return ERROR_INVALID_PARAMETER;
}



DNS_STATUS
ProcessRecordDelete(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
/*++

Routine Description:

    Delete record(s) from node in zone.

--*/
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PDNS_RECORD     prr;
    PDNS_RPC_RECORD prrRpc = NULL;
    LPSTR           pzoneName = NULL;
    LPSTR           pnodeName = NULL;
    BOOL            ballocatedNode = FALSE;
    LPSTR           pzoneArg;
    LPSTR           psztypeArg = NULL;
    WORD            wType;
    DWORD           ttl = 0;
    DWORD           ttlFlag = 0;
    CHAR            buf[33];
    BOOL            fconfirm = TRUE;

    //
    //  RecordDelete <Zone> <Node> <RRType> [<RRData>] [/f]
    //

    if ( Argc < 3 || Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    //
    //  Check for "force"  (no-confirm) flag
    //

    if ( !_stricmp( Argv[Argc-1], "/f" ) )
    {
        fconfirm = FALSE;
        Argc--;
    }
    if ( Argc < 3 )
    {
        goto Help;
    }

    //
    //  read zone and domain name
    //

    readZoneAndDomainName(
        Argv,
        & pzoneName,
        & pnodeName,
        & ballocatedNode,
        & pzoneArg,
        NULL );

    Argv++;
    Argc--;
    Argv++;
    Argc--;

    //
    //  TTL -- optional
    //      - use default if none given
    //

    ttl = strtoul(
                *Argv,
                NULL,
                10 );

    if ( ttl == 0  &&  strcmp(*Argv, "0") != 0  )
    {
        ttlFlag = DNS_RPC_RECORD_FLAG_DEFAULT_TTL;
    }
    else    //  read TTL
    {
        Argv++;
        Argc--;
        if ( Argc < 1 )
        {
            goto Help;
        }
    }

    //
    //  record type
    //

    psztypeArg = *Argv;

    wType = Dns_RecordTypeForName(
                psztypeArg,
                0       // null terminated
                );
    if ( !wType )
    {
        printf( "Invalid RRType: <%s>!\n", *Argv );
        goto Help;
    }
    Argv++;
    Argc--;

    //
    //  build DNS_RECORD
    //      - if no record data, then type delete
    //      - otherwise build record
    //

    if ( Argc )
    {
        prr = Dns_RecordBuild_A(
                    NULL,           // ptr to RRSet
                    pnodeName,    // nameOwner
                    wType,          // RR type in WORD
                    FALSE,          // ! S.Delete
                    0,              // S.section
                    Argc,           // count of strings
                    Argv            // strings to fill into RR
                    );
        if ( ! prr )
        {
            printf( "\nInvalid Data!\n" );
            goto Help;
        }

        //  convert DNS_RECORD to RPC buffer

        prrRpc = DnsConvertRecordToRpcBuffer( prr );
        if ( ! prrRpc )
        {
#if DBG
            printf("DnsConvertRecordToRpcBuffer()faild\n");
#endif
            status = GetLastError();
            goto Help;
        }
        //  prr and prrRpc freed by process termination
        //  set TTL for the RR

        prrRpc->dwTtlSeconds = ttl;
        prrRpc->dwFlags = ttlFlag;
    }

    //
    //  ask user for confirmation
    //

    if ( fconfirm )
    {
        if ( !getUserConfirmation( "delete record" ) )
        {
            return ERROR_SUCCESS;
        }
    }

    //
    //  delete
    //      - if record do full update
    //      - if type do type delete
    //

    if ( prrRpc )
    {
        status = DnssrvUpdateRecord(
                     pwszServerName,    // server
                     pzoneName,       // zone
                     pnodeName,       // node
                     NULL,              // no add
                     prrRpc             // RR to delete
                     );
    }
    else
    {
        status = DnssrvDeleteRecordSet(
                     pwszServerName,    // server
                     pzoneName,       // zone
                     pnodeName,       // node
                     wType
                     );
    }

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "Deleted %s record(s) at %s\n",
            psztypeArg,
            pzoneArg );
    }

    //  free node name if allocated

    if ( ballocatedNode && pnodeName )
    {
        free( pnodeName );
    }

    return status;

Help:
    printf(
        "Usage: DnsCmd <ServerName> /RecordDelete <Zone> <NodeName>\n"
        "              <RRType> <RRData> [/f]\n\n"
        "  <Zone>      -- FQDN of a zone of /RootHints or /Cache\n"
        "  <NodeName>  -- name of node from which a record will be deleted\n"
        "                   - \"@\" for zone root OR\n"
        "                   - FQDN of a node (DNS name with a '.' at the end) OR\n"
        "                   - single label for name relative to zone root ) OR\n"
        "                   - service name for SRV only (e.g. _ftp._tcp)\n"
        "  <RRType>:       <RRData>:\n"
        "    A             <IP Address>\n"
        "    SRV           <Priority> <Weight> <Port> <HostName>\n"
        "    AAAA          <IPv6 Address>\n"
        "    MX            <Preference> <ServerName>\n"
        "    NS,CNAME,PTR  <HostName>\n"
        "    For help on how to specify the <RRData> for other record\n"
        "      types see \"DnsCmd /RecordAdd /?\"\n"
        "    If <RRData> is not specified deletes all records with of specified type\n"
        "  /f --  Execute without asking for confirmation\n\n" );

    //  free node name if allocated

    if ( ballocatedNode )
    {
        free( pnodeName );
    }

    return ERROR_INVALID_PARAMETER;
}



DNS_STATUS
ProcessNodeDelete(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
/*++

Routine Description:

    Delete record(s) from node in zone.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       pzoneName;
    LPSTR       pnodeName;
    BOOL        ballocatedNode = FALSE;
    LPSTR       pzoneArg;
    DWORD       iarg;
    BOOL        bsubtree = FALSE;
    BOOL        bnoConfirm = FALSE;

    //
    //  /DeleteNode <Zone> <NodeName> [/Tree] [/f]
    //

    if ( Argc < 2 || Argc > 4 )
    {
        goto Help;
    }

    //  read options

    iarg = 3;
    while ( iarg <= Argc )
    {
        if ( !_stricmp(Argv[iarg-1], "/Tree") )
        {
            bsubtree = 1;
        }
        else if ( !_stricmp(Argv[iarg-1], "/f") )
        {
            bnoConfirm = 1;
        }
        else
        {
            goto Help;
        }
        iarg ++;
    }

    //
    //  if confirmation option, get user confirmation
    //      - if denied, bail
    //

    if ( !bnoConfirm )
    {
        PCHAR   pmessage = "delete node";

        if ( bsubtree )
        {
            pmessage = "delete node's subtree";
        }
        if ( !getUserConfirmation( pmessage ) )
        {
            return ERROR_SUCCESS;
        }
    }

    //
    //  read zone and domain name
    //

    readZoneAndDomainName(
        Argv,
        & pzoneName,
        & pnodeName,
        & ballocatedNode,
        & pzoneArg,
        NULL );

    //
    //  delete
    //

    status = DnssrvDeleteNode(
                pwszServerName,
                pzoneName,
                pnodeName,
                bsubtree );

    if ( status == ERROR_SUCCESS )
    {
        LPWSTR      pwsznodeName = utf8ToUnicode( pnodeName, 0 );

        printf(
            "DNS Server %S deleted node at %S:\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            pwsznodeName,
            status, status );
         FREE_HEAP( pwsznodeName );
    }

    //  free node name if allocated

    if ( ballocatedNode )
    {
        free( pnodeName );
    }

    return status;

Help:
    printf(
        "Usage: DnsCmd <ServerName> /NodeDelete "
        "<Zone> <NodeName> [/Tree] [/f]\n"
        "    <Zone>     -- <ZoneName> | /RootHints | /Cache\n"
        "    <ZoneName> -- FQDN of a zone\n"
        "    <NodeName> -- FQDN of a node (with a '.' at the end)  OR\n"
        "                    node name relative to the ZoneName\n"
        "    /Tree      -- must be provided, when deleting a subdomain;\n"
        "                    (Not to delete sub tree is the default)\n"
        "    /f         -- execute without asking for confirmation\n" );
    return ERROR_INVALID_PARAMETER;
}



DNS_STATUS
ProcessAgeAllRecords(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
/*++

Routine Description:

    Delete record(s) from node in zone.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       pszzoneName;
    LPWSTR      pwszzoneName;
    LPSTR       pnodeName;
    BOOL        ballocatedNode = FALSE;
    LPSTR       pzoneArg;
    DWORD       iarg;
    BOOL        bsubtree = FALSE;
    BOOL        bnoConfirm = FALSE;

    //
    //  /AgeAllRecords <Zone> [<NodeName>] [/f] [Tree]
    //

    if ( Argc < 1  ||  Argc > 4 )
    {
        goto Help;
    }

    //
    //  read options
    //      - iarg left at FIRST option parsed
    //      so we can determine if "node" option exists
    //

    iarg = Argc;
    while ( iarg > 1 )
    {
        if ( !_stricmp(Argv[iarg-1], "/Tree") )
        {
            bsubtree = 1;
        }
        else if ( !_stricmp(Argv[iarg-1], "/f") )
        {
            bnoConfirm = 1;
        }
        else
        {
            break;
        }
        iarg--;
    }

    //
    //  read zone and optionally, domain name
    //

    if ( iarg > 1 )
    {
        readZoneAndDomainName(
            Argv,
            &pszzoneName,
            &pnodeName,
            &ballocatedNode,
            &pzoneArg,
            NULL );
    }
    else
    {
        pzoneArg = pszzoneName = Argv[ 0 ];
        pnodeName = NULL;
    }

    pwszzoneName = UnicodeArgv[ 0 ];

    //
    //  if confirmation option, get user confirmation
    //      - if denied, bail
    //

    if ( !bnoConfirm )
    {
        PCHAR   pmessage = "force aging on node";

        if ( bsubtree )
        {
            if ( pnodeName )
            {
                pmessage = "force aging on node's subtree";
            }
            else
            {
                pmessage = "force aging on entire zone";
            }
        }
        if ( !getUserConfirmation( pmessage ) )
        {
            return ERROR_SUCCESS;
        }
    }

    //
    //  force aging
    //

    status = DnssrvForceAging(
                pwszServerName,
                pszzoneName,
                pnodeName,
                bsubtree );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S forced aging on records %s %s of zone %S:\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            bsubtree ? "in subtree" : "at",
            pnodeName ? pnodeName : "root",
            pwszzoneName,
            status, status );
    }

    //  free node name if allocated

    if ( ballocatedNode )
    {
        free( pnodeName );
    }

    return status;

Help:

    printf(
        "Usage: DnsCmd <ServerName> /AgeAllRecords <ZoneName> [<NodeName>] [/Tree] [/f]\n"
        "    <Zone>     -- <ZoneName>\n"
        "    <ZoneName> -- FQDN of a zone\n"
        "    <NodeName> -- name or node or subtree in which to enable aging\n"
        "                   - \"@\" for zone root OR\n"
        "                   - FQDN of a node (name with a '.' at the end) OR\n"
        "                   - single label for name relative to zone root\n"
        "    /Tree      -- force aging on entire subtree of node\n"
        "                    or entire zone if node not given\n"
        "    /f         -- execute without asking for confirmation\n" );

    return ERROR_INVALID_PARAMETER;
}



//
//  Server configuration API
//

DNS_STATUS
ProcessResetProperty(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       pszZone = NULL;
    LPSTR       pszProperty = NULL;
    BOOL        fAllZones = FALSE;

    //
    //  Config [Zone] <PropertyName> <Value>
    //  Note: if there is no valid, pass 0 for DWORDs or NULL for
    //  other types. This allows you to clear values, such as the
    //  LogFilterIPList.
    //

    if ( Argc < 1 || Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    //
    //  The first arg is the zone name unless it starts with a
    //  slash, which means the zone name was omitted.
    //

    if ( *Argv[ 0 ] != '/' )
    {
        pszZone = Argv[ 0 ];
        --Argc;
        ++Argv;
    }

    //
    //  Property name - starts with a slash.
    //

    pszProperty = getCommandName( Argv[ 0 ] );
    if ( !pszProperty )
    {
        goto Help;
    }
    --Argc;
    ++Argv;

    //
    //  Trap apply to all zone operation.
    //

    if ( pszZone &&
         _stricmp( pszZone, "_ApplyAllZones_" ) == 0 )
    {
        pszZone = NULL;
        fAllZones = TRUE;
    }

    //
    //  Do a strcmp to decide if this is a string or DWORD property.
    //  As more string properties are added we should probably use a
    //  table instead of a bunch of stricmps.
    //

    if ( _stricmp( pszProperty, DNS_REGKEY_LOG_FILE_PATH ) == 0 ||
        _stricmp( pszProperty, DNS_REGKEY_ZONE_BREAK_ON_NAME_UPDATE ) == 0 ||
        _stricmp( pszProperty, DNS_REGKEY_SERVER_PLUGIN ) == 0 )
    {
        //
        //  This property is a string value. 
        //

        LPWSTR      pwszPropertyValue = NULL;
        
        if ( Argc && Argv[ 0 ] )
        {
            pwszPropertyValue = Dns_StringCopyAllocate(
                                    Argv[ 0 ],
                                    0,
                                    DnsCharSetUtf8,
                                    DnsCharSetUnicode );
        }

        if ( g_UseWmi )
        {
            status = DnscmdWmi_ResetProperty(
                        pszZone,
                        pszProperty,
                        VT_BSTR,
                        ( PVOID ) pwszPropertyValue );
        }
        else
        {
            status = DnssrvResetStringProperty(
                        pwszServerName,
                        pszZone,
                        pszProperty,
                        pwszPropertyValue,
                        fAllZones ? DNSSRV_OP_PARAM_APPLY_ALL_ZONES : 0 );
        }

        FREE_HEAP( pwszPropertyValue );
    }
    else if ( _stricmp( pszProperty, DNS_REGKEY_LISTEN_ADDRESSES ) == 0 ||
              _stricmp( pszProperty, DNS_REGKEY_LOG_IP_FILTER_LIST ) == 0 ||
              _stricmp( pszProperty, DNS_REGKEY_FORWARDERS ) == 0 ||
              _stricmp( pszProperty, DNS_REGKEY_ZONE_ALLOW_AUTONS ) == 0 ||
              _stricmp( pszProperty, DNS_REGKEY_ZONE_MASTERS ) == 0 ||
              _stricmp( pszProperty, DNS_REGKEY_ZONE_LOCAL_MASTERS ) == 0 ||
              _stricmp( pszProperty, DNS_REGKEY_ZONE_SCAVENGE_SERVERS ) == 0 ||
              _stricmp( pszProperty, DNS_REGKEY_BREAK_ON_UPDATE_FROM ) == 0 ||
              _stricmp( pszProperty, DNS_REGKEY_BREAK_ON_RECV_FROM ) == 0 )

    {
        //
        //  This property is an IP list value. 
        //

        DWORD           ipCount;
        IP_ADDRESS      ipAddressArray[ MAX_IP_PROPERTY_COUNT ];
        PIP_ARRAY       pipArray = NULL;

        if ( Argc )
        {
            BOOL fInaddrNoneAllowed = 
                _stricmp( pszProperty, DNS_REGKEY_BREAK_ON_UPDATE_FROM ) == 0 ||
                _stricmp( pszProperty, DNS_REGKEY_BREAK_ON_RECV_FROM ) == 0;

            ipCount = readIpAddressArray(
                                ipAddressArray,
                                MAX_IP_PROPERTY_COUNT,
                                Argc,
                                Argv,
                                fInaddrNoneAllowed );
            if ( ipCount < 1 )
            {
                goto Help;
            }
            Argc -= ipCount;
            Argv += ipCount;

            pipArray = Dns_BuildIpArray( ipCount, ipAddressArray );
        }

        if ( g_UseWmi )
        {
            status = DnscmdWmi_ResetProperty(
                        pszZone,
                        pszProperty,
                        PRIVATE_VT_IPARRAY,
                        ( PVOID ) pipArray );
        }
        else
        {
            status = DnssrvResetIPListProperty(
                        pwszServerName,
                        pszZone,
                        pszProperty,
                        pipArray,
                        fAllZones ? DNSSRV_OP_PARAM_APPLY_ALL_ZONES : 0 );
        }

        FREE_HEAP( pipArray );
    }
    else
    {
        //
        //  This property is a DWORD value.
        //

        DWORD   value = Argc ? 
                        convertDwordParameterUnknownBase( Argv[ 0 ] ) :
                        0;

        if ( fAllZones )
        {
            value |= DNSSRV_OP_PARAM_APPLY_ALL_ZONES;
        }

        if ( g_UseWmi )
        {
            status = DnscmdWmi_ResetProperty(
                        pszZone,
                        pszProperty,
                        VT_I4,
                        ( PVOID ) ( DWORD_PTR ) value );
        }
        else
        {
            status = DnssrvResetDwordProperty(
                        pwszServerName,
                        pszZone,
                        pszProperty,
                        value );
        }
    }

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "Registry property %s successfully reset.\n",
            pszProperty );
    }
    else
    {
        printf(
            "DNS Server failed to reset registry property.\n"
            "    Status = %d (0x%08lx)\n",
            status, status );
    }
    return status;

Help:

    //  Note: removing ..AllZones from help. It doesn't work that well
    //  and it's not a very good model anyways. But leave it in place in
    //  case anyone actually wants to use it.
    
    printf(
        "Usage: DnsCmd <ServerName> /Config "
        "<ZoneName> <Property> <Value>\n"
        "  Server <Property>:\n"
        "    /RpcProtocol\n"
        "    /LogLevel\n"
        "    /" DNS_REGKEY_LOG_FILE_PATH " <Log file name>\n"
        "    /" DNS_REGKEY_LOG_IP_FILTER_LIST " <IP list>\n"
        "    /" DNS_REGKEY_LOG_FILE_MAX_SIZE "\n"
        "    /EventlogLevel\n"
        "    /NoRecursion\n"
        "    /" DNS_REGKEY_BOOT_METHOD "\n"
        "    /ForwardDelegations\n"
        "    /ForwardingTimeout\n"
        "    /IsSlave\n"
        "    /SecureResponses\n"
        "    /RecursionRetry\n"
        "    /RecursionTimeout\n"
        "    /MaxCacheTtl\n"
        "    /" DNS_REGKEY_MAX_CACHE_SIZE "\n"
        "    /MaxNegativeCacheTtl\n"
        "    /RoundRobin\n"
        "    /LocalNetPriority\n"
        "    /AddressAnswerLimit\n"
        "    /BindSecondaries\n"
        "    /WriteAuthorityNs\n"
        "    /NameCheckFlag\n"
        "    /StrictFileParsing\n"
        "    /UpdateOptions\n"
        "    /DisableAutoReverseZones\n"
        "    /SendPort\n"
        "    /NoTcp\n"
        "    /XfrConnectTimeout\n"
        "    /DsPollingInterval\n"
        "    /DsTombstoneInterval\n"
        "    /ScavengingInterval\n"
        "    /DefaultAgingState\n"
        "    /DefaultNoRefreshInterval\n"
        "    /DefaultRefreshInterval\n"
        "    /" DNS_REGKEY_ENABLE_DNSSEC "\n"
        "    /" DNS_REGKEY_ENABLE_EDNS "\n"
        "    /" DNS_REGKEY_EDNS_CACHE_TIMEOUT "\n"
        "    /" DNS_REGKEY_DISABLE_AUTONS "\n"
        "  Zone <Property>:\n"
        "    /SecureSecondaries\n"
        "    /AllowUpdate <Value>\n"
        "       <Value> -- 0: no updates; 1: unsecure updates; 2: secure updates only\n"
        "    /Aging\n"
        "    /RefreshInterval <Value>\n"
        "    /NoRefreshInterval <Value>\n"
        "    /" DNS_REGKEY_ZONE_FWD_TIMEOUT " <Value>\n"
        "    /" DNS_REGKEY_ZONE_FWD_SLAVE " <Value>\n"
        "    /" DNS_REGKEY_ZONE_ALLOW_AUTONS " <IP List>\n"
        "  <Value>: New property value. Use 0x prefix to indicate hex value.\n"
        "    Note some server and zone DWORD properties must be reset as\n"
        "    part of a more complex operation.\n" );
        
    return ERROR_INVALID_PARAMETER;
}   //  ProcessResetProperty



DNS_STATUS
ProcessResetForwarders(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
#define MAX_FORWARD_COUNT  (50)

    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       iArg = 0;
    DWORD       fSlave = FALSE;
    DWORD       dwTimeout = DNS_DEFAULT_FORWARD_TIMEOUT;
    DWORD       cForwarders = 0;
    IP_ADDRESS  aipForwarders[ MAX_FORWARD_COUNT ];
    LPSTR       cmd;

    //
    //  ResetForwarders [<ForwarderIP>] ...] [/Slave|/NoSlave] [/TimeOut <time>]
    //

    if ( Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    // read forwarder ipAddresses:

    while ( ( iArg < Argc ) &&
            ( !getCommandName(Argv[iArg]) ) )
    {
        if ( iArg < MAX_FORWARD_COUNT )
        {
            aipForwarders[iArg] = inet_addr( Argv[iArg] );
        }
        iArg++;
    }

    cForwarders = iArg;

    //
    //  Optional commands
    //

    while ( iArg < Argc )
    {
        cmd = getCommandName( Argv[iArg] );

        if ( cmd )
        {
            if ( !_stricmp(cmd, "Slave") )
            {
                fSlave = TRUE;
            }
            else if ( !_stricmp(cmd, "NoSlave") )
            {
                fSlave = FALSE;
            }
            else if ( !_stricmp(cmd, "TimeOut") )
            {
                if ( ++iArg >= Argc )
                {
                    goto Help;
                }

                dwTimeout = strtoul(
                                Argv[iArg],
                                NULL,
                                10 );
            }
            else
            {
                goto Help;
            }

            iArg ++;
        }
        else
        {
            goto Help;
        }
    }

    if ( g_UseWmi )
    {
        status = DnscmdWmi_ProcessResetForwarders(
                    cForwarders,
                    aipForwarders,
                    dwTimeout,
                    fSlave );
    }
    else
    {
        status = DnssrvResetForwarders(
                    pwszServerName,
                    cForwarders,
                    aipForwarders,
                    dwTimeout,
                    fSlave );
    }

    if ( status == ERROR_SUCCESS )
    {
        printf( "Forwarders reset successfully.\n" );
    }
    else
    {
        printf(
            "DNS Server failed to reset forwarders.\n"
            "    Status = %d (0x%08lx)\n",
            status, status );
    }

    return status;

Help:

    printf( "Usage: DnsCmd <ServerName> /ResetForwarders "
        "[<IPAddress>] ...] [ /[No]Slave ] [/TimeOut <Time>]\n"
        "  <IPAddress>  -- where to forward unsolvable DNS queries\n"
        "  /Slave       -- operate as slave server\n"
        "  /NoSlave     -- not as slave server  (default)\n"
        "    No forwarders is the default.\n"
        "    Default timeout is %d sec\n",
        DNS_DEFAULT_FORWARD_TIMEOUT );

    return ERROR_INVALID_PARAMETER;
}



DNS_STATUS
ProcessResetListenAddresses(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       iArg;
    DWORD       cListenAddresses = 0;
    IP_ADDRESS  aipListenAddresses[ 10 ];

    //
    //  ResetListenAddresses <IPAddress> ...
    //

    //Help:

    if ( Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }
    if ( Argc > 0 &&
         getCommandName(Argv[0]) )
    {
        goto Help;
    }


    //  read listen addresses

    cListenAddresses = Argc;

    for ( iArg=0; iArg<cListenAddresses; iArg++)
    {
        aipListenAddresses[iArg] = inet_addr( Argv[iArg] );
    }

    status = DnssrvResetServerListenAddresses(
                pwszServerName,
                cListenAddresses,
                aipListenAddresses );

    if ( status == ERROR_SUCCESS )
    {
        printf( "ListenAddresses reset successful.\n" );
    }
    else
    {
        printf(
            "DNS Server failed to reset listen addressess.\n"
            "    Status = %d (0x%08lx)\n",
            status, status );
    }

    return status;

Help:

    printf( "Usage: DnsCmd <ServerName> /ResetListenAddresses [<ListenAddress>] ...]\n"
        "  <ListenAddress>  -- an IP address belonging to the DNS server\n"
        "    Default:  listen to all server IP Address(es) for DNS requests\n\n" );
    return ERROR_INVALID_PARAMETER;
}



//
//  Zone Queries
//

DNS_STATUS
ProcessEnumZones(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS          status = ERROR_SUCCESS;
    DWORD               filter = 0;
    DWORD               zoneCount;
    DWORD               iArg = 0;
    PDNS_RPC_ZONE_LIST  pZoneList = NULL;
    LPSTR               cmd;
    LPSTR               pszpartition = NULL;

    //
    //  EnumZones [<Filter1>] [<Filter2>]
    //

    //  get filters:

    while ( iArg < Argc )
    {
        cmd = getCommandName( Argv[iArg] );

        if ( !cmd )
        {
            goto Help;
        }

        if ( !_stricmp( cmd, "Primary" ) )
        {
            filter |= ZONE_REQUEST_PRIMARY;
        }
        else if ( !_stricmp( cmd, "Secondary" ) )
        {
            filter |= ZONE_REQUEST_SECONDARY;
        }
        else if ( !_stricmp( cmd, "Forwarder" ) )
        {
            filter |= ZONE_REQUEST_FORWARDER;
        }
        else if ( !_stricmp( cmd, "Stub" ) )
        {
            filter |= ZONE_REQUEST_STUB;
        }
        else if ( !_stricmp( cmd, "Cache" ) )
        {
            filter |= ZONE_REQUEST_CACHE;
        }
        else if ( !_stricmp( cmd, "Auto-Created" ) || !_stricmp( cmd, "Auto" ) )
        {
            filter |= ZONE_REQUEST_AUTO;
        }
        else if ( !_stricmp( cmd, "Forward" ) )
        {
            filter |= ZONE_REQUEST_FORWARD;
        }
        else if ( !_stricmp( cmd, "Reverse" ) )
        {
            filter |= ZONE_REQUEST_REVERSE;
        }
        else if ( !_stricmp( cmd, "Ds" ) )
        {
            filter |= ZONE_REQUEST_DS;
        }
        else if ( !_stricmp( cmd, "NonDs" ) || !_stricmp( cmd, "File" ) )
        {
            filter |= ZONE_REQUEST_NON_DS;
        }
        else if ( !_stricmp( cmd, "DomainDirectoryPartition" ) ||
                  !_stricmp( cmd, "DomainDp" ) )
        {
            filter |= ZONE_REQUEST_DOMAIN_DP;
        }
        else if ( !_stricmp( cmd, "ForestDirectoryPartition" ) ||
                  !_stricmp( cmd, "ForestDp" ) )
        {
            filter |= ZONE_REQUEST_FOREST_DP;
        }
        else if ( !_stricmp( cmd, "CustomDirectoryPartition" ) ||
                  !_stricmp( cmd, "CustomDp" ) )
        {
            filter |= ZONE_REQUEST_CUSTOM_DP;
        }
        else if ( !_stricmp( cmd, "LegacyDirectoryPartition" ) ||
                  !_stricmp( cmd, "LegacyDp" ) )
        {
            filter |= ZONE_REQUEST_LEGACY_DP;
        }
        else if ( !_stricmp( cmd, "Dp" ) ||
                  !_stricmp( cmd, "DirectoryPartition" ) )
        {
            if ( iArg + 1 >= Argc ||
                 !Argv[ iArg + 1 ] ||
                 getCommandName( Argv[ iArg + 1 ] ) != NULL )
            {
                goto Help;
            }
            pszpartition = Argv[ ++iArg ];
        }
        else
        {
            goto Help;
        }

        ++iArg;
    }

    //  special case NO filter

    if ( filter == 0 )
    {
        filter = ZONE_REQUEST_ALL_ZONES_AND_CACHE;
    }


    if ( g_UseWmi )
    {
        status = DnscmdWmi_ProcessEnumZones(
                    filter );
    }
    else
    {
        status = DnssrvEnumZonesEx(
                    pwszServerName,
                    filter,             //  DWORD filter
                    pszpartition,       //  directory partition FQDN
                    NULL,               //  query string (not implemented)
                    NULL,               //  last zone
                    &pZoneList );

        if ( status != ERROR_SUCCESS )
        {
            printf(
                "Zone enumeration failed\n"
                "    status = %d (0x%08lx)\n",
                status, status );
            goto Cleanup;
        }
        else
        {
            DnsPrint_RpcZoneList(
                dnscmd_PrintRoutine,
                dnscmd_PrintContext,
                "Enumerated zone list:\n",
                pZoneList );
        }
    }

Cleanup:

    //
    //  deallocate zone list
    //

    DnssrvFreeZoneList( pZoneList );
    return status;

Help:
    printf( "Usage: DnsCmd <ServerName> /EnumZones [<Filter1> <Filter2> ...]\n"
        "  Filters:\n"
        "    /Primary       - primary zones\n"
        "    /Secondary     - secondary zones\n"
        "    /Forwarder     - conditional forwarding zones\n"
        "    /Stub          - stub zones\n"
        "    /Cache         - the cache zone\n"
        "    /Auto-Created  - auto-created zones\n"
        "    /Forward       - forward lookup zones\n"
        "    /Reverse       - reverse lookup zones\n"
        "    /Ds            - DS-integrated zones\n"
        "    /File          - file-backed zones\n"
        "    /DomainDirectoryPartition  - zones in domain directory partition\n"
        "    /ForestDirectoryPartition  - zones in forest directory partition\n"
        "    /CustomDirectoryPartition  - zones in any custom directory partition\n"
        "    /LegacyDirectoryPartition  - zones in the legacy partition\n"
        "    /DirectoryPartition        - zones in partition specified by next arg\n"
        "  Output:\n"
        "    Storage:\n"
        "      File - zone is stored in a file\n"
        "      AD-Forest - zone is stored in the forest Active Directory DNS partition\n"
        "      AD-Domain - zone is stored in the domain Active Directory DNS partition\n"
        "      AD-Legacy - zone is stored in the W2K-compatible DNS partition\n"
        "    Properties:\n"
        "      Update - zone accepts DNS dynamic updates\n"
        "      Secure - zone accepts secure DNS dynamic updates\n"
        "      Rev - zone is a reverse lookup zone\n"
        "      Auto - zone was auto-created by the DNS server\n"
        "      Aging - aging is enabled for this zone\n"
        "      Down - zone is currently shutdown\n"
        "      Paused - zone is currently paused\n" );
    return ERROR_INVALID_PARAMETER;

}



//
//  Create a new zone
//

DNS_STATUS
ProcessZoneAdd(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       pzoneName;
    DWORD       zoneType = DNS_ZONE_TYPE_PRIMARY;
    DWORD       countMasters = 0;
    IP_ADDRESS  masterArray[ MAX_IP_PROPERTY_COUNT ];
    DWORD       floadExisting = FALSE;
    LPSTR       pszAllocatedDataFile = NULL;
    LPSTR       pszDataFile = NULL;
    LPSTR       pszEmailAdminName = NULL;   //  pass NULL by default
    LPSTR       cmd;
    BOOL        fDsIntegrated;
    BOOL        fdpSpecified = FALSE;

    DWORD       dwTimeout = 0;              //  for forwarder zones only
    BOOL        fSlave = FALSE;             //  for forwarder zones only

    BOOL        fInDirPart = FALSE;
    DWORD       dpFlag = 0;         //  directory partition flag for builtin
    LPSTR       pszDpFqdn = NULL;   //  directory partition FQDN for custom

    #if DBG
    DWORD       dwdcPromo = 0;
    #endif
    
    PWSTR       pwszzoneName = NULL;

    //
    //  CreateZone
    //

    if ( Argc < 2 ||
         Argc == NEED_HELP_ARGC ||
         getCommandName(Argv[0]) )
    {
        goto Help;
    }

    //  set zone name

    pzoneName = Argv[0];
    Argv++;
    Argc--;

    //
    //  zone type
    //      - Primary
    //      - Secondary, then read master IP array
    //      - DsPrimary
    //

    cmd = getCommandName( Argv[0] );
    if ( !cmd )
    {
        goto Help;
    }
    Argv++;
    Argc--;

    zoneType = parseZoneTypeString( cmd, &fDsIntegrated );

    if ( zoneType == -1 )
    {
        goto Help;
    }

    // JJW: should I set floadExisting for all DsIntegrated zones?
    if ( zoneType == DNS_ZONE_TYPE_PRIMARY && fDsIntegrated )
    {
        floadExisting = TRUE;
    }
    else if ( zoneType == DNS_ZONE_TYPE_SECONDARY ||
                zoneType == DNS_ZONE_TYPE_STUB ||
                zoneType == DNS_ZONE_TYPE_FORWARDER )
    {
        // get master IP list

        countMasters = readIpAddressArray(
                            masterArray,
                            MAX_IP_PROPERTY_COUNT,
                            Argc,
                            Argv,
                            FALSE );
        if ( countMasters < 1 )
        {
            goto Help;
        }
        Argc -= countMasters;
        Argv += countMasters;
    }

    //
    //  options
    //      - file name (default to load existing file)
    //      - admin email name
    //      - DS overwrite options
    //

    while ( Argc )
    {
        cmd = getCommandName( *Argv );
        if ( !cmd )
        {
            goto Help;
        }
        Argc--;
        Argv++;

        if ( !_stricmp( cmd, "file" ) )
        {
            if ( Argc <= 0 || zoneType == DNS_ZONE_TYPE_FORWARDER )
            {
                goto Help;
            }
            pszDataFile = *Argv;
            Argc--;
            Argv++;
        }
        else if ( !_stricmp(cmd, "a") )
        {
            if ( Argc <= 0 )
            {
                goto Help;
            }
            pszEmailAdminName = *Argv;
            Argc--;
            Argv++;
        }
        else if ( !_stricmp(cmd, "load") )
        {
            floadExisting = TRUE;
        }
        else if ( !_stricmp(cmd, "timeout") &&
            zoneType == DNS_ZONE_TYPE_FORWARDER )
        {
            dwTimeout = strtoul( *( Argv++ ), NULL, 10 );
            Argc--;
        }
        else if ( !_stricmp(cmd, "slave") &&
            zoneType == DNS_ZONE_TYPE_FORWARDER )
        {
            fSlave = TRUE;
        }
        else if ( ( !_stricmp(cmd, "dp" ) ||
            !_stricmp(cmd, "DirectoryPartition" ) ) &&
                fDsIntegrated )

        {
            //
            //  Directory partition for zone. Check to see if a builtin DP
            //  is requested, if so set flag, Otherwise DP argument must
            //  be the FQDN of a custom DP.
            //

            if ( !parseDpSpecifier( *Argv, &dpFlag, &pszDpFqdn ) )
            {
                goto Help;
            }

            fdpSpecified = TRUE;
            fInDirPart = TRUE;
            Argc--;
            Argv++;
        }
        #if DBG
        else if ( !_stricmp( cmd, "dcpromo" ) )
        {
            //
            //  DCPROMO argument is debug only (for test)
            //  Argument following should be /forest or /domain.
            //

            if ( _strnicmp( *Argv, "/d", 2 ) == 0 )
            {
                dwdcPromo = DNS_ZONE_CREATE_FOR_DCPROMO;
            }
            else if ( _strnicmp( *Argv, "/f", 2 ) == 0 )
            {
                dwdcPromo = DNS_ZONE_CREATE_FOR_DCPROMO_FOREST;
            }
            else
            {
                goto Help;
            }
            Argc--;
            Argv++;
        }
        #endif
        else
        {
            goto Help;
        }
    }

    //
    //  If no file name for file-backed, set up default.
    //

    if ( zoneType == DNS_ZONE_TYPE_PRIMARY &&
        !pszDataFile &&
        !fDsIntegrated )
    {
        pszAllocatedDataFile = MIDL_user_allocate( strlen( pzoneName ) + 20 );
        strcpy( pszAllocatedDataFile, pzoneName );
        strcat( pszAllocatedDataFile, ".dns" );
        pszDataFile = pszAllocatedDataFile;
    }
    
    //
    //  For DS integrated zones, if no DP is specified then we need to
    //  select the best DP: legacy or built-in domain DP.
    //
    //  By default stub and forwarder zones are always created in the
    //  domain NDNC if no target NDNC was specified.
    //
    
    else if ( fDsIntegrated && !fdpSpecified )
    {
        DWORD       dwdomainVersion = 0;
        
        status = getServerVersion(
                    pwszServerName,
                    TRUE,
                    NULL,
                    NULL,
                    NULL,
                    &dwdomainVersion );
        if ( status == ERROR_SUCCESS &&
             dwdomainVersion >= DS_BEHAVIOR_WIN2003 ||
             zoneType == DNS_ZONE_TYPE_FORWARDER ||
             zoneType == DNS_ZONE_TYPE_STUB )
        {
            dpFlag = DNS_DP_DOMAIN_DEFAULT;
            pszDpFqdn = NULL;
            fInDirPart = TRUE;

            printf( "Creating zone in built-in domain directory partition...\n" );
        }
        status = ERROR_SUCCESS;
    }

    //
    //  Let there be zone!
    //

    #if DBG
    if ( dwdcPromo )
    {
        printf( "Creating dcpromo zone with dcpromo flag 0x%08X\n", dwdcPromo );

        status = DnssrvCreateZoneForDcPromoEx(
                    pwszServerName,
                    pzoneName,
                    pszDataFile,
                    dwdcPromo );
    }
    else
    #endif
    
    if ( fInDirPart )
    {
        status = DnssrvCreateZoneInDirectoryPartition(
                    pwszServerName,
                    pzoneName,
                    zoneType,
                    pszEmailAdminName,
                    countMasters,
                    masterArray,
                    floadExisting,
                    dwTimeout,
                    fSlave,
                    dpFlag,
                    pszDpFqdn );
    }
    else
    {
        status = DnssrvCreateZone(
                    pwszServerName,
                    pzoneName,
                    zoneType,
                    pszEmailAdminName,
                    countMasters,
                    masterArray,
                    floadExisting,
                    fDsIntegrated,
                    pszDataFile,
                    dwTimeout,
                    fSlave );
    }

    if ( pszAllocatedDataFile )
    {
        MIDL_user_free( pszAllocatedDataFile );
        pszAllocatedDataFile = NULL;
    }

    if ( status == ERROR_SUCCESS )
    {
        pwszzoneName = getUnicodeForUtf8( pzoneName );
        printf(
            "DNS Server %S created zone %S:\n",
            pwszServerName,
            pwszzoneName );
        FREE_HEAP( pwszzoneName );
    }
    return status;

Help:

    printf(
        "Usage: DnsCmd <ServerName> /ZoneAdd <ZoneName> <ZoneType> [<Options>]\n"
        "  <ZoneName> -- FQDN of zone\n"
        "  <ZoneType>:\n"
        "    /DsPrimary [/dp <FQDN>]\n"
        "      -- DS integrated primary zone\n"
        "    /Primary /file <filename>\n"
        "      -- standard file backed primary;  MUST include filename.\n"
        "    /Secondary <MasterIPaddress> [<MasterIPaddress>] ..] [/file <filename>]\n"
        "      -- standard secondary, MUST include at least one master IP;\n"
        "         filename is optional.\n"
        "    /Stub <MasterIPaddress> [<MasterIPaddress>] ..] [/file <filename>]\n"
        "      -- stub secondary, only replicates NS info from primary server\n"
        "    /DsStub -- as /Stub but DS integrated - use same options\n"
        "    /Forwarder <MasterIPaddress> [<MasterIPaddress>] ..] [/Timeout <Time>]\n"
        "                                 [/Slave]\n"
        "      -- forwarder zone, queries for names in zone forwarded to masters\n"
        "    /DsForwarder -- as /Forwarder but DS integrated - use same options\n"
        "  <Options>:\n"
        "    [/file <filename>]  -- filename, invalid for DS integrated zones\n"
        "    [/load]             -- load existing file;  if not specified,\n"
        "                           non-DS primary creates default zone records\n"
        "    [/a <AdminName>]    -- zone admin email name; primary zones only\n"
        "    [/DP <FQDN>]        -- fully qualified domain name of directory partition\n"
        "                           where zone should be stored; or use one of:\n"
        "                             /DP /domain - domain directory partition\n"
        "                             /DP /forest - forest directory partition\n"
        "                             /DP /legacy - legacy directory partition\n" );
        
    return ERROR_INVALID_PARAMETER;
}



DNS_STATUS
ProcessZoneDelete(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       cmd;
    BOOL        fconfirm = TRUE;
    DWORD       iArg;
    LPSTR       pszOperation;


    //
    //  ZoneDelete <ZoneName> [/DsDel] [/f]
    //

    if ( Argc < 1 ||
         Argc == NEED_HELP_ARGC ||
         ( getCommandName( Argv[0] ) ) )
    {
        goto Help;
    }

    pszOperation = DNSSRV_OP_ZONE_DELETE;

    //  read options

    iArg = 1;
    while ( iArg < Argc )
    {
        if ( !(cmd = getCommandName(Argv[iArg]) ) )
        {
            goto Help;
        }
        if ( !_stricmp( cmd, "f" ) )
        {
            // execute without confirmation:
            fconfirm = FALSE;
        }
        else if ( !_stricmp( cmd, "DsDel" ) )
        {
            // delete zone from DS:
            pszOperation = DNSSRV_OP_ZONE_DELETE_FROM_DS;
        }
        else
        {
            goto Help;
        }
        iArg ++;
    }

    //
    //  get user confirmation
    //

    if ( fconfirm )
    {
        if ( !getUserConfirmation( pszOperation ) )
        {
            return ERROR_SUCCESS;
        }
    }

    if ( g_UseWmi )
    {
        status = DnscmdWmi_ProcessDnssrvOperation(
                    Argv[ 0 ],              //  zone name
                    pszOperation,           //  delete or delete from DS
                    DNSSRV_TYPEID_NULL,     //  no data
                    ( PVOID ) NULL );
    }
    else
    {
        status = DnssrvOperation(
                    pwszServerName,
                    Argv[ 0 ],              //  zone name
                    pszOperation,           //  delete or delete from DS
                    DNSSRV_TYPEID_NULL,     //  no data
                    ( PVOID ) NULL );
    }

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S deleted zone %S:\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            UnicodeArgv[0],
            status, status );
    }
    return status;

Help:
    printf(
        "Usage: DnsCmd <ServerName> /ZoneDelete <ZoneName> [/DsDel] [/f]\n"
        "  /DsDel   -- Delete Zone from DS\n"
        "  /f       -- Execute without asking for confirmation\n"
        "  Default: delete zone from DNS sever, but NOT from DS\n" );

    return ERROR_INVALID_PARAMETER;
}



DNS_STATUS
ProcessZonePause(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;

    //
    //  ZonePause <ZoneName>
    //

    //Help:

    if ( Argc != 1 ||
         getCommandName( Argv[0] ) )
    {
        goto Help;
    }

    status = DnssrvPauseZone(
                pwszServerName,
                Argv[0]      // zone name
                );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S paused zone %S:\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            UnicodeArgv[0],
            status, status );
    }
    return status;

Help:

    printf( "Usage: DnsCmd <ServerName> /ZonePause <ZoneName>\n" );
    return ERROR_INVALID_PARAMETER;
}



DNS_STATUS
ProcessZoneResume(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;

    //
    //  ResumeZone <ZoneName>
    //

    if ( Argc != 1 ||
         getCommandName( Argv[0] ) )
    {
        goto Help;
    }

    status = DnssrvResumeZone(
                pwszServerName,
                Argv[0]      // zone name
                );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S resumed use of zone %S:\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            UnicodeArgv[0],
            status, status );
    }
    return status;

Help:

    printf( "Usage: DnsCmd <ServerName> /ZoneResume <ZoneName>\n" );

    return ERROR_INVALID_PARAMETER;
}



DNS_STATUS
ProcessZoneReload(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;

    //
    //  ReloadZone <ZoneName>
    //

    if ( Argc != 1 ||
         getCommandName( Argv[0] ) )
    {
        goto Help;
    }

    status = DnssrvOperation(
                pwszServerName,
                Argv[0],         // zone name
                DNSSRV_OP_ZONE_RELOAD,  // operation
                DNSSRV_TYPEID_NULL,     // no data
                (PVOID) NULL
                );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S reloaded zone %S:\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            UnicodeArgv[0],
            status, status );
    }
    return status;

Help:

    printf( "Usage: DnsCmd <ServerName> /ZoneReload <ZoneName>\n" );

    return ERROR_INVALID_PARAMETER;
}



DNS_STATUS
ProcessZoneWriteBack(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;

    //
    //  ZoneWriteBack <ZoneName>
    //

    if ( Argc != 1 ||
         getCommandName( Argv[0] ) )
    {
        goto Help;
    }

    status = DnssrvOperation(
                pwszServerName,
                Argv[0],                     // zone name
                DNSSRV_OP_ZONE_WRITE_BACK_FILE,     // operation
                DNSSRV_TYPEID_NULL,                 // no data
                (PVOID) NULL
                );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S wrote back zone %S:\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            UnicodeArgv[0],
            status, status );
    }
    return status;

Help:

    printf( "Usage: DnsCmd <ServerName> /ZoneWriteBack <ZoneName>\n" );

    return ERROR_INVALID_PARAMETER;
}



DNS_STATUS
ProcessZoneRefresh(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;

    //
    //  ZoneRefresh <ZoneName>
    //

    if ( Argc != 1  ||  getCommandName( Argv[0] ) )
    {
        goto Help;
    }

    status = DnssrvOperation(
                pwszServerName,
                Argv[0],                     // zone name
                DNSSRV_OP_ZONE_REFRESH,             // operation
                DNSSRV_TYPEID_NULL,                 // no data
                (PVOID) NULL
                );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S forced refresh of zone %S:\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            UnicodeArgv[0],
            status, status );
    }
    return status;

Help:

    printf( "Usage: DnsCmd <ServerName> /ZoneRefresh <ZoneName>\n" );
    return ERROR_INVALID_PARAMETER;
}



DNS_STATUS
ProcessZoneUpdateFromDs(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;

    //
    //  ZoneUpdateFromDs <ZoneName>
    //

    if ( Argc != 1  ||  getCommandName( Argv[0] ) )
    {
        goto Help;
    }

    status = DnssrvOperation(
                pwszServerName,
                Argv[0],
                DNSSRV_OP_ZONE_UPDATE_FROM_DS,
                DNSSRV_TYPEID_NULL,
                (PVOID) NULL );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S update zone %S\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            UnicodeArgv[0],
            status, status );
    }
    return status;

Help:

    printf( "Usage: DnsCmd <ServerName> /ZoneUpdateFromDs <ZoneName>\n" );

    return ERROR_INVALID_PARAMETER;
}



//
//  Zone property reset functions
//

DNS_STATUS
ProcessZoneResetType(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    LPSTR           pszzoneName;
    LPWSTR          pwszzoneName;
    DWORD           zoneType = DNS_ZONE_TYPE_PRIMARY;       //  default
    DWORD           countMasters = 0;
    IP_ADDRESS      masterArray[ MAX_IP_PROPERTY_COUNT ];
    DWORD           fDsIntegrated;
    DWORD           loadOptions = TRUE;                     //  load existing
    LPSTR           pszDataFile = NULL;
    LPSTR           pszDpFqdn = NULL;
    DWORD           dpFlag = 0;
    DWORD           iArg = 0;
    LPSTR           cmd;

    //
    //  ZoneResetType <ZoneName> <Property> [<options>]
    //

    if ( Argc < 2 ||
         Argc == NEED_HELP_ARGC ||
         getCommandName(Argv[0]) )
    {
        goto Help;
    }

    //  get zone name

    pszzoneName = Argv[ 0 ];
    pwszzoneName = UnicodeArgv[ 0 ];
    Argv++;
    Argc--;

    //  get zone type:

    cmd = getCommandName( Argv[0] );
    if ( !cmd )
    {
        goto Help;
    }

    zoneType = parseZoneTypeString( cmd, &fDsIntegrated );

    if ( zoneType == -1 )
    {
        goto Help;
    }

    if ( zoneType == DNS_ZONE_TYPE_SECONDARY ||
            zoneType == DNS_ZONE_TYPE_STUB ||
            zoneType == DNS_ZONE_TYPE_FORWARDER )
    {
        // get master IP list

        countMasters = readIpAddressArray(
                            masterArray,
                            MAX_IP_PROPERTY_COUNT,
                            Argc-1,
                            Argv+1,
                            FALSE );
        if ( countMasters < 1 )
        {
            goto Help;
        }
        Argv += countMasters;
        Argc -= countMasters;
    }

    Argv++;
    Argc--;

    //
    //  options
    //

    iArg = 0;

    while ( iArg < Argc )
    {
        cmd = getCommandName( Argv[iArg] );
        if ( !cmd )
        {
            goto Help;
        }

        if ( !_stricmp(cmd, "file") )
        {
            if ( ++iArg >= Argc )
            {
                goto Help;
            }
            pszDataFile = Argv[ iArg ];
        }
        else if ( !_stricmp( cmd, "OverWrite_Mem" ) )
        {
            loadOptions |= DNS_ZONE_LOAD_OVERWRITE_MEMORY;
        }
        else if ( !_stricmp( cmd, "OverWrite_Ds" ) )
        {
            loadOptions |= DNS_ZONE_LOAD_OVERWRITE_DS;
        }
        else if ( _stricmp( cmd, "Dp" ) == 0 ||
                  _stricmp( cmd, "DirectoryPartition" ) == 0 )
        {

            if ( ++iArg >= Argc )
            {
                goto Help;
            }

            if ( !parseDpSpecifier( Argv[ iArg ], &dpFlag, &pszDpFqdn ) )
            {
                goto Help;
            }
        }
        else
        {
            goto Help;
        }

        iArg++;
    }

    //
    //  reset type
    //

    status = DnssrvResetZoneTypeEx(
                pwszServerName,
                pszzoneName,
                zoneType,
                countMasters,
                masterArray,
                loadOptions,
                fDsIntegrated,
                pszDataFile,
                dpFlag,
                pszDpFqdn );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S reset type of zone %S:\n",
            pwszServerName,
            pwszzoneName );
    }
    return status;

Help:

    printf(
        "Usage: DnsCmd <ServerName> /ZoneResetType <ZoneName> <Property> [<Options>]\n"
        "  <ZoneName>      -- FQDN of zone\n"
        "  <Property>:\n"
        "    /DsPrimary\n"
        "    /Primary /file <filename>\n"
        "    /Secondary <MasterIPaddress> [<MasterIPaddress>] [/file <filename>]\n"
        "    /Stub <MasterIPaddress> [<MasterIPaddress>] [/file <filename>]\n"
        "    /DsStub <MasterIPaddress> [<MasterIPaddress>]\n"
        "    /Forwarder <MasterIPaddress> [<MasterIPaddress>] [/file <filename>]\n"
        "    /DsForwarder <MasterIPaddress> [<MasterIPaddress>] [/file <filename>]\n"
        "  <Options>:\n"
        "    /OverWrite_Mem  -- overwrite DNS by data in DS\n"
        "    /OverWrite_Ds   -- overwrite DS by data in DNS\n"
        "    /DirectoryPartition <FQDN> -- store the new zone in the directory\n"
        "        partition specified by the next argument\n" );
        
    return ERROR_INVALID_PARAMETER;
}



//
//  Zone rename
//

DNS_STATUS
ProcessZoneRename(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    LPSTR           pszCurrentZoneName = NULL;
    LPWSTR          pwszCurrentZoneName = NULL;
    LPSTR           pszNewZoneName = NULL;
    LPWSTR          pwszNewZoneName = NULL;
    LPSTR           pszNewFileName = NULL;
    LPSTR           cmd;

    //
    //  ZoneRename <ZoneName> <Property> [<options>]
    //

    if ( Argc < 2  ||
         Argc == NEED_HELP_ARGC ||
         getCommandName( Argv[ 0 ] ) )
    {
        goto Help;
    }

    //  get current and new zone names

    pszCurrentZoneName = Argv[ 0 ];
    pwszCurrentZoneName = UnicodeArgv[ 0 ];
    Argv++;
    UnicodeArgv++;
    Argc--;

    pwszNewZoneName = UnicodeArgv[ 0 ];
    Argv++;
    UnicodeArgv++;
    Argc--;

    // optionally get file name

    if ( Argc > 0 )
    {
        cmd = getCommandName( *Argv );
        Argc--;
        Argv++;
        if ( cmd && !_stricmp( cmd, "file" ) )
        {
            if ( Argc <= 0 )
            {
                goto Help;
            }
            pszNewFileName = *Argv;
            Argc--;
            Argv++;
        }
    }

    status = DnssrvRenameZone(
                pwszServerName,
                pszCurrentZoneName,
                pszNewZoneName,
                pszNewFileName );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S renamed zone\n    %S to\n    %S\n",
            pwszServerName,
            pwszCurrentZoneName,
            pwszNewZoneName );
    }
    return status;

Help:

    printf(
        "Usage: DnsCmd <ServerName> /ZoneRename <CurrentZoneName> <NewZoneName>\n" );

    return ERROR_INVALID_PARAMETER;
}


//
//  Zone export
//

DNS_STATUS
ProcessZoneExport(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    LPSTR           pszzoneName = NULL;
    LPWSTR          pwszzoneName = NULL;
    LPSTR           pszzoneExportFile = NULL;
    LPSTR           cmd;

    //
    //  ZoneExport <ZoneName> ZoneExportFile
    //

    if ( Argc != 2 || Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    //  Get zone name argument and output file argument.

    pszzoneName = Argv[ 0 ];
    pwszzoneName = UnicodeArgv[ 0 ];
    Argv++;
    Argc--;
    if ( _stricmp( pszzoneName, "/Cache" ) == 0 )
    {
        pszzoneName = DNS_ZONE_CACHE;
    }
    pszzoneExportFile = Argv[ 0 ];
    Argv++;
    Argc--;

    status = DnssrvExportZone(
                pwszServerName,
                pszzoneName,
                pszzoneExportFile );

    if ( status == ERROR_SUCCESS )
    {
        //
        //  If we are executing this command on the local server, try and
        //  get the real value of the windir environment variable to make
        //  the output as helpful as possible. Otherwise just print %windir%
        //  as literal text. Note: fServerIsRemote is not 100% accurate - if
        //  you type in the name of the local machine as the server, for
        //  example. But since it is only used to tailor the output message
        //  slightly this is acceptable.
        //

        BOOL        fServerIsRemote = wcscmp( pwszServerName, L"." ) != 0;
        char *      pszWinDir = "%windir%";

        if ( !fServerIsRemote )
        {
            char *  pszRealWinDir = getenv( "windir" );

            if ( pszRealWinDir )
            {
                pszWinDir = pszRealWinDir;
            }
        }

        printf(
            "DNS Server %S exported zone\n"
            "  %S to file %s\\system32\\dns\\%s%s\n",
            pwszServerName,
            pwszzoneName,
            pszWinDir,
            pszzoneExportFile,
            fServerIsRemote ? " on the DNS server" : "" );
    }
    return status;

Help:

    printf(
        "Usage: DnsCmd <ServerName> /ZoneExport <ZoneName> <ZoneExportFile>\n"
        "    <ZoneName>   -- FQDN of zone to export\n"
        "                    /Cache to export cache\n" );

    return ERROR_INVALID_PARAMETER;
}


//
//  Move zone to another directory partition
//

DNS_STATUS
ProcessZoneChangeDirectoryPartition(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    LPSTR           pszzoneName = NULL;
    LPWSTR          pwszzoneName = NULL;
    DWORD           dwdpFlag = 0;       //  directory partition flag for built-in
    LPSTR           pszdpFqdn = NULL;   //  directory partition FQDN for custom

    //
    //  ZoneChangeDP ZoneName NewPartitionName
    //

    if ( Argc != 2 || Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    pszzoneName = Argv[ 0 ];
    pwszzoneName = UnicodeArgv[ 0 ];
    Argv++;
    Argc--;

    if ( !parseDpSpecifier( *Argv, NULL, &pszdpFqdn ) )
    {
        goto Help;
    }
    Argv++;
    Argc--;

    status = DnssrvChangeZoneDirectoryPartition(
                pwszServerName,
                pszzoneName,
                pszdpFqdn );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S moved zone %S to new directory partition\n",
            pwszServerName,
            pwszzoneName );
    }
    return status;

Help:

    printf(
        "Usage: DnsCmd <ServerName> /ZoneChangeDirectoryPartition <ZoneName> <NewPartitionName>\n"
        "    <ZoneName>      -- FQDN of zone to move to new partition\n"
        "    <NewPartition>  -- FQDN of new directory partition or one of:\n"
        "                         /domain   - domain directory partition\n"
        "                         /forest   - forest directory partition\n"
        "                         /legacy   - legacy directory partition\n" );

    return ERROR_INVALID_PARAMETER;
}   //  ProcessZoneChangeDirectoryPartition





DNS_STATUS
ProcessZoneResetSecondaries(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       fsecureSecondaries = MAXDWORD;
    DWORD       fnotifyLevel = MAXDWORD;
    DWORD       countSecondaries = 0;
    DWORD       countNotify = 0;
    IP_ADDRESS  secondaries[ MAX_IP_PROPERTY_COUNT ];
    IP_ADDRESS  notifyList[ MAX_IP_PROPERTY_COUNT ];
    PIP_ADDRESS array;
    LPSTR       pszzoneName;
    LPWSTR      pwszzoneName;
    LPSTR       cmd;
    DWORD       count;

    //
    //  ZoneResetSecondaries <ZoneName> [<SecureFlag>] [<NotifyFlag>] [<NotifyIPAddress>] ...]
    //

    if ( Argc < 1 ||
         Argc == NEED_HELP_ARGC ||
         getCommandName( Argv[ 0 ] ) )
    {
        goto Help;
    }

    //  zone name

    pszzoneName = Argv[ 0 ];
    pwszzoneName = UnicodeArgv[ 0 ];

    Argc--;
    Argv++;

    //  read security and notify flags

    while ( Argc )
    {
        cmd = getCommandName( Argv[ 0 ] );
        if ( cmd )
        {
            //  security cases

            if ( !_stricmp(cmd, "NoXfr") )
            {
                fsecureSecondaries = ZONE_SECSECURE_NO_XFR;
            }
            else if ( !_stricmp(cmd, "SecureNs") )
            {
                fsecureSecondaries = ZONE_SECSECURE_NS_ONLY;
            }
            else if ( !_stricmp(cmd, "SecureList") )
            {
                fsecureSecondaries = ZONE_SECSECURE_LIST;
            }
            else if ( !_stricmp(cmd, "NonSecure") )
            {
                fsecureSecondaries = ZONE_SECSECURE_NO_SECURITY;
            }

            //  notify cases

            else if ( !_stricmp(cmd, "NoNotify") )
            {
                fnotifyLevel = ZONE_NOTIFY_OFF;
            }
            else if ( !_stricmp(cmd, "Notify") )
            {
                fnotifyLevel = ZONE_NOTIFY_ALL;
            }
            else if ( !_stricmp(cmd, "NotifyList") )
            {
                fnotifyLevel = ZONE_NOTIFY_LIST_ONLY;
            }
            else
            {
                goto Help;
            }
            Argc--;
            Argv++;
            continue;
        }

        //  get IP list
        //      - secondary IP before <Notify> flag
        //      - notify IP list after

        array = secondaries;
        if ( fnotifyLevel != MAXDWORD )
        {
            array = notifyList;
        }
        count = 0;

        while ( Argc )
        {
            IP_ADDRESS ip;

            cmd = getCommandName( Argv[0] );
            if ( cmd )
            {
                break;      // no more IP
            }

            ip = inet_addr( Argv[0] );
            if ( ip == -1 )
            {
                goto Help;
            }
            array[ count ] = ip;
            count++;

            Argc--;
            Argv++;
        }

        if ( fnotifyLevel == MAXDWORD )
        {
            countSecondaries = count;
        }
        else
        {
            countNotify = count;
        }
    }

    //
    //  default flags
    //      - do intelligent thing if lists are given
    //      otherwise default to open zone with notify
    //

    if ( countSecondaries )
    {
        fsecureSecondaries = ZONE_SECSECURE_LIST;
    }
    else if ( fsecureSecondaries == MAXDWORD )
    {
        fsecureSecondaries = ZONE_SECSECURE_NO_SECURITY;
    }

    if ( countNotify )
    {
        fnotifyLevel = ZONE_NOTIFY_LIST_ONLY;
    }
    else if ( fnotifyLevel == MAXDWORD )
    {
        fnotifyLevel = ZONE_NOTIFY_ALL;
    }

    //
    //  reset secondaries on server
    //

    if ( g_UseWmi )
    {
        status = DnscmdWmi_ProcessResetZoneSecondaries(
                    pszzoneName,
                    fsecureSecondaries,
                    countSecondaries,
                    secondaries,
                    fnotifyLevel,
                    countNotify,
                    notifyList );
    }
    else
    {
        status = DnssrvResetZoneSecondaries(
                    pwszServerName,
                    pszzoneName,
                    fsecureSecondaries,
                    countSecondaries,
                    secondaries,
                    fnotifyLevel,
                    countNotify,
                    notifyList );
    }

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "Zone %S reset notify list successful\n",
            pwszzoneName );
    }
    return status;

Help:

    printf(
        "Usage: DnsCmd <ServerName> /ZoneResetSecondaries <ZoneName> \n"
        "               [<Security>] [<SecondaryIPAddress>] ...]\n"
        "               [<Notify>] [<NotifyIPAddress>] ...]\n"
        "  <Security>:\n"
        "    /NoXfr       -- no zone transfer\n"
        "    /NonSecure   -- transfer to any IP (default)\n"
        "    /SecureNs    -- transfer only to NS for zone\n"
        "    /SecureList  -- transfer only to NS in secondary list; must\n"
        "                    then provide secondary IP list\n"
        "  <Notify>:\n"
        "    /NoNotify    -- turn off notify\n"
        "    /Notify      -- notify (default);  notifies all secondaries in list and \n"
        "                    for non-DS primary notifies all NS servers for zone\n"
        "    /NotifyList  -- notify only notify list IPs;\n"
        "                    must then provide notify IP list\n" );

    return ERROR_INVALID_PARAMETER;
}



DNS_STATUS
ProcessZoneResetScavengeServers(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    IP_ADDRESS  serverArray[ MAX_IP_PROPERTY_COUNT + 1 ];
    DWORD       serverCount;
    LPSTR       pszzoneName;
    LPWSTR      pwszzoneName;

    //
    //  ZoneSetScavengeServers <ZoneName> <ServerIPAddress>
    //

    if ( Argc < 1 || getCommandName(Argv[0]) )
    {
        goto Help;
    }

    //  zone name

    pszzoneName = Argv[ 0 ];
    pwszzoneName = UnicodeArgv[ 0 ];

    Argc--;
    Argv++;

    //  get server IP list

    serverCount = readIpArray(
                        (PIP_ARRAY) serverArray,
                        MAX_IP_PROPERTY_COUNT,
                        Argc,
                        Argv );

    if ( serverCount != Argc )
    {
        goto Help;
    }

    DnsPrint_Ip4Array(
        dnscmd_PrintRoutine,
        dnscmd_PrintContext,
        "New scavenge servers:",
        "server",
        ( PIP_ARRAY ) serverArray );

    //
    //  reset scavenging servers
    //      - if NO addresses given, send NULL to enable all servers to
    //      scavenge zone
    //

    status = DnssrvOperation(
                pwszServerName,
                pszzoneName,
                DNS_REGKEY_ZONE_SCAVENGE_SERVERS,
                DNSSRV_TYPEID_IPARRAY,
                serverCount
                    ? (PIP_ARRAY) serverArray
                    : NULL );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "Reset scavenging servers on zone %S successfully.\n",
            pwszzoneName );
    }
    else
    {
        printf(
            "Error, failed reset of scavenge servers on zone %S.\n"
            "    Status = %d\n",
            pwszzoneName,
            status );
    }
    return status;

Help:

    printf(
        "Usage: DnsCmd <ServerName> /ZoneResetScavengeServers <ZoneName> [<Server IPs>]\n"
        "    <Server IPs> -- list of one or more IP addresses of servers to scavenge\n"
        "           this zone;  if no addresses given ALL servers hosting this zone\n"
        "           will be allowed to scavenge the zone.\n" );

    return ERROR_INVALID_PARAMETER;
}



DNS_STATUS
ProcessZoneResetMasters(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS  status = ERROR_SUCCESS;
    IP_ADDRESS  serverArray[ MAX_IP_PROPERTY_COUNT+1 ];
    DWORD       serverCount;
    LPSTR       pszzoneName;
    LPWSTR      pwszzoneName;
    LPSTR       psz;
    BOOL        fLocalMasters = FALSE;

    //
    //  ZoneResetMasters <ZoneName> [/Local] <MasterIPAddress>
    //
    //  Local tells the server to set the local master list for DS integrated
    //  stub zones.
    //

    if ( Argc < 1 || getCommandName(Argv[0]) )
    {
        goto Help;
    }

    //  zone name

    pszzoneName = Argv[ 0 ];
    pwszzoneName = UnicodeArgv[ 0 ];

    Argc--;
    Argv++;

    //  local flag

    psz = getCommandName( Argv[ 0 ] );
    if ( psz )
    {
        if ( _stricmp( psz, "Local" ) == 0 )
        {
            fLocalMasters = TRUE;
        }
        else
        {
            goto Help;      //  Unknown option
        }
        Argc--;
        Argv++;
    }

    //  get server IP list - an empty IP list is permissable

    serverCount = readIpArray(
                        ( PIP_ARRAY ) serverArray,
                        MAX_IP_PROPERTY_COUNT,
                        Argc,
                        Argv );

    if ( serverCount != Argc )
    {
        goto Help;
    }

    //
    //  reset masters
    //

    if ( g_UseWmi )
    {
        status = DnscmdWmi_ProcessDnssrvOperation(
                    pszzoneName,
                    fLocalMasters ?
                        DNS_REGKEY_ZONE_LOCAL_MASTERS :
                        DNS_REGKEY_ZONE_MASTERS,
                    DNSSRV_TYPEID_IPARRAY,
                    ( PIP_ARRAY ) serverArray );
    }
    else
    {
        status = DnssrvOperation(
                    pwszServerName,
                    pszzoneName,
                    fLocalMasters ?
                        DNS_REGKEY_ZONE_LOCAL_MASTERS :
                        DNS_REGKEY_ZONE_MASTERS,
                    DNSSRV_TYPEID_IPARRAY,
                    ( PIP_ARRAY ) serverArray );
    }

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "Reset master servers for zone %S successfully.\n",
            pwszzoneName );
    }
    else
    {
        printf(
            "Error failed reset of master servers for zone %S.\n"
            "    Status = %d\n",
            pwszzoneName ,
            status );
    }
    return status;

Help:

    printf(
        "Usage: DnsCmd <ServerName> /ZoneResetMasters <ZoneName> [/Local] [<Server IPs>]\n"
        "    /Local -- Set the local master list for DS integrated zones.\n"
        "    <Server IPs> -- List of one or more IP addresses of master servers for\n"
        "           this zone.  Masters may include the primary or other secondaries\n"
        "           for the zone, but should not make the replication graph cyclic.\n" );

    return ERROR_INVALID_PARAMETER;
}



//
//  Record viewing commands
//

DNS_STATUS
ProcessEnumRecords(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    LPSTR           pzoneName;
    LPSTR           pnodeName;
    BOOL            ballocatedNode;
    LPSTR           pstartChild = NULL;
    WORD            type = DNS_TYPE_ALL;
    DWORD           flag = 0;
    DWORD           authFlag = 0;
    DWORD           bufferLength;
    PBYTE           pbuffer;
    LPSTR           pszcmd;
    PDNS_RPC_NAME   plastName;
    BOOL            bcontinue = FALSE;
    BOOL            bdetail = FALSE;
    CHAR            nextChildName[ DNS_MAX_NAME_BUFFER_LENGTH ];

    //
    //  EnumRecords
    //

    if ( Argc < 2 || Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    //
    //  read zone and domain name
    //

    readZoneAndDomainName(
        Argv,
        & pzoneName,
        & pnodeName,
        & ballocatedNode,
        NULL,
        NULL );

    Argv++;
    Argc--;
    Argv++;
    Argc--;

    //
    //  commands
    //
    //  on authority level flags, build separate from final flag
    //      so we can determine if authority screen was set, otherwise
    //      flag will be set to view all data

    while ( (LONG)Argc > 0 )
    {
        pszcmd = getCommandName( *Argv );
        if ( !pszcmd )
        {
            goto Help;
        }
        else if ( !_stricmp(pszcmd, "Continue") )
        {
            bcontinue = TRUE;
        }
        else if ( !_stricmp(pszcmd, "Detail") )
        {
            bdetail = TRUE;
        }
        else if ( !_stricmp(pszcmd, "Authority") )
        {
            authFlag |= DNS_RPC_VIEW_AUTHORITY_DATA;
        }
        else if ( !_stricmp(pszcmd, "Glue") )
        {
            authFlag |= DNS_RPC_VIEW_GLUE_DATA;
        }
        else if ( !_stricmp(pszcmd, "Additional") )
        {
            flag |= DNS_RPC_VIEW_ADDITIONAL_DATA;
        }
        else if ( !_stricmp(pszcmd, "Node") )
        {
            flag |= DNS_RPC_VIEW_NO_CHILDREN;
        }
        else if ( !_stricmp(pszcmd, "Root") )
        {
            flag |= DNS_RPC_VIEW_NO_CHILDREN;
        }
        else if ( !_stricmp(pszcmd, "Child") )
        {
            flag |= DNS_RPC_VIEW_ONLY_CHILDREN;
        }
        else if ( !_stricmp(pszcmd, "Type") )
        {
            Argv++;
            Argc--;
            if ( (INT)Argc <= 0 )
            {
                goto Help;
            }
            type = Dns_RecordTypeForName( *Argv, 0 );
            if ( type == 0 )
            {
                type = DNS_TYPE_ALL;
            }
        }
        else if ( !_stricmp(pszcmd, "StartChild") ||
                  !_stricmp(pszcmd, "StartPoint") )
        {
            Argv++;
            Argc--;
            if ( ! Argc )
            {
                goto Help;
            }
            pstartChild = *Argv;
        }
        else    // unknown command
        {
            goto Help;
        }

        Argc--;
        Argv++;
    }

    //  if no flag entered, view all data

    if ( authFlag == 0 )
    {
        authFlag = DNS_RPC_VIEW_ALL_DATA;
    }
    flag |= authFlag;


    //
    //  enumerate records
    //      - call in loop to handle error more data case
    //

    if ( g_UseWmi )
    {
        status = DnscmdWmi_ProcessEnumRecords(
                    pzoneName,
                    pnodeName,
                    bdetail,
                    flag );
    }
    else
    {
        while ( 1 )
        {
            status = DnssrvEnumRecords(
                        pwszServerName,
                        pzoneName,
                        pnodeName,
                        pstartChild,
                        type,
                        flag,
                        NULL,
                        NULL,
                        & bufferLength,
                        & pbuffer );

            if ( status == ERROR_SUCCESS ||
                status == ERROR_MORE_DATA )
            {
                plastName = DnsPrint_RpcRecordsInBuffer(
                                dnscmd_PrintRoutine,
                                dnscmd_PrintContext,
                                "Returned records:\n",
                                bdetail,
                                bufferLength,
                                pbuffer );

                if ( status == ERROR_SUCCESS )
                {
                    break;
                }

                //  more records to enumerate

                if ( !plastName )
                {
                    break;
                }
                DnssrvCopyRpcNameToBuffer(
                    nextChildName,
                    plastName );

                if ( bcontinue )
                {
                    pstartChild = nextChildName;

                    DNSDBG( ANY, (
                        "Continuing enum at %s\n",
                        pstartChild ));
                    continue;
                }
                else
                {
                    printf(
                        "More records remain to be enumerated!\n"
                        "\n"
                        "To enumerate ALL reissue the command with the \"/Continue\" option.\n"
                        "   OR\n"
                        "To enumerate remaining records serially, reissue the command \n"
                        "with \"/StartChild %s\" option.\n",
                        nextChildName );

                    status = ERROR_SUCCESS;
                    break;
                }
            }
            else
            {
                printf(
                    "DNS Server failed to enumerate records for node %s.\n"
                    "    Status = %d (0x%08lx)\n",
                    pnodeName,
                    status, status );
            }
            break;
        }
    }

    return status;

Help:

    printf( "Usage: DnsCmd <ServerName> /EnumRecords <ZoneName> <NodeName> "
        "[<DataOptions>] [<ViewOptions>]\n"
        "  <ZoneName>   -- FQDN of zone node to enumerate\n"
        "                  /RootHints for roots-hints enumeration\n"
        "                  /Cache for cache enumeration\n"
        "  <NodeName>   -- name of node whose records will be enumerated\n"
        "                  - \"@\" for zone root                            OR\n"
        "                  - FQDN of a node  (name with a '.' at the end) OR\n"
        "                  - node name relative to the <ZoneName>\n"
        "  <DataOptions>:  (All data is the default)\n"
        "    /Type <RRType> -- enumerate RRs of specific type\n"
        "      <RRType> is standard type name;  eg. A, NS, SOA, ...\n"
        "    /Authority     -- include authoritative data\n"
        "    /Glue          -- include glue data\n"
        "    /Additional    -- include additional data when enumerating\n"
        "    /Node          -- only enumerate RRs of the given node\n"
        "    /Child         -- only enumerate RRs of children of the given node\n"
        "    /StartChild <ChildName> -- child name, after which to start enumeration\n"
        "  <ViewOptions>:\n"
        "    /Continue      -- on full buffer condition, continue enum until end of records\n"
        "                      default is to retrieve only first buffer of data\n"
        "    /Detail        -- print detailed record node information\n"
        "                      default is view of records similar to zone file\n\n" );

    return ERROR_INVALID_PARAMETER;
}


typedef struct
{
    LONG        ilNodes;
    LONG        ilRecords;
    int         ilRecurseDepth;
    int         ilMaxRecurseDepth;
} DISP_ZONE_STATS, * PDISP_ZONE_STATS;


PDNS_RPC_NAME
DNS_API_FUNCTION
ProcessDisplayAllZoneRecords_Guts(
    IN      PRINT_ROUTINE   PrintRoutine,
    IN OUT  PPRINT_CONTEXT  pPrintContext,
    IN      LPSTR           pZoneName,
    IN      LPSTR           pNodeName,
    IN      WORD            wType,
    IN      DWORD           dwFlags,
    IN      BOOL            fDetail,
    IN      PDISP_ZONE_STATS    pStats
    )
/*++

Routine Description:

    The guts of the dump cache functionality.

Arguments:

    PrintRoutine -- printf like routine to print with

    fDetail -- if TRUE print detailed record info

    dwBufferLength -- buffer length

    abBuffer -- ptr to RPC buffer

Return Value:

    Ptr to last RPC node name in buffer.
    NULL on error.

--*/
{
    PBYTE           pcurrent;
    PBYTE           pstop;
    PDNS_RPC_NAME   plastName = NULL;
    INT             recordCount;
    PCHAR           precordHeader;
    DNS_STATUS      status;
    PBYTE           pbuffer = NULL;
    DWORD           dwbufferSize = 0;
    CHAR            nextChildName[ DNS_MAX_NAME_BUFFER_LENGTH ];
    LPSTR           pstartChild = NULL;
    BOOL            fdisplayedHeader = FALSE;

    if ( pStats )
    {
        if ( ++pStats->ilRecurseDepth > pStats->ilMaxRecurseDepth )
        {
            pStats->ilMaxRecurseDepth = pStats->ilRecurseDepth;
        }
        //  printf( "GUTS: depth %d: %s\n", pStats->ilRecurseDepth, pNodeName );
    }

    while ( 1 )
    {
        if ( pbuffer )
        {
            MIDL_user_free( pbuffer );
            pbuffer = NULL;
        }

        status = DnssrvEnumRecords(
                    pwszServerName,
                    pZoneName,
                    pNodeName,
                    pstartChild,
                    wType,
                    dwFlags,
                    NULL,
                    NULL,
                    &dwbufferSize,
                    &pbuffer );

        if ( status == ERROR_SUCCESS || status == ERROR_MORE_DATA )
        {
            DnsPrint_Lock();

            if ( !pbuffer )
            {
                PrintRoutine( pPrintContext, "NULL record buffer ptr.\n" );
                goto Done;
            }

            //
            //  find stop byte
            //

            ASSERT( DNS_IS_DWORD_ALIGNED( pbuffer ) );

            pstop = pbuffer + dwbufferSize;
            pcurrent = pbuffer;

            //
            //  loop until out of nodes
            //

            while ( pcurrent < pstop )
            {
                PDNS_RPC_NODE   pcurrNode = ( PDNS_RPC_NODE ) pcurrent;
                CHAR            szchildNodeName[ DNS_MAX_NAME_BUFFER_LENGTH ] = "";

                //
                //  print owner node
                //      - if NOT printing detail and no records
                //      (essentially domain nodes) then no node print
                //

                plastName = &pcurrNode->dnsNodeName;

                recordCount = pcurrNode->wRecordCount;

                if ( pStats )
                {
                    ++pStats->ilNodes;
                    pStats->ilRecords += recordCount;
                }

                if ( fDetail )
                {
                    DnsPrint_RpcNode(
                        PrintRoutine, pPrintContext,
                        NULL,
                        (PDNS_RPC_NODE)pcurrent );
                    if ( recordCount == 0 )
                    {
                        PrintRoutine( pPrintContext, "\n" );
                    }
                }
                else if ( recordCount != 0 )
                {
                    BOOL    outputLastName = FALSE;

                    if ( plastName && plastName->cchNameLength )
                    {
                        DnsPrint_RpcName(
                            PrintRoutine, pPrintContext,
                            NULL,
                            plastName,
                            NULL );
                        outputLastName = TRUE;
                    }
                    if ( pNodeName &&
                         ( *pNodeName != '@' || !outputLastName ) )
                    {
                        PWSTR pwsznodeName = getUnicodeForUtf8( pNodeName );
                    
                        PrintRoutine(
                            pPrintContext,
                            "%s%S",
                            outputLastName ? "." : "",
                            pwsznodeName );

                        FREE_HEAP( pwsznodeName );
                    }
                }

                if ( pcurrNode->dwFlags & DNS_RPC_FLAG_NODE_STICKY )
                {
                    //
                    //  Set up child node name before we start iterating
                    //  records at this name.
                    //

                    memcpy(
                        szchildNodeName,
                        pcurrNode->dnsNodeName.achName,
                        pcurrNode->dnsNodeName.cchNameLength );
                    szchildNodeName[ pcurrNode->dnsNodeName.cchNameLength ] = '.';
                    szchildNodeName[ pcurrNode->dnsNodeName.cchNameLength + 1 ] = '\0';
                    if ( strcmp( pNodeName, "@" ) != 0 ) 
                    {
                        strcat( szchildNodeName, pNodeName );
                    }
                    if ( szchildNodeName[ strlen( szchildNodeName ) - 1 ] == '.' )
                    {
                        szchildNodeName[ strlen( szchildNodeName ) - 1 ] = '\0';
                    }
                }

                pcurrent += pcurrNode->wLength;
                pcurrent = DNS_NEXT_DWORD_PTR(pcurrent);

                //
                //  Print all records at this node.
                //

                precordHeader = "";

                while( recordCount-- )
                {
                    if ( pcurrent >= pstop )
                    {
                        PrintRoutine( pPrintContext,
                            "ERROR:  Bogus buffer at %p\n"
                            "    Expect record at %p past buffer end at %p\n"
                            "    with %d records remaining.\n",
                            pbuffer,
                            (PDNS_RPC_RECORD) pcurrent,
                            pstop,
                            recordCount+1 );

                        ASSERT( FALSE );
                        break;
                    }

                    DnsPrint_RpcRecord(
                        PrintRoutine, pPrintContext,
                        precordHeader,
                        fDetail,
                        (PDNS_RPC_RECORD)pcurrent );

                    precordHeader = "\t\t";

                    pcurrent += ((PDNS_RPC_RECORD)pcurrent)->wDataLength
                                    + SIZEOF_DNS_RPC_RECORD_HEADER;
            
                    pcurrent = DNS_NEXT_DWORD_PTR(pcurrent);
                }

                //
                //  Recurse on this node if it has children. If the caller's
                //  header argument is NULL or is a comment assume we're at
                //  the root of the zone.
                //

                if ( *szchildNodeName )
                {
                    ProcessDisplayAllZoneRecords_Guts(
                        PrintRoutine,
                        pPrintContext,
                        pZoneName,
                        szchildNodeName,
                        wType,
                        dwFlags,
                        fDetail,
                        pStats );
                }
            }

            if ( status == ERROR_SUCCESS )
            {
                break;
            }

            //  more records to enumerate

            if ( !plastName )
            {
                break;
            }
            DnssrvCopyRpcNameToBuffer(
                nextChildName,
                plastName );

            pstartChild = nextChildName;

            DNSDBG( ANY, (
                "Continuing enum at %s\n",
                pstartChild ));
            continue;
        }
        else
        {
            printf(
                "DNS Server failed to enumerate records for node %s.\n"
                "    Status = %s     %d  (0x%08lx)\n",
                pNodeName,
                Dns_StatusString( status ),
                status, status );
        }
        break;
    }
    if ( pbuffer )
    {
        MIDL_user_free( pbuffer );
    }

Done:

    DnsPrint_Unlock();

    if ( pStats )
    {
        --pStats->ilRecurseDepth;
    }

    return plastName;
}   //  ProcessDisplayAllZoneRecords_Guts


DNS_STATUS
ProcessDisplayAllZoneRecords(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    LPSTR           pszcmd;
    LPSTR           pszzoneName = NULL;
    BOOL            bdetail = FALSE;
    time_t          now;
    CHAR            sznow[ 30 ];
    size_t          len;
    WCHAR           wszserverName[ DNS_MAX_NAME_BUFFER_LENGTH ] = L"";
    PWSTR           pwszserverDisplayName = pwszServerName;
    DISP_ZONE_STATS displayZoneStats = { 0 };
    PWSTR           pwszzonename;

    //
    //  /ZonePrint [ZoneName] /Detail
    //

    if ( Argc > 3 || Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    //
    //  Parse arguments.
    //

    while ( Argc )
    {
        pszcmd = getCommandName( *Argv );
        if ( !pszcmd && !pszzoneName )
        {
            pszzoneName = *Argv;
        }
        else if ( _strnicmp( pszcmd, "D", 1 ) == 0 )
        {
            bdetail = TRUE;
        }
        else
        {
            goto Help;
        }
        Argv++;
        Argc--;
    }
    if ( !pszzoneName )
    {
        goto Help;
    }

    //  Get time string.

    time( &now );
    strcpy( sznow, asctime( gmtime( &now ) ) );
    len = strlen( sznow ) - 1;
    if ( sznow[ len ] == '\n' )
    {
        sznow[ len ] = '\0';
    }

    //  Get local hostname string.

    if ( wcscmp( pwszServerName, L"." ) == 0 )
    {
        DWORD bufsize = sizeof( wszserverName ) /
                        sizeof( wszserverName[ 0 ] );

        if ( GetComputerNameExW(
                ComputerNamePhysicalDnsFullyQualified,
                wszserverName,
                &bufsize ) )
        {
            pwszserverDisplayName = wszserverName;
        }
    }

    pwszzonename = getUnicodeForUtf8( pszzoneName );

    dnscmd_PrintRoutine(
        dnscmd_PrintContext,
        ";\n"
        ";  Zone:    %S\n"
        ";  Server:  %S\n"
        ";  Time:    %s UTC\n"
        ";\n",
        pwszzonename,
        pwszserverDisplayName,
        sznow );

    FREE_HEAP( pwszzonename );

    if ( ProcessDisplayAllZoneRecords_Guts(
            dnscmd_PrintRoutine,
            dnscmd_PrintContext,
            pszzoneName,
            "@",
            DNS_TYPE_ALL,
            DNS_RPC_VIEW_ALL_DATA,
            bdetail,
            &displayZoneStats ) )
    {
        dnscmd_PrintRoutine(
            dnscmd_PrintContext,
            ";\n"
            ";  Finished zone: %lu nodes and %lu records in %d seconds\n"
            ";\n",
            displayZoneStats.ilNodes,
            displayZoneStats.ilRecords,
            time( NULL ) - now );
    }

    return status;

Help:

    printf(
        "Usage: DnsCmd <ServerName> /ZonePrint [<ZoneName>] [/Detail]\n"
        "  <ZoneName> -- name of the zone (use ..Cache for DNS server cache)\n"
        "  /Detail -- explicit RPC node contents\n" );

    return ERROR_INVALID_PARAMETER;
}   //  ProcessDisplayAllZoneRecords



DNS_STATUS
ProcessSbsRegister(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    IP_ADDRESS      hostIp;
    DWORD           ttl;

    //
    //  SbsRegister
    //

    if ( Argc < 2 || Argc == NEED_HELP_ARGC )
    {
        goto Usage;
    }

    //  client host IP

    hostIp = inet_addr( Argv[3] );
    if ( hostIp == (-1) )
    {
        goto Usage;
    }

    //  record TTL

    ttl = strtoul(
            Argv[3],
            NULL,
            10 );

    status = DnssrvSbsAddClientToIspZone(
                pwszServerName,
                Argv[0],
                Argv[1],
                Argv[2],
                hostIp,
                ttl );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S registered SAM records for client %s:\n",
            pwszServerName,
            Argv[1] );
    }
    else
    {
        printf(
            "DNS Server %S failed to register SAM records for %s.\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            Argv[1],
            status, status );
    }
    return status;

Usage:

    printf(
        "Usage: dnscmd <Server> /SbsRegister <IspZoneName> <Client> <ClientHost> <HostIP> <TTL>\n"
        "  <Server>         -- server name (DNS, netBIOS or IP)\n"
        "  <IspZoneName>    -- full DNS name of ISP's zone\n"
        "  <Client>         -- client name (not FQDN)\n"
        "  <ClientHost>     -- client host name (not FQDN)\n"
        "  <HostIP>         -- client host IP\n"
        "  <Ttl>            -- TTL for records\n"
        "\n" );

    return ERROR_INVALID_PARAMETER;
}



DNS_STATUS
ProcessSbsDeleteRecord(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    WORD            type;
    IP_ADDRESS      hostIp = 0;
    LPSTR           pszdata = NULL;

    //
    //  SbsRegister
    //

    if ( Argc < 5 || Argc == NEED_HELP_ARGC )
    {
        goto Usage;
    }

    //  type to delete

    type = Dns_RecordTypeForName( Argv[3], 0 );
    if ( type == 0 )
    {
        goto Usage;
    }

    //  if A record, then data will be IP address, otherwise it is DNS name

    if ( type == DNS_TYPE_A )
    {
        hostIp = inet_addr( Argv[4] );
        if ( hostIp == (-1) )
        {
            goto Usage;
        }
    }
    else
    {
        pszdata = Argv[4];
    }

    status = DnssrvSbsDeleteRecord(
                pwszServerName,
                Argv[0],
                Argv[1],
                Argv[2],
                type,
                pszdata,
                hostIp );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S deleted SAM record at %s in client domain %s:\n",
            pwszServerName,
            Argv[2],
            Argv[1] );
    }
    else
    {
        printf(
            "DNS Server %S failed to delete SAM record at %s in domain %s.\n"
            "    Status = %d (0x%08lx)\n",
            pwszServerName,
            Argv[2],
            Argv[1],
            status, status );
    }
    return status;

Usage:

    printf(
        "Usage: DnsCmd <Server> /SbsDeleteA <ZoneName> <Domain> <Host> <Type> <Data>\n"
        "  <Server>     -- server name (DNS, netBIOS or IP)\n"
        "  <ZoneName>   -- full DNS name of ISP's zone\n"
        "  <Client>     -- client name (not FQDN)\n"
        "  <Host>       -- client host name (not FQDN)\n"
        "  <Type>       -- record type (ex. A, NS, CNAME)\n"
        "  <HostIP>     -- client host IP\n"
        "\n" );

    return ERROR_INVALID_PARAMETER;
}



//
//  Directory partition operations
//

DNS_STATUS
ProcessEnumDirectoryPartitions(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS          status = ERROR_SUCCESS;
    PDNS_RPC_DP_LIST    pdpList = NULL;
    LPSTR               pszcmd;
    DWORD               dwfilter = 0;

    //
    //  Command format: /EnumDirectoryPartitions [filter strings]
    //
    //  
    //

    if ( Argc > 1 || Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    if ( Argc == 1 )
    {
        pszcmd = getCommandName( *Argv );
        if ( pszcmd && _strnicmp( pszcmd, "Cust", 4 ) == 0 )
        {
            dwfilter |= DNS_ENUMDPS_CUSTOMONLY;
        }
        Argv++;
        Argc--;
    }

    status = DnssrvEnumDirectoryPartitions(
                pwszServerName,
                dwfilter,
                &pdpList );

    if ( status != ERROR_SUCCESS )
    {
        printf(
            "Directory partition enumeration failed\n"
            "    status = %d (0x%08lx)\n",
            status, status );
        goto Cleanup;
    }
    else
    {
        DnsPrint_RpcDpList(
            dnscmd_PrintRoutine,
            dnscmd_PrintContext,
            "Enumerated directory partition list:\n",
            pdpList );
    }

    Cleanup:

    //
    //  deallocate zone list
    //

    DnssrvFreeDirectoryPartitionList( pdpList );
    return status;

    Help:

    printf( "Usage: DnsCmd <ServerName> /EnumDirectoryPartitions [/Custom]\n" );
    return ERROR_INVALID_PARAMETER;
}   //  ProcessEnumDirectoryPartitions


DNS_STATUS
ProcessDirectoryPartitionInfo(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS          status = ERROR_SUCCESS;
    PDNS_RPC_DP_INFO    pDpInfo = NULL;
    BOOL                bdetail = FALSE;
    LPSTR               pszfqdn;
    LPSTR               pszcmd;

    //
    //  Command format: /DirectoryPartitionInfo fqdn [/Detail]
    //
    //  Currently no arguments.
    //

    if ( Argc <= 0 || Argc > 2 || Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    pszfqdn = *Argv;
    Argv++;
    Argc--;

    if ( Argc == 1 )
    {
        pszcmd = getCommandName( *Argv );
        if ( pszcmd && _stricmp( pszcmd, "Detail" ) == 0 )
        {
            bdetail = TRUE;
        }
        Argv++;
        Argc--;
    }

    status = DnssrvDirectoryPartitionInfo(
                pwszServerName,
                pszfqdn,
                &pDpInfo );

    if ( status != ERROR_SUCCESS )
    {
        printf(
            "Directory partition info query failed\n"
            "    status = %d (0x%08lx)\n",
            status, status );
        goto Cleanup;
    }
    else
    {
        DnsPrint_RpcDpInfo(
            dnscmd_PrintRoutine,
            dnscmd_PrintContext,
            "Directory partition info:",
            pDpInfo,
            !bdetail );
    }

    Cleanup:

    DnssrvFreeDirectoryPartitionInfo( pDpInfo );
    return status;

    Help:

    printf( "Usage: DnsCmd <ServerName> /DirectoryPartitionInfo <FQDN of partition> [/Detail]\n" );
    return ERROR_INVALID_PARAMETER;
}   //  ProcessDirectoryPartitionInfo


DNS_STATUS
ProcessCreateDirectoryPartition(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    PSTR            pszDpFqdn;
    PWSTR           pwszDpFqdn;

    //
    //  Command format: /CreateDirectoryPartition DP-FQDN [/Create]
    //

    if ( Argc != 1 )
    {
        goto Help;
    }

    pszDpFqdn = Argv[ 0 ];

    //
    //  Make sure FQDN argument is not a command switch.
    //

    if ( !pszDpFqdn || pszDpFqdn[ 0 ] == '/' )
    {
        return ERROR_INVALID_PARAMETER;
    }

    //
    //  Perform the operation.
    //

    status = DnssrvEnlistDirectoryPartition(
                pwszServerName,
                DNS_DP_OP_CREATE,
                pszDpFqdn );

    pwszDpFqdn = getUnicodeForUtf8( pszDpFqdn );
    
    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S created directory partition: %S\n",
            pwszServerName,
            pwszDpFqdn );
    }
    else
    {
        wprintf(
            L"Create directory partition failed: %s\n"
            L"    status = %d (0x%08lx)\n",
            pwszDpFqdn,
            status, status );
    }

    FREE_HEAP( pwszDpFqdn );
    
    return status;

    Help:

    printf( "Usage: DnsCmd <ServerName> /CreateDirectoryPartition <FQDN of partition>\n" );
    return ERROR_INVALID_PARAMETER;
}   //  ProcessCreateDirectoryPartition


DNS_STATUS
ProcessDeleteDirectoryPartition(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    LPSTR           pszDpFqdn;
    LPWSTR          pwszDpFqdn;

    //
    //  Command format: /DeleteDirectoryPartition DP-FQDN [/Create]
    //

    if ( Argc != 1 )
    {
        goto Help;
    }

    pszDpFqdn = Argv[ 0 ];
    pwszDpFqdn = UnicodeArgv[ 0 ];

    status = DnssrvEnlistDirectoryPartition(
                pwszServerName,
                DNS_DP_OP_DELETE,
                pszDpFqdn );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S deleted directory partition: %S\n",
            pwszServerName,
            pwszDpFqdn );
    }
    else
    {
        printf(
            "Delete directory partition failed: %S\n"
            "    status = %d (0x%08lx)\n",
            pwszDpFqdn,
            status, status );
    }

    return status;

    Help:

    printf( "Usage: DnsCmd <ServerName> /DeleteDirectoryPartition <FQDN of partition>\n" );
    return ERROR_INVALID_PARAMETER;
}   //  ProcessDeleteDirectoryPartition


DNS_STATUS
ProcessEnlistDirectoryPartition(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    LPSTR           pszDpFqdn;
    LPWSTR          pwszDpFqdn;

    //
    //  Command format: /EnlistDirectoryPartition DP-FQDN [/Create]
    //

    if ( Argc != 1 )
    {
        goto Help;
    }

    pszDpFqdn = Argv[ 0 ];
    pwszDpFqdn = UnicodeArgv[ 0 ];

    status = DnssrvEnlistDirectoryPartition(
                pwszServerName,
                DNS_DP_OP_ENLIST,
                pszDpFqdn );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S enlisted directory partition: %S\n",
            pwszServerName,
            pwszDpFqdn );
    }
    else
    {
        printf(
            "Enlist directory partition failed: %S\n"
            "    status = %d (0x%08lX)\n",
            pwszDpFqdn,
            status, status );
    }

    return status;

    Help:

    printf( "Usage: DnsCmd <ServerName> /EnlistDirectoryPartition <FQDN of partition>\n" );
    return ERROR_INVALID_PARAMETER;
}   //  ProcessEnlistDirectoryPartition


DNS_STATUS
ProcessUnenlistDirectoryPartition(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    LPSTR           pszDpFqdn;
    LPWSTR          pwszDpFqdn;

    //
    //  Command format: /UnenlistDirectoryPartition DP-FQDN [/Create]
    //

    if ( Argc != 1 )
    {
        goto Help;
    }

    pszDpFqdn = Argv[ 0 ];
    pwszDpFqdn = UnicodeArgv[ 0 ];

    status = DnssrvEnlistDirectoryPartition(
                pwszServerName,
                DNS_DP_OP_UNENLIST,
                pszDpFqdn );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S unenlisted directory partition: %S\n",
            pwszServerName,
            pwszDpFqdn );
    }
    else
    {
        printf(
            "Unenlist directory partition failed: %S\n"
            "    status = %d (0x%08lX)\n",
            pwszDpFqdn,
            status, status );
    }

    return status;

    Help:

    printf( "Usage: DnsCmd <ServerName> /UnenlistDirectoryPartition <FQDN of partition>\n" );
    return ERROR_INVALID_PARAMETER;
}   //  ProcessUnenlistDirectoryPartition



DNS_STATUS
ProcessCreateBuiltinDirectoryPartitions(
    IN  DWORD       Argc,
    IN  LPSTR *     Argv,
    IN  LPWSTR *    UnicodeArgv
    )
{
    DNS_STATUS      status = ERROR_SUCCESS;
    DWORD           dwopcode = 0xFFFFFFFF;
    PCHAR           psz;

    //
    //  Command format: /CreateBuiltinDPs [/Domain | /Forest | /AllDomains]
    //
    //  /Domain         - create domain DP
    //  /Forest         - create forest DP
    //  /AllDomains     - create domain DPs for all domains in forest
    //

    if ( Argc != 1 || Argc == NEED_HELP_ARGC )
    {
        goto Help;
    }

    if ( ( psz = getCommandName( Argv[ 0 ] ) ) != NULL )
    {
        if ( _strnicmp( psz, "All", 3 ) == 0 )
        {
            dwopcode = DNS_DP_OP_CREATE_ALL_DOMAINS;
        }
        else if ( _strnicmp( psz, "For", 3 ) == 0 )
        {
            dwopcode = DNS_DP_OP_CREATE_FOREST;
        }
        else if ( _strnicmp( psz, "Dom", 3 ) == 0 )
        {
            dwopcode = DNS_DP_OP_CREATE_DOMAIN;
        }
        else
        {
            goto Help;
        }
    }

    status = DnssrvEnlistDirectoryPartition(
                pwszServerName,
                dwopcode,
                NULL );

    if ( status == ERROR_SUCCESS )
    {
        printf(
            "DNS Server %S completed operation successfully\n",
            pwszServerName );
    }
    else
    {
        printf(
            "Create built-in directory partitions failed\n"
            "    status = %d (0x%08lx)\n",
            status, status );
    }

    return status;

    Help:

    printf(
        "Usage: DnsCmd <ServerName> /CreateBuiltinDirectoryPartitions <Option>\n"
        "  Option must be one of:\n"
        "    /Domain -- Creates the built-in domain-wide DNS directory partition for\n"
        "        the Active Directory domain where the DNS server specified by\n"
        "        ServerName is located.\n"
        "    /Forest -- Creates the built-in forest-wide DNS directory partition for\n"
        "        the Active Directory forest where the DNS server specified by\n"
        "        ServerName is located.\n"
        "    /AllDomains -- Creates the built-in domain-wide DNS directory partitions\n"
        "        on a DNS server in each domain in the Active Directory forest where\n"
        "        the user running this command is logged on. The ServerName argument\n"
        "        is ignored for this operation.\n" );
    return ERROR_INVALID_PARAMETER;
}   //  ProcessCreateBuiltinDirectoryPartitions



//
//  Command table
//  Have this down here so no need for private protos on dispatch functions.
//
//  DEVNOTE: all this needs internationalization
//

COMMAND_INFO  GlobalCommandInfo[] =
{
    //  Zone + Server operations

    //  Server and Zone Operations

    {   "/Info",
            ProcessInfo,
                "Get server information"
    },
    {   "/Config",
            ProcessResetProperty,
                "Reset server or zone configuration"
    },
    {   "/EnumZones",
            ProcessEnumZones,
                "Enumerate zones"
    },

    //  Server Operations

    {   "/Statistics",
            ProcessStatistics,
                "Query/clear server statistics data"
    },
    {   "/ClearCache",
            ProcessSimpleServerOperation,
                "Clear DNS server cache"
    },
    {   "/WriteBackFiles",
            ProcessWriteBackFiles,
                "Write back all zone or root-hint datafile(s)"
    },
    {   "/StartScavenging",
            ProcessSimpleServerOperation,
                "Initiates server scavenging"
    },

    //  Server Property Reset

    {   "/ResetListenAddresses",
            ProcessResetListenAddresses,
                "Set server IP address(es) to serve DNS requests"
    },
    {   "/ResetForwarders",
            ProcessResetForwarders,
                "Set DNS servers to forward recursive queries to"
    },

    //  Zone Operations

    {   "/ZoneInfo",
            ProcessZoneInfo,
                "View zone information"
    },
    {   "/ZoneAdd",
            ProcessZoneAdd,
                "Create a new zone on the DNS server"
    },
    {   "/ZoneDelete",
            ProcessZoneDelete,
                "Delete a zone from DNS server or DS"
    },
    {   "/ZonePause",
            ProcessZonePause,
                "Pause a zone"
    },
    {   "/ZoneResume",
            ProcessZoneResume,
                "Resume a zone"
    },
    {   "/ZoneReload",
            ProcessZoneReload,
                "Reload zone from its database (file or DS)"
    },
    {   "/ZoneWriteBack",
            ProcessZoneWriteBack,
                "Write back zone to file"
    },
    {   "/ZoneRefresh",
            ProcessZoneRefresh,
                "Force refresh of secondary zone from master"
    },
    {   "/ZoneUpdateFromDs",
            ProcessZoneUpdateFromDs,
                "Update a DS integrated zone by data from DS"
    },
    {   "/ZonePrint",
            ProcessDisplayAllZoneRecords,
                "Display all records in the zone"
    },

    //  Zone Property Reset

    {   "/ZoneResetType",
            ProcessZoneResetType,
                "Change zone type"
    },
    {   "/ZoneResetSecondaries",
            ProcessZoneResetSecondaries,
                "Reset secondary\\notify information for a zone"
    },
    {   "/ZoneResetScavengeServers",
            ProcessZoneResetScavengeServers,
                "Reset scavenging servers for a zone"
    },
    {   "/ZoneResetMasters",
            ProcessZoneResetMasters,
                "Reset secondary zone's master servers"
    },
#if 0
    {   "/ZoneRename",
            ProcessZoneRename,
                "Rename a zone"
    },
#endif
    {   "/ZoneExport",
            ProcessZoneExport,
                "Export a zone to file"
    },
#if 0
    {   "/ZoneResetAging",
            ProcessZoneResetAging,
                "Reset aging\scavenging information for a zone"
    },
#endif
    {   "/ZoneChangeDirectoryPartition",
            ProcessZoneChangeDirectoryPartition,
                "Move a zone to another directory partition"
    },

    //  Record Operations

    {   "/EnumRecords",
            ProcessEnumRecords,
                "Enumerate records at a name"
    },
    {   "/RecordAdd",
            ProcessRecordAdd,
                "Create a record in zone or RootHints"
    },
    {   "/RecordDelete",
            ProcessRecordDelete,
                "Delete a record from zone, RootHints or cache"
    },
    {   "/NodeDelete",
            ProcessNodeDelete,
                "Delete all records at a name"
    },
    {   "/AgeAllRecords",
            ProcessAgeAllRecords,
                "Force aging on node(s) in zone"
    },

    //  Directory partitions

    {
        "/EnumDirectoryPartitions",
            ProcessEnumDirectoryPartitions,
                "Enumerate directory partitions"
    },
    {
        "/DirectoryPartitionInfo",
            ProcessDirectoryPartitionInfo,
                "Get info on a directory partition"
    },
    {
        "/CreateDirectoryPartition",
            ProcessCreateDirectoryPartition,
                "Create a directory partition"
    },
    {
        "/DeleteDirectoryPartition",
            ProcessDeleteDirectoryPartition,
                "Delete a directory partition"
    },
    {
        "/EnlistDirectoryPartition",
            ProcessEnlistDirectoryPartition,
                "Add DNS server to partition replication scope"
    },
    {
        "/UnenlistDirectoryPartition",
            ProcessUnenlistDirectoryPartition,
                "Remove DNS server from replication scope"
    },
    {   "/CreateBuiltinDirectoryPartitions",
            ProcessCreateBuiltinDirectoryPartitions,
                "Create built-in partitions"
    },


    //  END displayed commands
    //  commands below here are duplicate names of above or
    //  hidden commands

    {   "***StopDisplayMarker***",
            NULL,
                NULL
    },

    //  Hidden

    {   "/Restart",
            ProcessSimpleServerOperation,
                "Restart DNS server"
    },
    {   "/" DNSSRV_OP_AUTO_CONFIGURE,
            ProcessAutoConfigure,
                "Prime root hints, forwarder, and point resolver at local server"
    },

    //  Debug only

    {   "/DebugBreak",
            ProcessSimpleServerOperation,
                "Server debug break (internal)"
    },
    {   "/ClearDebugLog",
            ProcessSimpleServerOperation,
                "Clear server debug log (internal)"
    },
    {   "/RootBreak",
            ProcessSimpleServerOperation,
                "Root break (internal)"
    },

    //  Duplicate command names

    {   "/ResetRegistry",
            ProcessResetProperty,
                "Reset server or zone configuration"
    },
    {   "/ZoneResetNotify",
            ProcessZoneResetSecondaries,
                "Reset secondary\notify information for a zone"
    },
    {   "/DeleteNode",
            ProcessNodeDelete,
                "Delete all records at a name"
    },
    {   "/WriteBackFiles",
            ProcessWriteBackFiles,
                "Write back all zone or root-hint datafiles"
    },

    //  SAM test

    {   "/SbsRegister",
            ProcessSbsRegister,
                "SBS Registration"
    },
    {   "/SbsDeleteRecord",
            ProcessSbsDeleteRecord,
                "SBS Record Delete"
    },

    //  Directory partitions

    {   "/EnumDPs",
            ProcessEnumDirectoryPartitions,
                "Enumerate directory partitions"
    },
    {
        "/DPInfo",
            ProcessDirectoryPartitionInfo,
                "Get info on a directory partition"
    },
    {
        "/CreateDP",
            ProcessCreateDirectoryPartition,
                "Create a directory partition"
    },
    {
        "/DeleteDP",
            ProcessDeleteDirectoryPartition,
                "Delete a directory partition"
    },
    {
        "/EnlistDP",
            ProcessEnlistDirectoryPartition,
                "Add DNS server to partition replication scope"
    },
    {
        "/UnenlistDP",
            ProcessUnenlistDirectoryPartition,
                "Remove DNS server from replication scope"
    },
    {   "/ZoneChangeDP",
            ProcessZoneChangeDirectoryPartition,
                "Move zone to another directory partition"
    },
    {   "/CreateBuiltinDirectoryPartitions",
            ProcessCreateBuiltinDirectoryPartitions,
                "Create built-in partitions using admin's credentials"
    },
    {   "/CreateBuiltinDPs",
            ProcessCreateBuiltinDirectoryPartitions,
                "Create built-in partitions using admin's credentials"
    },

    { NULL,   NULL,  "" },
};


//
//  End dnscmd.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\client\rconvert.c ===
/*++

Copyright (c) 1997-2000  Microsoft Corporation

Module Name:

    rconvert.c

Abstract:

    Domain Name System (DNS) Server -- Admin Client Library

    RPC record conversion routines.
    Convert records in RPC buffer to DNS_RECORD type.

Author:

    Jim Gilroy (jamesg)     April, 1997

Revision History:

--*/


#include "dnsclip.h"


#define IS_COMPLETE_NODE( pRpcNode )    \
            (!!((pRpcNode)->dwFlags & DNS_RPC_NODE_FLAG_COMPLETE))

//
//  Copy-convert string from RPC format (UTF8) into DNS_RECORD buffer
//      - assume previously allocated required buffer
//
//  Note:  no difference between string and name conversion as we're
//          going FROM UTF8
//

#define COPY_UTF8_STR_TO_BUFFER( buf, psz, len, charSet ) \
        Dns_StringCopy(     \
            (buf),          \
            NULL,           \
            (psz),          \
            (len),          \
            DnsCharSetUtf8, \
            (charSet) )


//
//  RPC record to DNS_RECORD conversion routines
//

PDNS_RECORD
ARpcRecordConvert(
    IN      PDNS_RPC_RECORD pRpcRR,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Read A record data from packet.

Arguments:

    pRpcRR - message being read

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;

    DNS_ASSERT( pRpcRR->wDataLength == sizeof( IP_ADDRESS ) );

    precord = Dns_AllocateRecord( sizeof( IP_ADDRESS ) );
    if ( !precord )
    {
        return NULL;
    }
    precord->Data.A.IpAddress = pRpcRR->Data.A.ipAddress;

    return precord;
}



PDNS_RECORD
PtrRpcRecordConvert(
    IN      PDNS_RPC_RECORD pRpcRR,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Process PTR compatible record from wire.
    Includes: NS, PTR, CNAME, MB, MR, MG, MD, MF

Arguments:

    pRpcRR - message being read

    CharSet - character set for resulting record

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;
    PDNS_RPC_NAME   pname = &pRpcRR->Data.PTR.nameNode;
    WORD            bufLength;

    //
    //  PTR data is another domain name
    //

    if ( ! DNS_IS_NAME_IN_RECORD(pRpcRR, pname) )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_PTR_DATA )
                + STR_BUF_SIZE_GIVEN_UTF8_LEN( pname->cchNameLength, CharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return NULL;
    }

    //
    //  write hostname into buffer, immediately following PTR data struct
    //

    precord->Data.PTR.pNameHost = (PCHAR)&precord->Data + sizeof(DNS_PTR_DATA);

    COPY_UTF8_STR_TO_BUFFER(
        precord->Data.PTR.pNameHost,
        pname->achName,
        pname->cchNameLength,
        CharSet );

    return precord;
}



PDNS_RECORD
SoaRpcRecordConvert(
    IN      PDNS_RPC_RECORD pRpcRR,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Read SOA record from wire.

Arguments:

    pRR - ptr to record with RR set context

    pRpcRR - message being read

    pchData - ptr to RR data field

    pchEnd - ptr to byte after data field

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;
    WORD            bufLength;
    DWORD           dwLength;
    PDNS_RPC_NAME   pnamePrimary = &pRpcRR->Data.SOA.namePrimaryServer;
    PDNS_RPC_NAME   pnameAdmin;

    //
    //  verify names in SOA record
    //

    if ( ! DNS_IS_NAME_IN_RECORD(pRpcRR, pnamePrimary) )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }
    pnameAdmin = DNS_GET_NEXT_NAME(pnamePrimary);
    if ( ! DNS_IS_NAME_IN_RECORD(pRpcRR, pnameAdmin) )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_SOA_DATA )
                + STR_BUF_SIZE_GIVEN_UTF8_LEN( pnamePrimary->cchNameLength, CharSet )
                + STR_BUF_SIZE_GIVEN_UTF8_LEN( pnameAdmin->cchNameLength, CharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return NULL;
    }

    //
    //  copy fixed fields
    //

    RtlCopyMemory(
        (PCHAR) & precord->Data.SOA.dwSerialNo,
        (PCHAR) & pRpcRR->Data.SOA.dwSerialNo,
        SIZEOF_SOA_FIXED_DATA );

    //
    //  copy names into RR buffer
    //      - primary server immediately follows SOA data struct
    //      - responsible party follows primary server
    //

    precord->Data.SOA.pNamePrimaryServer = (PCHAR)&precord->Data
                                            + sizeof(DNS_SOA_DATA);
    dwLength  =
        COPY_UTF8_STR_TO_BUFFER(
            precord->Data.SOA.pNamePrimaryServer,
            pnamePrimary->achName,
            (DWORD)pnamePrimary->cchNameLength,
            CharSet );
    precord->Data.SOA.pNameAdministrator = precord->Data.SOA.pNamePrimaryServer + dwLength;

    COPY_UTF8_STR_TO_BUFFER(
        precord->Data.SOA.pNameAdministrator,
        pnameAdmin->achName,
        (DWORD)pnameAdmin->cchNameLength,
        CharSet );

    return precord;
}



PDNS_RECORD
TxtRpcRecordConvert(
    IN      PDNS_RPC_RECORD pRpcRR,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Read TXT compatible record from wire.
    Includes: TXT, X25, HINFO, ISDN

Arguments:

    pRpcRR - message being read

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;
    DWORD           bufLength = 0;
    DWORD           length = 0;
    INT             count = 0;
    PCHAR           pch;
    PCHAR           pchend;
    PCHAR           pchbuffer;
    PCHAR *         ppstring;
    PDNS_RPC_NAME   pname = &pRpcRR->Data.TXT.stringData;

    //
    //  determine required buffer length and allocate
    //      - allocate space for each string
    //      - and ptr for each string
    //

    pch = (PCHAR)&pRpcRR->Data.TXT;
    pchend = pch + pRpcRR->wDataLength;

    while ( pch < pchend )
    {
        length = (UCHAR) *pch++;
        pch += length;
        count++;
        bufLength += STR_BUF_SIZE_GIVEN_UTF8_LEN( length, CharSet );
    }
    if ( pch != pchend )
    {
        DNS_PRINT((
            "ERROR:  Invalid RPCstring data\n"
            "    pch = %p\n"
            "    pchEnd = %p\n"
            "    count = %d\n"
            "    length = %d\n",
            pch, pchend, count, length ));
        SetLastError( ERROR_INVALID_DATA );
        return NULL;
    }

    //  allocate

    bufLength += (WORD) DNS_TEXT_RECORD_LENGTH(count);
    precord = Dns_AllocateRecord( (WORD)bufLength );
    if ( !precord )
    {
        return NULL;
    }
    precord->Data.TXT.dwStringCount = count;

    //
    //  go back through list copying strings to buffer
    //      - ptrs to strings are saved to argv like data section
    //          ppstring walks through this section
    //      - first string written immediately following data section
    //      - each subsequent string immediately follows predecessor
    //          pchbuffer keeps ptr to position to write strings
    //

    pch = (PCHAR)&pRpcRR->Data.TXT;
    ppstring = precord->Data.TXT.pStringArray;
    pchbuffer = (PCHAR)ppstring + (count * sizeof(PCHAR));

    while ( pch < pchend )
    {
        length = (DWORD)((UCHAR) *pch++);
        *ppstring++ = pchbuffer;

        pchbuffer += COPY_UTF8_STR_TO_BUFFER(
                        pchbuffer,
                        pch,
                        length,
                        CharSet );
        pch += length;
#if DBG
        DNS_PRINT((
            "Read text string %s\n",
            * (ppstring - 1)
            ));
        count--;
#endif
    }
    DNS_ASSERT( pch == pchend && count == 0 );

    return precord;
}



PDNS_RECORD
MinfoRpcRecordConvert(
    IN      PDNS_RPC_RECORD pRpcRR,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Read MINFO record from wire.

Arguments:

    pRpcRR - message being read

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;
    WORD            bufLength;
    DWORD           dwLength;
    PDNS_RPC_NAME   pname1 = &pRpcRR->Data.MINFO.nameMailBox;
    PDNS_RPC_NAME   pname2;

    //
    //  verify names in MINFO record
    //

    if ( ! DNS_IS_NAME_IN_RECORD(pRpcRR, pname1) )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }
    pname2 = DNS_GET_NEXT_NAME(pname1);
    if ( ! DNS_IS_NAME_IN_RECORD(pRpcRR, pname2) )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = (WORD)
                ( sizeof( DNS_MINFO_DATA )
                + STR_BUF_SIZE_GIVEN_UTF8_LEN( pname1->cchNameLength, CharSet )
                + STR_BUF_SIZE_GIVEN_UTF8_LEN( pname2->cchNameLength, CharSet ) );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return NULL;
    }

    //
    //  copy names into RR buffer
    //      - mailbox immediately follows MINFO data struct
    //      - errors mailbox immediately follows primary server
    //

    precord->Data.MINFO.pNameMailbox
                    = (PCHAR)&precord->Data + sizeof( DNS_MINFO_DATA );

    dwLength =
        COPY_UTF8_STR_TO_BUFFER(
            precord->Data.MINFO.pNameMailbox,
            pname1->achName,
            (DWORD)pname1->cchNameLength,
            CharSet );
    precord->Data.MINFO.pNameErrorsMailbox = precord->Data.MINFO.pNameMailbox + dwLength;

    COPY_UTF8_STR_TO_BUFFER(
        precord->Data.MINFO.pNameErrorsMailbox,
        pname2->achName,
        (DWORD)pname2->cchNameLength,
        CharSet );

    return precord;
}



PDNS_RECORD
MxRpcRecordConvert(
    IN      PDNS_RPC_RECORD pRpcRR,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Read MX compatible record from wire.
    Includes: MX, RT, AFSDB

Arguments:

    pRpcRR - message being read

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;
    PDNS_RPC_NAME   pname = &pRpcRR->Data.MX.nameExchange;
    WORD            bufLength;

    //
    //  MX exchange is another DNS name
    //

    if ( ! DNS_IS_NAME_IN_RECORD(pRpcRR, pname) )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_MX_DATA )
                + STR_BUF_SIZE_GIVEN_UTF8_LEN( pname->cchNameLength, CharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return NULL;
    }

    //
    //  copy preference
    //

    precord->Data.MX.wPreference = pRpcRR->Data.MX.wPreference;

    //
    //  write hostname into buffer, immediately following MX struct
    //

    precord->Data.MX.pNameExchange = (PCHAR)&precord->Data + sizeof( DNS_MX_DATA );

    COPY_UTF8_STR_TO_BUFFER(
        precord->Data.MX.pNameExchange,
        pname->achName,
        pname->cchNameLength,
        CharSet );

    return precord;
}



PDNS_RECORD
FlatRpcRecordConvert(
    IN      PDNS_RPC_RECORD pRpcRR,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Read memory copy compatible record from wire.
    Includes AAAA and WINS types.

Arguments:

    pRpcRR - message being read

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD precord;
    WORD        bufLength;

    //
    //  determine required buffer length and allocate
    //

    bufLength = pRpcRR->wDataLength;

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return NULL;
    }

    //
    //  copy packet data to record
    //

    RtlCopyMemory(
        & precord->Data,
        (PCHAR) &pRpcRR->Data.A,
        bufLength );

    return precord;
}



PDNS_RECORD
SrvRpcRecordConvert(
    IN      PDNS_RPC_RECORD pRpcRR,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Read SRV record from wire.

Arguments:

    pRpcRR - message being read

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;
    PDNS_RPC_NAME   pname = &pRpcRR->Data.SRV.nameTarget;
    WORD            bufLength;

    //
    //  SRV target host is another DNS name
    //

    if ( ! DNS_IS_NAME_IN_RECORD(pRpcRR, pname) )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_SRV_DATA )
                + STR_BUF_SIZE_GIVEN_UTF8_LEN( pname->cchNameLength, CharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return NULL;
    }

    //
    //  copy SRV fixed fields
    //

    precord->Data.SRV.wPriority = pRpcRR->Data.SRV.wPriority;
    precord->Data.SRV.wWeight = pRpcRR->Data.SRV.wWeight;
    precord->Data.SRV.wPort = pRpcRR->Data.SRV.wPort;

    //
    //  write hostname into buffer, immediately following SRV struct
    //

    precord->Data.SRV.pNameTarget = (PCHAR)&precord->Data + sizeof( DNS_SRV_DATA );

    COPY_UTF8_STR_TO_BUFFER(
        precord->Data.SRV.pNameTarget,
        pname->achName,
        pname->cchNameLength,
        CharSet );

    return precord;
}



PDNS_RECORD
NbstatRpcRecordConvert(
    IN      PDNS_RPC_RECORD pRpcRR,
    IN      DNS_CHARSET     CharSet
    )
/*++

Routine Description:

    Read WINSR record from wire.

Arguments:

    pRpcRR - message being read

Return Value:

    Ptr to new record if successful.
    NULL on failure.

--*/
{
    PDNS_RECORD     precord;
    PDNS_RPC_NAME   pname = &pRpcRR->Data.WINSR.nameResultDomain;
    WORD            bufLength;

    //
    //  WINSR target host is another DNS name
    //

    if ( ! DNS_IS_NAME_IN_RECORD(pRpcRR, pname) )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }

    //
    //  determine required buffer length and allocate
    //

    bufLength = sizeof( DNS_WINSR_DATA )
                + STR_BUF_SIZE_GIVEN_UTF8_LEN( pname->cchNameLength, CharSet );

    precord = Dns_AllocateRecord( bufLength );
    if ( !precord )
    {
        return NULL;
    }

    //
    //  copy WINSR fixed fields
    //

    precord->Data.WINSR.dwMappingFlag = pRpcRR->Data.WINSR.dwMappingFlag;
    precord->Data.WINSR.dwLookupTimeout = pRpcRR->Data.WINSR.dwLookupTimeout;
    precord->Data.WINSR.dwCacheTimeout = pRpcRR->Data.WINSR.dwCacheTimeout;

    //
    //  write hostname into buffer, immediately following WINSR struct
    //

    precord->Data.WINSR.pNameResultDomain
                        = (PCHAR)&precord->Data + sizeof( DNS_WINSR_DATA );
    COPY_UTF8_STR_TO_BUFFER(
        precord->Data.WINSR.pNameResultDomain,
        pname->achName,
        pname->cchNameLength,
        CharSet );

    return precord;
}



//
//  RR conversion from RPC buffer to DNS_RECORD
//

typedef PDNS_RECORD (* RR_CONVERT_FUNCTION)( PDNS_RPC_RECORD, DNS_CHARSET );

RR_CONVERT_FUNCTION   RRRpcConvertTable[] =
{
    NULL,                       //  ZERO
    ARpcRecordConvert,          //  A
    PtrRpcRecordConvert,        //  NS
    PtrRpcRecordConvert,        //  MD
    PtrRpcRecordConvert,        //  MF
    PtrRpcRecordConvert,        //  CNAME
    SoaRpcRecordConvert,        //  SOA
    PtrRpcRecordConvert,        //  MB
    PtrRpcRecordConvert,        //  MG
    PtrRpcRecordConvert,        //  MR
    NULL,                       //  NULL
    FlatRpcRecordConvert,       //  WKS
    PtrRpcRecordConvert,        //  PTR
    TxtRpcRecordConvert,        //  HINFO
    MinfoRpcRecordConvert,      //  MINFO
    MxRpcRecordConvert,         //  MX
    TxtRpcRecordConvert,        //  TXT
    MinfoRpcRecordConvert,      //  RP
    MxRpcRecordConvert,         //  AFSDB
    TxtRpcRecordConvert,        //  X25
    TxtRpcRecordConvert,        //  ISDN
    MxRpcRecordConvert,         //  RT
    NULL,                       //  NSAP
    NULL,                       //  NSAPPTR
    NULL,                       //  SIG
    NULL,                       //  KEY
    NULL,                       //  PX
    NULL,                       //  GPOS
    FlatRpcRecordConvert,       //  AAAA
    NULL,                       //  29
    NULL,                       //  30
    NULL,                       //  31
    NULL,                       //  32
    SrvRpcRecordConvert,        //  SRV
    NULL,                       //  ATMA
    NULL,                       //  35
    NULL,                       //  36
    NULL,                       //  37
    NULL,                       //  38
    NULL,                       //  39
    NULL,                       //  40
    NULL,                       //  OPT
    NULL,                       //  42
    NULL,                       //  43
    NULL,                       //  44
    NULL,                       //  45
    NULL,                       //  46
    NULL,                       //  47
    NULL,                       //  48

    //
    //  NOTE:  last type indexed by type ID MUST be set
    //         as MAX_SELF_INDEXED_TYPE #define in record.h
    //         (see note above in record info table)

    //  note these follow, but require OFFSET_TO_WINS_RR subtraction
    //  from actual type value

    NULL,                       //  TKEY
    NULL,                       //  TSIG
    FlatRpcRecordConvert,       //  WINS
    NbstatRpcRecordConvert      //  WINS-R
};



//
//  API for doing conversion
//

PDNS_RECORD
DnsConvertRpcBufferToRecords(
    IN      PBYTE *         ppByte,
    IN      PBYTE           pStopByte,
    IN      DWORD           cRecords,
    IN      PDNS_NAME       pszNodeName,
    IN      BOOLEAN         fUnicode
    )
/*++

Routine Description:

    Convert RPC buffer records to standard DNS records.

Arguments:

    ppByte -- addr of ptr into buffer where records start

    pStopByte -- stop byte of buffer

    cRecords -- number of records to convert

    pszNodeName -- node name (in desired format, not converted)

    fUnicode -- flag, write records into unicode

Return Value:

    Ptr to new record(s) if successful.
    NULL on failure.

--*/
{
    PDNS_RPC_RECORD prpcRecord = (PDNS_RPC_RECORD)*ppByte;
    PDNS_RECORD     precord;
    DNS_RRSET       rrset;
    WORD            index;
    WORD            type;
    DNS_CHARSET     charSet;
    RR_CONVERT_FUNCTION pFunc;

    DNS_ASSERT( DNS_IS_DWORD_ALIGNED(prpcRecord) );
    IF_DNSDBG( RPC2 )
    {
        DNS_PRINT((
            "Enter DnsConvertRpcBufferToRecords()\n"
            "    pRpcRecord   = %p\n"
            "    Count        = %d\n"
            "    Nodename     = %s%S\n",
            prpcRecord,
            cRecords,
            DNSSTRING_UTF8( fUnicode, pszNodeName ),
            DNSSTRING_WIDE( fUnicode, pszNodeName ) ));
    }

    DNS_RRSET_INIT( rrset );

    //
    //  loop until out of nodes
    //

    while( cRecords-- )
    {
        if ( (PBYTE)prpcRecord >= pStopByte ||
            (PBYTE)&prpcRecord->Data + prpcRecord->wDataLength > pStopByte )
        {
            DNS_PRINT((
                "ERROR:  Bogus buffer at %p\n"
                "    Record leads past buffer end at %p\n"
                "    with %d records remaining\n",
                prpcRecord,
                pStopByte,
                cRecords+1 ));
            DNS_ASSERT( FALSE );
            return NULL;
        }

        //
        //  convert record
        //      set unicode flag if converting
        //

        charSet = DnsCharSetUtf8;
        if ( fUnicode )
        {
            charSet = DnsCharSetUnicode;
        }

        type = prpcRecord->wType;
        index = INDEX_FOR_TYPE( type );
        DNS_ASSERT( index <= MAX_RECORD_TYPE_INDEX );

        if ( !index || !(pFunc = RRRpcConvertTable[ index ]) )
        {
            //  if unknown type try flat record copy -- best we can
            //  do to protect if server added new types since admin built

            DNS_PRINT((
                "ERROR:  no RPC to DNS_RECORD conversion routine for type %d\n"
                "    using flat conversion routine\n",
                type ));
            pFunc = FlatRpcRecordConvert;
        }

        precord = (*pFunc)( prpcRecord, charSet );
        if ( ! precord )
        {
            DNS_PRINT((
                "ERROR:  Record build routine failure for record type %d\n"
                "    status = %p\n\n",
                type,
                GetLastError() ));

            prpcRecord = DNS_GET_NEXT_RPC_RECORD(prpcRecord);
            continue;
        }

        //
        //  fill out record structure
        //

        precord->pName = pszNodeName;
        precord->wType = type;
        RECORD_CHARSET( precord ) = charSet;

        //
        //  DEVNOTE: data types (root hint, glue set)
        //

        if ( prpcRecord->dwFlags & DNS_RPC_RECORD_FLAG_CACHE_DATA )
        {
            precord->Flags.S.Section = DNSREC_CACHE_DATA;
        }
        else
        {
            precord->Flags.S.Section = DNSREC_ZONE_DATA;
        }

        IF_DNSDBG( INIT )
        {
            DnsDbg_Record(
                "New record built\n",
                precord );
        }

        //
        //  link into RR set
        //

        DNS_RRSET_ADD( rrset, precord );

        prpcRecord = DNS_GET_NEXT_RPC_RECORD(prpcRecord);
    }

    IF_DNSDBG( RPC2 )
    {
        DnsDbg_RecordSet(
            "Finished DnsConvertRpcBufferToRecords() ",
            rrset.pFirstRR );
    }

    //  reset ptr in buffer

    *ppByte = (PBYTE) prpcRecord;

    return rrset.pFirstRR;
}



PDNS_NODE
DnsConvertRpcBufferNode(
    IN      PDNS_RPC_NODE   pRpcNode,
    IN      PBYTE           pStopByte,
    IN      BOOLEAN         fUnicode
    )
/*++

Routine Description:

    Convert RPC buffer records to standard DNS records.

Arguments:

    pRpcNode -- ptr to RPC node in buffer

    pStopByte -- stop byte of buffer

    fUnicode -- flag, write records into unicode

Return Value:

    Ptr to new node if successful.
    NULL on failure.

--*/
{
    PDNS_NODE       pnode;
    PDNS_RPC_NAME   pname;
    PBYTE           pendNode;


    IF_DNSDBG( RPC2 )
    {
        DnsDbg_RpcNode(
            "Enter DnsConvertRpcBufferNode() ",
            pRpcNode );
    }

    //
    //  validate node
    //

    DNS_ASSERT( DNS_IS_DWORD_ALIGNED(pRpcNode) );
    pendNode = (PBYTE)pRpcNode + pRpcNode->wLength;
    if ( pendNode > pStopByte )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }
    pname = &pRpcNode->dnsNodeName;
    if ( (PBYTE)DNS_GET_NEXT_NAME(pname) > pendNode )
    {
        DNS_ASSERT( FALSE );
        return NULL;
    }

    //
    //  create node
    //

    pnode = (PDNS_NODE) ALLOCATE_HEAP( sizeof(DNS_NODE)
                    + STR_BUF_SIZE_GIVEN_UTF8_LEN( pname->cchNameLength, fUnicode ) );
    if ( !pnode )
    {
        return NULL;
    }
    pnode->pNext = NULL;
    pnode->pRecord = NULL;
    pnode->Flags.W = 0;

    //
    //  copy owner name, starts directly after node structure
    //

    pnode->pName = (PWCHAR) ((PBYTE)pnode + sizeof(DNS_NODE));

    if ( ! Dns_StringCopy(
                (PCHAR) pnode->pName,
                NULL,
                pname->achName,
                pname->cchNameLength,
                DnsCharSetUtf8,         // UTF8 in
                fUnicode ? DnsCharSetUnicode : DnsCharSetUtf8 ) )
    {
        //  name conversion error
        DNS_ASSERT( FALSE );
        FREE_HEAP( pnode );
        return NULL;
    }
    IF_DNSDBG( RPC2 )
    {
        DnsDbg_RpcName(
            "Node name in RPC buffer: ",
            pname,
            "\n" );
        DnsDbg_String(
            "Converted name ",
            (PCHAR) pnode->pName,
            fUnicode,
            "\n" );
    }

    //
    //  set flags
    //      - name always internal
    //      - catch domain roots
    //

    pnode->Flags.S.Unicode = fUnicode;

    if ( pRpcNode->dwChildCount ||
        (pRpcNode->dwFlags & DNS_RPC_NODE_FLAG_STICKY) )
    {
        pnode->Flags.S.Domain = TRUE;
    }

    IF_DNSDBG( RPC2 )
    {
        DnsDbg_Node(
            "Finished DnsConvertRpcBufferNode() ",
            pnode,
            TRUE );         //  view the records
    }
    return pnode;
}



PDNS_NODE
DnsConvertRpcBuffer(
    OUT     PDNS_NODE *     ppNodeLast,
    IN      DWORD           dwBufferLength,
    IN      BYTE            abBuffer[],
    IN      BOOLEAN         fUnicode
    )
{
    PBYTE       pbyte;
    PBYTE       pstopByte;
    INT         countRecords;
    PDNS_NODE   pnode;
    PDNS_NODE   pnodeFirst = NULL;
    PDNS_NODE   pnodeLast = NULL;
    PDNS_RECORD precord;

    IF_DNSDBG( RPC2 )
    {
        DNS_PRINT((
            "DnsConvertRpcBuffer( %p ), len = %d\n",
            abBuffer,
            dwBufferLength ));
    }

    //
    //  find stop byte
    //

    DNS_ASSERT( DNS_IS_DWORD_ALIGNED(abBuffer) );

    pstopByte = abBuffer + dwBufferLength;
    pbyte = abBuffer;

    //
    //  loop until out of nodes
    //

    while( pbyte < pstopByte )
    {
        //
        //  build owner node
        //      - only build complete nodes
        //      - add to list
        //

        if ( !IS_COMPLETE_NODE( (PDNS_RPC_NODE)pbyte ) )
        {
            break;
        }
        pnode = DnsConvertRpcBufferNode(
                    (PDNS_RPC_NODE)pbyte,
                    pstopByte,
                    fUnicode );
        if ( !pnode )
        {
            DNS_ASSERT( FALSE );
            //  DEVNOTE: cleanup
            return NULL;
        }
        if ( !pnodeFirst )
        {
            pnodeFirst = pnode;
            pnodeLast = pnode;
        }
        else
        {
            pnodeLast->pNext = pnode;
            pnodeLast = pnode;
        }

        countRecords = ((PDNS_RPC_NODE)pbyte)->wRecordCount;
        pbyte += ((PDNS_RPC_NODE)pbyte)->wLength;
        pbyte = DNS_NEXT_DWORD_PTR(pbyte);

        //
        //  for each node, build all records
        //

        if ( countRecords )
        {
            precord = DnsConvertRpcBufferToRecords(
                            & pbyte,
                            pstopByte,
                            countRecords,
                            (PCHAR) pnode->pName,
                            fUnicode );
            if ( !precord )
            {
                DNS_ASSERT( FALSE );
            }
            pnode->pRecord = precord;
        }
    }

    //  set last node and return first node

    *ppNodeLast = pnodeLast;

    return pnodeFirst;
}

//
//  End rconvert.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\client\remote.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    remote.c

Abstract:

    Domain Name System (DNS) Server -- Admin Client API

    Remote API that are not direct calls to RPC stubs.

Author:

    Jim Gilroy (jamesg)     April 1997

Environment:

    User Mode - Win32

Revision History:

--*/


#include "dnsclip.h"

#include <ntdsapi.h>
#include <dsgetdc.h>
#include <lmapibuf.h>


//
//  Error indicating talking to old server
//

#define DNS_ERROR_NT4   RPC_S_UNKNOWN_IF


//
//  Macro to set up RPC structure header fields.
//  
//  Sample:
//      DNS_RPC_FORWARDERS  forwarders;
//      INITIALIZE_RPC_STRUCT( FORWARDERS, forwarders );
//

#define INITIALIZE_RPC_STRUCT( rpcStructType, rpcStruct )           \
    * ( DWORD * ) &( rpcStruct ) =                                  \
        DNS_RPC_## rpcStructType ##_VER;                            \
    * ( ( ( DWORD * ) &( rpcStruct ) ) + 1 ) = 0;

//
//  DNS_VERBOSE_ macros
//

#define DNS_DBG( _Level, _PrintArgs )                               \
    if ( _Level >= dwVerbose )                                      \
    {                                                               \
        printf _PrintArgs;                                          \
    }




//
//  General Server\Zone, Query\Operation for DWORD properties
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvQueryDwordPropertyEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone,
    IN      LPCSTR          pszProperty,
    OUT     PDWORD          pdwResult
    )
{
    DNS_STATUS  status;
    DWORD       typeId;

    DNSDBG( STUB, (
        "Enter DnssrvQueryDwordProperty()\n"
        "    Client ver   = 0x%X\n"
        "    Server       = %s\n"
        "    ZoneName     = %s\n"
        "    Property     = %s\n"
        "    pResult      = %p\n",
        dwClientVersion,
        Server,
        pszZone,
        pszProperty,
        pdwResult ));

    status = DnssrvComplexOperationEx(
                dwClientVersion,
                dwSettingFlags,
                Server,
                pszZone,
                DNSSRV_QUERY_DWORD_PROPERTY,
                DNSSRV_TYPEID_LPSTR,        //  property name as string
                (LPSTR) pszProperty,
                & typeId,                   //  DWORD property value back out
                (PVOID *) pdwResult );

    DNSDBG( STUB, (
        "Leave DnssrvQueryDwordProperty():  status %d (%p)\n"
        "    Server       = %s\n"
        "    ZoneName     = %s\n"
        "    Property     = %s\n"
        "    TypeId       = %d\n"
        "    Result       = %d (%p)\n",
        status, status,
        Server,
        pszZone,
        pszProperty,
        typeId,
        *pdwResult, *pdwResult ));

    ASSERT(
        (status == ERROR_SUCCESS && typeId == DNSSRV_TYPEID_DWORD) ||
        (status != ERROR_SUCCESS && *pdwResult == 0 ) );

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResetDwordPropertyEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone,
    IN      DWORD           dwContext,
    IN      LPCSTR          pszProperty,
    IN      DWORD           dwPropertyValue
    )
{
    DNS_STATUS  status;
    DNS_RPC_NAME_AND_PARAM  param;

    param.dwParam = dwPropertyValue;
    param.pszNodeName = (LPSTR) pszProperty;

    DNSDBG( STUB, (
        "Enter DnssrvResetDwordPropertyEx()\n"
        "    Client ver       = 0x%X\n"
        "    Server           = %S\n"
        "    ZoneName         = %s\n"
        "    Context          = %p\n"
        "    PropertyName     = %s\n"
        "    PropertyValue    = %d (%p)\n",
        dwClientVersion,
        Server,
        pszZone,
        dwContext,
        pszProperty,
        dwPropertyValue,
        dwPropertyValue ));

    status = DnssrvOperationEx(
                dwClientVersion,
                dwSettingFlags,
                Server,
                pszZone,
                dwContext,
                DNSSRV_OP_RESET_DWORD_PROPERTY,
                DNSSRV_TYPEID_NAME_AND_PARAM,
                &param );

    DNSDBG( STUB, (
        "Leaving DnssrvResetDwordPropertyEx():  status = %d (%p)\n",
        status, status ));

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResetStringPropertyEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         pwszServerName,
    IN      LPCSTR          pszZone,
    IN      DWORD           dwContext,
    IN      LPCSTR          pszProperty,
    IN      LPCWSTR         pswzPropertyValue,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Set a string property on the server. The property value is
    unicode.

Arguments:

    Server - server name

    pszZone - pointer to zone

    dwContext - context

    pszProperty - name of property to set

    pswzPropertyValue - unicode property value

    dwFlags - flags, may be combination of:
        DNSSRV_OP_PARAM_APPLY_ALL_ZONES

Return Value:

    None

--*/
{
    DNS_STATUS                      status;

    DNSDBG( STUB, (
        "Enter DnssrvResetStringPropertyEx()\n"
        "    Client ver       = 0x%X\n"
        "    Server           = %S\n"
        "    ZoneName         = %s\n"
        "    Context          = %p\n"
        "    PropertyName     = %s\n"
        "    PropertyValue    = %S\n",
        dwClientVersion,
        pwszServerName,
        pszZone,
        dwContext,
        pszProperty,
        pswzPropertyValue ));

    status = DnssrvOperationEx(
                dwClientVersion,
                dwSettingFlags,
                pwszServerName,
                pszZone,
                dwContext,
                pszProperty,
                DNSSRV_TYPEID_LPWSTR,
                ( PVOID ) pswzPropertyValue );

    DNSDBG( STUB, (
        "Leaving DnssrvResetDwordPropertyEx():  status = %d (%p)\n",
        status, status ));

    return status;
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResetIPListPropertyEx(
    IN      DWORD           dwClientVersion,
    IN      DWORD           dwSettingFlags,
    IN      LPCWSTR         pwszServerName,
    IN      LPCSTR          pszZone,
    IN      DWORD           dwContext,
    IN      LPCSTR          pszProperty,
    IN      PIP_ARRAY       pipArray,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Set an IP list property on the server. 

Arguments:

    Server - server name

    pszZone - pointer to zone

    dwContext - context

    pszProperty - name of property to set

    pipArray - new IP array property value

    dwFlags - flags, may be combination of:
        DNSSRV_OP_PARAM_APPLY_ALL_ZONES

Return Value:

    None

--*/
{
    DNS_STATUS                      status;

    DNSDBG( STUB, (
        "Enter DnssrvResetIPListPropertyEx()\n"
        "    Client ver       = 0x%X\n"
        "    Server           = %S\n"
        "    ZoneName         = %s\n"
        "    Context          = %p\n"
        "    PropertyName     = %s\n"
        "    pipArray         = %p\n",
        dwClientVersion,
        pwszServerName,
        pszZone,
        dwContext,
        pszProperty,
        pipArray ));

    DnsDbg_Ip4Array(
        "DnssrvResetIPListPropertyEx\n",
        NULL,
        pipArray );

    status = DnssrvOperationEx(
                dwClientVersion,
                dwSettingFlags,
                pwszServerName,
                pszZone,
                dwContext,
                pszProperty,
                DNSSRV_TYPEID_IPARRAY,
                ( pipArray && pipArray->AddrCount ) ?
                    pipArray :
                    NULL );

    DNSDBG( STUB, (
        "Leaving DnssrvResetIPListPropertyEx():  status = %d (%p)\n",
        status, status ));

    return status;
}   //  DnssrvResetIPListPropertyEx



//
//  Server Queries
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvGetServerInfo(
    IN      LPCWSTR                 Server,
    OUT     PDNS_RPC_SERVER_INFO *  ppServerInfo
    )
{
    DNS_STATUS  status;
    DWORD       typeId;

    status = DnssrvQuery(
                Server,
                NULL,
                DNSSRV_QUERY_SERVER_INFO,
                &typeId,
                ppServerInfo );
    ASSERT(
        (status == ERROR_SUCCESS && typeId == DNSSRV_TYPEID_SERVER_INFO) ||
        (status != ERROR_SUCCESS && *ppServerInfo == NULL ) );

    return( status );
}


DNS_STATUS
DNS_API_FUNCTION
DnssrvQueryZoneDwordProperty(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszProperty,
    OUT     PDWORD          pdwResult
    )
{
    DNS_STATUS  status;
    DWORD       typeId;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvQueryDwordProperty()\n"
            "    Server           = %s\n"
            "    pszProperty      = %s\n"
            "    pResult          = %p\n",
            Server,
            pszZoneName,
            pszProperty,
            pdwResult ));
    }

    status = DnssrvQuery(
                Server,
                pszZoneName,
                pszProperty,
                & typeId,
                (PVOID *) pdwResult );

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Leave DnssrvQueryZoneDwordProperty():  status %d (%p)\n"
            "    Server           = %s\n"
            "    pszProperty      = %s\n"
            "    TypeId           = %d\n"
            "    Result           = %d (%p)\n",
            status, status,
            Server,
            pszProperty,
            typeId,
            *pdwResult, *pdwResult ));

        ASSERT(
            (status == ERROR_SUCCESS && typeId == DNSSRV_TYPEID_DWORD) ||
            (status != ERROR_SUCCESS && *pdwResult == 0 ) );
    }
    return( status );
}



//
//  Server Operations
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetServerDwordProperty(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszProperty,
    IN      DWORD           dwPropertyValue
    )
{
    DNS_STATUS status;

    DNSDBG( STUB, (
        "Enter DnssrvResetServerDwordProperty()\n"
        "    Server           = %s\n"
        "    pszPropertyName  = %s\n"
        "    dwPropertyValue  = %p\n",
        Server,
        pszProperty,
        dwPropertyValue ));

    status = DnssrvOperation(
                Server,
                NULL,
                pszProperty,
                DNSSRV_TYPEID_DWORD,
                (PVOID) (DWORD_PTR) dwPropertyValue );

    DNSDBG( STUB, (
        "Leaving DnssrvResetServerDwordProperty:  status = %d (%p)\n",
        status, status ));

    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvCreateZoneEx(
    IN      LPCWSTR             Server,
    IN      LPCSTR              pszZoneName,
    IN      DWORD               dwZoneType,
    IN      DWORD               fAllowUpdate,
    IN      DWORD               dwCreateFlags,
    IN      LPCSTR              pszAdminEmailName,
    IN      DWORD               cMasters,
    IN      PIP_ADDRESS         aipMasters,
    IN      BOOL                bDsIntegrated,
    IN      LPCSTR              pszDataFile,
    IN      DWORD               dwTimeout,      //  for forwarder zones
    IN      DWORD               fSlave,         //  for forwarder zones
    IN      DWORD               dwDpFlags,      //  for directory partition
    IN      LPCSTR              pszDpFqdn       //  for directory partition
    )
{
    DNS_STATUS                  status;
    DNS_RPC_ZONE_CREATE_INFO    zoneInfo;
    PIP_ARRAY                   arrayIp = NULL;

    RtlZeroMemory(
        &zoneInfo,
        sizeof( DNS_RPC_ZONE_CREATE_INFO ) );

    INITIALIZE_RPC_STRUCT( ZONE_CREATE_INFO, zoneInfo );

    if ( cMasters && aipMasters )
    {
        arrayIp = Dns_BuildIpArray(
                    cMasters,
                    aipMasters );
        if ( !arrayIp && cMasters )
        {
            return( DNS_ERROR_NO_MEMORY );
        }
    }
    zoneInfo.pszZoneName    = (LPSTR) pszZoneName;
    zoneInfo.dwZoneType     = dwZoneType;
    zoneInfo.fAllowUpdate   = fAllowUpdate;
    zoneInfo.fAging         = 0;
    zoneInfo.dwFlags        = dwCreateFlags;
    zoneInfo.fDsIntegrated  = (DWORD) bDsIntegrated;
    //  temp backward compat
    zoneInfo.fLoadExisting  = !!(dwCreateFlags & DNS_ZONE_LOAD_EXISTING);
    zoneInfo.pszDataFile    = (LPSTR) pszDataFile;
    zoneInfo.pszAdmin       = (LPSTR) pszAdminEmailName;
    zoneInfo.aipMasters     = arrayIp;
    zoneInfo.dwTimeout      = dwTimeout;
    zoneInfo.fSlave         = fSlave;

    zoneInfo.dwDpFlags      = dwDpFlags;
    zoneInfo.pszDpFqdn      = ( LPSTR ) pszDpFqdn;

    status = DnssrvOperation(
                Server,
                NULL,                   // server operation
                DNSSRV_OP_ZONE_CREATE,
                DNSSRV_TYPEID_ZONE_CREATE,
                (PVOID) &zoneInfo
                );

    FREE_HEAP( arrayIp );
    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvCreateZone(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      DWORD           dwZoneType,
    IN      LPCSTR          pszAdminEmailName,
    IN      DWORD           cMasters,
    IN      PIP_ADDRESS     aipMasters,
    IN      DWORD           fLoadExisting,
    IN      DWORD           fDsIntegrated,
    IN      LPCSTR          pszDataFile,
    IN      DWORD           dwTimeout,
    IN      DWORD           fSlave
    )
{
    DWORD       flags = 0;
    DWORD       dpFlags = 0;

    if ( fLoadExisting )
    {
        flags = DNS_ZONE_LOAD_EXISTING;
    }

    return DnssrvCreateZoneEx(
                Server,
                pszZoneName,
                dwZoneType,
                0,                  // update unknown, send off
                flags,              // load flags
                pszAdminEmailName,
                cMasters,
                aipMasters,
                fDsIntegrated,
                pszDataFile,
                dwTimeout,
                fSlave,
                dpFlags,    //  dwDirPartFlag
                NULL        //  pszDirPartFqdn
                );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvCreateZoneForDcPromoEx(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszDataFile,
    IN      DWORD           dwFlags
    )
/*++

Routine Description:

    Create a zone during dcpromo. The DNS server will automagically move
    this zone to Active Directory when the directoy becomes available after
    reboot.

Arguments:

    Server -- server to send request to

    pszZoneName -- UTF-8 name of the new zone

    pszDataFile -- UTF-8 zone file name

    dwFlags -- zone creation flags, pass zero or one of:
                    DNS_ZONE_CREATE_FOR_DCPROMO
                    DNS_ZONE_CREATE_FOR_DCPROMO_FOREST

Return Value:

    None

--*/
{
    //
    //  By default the new zone must be a dcpromo zone so make sure that
    //  flag is turned on. For a new forest dcpromo zone both this flag
    //  and DNS_ZONE_CREATE_FOR_NEW_FOREST_DCPROMO should be set.
    //

    dwFlags |= DNS_ZONE_CREATE_FOR_DCPROMO;

    //
    //  Create the zone.
    //

    return DnssrvCreateZoneEx(
                Server,
                pszZoneName,
                1,          //  primary
                0,          //  update unknown, send off
                dwFlags,
                NULL,       //  no admin name
                0,          //  no masters
                NULL,
                FALSE,      //  not DS integrated
                pszDataFile,
                0,          //  timeout - for forwarder zones
                0,          //  slave - for forwarder zones
                0,          //  dwDirPartFlag
                NULL );     //  pszDirPartFqdn
}   //  DnssrvCreateZoneForDcPromoEx



DNS_STATUS
DNS_API_FUNCTION
DnssrvCreateZoneForDcPromo(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszDataFile
    )
{
    return DnssrvCreateZoneForDcPromoEx(
                Server,
                pszZoneName,
                pszDataFile,
                0 );        //  flags
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvCreateZoneInDirectoryPartition(
    IN      LPCWSTR             pwszServer,
    IN      LPCSTR              pszZoneName,
    IN      DWORD               dwZoneType,
    IN      LPCSTR              pszAdminEmailName,
    IN      DWORD               cMasters,
    IN      PIP_ADDRESS         aipMasters,
    IN      DWORD               fLoadExisting,
    IN      DWORD               dwTimeout,
    IN      DWORD               fSlave,
    IN      DWORD               dwDirPartFlags,
    IN      LPCSTR              pszDirPartFqdn
    )
{
    DWORD   dwFlags = 0;

    if ( fLoadExisting )
    {
        dwFlags = DNS_ZONE_LOAD_EXISTING;
    }

    return DnssrvCreateZoneEx(
                pwszServer,
                pszZoneName,
                dwZoneType,
                0,                      //  allow update
                dwFlags,
                pszAdminEmailName,
                cMasters,               //  masters count
                aipMasters,             //  masters array
                TRUE,                   //  DS integrated
                NULL,                   //  data file
                dwTimeout,              //  for forwarder zones
                fSlave,                 //  for forwarder zones
                dwDirPartFlags,
                pszDirPartFqdn );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvClearStatistics(
    IN      LPCWSTR         Server
    )
{
    DNS_STATUS  status;

    status = DnssrvOperation(
                Server,
                NULL,
                DNSSRV_OP_CLEAR_STATISTICS,
                DNSSRV_TYPEID_NULL,
                (PVOID) NULL
                );
    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResetServerListenAddresses(
    IN      LPCWSTR         Server,
    IN      DWORD           cListenAddrs,
    IN      PIP_ADDRESS     aipListenAddrs
    )
{
    DNS_STATUS  status;
    PIP_ARRAY   arrayIp;

    arrayIp = Dns_BuildIpArray(
                    cListenAddrs,
                    aipListenAddrs );
    if ( !arrayIp && cListenAddrs )
    {
        return( DNS_ERROR_NO_MEMORY );
    }

    status = DnssrvOperation(
                Server,
                NULL,
                DNS_REGKEY_LISTEN_ADDRESSES,
                DNSSRV_TYPEID_IPARRAY,
                (PVOID) arrayIp
                );

    FREE_HEAP( arrayIp );
    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResetForwarders(
    IN      LPCWSTR         Server,
    IN      DWORD           cForwarders,
    IN      PIP_ADDRESS     aipForwarders,
    IN      DWORD           dwForwardTimeout,
    IN      DWORD           fSlave
    )
{
    DNS_STATUS          status;
    DNS_RPC_FORWARDERS  forwarders;
    PIP_ARRAY           arrayIp;

    INITIALIZE_RPC_STRUCT( FORWARDERS, forwarders );

    arrayIp = Dns_BuildIpArray(
                cForwarders,
                aipForwarders );
    if ( !arrayIp && cForwarders )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    forwarders.fSlave = fSlave;
    forwarders.dwForwardTimeout = dwForwardTimeout;
    forwarders.aipForwarders = arrayIp;

    status = DnssrvOperation(
                Server,
                NULL,
                DNS_REGKEY_FORWARDERS,
                DNSSRV_TYPEID_FORWARDERS,
                (PVOID) &forwarders
                );

    FREE_HEAP( arrayIp );
    return( status );
}



//
//  Zone Queries
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvGetZoneInfo(
    IN      LPCWSTR                 Server,
    IN      LPCSTR                  pszZone,
    OUT     PDNS_RPC_ZONE_INFO *    ppZoneInfo
    )
{
    DNS_STATUS  status;
    DWORD       typeId;

    status = DnssrvQuery(
                Server,
                pszZone,
                DNSSRV_QUERY_ZONE_INFO,
                & typeId,
                ppZoneInfo
                );
    ASSERT(
        (status == ERROR_SUCCESS && typeId == DNSSRV_TYPEID_ZONE_INFO) ||
        (status != ERROR_SUCCESS && *ppZoneInfo == NULL ) );

    return( status );
}



//
//  Zone Operations
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneTypeEx(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      DWORD           dwZoneType,
    IN      DWORD           cMasters,
    IN      PIP_ADDRESS     aipMasters,
    IN      DWORD           dwLoadOptions,
    IN      DWORD           fDsIntegrated,
    IN      LPCSTR          pszDataFile,
    IN      DWORD           dwDpFlags,
    IN      LPCSTR          pszDpFqdn
    )
{
    DNS_STATUS                  status;
    DNS_RPC_ZONE_CREATE_INFO    zoneInfo;
    PIP_ARRAY                   arrayIp = NULL;

    RtlZeroMemory(
        &zoneInfo,
        sizeof( DNS_RPC_ZONE_CREATE_INFO ) );

    INITIALIZE_RPC_STRUCT( ZONE_CREATE_INFO, zoneInfo );

    if ( cMasters )
    {
        arrayIp = Dns_BuildIpArray(
                    cMasters,
                    aipMasters );
        if ( !arrayIp )
        {
            return( DNS_ERROR_NO_MEMORY );
        }
    }

    zoneInfo.pszZoneName        = ( LPSTR ) pszZoneName;
    zoneInfo.dwZoneType         = dwZoneType;
    zoneInfo.fDsIntegrated      = fDsIntegrated;
    zoneInfo.fLoadExisting      = dwLoadOptions;
    zoneInfo.pszDataFile        = ( LPSTR ) pszDataFile;
    zoneInfo.pszAdmin           = NULL;
    zoneInfo.aipMasters         = arrayIp;
    zoneInfo.dwDpFlags          = dwDpFlags;
    zoneInfo.pszDpFqdn          = ( LPSTR ) pszDpFqdn;

    status = DnssrvOperation(
                Server,
                pszZoneName,
                DNSSRV_OP_ZONE_TYPE_RESET,
                DNSSRV_TYPEID_ZONE_CREATE,
                ( PVOID ) &zoneInfo );

    FREE_HEAP( arrayIp );

    return status;
}


DNS_STATUS
DNS_API_FUNCTION
DnssrvRenameZone(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszCurrentZoneName,
    IN      LPCSTR          pszNewZoneName,
    IN      LPCSTR          pszNewFileName
    )
{
    DNS_STATUS                  status;
    DNS_RPC_ZONE_RENAME_INFO    renameInfo;

    RtlZeroMemory(
        &renameInfo,
        sizeof( DNS_RPC_ZONE_RENAME_INFO ) );

    INITIALIZE_RPC_STRUCT( ZONE_RENAME_INFO, renameInfo );

    renameInfo.pszNewZoneName = ( LPSTR ) pszNewZoneName;
    renameInfo.pszNewFileName = ( LPSTR ) pszNewFileName;

    status = DnssrvOperation(
                Server,
                pszCurrentZoneName,
                DNSSRV_OP_ZONE_RENAME,
                DNSSRV_TYPEID_ZONE_RENAME,
                ( PVOID ) &renameInfo );
    return status;
}


DNS_STATUS
DNS_API_FUNCTION
DnssrvChangeZoneDirectoryPartition(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszNewPartitionName
    )
{
    DNS_STATUS              status;
    DNS_RPC_ZONE_CHANGE_DP  rpcInfo;

    RtlZeroMemory(
        &rpcInfo,
        sizeof( DNS_RPC_ZONE_CHANGE_DP ) );

    INITIALIZE_RPC_STRUCT( ZONE_RENAME_INFO, rpcInfo );

    rpcInfo.pszDestPartition = ( LPSTR ) pszNewPartitionName;

    status = DnssrvOperation(
                Server,
                pszZoneName,
                DNSSRV_OP_ZONE_CHANGE_DP,
                DNSSRV_TYPEID_ZONE_CHANGE_DP,
                ( PVOID ) &rpcInfo );
    return status;
}


DNS_STATUS
DNS_API_FUNCTION
DnssrvExportZone(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszZoneExportFile
    )
{
    DNS_STATUS                  status;
    DNS_RPC_ZONE_EXPORT_INFO    info;

    RtlZeroMemory(
        &info,
        sizeof( DNS_RPC_ZONE_EXPORT_INFO ) );

    INITIALIZE_RPC_STRUCT( ZONE_EXPORT_INFO, info );

    info.pszZoneExportFile = ( LPSTR ) pszZoneExportFile;

    status = DnssrvOperation(
                Server,
                pszZoneName,
                DNSSRV_OP_ZONE_EXPORT,
                DNSSRV_TYPEID_ZONE_EXPORT,
                ( PVOID ) &info );

    return status;
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneMastersEx(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone,
    IN      DWORD           cMasters,
    IN      PIP_ADDRESS     aipMasters,
    IN      DWORD           fSetLocalMasters
    )
{
    DNS_STATUS              status;
    PIP_ARRAY               arrayIp;

    arrayIp = Dns_BuildIpArray(
                cMasters,
                aipMasters );
    if ( !arrayIp && cMasters )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    status = DnssrvOperation(
                Server,
                pszZone,
                fSetLocalMasters ?
                    DNS_REGKEY_ZONE_LOCAL_MASTERS :
                    DNS_REGKEY_ZONE_MASTERS,
                DNSSRV_TYPEID_IPARRAY,
                (PVOID) arrayIp );
    FREE_HEAP( arrayIp );
    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneMasters(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone,
    IN      DWORD           cMasters,
    IN      PIP_ADDRESS     aipMasters
    )
{
    DNS_STATUS              status;
    PIP_ARRAY               arrayIp;

    arrayIp = Dns_BuildIpArray(
                cMasters,
                aipMasters );
    if ( !arrayIp && cMasters )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    status = DnssrvOperation(
                Server,
                pszZone,
                DNS_REGKEY_ZONE_MASTERS,
                DNSSRV_TYPEID_IPARRAY,
                (PVOID) arrayIp
                );
    FREE_HEAP( arrayIp );
    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneSecondaries(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone,
    IN      DWORD           fSecureSecondaries,
    IN      DWORD           cSecondaries,
    IN      PIP_ADDRESS     aipSecondaries,
    IN      DWORD           fNotifyLevel,
    IN      DWORD           cNotify,
    IN      PIP_ADDRESS     aipNotify
    )
{
    DNS_STATUS                  status;
    DNS_RPC_ZONE_SECONDARIES    secondaryInfo;
    PIP_ARRAY                   arrayIp;

    INITIALIZE_RPC_STRUCT( ZONE_SECONDARIES, secondaryInfo );

    arrayIp = Dns_BuildIpArray(
                    cSecondaries,
                    aipSecondaries );
    if ( !arrayIp && cSecondaries )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    secondaryInfo.fSecureSecondaries = fSecureSecondaries;
    secondaryInfo.aipSecondaries = arrayIp;

    arrayIp = Dns_BuildIpArray(
                    cNotify,
                    aipNotify );
    if ( !arrayIp && cNotify )
    {
        return( DNS_ERROR_NO_MEMORY );
    }
    secondaryInfo.aipNotify = arrayIp;
    secondaryInfo.fNotifyLevel = fNotifyLevel;

    status = DnssrvOperation(
                Server,
                pszZone,
                DNS_REGKEY_ZONE_SECONDARIES,
                DNSSRV_TYPEID_ZONE_SECONDARIES,
                (PVOID) &secondaryInfo
                );

    FREE_HEAP( secondaryInfo.aipNotify );
    FREE_HEAP( secondaryInfo.aipSecondaries );
    return( status );
}



#if 0
DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneScavengeServers(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone,
    IN      DWORD           cServers,
    IN      PIP_ADDRESS     aipServers
    )
{
    DNS_STATUS  status;
    PIP_ARRAY   arrayIp;

    arrayIp = Dns_BuildIpArray(
                    cServers,
                    aipServers );
    if ( !arrayIp && cSecondaries )
    {
        return( DNS_ERROR_NO_MEMORY );
    }

    status = DnssrvOperation(
                Server,
                pszZone,
                DNS_REGKEY_ZONE_SCAVENGE_SERVERS,
                DNSSRV_TYPEID_IPARRAY,
                arrayIp
                );

    FREE_HEAP( arrayIp );
    return( status );
}
#endif



//
//  Zone management API
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvIncrementZoneVersion(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone
    )
{
    return DnssrvOperation(
                Server,
                pszZone,
                DNSSRV_OP_ZONE_INCREMENT_VERSION,
                DNSSRV_TYPEID_NULL,
                (PVOID) NULL
                );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteZone(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone
    )
{
    return DnssrvOperation(
                Server,
                pszZone,
                DNSSRV_OP_ZONE_DELETE,
                DNSSRV_TYPEID_NULL,
                (PVOID) NULL
                );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvPauseZone(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone
    )
{
    return DnssrvOperation(
                Server,
                pszZone,
                DNSSRV_OP_ZONE_PAUSE,
                DNSSRV_TYPEID_NULL,
                (PVOID) NULL
                );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResumeZone(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone
    )
{
    return DnssrvOperation(
                Server,
                pszZone,
                DNSSRV_OP_ZONE_RESUME,
                DNSSRV_TYPEID_NULL,
                (PVOID) NULL
                );
}



//
//  Record viewing API
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumRecordsAndConvertNodes(
    IN      LPCWSTR     pszServer,
    IN      LPCSTR      pszZoneName,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszStartChild,
    IN      WORD        wRecordType,
    IN      DWORD       dwSelectFlag,
    IN      LPCSTR      pszFilterStart,
    IN      LPCSTR      pszFilterStop,
    OUT     PDNS_NODE * ppNodeFirst,
    OUT     PDNS_NODE * ppNodeLast
    )
{
    DNS_STATUS  status;
    PDNS_NODE   pnode;
    PDNS_NODE   pnodeLast;
    PBYTE       pbuffer;
    DWORD       bufferLength;

    //
    //  get records from server
    //

    status = DnssrvEnumRecords(
                pszServer,
                pszZoneName,
                pszNodeName,
                pszStartChild,
                wRecordType,
                dwSelectFlag,
                pszFilterStart,
                pszFilterStop,
                & bufferLength,
                & pbuffer );

    if ( status != ERROR_SUCCESS && status != ERROR_MORE_DATA )
    {
        return( status );
    }

    //
    //  pull nodes and records out of RPC buffer
    //

    pnode = DnsConvertRpcBuffer(
                & pnodeLast,
                bufferLength,
                pbuffer,
                TRUE    // convert unicode
                );
    if ( !pnode )
    {
        DNS_PRINT((
            "ERROR:  failure converting RPC buffer to DNS records\n"
            "    status = %p\n",
            GetLastError() ));
        ASSERT( FALSE );
        return( ERROR_INVALID_DATA );
    }

    *ppNodeFirst = pnode;
    *ppNodeLast = pnodeLast;
    return( status );
}



//
//  Record management API
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteNode(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszNodeName,
    IN      BOOL            bDeleteSubtree
    )
{
    DNS_RPC_NAME_AND_PARAM  param;

    param.dwParam = (DWORD) bDeleteSubtree;
    param.pszNodeName = (LPSTR) pszNodeName;

    return DnssrvOperation(
                Server,
                pszZoneName,
                DNSSRV_OP_DELETE_NODE,
                DNSSRV_TYPEID_NAME_AND_PARAM,
                (PVOID) &param
                );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteRecordSet(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszNodeName,
    IN      WORD            wType
    )
{
    DNS_RPC_NAME_AND_PARAM  param;

    param.dwParam = (DWORD) wType;
    param.pszNodeName = (LPSTR) pszNodeName;

    return DnssrvOperation(
                Server,
                pszZoneName,
                DNSSRV_OP_DELETE_RECORD_SET,
                DNSSRV_TYPEID_NAME_AND_PARAM,
                (PVOID) &param
                );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvForceAging(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZoneName,
    IN      LPCSTR          pszNodeName,
    IN      BOOL            bAgeSubtree
    )
{
    DNS_RPC_NAME_AND_PARAM  param;

    param.dwParam = (DWORD) bAgeSubtree;
    param.pszNodeName = (LPSTR) pszNodeName;

    return DnssrvOperation(
                Server,
                pszZoneName,
                DNSSRV_OP_FORCE_AGING_ON_NODE,
                DNSSRV_TYPEID_NAME_AND_PARAM,
                (PVOID) &param
                );
}



//
//  Server API
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumZonesEx(
    IN      LPCWSTR                 Server,
    IN      DWORD                   dwFilter,
    IN      LPCSTR                  pszDirectoryPartitionFqdn,
    IN      LPCSTR                  pszQueryString,
    IN      LPCSTR                  pszLastZone,
    OUT     PDNS_RPC_ZONE_LIST *    ppZoneList
    )
{
    DNS_STATUS  status;
    DWORD       typeId;
    PDNS_RPC_ZONE_LIST  pzoneEnum = NULL;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvEnumZones()\n"
            "    Server       = %s\n"
            "    Filter       = 0x%08X\n"
            "    Partition    = %s\n"
            "    Query string = %s\n"
            "    LastZone     = %s\n"
            "    ppZoneList   = %p\n",
            Server,
            dwFilter,
            pszDirectoryPartitionFqdn,
            pszQueryString,
            pszLastZone,
            ppZoneList ));
    }

    if ( pszDirectoryPartitionFqdn || pszQueryString )
    {
        DNS_RPC_ENUM_ZONES_FILTER   ezfilter = { 0 };

        ezfilter.dwRpcStructureVersion = DNS_RPC_ENUM_ZONES_FILTER_VER;
        ezfilter.dwFilter = dwFilter;
        ezfilter.pszPartitionFqdn = ( LPSTR ) pszDirectoryPartitionFqdn;
        ezfilter.pszQueryString = ( LPSTR ) pszQueryString;

        status = DnssrvComplexOperation(
                    Server,
                    NULL,
                    DNSSRV_OP_ENUM_ZONES2,
                    DNSSRV_TYPEID_ENUM_ZONES_FILTER,
                    ( PVOID ) &ezfilter,
                    &typeId,
                    ( PVOID * ) &pzoneEnum );
    }
    else
    {
        status = DnssrvComplexOperation(
                    Server,
                    NULL,
                    DNSSRV_OP_ENUM_ZONES,
                    DNSSRV_TYPEID_DWORD,
                    ( PVOID ) ( DWORD_PTR ) dwFilter,
                    & typeId,
                    ( PVOID * ) &pzoneEnum );
    }

    if ( status != DNS_ERROR_NT4 )
    {
        ASSERT(
            ( status == ERROR_SUCCESS && typeId == DNSSRV_TYPEID_ZONE_LIST ) ||
            ( status != ERROR_SUCCESS && pzoneEnum == NULL ) );

        *ppZoneList = pzoneEnum;
    }
    return status;
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumDirectoryPartitions(
    IN      LPCWSTR                 Server,
    IN      DWORD                   dwFilter,
    OUT     PDNS_RPC_DP_LIST *      ppDpList
    )
{
    DNS_STATUS          status;
    PDNS_RPC_DP_LIST    pdpList = NULL;
    DWORD               dwtypeId;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvEnumDirectoryPartitions()\n"
            "\tServer       = %S\n"
            "\tppDpList     = %p\n",
            Server,
            ppDpList ));
    }

    status = DnssrvComplexOperation(
                Server,
                NULL,
                DNSSRV_OP_ENUM_DPS,
                DNSSRV_TYPEID_DWORD,
                ( PVOID ) ( DWORD_PTR ) dwFilter,
                &dwtypeId,
                ( PVOID * ) &pdpList );

    ASSERT( ( status == ERROR_SUCCESS &&
                dwtypeId == DNSSRV_TYPEID_DP_LIST ) ||
            ( status != ERROR_SUCCESS && pdpList == NULL ) );

    *ppDpList = pdpList;
    return status;
}   //  DnssrvEnumDirectoryPartitions



DNS_STATUS
DNS_API_FUNCTION
DnssrvEnlistDirectoryPartition(
    IN      LPCWSTR                         pszServer,
    IN      DWORD                           dwOperation,
    IN      LPCSTR                          pszDirPartFqdn
    )
{
    DNS_STATUS          status;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvEnlistDirectoryPartition()\n"
            "    pszServer        = %S\n"
            "    dwOperation      = %d\n"
            "    pszDirPartFqdn   = %s\n",
            pszServer,
            dwOperation,
            pszDirPartFqdn ));
    }

    if ( dwOperation == DNS_DP_OP_CREATE_ALL_DOMAINS )
    {
        //
        //  This operation is not specific to any DNS server.
        // 

        status = DnssrvCreateAllDomainDirectoryPartitions(
                        pszServer,
                        DNS_VERBOSE_PROGRESS );
    }
    else
    {
        //
        //  This operation should be sent directly to pszServer.
        //

        DNS_RPC_ENLIST_DP   param;

        INITIALIZE_RPC_STRUCT( ENLIST_DP, param );
   
        param.pszDpFqdn         = ( LPSTR ) pszDirPartFqdn;
        param.dwOperation       = dwOperation;

        status = DnssrvOperation(
                    pszServer,
                    NULL,
                    DNSSRV_OP_ENLIST_DP,
                    DNSSRV_TYPEID_ENLIST_DP,
                    &param );
    }

    return status;
}   //  DnssrvEnlistDirectoryPartition



DNS_STATUS
DNS_API_FUNCTION
DnssrvSetupDefaultDirectoryPartitions(
    IN      LPCWSTR                         pszServer,
    IN      DWORD                           dwParam
    )
{
    DNS_STATUS          status;
    DNS_RPC_ENLIST_DP   param;

    INITIALIZE_RPC_STRUCT( ENLIST_DP, param );

    param.pszDpFqdn         = NULL;
    param.dwOperation       = dwParam;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvSetupDefaultDirectoryPartitions()\n"
            "    pszServer        = %S\n"
            "    dwParam          = %d\n",
            pszServer,
            dwParam ));
    }

    status = DnssrvOperation(
                pszServer,
                NULL,
                DNSSRV_OP_ENLIST_DP,
                DNSSRV_TYPEID_ENLIST_DP,
                &param );

    return status;
}   //  DnssrvSetupDefaultDirectoryPartitions



DNS_STATUS
DNS_API_FUNCTION
DnssrvDirectoryPartitionInfo(
    IN      LPCWSTR                 Server,
    IN      LPSTR                   pszDpFqdn,
    OUT     PDNS_RPC_DP_INFO *      ppDpInfo
    )
{
    DNS_STATUS          status;
    DWORD               dwTypeId;
    PDNS_RPC_DP_INFO    pDpInfo = NULL;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvDirectoryPartitionInfo()\n"
            "    Server       = %S\n"
            "    pszDpFqdn    = %s\n"
            "    ppDpInfo     = %p\n",
            Server,
            pszDpFqdn,
            ppDpInfo ));
    }

    status = DnssrvComplexOperation(
                Server,
                NULL,
                DNSSRV_OP_DP_INFO,
                DNSSRV_TYPEID_LPSTR,
                ( PVOID ) ( DWORD_PTR ) pszDpFqdn,
                &dwTypeId,
                ( PVOID * ) &pDpInfo );

    ASSERT( ( status == ERROR_SUCCESS &&
                dwTypeId == DNSSRV_TYPEID_DP_INFO ) ||
            status != ERROR_SUCCESS );

    *ppDpInfo = pDpInfo;
    return status;
}   //  DnssrvDirectoryPartitionInfo



/*++

Routine Description:

    This function iterates all domains in the forest and creates
    any missing built-in DNS directory partitions that cannot be
    found.

Arguments:

    pszServer -- host name of DC to contact for initial queries

    dwVerbose -- output level via printf

Return Value:

    DNS_STATUS return code

--*/
DNS_STATUS
DNS_API_FUNCTION
DnssrvCreateAllDomainDirectoryPartitions(
    IN      LPCWSTR     pszServer,
    IN      DWORD       dwVerbose
    )
{
    DNS_STATUS          status = ERROR_SUCCESS;
    HANDLE              hds = NULL;
    PDS_DOMAIN_TRUSTS   pdomainTrusts = NULL;
    ULONG               domainCount = 0;
    ULONG               idomain;
    PDNS_RECORD         pdnsRecordList = NULL;
    PDNS_RECORD         pdnsRecord = NULL;

    //
    //  Get domain list.
    //

    status = DsEnumerateDomainTrustsA(
                    NULL,
                    DS_DOMAIN_IN_FOREST,
                    &pdomainTrusts,
                    &domainCount );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DBG( DNS_VERBOSE_ERROR, (
            "Error 0x%X enumerating domains in the forest\n",
            status ));
        goto Done;
    }

    //
    //  Iterate domains.
    //

    for ( idomain = 0; idomain < domainCount; ++idomain )
    {
        int     insCount = 0;
        PSTR    pszdomainName = pdomainTrusts[ idomain ].DnsDomainName;

        if ( !pszdomainName )
        {
            continue;
        }

        DNS_DBG( DNS_VERBOSE_PROGRESS, (
            "\n\nFound domain: %s\n",
            pszdomainName ));

        //
        //  Get the DNS server list for this domain.
        //

        status = DnsQuery_UTF8(
                    pszdomainName,
                    DNS_TYPE_NS,
                    DNS_QUERY_STANDARD,
                    NULL,                       //  DNS server list
                    &pdnsRecordList,
                    NULL );                     //  reserved
        if ( status != ERROR_SUCCESS )
        {
            if ( status == DNS_INFO_NO_RECORDS )
            {
                DNS_DBG( DNS_VERBOSE_PROGRESS, (
                    "%s: no DNS servers could be found\n", pszdomainName ));
            }
            else
            {
                DNS_DBG( DNS_VERBOSE_PROGRESS, (
                    "%s: error 0x%X from query for DNS servers\n",
                    pszdomainName,
                    status ));
            }
            continue;
        }

        for ( pdnsRecord = pdnsRecordList;
              pdnsRecord != NULL;
              pdnsRecord = pdnsRecord->pNext )
        {
            PWSTR                   pwszserverName;
            DWORD                   dwtypeid;
            PDNS_RPC_SERVER_INFO    pdata;
            DWORD                   dwmajorVersion;
            DWORD                   dwminorVersion;
            DWORD                   dwbuildNum;

            if ( pdnsRecord->wType != DNS_TYPE_NS )
            {
                continue;
            }

            ++insCount;

            DNS_DBG( DNS_VERBOSE_PROGRESS, (
                "\n%s: found DNS server %s\n",
                pszdomainName,
                pdnsRecord->Data.NS.pNameHost ));

            pwszserverName = Dns_NameCopyAllocate(
                                    ( PSTR ) pdnsRecord->Data.NS.pNameHost,
                                    0,
                                    DnsCharSetUtf8,
                                    DnsCharSetUnicode );
            if ( !pwszserverName )
            {
                status = DNS_ERROR_NO_MEMORY;
                goto Done;
            }

            //
            //  "Ping" the DNS server with a server info query to get its
            //  version. This is not strictly necessary but it does allow us
            //  to find out if the server is up and of good version before
            //  we actually think about creating partitions.
            //

            status = DnssrvQuery(
                        pwszserverName,
                        NULL,
                        DNSSRV_QUERY_SERVER_INFO,
                        &dwtypeid,
                        &pdata );
            if ( status != ERROR_SUCCESS )
            {
                DNS_DBG( DNS_VERBOSE_PROGRESS, (
                    "DNS server %S returned RPC error %d\n"
                    "    directory partitions cannot be created on this server\n",
                    pwszserverName,
                    status  ));
                continue;
            }

            dwmajorVersion =    pdata->dwVersion & 0x000000FF;
            dwminorVersion =    ( pdata->dwVersion & 0x0000FF00 ) >> 8;
            dwbuildNum =        pdata->dwVersion >> 16;

            if ( dwbuildNum > 10000 ||
                 dwmajorVersion < 5 ||
                 dwmajorVersion == 5 && dwminorVersion < 1 )
            {
                //
                //  This is a W2K server so do nothing.
                //

                DNS_DBG( DNS_VERBOSE_PROGRESS, (
                    "DNS Server %S is version %u.%u\n"
                    "    directory partitions cannot be created on this server\n",
                    pwszserverName,
                    dwmajorVersion,
                    dwminorVersion ));
            }
            else
            {
                //
                //  This is a Whistler server so attempt to create domain partition.
                //

                #if 0
                DNS_DBG( DNS_VERBOSE_PROGRESS, (
                    "DNS Server %S is version %u.%u build %u\n",
                    pwszserverName,
                    dwmajorVersion,
                    dwminorVersion,
                    dwbuildNum ));
                #endif

                status = DnssrvEnlistDirectoryPartition(
                            pwszserverName,
                            DNS_DP_OP_CREATE_DOMAIN,
                            NULL );
                if ( status == ERROR_SUCCESS )
                {
                    DNS_DBG( DNS_VERBOSE_PROGRESS, (
                        "DNS server %S successfully created the built-in\n"
                        "    domain directory partition for domain %s\n",
                        pwszserverName,
                        pszdomainName  ));
                    break;
                }
                else
                {
                    DNS_DBG( DNS_VERBOSE_PROGRESS, (
                        "DNS server %S returned error %d\n"
                        "    will attempt to create built-in domain partition on another\n"
                        "    DNS server for this domain\n",
                        pwszserverName,
                        status  ));
                }
            }
        }
    }

    //
    //  Cleanup and return
    //

    Done:

    DnsRecordListFree( pdnsRecordList, 0 );

    if ( pdomainTrusts )
    {
        NetApiBufferFree( pdomainTrusts );
    }

    return status;
}   //  DnssrvCreateAllDomainDirectoryPartitions



DNS_STATUS
DNS_API_FUNCTION
DnssrvGetStatistics(
    IN      LPCWSTR             Server,
    IN      DWORD               dwFilter,
    OUT     PDNS_RPC_BUFFER *   ppStatsBuffer
    )
{
    DNS_STATUS      status;
    DWORD           typeId;
    PDNS_RPC_BUFFER pstatsBuf = NULL;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvGetStatistics()\n"
            "    Server       = %S\n"
            "    Filter       = %p\n"
            "    ppStatsBuf   = %p\n",
            Server,
            dwFilter,
            ppStatsBuffer
            ));
    }

    status = DnssrvComplexOperation(
                Server,
                NULL,
                DNSSRV_QUERY_STATISTICS,
                DNSSRV_TYPEID_DWORD,    // DWORD filter in
                (PVOID) (DWORD_PTR) dwFilter,
                & typeId,               // enumeration out
                (PVOID*) &pstatsBuf
                );

    ASSERT( (status == ERROR_SUCCESS && typeId == DNSSRV_TYPEID_BUFFER )
            || (status != ERROR_SUCCESS && pstatsBuf == NULL ) );

    *ppStatsBuffer = pstatsBuf;
    return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvWriteDirtyZones(
    IN      LPCWSTR         Server
    )
{
    DNS_STATUS  status;

    status = DnssrvOperation(
                Server,
                NULL,
                DNSSRV_OP_WRITE_DIRTY_ZONES,
                DNSSRV_TYPEID_NULL,
                NULL
                );
    return( status );
}



//
//  Old zone API -- discontinued
//

DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneType(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone,
    IN      DWORD           dwZoneType,
    IN      DWORD           cMasters,
    IN      PIP_ADDRESS     aipMasters
    )
{
   DNS_STATUS              status;
   DNS_RPC_ZONE_TYPE_RESET typeReset;
   PIP_ARRAY               arrayIp;

   INITIALIZE_RPC_STRUCT( ZONE_TYPE_RESET, typeReset );

   arrayIp = Dns_BuildIpArray(
               cMasters,
               aipMasters );
   if ( !arrayIp && cMasters )
   {
       return( DNS_ERROR_NO_MEMORY );
   }
   typeReset.dwZoneType = dwZoneType;
   typeReset.aipMasters = arrayIp;

   status = DnssrvOperation(
               Server,
               pszZone,
               DNS_REGKEY_ZONE_TYPE,
               DNSSRV_TYPEID_ZONE_TYPE_RESET,
               (PVOID) &typeReset
               );

   FREE_HEAP( arrayIp );
   return( status );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvResetZoneDatabase(
    IN      LPCWSTR         Server,
    IN      LPCSTR          pszZone,
    IN      DWORD           fDsIntegrated,
    IN      LPCSTR          pszDataFile
    )
{
    DNS_STATUS              status;
    DNS_RPC_ZONE_DATABASE   dbase;

    INITIALIZE_RPC_STRUCT( ZONE_DATABASE, dbase );

    dbase.fDsIntegrated = fDsIntegrated;
    dbase.pszFileName = (LPSTR) pszDataFile;

    return DnssrvOperation(
                Server,
                pszZone,
                DNS_REGKEY_ZONE_FILE,
                DNSSRV_TYPEID_ZONE_DATABASE,
                (PVOID) &dbase
                );
}

//
//  End remote.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\client\rpcbind.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    rpcbind.c

Abstract:

    Domain Name System (DNS) Server -- Admin Client API

    RPC binding routines for client.

Author:

    Jim Gilroy (jamesg)     September 1995

Environment:

    User Mode Win32

Revision History:

--*/


#include "dnsclip.h"

#include "ws2tcpip.h"

#include <rpcutil.h>
#include <ntdsapi.h>
#include <dnslibp.h>


//
//  Allow 45 seconds for RPC connection. This should allow one 30 second
//  TCP attempt plus 15 seconds of the second TCP retry.
//

#define DNS_RPC_CONNECT_TIMEOUT     ( 45 * 1000 )       //  in milliseconds


//
//  Local machine name
//
//  Keep this as static data to check when attempt to access local
//  machine by name.
//  Buffer is large enough to hold unicode version of name.
//

static WCHAR    wszLocalMachineName[ MAX_COMPUTERNAME_LENGTH + 1 ] = L"";
LPWSTR          pwszLocalMachineName = wszLocalMachineName;
LPSTR           pszLocalMachineName = ( LPSTR ) wszLocalMachineName;



//
//  NT4 uses ANSI\UTF8 string for binding
//

DWORD
FindProtocolToUseNt4(
    IN  LPSTR   pszServerName
    )
/*++

Routine Description:

    Determine which protocol to use.

    This is determined from server name:
        - noneexistent or local -> use LPC
        - valid IpAddress -> use TCP/IP
        - otherwise named pipes

Arguments:

    pszServerName -- server name we want to bind to

Return Value:

        DNS_RPC_USE_TCPIP
        DNS_RPC_USE_NP
        DNS_RPC_USE_LPC

--*/
{
    DWORD               dwComputerNameLength;
    DWORD               dwIpAddress;
    DWORD               status;

    DNSDBG( RPC, (
        "FindProtocolToUseNt4(%s)\n",
        pszServerName ));

    //
    //  no address given, use LPC
    //

    if ( pszServerName == NULL ||
         *pszServerName == 0 ||
         ( *pszServerName == '.' && *( pszServerName + 1 ) == 0 ) )
    {
        return DNS_RPC_USE_LPC;
    }

    //
    //  if valid IP address, use TCP/IP
    //      - except if loopback address, then use LPC
    //

    dwIpAddress = inet_addr( pszServerName );

    if ( dwIpAddress != INADDR_NONE )
    {
        if ( strcmp( "127.0.0.1", pszServerName ) == 0 )
        {
            return DNS_RPC_USE_LPC;
        }
       
        return DNS_RPC_USE_TCPIP;
    }

    //
    //  DNS name -- use TCP/IP
    //

    if ( strchr( pszServerName, '.' ) )
    {
        status = Dns_ValidateName_UTF8(
                        pszServerName,
                        DnsNameHostnameFull );

        if ( status == ERROR_SUCCESS || status == DNS_ERROR_NON_RFC_NAME )
        {
            return DNS_RPC_USE_TCPIP;
        }
    }

    //
    //  pszServerName is netBIOS computer name
    //
    //  check if local machine name -- then use LPC
    //      - save copy of local computer name if don't have it
    //

    if ( *pszLocalMachineName == '\0' )
    {
        dwComputerNameLength = MAX_COMPUTERNAME_LENGTH;
        if( !GetComputerName(
                    pszLocalMachineName,
                    &dwComputerNameLength ) )
        {
            *pszLocalMachineName = '\0';
        }
    }

    if ( ( *pszLocalMachineName != '\0' ) )
    {
        // if the machine has "\\" skip it for name compare.

        if ( *pszServerName == '\\' )
        {
            pszServerName += 2;
        }
        if ( _stricmp( pszLocalMachineName, pszServerName ) == 0 )
        {
            return DNS_RPC_USE_LPC;
        }
        if ( _stricmp( "localhost", pszServerName ) == 0 )
        {
            return DNS_RPC_USE_LPC;
        }
    }

    //
    //  remote machine name -- use named pipes
    //

    return DNS_RPC_USE_NAMED_PIPE;
}



//
//  NT5 binding handle is unicode
//

DWORD
FindProtocolToUse(
    IN  LPWSTR  pwszServerName
    )
/*++

Routine Description:

    Determine which protocol to use.

    This is determined from server name:
        - noneexistent or local -> use LPC
        - valid IpAddress -> use TCP/IP
        - otherwise named pipes

Arguments:

    pwszServerName -- server name we want to bind to

Return Value:

    DNS_RPC_USE_TCPIP
    DNS_RPC_USE_NP
    DNS_RPC_USE_LPC

--*/
{
    DWORD   nameLength;
    DWORD   status;
    CHAR    nameBuffer[ DNS_MAX_NAME_BUFFER_LENGTH ];

    DNSDBG( RPC, ( "FindProtocolToUse( %S )\n", pwszServerName ));

    //
    //  If no server name was given, use LPC.
    //  Special case "." as local machine for convenience in dnscmd.exe.
    //

    if ( pwszServerName == NULL ||
         *pwszServerName == 0 ||
         ( *pwszServerName == L'.' && * ( pwszServerName + 1 ) == 0 ) )
    {
        return DNS_RPC_USE_LPC;
    }

    //
    //  If the name appears to be an address or a fully qualified
    //  domain name, check for TCP versus LPC. We want to use LPC in
    //  all cases where the target is the name of the local machine
    //  or is a local address.
    //

    if ( ( wcschr( pwszServerName, L'.' ) ||
           wcschr( pwszServerName, L':' ) ) &&
         Dns_UnicodeToUtf8(
                pwszServerName,
                wcslen( pwszServerName ),
                nameBuffer,
                sizeof( nameBuffer ) ) )
    {
        struct addrinfo *   paddrinfo = NULL;
        struct addrinfo     hints = { 0 };
        
        //
        //  Remove trailing dots from nameBuffer so that we can do string
        //  compares later to see if it matches the local host name.
        //
        
        while ( nameBuffer[ 0 ] &&
                nameBuffer[ strlen( nameBuffer ) - 1 ] == '.' )
        {
            nameBuffer[ strlen( nameBuffer ) - 1 ] = '\0';
        }
        
        //
        //  Attempt to convert the string into an address.
        //
        
        hints.ai_flags = AI_NUMERICHOST;
        
        if ( getaddrinfo(
                    nameBuffer,
                    NULL,           //  service name
                    &hints,
                    &paddrinfo ) == ERROR_SUCCESS &&
              paddrinfo )
        {
            if ( paddrinfo->ai_family == AF_INET )
            {
                PDNS_ADDR_ARRAY         dnsapiArrayIpv4;
                BOOL                    addrIsLocal = FALSE;

                if ( strcmp( "127.0.0.1", nameBuffer ) == 0 )
                {
                    return DNS_RPC_USE_LPC;
                }

                //
                //  Check IP passed in against local IPv4 address list.
                //  If we are unable to retrieve local IPv4 address list,
                //  fail silently and use TCP/IP.
                //
                
                dnsapiArrayIpv4 = ( PDNS_ADDR_ARRAY )
                    DnsQueryConfigAllocEx(
                        DnsConfigLocalAddrsIp4,
                        NULL,                       //  adapter name
                        FALSE );                    //  local alloc
                if ( dnsapiArrayIpv4 )
                {
                    DWORD                   iaddr;
                    struct sockaddr_in *    psin4;
                    
                    psin4 = ( struct sockaddr_in * ) paddrinfo->ai_addr;
                    for ( iaddr = 0; iaddr < dnsapiArrayIpv4->AddrCount; ++iaddr )
                    {
                        if ( DnsAddr_GetIp4( &dnsapiArrayIpv4->AddrArray[ iaddr ] ) ==
                             psin4->sin_addr.s_addr )
                        {
                            addrIsLocal = TRUE;
                            break;
                        }
                    }
                    DnsFreeConfigStructure( dnsapiArrayIpv4, DnsConfigLocalAddrsIp4 );
                    
                    if ( addrIsLocal )
                    {
                        return DNS_RPC_USE_LPC;
                    }
                }
                
                return DNS_RPC_USE_TCPIP;
            }
            else if ( paddrinfo->ai_family == AF_INET6 )
            {
                struct sockaddr_in6 *   psin6;
                
                psin6 = ( struct sockaddr_in6 * ) paddrinfo->ai_addr;
                if ( IN6_IS_ADDR_LOOPBACK( &psin6->sin6_addr ) )
                {
                    return DNS_RPC_USE_LPC;
                }
                return DNS_RPC_USE_TCPIP;
            }
        }

        status = Dns_ValidateName_UTF8(
                        nameBuffer,
                        DnsNameHostnameFull );
        if ( status == ERROR_SUCCESS  ||  status == DNS_ERROR_NON_RFC_NAME )
        {
            //
            //  Note: assume we will never need a larger buffer, and
            //  if GetComputerName fails, return TCP/IP always.
            //
            
            CHAR    szhost[ DNS_MAX_NAME_BUFFER_LENGTH ];
            DWORD   dwhostsize = DNS_MAX_NAME_BUFFER_LENGTH;
            
            if ( GetComputerNameEx(
                        ComputerNameDnsFullyQualified,
                        szhost,
                        &dwhostsize ) &&
                 _stricmp( szhost, nameBuffer ) == 0 )
            {
                return DNS_RPC_USE_LPC;
            }

            return DNS_RPC_USE_TCPIP;
        }
    }

    //
    //  pwszServerName is netBIOS computer name
    //
    //  check if local machine name -- then use LPC
    //      - save copy of local computer name if don't have it
    //

    if ( *pwszLocalMachineName == 0 )
    {
        nameLength = MAX_COMPUTERNAME_LENGTH;
        if( !GetComputerNameW(
                    pwszLocalMachineName,
                    &nameLength ) )
        {
            *pwszLocalMachineName = 0;
        }
    }

    if ( *pwszLocalMachineName != 0 )
    {
        // if the machine has "\\" skip it for name compare.

        if ( *pwszServerName == L'\\' )
        {
            pwszServerName += 2;
        }
        if ( _wcsicmp( pwszLocalMachineName, pwszServerName ) == 0 )
        {
            return DNS_RPC_USE_LPC;
        }
        if ( _wcsicmp( L"localhost", pwszServerName ) == 0 )
        {
            return DNS_RPC_USE_LPC;
        }
    }

    //
    //  remote machine name -- use named pipes
    //

    return DNS_RPC_USE_NAMED_PIPE;
}



DNS_STATUS
makeSpn(
    IN PWSTR ServiceClass, 
    IN PWSTR ServiceName, 
    IN OPTIONAL PWSTR InstanceName, 
    IN OPTIONAL USHORT InstancePort, 
    IN OPTIONAL PWSTR Referrer, 
    OUT PWSTR *Spn
)
/*
Routine Description:

    This routine is wrapper around DsMakeSpnWto avoid two calls to this function,
    one to find the size of the return value and second to get the actual value.
    
    jwesth: I stole this routine from ds\src\sam\client\wrappers.c.
    
Arguments:

    ServiceClass -- Pointer to a constant null-terminated Unicode string specifying the 
        class of the service. This parameter may be any string unique to that service; 
        either the protocol name (for example, ldap) or the string form of a GUID will work. 
        
    ServiceName -- Pointer to a constant null-terminated string specifying the DNS name, 
        NetBIOS name, or distinguished name (DN). This parameter must be non-NULL. 

    InstanceName -- Pointer to a constant null-terminated Unicode string specifying the DNS name 
        or IP address of the host for an instance of the service. If ServiceName specifies 
        the DNS or NetBIOS name of the service's host computer, the InstanceName parameter must be NULL.

    InstancePort -- Port number for an instance of the service. Use 0 for the default port. 
        If this parameter is zero, the SPN does not include a port number. 
        
    Referrer -- Pointer to a constant null-terminated Unicode string specifying the DNS name 
        of the host that gave an IP address referral. This parameter is ignored unless the 
        ServiceName parameter specifies an IP address. 

    Spn -- Pointer to a Unicode string that receives the constructed SPN.
         The caller must free this value.

Return Value:

    STATUS_SUCCESS
        Successful

    STATUS_NO_MEMORY
        not enough memory to complete the task

    STATUS_INVALID_PARAMETER
        one of the parameters is invalid

    STATUS_INTERNAL_ERROR
        opps something went wrong!

*/
{
    DWORD                   DwStatus;
    NTSTATUS                Status = STATUS_SUCCESS;
    ULONG                   SpnLength = 0;
    ADDRINFO *              paddrinfo = NULL;
    ADDRINFO                hints = { 0 };
    CHAR                    szname[ DNS_MAX_NAME_LENGTH + 1 ];
    PWSTR                   pwsznamecopy = NULL;
    PSTR                    psznamecopy = NULL;

    //
    //  If ServiceName is an IP address, do DNS lookup on it.
    //
    
    hints.ai_flags = AI_NUMERICHOST;
    
    psznamecopy = Dns_StringCopyAllocate(
                        ( PSTR ) ServiceName,
                        0,
                        DnsCharSetUnicode,
                        DnsCharSetUtf8 );
    
    if ( psznamecopy &&
         getaddrinfo(
                psznamecopy,
                NULL,
                &hints,
                &paddrinfo ) == ERROR_SUCCESS )
    {
        *szname = L'\0';
        
        if ( getnameinfo(
                    paddrinfo->ai_addr,
                    paddrinfo->ai_addrlen,
                    szname,
                    DNS_MAX_NAME_LENGTH,
                    NULL,
                    0,
                    0 ) == ERROR_SUCCESS &&
             *szname )
        {
            pwsznamecopy = Dns_StringCopyAllocate(
                                    szname,
                                    0,
                                    DnsCharSetUtf8,
                                    DnsCharSetUnicode );
            if ( pwsznamecopy )
            {
                ServiceName = pwsznamecopy;
            }
        }
    }
    
    freeaddrinfo( paddrinfo );
    
    //
    //  Construct SPN.
    //
    
    *Spn = NULL;
    DwStatus = DsMakeSpnW(
                    ServiceClass,
                    ServiceName,
                    NULL,
                    0,
                    NULL,
                    &SpnLength,
                    NULL );
    
    if ( DwStatus != ERROR_BUFFER_OVERFLOW )
    {
        ASSERT( !"DwStatus must be INVALID_PARAMETER, so which parameter did we pass wrong?" );
        Status = STATUS_INVALID_PARAMETER;
        goto Error;
    }

    *Spn = MIDL_user_allocate( SpnLength * sizeof( WCHAR ) );
    
    if( *Spn == NULL ) {
        
        Status = STATUS_NO_MEMORY;
        goto Error;
    }
    
    DwStatus = DsMakeSpnW(
                    ServiceClass,
                    ServiceName,
                    NULL,
                    0,
                    NULL,
                    &SpnLength,
                    *Spn );
    
    if ( DwStatus != ERROR_SUCCESS )
    {
        ASSERT( !"DwStatus must be INVALID_PARAMETER or BUFFER_OVERFLOW, so what did we do wrong?" );
        Status = STATUS_INTERNAL_ERROR;
        goto Error;
    }
    goto Exit;

Error:

    ASSERT( !NT_SUCCESS( Status ) );

    MIDL_user_free( *Spn );
    *Spn = NULL;

Exit:    

    FREE_HEAP( pwsznamecopy );
    FREE_HEAP( psznamecopy );

    return Status;
}



handle_t
DNSSRV_RPC_HANDLE_bind(
    IN  DNSSRV_RPC_HANDLE   pszServerName
    )
/*++

Routine Description:

    Get binding handle to a DNS server.

    This routine is called from the DNS client stubs when
    it is necessary create an RPC binding to the DNS server.

Arguments:

    pszServerName - String containing the name of the server to bind with.

Return Value:

    The binding handle if successful.
    NULL if bind unsuccessful.

--*/
{
    RPC_STATUS                      status;
    LPWSTR                          binding;
    handle_t                        bindingHandle;
    DWORD                           RpcProtocol;
    PWSTR                           pwszspn = NULL;
    RPC_SECURITY_QOS                rpcSecurityQOS;
    BOOL                            bW2KBind = dnsrpcGetW2KBindFlag();

    //
    //  Clear thread local W2K bind retry flag for the next attempt.
    //
    
    dnsrpcSetW2KBindFlag( FALSE );
    
    //
    //  Initialize RPC quality of service structure.
    //
    
    rpcSecurityQOS.Version              = RPC_C_SECURITY_QOS_VERSION;
    rpcSecurityQOS.Capabilities         = RPC_C_QOS_CAPABILITIES_MUTUAL_AUTH;
    rpcSecurityQOS.IdentityTracking     = RPC_C_QOS_IDENTITY_STATIC;
    rpcSecurityQOS.ImpersonationType    = RPC_C_IMP_LEVEL_DELEGATE;
    
    //
    //  Determine protocol from target name (could be short name, long name, or IP).
    //

    RpcProtocol = FindProtocolToUse( (LPWSTR)pszServerName );

    IF_DNSDBG( RPC )
    {
        DNS_PRINT(( "RPC Protocol = %d\n", RpcProtocol ));
    }

    if( RpcProtocol == DNS_RPC_USE_LPC )
    {
        status = RpcStringBindingComposeW(
                        0,
                        L"ncalrpc",
                        NULL,
                        DNS_RPC_LPC_EP_W,
                        L"Security=Impersonation Static True",
                        &binding );
    }
    else if( RpcProtocol == DNS_RPC_USE_NAMED_PIPE )
    {
        status = RpcStringBindingComposeW(
                        0,
                        L"ncacn_np",
                        ( LPWSTR ) pszServerName,
                        DNS_RPC_NAMED_PIPE_W,
                        L"Security=Impersonation Static True",
                        &binding );
    }
    else
    {
        status = RpcStringBindingComposeW(
                        0,
                        L"ncacn_ip_tcp",
                        ( LPWSTR ) pszServerName,
                        DNS_RPC_SERVER_PORT_W,
                        NULL,
                        &binding );
    }


    if ( status != RPC_S_OK )
    {
        DNS_PRINT((
            "ERROR:  RpcStringBindingCompose failed for protocol %d\n"
            "    Status = %d\n",
            RpcProtocol,
            status ));
        goto Cleanup;
    }

    status = RpcBindingFromStringBindingW(
                    binding,
                    &bindingHandle );

    if ( status != RPC_S_OK )
    {
        DNS_PRINT((
            "ERROR:  RpcBindingFromStringBinding failed\n"
            "    Status = %d\n",
            status ));
        goto Cleanup;
    }

    if ( RpcProtocol == DNS_RPC_USE_TCPIP )
    {
        //
        //  Create SPN string
        //
    
        if ( !bW2KBind )
        {    
            status = makeSpn(
                        L"Rpcss",
                        ( PWSTR ) pszServerName,
                        NULL,
                        0,
                        NULL,
                        &pwszspn );
        }
        
        if ( !bW2KBind && status == RPC_S_OK )
        {
            //
            //  Set up RPC security.
            //

            #if DBG
            printf( "rpcbind: SPN = %S\n", pwszspn );
            #endif

            status = RpcBindingSetAuthInfoExW(
                            bindingHandle,                  //  binding handle
                            pwszspn,                        //  app name to security provider
                            RPC_C_AUTHN_LEVEL_CONNECT,      //  auth level
                            RPC_C_AUTHN_GSS_NEGOTIATE,      //  auth package ID
                            NULL,                           //  client auth info, NULL specified logon info.
                            0,                              //  auth service
                            &rpcSecurityQOS );              //  RPC security quality of service
            if ( status != RPC_S_OK )
            {
                DNS_PRINT((
                    "ERROR:  RpcBindingSetAuthInfo failed\n"
                    "    Status = %d\n",
                    status ));
                goto Cleanup;
            }
        }
        else
        {
            #if DBG
            printf( "rpcbind: SPN = %s\n", DNS_RPC_SECURITY );
            #endif
            //
            //  No SPN is available, so make the call that we used in W2K.
            //  This seems to have a beneficial effect even though it is
            //  not really correct. If the target is an IP address and there
            //  is no reverse lookup zone, without the call below we do not
            //  get a working RPC session.
            //
            
            if ( bW2KBind )
            {
                status = RpcBindingSetAuthInfoA(
                                bindingHandle,                  //  binding handle
                                DNS_RPC_SECURITY,               //  app name to security provider
                                RPC_C_AUTHN_LEVEL_CONNECT,      //  auth level
                                RPC_C_AUTHN_WINNT,              //  auth package ID
                                NULL,                           //  client auth info, NULL specified logon info.
                                0 );                            //  auth service
            }
            else
            {
                status = RpcBindingSetAuthInfoExA(
                                bindingHandle,                  //  binding handle
                                DNS_RPC_SECURITY,               //  app name to security provider
                                RPC_C_AUTHN_LEVEL_CONNECT,      //  auth level
                                RPC_C_AUTHN_GSS_NEGOTIATE,      //  auth package ID
                                NULL,                           //  client auth info, NULL specified logon info.
                                0,                              //  auth service
                                &rpcSecurityQOS );              //  RPC security quality of service
            }
            if ( status != RPC_S_OK )
            {
                DNS_PRINT((
                    "ERROR:  RpcBindingSetAuthInfo failed\n"
                    "    Status = %d\n",
                    status ));
                goto Cleanup;
            }
        }
    }

#if 0
    //
    //  Set RPC connection timeout. The default timeout is very long. If 
    //  the remote IP is unreachable we don't really need to wait that long.
    //
    
    //  Can't do this. It's a nice idea but RPC uses this timeout for the
    //  entire call, which means that long running RPC calls will return
    //  RPC_S_CALL_CANCELLED to the client after 45 seconds. What I want
    //  is a timeout option for connection only. RPC does not provide this.
    //

    RpcBindingSetOption(
        bindingHandle,
        RPC_C_OPT_CALL_TIMEOUT,
        DNS_RPC_CONNECT_TIMEOUT );
#endif

Cleanup:

    RpcStringFreeW( &binding );

    MIDL_user_free( pwszspn );

    if ( status != RPC_S_OK )
    {
        SetLastError( status );
        return NULL;
    }
    return bindingHandle;
}



void
DNSSRV_RPC_HANDLE_unbind(
    IN  DNSSRV_RPC_HANDLE   pszServerName,
    IN  handle_t            BindHandle
    )
/*++

Routine Description:

    Unbind from DNS server.

    Called from the DNS client stubs when it is necessary to unbind
    from a server.

Arguments:

    pszServerName - This is the name of the server from which to unbind.

    BindingHandle - This is the binding handle that is to be closed.

Return Value:

    None.

--*/
{
    UNREFERENCED_PARAMETER(pszServerName);

    DNSDBG( RPC, ( "RpcBindingFree()\n" ));

    RpcBindingFree( &BindHandle );
}


//
//  End rpcbind.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\client\sam.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    sam.c

Abstract:

    Domain Name System (DNS) Server -- Admin Client API

    Functions developed for SAM as simplified interfaces \ examples.

Author:

    Jim Gilroy (jamesg)     September 1997

Environment:

    User Mode - Win32

Revision History:

--*/


#include "dnsclip.h"

#define MAX_SAM_BACKOFF     (32000)     // wait up to 32 seconds



//
//  Type specific update functions.
//

VOID
DNS_API_FUNCTION
DnssrvFillRecordHeader(
    IN OUT  PDNS_RPC_RECORD     pRecord,
    IN      DWORD               dwTtl,
    IN      DWORD               dwTimeStamp,
    IN      BOOL                fSuppressNotify
    )
{
    pRecord->dwTtlSeconds = dwTtl;
    pRecord->dwTimeStamp = dwTimeStamp;
    pRecord->dwFlags = 0;
    if ( fSuppressNotify )
    {
        pRecord->dwFlags |= DNS_RPC_FLAG_SUPPRESS_NOTIFY;
    }
}


DWORD
DNS_API_FUNCTION
DnssrvWriteNameToFlatBuffer(
    IN OUT  PCHAR       pchWrite,
    IN      LPCSTR      pszName
    )
/*++

Routine Description:

    Write DNS name (or string) to flat buffer.

Arguments:

    pchWrite -- location to write name at

    pszName -- name or string to write

Return Value:

    Length of name written, including count byte.  Caller may countinue in
        buffer at pchWrite + returned length.
    0 on name error.

--*/
{
    DWORD   length;

    //
    //  get name length
    //  whether name or string, must be 255 or less to fit
    //      counted character format

    length = strlen( pszName );
    if ( length > DNS_MAX_NAME_LENGTH )
    {
        return( 0 );
    }

    //
    //  write name to desired location
    //      - count byte first
    //      - then name itself

    * (PUCHAR) pchWrite = (UCHAR) length;
    pchWrite++;

    RtlCopyMemory(
        pchWrite,
        pszName,
        length );

    return( length+1 );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvFillOutSingleIndirectionRecord(
    IN OUT  PDNS_RPC_RECORD     pRecord,
    IN      WORD                wType,
    IN      LPCSTR              pszName
    )
{
    PCHAR   pwriteName;
    DWORD   length;
    DWORD   dataLength = 0;

    //
    //  find name write position and final data length for various types
    //

    switch( wType )
    {
    case DNS_TYPE_MX:

        pwriteName = (PCHAR) &pRecord->Data.MX.nameExchange;
        dataLength += sizeof(WORD);
        break;

    case DNS_TYPE_SRV:

        pwriteName = (PCHAR) &pRecord->Data.SRV.nameTarget;
        dataLength += 3*sizeof(WORD);
        break;

    default:
        //  all plain single-indirection types (CNAME, NS, PTR, etc)

        pwriteName = (PCHAR) &pRecord->Data.PTR.nameNode;
    }

    //
    //  write name
    //      - note name's datalength includes count character
    //

    length = DnssrvWriteNameToFlatBuffer( pwriteName, pszName );
    if ( !length )
    {
        return( ERROR_INVALID_DATA );
    }
    dataLength += length;

    //  set record header fields

    pRecord->wType = wType;
    pRecord->wDataLength = (WORD)dataLength;

    ASSERT( (PCHAR)pRecord + SIZEOF_DNS_RPC_RECORD_HEADER + dataLength
                == pwriteName + length );

    return( ERROR_SUCCESS );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvAddARecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      IP_ADDRESS  ipAddress,
    IN      DWORD       dwTtl,
    IN      DWORD       dwTimeout,
    IN      BOOL        fSuppressNotify
    )
{
    DNS_RPC_RECORD  record;

    //  pack up data and send

    DnssrvFillRecordHeader(
        & record,
        dwTtl,
        dwTimeout,
        fSuppressNotify );

    record.wType = DNS_TYPE_A;
    record.wDataLength = sizeof(IP_ADDRESS);
    record.Data.A.ipAddress = ipAddress;

    return  DnssrvUpdateRecord(
                pwszServer,
                NULL,           // zone not specified
                pszNodeName,
                &record,
                NULL );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvAddCnameRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszCannonicalName,
    IN      DWORD       dwTtl,
    IN      DWORD       dwTimeout,
    IN      BOOL        fSuppressNotify
    )
{
    DNS_RPC_RECORD  record;

    //  pack up data and send

    DnssrvFillRecordHeader(
        & record,
        dwTtl,
        dwTimeout,
        fSuppressNotify );

    DnssrvFillOutSingleIndirectionRecord(
        & record,
        DNS_TYPE_CNAME,
        pszCannonicalName );

    return  DnssrvUpdateRecord(
                pwszServer,
                NULL,           // zone not specified
                pszNodeName,
                &record,
                NULL );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvAddMxRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszMailExchangeHost,
    IN      WORD        wPreference,
    IN      DWORD       dwTtl,
    IN      DWORD       dwTimeout,
    IN      BOOL        fSuppressNotify
    )
{
    DNS_RPC_RECORD  record;

    //  pack up data and send

    DnssrvFillRecordHeader(
        & record,
        dwTtl,
        dwTimeout,
        fSuppressNotify );

    DnssrvFillOutSingleIndirectionRecord(
        & record,
        DNS_TYPE_MX,
        pszMailExchangeHost );

    record.Data.MX.wPreference = wPreference;

    return  DnssrvUpdateRecord(
                pwszServer,
                NULL,           // zone not specified
                pszNodeName,
                &record,
                NULL );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvAddNsRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszNsHostName,
    IN      DWORD       dwTtl,
    IN      DWORD       dwTimeout,
    IN      BOOL        fSuppressNotify
    )
{
    DNS_RPC_RECORD  record;
    DWORD           length;

    //  pack up data and send

    DnssrvFillRecordHeader(
        & record,
        dwTtl,
        dwTimeout,
        fSuppressNotify );

    DnssrvFillOutSingleIndirectionRecord(
        & record,
        DNS_TYPE_NS,
        pszNsHostName );

    return  DnssrvUpdateRecord(
                pwszServer,
                NULL,           // zone not specified
                pszNodeName,
                &record,
                NULL );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvConcatDnsNames(
    OUT     PCHAR       pszResult,
    IN      LPCSTR      pszDomain,
    IN      LPCSTR      pszName
    )
/*++

Routine Description:

    Concatenate two DNS names.
    Result is FQDN DNS name -- dot terminated.

    Note, currently no validity check is done on names being appended.
    If they are invalid DNS names then result is invalid DNS name.

Arguments:

    pszResult -- result name buffer;  should be DNS_MAX_NAME_BUFFER_LEN to
        be protected from name overwrite

    pszDomain -- domain name to write

    pszName -- name (like a host name) to prepend to domain name

Return Value:

    ERROR_SUCCESS if successful.  pszResult then contains FQDN
    DNS_ERROR_INVALID_NAME on failure.

--*/
{
    DWORD   lengthDomain;
    DWORD   lengthName;

    //  handle NULL name case

    if ( !pszName )
    {
        strcpy( pszResult, pszDomain );
        return( ERROR_SUCCESS );
    }

    //
    //  build combined name
    //      - verify combined length within DNS limit
    //      - put dot between names
    //      - dot terminate combined name (make FQDN)
    //

    lengthDomain = strlen( pszDomain );
    lengthName = strlen( pszName );

    if ( lengthDomain + lengthName + 2 > DNS_MAX_NAME_LENGTH )
    {
        return( DNS_ERROR_INVALID_NAME );
    }

    strcpy( pszResult, pszName );
    if ( pszDomain[lengthName-1] != '.' )
    {
        strcat( pszResult, "." );
    }
    strcat( pszResult, pszDomain );
    if ( pszDomain[lengthDomain-1] != '.' )
    {
        strcat( pszResult, "." );
    }

    return( ERROR_SUCCESS );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvSbsAddClientToIspZone(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszIspZone,
    IN      LPCSTR      pszClient,
    IN      LPCSTR      pszClientHost,
    IN      IP_ADDRESS  ipClientHost,
    IN      DWORD       dwTtl
    )
{
    DNS_STATUS  status;
    INT         recordCount = (-1);
    INT         backoff = 0;
    CHAR        szdomain[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR        szhost[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR        sztarget[ DNS_MAX_NAME_BUFFER_LENGTH ];

    //
    //  to register in ISP zone need to register
    //      - MX
    //      - CNAME for web server
    //      - host for web and mail server
    //
    //  build FQDN for domain and host and cname
    //      - do this now so we know names are valid
    //

    status = DnssrvConcatDnsNames(
                szdomain,
                pszIspZone,
                pszClient );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    status = DnssrvConcatDnsNames(
                szhost,
                szdomain,
                pszClientHost );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    status = DnssrvConcatDnsNames(
                sztarget,
                szdomain,
                "www" );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }


    //
    //  do registrations, looping in case server is unable to complete
    //      immediately but is open for update
    //

    while ( 1 )
    {
        //  if retrying backoff, but continue trying

        if ( backoff )
        {
            if ( backoff > MAX_SAM_BACKOFF )
            {
                break;
            }
            Sleep( backoff );
        }
        backoff += 1000;

        //
        //  remove any old entries at client domain
        //

        if ( recordCount < 0 )
        {
            status = DnssrvDeleteNode(
                        pwszServer,
                        pszIspZone,
                        szdomain,
                        1           // delete subtree
                        );
            if ( status == DNS_ERROR_NAME_DOES_NOT_EXIST )
            {
                status = ERROR_SUCCESS;
            }
        }

        //  register A record

        else if ( recordCount < 1 )
        {
            status = DnssrvAddARecord(
                        pwszServer,
                        szhost,
                        ipClientHost,
                        dwTtl,
                        0,          // no timeout
                        TRUE );     // suppress notify
        }

        //  register CNAME for WEB server

        else if ( recordCount < 2 )
        {
            status = DnssrvAddCnameRecord(
                        pwszServer,
                        sztarget,
                        szhost,
                        dwTtl,
                        0,          // no timeout
                        TRUE );     // suppress notify
        }

        //  register MX at client's domain root
        //      then at wildcard

        else if ( recordCount < 3 )
        {
            status = DnssrvAddMxRecord(
                        pwszServer,
                        szdomain,
                        szhost,
                        10,         // preference
                        dwTtl,
                        0,          // no timeout
                        TRUE );     // suppress notify
        }

        else if ( recordCount < 4 )
        {
            //  prepare *.<client>.isp name for wildcard MX record

            status = DnssrvConcatDnsNames(
                        sztarget,
                        szdomain,
                        "*" );
            if ( status != ERROR_SUCCESS )
            {
                ASSERT( FALSE );
                break;
            }
            status = DnssrvAddMxRecord(
                        pwszServer,
                        sztarget,
                        szhost,
                        10,         // preference
                        dwTtl,
                        0,          // no timeout
                        TRUE );     // suppress notify

        }

        //  all desired records registered

        else
        {
            ASSERT( recordCount == 4 );
            break;
        }

        //
        //  check status on operations
        //      - if successful, inc count and reset backoff to move
        //          onto next operation
        //      - if zone locked, continue after backoff
        //      - other errors are terminal
        //

        if ( status == ERROR_SUCCESS ||
             status == DNS_ERROR_RECORD_ALREADY_EXISTS )
        {
            recordCount++;
            backoff = 0;
        }
        else if ( status == DNS_ERROR_ZONE_LOCKED )
        {
            continue;
        }
        else
        {
            break;
        }
    }

    return( status );
}



//
//  Record deleting functions.
//
//  This example uses A records.
//      Could be cloned to handle MX or CNAME or NS.
//  OR could expand this function to choose type
//

BOOL
DNS_API_FUNCTION
DnssrvMatchDnsRpcName(
    IN      PDNS_RPC_NAME   pRpcName,
    IN      LPCSTR          pszName
    )
{
    CHAR    nameBuf[ DNS_MAX_NAME_BUFFER_LENGTH ] = "";

    RtlCopyMemory(
        nameBuf,
        pRpcName->achName,
        pRpcName->cchNameLength );

    return  Dns_NameCompare_UTF8( nameBuf, (LPSTR)pszName );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteARecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      IP_ADDRESS  ipAddress,
    IN      BOOL        fSuppressNotify
    )
{
    DNS_RPC_RECORD  record;

    DNSDBG( RPC2, ( "DnssrvDeleteARecord()\n" ));

    //  pack up data and send

    DnssrvFillRecordHeader(
        & record,
        0,                  //  TTL irrelevant for delete
        0,                  //  timeout irrelevant
        fSuppressNotify );

    record.wType = DNS_TYPE_A;
    record.wDataLength = sizeof(IP_ADDRESS);
    record.Data.A.ipAddress = ipAddress;

    return  DnssrvUpdateRecord(
                pwszServer,
                NULL,           // zone not specified
                pszNodeName,
                NULL,               // no add
                &record );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteCnameRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszCannonicalName,
    IN      BOOL        fSuppressNotify
    )
{
    DNS_RPC_RECORD  record;

    //  pack up data and send

    DnssrvFillRecordHeader(
        & record,
        0,          //  TTL irrelevant for delete
        0,          //  timeout irrelevant
        fSuppressNotify );

    DnssrvFillOutSingleIndirectionRecord(
        & record,
        DNS_TYPE_CNAME,
        pszCannonicalName );

    return  DnssrvUpdateRecord(
                pwszServer,
                NULL,           // zone not specified
                pszNodeName,
                NULL,
                &record );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteMxRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszMailExchangeHost,
    IN      WORD        wPreference,
    IN      BOOL        fSuppressNotify
    )
{
    DNS_RPC_RECORD  record;

    //  pack up data and send

    DnssrvFillRecordHeader(
        & record,
        0,          //  TTL irrelevant for delete
        0,          //  timeout irrelevant
        fSuppressNotify );

    DnssrvFillOutSingleIndirectionRecord(
        & record,
        DNS_TYPE_MX,
        pszMailExchangeHost );

    record.Data.MX.wPreference = wPreference;

    return  DnssrvUpdateRecord(
                pwszServer,
                NULL,           // zone not specified
                pszNodeName,
                NULL,
                &record );
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvDeleteNsRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszNsHostName,
    IN      BOOL        fSuppressNotify
    )
{
    DNS_RPC_RECORD  record;

    //  pack up data and send

    DnssrvFillRecordHeader(
        & record,
        0,          //  TTL irrelevant for delete
        0,          //  timeout irrelevant
        fSuppressNotify );

    DnssrvFillOutSingleIndirectionRecord(
        & record,
        DNS_TYPE_NS,
        pszNsHostName );

    return  DnssrvUpdateRecord(
                pwszServer,
                NULL,           // zone not specified
                pszNodeName,
                NULL,
                &record );
}


#if 0

DNS_STATUS
DNS_API_FUNCTION
DnssrvSbsDeleteRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszZone,
    IN      LPCSTR      pszDomain,
    IN      LPCSTR      pszOwner,
    IN      WORD        wType,
    IN      LPCSTR      pszDataName,
    IN      IP_ADDRESS  ipHost
    )
{
    PDNS_RPC_RECORD prpcRecord;
    DNS_STATUS      status;
    BOOL            ffound;
    INT             countRecords;
    PBYTE           pbyte;
    PBYTE           pstopByte;
    PBYTE           pbuffer;
    DWORD           bufferLength;
    CHAR            szdomain[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR            szhost[ DNS_MAX_NAME_BUFFER_LENGTH ];

    DNSDBG( RPC2, ( "DnssrvSbsDeleteRecord()\n" ));

    //
    //  to register in ISP zone need to register
    //      - MX
    //      - CNAME for web server
    //      - host for web and mail server
    //
    //  build FQDN for domain and host and cname
    //      - do this now so we know names are valid
    //

    status = DnssrvConcatDnsNames(
                szdomain,
                pszZone,
                pszDomain );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    status = DnssrvConcatDnsNames(
                szhost,
                szdomain,
                pszOwner );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //
    //  enumerate records at a particular node
    //

    status = DnssrvEnumRecords(
                pwszServer,
                szhost,
                NULL,
                wType,
                ( DNS_RPC_VIEW_ALL_DATA | DNS_RPC_VIEW_NO_CHILDREN ),
                & bufferLength,
                & pbuffer );

    if ( status != ERROR_SUCCESS )
    {
        DNSDBG( RPC2, ( "DnssrvEnumRecord() failed %p.\n", status ));
        return( status );
    }

    pstopByte = pbuffer + bufferLength;
    pbyte = pbuffer;

    //
    //  read node info
    //      - extract record count
    //

    countRecords = ((PDNS_RPC_NODE)pbyte)->wRecordCount;
    pbyte += ((PDNS_RPC_NODE)pbyte)->wLength;
    pbyte = DNS_NEXT_DWORD_PTR(pbyte);

    //
    //  loop through all records in node, delete appropriate one
    //

    DNSDBG( RPC2, (
        "Checking %d records for matching record.\n",
        countRecords ));

    while ( countRecords-- )
    {
        prpcRecord = (PDNS_RPC_RECORD) pbyte;

        if ( !DNS_IS_RPC_RECORD_WITHIN_BUFFER( prpcRecord, pstopByte ) )
        {
            DNS_PRINT((
                "ERROR:  Bogus buffer at %p\n"
                "\tRecord leads past buffer end at %p\n"
                "\twith %d records remaining.\n",
                prpcRecord,
                pstopByte,
                countRecords+1 ));
            DNS_ASSERT( FALSE );
            return( DNS_ERROR_INVALID_DATA );
        }

        //  if type not desired type, then not interesting

        if ( prpcRecord->wType != wType )
        {
            DNS_ASSERT( FALSE );
            return( DNS_ERROR_INVALID_DATA );
        }

        DNSDBG( RPC2, (
            "Checking record at %p for matching data of type %d.\n",
            prpcRecord,
            wType ));

        //
        //  check for data match, delete if match
        //

        switch ( wType )
        {
        case DNS_TYPE_A:

            ffound = ( prpcRecord->Data.A.ipAddress == ipHost );
            DNSDBG( RPC2, (
                "%s match between A record %lx and desired IP %lx\n",
                ffound ? "Found" : "No",
                prpcRecord->Data.A.ipAddress,
                ipHost ));
            break;

        case DNS_TYPE_MX:

            ffound = DnssrvMatchDnsRpcName(
                        & prpcRecord->Data.MX.nameExchange,
                        pszDataName );
            break;

        case DNS_TYPE_NS:
        case DNS_TYPE_CNAME:
        case DNS_TYPE_PTR:

            ffound = DnssrvMatchDnsRpcName(
                        & prpcRecord->Data.MX.nameExchange,
                        pszDataName );
            break;

        default:

            return( DNS_ERROR_INVALID_DATA );
        }

        if ( ffound )
        {
            DNSDBG( RPC2, (
                "Found record (handle = %p) with desired data\n"
                "\t... deleting record\n",
                prpcRecord->hRecord ));

            status = DnssrvDeleteRecord(
                        pwszServer,
                        szhost,
                        prpcRecord->hRecord );
            if ( status != ERROR_SUCCESS )
            {
                return( status );
            }

            //  shouldn't need to continue, as no duplicates allowed in general case
            //  however to rule out glue or WINS cached data, continue compare\delete
            //  until node is clear
        }

        //  position ourselves at next record

        pbyte = (PCHAR) DNS_GET_NEXT_RPC_RECORD( prpcRecord );

        //  continue looking for matching records
    }

    return( ERROR_SUCCESS );
}
#endif



DNS_STATUS
DNS_API_FUNCTION
DnssrvSbsDeleteRecord(
    IN      LPCWSTR     pwszServer,
    IN      LPCSTR      pszZone,
    IN      LPCSTR      pszDomain,
    IN      LPCSTR      pszOwner,
    IN      WORD        wType,
    IN      LPCSTR      pszDataName,
    IN      IP_ADDRESS  ipHost
    )
{
    DNS_STATUS  status;
    CHAR        szdomain[ DNS_MAX_NAME_BUFFER_LENGTH ];
    CHAR        szhost[ DNS_MAX_NAME_BUFFER_LENGTH ];

    DNSDBG( RPC2, ( "DnssrvSbsDeleteRecord()\n" ));

    //
    //  to register in ISP zone need to register
    //      - MX
    //      - CNAME for web server
    //      - host for web and mail server
    //
    //  build FQDN for domain and host and cname
    //      - do this now so we know names are valid
    //

    status = DnssrvConcatDnsNames(
                szdomain,
                pszZone,
                pszDomain );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    status = DnssrvConcatDnsNames(
                szhost,
                szdomain,
                pszOwner );
    if ( status != ERROR_SUCCESS )
    {
        return( status );
    }

    //
    //  dispatch to appropriate type delete routine
    //

    switch ( wType )
    {
    case DNS_TYPE_A:

        return  DnssrvDeleteARecord(
                    pwszServer,
                    szhost,
                    ipHost,
                    FALSE           // no notify suppress
                    );

    case DNS_TYPE_NS:

        return  DnssrvDeleteNsRecord(
                    pwszServer,
                    szhost,
                    pszDataName,
                    FALSE           // no notify suppress
                    );

    case DNS_TYPE_CNAME:

        return  DnssrvDeleteCnameRecord(
                    pwszServer,
                    szhost,
                    pszDataName,
                    FALSE           // no notify suppress
                    );

    case DNS_TYPE_MX:

        return  DnssrvDeleteMxRecord(
                    pwszServer,
                    szhost,
                    pszDataName,
                    (WORD) ipHost,
                    FALSE           // no notify suppress
                    );

    default:

        return( DNS_ERROR_INVALID_DATA );
    }

    return( ERROR_SUCCESS );
}


//
//  End sam.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\client\stub.c ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    stub.c

Abstract:

    Domain Name System (DNS) Server -- Admin Client API

    Client stubs for DNS API.
    These are stubs for NT5+ API.  NT4 API stubs are in nt4stub.c.

Author:

    Jim Gilroy (jamesg)     April 1997

Environment:

    User Mode - Win32

Revision History:

--*/


#include "dnsclip.h"

#if DBG
#include "rpcasync.h"
#endif


//
//  For versioning, we use a simple state machine in each function's
//  RPC exception block to try the new RPC call then the old RPC call.
//  If there is any RPC error, retry a downlevel operation.
//
//  This macro'ing is a bit overkill, but each RPC interface wrapper 
//  needs this retry logic.
//

#define DNS_RPC_RETRY_STATE()           iDnsRpcRetryState
#define DECLARE_DNS_RPC_RETRY_LABEL()   DnsRpcRetryLabel:

#define DECLARE_DNS_RPC_RETRY_STATE( status )               \
    INT DNS_RPC_RETRY_STATE() = 0;                          \
    status = dnsrpcInitializeTls()

//  Test return code to see if we need to retry for W2K remote RPC server.

#define ADVANCE_DNS_RPC_RETRY_STATE( dwStatus )             \
    if ( DNS_RPC_RETRY_STATE() == DNS_RPC_TRY_NEW &&        \
         dwStatus != RPC_S_SEC_PKG_ERROR &&                 \
        ( dwStatus == ERROR_SUCCESS ||                      \
            dwStatus == RPC_S_SERVER_UNAVAILABLE ||         \
            dwStatus < RPC_S_INVALID_STRING_BINDING ||      \
            dwStatus > RPC_X_BAD_STUB_DATA ) )              \
        DNS_RPC_RETRY_STATE() = DNS_RPC_TRY_DONE;           \
    else                                                    \
    {                                                       \
        dnsrpcSetW2KBindFlag( TRUE );                       \
        ++DNS_RPC_RETRY_STATE();                            \
    }

#define TEST_DNS_RPC_RETRY() \
    if ( DNS_RPC_RETRY_STATE() < DNS_RPC_TRY_DONE ) { goto DnsRpcRetryLabel; }

#define ASSERT_DNS_RPC_RETRY_STATE_VALID()                  \
    ASSERT( DNS_RPC_RETRY_STATE() == DNS_RPC_TRY_NEW ||     \
            DNS_RPC_RETRY_STATE() == DNS_RPC_TRY_OLD )

#define DNS_RPC_TRY_NEW     0
#define DNS_RPC_TRY_OLD     1
#define DNS_RPC_TRY_DONE    2



//
//  This macro is a safety helper for use in DnsRpc_ConvertToCurrent.
//
//  If header definitions change, DnsRpc_ConvertToCurrent can
//  start doing wacky things. Using memcpy instead of individual
//  assignments saves instructions but is potentially dangerous if
//  headers change and this function is not updated. Add ASSERTS
//  where possible to try and catch header changes that have not
//  been accounted for here. A general principal is that a structure
//  may grow but not shrink in size between versions.
//

#if DBG
    #define DNS_ASSERT_CURRENT_LARGER( structName )             \
        ASSERT( sizeof( DNS_RPC_##structName##_DOTNET ) >=      \
                sizeof( DNS_RPC_##structName##_W2K ) );

    #define DNS_ASSERT_RPC_STRUCTS_ARE_SANE()                   \
        {                                                       \
        static LONG     finit = 0;                              \
                                                                \
        if ( InterlockedIncrement( &finit ) != 1 )              \
        {                                                       \
            goto DoneDbgAsserts;                                \
        }                                                       \
                                                                \
        DNS_ASSERT_CURRENT_LARGER( SERVER_INFO );               \
        DNS_ASSERT_CURRENT_LARGER( FORWARDERS );                \
        DNS_ASSERT_CURRENT_LARGER( ZONE );                      \
        DNS_ASSERT_CURRENT_LARGER( ZONE_INFO );                 \
        DNS_ASSERT_CURRENT_LARGER( ZONE_SECONDARIES );          \
        DNS_ASSERT_CURRENT_LARGER( ZONE_DATABASE );             \
        DNS_ASSERT_CURRENT_LARGER( ZONE_TYPE_RESET );           \
        DNS_ASSERT_CURRENT_LARGER( ZONE_CREATE_INFO );          \
        DNS_ASSERT_CURRENT_LARGER( ZONE_LIST );                 \
        DNS_ASSERT_CURRENT_LARGER( SERVER_INFO );               \
        DNS_ASSERT_CURRENT_LARGER( FORWARDERS );                \
        DNS_ASSERT_CURRENT_LARGER( ZONE );                      \
        DNS_ASSERT_CURRENT_LARGER( ZONE_SECONDARIES );          \
        DNS_ASSERT_CURRENT_LARGER( ZONE_DATABASE );             \
        DNS_ASSERT_CURRENT_LARGER( ZONE_TYPE_RESET );           \
        DNS_ASSERT_CURRENT_LARGER( ZONE_LIST );                 \
                                                                \
        DoneDbgAsserts:     ;                                   \
        }
#else
    #define DNS_ASSERT_RPC_STRUCTS_ARE_SANE()
#endif  //  DBG


DWORD       g_bAttemptW2KRPCBindTlsIndex = TLS_OUT_OF_INDEXES;



DNS_STATUS
dnsrpcInitializeTls(
    VOID
    )
/*++

Routine Description:

    The W2K RPC bind global retry flag is stored in thread local
    storage. Each stub function must make certain that the TLS index
    is allocated before calling any RPC interface. Unfortunately there
    is no initialization function called by clients of DNSRPC.LIB
    where this can be done.
    
    NOTE: the TLS block is never freed. There is no convenient place
    to clean it up so for now just let it persist until process
    termination. This is harmless and is not a leak.

Arguments:

Return Value:

    On failure, there was a TLS error - likely too many TLS indices
    have been allocated in this process.

--*/
{
    static LONG     dnsrpcTlsInitialized = 0;
    DWORD           tlsIndex;
    DNS_STATUS      status = ERROR_SUCCESS;

    //
    //  Quick-check: already initialized?
    //
        
    if ( dnsrpcTlsInitialized )
    {
        goto Done;
    }
    
    //
    //  Safe-check for initialization. If two threads attempt to initialize
    //  at the same time the quick-check above may pass both. The safe check 
    //  will ensure that only one thread will actually perform initialization.
    //
    
    if ( InterlockedIncrement( &dnsrpcTlsInitialized ) != 1 )
    {
        InterlockedDecrement( &dnsrpcTlsInitialized );
        goto Done;
    }
    
    //
    //  Initialize the TLS index for the DNSRPC W2K retry flag.
    //
    
    tlsIndex = TlsAlloc();
    ASSERT( tlsIndex != TLS_OUT_OF_INDEXES );
    if ( tlsIndex == TLS_OUT_OF_INDEXES )
    {
        status = GetLastError();
        goto Done;
    }
    
    g_bAttemptW2KRPCBindTlsIndex = tlsIndex;
    
    //
    //  Provide initial flag value.
    //
    
    dnsrpcSetW2KBindFlag( FALSE );
    
    Done:
    
    return status;
}   //  dnsrpcInitializeTls



VOID
dnsrpcSetW2KBindFlag(
    BOOL        newFlagValue
    )
/*++

Routine Description:

    Sets the W2K bind retry flag in thread local storage.

Arguments:

    newFlagValue -- new flag value to be stored in TLS

Return Value:

--*/
{
    DWORD       tlsIndex = g_bAttemptW2KRPCBindTlsIndex;
    
    ASSERT( tlsIndex != TLS_OUT_OF_INDEXES );
    
    if ( tlsIndex != TLS_OUT_OF_INDEXES )
    {
        TlsSetValue( tlsIndex, ( LPVOID ) ( DWORD_PTR ) newFlagValue );
    }
}   //  dnsrpcSetW2KBindFlag



BOOL
dnsrpcGetW2KBindFlag(
    VOID
    )
/*++

Routine Description:

    Gets the W2K bind retry flag from thread local storage.

Arguments:

Return Value:

    The current value of this thread's W2K bind retry flag.

--*/
{
    DWORD       tlsIndex = g_bAttemptW2KRPCBindTlsIndex;
    
    ASSERT( tlsIndex != TLS_OUT_OF_INDEXES );
    
    if ( tlsIndex == TLS_OUT_OF_INDEXES )
    {
        return FALSE;
    }
    else
    {
        return ( BOOL ) ( DWORD_PTR ) TlsGetValue( tlsIndex );
    }
}   //  dnsrpcSetW2KBindFlag



VOID
printExtendedRpcErrorInfo(
    DNS_STATUS      externalStatus
    )
/*++

Routine Description:

    Prints extended RPC error information to console.

Arguments:

Return Value:

--*/
{
#if DBG    
    DBG_FN( "RpcError" )

    RPC_STATUS              status;
    RPC_ERROR_ENUM_HANDLE   enumHandle;

    if ( externalStatus == ERROR_SUCCESS )
    {
        return;
    }

    status = RpcErrorStartEnumeration( &enumHandle );
    if ( status != RPC_S_OK )
    {
        printf( "%s: error %d retrieving RPC error information\n", fn, status );
    }
    else
    {
        RPC_EXTENDED_ERROR_INFO     errorInfo;
        int                         records;
        BOOL                        result;
        BOOL                        copyStrings = TRUE;
        BOOL                        fuseFileTime = TRUE;
        SYSTEMTIME *                systemTimeToUse;
        SYSTEMTIME                  systemTimeBuffer;

        while ( status == RPC_S_OK )
        {
            errorInfo.Version = RPC_EEINFO_VERSION;
            errorInfo.Flags = 0;
            errorInfo.NumberOfParameters = 4;
            if ( fuseFileTime )
            {
                errorInfo.Flags |= EEInfoUseFileTime;
            }

            status = RpcErrorGetNextRecord( &enumHandle, copyStrings, &errorInfo );
            if ( status == RPC_S_ENTRY_NOT_FOUND )
            {
                break;
            }
            else if ( status != RPC_S_OK )
            {
                printf( "%s: error %d during error info enumeration\n", fn, status );
                break;
            }
            else
            {
                int     i;

                if ( errorInfo.ComputerName )
                {
                    printf( "%s: ComputerName %S\n", fn, errorInfo.ComputerName );
                    if ( copyStrings )
                    {
                        result = HeapFree( GetProcessHeap(), 0, errorInfo.ComputerName );
                        ASSERT( result );
                    }
                }
                printf( "ProcessID is %d\n", errorInfo.ProcessID );
                if ( fuseFileTime )
                {
                    result = FileTimeToSystemTime(
                                    &errorInfo.u.FileTime,
                                    &systemTimeBuffer);
                    ASSERT( result );
                    systemTimeToUse = &systemTimeBuffer;
                }
                else
                {
                    systemTimeToUse = &errorInfo.u.SystemTime;
                }

                printf(
                    "System Time is: %d/%d/%d %d:%d:%d:%d\n", 
                    systemTimeToUse->wMonth,
                    systemTimeToUse->wDay,
                    systemTimeToUse->wYear,
                    systemTimeToUse->wHour,
                    systemTimeToUse->wMinute,
                    systemTimeToUse->wSecond,
                    systemTimeToUse->wMilliseconds );
                    
                printf( "Generating component is %d\n", errorInfo.GeneratingComponent );
                printf( "Status is %d\n", errorInfo.Status );
                printf( "Detection location is %d\n", ( int ) errorInfo.DetectionLocation );
                printf( "Flags is %d\n", errorInfo.Flags );
                printf( "NumberOfParameters is %d\n", errorInfo.NumberOfParameters );

                for ( i = 0; i < errorInfo.NumberOfParameters; ++i )
                {
                    switch( errorInfo.Parameters[i].ParameterType )
                    {
                        case eeptAnsiString:
                            printf( "Ansi string: %s\n", 
                                        errorInfo.Parameters[i].u.AnsiString );
                            if ( copyStrings )
                            {
                                result = HeapFree( GetProcessHeap(),
                                                   0, 
                                                   errorInfo.Parameters[i].u.AnsiString );
                                ASSERT( result );
                            }
                            break;

                        case eeptUnicodeString:
                            printf( "Unicode string: %S\n", 
                                        errorInfo.Parameters[i].u.UnicodeString );
                            if ( copyStrings )
                            {
                                result = HeapFree(
                                            GetProcessHeap(),
                                            0, 
                                            errorInfo.Parameters[i].u.UnicodeString );
                                ASSERT( result );
                            }
                            break;

                        case eeptLongVal:
                            printf( "Long val: %d\n", errorInfo.Parameters[i].u.LVal );
                            break;

                        case eeptShortVal:
                            printf( "Short val: %d\n", ( int ) errorInfo.Parameters[i].u.SVal );
                            break;

                        case eeptPointerVal:
                            printf( "Pointer val: %d\n", errorInfo.Parameters[i].u.PVal );
                            break;

                        case eeptNone:
                            printf( "Truncated\n" );
                            break;

                        default:
                            printf( "Invalid type: %d\n", errorInfo.Parameters[i].ParameterType );
                            break;
                    }
                }
            }
        }
        RpcErrorEndEnumeration( &enumHandle );
    }
#endif
}   //  printExtendedRpcErrorInfo



DNS_STATUS
DNS_API_FUNCTION
DnsRpc_ConvertToCurrent(
    IN      PDWORD      pdwTypeId,          IN  OUT
    IN      PVOID *     ppData              IN  OUT
    )
/*++

Routine Description:

    Takes any DNS RPC structure as input and if necessary fabricates
    the latest revision of that structure from the members of the input
    structure.

    If a new structure is allocated, the old one is freed and the pointer
    value at ppData is replaced. Allocated points within the old struct
    will be freed or copied to the new struct. Basically, the client
    does not have to worry about freeing any part of the old struct. When
    he's done with the new struct he has to free it and it's members, as
    usual.

    There are two main uses of this function:

    -   If an old client sends the DNS server an input structure, such as
        ZONE_CREATE, the new DNS server can use this function to update
        the structure so that it can be processed.
    -   If an old server sends the DNS RPC client an output structure, such
        as SERVER_INFO, the new DNS RPC client can use this function to
        update the structure so that it can be processed.

Arguments:

    pdwTypeId - type ID of object pointed to by ppData, value may be
        changed to type ID of new object at ppData

    ppData - pointer to object, pointer may be replaced by a pointer to
        a newly allocated, completed different structure as required

Return Value:

    ERROR_SUCCESS or error code. If return code is not ERROR_SUCCESS, there
    has been some kind of fatal error. Assume data invalid in this case.

--*/
{
    DBG_FN( "DnsRpc_ConvertToCurrent" )

    DNS_STATUS      status = ERROR_SUCCESS;
    DWORD           dwtypeIn = -1;
    PVOID           pdataIn = NULL;
    DWORD           dwtypeOut = -1;
    PVOID           pdataOut = NULL;
    DWORD           i;

    if ( !pdwTypeId || !ppData )
    {
        ASSERT( pdwTypeId && ppData );
        status = ERROR_INVALID_DATA;
        goto NoTranslation;
    }

    //
    //  Shortcuts: do not translate NULL or certain common types.
    //

    if ( *pdwTypeId < DNSSRV_TYPEID_SERVER_INFO_W2K || *ppData == NULL )
    {
        goto NoTranslation;
    }

    dwtypeOut = dwtypeIn = *pdwTypeId;
    pdataOut = pdataIn = *ppData;

    DNS_ASSERT_RPC_STRUCTS_ARE_SANE();

    //
    //  Handy macros to make allocating the differently sized structs easy.
    //

    #define ALLOCATE_RPC_BYTES( ptr, byteCount )                \
        ptr = MIDL_user_allocate( byteCount );                  \
        if ( ptr == NULL )                                      \
            {                                                   \
            status = DNS_ERROR_NO_MEMORY;                       \
            goto Done;                                          \
            }                                                   \
        RtlZeroMemory( ptr, byteCount );

    #define ALLOCATE_RPC_STRUCT( ptr, structType )              \
        ALLOCATE_RPC_BYTES( ptr, sizeof( structType ) );

    #define DNS_DOTNET_VERSION_SIZE   ( 2 * sizeof( DWORD ) )

    //
    //  Giant switch statement of all types that are no longer current.
    //
    //  Add to this switch as we create more versions of types. The idea 
    //  is to convert any structure from an old server to the 
    //  corresponding current version so that the RPC client doesn't
    //  have to worry about multiple versions of the structures.
    //

    switch ( dwtypeIn )
    {
        case DNSSRV_TYPEID_SERVER_INFO_W2K:

            //
            //  Do a member-by-member copy so .NET is not contrained
            //  by the W2K structure layout.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_SERVER_INFO_DOTNET );

            #define MEMBERCOPY( _Member )                                   \
                ( ( PDNS_RPC_SERVER_INFO_DOTNET ) pdataOut )->_Member =     \
                ( ( PDNS_RPC_SERVER_INFO_W2K ) pdataIn )->_Member

            MEMBERCOPY( dwVersion );
            MEMBERCOPY( fAdminConfigured );
            MEMBERCOPY( fAllowUpdate );
            MEMBERCOPY( fDsAvailable );
            MEMBERCOPY( pszServerName );
            MEMBERCOPY( pszDsContainer );
            MEMBERCOPY( aipServerAddrs );
            MEMBERCOPY( aipListenAddrs );
            MEMBERCOPY( aipForwarders );
            MEMBERCOPY( dwLogLevel );
            MEMBERCOPY( dwDebugLevel );
            MEMBERCOPY( dwForwardTimeout );
            MEMBERCOPY( dwRpcProtocol );
            MEMBERCOPY( dwNameCheckFlag );
            MEMBERCOPY( cAddressAnswerLimit );
            MEMBERCOPY( dwRecursionTimeout );
            MEMBERCOPY( dwMaxCacheTtl );
            MEMBERCOPY( dwDsPollingInterval );
            MEMBERCOPY( dwScavengingInterval );
            MEMBERCOPY( dwDefaultRefreshInterval );
            MEMBERCOPY( dwDefaultNoRefreshInterval );
            MEMBERCOPY( fAutoReverseZones );
            MEMBERCOPY( fAutoCacheUpdate );
            MEMBERCOPY( fSlave );
            MEMBERCOPY( fForwardDelegations );
            MEMBERCOPY( fNoRecursion );
            MEMBERCOPY( fSecureResponses );
            MEMBERCOPY( fRoundRobin );
            MEMBERCOPY( fLocalNetPriority );
            MEMBERCOPY( fBindSecondaries );
            MEMBERCOPY( fWriteAuthorityNs );
            MEMBERCOPY( fStrictFileParsing );
            MEMBERCOPY( fLooseWildcarding );
            MEMBERCOPY( fDefaultAgingState );
            MEMBERCOPY( dwMaxCacheTtl );
            MEMBERCOPY( dwMaxCacheTtl );

            dwtypeOut = DNSSRV_TYPEID_SERVER_INFO;
            break;

        case DNSSRV_TYPEID_FORWARDERS_W2K:

            //
            //  Structures are identical except for dwRpcStructureVersion.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_FORWARDERS_DOTNET );
            RtlCopyMemory( 
                ( PBYTE ) pdataOut + DNS_DOTNET_VERSION_SIZE,
                pdataIn,
                sizeof( DNS_RPC_FORWARDERS_W2K ) );
            ( ( PDNS_RPC_FORWARDERS_DOTNET ) pdataOut )->
                dwRpcStructureVersion = DNS_RPC_FORWARDERS_VER;
            dwtypeOut = DNSSRV_TYPEID_FORWARDERS;
            break;

        case DNSSRV_TYPEID_ZONE_W2K:

            //
            //  Structures are identical except for dwRpcStructureVersion.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_DOTNET );
            RtlCopyMemory( 
                ( PBYTE ) pdataOut + DNS_DOTNET_VERSION_SIZE,
                pdataIn,
                sizeof( DNS_RPC_ZONE_W2K ) );
            ( ( PDNS_RPC_ZONE_DOTNET ) pdataOut )->
                dwRpcStructureVersion = DNS_RPC_ZONE_VER;
            dwtypeOut = DNSSRV_TYPEID_ZONE;
            break;

        case DNSSRV_TYPEID_ZONE_INFO_W2K:

            //
            //  .NET structure is larger and has new fields for
            //  forwarder zones, stub zones, directory partitions, etc.
            //  The structures are identical up to the beginning of
            //  the reserved DWORDs at the end of the W2K structure.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_INFO_DOTNET );
            RtlZeroMemory( pdataOut, sizeof( DNS_RPC_ZONE_INFO_DOTNET ) );
            RtlCopyMemory( 
                ( PBYTE ) pdataOut + DNS_DOTNET_VERSION_SIZE,
                pdataIn,
                sizeof( DNS_RPC_ZONE_INFO_W2K ) );
            ( ( PDNS_RPC_ZONE_INFO_DOTNET ) pdataOut )->
                dwRpcStructureVersion = DNS_RPC_ZONE_VER;
            dwtypeOut = DNSSRV_TYPEID_ZONE_INFO;
            break;

        case DNSSRV_TYPEID_ZONE_SECONDARIES_W2K:

            //
            //  Structures are identical except for dwRpcStructureVersion.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_SECONDARIES_DOTNET );
            RtlCopyMemory( 
                ( PBYTE ) pdataOut + DNS_DOTNET_VERSION_SIZE,
                pdataIn,
                sizeof( DNS_RPC_ZONE_SECONDARIES_W2K ) );
            ( ( PDNS_RPC_ZONE_SECONDARIES_DOTNET ) pdataOut )->
                dwRpcStructureVersion = DNS_RPC_ZONE_SECONDARIES_VER;
            dwtypeOut = DNSSRV_TYPEID_ZONE_SECONDARIES;
            break;

        case DNSSRV_TYPEID_ZONE_DATABASE_W2K:

            //
            //  Structures are identical except for dwRpcStructureVersion.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_DATABASE_DOTNET );
            RtlCopyMemory( 
                ( PBYTE ) pdataOut + DNS_DOTNET_VERSION_SIZE,
                pdataIn,
                sizeof( DNS_RPC_ZONE_DATABASE_W2K ) );
            ( ( PDNS_RPC_ZONE_DATABASE_DOTNET ) pdataOut )->
                dwRpcStructureVersion = DNS_RPC_ZONE_DATABASE_VER;
            dwtypeOut = DNSSRV_TYPEID_ZONE_DATABASE;
            break;

        case DNSSRV_TYPEID_ZONE_TYPE_RESET_W2K:

            //
            //  Structures are identical except for dwRpcStructureVersion.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_TYPE_RESET_DOTNET );
            RtlCopyMemory( 
                ( PBYTE ) pdataOut + DNS_DOTNET_VERSION_SIZE,
                pdataIn,
                sizeof( DNS_RPC_ZONE_TYPE_RESET_W2K ) );
            ( ( PDNS_RPC_ZONE_TYPE_RESET_DOTNET ) pdataOut )->
                dwRpcStructureVersion = DNS_RPC_ZONE_TYPE_RESET_VER;
            dwtypeOut = DNSSRV_TYPEID_ZONE_TYPE_RESET;
            break;

        case DNSSRV_TYPEID_ZONE_CREATE_W2K:

            //
            //  Structures are identical except for dwRpcStructureVersion
            //  and some usage in .NET of reserved W2K fields. No
            //  need to be concerned about the newly used reserved, they
            //  will be NULL in the W2K structure.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_CREATE_INFO_DOTNET );
            RtlCopyMemory( 
                ( PBYTE ) pdataOut + DNS_DOTNET_VERSION_SIZE,
                pdataIn,
                sizeof( DNS_RPC_ZONE_CREATE_INFO_W2K ) );
            ( ( PDNS_RPC_ZONE_CREATE_INFO_DOTNET ) pdataOut )->
                dwRpcStructureVersion = DNS_RPC_ZONE_CREATE_INFO_VER;
            dwtypeOut = DNSSRV_TYPEID_ZONE_CREATE;
            break;

        case DNSSRV_TYPEID_ZONE_LIST_W2K:
        {
            DWORD                           dwzoneCount;
            DWORD                           dwzonePtrCount;
            PDNS_RPC_ZONE_LIST_DOTNET       pzonelistDotNet;
            PDNS_RPC_ZONE_LIST_W2K          pzonelistW2K;

            //
            //  Structures are identical except for dwRpcStructureVersion.
            //  Note: there is always at least one pointer, even if the
            //  zone count is zero.
            //

            pzonelistW2K = ( PDNS_RPC_ZONE_LIST_W2K ) pdataIn;

            dwzoneCount = dwzonePtrCount = pzonelistW2K->dwZoneCount;
            if ( dwzonePtrCount > 0 )
            {
                --dwzonePtrCount;   //  num ptrs after ZONE_LIST struct
            }
            ALLOCATE_RPC_BYTES(
                pzonelistDotNet,
                sizeof( DNS_RPC_ZONE_LIST_DOTNET ) +
                    sizeof( PDNS_RPC_ZONE_DOTNET ) * dwzonePtrCount );
            pdataOut = pzonelistDotNet;
            RtlCopyMemory( 
                ( PBYTE ) pzonelistDotNet + DNS_DOTNET_VERSION_SIZE,
                pzonelistW2K,
                sizeof( DNS_RPC_ZONE_LIST_W2K ) +
                    sizeof( PDNS_RPC_ZONE_W2K ) * dwzonePtrCount );
            pzonelistDotNet->dwRpcStructureVersion = DNS_RPC_ZONE_LIST_VER;
            dwtypeOut = DNSSRV_TYPEID_ZONE_LIST;

            //
            //  The zone array must also be converted. Count the new zones
            //  as they are successfully created so that if there's an error
            //  converting one zone we will still have a coherent structure.
            //

            pzonelistDotNet->dwZoneCount = 0;
            for ( i = 0; status == ERROR_SUCCESS && i < dwzoneCount; ++i )
            {
                DWORD       dwtype = DNSSRV_TYPEID_ZONE_W2K;

                status = DnsRpc_ConvertToCurrent(
                                &dwtype, 
                                &pzonelistDotNet->ZoneArray[ i ] );
                if ( status != ERROR_SUCCESS )
                {
                    ASSERT( status == ERROR_SUCCESS );
                    break;
                }
                ASSERT( dwtype == DNSSRV_TYPEID_ZONE );
                ++pzonelistDotNet->dwZoneCount;
            }

            break;
        }

        default:
            break;      //  This struct requires no translation.
    }

    //
    //  Cleanup and return.
    //

    Done:

    if ( pdwTypeId )
    {
        *pdwTypeId = dwtypeOut;
    }
    if ( ppData )
    {
        *ppData = pdataOut;
    }

    NoTranslation:

    DNSDBG( STUB, (
        "%s: status=%d\n  type in=%d out=%d\n  pdata in=%p out=%p\n", fn,
        status,
        dwtypeIn,
        dwtypeOut,
        pdataIn,
        *ppData ));

    return status;
}   //  DnsRpc_ConvertToCurrent



DNS_STATUS
DNS_API_FUNCTION
DnsRpc_ConvertToUnversioned(
    IN      PDWORD      pdwTypeId,              IN  OUT
    IN      PVOID *     ppData,                 IN  OUT
    IN      BOOL *      pfAllocatedRpcStruct    OUT OPTIONAL
    )
/*++

Routine Description:

    Takes any DNS RPC structure as input and if necessary fabricates
    the old-style unversioned revision of that structure from the members
    of the input structure. This function is cousin to
    DnsRpc_ConvertToCurrent.

    If a new structure is allocated, the old one is freed and the pointer
    value at ppData is replaced. Allocated points within the old struct
    will be freed or copied to the new struct. Basically, the client
    does not have to worry about freeing any part of the old struct. When
    he's done with the new struct he has to free it and it's members, as
    usual.

    The main use of this function is to allow a new client to send 
    a new RPC structure (e.g. a ZONE_CREATE structure) to an old DNS
    server transparently. This function will attempt to make intelligent
    decisions about what to do if there are large functional differences
    in the old and new structures.

Arguments:

    pdwTypeId - type ID of object pointed to by ppData, value may be
        changed to type ID of new object at ppData

    ppData - pointer to object, pointer may be replaced by a pointer to
        a newly allocated, completed different structure as required

    pfAllocatedRpcStruct - if not NULL, value is set to TRUE if
        a new structure is allocated by this function - the should request
        this information if it needs to know if it should free the
        replaced pData pointer using MIDL_user_free()

Return Value:

    ERROR_SUCCESS or error code. If return code is not ERROR_SUCCESS, there
    has been some kind of fatal error. Assume data invalid in this case.

--*/
{
    DBG_FN( "DnsRpc_ConvertToUnversioned" )

    DNS_STATUS      status = ERROR_SUCCESS;
    BOOL            fallocatedRpcStruct = FALSE;
    DWORD           dwtypeIn = -1;
    PVOID           pdataIn = NULL;
    DWORD           dwtypeOut = -1;
    PVOID           pdataOut = NULL;
    DWORD           i;

    if ( !pdwTypeId || !ppData )
    {
        ASSERT( pdwTypeId && ppData );
        status = ERROR_INVALID_DATA;
        goto NoTranslation;
    }

    //
    //  Shortcuts: do not translate NULL, any structure that is not 
    //  versioned, or any structure that is already in unversioned
    //  format.
    //

    if ( *pdwTypeId <= DNSSRV_TYPEID_ZONE_LIST_W2K || *ppData == NULL )
    {
        goto NoTranslation;
    }

    dwtypeOut = dwtypeIn = *pdwTypeId;
    pdataOut = pdataIn = *ppData;
    fallocatedRpcStruct = TRUE;

    //
    //  Giant switch statement of all types that can be downleveled.
    //

    switch ( dwtypeIn )
    {
        case DNSSRV_TYPEID_FORWARDERS:

            //
            //  Structures are identical except for dwRpcStructureVersion.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_FORWARDERS_W2K );
            RtlCopyMemory( 
                pdataOut,
                ( PBYTE ) pdataIn + DNS_DOTNET_VERSION_SIZE,
                sizeof( DNS_RPC_FORWARDERS_W2K ) );
            dwtypeOut = DNSSRV_TYPEID_FORWARDERS_W2K;
            break;

        case DNSSRV_TYPEID_ZONE_CREATE:

            //
            //  .NET has several additional members.
            //

            {
            PDNS_RPC_ZONE_CREATE_INFO_W2K   pzoneOut;
            PDNS_RPC_ZONE_CREATE_INFO       pzoneIn = pdataIn;
            
            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_CREATE_INFO_W2K );
            pzoneOut = pdataOut;
            pzoneOut->pszZoneName = pzoneIn->pszZoneName;
            pzoneOut->dwZoneType = pzoneIn->dwZoneType;
            pzoneOut->fAllowUpdate = pzoneIn->fAllowUpdate;
            pzoneOut->fAging = pzoneIn->fAging;
            pzoneOut->dwFlags = pzoneIn->dwFlags;
            pzoneOut->pszDataFile = pzoneIn->pszDataFile;
            pzoneOut->fDsIntegrated = pzoneIn->fDsIntegrated;
            pzoneOut->fLoadExisting = pzoneIn->fLoadExisting;
            pzoneOut->pszAdmin = pzoneIn->pszAdmin;
            pzoneOut->aipMasters = pzoneIn->aipMasters;
            pzoneOut->aipSecondaries = pzoneIn->aipSecondaries;
            pzoneOut->fSecureSecondaries = pzoneIn->fSecureSecondaries;
            pzoneOut->fNotifyLevel = pzoneIn->fNotifyLevel;
            dwtypeOut = DNSSRV_TYPEID_ZONE_CREATE_W2K;
            break;
            }

        case DNSSRV_TYPEID_ZONE_TYPE_RESET:

            //
            //  Structures are identical except for dwRpcStructureVersion.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_TYPE_RESET_W2K );
            RtlCopyMemory( 
                pdataOut,
                ( PBYTE ) pdataIn + DNS_DOTNET_VERSION_SIZE,
                sizeof( DNS_RPC_ZONE_TYPE_RESET_W2K ) );
            dwtypeOut = DNSSRV_TYPEID_ZONE_TYPE_RESET_W2K;
            break;

        case DNSSRV_TYPEID_ZONE_SECONDARIES:

            //
            //  Structures are identical except for dwRpcStructureVersion.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_SECONDARIES_W2K );
            RtlCopyMemory( 
                pdataOut,
                ( PBYTE ) pdataIn + DNS_DOTNET_VERSION_SIZE,
                sizeof( DNS_RPC_ZONE_SECONDARIES_W2K ) );
            dwtypeOut = DNSSRV_TYPEID_ZONE_SECONDARIES_W2K;
            break;

        case DNSSRV_TYPEID_ZONE_DATABASE:

            //
            //  Structures are identical except for dwRpcStructureVersion.
            //

            ALLOCATE_RPC_STRUCT( pdataOut, DNS_RPC_ZONE_DATABASE_W2K );
            RtlCopyMemory( 
                pdataOut,
                ( PBYTE ) pdataIn + DNS_DOTNET_VERSION_SIZE,
                sizeof( DNS_RPC_ZONE_DATABASE_W2K ) );
            dwtypeOut = DNSSRV_TYPEID_ZONE_DATABASE_W2K;
            break;

        default:
            fallocatedRpcStruct = FALSE;
            break;      //  Unknown - do nothing.
    }

    //
    //  Cleanup and return.
    //

    Done:

    if ( pdwTypeId )
    {
        *pdwTypeId = dwtypeOut;
    }
    if ( ppData )
    {
        *ppData = pdataOut;
    }

    NoTranslation:

    if ( pfAllocatedRpcStruct )
    {
        *pfAllocatedRpcStruct = fallocatedRpcStruct;
    }

    DNSDBG( STUB, (
        "%s: status=%d\n  type in=%d out=%d\n  pdata in=%p out=%p\n", fn,
        status,
        dwtypeIn,
        dwtypeOut,
        pdataIn,
        *ppData ));

    return status;
}   //  DnsRpc_ConvertToUnversioned


//
//  RPC functions
//

  

DNS_STATUS
DNS_API_FUNCTION
DnssrvOperationEx(
    IN      DWORD       dwClientVersion,
    IN      DWORD       dwSettingFlags,
    IN      LPCWSTR     Server,
    IN      LPCSTR      pszZone,
    IN      DWORD       dwContext,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeId,
    IN      PVOID       pData
    )
{
    DNS_STATUS          status;
    DNSSRV_RPC_UNION    rpcData;
    BOOL                fallocatedRpcStruct = FALSE;

    DECLARE_DNS_RPC_RETRY_STATE( status );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    rpcData.Null = pData;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvOperationEx()\n"
            "\tClient ver   = 0x%X\n"
            "\tServer       = %S\n"
            "\tZone         = %s\n"
            "\tContext      = %p\n"
            "\tOperation    = %s\n"
            "\tTypeid       = %d\n",
            dwClientVersion,
            Server,
            pszZone,
            dwContext,
            pszOperation,
            dwTypeId ));

        IF_DNSDBG( STUB2 )
        {
            DnsDbg_RpcUnion(
                "pData for R_DnssrvOperationEx ",
                dwTypeId,
                rpcData.Null );
        }
    }

#if 0
    //  generate multizone context?
    //
    //  DEVNOTE: get this working

    if ( pszZone )
    {
        dwContext = DnssrvGenerateZoneOperationContext( pszZone, dwContext );
    }
#endif

    DECLARE_DNS_RPC_RETRY_LABEL()

    RpcTryExcept
    {
        ASSERT_DNS_RPC_RETRY_STATE_VALID();

        if ( DNS_RPC_RETRY_STATE() == DNS_RPC_TRY_NEW )
        {
            status = R_DnssrvOperation2(
                        dwClientVersion,
                        dwSettingFlags,
                        Server,
                        pszZone,
                        dwContext,
                        pszOperation,
                        dwTypeId,
                        rpcData );
        }
        else
        {
            status = R_DnssrvOperation(
                        Server,
                        pszZone,
                        dwContext,
                        pszOperation,
                        dwTypeId,
                        rpcData );
        }
        
        ADVANCE_DNS_RPC_RETRY_STATE( status );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "Leave R_DnssrvOperation():  status %d (%p)\n",
                status, status ));
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d (%p)\n",
                status, status ));
        }

        //
        //  For downlevel server, attempt to construct old-style data.
        //

        DnsRpc_ConvertToUnversioned( &dwTypeId, &pData, &fallocatedRpcStruct ); 
        rpcData.Null = pData;

        ADVANCE_DNS_RPC_RETRY_STATE( status );
    }
    RpcEndExcept

    TEST_DNS_RPC_RETRY();

    printExtendedRpcErrorInfo( status );

    if ( fallocatedRpcStruct )
    {
        MIDL_user_free( pData );
    }

    return status;
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvQueryEx(
    IN      DWORD       dwClientVersion,
    IN      DWORD       dwSettingFlags,
    IN      LPCWSTR     Server,
    IN      LPCSTR      pszZone,
    IN      LPCSTR      pszQuery,
    OUT     PDWORD      pdwTypeId,
    OUT     PVOID *     ppData
    )
{
    DNS_STATUS      status;

    DECLARE_DNS_RPC_RETRY_STATE( status );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvQuery()\n"
            "\tClient ver   = 0x%X\n"
            "\tServer       = %S\n"
            "\tZone         = %s\n"
            "\tQuery        = %s\n",
            dwClientVersion,
            Server,
            pszZone,
            pszQuery ));

        DNSDBG( STUB2, (
            "\tpdwTypeId    = %p\n"
            "\tppData       = %p\n"
            "\t*pdwTypeId   = %d\n"
            "\t*ppData      = %p\n",
            pdwTypeId,
            ppData,
            *pdwTypeId,
            *ppData ));
    }

    if ( !pszQuery || !ppData || !pdwTypeId )
    {
        DNS_ASSERT( FALSE );
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  RPC sees ppData as actually a PTR to a UNION structure, and
    //  for pointer type returns, would like to copy the data back into the
    //  memory pointed at by the current value of the pointer.
    //
    //  This is not what we want, we just want to capture a pointer to
    //  the returned data block.  To do this init the pointer value to
    //  be NULL, so RPC will then allocate memory of all pointer types
    //  in the UNION.
    //

    *ppData = NULL;

    DECLARE_DNS_RPC_RETRY_LABEL()

    RpcTryExcept
    {
        ASSERT_DNS_RPC_RETRY_STATE_VALID();

        if ( DNS_RPC_RETRY_STATE() == DNS_RPC_TRY_NEW )
        {
            status = R_DnssrvQuery2(
                        dwClientVersion,
                        dwSettingFlags,
                        Server,
                        pszZone,
                        pszQuery,
                        pdwTypeId,
                        ( DNSSRV_RPC_UNION * ) ppData );
        }
        else
        {
            status = R_DnssrvQuery(
                        Server,
                        pszZone,
                        pszQuery,
                        pdwTypeId,
                        ( DNSSRV_RPC_UNION * ) ppData );
        }
        ADVANCE_DNS_RPC_RETRY_STATE( status );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "Leave R_DnssrvQuery():  status %d (%p)\n"
                "\tTypeId   = %d\n"
                "\tDataPtr  = %p\n",
                status, status,
                *pdwTypeId,
                *ppData ));

            if ( ppData )
            {
                DnsDbg_RpcUnion(
                    "After R_DnssrvQuery ...\n",
                    *pdwTypeId,
                    *ppData );
            }
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d (%p)\n",
                status, status ));
        }
        ADVANCE_DNS_RPC_RETRY_STATE( status );
    }
    RpcEndExcept

    TEST_DNS_RPC_RETRY();

    //
    //  Upgrade old structure to new.
    //

    printExtendedRpcErrorInfo( status );

    if ( status == ERROR_SUCCESS )
    {
        status = DnsRpc_ConvertToCurrent( pdwTypeId, ppData ); 
    }
    
    return status;
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvComplexOperationEx(
    IN      DWORD       dwClientVersion,
    IN      DWORD       dwSettingFlags,
    IN      LPCWSTR     Server,
    IN      LPCSTR      pszZone,
    IN      LPCSTR      pszOperation,
    IN      DWORD       dwTypeIn,
    IN      PVOID       pDataIn,
    OUT     PDWORD      pdwTypeOut,
    OUT     PVOID *     ppDataOut
    )
{
    DNS_STATUS          status;
    DNSSRV_RPC_UNION    rpcData;

    DECLARE_DNS_RPC_RETRY_STATE( status );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    rpcData.Null = pDataIn;

    IF_DNSDBG( STUB )
    {
        DNS_PRINT((
            "Enter DnssrvComplexOperation()\n"
            "\tClient ver   = 0x%X\n"
            "\tServer       = %S\n"
            "\tZone         = %s\n"
            "\tOperation    = %s\n"
            "\tTypeIn       = %d\n",
            dwClientVersion,
            Server,
            pszZone,
            pszOperation,
            dwTypeIn ));

        IF_DNSDBG( STUB2 )
        {
            DnsDbg_RpcUnion(
                "pData for R_DnssrvOperation ",
                dwTypeIn,
                rpcData.Null );

            DNS_PRINT((
                "\tpdwTypeOut    = %p\n"
                "\tppDataOut     = %p\n"
                "\t*pdwTypeOut   = %d\n"
                "\t*ppDataOut    = %p\n",
                pdwTypeOut,
                ppDataOut,
                *pdwTypeOut,
                *ppDataOut ));
        }
    }

    if ( !pszOperation || !ppDataOut || !pdwTypeOut )
    {
        DNS_ASSERT( FALSE );
        return( ERROR_INVALID_PARAMETER );
    }

    //
    //  RPC sees ppDataOut as actually a PTR to a UNION structure, and
    //  for pointer type returns, would like to copy the data back into
    //  the memory pointed at by the current value of the pointer.
    //
    //  This is not what we want, we just want to capture a pointer to
    //  the returned data block.  To do this init the pointer value to
    //  be NULL, so RPC will then allocate memory of all pointer types
    //  in the UNION.
    //

    *ppDataOut = NULL;

    DECLARE_DNS_RPC_RETRY_LABEL()

    RpcTryExcept
    {
        ASSERT_DNS_RPC_RETRY_STATE_VALID();

        if ( DNS_RPC_RETRY_STATE() == DNS_RPC_TRY_NEW )
        {
            status = R_DnssrvComplexOperation2(
                        dwClientVersion,
                        dwSettingFlags,
                        Server,
                        pszZone,
                        pszOperation,
                        dwTypeIn,
                        rpcData,
                        pdwTypeOut,
                        ( DNSSRV_RPC_UNION * ) ppDataOut );
        }
        else
        {
            status = R_DnssrvComplexOperation(
                        Server,
                        pszZone,
                        pszOperation,
                        dwTypeIn,
                        rpcData,
                        pdwTypeOut,
                        ( DNSSRV_RPC_UNION * ) ppDataOut );
        }
        ADVANCE_DNS_RPC_RETRY_STATE( status );
        
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "Leave R_DnssrvComplexOperation():  status %d (%p)\n"
                "\tTypeId   = %d\n"
                "\tDataPtr  = %p\n",
                status, status,
                *pdwTypeOut,
                *ppDataOut ));

            if ( ppDataOut )
            {
                DnsDbg_RpcUnion(
                    "After R_DnssrvQuery ...\n",
                    *pdwTypeOut,
                    *ppDataOut );
            }
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d (%p)\n",
                status, status ));
        }
        ADVANCE_DNS_RPC_RETRY_STATE( status );
    }
    RpcEndExcept

    TEST_DNS_RPC_RETRY();

    printExtendedRpcErrorInfo( status );

    //
    //  Upgrade old structure to new.
    //

    if ( status == ERROR_SUCCESS )
    {
        status = DnsRpc_ConvertToCurrent( pdwTypeOut, ppDataOut ); 
    }
    
    return status;
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvEnumRecordsEx(
    IN      DWORD       dwClientVersion,
    IN      DWORD       dwSettingFlags,
    IN      LPCWSTR     Server,
    IN      LPCSTR      pszZoneName,
    IN      LPCSTR      pszNodeName,
    IN      LPCSTR      pszStartChild,
    IN      WORD        wRecordType,
    IN      DWORD       dwSelectFlag,
    IN      LPCSTR      pszFilterStart,
    IN      LPCSTR      pszFilterStop,
    IN OUT  PDWORD      pdwBufferLength,
    OUT     PBYTE *     ppBuffer
    )
/*++

Routine Description:

    Stub for EnumRecords API.

    Note, this matches DnssrvEnumRecords() API exactly.
    The "Stub" suffix is attached to distinguish from the actual
    DnssrvEnumRecords() (remote.c) which handles NT4 server compatibility.
    When that is no longer desired, that routine may be eliminated and
    this the "Stub" suffix removed from this routine.

Arguments:

Return Value:

    ERROR_SUCCESS on successful enumeration.
    ERROR_MORE_DATA when buffer full and more data remains.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status;

    DECLARE_DNS_RPC_RETRY_STATE( status );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    DNSDBG( STUB, (
        "Enter DnssrvEnumRecords()\n"
        "\tClient ver       = 0x%X\n"
        "\tServer           = %S\n"
        "\tpszZoneName      = %s\n"
        "\tpszNodeName      = %s\n"
        "\tpszStartChild    = %s\n"
        "\twRecordType      = %d\n"
        "\tdwSelectFlag     = %p\n"
        "\tpszFilterStart   = %s\n"
        "\tpszFilterStop    = %s\n"
        "\tpdwBufferLength  = %p\n"
        "\tppBuffer         = %p\n",
        dwClientVersion,
        Server,
        pszZoneName,
        pszNodeName,
        pszStartChild,
        wRecordType,
        dwSelectFlag,
        pszFilterStart,
        pszFilterStop,
        pdwBufferLength,
        ppBuffer ));

    DECLARE_DNS_RPC_RETRY_LABEL()

    RpcTryExcept
    {
        //  clear ptr for safety, we don't want to free any bogus memory

        *ppBuffer = NULL;

        ASSERT_DNS_RPC_RETRY_STATE_VALID();

        if ( DNS_RPC_RETRY_STATE() == DNS_RPC_TRY_NEW )
        {
            status = R_DnssrvEnumRecords2(
                            dwClientVersion,
                            dwSettingFlags,
                            Server,
                            pszZoneName,
                            pszNodeName,
                            pszStartChild,
                            wRecordType,
                            dwSelectFlag,
                            pszFilterStart,
                            pszFilterStop,
                            pdwBufferLength,
                            ppBuffer );
        }
        else
        {
            status = R_DnssrvEnumRecords(
                            Server,
                            pszZoneName,
                            pszNodeName,
                            pszStartChild,
                            wRecordType,
                            dwSelectFlag,
                            pszFilterStart,
                            pszFilterStop,
                            pdwBufferLength,
                            ppBuffer );
        }
        ADVANCE_DNS_RPC_RETRY_STATE( status );

        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "R_DnssrvEnumRecords: try = %d status = %d / %p\n",
                DNS_RPC_RETRY_STATE(),
                status,
                status ));

            if ( status == ERROR_SUCCESS || status == ERROR_MORE_DATA )
            {
                DnsDbg_RpcRecordsInBuffer(
                    "Returned records: ",
                    *pdwBufferLength,
                    *ppBuffer );
            }
        }
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        IF_DNSDBG( STUB )
        {
            DNS_PRINT((
                "RpcExcept:  code = %d / %p\n",
                status,
                status ));
        }
        ADVANCE_DNS_RPC_RETRY_STATE( status );
    }
    RpcEndExcept

    TEST_DNS_RPC_RETRY();

    printExtendedRpcErrorInfo( status );

    return status;
}



DNS_STATUS
DNS_API_FUNCTION
DnssrvUpdateRecordEx(
    IN      DWORD                   dwClientVersion,
    IN      DWORD                   dwSettingFlags,
    IN      LPCWSTR                 Server,
    IN      LPCSTR                  pszZoneName,
    IN      LPCSTR                  pszNodeName,
    IN      PDNS_RPC_RECORD         pAddRecord,
    IN      PDNS_RPC_RECORD         pDeleteRecord
    )
/*++

Routine Description:

    Stub for UpdateRecords API.

Arguments:

Return Value:

    ERROR_SUCCESS on successful enumeration.
    ErrorCode on failure.

--*/
{
    DNS_STATUS      status;

    DECLARE_DNS_RPC_RETRY_STATE( status );
    if ( status != ERROR_SUCCESS )
    {
        return status;
    }

    DNSDBG( STUB, (
        "Enter R_DnssrvUpdateRecord()\n"
        "\tClient ver       = 0x%X\n"
        "\tServer           = %S\n"
        "\tpszZoneName      = %s\n"
        "\tpszNodeName      = %s\n"
        "\tpAddRecord       = %p\n"
        "\tpDeleteRecord    = %p\n",
        dwClientVersion,
        Server,
        pszZoneName,
        pszNodeName,
        pAddRecord,
        pDeleteRecord ));

    DECLARE_DNS_RPC_RETRY_LABEL()

    RpcTryExcept
    {
        ASSERT_DNS_RPC_RETRY_STATE_VALID();

        if ( DNS_RPC_RETRY_STATE() == DNS_RPC_TRY_NEW )
        {
            status = R_DnssrvUpdateRecord2(
                            dwClientVersion,
                            dwSettingFlags,
                            Server,
                            pszZoneName,
                            pszNodeName,
                            pAddRecord,
                            pDeleteRecord );
        }
        else
        {
            status = R_DnssrvUpdateRecord(
                            Server,
                            pszZoneName,
                            pszNodeName,
                            pAddRecord,
                            pDeleteRecord );
        }
        ADVANCE_DNS_RPC_RETRY_STATE( status );
        
        DNSDBG( STUB, (
            "R_DnssrvUpdateRecord:  status = %d / %p\n",
            status, status ));
    }
    RpcExcept (1)
    {
        status = RpcExceptionCode();
        DNSDBG( STUB, (
            "RpcExcept:  code = %d / %p\n",
            status, status ));
        ADVANCE_DNS_RPC_RETRY_STATE( status );
    }
    RpcEndExcept

    TEST_DNS_RPC_RETRY();

    printExtendedRpcErrorInfo( status );

    return status;
}


//
//  End stub.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\client\w2kfuncs.c ===
/*++

Copyright (c) 1997-2000 Microsoft Corporation

Module Name:

    w2kfuncs.c

Abstract:

    Domain Name System (DNS) Server

    Frozen routines for processing W2K structures.

Author:

    Jeff Westhead (jwesth)      October, 2000

Revision History:

--*/


#include "dnsclip.h"


//
//  External functions
//


VOID
DnsPrint_RpcServerInfo_W2K(
    IN      PRINT_ROUTINE               PrintRoutine,
    IN OUT  PPRINT_CONTEXT              pPrintContext,
    IN      LPSTR                       pszHeader,
    IN      PDNS_RPC_SERVER_INFO_W2K    pServerInfo
    )
{
    DnsPrint_Lock();
    if ( pszHeader )
    {
        PrintRoutine( pPrintContext, pszHeader );
    }

    if ( ! pServerInfo )
    {
        PrintRoutine( pPrintContext, "NULL server info ptr.\n" );
    }
    else
    {
        int     majorVer = pServerInfo->dwVersion & 0x000000FF;
        int     minorVer = ( pServerInfo->dwVersion & 0x0000FF00 ) >> 8;
        int     buildNum = pServerInfo->dwVersion >> 16;

        PrintRoutine( pPrintContext,
            "Server info W2K:\n"
            "\tptr              = %p\n"
            "\tserver name      = %s\n",
            pServerInfo,
            pServerInfo->pszServerName );

        //
        //  Sanitize build number for older versions where build number is wacked.
        //

        if ( buildNum < 1 || buildNum > 5000 )
        {
            PrintRoutine( pPrintContext,
                "\tversion          = %08lX (%d.%d)\n",
                pServerInfo->dwVersion,
                majorVer,
                minorVer );
        }
        else
        {
            PrintRoutine( pPrintContext,
                "\tversion          = %08lX (%d.%d build %d)\n",
                pServerInfo->dwVersion,
                majorVer,
                minorVer,
                buildNum );
        }

        PrintRoutine( pPrintContext,
            "\tDS container     = %S\n",
            ( PWSTR ) pServerInfo->pszDsContainer );

        PrintRoutine( pPrintContext,
            "  Configuration:\n"
            "\tdwLogLevel               = %p\n"
            "\tdwDebugLevel             = %p\n"
            "\tdwRpcProtocol            = %p\n"
            "\tdwNameCheckFlag          = %p\n"
            "\tcAddressAnswerLimit      = %d\n"
            "\tdwRecursionRetry         = %d\n"
            "\tdwRecursionTimeout       = %d\n"
            "\tdwDsPollingInterval      = %d\n",
            pServerInfo->dwLogLevel,
            pServerInfo->dwDebugLevel,
            pServerInfo->dwRpcProtocol,
            pServerInfo->dwNameCheckFlag,
            pServerInfo->cAddressAnswerLimit,
            pServerInfo->dwRecursionRetry,
            pServerInfo->dwRecursionTimeout,
            pServerInfo->dwDsPollingInterval
            );

        PrintRoutine( pPrintContext,
            "  Configuration Flags:\n"
            "\tfBootMethod                  = %d\n"
            "\tfAdminConfigured             = %d\n"
            "\tfAllowUpdate                 = %d\n"
            "\tfDsAvailable                 = %d\n"
            "\tfAutoReverseZones            = %d\n"
            "\tfAutoCacheUpdate             = %d\n"
            "\tfSlave                       = %d\n"
            "\tfNoRecursion                 = %d\n"
            "\tfRoundRobin                  = %d\n"
            "\tfLocalNetPriority            = %d\n"
            "\tfStrictFileParsing           = %d\n"
            "\tfLooseWildcarding            = %d\n"
            "\tfBindSecondaries             = %d\n"
            "\tfWriteAuthorityNs            = %d\n",
            pServerInfo->fBootMethod,
            pServerInfo->fAdminConfigured,
            pServerInfo->fAllowUpdate,
            pServerInfo->fDsAvailable,
            pServerInfo->fAutoReverseZones,
            pServerInfo->fAutoCacheUpdate,
            pServerInfo->fSlave,
            pServerInfo->fNoRecursion,
            pServerInfo->fRoundRobin,
            pServerInfo->fLocalNetPriority,
            pServerInfo->fStrictFileParsing,
            pServerInfo->fLooseWildcarding,
            pServerInfo->fBindSecondaries,
            pServerInfo->fWriteAuthorityNs
            );

        PrintRoutine(
            pPrintContext,
            "  Aging Configuration:\n"
            "\tScavengingInterval           = %d\n"
            "\tDefaultAgingState            = %d\n"
            "\tDefaultRefreshInterval       = %d\n"
            "\tDefaultNoRefreshInterval     = %d\n",
            pServerInfo->dwScavengingInterval,
            pServerInfo->fDefaultAgingState,
            pServerInfo->dwDefaultRefreshInterval,
            pServerInfo->dwDefaultNoRefreshInterval
            );

        DnsPrint_Ip4Array(
            PrintRoutine,
            pPrintContext,
            "  ServerAddresses:\n",
            "\tAddr",
            pServerInfo->aipServerAddrs );

        DnsPrint_Ip4Array(
            PrintRoutine,
            pPrintContext,
            "  ListenAddresses:\n",
            "\tAddr",
            pServerInfo->aipListenAddrs );

        DnsPrint_Ip4Array(
            PrintRoutine,
            pPrintContext,
            "  Forwarders:\n",
            "\tAddr",
            pServerInfo->aipForwarders );

        PrintRoutine(
            pPrintContext,
            "\tforward timeout  = %d\n"
            "\tslave            = %d\n",
            pServerInfo->dwForwardTimeout,
            pServerInfo->fSlave );
    }
    DnsPrint_Unlock();
}



VOID
DnsPrint_RpcZoneInfo_W2K(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pPrintContext,
    IN      LPSTR                   pszHeader,
    IN      PDNS_RPC_ZONE_INFO_W2K  pZoneInfo
    )
{
    DnsPrint_Lock();
    PrintRoutine( pPrintContext, (pszHeader ? pszHeader : "") );

    if ( ! pZoneInfo )
    {
        PrintRoutine( pPrintContext, "NULL zone info ptr.\n" );
    }
    else
    {
        PrintRoutine( pPrintContext,
            "Zone info W2K:\n"
            "\tptr                = %p\n"
            "\tzone name          = %s\n"
            "\tzone type          = %d\n"
            "\tupdate             = %d\n"
            "\tDS integrated      = %d\n"
            "\tdata file          = %s\n"
            "\tusing WINS         = %d\n"
            "\tusing Nbstat       = %d\n"
            "\taging              = %d\n"
            "\t  refresh interval    = %lu\n"
            "\t  no refresh          = %lu\n"
            "\t  scavenge available  = %lu\n",
            pZoneInfo,
            pZoneInfo->pszZoneName,
            pZoneInfo->dwZoneType,
            pZoneInfo->fAllowUpdate,
            pZoneInfo->fUseDatabase,
            pZoneInfo->pszDataFile,
            pZoneInfo->fUseWins,
            pZoneInfo->fUseNbstat,
            pZoneInfo->fAging,
            pZoneInfo->dwRefreshInterval,
            pZoneInfo->dwNoRefreshInterval,
            pZoneInfo->dwAvailForScavengeTime
            );

        DnsPrint_Ip4Array(
            PrintRoutine, pPrintContext,
            "\tZone Masters\n",
            "\tMaster",
            pZoneInfo->aipMasters );

        DnsPrint_Ip4Array(
            PrintRoutine, pPrintContext,
            "\tZone Secondaries\n",
            "\tSecondary",
            pZoneInfo->aipSecondaries );

        PrintRoutine( pPrintContext,
            "\tsecure secs         = %d\n",
            pZoneInfo->fSecureSecondaries );

        if ( pZoneInfo->aipScavengeServers )
        {
            DnsPrint_Ip4Array(
                PrintRoutine, pPrintContext,
                "\tScavenge Servers\n",
                "\tServer",
                pZoneInfo->aipScavengeServers );
        }
    }
    DnsPrint_Unlock();
}


VOID
DnsPrint_RpcZone_W2K(
    IN      PRINT_ROUTINE       PrintRoutine,
    IN OUT  PPRINT_CONTEXT      pPrintContext,
    IN      LPSTR               pszHeader,
    IN      PDNS_RPC_ZONE_W2K   pZone
    )
{
    if ( ! pZone )
    {
        PrintRoutine( pPrintContext,
            "%sNULL zone info ptr.\n",
            ( pszHeader ? pszHeader : "" ) );
    }
    else
    {
        //  print zone per line

        PrintRoutine( pPrintContext,
            "%s\n"
            " %-29S",
            pszHeader
                ? pszHeader
                : "",
            pZone->pszZoneName );

        PrintRoutine( pPrintContext,
            "  %1d  %2s  %3s  %4s  Up=%1d  %5s %6s %6s\n",
            pZone->ZoneType,
            pZone->Flags.DsIntegrated   ? "DS  "    : "file",
            pZone->Flags.Reverse        ? "Rev"     : "",
            pZone->Flags.AutoCreated    ? "Auto"    : "",
            pZone->Flags.Update,
            pZone->Flags.Aging          ? "Aging"   : "",
            pZone->Flags.Paused         ? "Paused"  : "",
            pZone->Flags.Shutdown       ? "Shutdn"  : "" );
    }
}



VOID
DNS_API_FUNCTION
DnsPrint_RpcZoneList_W2K(
    IN      PRINT_ROUTINE           PrintRoutine,
    IN OUT  PPRINT_CONTEXT          pPrintContext,
    IN      LPSTR                   pszHeader,
    IN      PDNS_RPC_ZONE_LIST_W2K  pZoneList
    )
{
    DWORD   i;

    DnsPrint_Lock();
    if ( pszHeader )
    {
        PrintRoutine( pPrintContext, "%s\n", pszHeader );
    }

    if ( !pZoneList )
    {
        PrintRoutine( pPrintContext, "NULL zone list pointer.\n" );
    }
    else
    {
        PrintRoutine( pPrintContext, "\tZone Count = %d (W2K)\n", pZoneList->dwZoneCount );

        if ( pZoneList->dwZoneCount )
        {
            DnsPrint_RpcZone_W2K(
                PrintRoutine, pPrintContext,
                NULL,   // print default header
                pZoneList->ZoneArray[0] );
        }

        for ( i=1; i<pZoneList->dwZoneCount; i++ )
        {
            DnsPrint_RpcZone_W2K(
                PrintRoutine, pPrintContext,
                " ",   // not to print default header
                pZoneList->ZoneArray[i] );
        }
        PrintRoutine( pPrintContext, "\n" );
    }
    DnsPrint_Unlock();
}


//
//  End of w2kfuncs.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\dnsadddp\dnsrpc_c_stub.c ===
#include "dnsrpc_c.c"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\dbgext\exts.cpp ===
/*-----------------------------------------------------------------------------
   Copyright (c) 2000  Microsoft Corporation

Module:
  exts.cpp
  
  Sampe file showing couple of extension examples

-----------------------------------------------------------------------------*/
#include "dbgexts.h"


/*
   Sample extension to demonstrace ececuting debugger command
   
 */
HRESULT CALLBACK 
cmdsample(PDEBUG_CLIENT Client, PCSTR args)
{
    CHAR Input[256];
    INIT_API();

    //
    // Output a 10 frame stack
    //
    g_ExtControl->OutputStackTrace(DEBUG_OUTCTL_ALL_CLIENTS |   // Flags on what to do with output
                                   DEBUG_OUTCTL_OVERRIDE_MASK |
                                   DEBUG_OUTCTL_NOT_LOGGED, 
                                   NULL, 
                                   10,           // number of frames to display
                                   DEBUG_STACK_FUNCTION_INFO | DEBUG_STACK_COLUMN_NAMES |
                                   DEBUG_STACK_ARGUMENTS | DEBUG_STACK_FRAME_ADDRESSES);
    //
    // Engine interface for print 
    //
    g_ExtControl->Output(DEBUG_OUTCTL_ALL_CLIENTS, "\n\nDebugger module list\n");
    
    //
    // list all the modules by executing lm command
    //
    g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                          DEBUG_OUTCTL_OVERRIDE_MASK |
                          DEBUG_OUTCTL_NOT_LOGGED,
                          "lm", // Command to be executed
                          DEBUG_EXECUTE_DEFAULT );
    
    //
    // Ask for user input
    //
    g_ExtControl->Output(DEBUG_OUTCTL_ALL_CLIENTS, "\n\n***User Input sample\n\nEnter Command to run : ");
    GetInputLine(NULL, &Input[0], sizeof(Input));
    g_ExtControl->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                          DEBUG_OUTCTL_OVERRIDE_MASK |
                          DEBUG_OUTCTL_NOT_LOGGED,
                          Input, // Command to be executed
                          DEBUG_EXECUTE_DEFAULT );
    
    EXIT_API();
    return S_OK;
}

/*
  Sample extension to read and dump a struct on target
    
  This reads the struct _EXCEPTION_RECORD which is defined as:
  
  typedef struct _EXCEPTION_RECORD {
    NTSTATUS ExceptionCode;
    ULONG ExceptionFlags;
    struct _EXCEPTION_RECORD *ExceptionRecord;
    PVOID ExceptionAddress;
    ULONG NumberParameters;
    ULONG_PTR ExceptionInformation[EXCEPTION_MAXIMUM_PARAMETERS];
    } EXCEPTION_RECORD;
*/
HRESULT CALLBACK 
structsample(PDEBUG_CLIENT Client, PCSTR args)
{
    ULONG64 Address;
    INIT_API();

    Address = GetExpression(args);
    
    DWORD Buffer[4], cb;

    // Read and display first 4 dwords at Address
    if (ReadMemory(Address, &Buffer, sizeof(Buffer), &cb) && cb == sizeof(Buffer)) {
        dprintf("%p: %08lx %08lx %08lx %08lx\n\n", Address,
                Buffer[0], Buffer[1], Buffer[2], Buffer[3]);
    }

    //
    // Method 1 to dump a struct
    //
    dprintf("Method 1:\n");
    // Inititalze type read from the Address
    if (InitTypeRead(Address, _EXCEPTION_RECORD) != 0) {
        dprintf("Error in reading _EXCEPTION_RECORD at %p", // Use %p to print pointer values
                Address);
    } else {
        // read and dump the fields
        dprintf("_EXCEPTION_RECORD @ %p\n", Address);
        dprintf("\tExceptionCode           : %lx\n", (ULONG) ReadField(ExceptionCode));
        dprintf("\tExceptionAddress        : %p\n", ReadField(ExceptionAddress));
        dprintf("\tExceptionInformation[1] : %I64lx\n", ReadField(ExceptionInformation[1]));
        // And so on...
    }

    //
    // Method 2 to read a struct
    //
    ULONG64 ExceptionInformation_1, ExceptionAddress, ExceptionCode;
    dprintf("\n\nMethod 2:\n");
    // Read and dump the fields by specifying type and address individually 
    if (GetFieldValue(Address, "_EXCEPTION_RECORD", "ExceptionCode", ExceptionCode)) {
        dprintf("Error in reading _EXCEPTION_RECORD at %p\n",
                Address);
    } else {
        // Pointers are read as ULONG64 values
        GetFieldValue(Address, "_EXCEPTION_RECORD", "ExceptionAddress", ExceptionAddress);
        GetFieldValue(Address, "_EXCEPTION_RECORD", "ExceptionInformation[1]", ExceptionInformation_1);
        // And so on..
        
        dprintf("_EXCEPTION_RECORD @ %p\n", Address);
        dprintf("\tExceptionCode           : %lx\n", ExceptionCode);
        dprintf("\tExceptionAddress        : %p\n", ExceptionAddress);
        dprintf("\tExceptionInformation[1] : %I64lx\n", ExceptionInformation_1);
    }

    ULONG64 Module;
    ULONG   i, TypeId;
    CHAR Name[MAX_PATH];
    //
    // To get/list field names
    //
    g_ExtSymbols->GetSymbolTypeId("_EXCEPTION_RECORD", &TypeId, &Module);
    dprintf("Fields of _EXCEPTION_RECORD\n");
    for (i=0; ;i++) {
	HRESULT Hr;
	ULONG Offset=0;

	Hr = g_ExtSymbols2->GetFieldName(Module, TypeId, i, Name, MAX_PATH, NULL);
	if (Hr == S_OK) {
	    g_ExtSymbols->GetFieldOffset(Module, TypeId, Name, &Offset);
	    dprintf("%lx (+%03lx) %s\n", i, Offset, Name);
	} else if (Hr == E_INVALIDARG) {
	    // All Fields done
	    break;
	} else {
	    dprintf("GetFieldName Failed %lx\n", Hr);
	    break;
	}
    }

    //
    // Get name for an enumerate
    //
    //     typedef enum {
    //        Enum1,
    //	      Enum2,
    //        Enum3,
    //     } TEST_ENUM;
    //
    ULONG   ValueOfEnum = 0;
    g_ExtSymbols->GetSymbolTypeId("TEST_ENUM", &TypeId, &Module);
    g_ExtSymbols2->GetConstantName(Module, TypeId, ValueOfEnum, Name, MAX_PATH, NULL);
    dprintf("Testenum %I64lx == %s\n", ExceptionCode, Name);
    // This prints out, Testenum 0 == Enum1

    //
    // Read an array
    //
    //    typedef struct FOO_TYPE {
    //      ULONG Bar;
    //      ULONG Bar2;
    //    } FOO_TYPE;
    //
    //    FOO_TYPE sampleArray[20];
    ULONG Bar, Bar2;
    CHAR TypeName[100];
    for (i=0; i<20; i++) {
	sprintf(TypeName, "sampleArray[%lx]", i);
	if (GetFieldValue(0, TypeName, "Bar", Bar)) 
	    break;
	GetFieldValue(0, TypeName, "Bar2", Bar2);
	dprintf("%16s -  Bar %2ld  Bar2 %ld\n", TypeName, Bar, Bar2);
    }

    EXIT_API();
    return S_OK;
}

/*
  This gets called (by DebugExtensionNotify whentarget is halted and is accessible
*/
HRESULT 
NotifyOnTargetAccessible(PDEBUG_CONTROL Control)
{
    dprintf("Extension dll detected a break");
    if (Connected) {
        dprintf(" connected to ");
        switch (TargetMachine) { 
        case IMAGE_FILE_MACHINE_I386:
            dprintf("X86");
            break;
        case IMAGE_FILE_MACHINE_AMD64:
            dprintf("AMD64");
            break;
        case IMAGE_FILE_MACHINE_IA64:
            dprintf("IA64");
            break;
        default:
            dprintf("Other");
            break;
        }
    }
    dprintf("\n");
    
    //
    // show the top frame and execute dv to dump the locals here and return
    //
    Control->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                     DEBUG_OUTCTL_OVERRIDE_MASK |
                     DEBUG_OUTCTL_NOT_LOGGED,
                     ".frame", // Command to be executed
                     DEBUG_EXECUTE_DEFAULT );
    Control->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                     DEBUG_OUTCTL_OVERRIDE_MASK |
                     DEBUG_OUTCTL_NOT_LOGGED,
                     "dv", // Command to be executed
                     DEBUG_EXECUTE_DEFAULT );
    return S_OK;
}

/*
  A built-in help for the extension dll
*/
HRESULT CALLBACK 
help(PDEBUG_CLIENT Client, PCSTR args)
{
    INIT_API();
    dprintf("Help for dbgexts.dll\n"
            "  cmdsample           - This does stacktrace and lists\n"
            "  help                = Shows this help\n"
            "  structsample <addr> - This dumps a struct at given address\n"
            );
    EXIT_API();

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\dbgext\dbgexts.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    dbgexts.cpp

Abstract:

    This file contains the generic routines and initialization code
    for the debugger extensions dll.

--*/

#include "dbgexts.h"


PDEBUG_CLIENT         g_ExtClient;
PDEBUG_CONTROL        g_ExtControl;
PDEBUG_SYMBOLS        g_ExtSymbols;
PDEBUG_SYMBOLS2       g_ExtSymbols2;

WINDBG_EXTENSION_APIS   ExtensionApis;

ULONG   TargetMachine;
BOOL    Connected;

// Queries for all debugger interfaces.
extern "C" HRESULT
ExtQuery(PDEBUG_CLIENT Client)
{
    HRESULT Status;
    
    if ((Status = Client->QueryInterface(__uuidof(IDebugControl),
                                 (void **)&g_ExtControl)) != S_OK)
    {
        goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols),
                                (void **)&g_ExtSymbols)) != S_OK)
    {
	goto Fail;
    }
    if ((Status = Client->QueryInterface(__uuidof(IDebugSymbols2),
                                (void **)&g_ExtSymbols2)) != S_OK)
    {
	goto Fail;
    }
    g_ExtClient = Client;
    
    return S_OK;

 Fail:
    ExtRelease();
    return Status;
}

// Cleans up all debugger interfaces.
void
ExtRelease(void)
{
    g_ExtClient = NULL;
    EXT_RELEASE(g_ExtControl);
    EXT_RELEASE(g_ExtSymbols);
    EXT_RELEASE(g_ExtSymbols2);
}

extern "C"
HRESULT
CALLBACK
DebugExtensionInitialize(PULONG Version, PULONG Flags)
{
    IDebugClient *DebugClient;
    PDEBUG_CONTROL DebugControl;
    HRESULT Hr;

    *Version = DEBUG_EXTENSION_VERSION(1, 0);
    *Flags = 0;
    

    if ((Hr = DebugCreate(__uuidof(IDebugClient),
                          (void **)&DebugClient)) != S_OK)
    {
        return Hr;
    }
    
    if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                  (void **)&DebugControl)) == S_OK)
    {

        //
        // Get the windbg-style extension APIS
        //
        ExtensionApis.nSize = sizeof (ExtensionApis);
        if ((Hr = DebugControl->GetWindbgExtensionApis64(&ExtensionApis)) != S_OK)
            return Hr;
        
        DebugControl->Release();

    }
    DebugClient->Release();
    return S_OK;
}


extern "C"
void
CALLBACK
DebugExtensionNotify(ULONG Notify, ULONG64 Argument)
{
    
    //
    // The first time we actually connect to a target
    //

    if ((Notify == DEBUG_NOTIFY_SESSION_ACCESSIBLE) && (!Connected))
    {
        IDebugClient *DebugClient;
        HRESULT Hr;
        PDEBUG_CONTROL DebugControl;

        if ((Hr = DebugCreate(__uuidof(IDebugClient),
                              (void **)&DebugClient)) == S_OK)
        {
            //
            // Get the architecture type.
            //

            if ((Hr = DebugClient->QueryInterface(__uuidof(IDebugControl),
                                       (void **)&DebugControl)) == S_OK)
            {
                if ((Hr = DebugControl->GetActualProcessorType(
                                             &TargetMachine)) == S_OK)
                {
                    Connected = TRUE;
                }

                NotifyOnTargetAccessible(DebugControl);

                DebugControl->Release();
            }
 
            DebugClient->Release();
        }
    }


    if (Notify == DEBUG_NOTIFY_SESSION_INACTIVE)
    {
        Connected = FALSE;
        TargetMachine = 0;
    }

    return;
}

extern "C"
void
CALLBACK
DebugExtensionUninitialize(void)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\dnsadddp\dnsadddp.c ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    dnscmd.c

Abstract:

    Domain Name System (DNS)

    DNS Directory Partition Creation Utility

Author:

    Jeff Westhead (jwesth)      April 2001

Revision History:

--*/


#include "precomp.h"


//
//  Debug printing (crude!)
//

#if DBG
#define DPDBG( _DbgArg ) printf _DbgArg;
#else
#define DPDBG( _DbgArg ) 
#endif


#if 1
int WINAPI
WinMain(
    HINSTANCE hInst,
    HINSTANCE hPrevInst,
    LPSTR lpszCmdLn,
    int nShowCmd
    )
#else
INT __cdecl
wmain(
    IN      INT             Argc,
    IN      PWSTR *         Argv
    )
#endif
/*++

Routine Description:

    DnsAddDp main routine

    Note that this executable print no messages (except in debug mode) so no
    localization is required.

Arguments:

    Command line args (currently unused)

Return Value:

    DNS_STATUS of create partitions operation

--*/
{
    DNS_STATUS status;

    //
    //  Create forest built-in directory partition.
    //
    
    DPDBG(( "\n" ));
    DPDBG(( "Attempting forest directory partition auto-create operation to local server...\n" ));

    status = DnssrvEnlistDirectoryPartition(
                L".",
                DNS_DP_OP_CREATE_FOREST,
                NULL );

    if ( status == ERROR_SUCCESS )
    {
        DPDBG(( "\nForest directory partition auto-create operation succeeded!\n" ));
    }
    else
    {
        DPDBG(( "\nForest directory partition auto-create operation returned %d\n", status ));
    }

    //
    //  Create domain built-in directory partition.
    //
    
    DPDBG(( "\n" ));
    DPDBG(( "Attempting domain directory partition auto-create operation to local server...\n" ));

    status = DnssrvEnlistDirectoryPartition(
                L".",
                DNS_DP_OP_CREATE_DOMAIN,
                NULL );

    if ( status == ERROR_SUCCESS )
    {
        DPDBG(( "\nDomain directory partition auto-create operation succeeded!\n" ));
    }
    else
    {
        DPDBG(( "\nDomain directory partition auto-create operation returned %d\n", status ));
    }

    return status;
};


//
//  End DnsAddDp.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\dbgext\dbgexts.h ===
/*++

    Copyright (c) 2000  Microsoft Corporation

Module Name:

    dbgexts.h

--*/


#ifndef _DNSDBG_H_
#define _DNSDBG_H_


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include <windows.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#define KDEXT_64BIT
#include <wdbgexts.h>
#include <dbgeng.h>

#ifdef __cplusplus
extern "C" {
#endif


#define INIT_API()                             \
    HRESULT Status;                            \
    if ((Status = ExtQuery(Client)) != S_OK) return Status; 

#define EXT_RELEASE(Unk) \
    ((Unk) != NULL ? ((Unk)->Release(), (Unk) = NULL) : NULL)

#define EXIT_API     ExtRelease


// Global variables initialized by query.
extern PDEBUG_CLIENT         g_ExtClient;
extern PDEBUG_CONTROL        g_ExtControl;
extern PDEBUG_SYMBOLS        g_ExtSymbols;
extern PDEBUG_SYMBOLS2       g_ExtSymbols2;

extern BOOL  Connected;
extern ULONG TargetMachine;

HRESULT
ExtQuery(PDEBUG_CLIENT Client);

void
ExtRelease(void);

HRESULT 
NotifyOnTargetAccessible(PDEBUG_CONTROL Control);

#ifdef __cplusplus
}

#endif


#endif  //  _DNSDBG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\dnsadddp\dnsadddp.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    DnsAddDp.h

Abstract:

    Domain Name System (DNS)

    DNS Directory Partition Creation Utility

Author:

    Jeff Westhead (jwesth)      April 2001

Revision History:

--*/


#ifndef _DNSADDDP_INCLUDED_
#define _DNSADDDP_INCLUDED_

#define _UNICODE
#define UNICODE

#pragma warning(disable:4214)
#pragma warning(disable:4514)
#pragma warning(disable:4152)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>

//  headers are messed up
//  if you bring in nt.h, then don't bring in winnt.h and
//  then you miss these

#ifndef MAXWORD
#define MINCHAR     0x80
#define MAXCHAR     0x7f
#define MINSHORT    0x8000
#define MAXSHORT    0x7fff
#define MINLONG     0x80000000
#define MAXLONG     0x7fffffff
#define MAXBYTE     0xff
#define MAXWORD     0xffff
#define MAXDWORD    0xffffffff
#endif

#include <winsock2.h>
#include "dnsrpc_c.h"   //  MIDL generated RPC interface definitions
#include <dnsrpc.h>

#include <stdio.h>
#include <stdlib.h>

#define  NO_DNSAPI_DLL
#include "dnslib.h"


//
//  If you like having a local variable in functions to hold the function 
//  name so that you can include it in debug logs without worrying about 
//  changing all the occurences when the function is renamed, use this 
//  at the top of the function:
//      DBG_FN( "MyFunction" )      <--- NOTE: no semi-colon!!
//

#if DBG
#define DBG_FN( funcName ) static const char * fn = (funcName);
#else
#define DBG_FN( funcName )
#endif


#endif //   _DNSADDDP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\dnsadddp\makefile.inc ===
!IF 0

Copyright (C) Microsoft Corporation, 1997 - 1999

Module Name:

    makefile.inc.

!ENDIF

$(NTTARGETFILE0):	..\idl\$(O)\$(@F)
    copy ..\idl\$(O)\$(@F) $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\dbgext\dnsexts.cpp ===
/*-----------------------------------------------------------------------------
    Copyright (c) 2001  Microsoft Corporation

    DNS Server debugger extension

    Written by Jeff Westhead Feb 2001

-----------------------------------------------------------------------------*/


#include "dbgexts.h"


//
//  DNS Server includes
//

#define LDAP_UNICODE        1
#include <winldap.h>        //  public LDAP
#include <winber.h>         //  for ber formatting
#include <ntldap.h>         //  public server ldap constants
#include <rpc.h>            //  RPC def needed for ntdsapi.h
#include <ntdsapi.h>        //  DS access bit definitions
#include <ntdsadef.h>       //  DS constants
#include <dsrole.h>
#include <time.h>
#define DNSLIB_SECURITY     //  include security defs

#define SDK_DNS_RECORD      //  DNS_RECORD in SDK format
#define NO_DNSAPI_DLL       //  build without requiring dnsapi.dll
#include <dnslib.h>         //  DNS library routines

#ifndef FASTCALL
#define FASTCALL
#endif

#include "dnsrpc_s.h"       //  DNS RPC definitions

#include "srvcfg.h"
#include "file.h"
#include "tree.h"
#include "name.h"
#include "record.h"
#include "update.h"
#include "dpart.h"
#include "EventControl.h"
#include "zone.h"
#include "registry.h"
#include "msginfo.h"
#include "socket.h"
#include "packetq.h"
#include "dbase.h"
#include "recurse.h"
#include "nameutil.h"
#include "stats.h"
#include "debug.h"
#include "memory.h"
#include "dfile.h"
#include "wins.h"
#include "rrfunc.h"
#include "dnsprocs.h"
#include "rescodes.h"
#include "sdutl.h"
#include "ds.h"
#include "timeout.h"


//
//  Print DNS server statistics
//

LPSTR   MemTagStrings[] =       //  Stolen from dns\server\client\print.c
{
    MEMTAG_NAME_NONE            ,
    MEMTAG_NAME_PACKET_UDP      ,
    MEMTAG_NAME_PACKET_TCP      ,
    MEMTAG_NAME_NAME            ,
    MEMTAG_NAME_ZONE            ,
    MEMTAG_NAME_UPDATE          ,
    MEMTAG_NAME_UPDATE_LIST     ,
    MEMTAG_NAME_TIMEOUT         ,
    MEMTAG_NAME_NODEHASH        ,
    MEMTAG_NAME_DS_DN           ,
    MEMTAG_NAME_DS_MOD          ,   //  10
    MEMTAG_NAME_DS_RECORD       ,
    MEMTAG_NAME_DS_OTHER        ,
    MEMTAG_NAME_THREAD          ,
    MEMTAG_NAME_NBSTAT          ,
    MEMTAG_NAME_DNSLIB          ,
    MEMTAG_NAME_TABLE           ,
    MEMTAG_NAME_SOCKET          ,
    MEMTAG_NAME_CONNECTION      ,
    MEMTAG_NAME_REGISTRY        ,
    MEMTAG_NAME_RPC             ,   //  20
    MEMTAG_NAME_STUFF           ,
    MEMTAG_NAME_FILEBUF         ,
    MEMTAG_NAME_REMOTE          ,
    MEMTAG_NAME_SAFE            ,

    MEMTAG_NAME_RECORD          ,
    MEMTAG_NAME_RECORD_FILE     ,
    MEMTAG_NAME_RECORD_DS       ,
    MEMTAG_NAME_RECORD_AXFR     ,
    MEMTAG_NAME_RECORD_IXFR     ,
    MEMTAG_NAME_RECORD_DYNUP    ,   //  30
    MEMTAG_NAME_RECORD_ADMIN    ,
    MEMTAG_NAME_RECORD_AUTO     ,
    MEMTAG_NAME_RECORD_CACHE    ,
    MEMTAG_NAME_RECORD_NOEXIST  ,
    MEMTAG_NAME_RECORD_WINS     ,
    MEMTAG_NAME_RECORD_WINSPTR  ,
    MEMTAG_NAME_RECORD_COPY     ,

    MEMTAG_NAME_NODE            ,
    MEMTAG_NAME_NODE_FILE       ,
    MEMTAG_NAME_NODE_DS         ,   //  40
    MEMTAG_NAME_NODE_AXFR       ,
    MEMTAG_NAME_NODE_IXFR       ,
    MEMTAG_NAME_NODE_DYNUP      ,
    MEMTAG_NAME_NODE_ADMIN      ,
    MEMTAG_NAME_NODE_AUTO       ,
    MEMTAG_NAME_NODE_CACHE      ,
    MEMTAG_NAME_NODE_NOEXIST    ,
    MEMTAG_NAME_NODE_WINS       ,
    MEMTAG_NAME_NODE_WINSPTR    ,
    MEMTAG_NAME_NODE_COPY       ,

    NULL,       // safety
    NULL,
    NULL,
    NULL
};


//
//  Functions
//


//
//  Iteration control. Be sure to call resetIterationCount at
//  the start of any iterating operation that will call checkIterationCount.
//  Note: call checkIterationCount aggressively, meaning at the top of
//  every single loop that iterates through a server data structure. It
//  is important that we be able to preset a limit to ALL iterating
//  functions.
//

int g_iIterationCount = 0;
int g_iMaxIterations = 0;

void
resetIterationCount()
{
    g_iIterationCount = 0;
}   //  resetIterationCount

bool
checkIterationCount()
{
    if ( g_iMaxIterations != 0 && g_iIterationCount++ > g_iMaxIterations )
    {
        dprintf(
            "Max iteration count (%d) reached - terminating operation\n",
            g_iMaxIterations );
        return false;
    }
    return true;
}   //  checkIterationCount


bool
myReadMemory(
    ULONG64 pMemory,
    void * ppBuffer,
    ULONG lLength,
    bool fQuiet )
{
    bool okay = true;
    DWORD bytes = 0;
    if ( !ReadMemory( pMemory, ppBuffer, lLength, &bytes ) ||
        bytes != lLength )
    {
        if ( !fQuiet )
        {
            dprintf(
                "DNSDBG: error reading %lu bytes of process memory at %p\n",
                lLength,
                pMemory );
        }
        okay = false;
    }
    return okay;
}   //  myReadMemory


bool
myReadString(
    ULONG64 pString,
    char * pszStringBuffer,
    ULONG lLength )
{
    bool okay = true;
    
    for ( ULONG i = 0; i < lLength - 1; ++i )
    {
        CHAR    szbuffer[ 2 ];
        
        if ( !myReadMemory( pString + i, &szbuffer , 1, true ) )
        {
            okay = false;
            break;
        }
        pszStringBuffer[ i ] = szbuffer[ 0 ];
        if ( pszStringBuffer[ i ] == '\0' )
        {
            break;
        }
    }
    pszStringBuffer[ i ] = '\0';
    return okay;
}   //  myReadMemory




HRESULT CALLBACK 
Stats(
    PDEBUG_CLIENT Client,
    PCSTR args )
{
    INIT_API();

    DWORD bytes;
    bool okay = true;

    ULONG64 pstatsTable = GetExpression( args );

    dprintf( "DNS Server statistics at %p\n", ( ULONG64 ) pstatsTable );

    for ( int i = 0; ; ++i )
    {
        struct StatsTableEntry statsEntry;
        if ( !ReadMemory(
                pstatsTable + i * sizeof( StatsTableEntry ),
                &statsEntry,
                sizeof( statsEntry ),
                &bytes ) ||
            bytes != sizeof( statsEntry ) )
        {
            dprintf(
                "Unable to read stat at %p index %d\n",
                ( ULONG64 ) ( ( PBYTE ) pstatsTable + i * sizeof( statsEntry ) ),
                i );
            okay = false;
            break;
        }

        if ( statsEntry.Id == 0 )
        {
            break;      //  Stat array terminator found!
        }

        #if 0
        dprintf(
            "Stat entry %d id=%08X length=%d\n",
            i,
            statsEntry.Id,
            statsEntry.wLength );
        #endif

        switch( statsEntry.Id )
        {
            #define StatDword( szIndent, statStruct, statMember )           \
                dprintf(                                                    \
                    "%s%-25s = %d\n",                                       \
                    szIndent,                                               \
                    #statMember,                                            \
                    statStruct.##statMember )

            case DNSSRV_STATID_MEMORY:
            {
                dprintf( "\n***** Memory Stats    id 0x%08X\n\n", statsEntry.Id );

                DNSSRV_MEMORY_STATS s;
                if ( ( okay = myReadMemory(
                                ( ULONG64 ) statsEntry.pStats,
                                &s,
                                sizeof( s ),
                                false ) ) == false )
                {
                    break;
                }

                #define StatIndent      "  "

                StatDword( StatIndent, s, Memory );
                StatDword( StatIndent, s, Alloc );
                StatDword( StatIndent, s, Free );
                dprintf( "\n" );

                StatDword( StatIndent, s, StdUsed );
                StatDword( StatIndent, s, StdReturn );
                StatDword( StatIndent, s, StdInUse );
                StatDword( StatIndent, s, StdMemory );
                dprintf( "\n" );

                StatDword( StatIndent, s, StdToHeapAlloc );
                StatDword( StatIndent, s, StdToHeapFree );
                StatDword( StatIndent, s, StdToHeapInUse );
                StatDword( StatIndent, s, StdToHeapMemory );
                dprintf( "\n" );

                StatDword( StatIndent, s, StdBlockAlloc );
                StatDword( StatIndent, s, StdBlockUsed );
                StatDword( StatIndent, s, StdBlockReturn );
                StatDword( StatIndent, s, StdBlockInUse );
                StatDword( StatIndent, s, StdBlockFreeList );
                StatDword( StatIndent, s, StdBlockFreeListMemory );
                StatDword( StatIndent, s, StdBlockMemory );
                dprintf( "\n" );

                dprintf( "      Memtag Name        Alloc       Free      InUse     Memory\n" );
                for ( int m = 0; m < MEMTAG_COUNT; ++m )
                {
                    dprintf(
                        "  %2d %-14s %10d %10d %10d %10d\n",
                        m,
                        MemTagStrings[ m ],
                        s.MemTags[ m ].Alloc,
                        s.MemTags[ m ].Free,
                        s.MemTags[ m ].Alloc - s.MemTags[ m ].Free,
                        s.MemTags[ m ].Memory );
                }

                #if 0

                //  THIS WOULD BE COOL BUT IT DOESN'T QUITE WORK!!

                ULONG64 module = 0;
                ULONG typeId = 0;
                CHAR szField[ MAX_PATH ];
                ULONG offset = 0;
                int iField;
                HRESULT hr;

                hr = g_ExtSymbols->GetSymbolTypeId(
                        "DNSSRV_MEMORY_STATS", &typeId, &module );
                dprintf( "GetSymbolTypeId returned 0x%lx\n", hr );
                for ( iField = 0; ; ++i )
                {
                    *szField = '\0';
                	hr = g_ExtSymbols2->GetFieldName(
                            module, typeId, iField,
                            szField, sizeof( szField ), NULL );
                    if ( hr == S_OK )
                    {
                	    hr = g_ExtSymbols->GetFieldOffset(
                                module, typeId, szField, &offset);
                        if ( hr == S_OK )
                        {
                            dprintf( "Field %s at offset %d\n", szField, offset );
                        }
                        else
                        {
                            dprintf(
                                "GetFieldOffset %s iField=%d failed 0x%lx\n",
                                szField, iField, hr );
                            break;
                        }
                    }
                    else if ( hr == E_INVALIDARG )
                    {
                        //  Done enumerating fields
                        break;
                    }
                    else
                    {
                        dprintf(
                            "GetFieldName iField=%d failed 0x%lx \"%s\"\n",
                            iField, hr, szField );
                        break;
                    }
                }
                #endif
                break;
            }

            default:
                dprintf(
                    "Unknown stat entry %d id=%08X length=%d\n",
                    i,
                    statsEntry.Id,
                    statsEntry.wLength );
                break;
        }
    }


    EXIT_API();
    return S_OK;
}   //  TimeoutArrays


bool
printNode(
    char * pszIndent,
    ULONG64 pNodeFull,
    bool fVerbose )
{
    bool okay = true;

    char szEmptyString[] = "";
    if ( !pszIndent )
    {
        pszIndent = szEmptyString;
    }

    DB_NODE node;
    okay = myReadMemory( pNodeFull, &node, sizeof( node ), false );
    if ( !okay )
    {
        okay = false;
        goto Cleanup;
    }

    //
    //  Force NULL termination in case this node was allocated
    //  longer than a standard node.
    //

    * ( ( PUCHAR ) &node + sizeof( node ) - 1 ) = '\0';

    //
    //  Read the string separately to try and get the whole string.
    //

    char szNodeName[ 65 ];
    if ( !myReadString(
                ( ULONG64 ) node.szLabel,
                szNodeName,
                sizeof( szNodeName ) ) )
    {
        strcpy( szNodeName, node.szLabel );
    }

    dprintf(
        "%sNODE %p %s%s %-16s abin %03d tbin %03d c%d",
        pszIndent,
        pNodeFull,
        node.pZone ? "Z" : " ",       //  has zone pointer?
        node.pRRList ? "R" : " ",     //  has RR list pointer?
        szNodeName ? szNodeName : "(ROOT)",
        node.uchAccessBin,
        node.uchTimeoutBin,
        node.cReferenceCount );
    int flags = node.dwNodeFlags;
    dprintf(
        " f%04X %s%s%s%s%s%s%s%s%s%s%s%s%s%s\n",
        flags,
        flags & NODE_NO_DELETE ? "Nodel" : "",
        flags & NODE_SELECT ? "Sel" : "",
        flags & NODE_FORCE_ENUM ? "Enum" : "",
        flags & NODE_IN_TIMEOUT ? "Tmot" : "",
        flags & NODE_AVAIL_TO_AUTHUSER ? "Avauth" : "",
        flags & NODE_ZONETREE ? "Ztree" : "",
        flags & NODE_AUTH_ZONE_ROOT ? "Authrt" : "",
        flags & NODE_WILDCARD_PARENT ? "Wildp" : "",
        flags & NODE_CNAME ? "Cname" : "",
        flags & NODE_ZONE_ROOT ? "Zroot" : "",
        flags & NODE_SECURE_EXPIRED ? "Secexp" : "",
        flags & NODE_TOMBSTONE ? "Tomb" : "",
        flags & NODE_THIS_HOST ? "This" : "",
        flags & NODE_NOEXIST ? "Noex" : "" );
    if ( fVerbose )
    {
        dprintf(
            "%s    par %p  up %p  left %p  right %p  children %p\n",
            pszIndent,
            ( ULONG64 ) node.pParent,
            ( ULONG64 ) node.pSibUp,
            ( ULONG64 ) node.pSibLeft,
            ( ULONG64 ) node.pSibRight,
            ( ULONG64 ) node.pChildren );
    }

    Cleanup:
    return okay;
}   //  printNode


//
//  Print summary of timeout system
//

void
internalTimeoutScanner(
    ULONG64 pTimeoutBinArray,
    bool fPrintStats,
    bool fPrintArrays,
    bool fPrintNodes,
    bool fPrintNodesHighDetail )
{
    DWORD nonEmptyTopLevelBins = 0;
    DWORD arraysFound = 0;
    DWORD nodesFound = 0;
    DWORD maxBinDepth = 0;
    DWORD maxNodesInBin = 0;
    DWORD bytes;
    bool okay = true;

    PTIMEOUT_ARRAY   timeoutBinArray[ TIMEOUT_BIN_COUNT ];

    //
    //  Read the timeout bin array
    //
    
    if ( !ReadMemory(
            pTimeoutBinArray,
            timeoutBinArray,
            sizeof( timeoutBinArray ),
            &bytes ) ||
        bytes != sizeof( timeoutBinArray ) )
    {
        dprintf(
            "Unable to read timeout bin array (%d bytes) at %p\n",
            sizeof( timeoutBinArray ),
            ( ULONG64 ) pTimeoutBinArray );
        goto Cleanup;
    }

    //
    //  For each bin in the array, traverse the bin to count
    //  nodes.
    //

    resetIterationCount();

    for ( int i = 0; okay && i < TIMEOUT_BIN_COUNT; ++i )
    {
        if ( !checkIterationCount() )
        {
            break;
        }

        if ( !timeoutBinArray[ i ] )
        {
            continue;
        }

        //
        //  Traverse all the arrays in this bin.
        //

        ++nonEmptyTopLevelBins;
        DWORD nodesInThisBin = 0;
        DWORD arraysInThisBin = 0;
        DWORD depth = 0;
        TIMEOUT_ARRAY array;
        for ( ULONG64 pArray = ( ULONG64 ) timeoutBinArray[ i ];
              okay && pArray != NULL;
              pArray = ( ULONG64 ) array.pNext )
        {
            if ( !checkIterationCount() )
            {
                break;
            }

            //
            //  Read this array.
            //

            if ( !ReadMemory(
                    pArray,
                    &array,
                    sizeof( array ),
                    &bytes ) ||
                bytes != sizeof( array ) )
            {
                dprintf(
                    "Unable to read timeout array for bin %d (%d bytes) at %p\n",
                    i,
                    sizeof( array ),
                    ( ULONG64 ) pArray );
                okay = false;
                break;
            }

            ++arraysInThisBin;
            ++arraysFound;
            ++depth;
            nodesInThisBin += array.Count;
            nodesFound += array.Count;

            if ( fPrintArrays )
            {
                dprintf(
                    "  ARRAY %3d in bin %3d has %2d elements  %p\n",
                    arraysInThisBin,
                    i,
                    array.Count,
                    ( ULONG64 ) pArray );
            }

            if ( !fPrintNodes && !fPrintNodesHighDetail )
            {
                continue;
            }

            //
            //  Traverse all the nodes in this array. 
            //

            for ( DWORD j = 0; okay && j < array.Count; ++j )
            {
                if ( !checkIterationCount() )
                {
                    break;
                }

                char sz[ 20 ];
                sprintf( sz, "    %2d ", j + 1 );
                okay = printNode(
                            sz,
                            ( ULONG64 ) array.pNode[ j ],
                            false );
            }
        }
        if ( !okay )
        {
            break;
        }

        if ( fPrintArrays && arraysInThisBin )
        {
            dprintf(
                "BIN %3d has %3d arrays %5d nodes\n",
                i,
                arraysInThisBin,
                nodesInThisBin );
        }

        //
        //  Record high water marks.
        //

        if ( nodesInThisBin > maxNodesInBin )
        {
            maxNodesInBin = nodesInThisBin;
        }
        if ( depth > maxBinDepth )
        {
            maxBinDepth = depth;
        }
    }

    if ( okay && fPrintStats )
    {
        dprintf(
            "Timeout summary for TimeoutBinArray at %p\n",
            pTimeoutBinArray );
        dprintf(
            "  nodes found in timeout system      %d\n"
            "  arrays found in timeout system     %d\n"
            "  non-empty top level bins           %d out of %d\n"
            "  maximum bin depth                  %d\n"
            "  maximum nodes in single bin        %d\n"
            "  average arrays per non-empty bin   %.2f\n",
            nodesFound,
            arraysFound,
            nonEmptyTopLevelBins,
            TIMEOUT_BIN_COUNT,
            maxBinDepth,
            maxNodesInBin,
            nonEmptyTopLevelBins ?
                ( ( double ) arraysFound /
                  ( double ) nonEmptyTopLevelBins + 0.5 ) : 0 );
    }

    Cleanup:
    return;
}   //  internalTimeoutScanner


HRESULT CALLBACK 
TimeoutSummary(
    PDEBUG_CLIENT Client,
    PCSTR args )
{
    INIT_API();

    ULONG64 ptimeoutBinArray = GetExpression( args );

    internalTimeoutScanner(
        ptimeoutBinArray,
        true,                   //  print stats
        false,                  //  print arrays
        false,                  //  print nodes
        false );                //  print nodes - high detail

    EXIT_API();
    return S_OK;
}   //  TimeoutSummary


HRESULT CALLBACK 
TimeoutArrays(
    PDEBUG_CLIENT Client,
    PCSTR args )
{
    INIT_API();

    ULONG64 ptimeoutBinArray = GetExpression( args );

    internalTimeoutScanner(
        ptimeoutBinArray,
        true,                   //  print stats
        true,                   //  print arrays
        false,                  //  print nodes
        false );                //  print nodes - high detail

    EXIT_API();
    return S_OK;
}   //  TimeoutArrays


HRESULT CALLBACK 
TimeoutNodes(
    PDEBUG_CLIENT Client,
    PCSTR args )
{
    INIT_API();

    ULONG64 ptimeoutBinArray = GetExpression( args );

    internalTimeoutScanner(
        ptimeoutBinArray,
        true,                   //  print stats
        true,                   //  print arrays
        true,                   //  print nodes
        false );                //  print nodes - high detail

    EXIT_API();
    return S_OK;
}   //  TimeoutNodes


/*
  This gets called (by DebugExtensionNotify when target is halted and is accessible
*/
HRESULT 
NotifyOnTargetAccessible(PDEBUG_CONTROL Control)
{
    dprintf( "DNS Server debugger extension dll detected a break" );
    if ( Connected )
    {
        dprintf( " (" );
        switch (TargetMachine) { 
        case IMAGE_FILE_MACHINE_I386:
            dprintf( "x86" );
            break;
        case IMAGE_FILE_MACHINE_IA64:
            dprintf( "ia64" );
            break;
        default:
            dprintf( "Unknown Architecture" );
            break;
        }
    }
    dprintf( ")\n" );

    dprintf( "\nDebugger extension build at " __DATE__ " " __TIME__ "\n\n" );
    
    //
    // show the top frame and execute dv to dump the locals here and return
    //
    Control->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                     DEBUG_OUTCTL_OVERRIDE_MASK |
                     DEBUG_OUTCTL_NOT_LOGGED,
                     ".frame", // Command to be executed
                     DEBUG_EXECUTE_DEFAULT );
    Control->Execute(DEBUG_OUTCTL_ALL_CLIENTS |
                     DEBUG_OUTCTL_OVERRIDE_MASK |
                     DEBUG_OUTCTL_NOT_LOGGED,
                     "dv", // Command to be executed
                     DEBUG_EXECUTE_DEFAULT );
    return S_OK;
}


char * g_ZoneTypeNames[] =
{
    "Cache",
    "Primary",
    "Secondary",
    "Stub",
    "Forwarder"
};


bool
printZoneProperties(
    ULONG64         pZoneFull,
    bool            fVerbose )
{
    bool okay = true;

    ZONE_INFO zone;
    if ( !myReadMemory( pZoneFull, &zone, sizeof( zone ), false ) )
    {
        okay = false;
        goto Cleanup;
    }

    char sz[ 256 ];
    if ( !myReadString( 
                ( ULONG64 ) zone.pszZoneName,
                sz,
                sizeof( sz ) ) )
    {
        okay = false;
        goto Cleanup;
    }

    if ( fVerbose )
    {
        dprintf( "\n" );
    }

    dprintf(
        "ZONE %p %s (%d)%-9s %s\n",
        pZoneFull,
        zone.fDsIntegrated ? "DS  " : "File",
        zone.fZoneType,
        zone.fZoneType <= DNS_ZONE_TYPE_FORWARDER ?
            g_ZoneTypeNames[ zone.fZoneType ] : "UNKNOWN-TYPE",
        sz );

    if ( fVerbose )
    {
        #define ZonePtr( szIndent, zoneMember )                         \
            dprintf(                                                    \
                "%s%-25s = %p\n",                                       \
                szIndent,                                               \
                #zoneMember,                                            \
                ( ULONG64 ) zone.##zoneMember )
        #define ZoneStr( szIndent, zoneMember, stringValue )            \
            dprintf(                                                    \
                "%s%-25s = %s\n",                                       \
                szIndent,                                               \
                #zoneMember,                                            \
                stringValue )
        #define ZoneDword( szIndent, zoneMember )                       \
            dprintf(                                                    \
                "%s%-25s = %8d = 0x%08X\n",                             \
                szIndent,                                               \
                #zoneMember,                                            \
                zone.##zoneMember,                                      \
                zone.##zoneMember )

        #define ZoneIndent      "  "

        *sz = '\0';
        if ( zone.pszDataFile )
        {
            if ( !myReadString( 
                        ( ULONG64 ) zone.pszDataFile,
                        sz,
                        sizeof( sz ) ) )
            {
                okay = false;
                goto Cleanup;
            }
        }
        ZoneStr( ZoneIndent, pszDataFile, sz );

        if ( zone.fDsIntegrated )
        {
            *sz = '\0';
            if ( zone.pwszZoneDN )
            {
                if ( !myReadString( 
                            ( ULONG64 ) zone.pwszZoneDN,
                            sz,
                            sizeof( sz ) ) )
                {
                    okay = false;
                    goto Cleanup;
                }
            }
            ZoneStr( ZoneIndent, pwszZoneDN, sz );
            ZonePtr( ZoneIndent, pDpInfo );
        }

        ZonePtr( ZoneIndent, pSoaRR );
        ZonePtr( ZoneIndent, pZoneRoot );
        ZonePtr( ZoneIndent, pTreeRoot );
        ZonePtr( ZoneIndent, pZoneTreeLink );
        dprintf( "\n" );

        ZonePtr( ZoneIndent, pLoadZoneRoot );
        ZonePtr( ZoneIndent, pLoadTreeRoot );
        ZonePtr( ZoneIndent, pLoadOrigin );
        ZonePtr( ZoneIndent, pOldTree );
        dprintf( "\n" );

        ZoneDword( ZoneIndent, iRRCount );
        ZoneDword( ZoneIndent, dwSerialNo );
        ZoneDword( ZoneIndent, dwLoadSerialNo );
        ZoneDword( ZoneIndent, dwLastXfrSerialNo );
        ZoneDword( ZoneIndent, dwNewSerialNo );
        ZoneDword( ZoneIndent, dwDefaultTtl );
        dprintf( "\n" );

        ZoneDword( ZoneIndent, dwNextTransferTime );
        dprintf( "\n" );

        ZoneDword( ZoneIndent, dwDcPromoConvert );
        dprintf( "\n" );
    }

    Cleanup:
    return okay;
}   //  printZoneProperties


//
//  Dump zone list with basic info on each zone.
//

HRESULT CALLBACK 
ZoneList(
    PDEBUG_CLIENT Client,
    PCSTR args )
{
    INIT_API();

    bool okay = true;
    int zoneIdx = 0;

    ULONG64 plistheadZone = GetExpression( args );

    LIST_ENTRY listEntry;
    if ( !myReadMemory( plistheadZone, &listEntry, sizeof( listEntry ), false ) )
    {
        goto Cleanup;
    }

    resetIterationCount();

    ZONE_INFO zone;
    for ( ULONG64 pzone = ( ULONG64 ) listEntry.Flink;
          pzone;
          pzone = ( ULONG64 ) zone.ListEntry.Flink )
    {
        if ( !checkIterationCount() )
        {
            break;
        }

        if ( zoneIdx != 0 && pzone == plistheadZone )
        {
            break;      //  Looped back to list head, so we're done.
        }

        if ( ++zoneIdx > 1000 )
        {
            dprintf( "Runaway zone list? Aborting enumeration...\n" );
            break;
        }

        if ( !myReadMemory( pzone, &zone, sizeof( zone ), false ) )
        {
            break;
        }

        printZoneProperties( pzone, false );
    }

    Cleanup:

    EXIT_API();
    return S_OK;
}   //  ZoneList


//
//  Dump zone info.
//

HRESULT CALLBACK 
Zone(
    PDEBUG_CLIENT Client,
    PCSTR args )
{
    INIT_API();

    ULONG64 p = GetExpression( args );
    printZoneProperties( p, true );

    EXIT_API();
    return S_OK;
}   //  Zone


//
//  Dump node info.
//

HRESULT CALLBACK 
Node(
    PDEBUG_CLIENT Client,
    PCSTR args )
{
    INIT_API();

    ULONG64 p = GetExpression( args );
    printNode( NULL, p, true );

    EXIT_API();
    return S_OK;
}   //  Node


bool
printHash(
    char * pszIndent,
    ULONG64 pHashFull,
    bool fVerbose )
{
    bool okay = true;

    char szEmptyString[] = "";
    if ( !pszIndent )
    {
        pszIndent = szEmptyString;
    }

    SIB_HASH_TABLE hash;
    okay = myReadMemory( pHashFull, &hash, sizeof( hash ), false );
    if ( !okay )
    {
        okay = false;
        goto Cleanup;
    }

    dprintf(
        "%sHASH %p lvl%02d\n",
        pszIndent,
        pHashFull,
        hash.cLevel );

    Cleanup:
    return okay;
}   //  printHash


//
//  Traverse a database tree of hashes and nodes. This function
//  is called recursively.
//

struct
{
    int     iRecurseCalls;
    int     iHashTables;
    int     iEmptyHashBuckets;
    int     iNonEmptyHashBuckets;
    int     iNodes;
    int     iNoExistNodes;
    int     iTimeoutNodes;
    int     iNodesWithNoRRs;
    int     iNodesWithNoChildren;
} g_TreeScannerStats;

//
//  iRecurseLevel: true level of function recursion
//  iChildLevel: level of node depth
//

bool
internalTreeScanner(
    ULONG64 pTreeRoot,
    bool fPrintSummary,
    bool fPrintHashNodes,
    bool fPrintHashBuckets,
    bool fPrintNodes,
    bool fPrintNodesHighDetail,
    int iRecurseLevel,               //  pass 0 on initial call
    int iChildLevel  )               //  pass 0 on initial call
{
    bool okay = true;

    //  dprintf( "internalTreeScanner p=%p level=%d\n", pTreeRoot, iRecurseLevel );

    if ( !checkIterationCount() )
    {
        return false;
    }

    if ( iRecurseLevel == 0 )
    {
        RtlZeroMemory( &g_TreeScannerStats, sizeof( g_TreeScannerStats ) );
    }

    if ( ++g_TreeScannerStats.iRecurseCalls > 10000000 )
    {
        dprintf( "Aborting: hit limit of 10000000 recurse calls\n" );
        return true;
    }

    char szIndent[] =
            "                                                            "
            "                                                            ";
    szIndent[ min( ( int ) strlen( szIndent ), iChildLevel * 2 ) ] = '\0';

    //
    //  Grab the first DWORD so we can determine if this is
    //  a hash or a node.
    //

    DWORD dw;
    if ( !myReadMemory( pTreeRoot, &dw, sizeof( dw ), false ) )
    {
        okay = false;
        goto Cleanup;
    }

    if ( IS_HASH_TABLE( &dw ) )
    {
        ++g_TreeScannerStats.iHashTables;
        if ( fPrintHashNodes )
        {
            okay = printHash( szIndent, pTreeRoot, false );
        }

        SIB_HASH_TABLE hash;
        okay = myReadMemory( pTreeRoot, &hash, sizeof( hash ), false );
        if ( !okay )
        {
            okay = false;
            goto Cleanup;
        }

        //
        //  Iterate through all the buckets in this hash node.
        //

        for ( int i = 0; i <= LAST_HASH_INDEX; ++i )
        {
            PDB_NODE pnode = hash.aBuckets[ i ];
            DWORD count = hash.aBucketCount[ i ];

            if ( pnode )
            {
                ++g_TreeScannerStats.iNonEmptyHashBuckets;

                if ( fPrintHashBuckets )
                {
                    dprintf(
                        "%sBUCKET %p  index %3d  count %3d\n",
                        szIndent,
                        ( ULONG64 ) pnode,
                        i,
                        count );
                }

                okay = internalTreeScanner(
                            ( ULONG64 ) pnode,
                            fPrintSummary,
                            fPrintHashNodes,
                            fPrintHashBuckets,
                            fPrintNodes,
                            fPrintNodesHighDetail,
                            iRecurseLevel + 1,
                            iChildLevel );
                if ( !okay )
                {
                    break;
                }
            }
            else
            {
                ++g_TreeScannerStats.iEmptyHashBuckets;
            }
        }
    }
    else
    {
        //
        //  This is a node.
        //

        ++g_TreeScannerStats.iNodes;

        DB_NODE node;
        okay = myReadMemory( pTreeRoot, &node, sizeof( node ), false );
        if ( !okay )
        {
            okay = false;
            goto Cleanup;
        }

        //
        //  Force NULL termination in case this node was allocated
        //  longer than a standard node.
        //

        * ( ( PUCHAR ) &node + sizeof( node ) - 1 ) = '\0';

        //
        //  Scan the left child tree then this node then the right child tree.
        //

        if ( node.pSibLeft )
        {
            okay = internalTreeScanner(
                        ( ULONG64 ) node.pSibLeft,
                        fPrintSummary,
                        fPrintHashNodes,
                        fPrintHashBuckets,
                        fPrintNodes,
                        fPrintNodesHighDetail,
                        iRecurseLevel + 1,
                        iChildLevel );
            if ( !okay )
            {
                goto Cleanup;
            }
        }

        if ( node.dwNodeFlags & NODE_NOEXIST )
        {
            ++g_TreeScannerStats.iNoExistNodes;
        }
        if ( node.dwNodeFlags & NODE_IN_TIMEOUT )
        {
            ++g_TreeScannerStats.iTimeoutNodes;
        }
        if ( !node.pRRList )
        {
            ++g_TreeScannerStats.iNodesWithNoRRs;
        }
        if ( !node.pChildren )
        {
            ++g_TreeScannerStats.iNodesWithNoChildren;
        }

        if ( fPrintNodes )
        {
            okay = printNode( szIndent, pTreeRoot, fPrintNodesHighDetail );
            if ( !okay )
            {
                goto Cleanup;
            }
        }

        if ( node.pChildren )
        {
            okay = internalTreeScanner(
                        ( ULONG64 ) node.pChildren,
                        fPrintSummary,
                        fPrintHashNodes,
                        fPrintHashBuckets,
                        fPrintNodes,
                        fPrintNodesHighDetail,
                        iRecurseLevel + 1,
                        iChildLevel + 1 );
            if ( !okay )
            {
                goto Cleanup;
            }
        }

        if ( node.pSibRight )
        {
            okay = internalTreeScanner(
                        ( ULONG64 ) node.pSibRight,
                        fPrintSummary,
                        fPrintHashNodes,
                        fPrintHashBuckets,
                        fPrintNodes,
                        fPrintNodesHighDetail,
                        iRecurseLevel + 1,
                        iChildLevel );
            if ( !okay )
            {
                goto Cleanup;
            }
        }
    }

    Cleanup:
    
    if ( iRecurseLevel == 0 )
    {
        if ( !okay )
        {
            dprintf( "\nERROR ITERATING TREE - STATS INCOMPLETE!\n\n" );
        }
        if ( fPrintSummary )
        {
            dprintf(
                "Tree summary for tree rooted at %p\n",
                pTreeRoot );
            dprintf(
                "  hash tables                  %d\n"
                "  empty hash buckets           %d\n"
                "  non-empty hash buckets       %d\n"
                "\n"
                "  nodes                        %d\n"
                "  no-exist nodes               %d\n"
                "  timeout nodes                %d\n"
                "  nodes with no RRs            %d\n"
                "  nodes with no children       %d\n",
                g_TreeScannerStats.iHashTables,
                g_TreeScannerStats.iEmptyHashBuckets,
                g_TreeScannerStats.iNonEmptyHashBuckets,
                g_TreeScannerStats.iNodes,
                g_TreeScannerStats.iNoExistNodes,
                g_TreeScannerStats.iTimeoutNodes,
                g_TreeScannerStats.iNodesWithNoRRs,
                g_TreeScannerStats.iNodesWithNoChildren );

        }
    }
    return okay;
}

//
//  Dump node tree.
//

HRESULT CALLBACK 
Tree(
    PDEBUG_CLIENT Client,
    PCSTR args )
{
    INIT_API();

    ULONG64 p = GetExpression( args );

    resetIterationCount();
    
    internalTreeScanner(
        p,
        true,
        true,
        true,
        true,
        false,
        0, 0 );

    EXIT_API();
    return S_OK;
}   //  Node


//
//  Print summary of a node tree.
//

HRESULT CALLBACK 
TreeSummary(
    PDEBUG_CLIENT Client,
    PCSTR args )
{
    INIT_API();

    ULONG64 p = GetExpression( args );

    resetIterationCount();

    internalTreeScanner(
        p,
        true,
        false,
        false,
        false,
        false,
        0, 0 );

    EXIT_API();
    return S_OK;
}   //  Node


//
//  Print info about a packet queue.
//

HRESULT CALLBACK 
PacketQ(
    PDEBUG_CLIENT Client,
    PCSTR args )
{
    INIT_API();

    ULONG64 p = GetExpression( args );

    PACKET_QUEUE q;
    CHAR szQueueName[ 80 ];

    if ( !myReadMemory(
                    ( ULONG64 ) p,
                    &q,
                    sizeof( q ),
                    false ) )
    {
        goto Cleanup;
    }

    if ( !myReadMemory(
                    ( ULONG64 ) q.pszName,
                    szQueueName,
                    sizeof( szQueueName ),
                    false ) )
    {
        goto Cleanup;
    }

    #define BoolFlagStr( f ) ( ( f ) ? "true" : "false" )

    dprintf(
        "Packet queue                       %p\n"
        "  queue name                       %s\n"
        "  first message                    %p\n"
        "  event                            %p\n"
        "  default timeout                  %d\n"
        "  minimum timeout                  %d\n",
        p,
        szQueueName,
        ( ULONG64 ) q.listHead.Flink,
        ( ULONG64 ) q.hEvent,
        q.dwDefaultTimeout,
        q.dwMinimumTimeout );

    dprintf(
        "  counters:\n"
        "    length                         %d\n"
        "    queued                         %d\n"
        "    dequeued                       %d\n"
        "    timed out                      %d\n",
        q.cLength,
        q.cQueued,
        q.cDequeued,
        q.cTimedOut );

    dprintf(
        "  flags:\n"
        "    query time order               %s\n"
        "    discard expired on queuing     %s\n"
        "    discard dups on queuing        %s\n"
        "  XID for referrals                %d\n",
        BoolFlagStr( q.fQueryTimeOrder ),
        BoolFlagStr( q.fDiscardExpiredOnQueuing ),
        BoolFlagStr( q.fDiscardDuplicatesOnQueuing ),
        ( int ) q.wXid );

    #undef BoolFlagStr

    Cleanup:

    EXIT_API();
    return S_OK;
}   //  PacketQ


//
//  Print info about a packet queue.
//

void
execDebugCmd(
    char * pszDebuggerCommand )
{
    g_ExtControl->Execute(
        DEBUG_OUTCTL_ALL_CLIENTS |
        DEBUG_OUTCTL_OVERRIDE_MASK |
        DEBUG_OUTCTL_NOT_LOGGED,
        pszDebuggerCommand,
        DEBUG_EXECUTE_DEFAULT );
}   //  execDebugCmd


HRESULT CALLBACK 
Globals(
    PDEBUG_CLIENT Client,
    PCSTR args )
{
    INIT_API();

    char szIndent1[] = "  ";
    char szIndent2[] = "    ";

    dprintf( "Zone list\n%s", szIndent1 );
    execDebugCmd( "dd dns!listheadZone l 2" );

    dprintf( "\nStatistics table\n%s", szIndent1 );
    execDebugCmd( "dd dns!StatsTable l 1" );

    dprintf( "\nPacket queues\n" );

    dprintf( "%sRecursion packet queue\n%s", szIndent1, szIndent2 );
    execDebugCmd( "dd dns!g_pRecursionQueue l 1" );

    dprintf( "%sSecondary packet queue\n%s", szIndent1, szIndent2 );
    execDebugCmd( "dd dns!g_SecondaryQueue l 1" );

    dprintf( "%sUpdate packet queue\n%s", szIndent1, szIndent2 );
    execDebugCmd( "dd dns!g_UpdateQueue l 1" );

    dprintf( "%sUpdate forwarding packet queue\n%s", szIndent1, szIndent2 );
    execDebugCmd( "dd dns!g_UpdateForwardingQueue l 1" );

    dprintf( "%sSecure negotiation packet queue\n%s", szIndent1, szIndent2 );
    execDebugCmd( "dd dns!g_SecureNegoQueue l 1" );

    dprintf( "%sWINS packet queue\n%s", szIndent1, szIndent2 );
    execDebugCmd( "dd dns!g_pWinsQueue l 1" );

    EXIT_API();
    return S_OK;
}   //  Globals


//
//  Dump a message.
//

HRESULT CALLBACK 
Msg(
    PDEBUG_CLIENT Client,
    PCSTR args )
{
    INIT_API();

    ULONG64 p = GetExpression( args );
    
    BYTE msg[ sizeof( DNS_MSGINFO ) + 512 ];
    PDNS_MSGINFO pmsg = ( PDNS_MSGINFO ) msg;
    if ( !myReadMemory( p, msg, sizeof( msg ), false ) )
    {
        goto Cleanup;
    }

    #define BoolFlagStr( f ) ( ( f ) ? "true" : "false" )

    dprintf(
        "DNS message                    %p\n"
        "Buffer info:\n"
        "  Tag                          %08X\n"
        "  BufferLength                 %d\n"
        "  MaxBufferLength              %d\n"
        "  MessageLength                %d\n"
        "  BytesToReceive               %d\n"
        "  pBufferEnd                   %p\n"
        "  pCurrent                     %p\n",
        ( ULONG64 ) p,
        pmsg->Tag,
        pmsg->BufferLength,
        pmsg->MaxBufferLength,
        ( int ) pmsg->MessageLength,
        ( int ) pmsg->BytesToReceive,
        ( ULONG64 ) pmsg->pBufferEnd,
        ( ULONG64 ) pmsg->pCurrent );

    dprintf(
        "Remote info:\n"
        "  Socket                       %d\n"
        "  RemoteAddr Family            %d\n"
        "  RemoteAddr Length            %d\n"
        "  RemoteAddr                   %08X = %d.%d.%d.%d\n",
        ( int ) pmsg->Socket,
        ( int ) pmsg->RemoteAddr.SockaddrIn.sin_family,
        ( int ) pmsg->RemoteAddr.SockaddrLength,
        ( int ) pmsg->RemoteAddr.SockaddrIn.sin_addr.s_addr,
        ( int ) pmsg->RemoteAddr.SockaddrIn.sin_addr.S_un.S_un_b.s_b1,
        ( int ) pmsg->RemoteAddr.SockaddrIn.sin_addr.S_un.S_un_b.s_b2,
        ( int ) pmsg->RemoteAddr.SockaddrIn.sin_addr.S_un.S_un_b.s_b3,
        ( int ) pmsg->RemoteAddr.SockaddrIn.sin_addr.S_un.S_un_b.s_b4 );

    dprintf(
        "Lookup info:\n"
        "  pnodeCurrent                 %p\n"
        "  pnodeClosest                 %p\n"
        "  pzoneCurrent                 %p\n"
        "  pnodeGlue                    %p\n"
        "  pnodeDelegation              %p\n"
        "  pnodeCache                   %p\n"
        "  pnodeCacheClosest            %p\n",
        ( ULONG64 ) pmsg->pnodeCurrent,
        ( ULONG64 ) pmsg->pnodeClosest,
        ( ULONG64 ) pmsg->pzoneCurrent,
        ( ULONG64 ) pmsg->pnodeGlue,
        ( ULONG64 ) pmsg->pnodeDelegation,
        ( ULONG64 ) pmsg->pnodeCache,
        ( ULONG64 ) pmsg->pnodeCacheClosest );

    dprintf(
        "  pnodeNxt                     %p\n"
        "  wTypeCurrent                 %d\n"
        "  wOffsetCurrent               %d\n"
        "  pNodeQuestion                %p\n"
        "  pNodeQuestionClosest         %p\n"
        "  pQuestion                    %p\n"
        "  wQuestionType                %d\n",
        ( ULONG64 ) pmsg->pnodeNxt,
        ( int ) pmsg->wTypeCurrent,
        ( int ) pmsg->wOffsetCurrent,
        ( ULONG64 ) pmsg->pNodeQuestion,
        ( ULONG64 ) pmsg->pNodeQuestionClosest,
        ( ULONG64 ) pmsg->pQuestion,
        ( int ) pmsg->wQuestionType );

    dprintf(
        "Queuing info:\n"
        "  wQueuingXid                  %d\n"
        "  dwQueryTime                  %d\n"
        "  dwMsQueryTime                %d\n"
        "  dwQueuingTime                %d\n"
        "  dwExpireTime                 %d\n",
        ( int ) pmsg->wQueuingXid,
        pmsg->dwQueryTime,
        pmsg->dwMsQueryTime,
        pmsg->dwQueuingTime,
        pmsg->dwExpireTime );

    dprintf(
        "EDNS info\n"
        "  fFoundOptInIncomingMsg       %s\n"
        "  fInsertOptInOutgoingMsg      %s\n"
        "  cExtendedRCodeBits           %d\n"
        "  cVersion                     %d\n"
        "  wUdpPayloadSize              %d\n"
        "  wOptOffset                   %d\n"
        "  wOriginalQueryPayloadSize    %d\n",
        BoolFlagStr( pmsg->Opt.fFoundOptInIncomingMsg ),
        BoolFlagStr( pmsg->Opt.fInsertOptInOutgoingMsg ),
        ( int ) pmsg->Opt.cExtendedRCodeBits,
        ( int ) pmsg->Opt.cVersion,
        ( int ) pmsg->Opt.wUdpPayloadSize,
        ( int ) pmsg->Opt.wOptOffset,
        ( int ) pmsg->Opt.wOriginalQueryPayloadSize );

    dprintf(
        "Recursion info:\n"
        "  pRecurseMsg                  %p\n"
        "  pnodeRecurseRetry            %p\n"
        "  pNsList                      %p\n",
        ( ULONG64 ) pmsg->pRecurseMsg,
        ( ULONG64 ) pmsg->pnodeRecurseRetry,
        ( ULONG64 ) pmsg->pNsList );

    dprintf(
        "Flags:\n"
        "  fDelete                      %s\n"
        "  fTcp                         %s\n"
        "  fMessageComplete             %s\n"
        "  Section                      %d\n"
        "  fDoAdditional                %s\n"
        "  fRecurseIfNecessary          %s\n"
        "  fRecursePacket               %s\n"
        "  fQuestionRecursed            %s\n"
        "  fQuestionCompleted           %s\n",
        BoolFlagStr( pmsg->fDelete ),
        BoolFlagStr( pmsg->fTcp ),
        BoolFlagStr( pmsg->fMessageComplete ),
        ( int ) pmsg->Section,
        BoolFlagStr( pmsg->fDoAdditional ),
        BoolFlagStr( pmsg->fRecurseIfNecessary ),
        BoolFlagStr( pmsg->fRecursePacket ),
        BoolFlagStr( pmsg->fQuestionRecursed ),
        BoolFlagStr( pmsg->fQuestionCompleted ) );

    dprintf(
        "  fRecurseQuestionSent         %s\n"
        "  fRecurseTimeoutWait          %s\n"
        "  nTimeoutCount                %d\n"
        "  nForwarder                   %d\n"
        "  fReplaceCname                %s\n"
        "  cCnameAnswerCount            %d\n"
        "  fNoCompressionWrite          %s\n"
        "  fWins                        %s\n"
        "  fQuestionWildcard            %s\n"
        "  fNsList                      %s\n",
        BoolFlagStr( pmsg->fRecurseQuestionSent ),
        BoolFlagStr( pmsg->fRecurseTimeoutWait ),
        ( int ) pmsg->nTimeoutCount,
        ( int ) pmsg->nForwarder,
        BoolFlagStr( pmsg->fReplaceCname ),
        ( int ) pmsg->cCnameAnswerCount,
        BoolFlagStr( pmsg->fNoCompressionWrite ),
        BoolFlagStr( pmsg->fWins ),
        BoolFlagStr( pmsg->fQuestionWildcard ),
        BoolFlagStr( pmsg->fNsList ) );

    dprintf(
        "DNS header:\n"
        "  Xid                          %04X\n"
        "  RecursionDesired             %d\n"
        "  Truncation                   %d\n"
        "  Authoritative                %d\n"
        "  Opcode                       %d\n"
        "  IsResponse                   %d\n",
        ( int ) pmsg->Head.Xid,
        ( int ) pmsg->Head.RecursionDesired,
        ( int ) pmsg->Head.Truncation,
        ( int ) pmsg->Head.Authoritative,
        ( int ) pmsg->Head.Opcode,
        ( int ) pmsg->Head.IsResponse );

    dprintf(
        "  ResponseCode                 %d\n"
        "  RecursionAvailable           %d\n"
        "  QuestionCount                %d\n"
        "  AnswerCount                  %d\n"
        "  NameServerCount              %d\n"
        "  AdditionalCount              %d\n",
        ( int ) pmsg->Head.ResponseCode,
        ( int ) pmsg->Head.RecursionAvailable,
        ( int ) pmsg->Head.QuestionCount,
        ( int ) pmsg->Head.AnswerCount,
        ( int ) pmsg->Head.NameServerCount,
        ( int ) pmsg->Head.AdditionalCount );

    ULONG64 pmsgbody = ( ULONG64 ) ( ( PBYTE ) p +
                            ( ( PBYTE ) pmsg->MessageBody -
                                ( PBYTE ) pmsg ) );
    dprintf(
        "DNS message body at            %p\n",
        pmsgbody );

    Cleanup:
    EXIT_API();
    return S_OK;
}   //  Msg


//
//  Set a max count to be respected by all other iterating commands.
//  This is cool for example if you have a tree with a million nodes
//  and you just want to dump the first few hundred to get an idea of
//  what's going on.
//

HRESULT CALLBACK 
MaxIterations(
    PDEBUG_CLIENT Client,
    PCSTR args )
{
    INIT_API();

    g_iMaxIterations = ( int ) GetExpression( args );
    
    dprintf(
        "MaxIterations set to %d%s\n",
        g_iMaxIterations,
        g_iMaxIterations == 0 ? " (unlimited)" : "" );

    EXIT_API();
    return S_OK;
}   //  MaxIterations


//
//  Help for the other commands
//

HRESULT CALLBACK 
help(
    PDEBUG_CLIENT Client,
    PCSTR args )
{
    INIT_API();

    dprintf(
        "Help for dnsdbg.dll\n"
        "  Globals"
        "    Print current values of various globals.\n"
        "  ZoneList ADDR\n"
        "    Print zone list. Argument is address of listheadZone.\n"
        "  Zone ADDR\n"
        "     Print zone info. Argument is address of ZONE_INFO struct.\n"
        "  Node ADDR\n"
        "     Print node info. Argument is address of DB_NODE struct.\n" );
    dprintf(
        "  Tree ADDR\n"
        "     Traverse and print a tree of nodes. Argument is address of the\n"
        "     tree root. The tree root can be a hash table or a DB_NODE.\n"
        "  TreeSummary ADDR\n"
        "     Traverse and print summary for a node tree. Argument same as Tree.\n"
        "  Stats ADDR\n"
        "     Print server statistics. Argument is address of StatsTable\n" );
    dprintf(
        "  TimeoutSummary ADDR\n"
        "     Print summary of nodes in the timeout system.\n"
        "     Argument is address of TimeoutBinArray\n"
        "  TimeoutArrays ADDR\n"
        "     Print timeout system arrays. Argument is address of TimeoutBinArray\n"
        "  TimeoutNodes ADDR\n"
        "     Print timeout system arrays and nodes.\n"
        "     Argument is address of TimeoutBinArray\n"
        "  PacketQ ADDR\n"
        "     Print packet queue info. Argument is address of PACKET_QUEUE struct.\n"
        "  Msg ADDR\n"
        "     Print message info. Argument is address of DNS_MSGINFO struct.\n" );
    dprintf(
        "  MaxIterations COUNT\n"
        "     Set max nodes or objects to visit. Argument is count in hex.\n"
        "  help - shows this help\n" );

    EXIT_API();
    return S_OK;
}   //  help
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\dnsperf\dnsperf.h ===
//
//  DNSCTR.h
//
//  Offset definition file for exensible counter objects and counters
//
//  These "relative" offsets must start at 0 and be multiples of 2 (i.e.
//  even numbers). In the Open Procedure, they will be added to the
//  "First Counter" and "First Help" values of the device they belong to,
//  in order to determine the  absolute location of the counter and
//  object names and corresponding help text in the registry.
//
//  this file is used by the extensible counter DLL code as well as the
//  counter name and help text definition file (.INI) file that is used
//  by LODCTR to load the names into the registry.
//
//  We use a version number to keep track of which set of counters we are
//  using, and whether the performance counters in the registry need to be
//  reloaded.  If you add or delete any counters, please change the version
//  number at the end of this file.
//
#define DNSOBJ                          0
#define TOTALQUERYRECEIVED              2
#define TOTALQUERYRECEIVED_S            4
#define UDPQUERYRECEIVED                6
#define UDPQUERYRECEIVED_S              8
#define TCPQUERYRECEIVED                10
#define TCPQUERYRECEIVED_S              12
#define TOTALRESPONSESENT               14
#define TOTALRESPONSESENT_S             16
#define UDPRESPONSESENT                 18
#define UDPRESPONSESENT_S               20
#define TCPRESPONSESENT                 22
#define TCPRESPONSESENT_S               24
#define RECURSIVEQUERIES                26
#define RECURSIVEQUERIES_S              28
#define RECURSIVETIMEOUT                30
#define RECURSIVETIMEOUT_S              32
#define RECURSIVEQUERYFAILURE           34
#define RECURSIVEQUERYFAILURE_S         36
#define NOTIFYSENT                      38
#define ZONETRANSFERREQUESTRECEIVED     40
#define ZONETRANSFERSUCCESS             42
#define ZONETRANSFERFAILURE             44
#define AXFRREQUESTRECEIVED             46
#define AXFRSUCCESSSENT                 48
#define IXFRREQUESTRECEIVED             50
#define IXFRSUCCESSSENT                 52
#define NOTIFYRECEIVED                  54
#define ZONETRANSFERSOAREQUESTSENT      56
#define AXFRREQUESTSENT                 58
#define AXFRRESPONSERECEIVED            60
#define AXFRSUCCESSRECEIVED             62
#define IXFRREQUESTSENT                 64
#define IXFRRESPONSERECEIVED            66
#define IXFRSUCCESSRECEIVED             68
#define IXFRUDPSUCCESSRECEIVED          70
#define IXFRTCPSUCCESSRECEIVED          72
#define WINSLOOKUPRECEIVED              74
#define WINSLOOKUPRECEIVED_S            76
#define WINSRESPONSESENT                78
#define WINSRESPONSESENT_S              80
#define WINSREVERSELOOKUPRECEIVED       82
#define WINSREVERSELOOKUPRECEIVED_S     84
#define WINSREVERSERESPONSESENT         86
#define WINSREVERSERESPONSESENT_S       88
#define DYNAMICUPDATERECEIVED           90
#define DYNAMICUPDATERECEIVED_S         92
#define DYNAMICUPDATENOOP               94
#define DYNAMICUPDATENOOP_S             96
#define DYNAMICUPDATEWRITETODB          98
#define DYNAMICUPDATEWRITETODB_S        100
#define DYNAMICUPDATEREJECTED           102
#define DYNAMICUPDATETIMEOUT            104
#define DYNAMICUPDATEQUEUED             106
#define SECUREUPDATERECEIVED            108
#define SECUREUPDATERECEIVED_S          110
#define SECUREUPDATEFAILURE             112
#define DATABASENODEMEMORY              114
#define RECORDFLOWMEMORY                116
#define CACHINGMEMORY                   118
#define UDPMESSAGEMEMORY                120
#define TCPMESSAGEMEMORY                122
#define NBSTATMEMORY                    124

#define DNS_PERF_COUNTER_BLOCK  TEXT("Global\\Microsoft.Windows.DNS.Perf")


extern volatile unsigned long * pcTotalQueryReceived;
extern volatile unsigned long * pcUdpQueryReceived;
extern volatile unsigned long * pcTcpQueryReceived;
extern volatile unsigned long * pcTotalResponseSent;
extern volatile unsigned long * pcUdpResponseSent;
extern volatile unsigned long * pcTcpResponseSent;
extern volatile unsigned long * pcRecursiveQueries;
extern volatile unsigned long * pcRecursiveTimeOut;
extern volatile unsigned long * pcRecursiveQueryFailure;
extern volatile unsigned long * pcNotifySent;
extern volatile unsigned long * pcZoneTransferRequestReceived;
extern volatile unsigned long * pcZoneTransferSuccess;
extern volatile unsigned long * pcZoneTransferFailure;
extern volatile unsigned long * pcAxfrRequestReceived;
extern volatile unsigned long * pcAxfrSuccessSent;
extern volatile unsigned long * pcIxfrRequestReceived;
extern volatile unsigned long * pcIxfrSuccessSent;
extern volatile unsigned long * pcNotifyReceived;
extern volatile unsigned long * pcZoneTransferSoaRequestSent;
extern volatile unsigned long * pcAxfrRequestSent;
extern volatile unsigned long * pcAxfrResponseReceived;
extern volatile unsigned long * pcAxfrSuccessReceived;
extern volatile unsigned long * pcIxfrRequestSent;
extern volatile unsigned long * pcIxfrResponseReceived;
extern volatile unsigned long * pcIxfrSuccessReceived;
extern volatile unsigned long * pcIxfrUdpSuccessReceived;
extern volatile unsigned long * pcIxfrTcpSuccessReceived;
extern volatile unsigned long * pcWinsLookupReceived;
extern volatile unsigned long * pcWinsResponseSent;
extern volatile unsigned long * pcWinsReverseLookupReceived;
extern volatile unsigned long * pcWinsReverseResponseSent;
extern volatile unsigned long * pcDynamicUpdateReceived;
extern volatile unsigned long * pcDynamicUpdateNoOp;
extern volatile unsigned long * pcDynamicUpdateWriteToDB;
extern volatile unsigned long * pcDynamicUpdateRejected;
extern volatile unsigned long * pcDynamicUpdateTimeOut;
extern volatile unsigned long * pcDynamicUpdateQueued;
extern volatile unsigned long * pcSecureUpdateReceived;
extern volatile unsigned long * pcSecureUpdateFailure;
extern volatile unsigned long * pcDatabaseNodeMemory;
extern volatile unsigned long * pcRecordFlowMemory;
extern volatile unsigned long * pcCachingMemory;
extern volatile unsigned long * pcUdpMessageMemory;
extern volatile unsigned long * pcTcpMessageMemory;
extern volatile unsigned long * pcNbstatMemory;


#define PERF_INC(p)         ( ++(*(p)) )
#define PERF_DEC(p)         ( --(*(p)) )
#define PERF_ADD(p, c)      ( (*(p)) += (c) )
#define PERF_SUB(p, c)      ( (*(p)) -= (c) )
#define PERF_SET(p, c)      ( (*(p)) =  (c) )


#define DNS_PERFORMANCE_COUNTER_VERSION 1
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\dnsperf\perfconfig.h ===
#ifdef __cplusplus
extern "C" {
#endif

/*
 *  GetConfigParam()
 *
 *      LPTSTR  parameter   - item for which we want the value
 *      PVOID   value       - pointer to variable in which to
 *                            place the value
 *      DWORD   dwSize      - size of value in bytes
 */

DWORD
GetConfigParam(
    //char * parameter,
    LPTSTR  parameter,
    void * value,
    DWORD dwSize);

DWORD
SetConfigParam(
    //char * parameter,
    LPCTSTR  parameter,
    DWORD dwType,
    void * value,
    DWORD dwSize);

/*
 *  Following is the list keys defined for use by the DNS and
 *  utilities.  First, the sections.
 */
#define SERVICE_NAME            "DNS"
#define DNS_CONFIG_ROOT         "System\\CurrentControlSet\\Services\\DNS"
#define DNS_CONFIG_SECTION      "System\\CurrentControlSet\\Services\\DNS\\Parameters"
#define DNS_PERF_SECTION        "System\\CurrentControlSet\\Services\\DNS\\Performance"
#define DNS_SECURITY_SECTION    "SOFTWARE\\Microsoft\\DNS\\Security"


/* Parameters keys */
#define PERF_COUNTER_VERSION    "Performance Counter Version"
#define DNS_PERF_DLL            "dnsperf.dll"

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\dnsperf\datadns.h ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

      datadns.h

Abstract:

    Header file for the DNS Extensible Object data definitions

    This file contains definitions to construct the dynamic data
    which is returned by the Configuration Registry.  Data from
    various system API calls is placed into the structures shown
    here.

Author:



Revision History:

    Jing Chen 1998
    (following the example of nt\private\ds\src\perfdsa\datadsa.h)

--*/

#ifndef _DATADNS_H_
#define _DATADNS_H_


/****************************************************************************\

           Adding a Counter to the Extensible Objects (DNS) Code

Note that the order or position of counters is significant.
There are two orders which are important, the order of counters indexes for
names and help, and the order of data in the shared data block for passing
your values.
You want to maintain consistent counter order, and consistent data layout,
across all five files to be modified.

You want to make sure that your binary matches the .h/.ini file on the target,
which gets loaded into the registry.

1. nt\ds\dns\server\perfdns\dnsperf.h
This file is copied to the %windir%\system32 directory of the target along
with the dnsctrs.ini file.
a. Add your counter offset at the end of the counter name list. Order
significant.
b. Add an extern reference for the pointer which the actual code will use
to set the measured value. Order doesn't matter.
c. Change the DNS peformance counter version number so the counters will
be reloaded on the next reboot.

2. nt\ds\dns\server\perfdns\dnsctrs.ini
This file is also copied to the %windir%\system32 directory of the target and
is read by the lodctr/unlodctr program to copy the counters in the registry.
a. Supply your counter visible name and help.  These are used by the perfmon
program. Order doesn't matter.

3. nt\ds\dns\server\perfdns\datadns.h (this file)
a. Add your data offset definition. Order significant.
b. Add a field to the DSA_DATA_DEFINITION for your counter. Order significant.

4. nt\ds\dns\server\perfdns\perfdns.c
This is the dll which perfmon uses to learn about your counters, and to read
them out of the shared data area.
a. Runtime Initialize the DnsDataDefinition name index and help index
   (CounterNameTitleIndex & CounterHelpTitleIndex). Order doesn't matter.
b. Update the huge initializer for the DnsDataDefinition array of counters to
   include your new counter (defined in 3b). Order important.

5.  nt\ds\dns\server\server\startperf.c
This file provides init function, startPerf(), which is called when DNS server
starts.  It loads the shared memory block and initializes pointers to the
counter fields.  It also loads/reloads the registry counters as necessary
according the version field.
a. Declare the pointer to the data in your counter. Order does not matter.
b. Initialize the pointer to the right location in the shared data block.
   Order of assignments doesn't matter.
c. Update the max size assert if your new counter is the last one
d. Initialize your pointer to the dummy value on error

6. yourfile.c
This is the file in the dns where the measured counter is changed.  Use public
operations, INC/DEC/ADD/SUB/SET, in dnsperf.h on the pointer to your data.

Note: adding an object is a little more work, but in all the same
places.  See the existing code for examples.  In addition, you must
increase the *NumObjectTypes parameter to CollectDnsPerformanceData
on return from that routine.

\****************************************************************************/

//
//  The routines that load these structures assume that all fields
//  are packed and aligned on DWORD boundries. Alpha support may
//  change this assumption so the pack pragma is used here to insure
//  the DWORD packing assumption remains valid.
//
#pragma pack (4)

//
//  Extensible Object definitions
//

//  Update the following sort of define when adding an object type.

#define DNS_NUM_PERF_OBJECT_TYPES 1

//----------------------------------------------------------------------------

//
//  DNS Resource object type counter definitions.
//
//  These are used in the counter definitions to describe the relative
//  position of each counter in the returned data.
//
//  The first counter (FirstCnt) follows immediately after the
//  PERF_COUNTER_BLOCK, and subsequent counters follow immediately
//  after.  Thus the offest of any counter in the block is <offset of
//  previous counter> + <size of previous counter>


// data offset:

#define TOTALQUERYRECEIVED_OFFSET       sizeof(PERF_COUNTER_BLOCK)
#define UDPQUERYRECEIVED_OFFSET         TOTALQUERYRECEIVED_OFFSET   + sizeof(DWORD)
#define TCPQUERYRECEIVED_OFFSET         UDPQUERYRECEIVED_OFFSET     + sizeof(DWORD)
#define TOTALRESPONSESENT_OFFSET        TCPQUERYRECEIVED_OFFSET     + sizeof(DWORD)
#define UDPRESPONSESENT_OFFSET          TOTALRESPONSESENT_OFFSET    + sizeof(DWORD)
#define TCPRESPONSESENT_OFFSET          UDPRESPONSESENT_OFFSET      + sizeof(DWORD)
#define RECURSIVEQUERIES_OFFSET         TCPRESPONSESENT_OFFSET      + sizeof(DWORD)
#define RECURSIVETIMEOUT_OFFSET         RECURSIVEQUERIES_OFFSET     + sizeof(DWORD)
#define RECURSIVEQUERYFAILURE_OFFSET    RECURSIVETIMEOUT_OFFSET     + sizeof(DWORD)
#define NOTIFYSENT_OFFSET               RECURSIVEQUERYFAILURE_OFFSET+ sizeof(DWORD)
#define ZONETRANSFERREQUESTRECEIVED_OFFSET    NOTIFYSENT_OFFSET     + sizeof(DWORD)
#define ZONETRANSFERSUCCESS_OFFSET      ZONETRANSFERREQUESTRECEIVED_OFFSET + sizeof(DWORD)
#define ZONETRANSFERFAILURE_OFFSET      ZONETRANSFERSUCCESS_OFFSET  + sizeof(DWORD)
#define AXFRREQUESTRECEIVED_OFFSET      ZONETRANSFERFAILURE_OFFSET  + sizeof(DWORD)
#define AXFRSUCCESSSENT_OFFSET          AXFRREQUESTRECEIVED_OFFSET  + sizeof(DWORD)
#define IXFRREQUESTRECEIVED_OFFSET      AXFRSUCCESSSENT_OFFSET      + sizeof(DWORD)
#define IXFRSUCCESSSENT_OFFSET          IXFRREQUESTRECEIVED_OFFSET  + sizeof(DWORD)
#define NOTIFYRECEIVED_OFFSET           IXFRSUCCESSSENT_OFFSET      + sizeof(DWORD)
#define ZONETRANSFERSOAREQUESTSENT_OFFSET \
                                    NOTIFYRECEIVED_OFFSET       + sizeof(DWORD)
#define AXFRREQUESTSENT_OFFSET      ZONETRANSFERSOAREQUESTSENT_OFFSET  + sizeof(DWORD)
#define AXFRRESPONSERECEIVED_OFFSET AXFRREQUESTSENT_OFFSET      + sizeof(DWORD)
#define AXFRSUCCESSRECEIVED_OFFSET  AXFRRESPONSERECEIVED_OFFSET + sizeof(DWORD)
#define IXFRREQUESTSENT_OFFSET      AXFRSUCCESSRECEIVED_OFFSET  + sizeof(DWORD)
#define IXFRRESPONSERECEIVED_OFFSET IXFRREQUESTSENT_OFFSET      + sizeof(DWORD)
#define IXFRSUCCESSRECEIVED_OFFSET  IXFRRESPONSERECEIVED_OFFSET + sizeof(DWORD)
#define IXFRUDPSUCCESSRECEIVED_OFFSET \
                                    IXFRSUCCESSRECEIVED_OFFSET  + sizeof(DWORD)
#define IXFRTCPSUCCESSRECEIVED_OFFSET \
                                    IXFRUDPSUCCESSRECEIVED_OFFSET + sizeof(DWORD)
#define WINSLOOKUPRECEIVED_OFFSET   IXFRTCPSUCCESSRECEIVED_OFFSET  + sizeof(DWORD)
#define WINSRESPONSESENT_OFFSET     WINSLOOKUPRECEIVED_OFFSET   + sizeof(DWORD)
#define WINSREVERSELOOKUPRECEIVED_OFFSET \
                                    WINSRESPONSESENT_OFFSET     + sizeof(DWORD)
#define WINSREVERSERESPONSESENT_OFFSET \
                                    WINSREVERSELOOKUPRECEIVED_OFFSET + sizeof(DWORD)
#define DYNAMICUPDATERECEIVED_OFFSET \
                                    WINSREVERSERESPONSESENT_OFFSET + sizeof(DWORD)
#define DYNAMICUPDATENOOP_OFFSET    DYNAMICUPDATERECEIVED_OFFSET + sizeof(DWORD)
#define DYNAMICUPDATEWRITETODB_OFFSET \
                                    DYNAMICUPDATENOOP_OFFSET    + sizeof(DWORD)
#define DYNAMICUPDATEREJECTED_OFFSET \
                                    DYNAMICUPDATEWRITETODB_OFFSET + sizeof(DWORD)
#define DYNAMICUPDATETIMEOUT_OFFSET DYNAMICUPDATEREJECTED_OFFSET + sizeof(DWORD)
#define DYNAMICUPDATEQUEUED_OFFSET  DYNAMICUPDATETIMEOUT_OFFSET + sizeof(DWORD)
#define SECUREUPDATERECEIVED_OFFSET DYNAMICUPDATEQUEUED_OFFSET  + sizeof(DWORD)
#define SECUREUPDATEFAILURE_OFFSET  SECUREUPDATERECEIVED_OFFSET + sizeof(DWORD)
#define DATABASENODEMEMORY_OFFSET   SECUREUPDATEFAILURE_OFFSET  + sizeof(DWORD)
#define RECORDFLOWMEMORY_OFFSET     DATABASENODEMEMORY_OFFSET   + sizeof(DWORD)
#define CACHINGMEMORY_OFFSET        RECORDFLOWMEMORY_OFFSET     + sizeof(DWORD)
#define UDPMESSAGEMEMORY_OFFSET     CACHINGMEMORY_OFFSET        + sizeof(DWORD)
#define TCPMESSAGEMEMORY_OFFSET     UDPMESSAGEMEMORY_OFFSET     + sizeof(DWORD)
#define NBSTATMEMORY_OFFSET         TCPMESSAGEMEMORY_OFFSET     + sizeof(DWORD)

#define SIZE_OF_DNS_PERFORMANCE_DATA \
                                    NBSTATMEMORY_OFFSET         + sizeof(DWORD)



//
//  This is the counter structure presently returned by Dns for
//  each Resource.  Each Resource is an Instance, named by its number.
//

typedef struct _DNS_DATA_DEFINITION
{
    PERF_OBJECT_TYPE            DnsObjectType;

    PERF_COUNTER_DEFINITION     TotalQueryReceived;
    PERF_COUNTER_DEFINITION     TotalQueryReceived_s;
    PERF_COUNTER_DEFINITION     UdpQueryReceived;
    PERF_COUNTER_DEFINITION     UdpQueryReceived_s;
    PERF_COUNTER_DEFINITION     TcpQueryReceived;
    PERF_COUNTER_DEFINITION     TcpQueryReceived_s;
    PERF_COUNTER_DEFINITION     TotalResponseSent;
    PERF_COUNTER_DEFINITION     TotalResponseSent_s;
    PERF_COUNTER_DEFINITION     UdpResponseSent;
    PERF_COUNTER_DEFINITION     UdpResponseSent_s;
    PERF_COUNTER_DEFINITION     TcpResponseSent;
    PERF_COUNTER_DEFINITION     TcpResponseSent_s;
    PERF_COUNTER_DEFINITION     RecursiveQueries;
    PERF_COUNTER_DEFINITION     RecursiveQueries_s;
    PERF_COUNTER_DEFINITION     RecursiveTimeOut;
    PERF_COUNTER_DEFINITION     RecursiveTimeOut_s;
    PERF_COUNTER_DEFINITION     RecursiveQueryFailure;
    PERF_COUNTER_DEFINITION     RecursiveQueryFailure_s;
    PERF_COUNTER_DEFINITION     NotifySent;
    PERF_COUNTER_DEFINITION     ZoneTransferRequestReceived;
    PERF_COUNTER_DEFINITION     ZoneTransferSuccess;
    PERF_COUNTER_DEFINITION     ZoneTransferFailure;
    PERF_COUNTER_DEFINITION     AxfrRequestReceived;
    PERF_COUNTER_DEFINITION     AxfrSuccessSent;
    PERF_COUNTER_DEFINITION     IxfrRequestReceived;
    PERF_COUNTER_DEFINITION     IxfrSuccessSent;
    PERF_COUNTER_DEFINITION     NotifyReceived;
    PERF_COUNTER_DEFINITION     ZoneTransferSoaRequestSent;
    PERF_COUNTER_DEFINITION     AxfrRequestSent;
    PERF_COUNTER_DEFINITION     AxfrResponseReceived;
    PERF_COUNTER_DEFINITION     AxfrSuccessReceived;
    PERF_COUNTER_DEFINITION     IxfrRequestSent;
    PERF_COUNTER_DEFINITION     IxfrResponseReceived;
    PERF_COUNTER_DEFINITION     IxfrSuccessReceived;
    PERF_COUNTER_DEFINITION     IxfrUdpSuccessReceived;
    PERF_COUNTER_DEFINITION     IxfrTcpSuccessReceived;
    PERF_COUNTER_DEFINITION     WinsLookupReceived;
    PERF_COUNTER_DEFINITION     WinsLookupReceived_s;
    PERF_COUNTER_DEFINITION     WinsResponseSent;
    PERF_COUNTER_DEFINITION     WinsResponseSent_s;
    PERF_COUNTER_DEFINITION     WinsReverseLookupReceived;
    PERF_COUNTER_DEFINITION     WinsReverseLookupReceived_s;
    PERF_COUNTER_DEFINITION     WinsReverseResponseSent;
    PERF_COUNTER_DEFINITION     WinsReverseResponseSent_s;
    PERF_COUNTER_DEFINITION     DynamicUpdateReceived;
    PERF_COUNTER_DEFINITION     DynamicUpdateReceived_s;
    PERF_COUNTER_DEFINITION     DynamicUpdateNoOp;
    PERF_COUNTER_DEFINITION     DynamicUpdateNoOp_s;
    PERF_COUNTER_DEFINITION     DynamicUpdateWriteToDB;
    PERF_COUNTER_DEFINITION     DynamicUpdateWriteToDB_s;
    PERF_COUNTER_DEFINITION     DynamicUpdateRejected;
    PERF_COUNTER_DEFINITION     DynamicUpdateTimeOut;
    PERF_COUNTER_DEFINITION     DynamicUpdateQueued;
    PERF_COUNTER_DEFINITION     SecureUpdateReceived;
    PERF_COUNTER_DEFINITION     SecureUpdateReceived_s;
    PERF_COUNTER_DEFINITION     SecureUpdateFailure;
    PERF_COUNTER_DEFINITION     DatabaseNodeMemory;
    PERF_COUNTER_DEFINITION     RecordFlowMemory;
    PERF_COUNTER_DEFINITION     CachingMemory;
    PERF_COUNTER_DEFINITION     UdpMessageMemory;
    PERF_COUNTER_DEFINITION     TcpMessageMemory;
    PERF_COUNTER_DEFINITION     NbstatMemory;

} DNS_DATA_DEFINITION;

#pragma pack ()

#endif //_DATADNS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\dnsperf\perfutil.h ===
/*
Copyright (c) 1992 Microsoft Corporation

Module Name:
    perfutil.h  

Abstract:
    This file supports routines used to parse and
    create Performance Monitor Data Structures.
    It actually supports Performance Object types with
    multiple instances

Author:
    Russ Blake  7/30/92

Revision History:
    11/1/95	Dave Van Horn	Trim out unused.

--*/
#ifndef _PERFUTIL_H_
#define _PERFUTIL_H_

extern WCHAR  GLOBAL_STRING[];      // Global command (get all local ctrs)
extern WCHAR  FOREIGN_STRING[];           // get data from foreign computers
extern WCHAR  COSTLY_STRING[];      
extern WCHAR  NULL_STRING[];

#define QUERY_GLOBAL    1
#define QUERY_ITEMS     2
#define QUERY_FOREIGN   3
#define QUERY_COSTLY    4

/*
 * The definition of the routines in perfutil.c, 
 */

DWORD   GetQueryType(IN LPWSTR);
BOOL    IsNumberInUnicodeList(DWORD, LPWSTR);

#endif  //_PERFUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\dnsadddp\precomp.h ===
/*++

Copyright (c) 1995-2000  Microsoft Corporation

Module Name:

    DnsAddDp.h

Abstract:

    Domain Name System (DNS)

    DNS Directory Partition Creation Utility

Author:

    Jeff Westhead (jwesth)      April 2001

Revision History:

--*/


#ifndef _DNSADDDP_PRECOMP_INCLUDED_
#define _DNSADDDP_PRECOMP_INCLUDED_

#pragma warning(disable:4214)
#pragma warning(disable:4514)
#pragma warning(disable:4152)

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windef.h>

//  headers are messed up
//  if you bring in nt.h, then don't bring in winnt.h and
//  then you miss these

#ifndef MAXWORD
#define MINCHAR     0x80
#define MAXCHAR     0x7f
#define MINSHORT    0x8000
#define MAXSHORT    0x7fff
#define MINLONG     0x80000000
#define MAXLONG     0x7fffffff
#define MAXBYTE     0xff
#define MAXWORD     0xffff
#define MAXDWORD    0xffffffff
#endif

#include <winsock2.h>
#include "dnsrpc_c.h"   //  MIDL generated RPC interface definitions
#include <dnsrpc.h>

#include <stdio.h>
#include <stdlib.h>

#define  NO_DNSAPI_DLL
#include "dnslib.h"


//
//  If you like having a local variable in functions to hold the function 
//  name so that you can include it in debug logs without worrying about 
//  changing all the occurences when the function is renamed, use this 
//  at the top of the function:
//      DBG_FN( "MyFunction" )      <--- NOTE: no semi-colon!!
//

#if DBG
#define DBG_FN( funcName ) static const char * fn = (funcName);
#else
#define DBG_FN( funcName )
#endif


#endif //   _DNSADDDP_PRECOMP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\dnsperf\perfutil.c ===
/*++ BUILD Version: 0001    // Increment this if a change has global effects

Copyright (c) 1992  Microsoft Corporation

Module Name:

    perfutil.c

Abstract:

    This file implements the utility routines used to construct the
	common parts of a PERF_INSTANCE_DEFINITION (see winperf.h) and
    perform event logging functions.
                 
Created:    

    Russ Blake  07/30/92

Revision History:
    Jing Chen   07/98

--*/
//
//  include files
//
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>

#include <winperf.h>
#include "perfconfig.h"
#include "perfutil.h"

#define INITIAL_SIZE     1024L
#define EXTEND_SIZE      1024L

//
// Global data definitions.
//


WCHAR GLOBAL_STRING[] = L"Global";
WCHAR FOREIGN_STRING[] = L"Foreign";
WCHAR COSTLY_STRING[] = L"Costly";

WCHAR NULL_STRING[] = L"\0";    // pointer to null string 

// test for delimiter, end of line and non-digit characters
// used by IsNumberInUnicodeList routine
//
#define DIGIT       1
#define DELIMITER   2
#define INVALID     3

#define EvalThisChar(c,d) ( \
     (c == d) ? DELIMITER : \
     (c == 0) ? DELIMITER : \
     (c < (WCHAR)'0') ? INVALID : \
     (c > (WCHAR)'9') ? INVALID : \
     DIGIT)


DWORD
GetQueryType (
    IN LPWSTR lpValue
)
/*++

GetQueryType

    returns the type of query described in the lpValue string so that
    the appropriate processing method may be used

Arguments

    IN lpValue
        string passed to PerfRegQuery Value for processing

Return Value

    QUERY_GLOBAL
        if lpValue == 0 (null pointer)
           lpValue == pointer to Null string
           lpValue == pointer to "Global" string

    QUERY_FOREIGN
        if lpValue == pointer to "Foriegn" string

    QUERY_COSTLY
        if lpValue == pointer to "Costly" string

    otherwise:

    QUERY_ITEMS

--*/
{
    WCHAR   *pwcArgChar, *pwcTypeChar;
    BOOL    bFound;


    if (lpValue == 0) {
        return QUERY_GLOBAL;
    } else if (*lpValue == 0) {
        return QUERY_GLOBAL;
    }

    // check for "Global" request

    pwcArgChar = lpValue;
    pwcTypeChar = GLOBAL_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_GLOBAL;

    // check for "Foreign" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = FOREIGN_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_FOREIGN;

    // check for "Costly" request
    
    pwcArgChar = lpValue;
    pwcTypeChar = COSTLY_STRING;
    bFound = TRUE;  // assume found until contradicted

    // check to the length of the shortest string
    
    while ((*pwcArgChar != 0) && (*pwcTypeChar != 0)) {
        if (*pwcArgChar++ != *pwcTypeChar++) {
            bFound = FALSE; // no match
            break;          // bail out now
        }
    }

    if (bFound) return QUERY_COSTLY;

    // if not Global and not Foreign and not Costly, 
    // then it must be an item list
    
    return QUERY_ITEMS;

}


BOOL
IsNumberInUnicodeList (
    IN DWORD   dwNumber,
    IN LPWSTR  lpwszUnicodeList
)
/*++

IsNumberInUnicodeList

Arguments:
        
    IN dwNumber
        DWORD number to find in list

    IN lpwszUnicodeList
        Null terminated, Space delimited list of decimal numbers

Return Value:

    TRUE:
            dwNumber was found in the list of unicode number strings

    FALSE:
            dwNumber was not found in the list.

--*/
{
    DWORD   dwThisNumber;
    WCHAR   *pwcThisChar;
    BOOL    bValidNumber;
    BOOL    bNewItem;
    WCHAR   wcDelimiter;    // could be an argument to be more flexible

    if (lpwszUnicodeList == 0) return FALSE;    // null pointer, # not founde

    pwcThisChar = lpwszUnicodeList;
    dwThisNumber = 0;
    wcDelimiter = (WCHAR)' ';
    bValidNumber = FALSE;
    bNewItem = TRUE;
    
    while (TRUE) {
        switch (EvalThisChar (*pwcThisChar, wcDelimiter)) {
            case DIGIT:
                // if this is the first digit after a delimiter, then 
                // set flags to start computing the new number
                if (bNewItem) {
                    bNewItem = FALSE;
                    bValidNumber = TRUE;
                }
                if (bValidNumber) {
                    dwThisNumber *= 10;
                    dwThisNumber += (*pwcThisChar - (WCHAR)'0');
                }
                break;
            
            case DELIMITER:
                // a delimter is either the delimiter character or the 
                // end of the string ('\0') if when the delimiter has been
                // reached a valid number was found, then compare it to the
                // number from the argument list. if this is the end of the
                // string and no match was found, then return.
                //
                if (bValidNumber) {
                    if (dwThisNumber == dwNumber) return TRUE;
                    bValidNumber = FALSE;
                }
                if (*pwcThisChar == 0) {
                    return FALSE;
                } else {
                    bNewItem = TRUE;
                    dwThisNumber = 0;
                }
                break;

            case INVALID:
                // if an invalid character was encountered, ignore all
                // characters up to the next delimiter and then start fresh.
                // the invalid number is not compared.
                bValidNumber = FALSE;
                break;

            default:
                break;

        }
        pwcThisChar++;
    }

}   // IsNumberInUnicodeList
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\dnsperf\dnsperf.c ===
/*++

Copyright (c) 1998  Microsoft Corporation

Module Name:

    dnsperf.c

Abstract:

    This file implements the Extensible Objects for the DNS object type

Created:

    Jing Chen 1998

Revision History

--*/


//
//  Include Files
//

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <rpc.h>

#include <wchar.h>
#include <winperf.h>


#include "perfutil.h"
#include "datadns.h"
#include "dnsperf.h"
#include "perfconfig.h"
#include "dnslibp.h"        // security routine

#define SERVICE_NAME    "DNS"


//
//  DNS counter data structures
//

DWORD   dwOpenCount = 0;                    // count of "Open" threads
BOOL    bInitOK = FALSE;                    // true = DLL initialized OK

HANDLE  hDnsSharedMemory = NULL;            // Handle of Dns Shared Memory
PDWORD  pCounterBlock = NULL;

extern DNS_DATA_DEFINITION DnsDataDefinition;

//
//  Function Prototypes
//
//      these are used to insure that the data collection functions
//      accessed by Perflib will have the correct calling format.
//

PM_OPEN_PROC            OpenDnsPerformanceData;
PM_COLLECT_PROC         CollectDnsPerformanceData;
PM_CLOSE_PROC           CloseDnsPerformanceData;




DWORD
OpenDnsPerformanceData(
    IN      LPWSTR          lpDeviceNames
    )
/*++

Routine Description:

    This routine will open and map the memory used by the DNS to
    pass performance data in. This routine also initializes the data
    structures used to pass data back to the registry

Arguments:

    Pointer to object ID of each device to be opened (DNS), which
    seems to be totally unused, just as it was in the sample code
    from which this is stolen.

Return Value:

    None.

--*/
{
    LONG    status;
    HKEY    hKeyDriverPerf = NULL;
    DWORD   size;
    DWORD   type;
    DWORD   dwFirstCounter;
    DWORD   dwFirstHelp;

    //
    //  Since SCREG is multi-threaded and will call this routine in
    //  order to service remote performance queries, this library
    //  must keep track of how many times it has been opened (i.e.
    //  how many threads have accessed it). the registry routines will
    //  limit access to the initialization routine to only one thread
    //  at a time so synchronization (i.e. reentrancy) should not be
    //  a problem
    //
    //  DNS_FIX0:  possible MT issues in dnsperf
    //      - thread counter is not protected, needs Interlocked instruction
    //      - contrary to above, reentrancy is not protected as we do
    //      file mapping first
    //      - file mapping not cleaned up on failure
    //      - registry handle not cleaned up on failure
    //

    if ( !dwOpenCount )
    {
        // open shared memory used by device driver to pass performance values

        hDnsSharedMemory = OpenFileMapping(
                                FILE_MAP_READ,
                                FALSE,
                                DNS_PERF_COUNTER_BLOCK );

        pCounterBlock = NULL;   // initialize pointer to memory

        if ( hDnsSharedMemory == NULL )
        {
            //
            //  create security on perfmon mapped file
            //
            //  security will be AuthenticatedUsers get to read
            //  note, using array syntax, to make it easier to tweak
            //  if want other ACLs later
            //

            SID_IDENTIFIER_AUTHORITY    ntAuthority = SECURITY_NT_AUTHORITY;
            SECURITY_ATTRIBUTES         secAttr;
            PSECURITY_ATTRIBUTES        psecAttr = NULL;
            PSECURITY_DESCRIPTOR        psd = NULL;
            DWORD                       maskArray[ 3 ] = { 0 };
            PSID                        sidArray[ 3 ] = { 0 };    //    NULL terminated!
            INT                         i;

            maskArray[ 0 ] = GENERIC_READ;
            status = RtlAllocateAndInitializeSid(
                            &ntAuthority,
                            1,
                            SECURITY_AUTHENTICATED_USER_RID,
                            0, 0, 0, 0, 0, 0, 0,
                            &sidArray[ 0 ] );
            if ( status != ERROR_SUCCESS )
            {
                maskArray[ 1 ] = GENERIC_ALL;
                status = RtlAllocateAndInitializeSid(
                                &ntAuthority,
                                1,
                                SECURITY_LOCAL_SYSTEM_RID,
                                0, 0, 0, 0, 0, 0, 0,
                                &sidArray[ 1 ] );
            }
            if ( status != ERROR_SUCCESS )
            {
                DNS_PRINT((
                    "ERROR <%lu>: Cannot create Authenticated Users SID\n",
                    status ));
            }
            else
            {
                status = Dns_CreateSecurityDescriptor(
                            &psd,
                            2,              //  number of ACEs
                            sidArray,
                            maskArray );

                if ( status == ERROR_SUCCESS )
                {
                    secAttr.lpSecurityDescriptor = psd;
                    secAttr.bInheritHandle = FALSE;
                    secAttr.nLength = sizeof( SECURITY_ATTRIBUTES );
                    psecAttr = &secAttr;
                }
                ELSE
                {
                    DNSDBG( ANY, (
                        "ERROR:  <%d> failed SD create for perfmon memory!\n",
                        status ));
                }
            }

            hDnsSharedMemory = CreateFileMapping(
                                    (HANDLE) (-1),
                                    psecAttr,
                                    PAGE_READWRITE,
                                    0,
                                    4096,
                                    DNS_PERF_COUNTER_BLOCK );

            for ( i = 0; sidArray[ i ]; ++i )
            {
                RtlFreeSid( sidArray[ i ] );
            }
            if ( psd )
            {
                Dns_Free( psd );
            }
        }

        // log error if unsuccessful

        if ( hDnsSharedMemory == NULL )
        {
            // this is fatal, if we can't get data then there's no
            // point in continuing.
            status = GetLastError(); // return error
            goto OpenFailed;
        }
        else
        {
            // if opened ok, then map pointer to memory
            pCounterBlock = (PDWORD) MapViewOfFile(
                                            hDnsSharedMemory,
                                            FILE_MAP_READ,
                                            0,
                                            0,
                                            0);

            if (pCounterBlock == NULL)
            {
                // this is fatal, if we can't get data then there's no
                // point in continuing.
                status = GetLastError(); // return error
                goto OpenFailed;
            }
        }

        // get counter and help index base values from registry
        //      Open key to registry entry
        //      read First Counter and First Help values
        //      update static data strucutures by adding base to
        //          offset value in structure.

        status = RegOpenKeyEx(
                    HKEY_LOCAL_MACHINE,
                    "SYSTEM\\CurrentControlSet\\Services\\" SERVICE_NAME "\\Performance",
                    0L,
                    KEY_READ,
                    &hKeyDriverPerf);

        if (status != ERROR_SUCCESS)
        {
            LPTSTR apsz[2];

            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            apsz[0] = (LPTSTR) (LONG_PTR) status;
            apsz[1] = "SYSTEM\\CurrentControlSet\\Services\\" SERVICE_NAME "\\Performance";
            goto OpenFailed;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(
                    hKeyDriverPerf,
                    "First Counter",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstCounter,
                    &size);

        if (status != ERROR_SUCCESS) {
            LPTSTR apsz[2];

            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            apsz[0] = (LPTSTR) (LONG_PTR) status;
            apsz[1] = "First Counter";
            goto OpenFailed;
        }

        size = sizeof (DWORD);
        status = RegQueryValueEx(
                    hKeyDriverPerf,
                    "First Help",
                    0L,
                    &type,
                    (LPBYTE)&dwFirstHelp,
                    &size);

        if (status != ERROR_SUCCESS)
        {
            LPTSTR apsz[2];

            // this is fatal, if we can't get the base values of the
            // counter or help names, then the names won't be available
            // to the requesting application  so there's not much
            // point in continuing.
            apsz[0] = (LPTSTR) (LONG_PTR) status;
            apsz[1] = "First Help";
            goto OpenFailed;
        }

        //
        //  NOTE: the initialization program could also retrieve
        //      LastCounter and LastHelp if they wanted to do
        //      bounds checking on the new number. e.g.
        //
        //      counter->CounterNameTitleIndex += dwFirstCounter;
        //      if (counter->CounterNameTitleIndex > dwLastCounter) {
        //          LogErrorToEventLog (INDEX_OUT_OF_BOUNDS);
        //      }

        DnsDataDefinition.DnsObjectType.ObjectNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DnsObjectType.ObjectHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.TotalQueryReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.TotalQueryReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.TotalQueryReceived_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.TotalQueryReceived_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.UdpQueryReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.UdpQueryReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.UdpQueryReceived_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.UdpQueryReceived_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.TcpQueryReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.TcpQueryReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.TcpQueryReceived_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.TcpQueryReceived_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.TotalResponseSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.TotalResponseSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.TotalResponseSent_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.TotalResponseSent_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.UdpResponseSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.UdpResponseSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.UdpResponseSent_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.UdpResponseSent_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.TcpResponseSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.TcpResponseSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.TcpResponseSent_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.TcpResponseSent_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.RecursiveQueries.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.RecursiveQueries.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.RecursiveQueries_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.RecursiveQueries_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.RecursiveTimeOut.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.RecursiveTimeOut.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.RecursiveTimeOut_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.RecursiveTimeOut_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.RecursiveQueryFailure.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.RecursiveQueryFailure.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.RecursiveQueryFailure_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.RecursiveQueryFailure_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.NotifySent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.NotifySent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.ZoneTransferRequestReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.ZoneTransferRequestReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.ZoneTransferSuccess.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.ZoneTransferSuccess.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.ZoneTransferFailure.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.ZoneTransferFailure.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.AxfrRequestReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.AxfrRequestReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.AxfrSuccessSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.AxfrSuccessSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.IxfrRequestReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.IxfrRequestReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.IxfrSuccessSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.IxfrSuccessSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.NotifyReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.NotifyReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.ZoneTransferSoaRequestSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.ZoneTransferSoaRequestSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.AxfrRequestSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.AxfrRequestSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.AxfrResponseReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.AxfrResponseReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.AxfrSuccessReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.AxfrSuccessReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.IxfrRequestSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.IxfrRequestSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.IxfrResponseReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.IxfrResponseReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.IxfrSuccessReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.IxfrSuccessReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.IxfrUdpSuccessReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.IxfrUdpSuccessReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.IxfrTcpSuccessReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.IxfrTcpSuccessReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.WinsLookupReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.WinsLookupReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.WinsLookupReceived_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.WinsLookupReceived_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.WinsResponseSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.WinsResponseSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.WinsResponseSent_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.WinsResponseSent_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.WinsReverseLookupReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.WinsReverseLookupReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.WinsReverseLookupReceived_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.WinsReverseLookupReceived_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.WinsReverseResponseSent.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.WinsReverseResponseSent.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.WinsReverseResponseSent_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.WinsReverseResponseSent_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DynamicUpdateReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DynamicUpdateReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DynamicUpdateReceived_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DynamicUpdateReceived_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DynamicUpdateNoOp.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DynamicUpdateNoOp.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DynamicUpdateNoOp_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DynamicUpdateNoOp_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DynamicUpdateWriteToDB.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DynamicUpdateWriteToDB.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DynamicUpdateWriteToDB_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DynamicUpdateWriteToDB_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DynamicUpdateRejected.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DynamicUpdateRejected.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DynamicUpdateTimeOut.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DynamicUpdateTimeOut.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DynamicUpdateQueued.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DynamicUpdateQueued.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.SecureUpdateReceived.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.SecureUpdateReceived.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.SecureUpdateReceived_s.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.SecureUpdateReceived_s.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.SecureUpdateFailure.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.SecureUpdateFailure.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.DatabaseNodeMemory.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.DatabaseNodeMemory.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.RecordFlowMemory.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.RecordFlowMemory.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.CachingMemory.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.CachingMemory.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.UdpMessageMemory.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.UdpMessageMemory.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.TcpMessageMemory.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.TcpMessageMemory.CounterHelpTitleIndex += dwFirstHelp;

        DnsDataDefinition.NbstatMemory.CounterNameTitleIndex += dwFirstCounter;
        DnsDataDefinition.NbstatMemory.CounterHelpTitleIndex += dwFirstHelp;

        RegCloseKey( hKeyDriverPerf ); // close key to registry

        bInitOK = TRUE; // ok to use this function
    }

    dwOpenCount++;  // increment OPEN counter

    return( ERROR_SUCCESS ); // for successful exit


OpenFailed:

    //
    //  close handles if open fails
    //

    if ( hKeyDriverPerf )
    {
        RegCloseKey( hKeyDriverPerf );
    }
    if ( pCounterBlock )
    {
        UnmapViewOfFile( pCounterBlock );
        pCounterBlock = NULL;
    }
    if ( hDnsSharedMemory )
    {
        CloseHandle( hDnsSharedMemory );
        hDnsSharedMemory = NULL;
    }

    return status;
}



DWORD
CollectDnsPerformanceData(
    IN      LPWSTR          lpValueName,
    IN OUT  LPVOID *        lppData,
    IN OUT  LPDWORD         lpcbTotalBytes,
    IN OUT  LPDWORD         lpNumObjectTypes
    )
/*++

Routine Description:

    This routine will return the data for the DNS counters.

Arguments:

   IN       LPWSTR   lpValueName
         pointer to a wide character string passed by registry.

   IN OUT   LPVOID   *lppData
         IN: pointer to the address of the buffer to receive the completed
            PerfDataBlock and subordinate structures. This routine will
            append its data to the buffer starting at the point referenced
            by *lppData.
         OUT: points to the first byte after the data structure added by this
            routine. This routine updated the value at lppdata after appending
            its data.

   IN OUT   LPDWORD  lpcbTotalBytes
         IN: the address of the DWORD that tells the size in bytes of the
            buffer referenced by the lppData argument
         OUT: the number of bytes added by this routine is writted to the
            DWORD pointed to by this argument

   IN OUT   LPDWORD  NumObjectTypes
         IN: the address of the DWORD to receive the number of objects added
            by this routine
         OUT: the number of objects added by this routine is writted to the
            DWORD pointed to by this argument

Return Value:

      ERROR_MORE_DATA if buffer passed is too small to hold data
         any error conditions encountered are reported to the event log if
         event logging is enabled.

      ERROR_SUCCESS  if success or any other error. Errors, however are
         also reported to the event log.

--*/
{
    //  Variables for reformating the data

    ULONG   SpaceNeeded;
    PDWORD  pdwCounter;
    PERF_COUNTER_BLOCK *pPerfCounterBlock;
    DNS_DATA_DEFINITION *pDnsDataDefinition;

    DWORD   dwQueryType;        // for error logging

    //
    // before doing anything else, see if Open went OK
    //
    if (!bInitOK)
    {
        // unable to continue because open failed.
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS; // yes, this is a successful exit
    }

    // see if this is a foreign (i.e. non-NT) computer data request
    //
    dwQueryType = GetQueryType (lpValueName);

    if ( dwQueryType == QUERY_FOREIGN )
    {
        // this routine does not service requests for data from
        // Non-NT computers
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_SUCCESS;
    }

    if (dwQueryType == QUERY_ITEMS)
    {
        if ( ! IsNumberInUnicodeList(
                    DnsDataDefinition.DnsObjectType.ObjectNameTitleIndex,
                    lpValueName ) )
        {
            // request received for data object not provided by this routine
            *lpcbTotalBytes = (DWORD) 0;
            *lpNumObjectTypes = (DWORD) 0;
            return ERROR_SUCCESS;
        }
    }

    //
    //  Get the data.
    //

    pDnsDataDefinition = (DNS_DATA_DEFINITION *) *lppData;

    SpaceNeeded = sizeof(DNS_DATA_DEFINITION) + SIZE_OF_DNS_PERFORMANCE_DATA;

    if ( *lpcbTotalBytes < SpaceNeeded )
    {
        *lpcbTotalBytes = (DWORD) 0;
        *lpNumObjectTypes = (DWORD) 0;
        return ERROR_MORE_DATA;
    }

    //
    // Copy the (constant, initialized) Object Type and counter definitions
    //  to the caller's data buffer
    //

    memmove(pDnsDataDefinition,
           &DnsDataDefinition,
           sizeof(DNS_DATA_DEFINITION));

    //  Format and collect DNS data from shared memory

    // The counter block is to immediately follow the data definition,
    // so obtain a pointer to that space
    pPerfCounterBlock = (PERF_COUNTER_BLOCK *) &pDnsDataDefinition[1];

    // The byte length is of the counter block header and all following data
    pPerfCounterBlock->ByteLength = SIZE_OF_DNS_PERFORMANCE_DATA;

    // Compute a pointer to the buffer immediately following the counter
    // block header
    pdwCounter = (PDWORD) (&pPerfCounterBlock[1]);

    // copy the counter data from shared memory block into the counter block
    memcpy(pdwCounter,
           &pCounterBlock[1],
           SIZE_OF_DNS_PERFORMANCE_DATA - sizeof(PERF_COUNTER_BLOCK));

    // Tell caller where the next available byte is
    *lppData = (PVOID) ((PBYTE)pdwCounter + SIZE_OF_DNS_PERFORMANCE_DATA - sizeof(PERF_COUNTER_BLOCK));

    // update arguments before return

    *lpNumObjectTypes = 1;

    *lpcbTotalBytes = (DWORD) ((PBYTE)*lppData - (PBYTE)pDnsDataDefinition);

    return ERROR_SUCCESS;
}



DWORD
CloseDnsPerformanceData(
    VOID
    )
/*++

Routine Description:

    This routine closes the open handles to DNS device performance counters

Arguments:

    None.

Return Value:

    ERROR_SUCCESS

--*/
{
    //
    //  cleanup when close last thread
    //
    //  DNS_FIX0:  MT issues in dnsperf cleanup
    //      no real protection on thread count (need interlock)
    //      but also close can be going on concurrently with another
    //      thread attempting to reopen (unlikely but possible)
    //
    //      perhaps two flag approach would work, with all new threads
    //      failing (not passing through but skipping open altogether)
    //      until pCounterBlock was NULL again
    //

    if ( !(--dwOpenCount) )
    {
        //  clear bInitOk, as otherwise collect function
        //  will attempt to reference into pCounterBlock

        bInitOK = FALSE;

        if ( pCounterBlock )
        {
            UnmapViewOfFile( pCounterBlock );
            pCounterBlock = NULL;
        }
        if ( hDnsSharedMemory )
        {
            CloseHandle( hDnsSharedMemory );
            hDnsSharedMemory = NULL;
        }
    }
    return ERROR_SUCCESS;
}


//
//  Data for this whole thing to work on
//

DNS_DATA_DEFINITION DnsDataDefinition =
{
    // DNS obj for PerfMon:
    {   sizeof(DNS_DATA_DEFINITION) + SIZE_OF_DNS_PERFORMANCE_DATA, // TotLen
        sizeof(DNS_DATA_DEFINITION),            // DefinitionLength
        sizeof(PERF_OBJECT_TYPE),               // HeaderLength
        DNSOBJ,                                 // ObjectNameTitleIndex
        0,                                      // ObjectNameTitle
        DNSOBJ,                                 // ObjectHelpTitleIndex
        0,                                      // ObjectHelpTitle
        PERF_DETAIL_NOVICE,                     // DetailLevel
        (sizeof(DNS_DATA_DEFINITION)-sizeof(PERF_OBJECT_TYPE))/
          sizeof(PERF_COUNTER_DEFINITION),      // NumCounters
        0,                                      // DefaultCounter
        -1,                                     // NumInstances
        0                                       // CodePage (0=Unicode)
    },

    // total query received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        TOTALQUERYRECEIVED,                     // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        TOTALQUERYRECEIVED,                     // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        TOTALQUERYRECEIVED_OFFSET               // CounterOffset
    },

    // total qurey received/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        TOTALQUERYRECEIVED_S,                   // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        TOTALQUERYRECEIVED_S,                   // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        TOTALQUERYRECEIVED_OFFSET               // CounterOffset
    },

    // UDP query received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        UDPQUERYRECEIVED,                       // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        UDPQUERYRECEIVED,                       // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        UDPQUERYRECEIVED_OFFSET                 // CounterOffset
    },

    // UDP query received/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        UDPQUERYRECEIVED_S,                     // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        UDPQUERYRECEIVED_S,                     // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        UDPQUERYRECEIVED_OFFSET                 // CounterOffset
    },

    // TCP query received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        TCPQUERYRECEIVED,                       // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        TCPQUERYRECEIVED,                       // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        TCPQUERYRECEIVED_OFFSET                 // CounterOffset
    },

    // TCP query received/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        TCPQUERYRECEIVED_S,                     // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        TCPQUERYRECEIVED_S,                     // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        TCPQUERYRECEIVED_OFFSET                 // CounterOffset
    },

    // total response sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        TOTALRESPONSESENT,                      // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        TOTALRESPONSESENT,                      // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        TOTALRESPONSESENT_OFFSET                // CounterOffset
    },

    // total response sent/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        TOTALRESPONSESENT_S,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        TOTALRESPONSESENT_S,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        TOTALRESPONSESENT_OFFSET                // CounterOffset
    },

    // UDP response sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        UDPRESPONSESENT,                        // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        UDPRESPONSESENT,                        // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        UDPRESPONSESENT_OFFSET                  // CounterOffset
    },

    // UDP response sent/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        UDPRESPONSESENT_S,                      // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        UDPRESPONSESENT_S,                      // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        UDPRESPONSESENT_OFFSET                  // CounterOffset
    },

    // TCP response sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        TCPRESPONSESENT,                        // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        TCPRESPONSESENT,                        // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        TCPRESPONSESENT_OFFSET                  // CounterOffset
    },

    // TCP response sent/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        TCPRESPONSESENT_S,                      // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        TCPRESPONSESENT_S,                      // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        TCPRESPONSESENT_OFFSET                  // CounterOffset
    },

    // recursive query received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        RECURSIVEQUERIES,                       // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        RECURSIVEQUERIES,                       // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        RECURSIVEQUERIES_OFFSET                 // CounterOffset
    },

    // recursive query received/s
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        RECURSIVEQUERIES_S,                     // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        RECURSIVEQUERIES_S,                     // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        RECURSIVEQUERIES_OFFSET                 // CounterOffset
    },

    // recursive query timeout
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        RECURSIVETIMEOUT,                       // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        RECURSIVETIMEOUT,                       // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        RECURSIVETIMEOUT_OFFSET                 // CounterOffset
    },

    // recursive query timeout/s
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        RECURSIVETIMEOUT_S,                     // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        RECURSIVETIMEOUT_S,                     // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        RECURSIVETIMEOUT_OFFSET                 // CounterOffset
    },

    // recursive query failure
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        RECURSIVEQUERYFAILURE,                  // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        RECURSIVEQUERYFAILURE,                  // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        RECURSIVEQUERYFAILURE_OFFSET            // CounterOffset
    },

    // recursive query failure/s
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        RECURSIVEQUERYFAILURE_S,                // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        RECURSIVEQUERYFAILURE_S,                // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        RECURSIVEQUERYFAILURE_OFFSET            // CounterOffset
    },

    // notify sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        NOTIFYSENT,                             // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        NOTIFYSENT,                             // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        NOTIFYSENT_OFFSET                       // CounterOffset
    },

    // zone transfer request received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        ZONETRANSFERREQUESTRECEIVED,            // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        ZONETRANSFERREQUESTRECEIVED,            // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        ZONETRANSFERREQUESTRECEIVED_OFFSET      // CounterOffset
    },

    // zone transfer success
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        ZONETRANSFERSUCCESS,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        ZONETRANSFERSUCCESS,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        ZONETRANSFERSUCCESS_OFFSET              // CounterOffset
    },

    // zone transfer failure
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        ZONETRANSFERFAILURE,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        ZONETRANSFERFAILURE,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        ZONETRANSFERFAILURE_OFFSET              // CounterOffset
    },

    // AXFR request received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        AXFRREQUESTRECEIVED,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        AXFRREQUESTRECEIVED,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        AXFRREQUESTRECEIVED_OFFSET              // CounterOffset
    },

    // AXFR success sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        AXFRSUCCESSSENT,                        // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        AXFRSUCCESSSENT,                        // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        AXFRSUCCESSSENT_OFFSET                  // CounterOffset
    },

    // IXFR request received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        IXFRREQUESTRECEIVED,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        IXFRREQUESTRECEIVED,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        IXFRREQUESTRECEIVED_OFFSET              // CounterOffset
    },

    // IXFR success sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        IXFRSUCCESSSENT,                        // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        IXFRSUCCESSSENT,                        // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        IXFRSUCCESSSENT_OFFSET                  // CounterOffset
    },

    // notify received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        NOTIFYRECEIVED,                         // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        NOTIFYRECEIVED,                         // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        NOTIFYRECEIVED_OFFSET                   // CounterOffset
    },

    // zone transfer SOA request sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        ZONETRANSFERSOAREQUESTSENT,             // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        ZONETRANSFERSOAREQUESTSENT,             // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        ZONETRANSFERSOAREQUESTSENT_OFFSET       // CounterOffset
    },

    // AXFR request sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        AXFRREQUESTSENT,                        // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        AXFRREQUESTSENT,                        // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        AXFRREQUESTSENT_OFFSET                  // CounterOffset
    },

    // AXFR response received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        AXFRRESPONSERECEIVED,                   // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        AXFRRESPONSERECEIVED,                   // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        AXFRRESPONSERECEIVED_OFFSET             // CounterOffset
    },

    // AXFR success received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        AXFRSUCCESSRECEIVED,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        AXFRSUCCESSRECEIVED,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        AXFRSUCCESSRECEIVED_OFFSET              // CounterOffset
    },

    // IXFR request sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        IXFRREQUESTSENT,                        // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        IXFRREQUESTSENT,                        // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        IXFRREQUESTSENT_OFFSET                  // CounterOffset
    },

    // IXFR response received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        IXFRRESPONSERECEIVED,                   // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        IXFRRESPONSERECEIVED,                   // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        IXFRRESPONSERECEIVED_OFFSET             // CounterOffset
    },

    // IXFR succes received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        IXFRSUCCESSRECEIVED,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        IXFRSUCCESSRECEIVED,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        IXFRSUCCESSRECEIVED_OFFSET              // CounterOffset
    },

    // IXFR UDP success received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        IXFRUDPSUCCESSRECEIVED,                 // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        IXFRUDPSUCCESSRECEIVED,                 // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        IXFRUDPSUCCESSRECEIVED_OFFSET           // CounterOffset
    },

    // IXFR TCP success received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        IXFRTCPSUCCESSRECEIVED,                 // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        IXFRTCPSUCCESSRECEIVED,                 // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        IXFRTCPSUCCESSRECEIVED_OFFSET           // CounterOffset
    },

    // WINS lookup request received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        WINSLOOKUPRECEIVED,                     // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        WINSLOOKUPRECEIVED,                     // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        WINSLOOKUPRECEIVED_OFFSET               // CounterOffset
    },

    // WINS lookup request received/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        WINSLOOKUPRECEIVED_S,                   // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        WINSLOOKUPRECEIVED_S,                   // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        WINSLOOKUPRECEIVED_OFFSET               // CounterOffset
    },

    // WINS response sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        WINSRESPONSESENT,                       // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        WINSRESPONSESENT,                       // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        WINSRESPONSESENT_OFFSET                 // CounterOffset
    },

    // WINS response sent/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        WINSRESPONSESENT_S,                     // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        WINSRESPONSESENT_S,                     // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        WINSRESPONSESENT_OFFSET                 // CounterOffset
    },

    // WINS reverse lookup received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        WINSREVERSELOOKUPRECEIVED,              // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        WINSREVERSELOOKUPRECEIVED,              // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        WINSREVERSELOOKUPRECEIVED_OFFSET        // CounterOffset
    },

    // WINS reverse lookup received/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        WINSREVERSELOOKUPRECEIVED_S,            // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        WINSREVERSELOOKUPRECEIVED_S,            // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        WINSREVERSELOOKUPRECEIVED_OFFSET        // CounterOffset
    },

    // WINS reverse response sent
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        WINSREVERSERESPONSESENT,                // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        WINSREVERSERESPONSESENT,                // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        WINSREVERSERESPONSESENT_OFFSET          // CounterOffset
    },

    // WINS reverse response sent/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        WINSREVERSERESPONSESENT_S,              // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        WINSREVERSERESPONSESENT_S,              // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        WINSREVERSERESPONSESENT_OFFSET          // CounterOffset
    },

    // dynamic update received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DYNAMICUPDATERECEIVED,                  // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DYNAMICUPDATERECEIVED,                  // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        DYNAMICUPDATERECEIVED_OFFSET            // CounterOffset
    },

    // dynamic update received/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DYNAMICUPDATERECEIVED_S,                // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DYNAMICUPDATERECEIVED_S,                // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        DYNAMICUPDATERECEIVED_OFFSET            // CounterOffset
    },

    // dynamic update NoOperation & Empty
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DYNAMICUPDATENOOP,                      // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DYNAMICUPDATENOOP,                      // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        DYNAMICUPDATENOOP_OFFSET                // CounterOffset
    },

    // dynamic update NoOperation & Empty/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DYNAMICUPDATENOOP_S,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DYNAMICUPDATENOOP_S,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        DYNAMICUPDATENOOP_OFFSET                // CounterOffset
    },

    // dynamic update write to database (completed)
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DYNAMICUPDATEWRITETODB,                 // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DYNAMICUPDATEWRITETODB,                 // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        DYNAMICUPDATEWRITETODB_OFFSET           // CounterOffset
    },

    // dynamic update write to database (completed)/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DYNAMICUPDATEWRITETODB_S,               // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DYNAMICUPDATEWRITETODB_S,               // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        DYNAMICUPDATEWRITETODB_OFFSET           // CounterOffset
    },

    // dynamic update rejected
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DYNAMICUPDATEREJECTED,                  // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DYNAMICUPDATEREJECTED,                  // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        DYNAMICUPDATEREJECTED_OFFSET            // CounterOffset
    },

    // dynamic update timeout
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DYNAMICUPDATETIMEOUT,                   // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DYNAMICUPDATETIMEOUT,                   // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        DYNAMICUPDATETIMEOUT_OFFSET             // CounterOffset
    },

    // dynamic update queued
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DYNAMICUPDATEQUEUED,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DYNAMICUPDATEQUEUED,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        DYNAMICUPDATEQUEUED_OFFSET              // CounterOffset
    },

    // secure update received
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        SECUREUPDATERECEIVED,                   // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        SECUREUPDATERECEIVED,                   // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        SECUREUPDATERECEIVED_OFFSET             // CounterOffset
    },

    // secure update received/sec
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        SECUREUPDATERECEIVED_S,                 // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        SECUREUPDATERECEIVED_S,                 // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_COUNTER,                   // CounterType
        sizeof(DWORD),                          // CounterSize
        SECUREUPDATERECEIVED_OFFSET             // CounterOffset
    },

    // secure update failure
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        SECUREUPDATEFAILURE,                    // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        SECUREUPDATEFAILURE,                    // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        SECUREUPDATEFAILURE_OFFSET              // CounterOffset
    },

    // database node memory
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        DATABASENODEMEMORY,                     // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        DATABASENODEMEMORY,                     // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        DATABASENODEMEMORY_OFFSET               // CounterOffset
    },

    // record flow memory
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        RECORDFLOWMEMORY,                       // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        RECORDFLOWMEMORY,                       // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        RECORDFLOWMEMORY_OFFSET                 // CounterOffset
    },

    // caching memory
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        CACHINGMEMORY,                          // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        CACHINGMEMORY,                          // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        CACHINGMEMORY_OFFSET                    // CounterOffset
    },

    // UDP message memory
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        UDPMESSAGEMEMORY,                       // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        UDPMESSAGEMEMORY,                       // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        UDPMESSAGEMEMORY_OFFSET                 // CounterOffset
    },

    // TCP message memory
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        TCPMESSAGEMEMORY,                       // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        TCPMESSAGEMEMORY,                       // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        TCPMESSAGEMEMORY_OFFSET                 // CounterOffset
    },

    // Nbstat memory
    {   sizeof(PERF_COUNTER_DEFINITION),        // ByteLength
        NBSTATMEMORY,                           // CounterNameTitleIndex
        0,                                      // CounterNameTitle
        NBSTATMEMORY,                           // CounterHelpTitleIndex
        0,                                      // CounterHelpTitle
        0,                                      // DefaultScale
        PERF_DETAIL_NOVICE,                     // DetailLevel
        PERF_COUNTER_RAWCOUNT,                  // CounterType
        sizeof(DWORD),                          // CounterSize
        NBSTATMEMORY_OFFSET                     // CounterOffset
    },


};

int APIENTRY _CRT_INIT(
        HANDLE hInstance,
        DWORD ulReasonBeingCalled,
        LPVOID lpReserved);


int __stdcall LibMain(
        HANDLE hInstance,
        DWORD ulReasonBeingCalled,
        LPVOID lpReserved)
{
    return (_CRT_INIT(hInstance, ulReasonBeingCalled,lpReserved));
}

//
//  End dnsperf.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\idl\imports.h ===
/*++

Copyright (c) 1995 Microsoft Corporation

Module Name:

    imports.h

Abstract:

    Domain Name System (DNS) Server

    Allows RPC API calls to use types specified in headers given
    below.  This file is included by dns.idl, through imports.idl.

Author:

    Jim Gilroy (jamesg)     September, 1995

Revision History:

--*/


#include <windef.h>

//
//  Need wtypes.h for SYSTEMTIME definition.
//
//  Define RPC_NO_WINDOWS_H to avoid expansion of windows.h from
//  rpc.h which is included in wtypes.h
//
//
// #define  RPC_NO_WINDOWS_H
// #include <wtypes.h>
//
//  Note, instead we've defined our own DNS_SYSTEMTIME structure.
//

#include <dnsrpc.h>
#include <lmcons.h>

//
//  Use DWORDs to transport BOOL values
//

#ifdef MIDL_PASS
#define BOOL DWORD
#endif

//
//  End imports.h
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\idl\dnsrpcp.h ===
/*++

Copyright (c) 1997  Microsoft Corporation

Module Name:

    dnsrpcp.h

Abstract:

    Domain Name System (DNS)

    DNS Record RPC defs

Author:

    Glenn Curtis (glennc)   January 11, 1997
    Jim Gilroy (jamesg)     April 3, 1997

Revision History:

--*/


#ifndef _DNSRPCP_INCLUDED_
#define _DNSRPCP_INCLUDED_


#include <dns.h>


#ifdef __cplusplus
extern "C"
{
#endif  // _cplusplus


#ifdef MIDL_PASS

//
//  Record data for specific types
//
//  These types don't require MIDL specific definitions and are taken
//  directly from dnsapi.h.  The copying is ugly, but trying to get a
//  MIDL safe version of dnsapi.h, leaves it much uglier.
//

typedef struct
{
    IP_ADDRESS  ipAddress;
}
DNS_A_DATA, *PDNS_A_DATA;

typedef struct
{
    DNS_NAME    nameHost;
}
DNS_PTR_DATA, *PDNS_PTR_DATA;

typedef struct
{
    DNS_NAME    namePrimaryServer;
    DNS_NAME    nameAdministrator;
    DWORD       dwSerialNo;
    DWORD       dwRefresh;
    DWORD       dwRetry;
    DWORD       dwExpire;
    DWORD       dwDefaultTtl;
}
DNS_SOA_DATA, *PDNS_SOA_DATA;

typedef struct
{
    DNS_NAME    nameMailbox;
    DNS_NAME    nameErrorsMailbox;
}
DNS_MINFO_DATA, *PDNS_MINFO_DATA;

typedef struct
{
    DNS_NAME    nameExchange;
    WORD        wPreference;
    WORD        Pad;        // keep ptrs DWORD aligned
}
DNS_MX_DATA, *PDNS_MX_DATA;

typedef struct
{
    DWORD       dwStringCount;
    DNS_TEXT    pStringArray[1];
}
DNS_TXT_DATA, *PDNS_TXT_DATA;

typedef struct
{
    DWORD       dwByteCount;
    BYTE        bData[];
}
DNS_NULL_DATA, *PDNS_NULL_DATA;

typedef struct
{
    IP_ADDRESS  ipAddress;
    UCHAR       chProtocol;
    BYTE        bBitMask[1];
}
DNS_WKS_DATA, *PDNS_WKS_DATA;

typedef struct
{
    IPV6_ADDRESS    ipv6Address;
}
DNS_AAAA_DATA, *PDNS_AAAA_DATA;

typedef struct
{
    DNS_NAME    nameTarget;
    WORD        wPriority;
    WORD        wWeight;
    WORD        wPort;
    WORD        Pad;        // keep ptrs DWORD aligned
}
DNS_SRV_DATA, *PDNS_SRV_DATA;

typedef struct
{
    DWORD       dwMappingFlag;
    DWORD       dwLookupTimeout;
    DWORD       dwCacheTimeout;
    DWORD       cWinsServerCount;
    IP_ADDRESS  aipWinsServers[];
}
DNS_WINS_DATA, *PDNS_WINS_DATA;

typedef struct
{
    DWORD       dwMappingFlag;
    DWORD       dwLookupTimeout;
    DWORD       dwCacheTimeout;
    DNS_NAME    nameResultDomain;
}
DNS_WINSR_DATA, *PDNS_WINSR_DATA;


//
//  RPC record data types that requires explicit MIDL pass definition
//  different than non-MIDL definition in dnsapi.h
//

typedef struct
{
    DWORD   dwByteCount;
    [size_is(dwByteCount)]  BYTE bData[];
}
DNS_NULL_DATA_RPC, *PDNS_NULL_DATA_RPC;

typedef struct
{
    DWORD   dwStringCount;
    [size_is(dwStringCount*sizeof(PCHAR))]  DNS_TEXT pStringArray[];
}
DNS_TXT_DATA_RPC, *PDNS_TXT_DATA_RPC;

typedef struct
{
    DWORD   dwMappingFlag;
    DWORD   dwLookupTimeout;
    DWORD   dwCacheTimeout;
    DWORD   cWinsServerCount;
    [size_is(cWinsServerCount*sizeof(IP_ADDRESS))] IP_ADDRESS aipWinsServers[];
}
DNS_WINS_DATA_RPC, *PDNS_WINS_DATA_RPC;


//
//  Union of record types using RPC types as required
//

typedef [switch_type(WORD)] union _DNS_RECORD_DATA_UNION
{
    [case(DNS_TYPE_A)]      DNS_A_DATA         A;

    [case(DNS_TYPE_SOA)]    DNS_SOA_DATA       SOA;

    [case(DNS_TYPE_PTR,
          DNS_TYPE_NS,
          DNS_TYPE_CNAME,
          DNS_TYPE_MB,
          DNS_TYPE_MD,
          DNS_TYPE_MF,
          DNS_TYPE_MG,
          DNS_TYPE_MR)]     DNS_PTR_DATA       PTR;

    [case(DNS_TYPE_MINFO,
          DNS_TYPE_RP)]     DNS_MINFO_DATA     MINFO;

    [case(DNS_TYPE_MX,
          DNS_TYPE_AFSDB,
          DNS_TYPE_RT)]     DNS_MX_DATA        MX;

    [case(DNS_TYPE_HINFO,
          DNS_TYPE_ISDN,
          DNS_TYPE_TEXT,
          DNS_TYPE_X25)]    DNS_TXT_DATA_RPC   TXT;

    [case(DNS_TYPE_NULL)]   DNS_NULL_DATA_RPC  Null;

    [case(DNS_TYPE_WKS)]    DNS_WKS_DATA       WKS;

    [case(DNS_TYPE_AAAA)]   DNS_AAAA_DATA      AAAA;

    [case(DNS_TYPE_SRV)]    DNS_SRV_DATA       SRV;

    [case(DNS_TYPE_WINS)]   DNS_WINS_DATA_RPC  WINS;
    [case(DNS_TYPE_NBSTAT)] DNS_WINSR_DATA     WINSR;
}
DNS_RECORD_DATA_UNION;


//
//  Record structure for RPC
//

typedef struct _DnsRecordRpc
{
    struct _DnsRecordRpc * pNext;
    DNS_NAME    nameOwner;
    DWORD       Flags;
    DWORD       dwTtl;
    WORD        wDataLength;
    WORD        wType;
    [switch_is(wType)]   DNS_RECORD_DATA_UNION Data;
}
DNS_RECORD_RPC, * PDNS_RECORD_RPC;

#else

//
//  not MIDL_PASS
//
//  for non-MIDL use, RPC record must identical field for field
//  with public defintion of DNS_RECORD
//

#include <dnsapi.h>

typedef DNS_RECORD  DNS_RECORD_RPC, *PDNS_RECORD_RPC;

#endif  // non-MIDL


#ifdef __cplusplus
}
#endif  // __cplusplus

#endif // _DNSRPCP_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\idl\makefile.inc ===
#
# This is the MIDL compile phase of the build process.
#
# The following is where you put the name of your .idl file without
# the .idl extension:
#

#define DISABLE_NET_UNICODE

!INCLUDE $(NTMAKEENV)\makefile.plt
!CMDSWITCHES +D

IDL_NAME    = dnssrv.idl
ACF_NAME    = dnssrv.acf
STUB_NAME   = dnsrpc
IMPORT      = imports

CLIENT_ACF = $(ACF_NAME)
SERVER_ACF = $(ACF_NAME)
CLIENT_C = $(STUB_NAME)_c.c
SERVER_C = $(STUB_NAME)_s.c
CLIENT_H = $(STUB_NAME)_c.h
SERVER_H = $(STUB_NAME)_s.h

INCS = -I. -I.\server -I$(SDK_INC_PATH) -I$(CRT_INC_PATH) -I$inc -I$(DS_INC_PATH)

CLIENT_TARGETS = \
    $(O)\$(CLIENT_C)  \
    $(O)\$(CLIENT_H)

SERVER_TARGETS = \
    $(O)\$(SERVER_C)  \
    $(O)\$(SERVER_H)

TARGETS = $(CLIENT_TARGETS) $(SERVER_TARGETS)

CLIENT_FLAGS = -acf $(CLIENT_ACF) -header $(CLIENT_H) -cstub $(CLIENT_C) -oldnames -out .\$(O)
SERVER_FLAGS = -acf $(SERVER_ACF) -header $(SERVER_H) -sstub $(SERVER_C) -oldnames -out .\$(O)

CPP = -cpp_cmd "$(MIDL_CPP)" $(MIDL_FLAGS) $(C_DEFINES) $(NET_C_DEFINES)


#
# MIDL COMPILE
#

$(CLIENT_TARGETS) : .\$(IDL_NAME) .\$(IMPORT).idl .\$(IMPORT).h .\$(CLIENT_ACF) $(EXTRN_DEPENDS)
    midl /Oicf /robust -server none -error allocation -error ref -ms_ext -c_ext $(CPP) $(CLIENT_FLAGS) .\$(IDL_NAME) $(INCS)

$(SERVER_TARGETS) : .\$(IDL_NAME) .\$(IMPORT).idl .\$(IMPORT).h .\$(SERVER_ACF) $(EXTRN_DEPENDS)
    midl  /Oicf /robust -client none -error allocation -error ref -ms_ext -c_ext $(CPP) $(SERVER_FLAGS) .\$(IDL_NAME) $(INCS)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\natlib\iprtrint.c ===
/*++


Copyright (c) 2001  Microsoft Corporation

Module Name:
    net\rras\ip\iprtrint\iprtrint.c

Abstract:
    Contains the private APIs exported by static library iprtrint.lib

Revision History:

    Anshul Dhir     Created

    For help contact routerdev

--*/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windef.h>
#include <winbase.h>
#include <mprapi.h>
#include <routprot.h>
#include <ipnathlp.h>
#include "iprtrint.h"
#pragma hdrstop


DWORD WINAPI
InternalRouterUpdateProtocolInfo(
    DWORD dwProtocolId,
    DWORD dwOperationId,
    PVOID MoreInfo1,
    PVOID MoreInfo2)

/*++
    Routine Description:

        This routine is used to update protocol information maintained by the
        router.
        e.g. it can be used to enable/disable DNS_PROXY.
        Also, can be extended to control other protocols like DHCP_ALLOCATOR.

    NOTE: Any functionality added to this routine should also be added to
          InternalConfigUpdateProtocolInfo 

    Arguments:

        dwProtocolId: 
            Protocol whose status is to be updated.
            Currently supported protocols:
                MS_IP_DNS_PROXY

        dwOperationId: 
            Possible values:
                UPI_OP_ENABLE
                    enables the specified protocol
                UPI_OP_DISABLE
                    disables the specified protocol
                UPI_OP_RESTORE_CONFIG
                    information (corresponding to the
                    specified protocol) stored in the config, is set to
                    the router

        MoreInfo1:
            Any extra information required to perform the specified operation

        MoreInfo2:
            Any extra information required to perform the specified operation


    Return Value:

        DWORD - status code
        
--*/

{
#if defined(NT4) || defined(CHICAGO)
    return ERROR_NOT_SUPPORTED;
#else
    BOOL  bModified = FALSE;
    DWORD dwErr = NO_ERROR;

    HANDLE hMprAdmin  = NULL;
    HANDLE hMprConfig = NULL;
    HANDLE hTransport = NULL;

    LPBYTE pAdminCurIPInfo = NULL;
    LPBYTE pAdminModIPInfo = NULL;
    LPBYTE pAdminProtoInfo = NULL;

    LPBYTE pConfigCurIPInfo = NULL;
    LPBYTE pConfigProtoInfo = NULL;

    LPBYTE pNewProtoInfo = NULL;

    PIP_DNS_PROXY_GLOBAL_INFO  pDnsInfo = NULL;

    DWORD  dwAdminCurIPInfoSize;
    DWORD  dwAdminProtoInfoSize, dwAdminProtoInfoCount;

    DWORD  dwConfigCurIPInfoSize;
    DWORD  dwConfigProtoInfoSize, dwConfigProtoInfoCount;

    DWORD  dwNewProtoInfoSize, dwNewProtoInfoCount;



    if ( dwProtocolId != MS_IP_DNS_PROXY ) {
        return ERROR_INVALID_PARAMETER;
    }


    do {

        dwErr = MprAdminServerConnect(
                    NULL,
                    &hMprAdmin);
                    
        if (dwErr != NO_ERROR) {
            break;
        }


        // Get the global information for IP
        dwErr = MprAdminTransportGetInfo(
                    hMprAdmin,
                    PID_IP,
                    (LPBYTE *) &pAdminCurIPInfo,
                    &dwAdminCurIPInfoSize,
                    NULL,
                    NULL);

        if (dwErr != NO_ERROR) {
            break;
        }

        // Find the Protocol specific information 
        dwErr = MprInfoBlockFind(
                    pAdminCurIPInfo,
                    dwProtocolId,
                    &dwAdminProtoInfoSize,
                    &dwAdminProtoInfoCount,
                    &pAdminProtoInfo);

        if (dwErr != NO_ERROR) {
            break;
        }

        

        // If we have to restore the config information 
        if ( dwOperationId == UPI_OP_RESTORE_CONFIG ) {

            dwErr = MprConfigServerConnect(
                        NULL,
                        &hMprConfig);
                    
            if (dwErr != NO_ERROR) {
                break;
            }


            dwErr = MprConfigTransportGetHandle(
                        hMprConfig,
                        PID_IP,
                        &hTransport);

            if (dwErr != NO_ERROR) {
                break;
            }


            dwErr = MprConfigTransportGetInfo(
                        hMprConfig,
                        hTransport,
                        (LPBYTE *) &pConfigCurIPInfo,
                        &dwConfigCurIPInfoSize,
                        NULL,
                        NULL,
                        NULL);

            if (dwErr != NO_ERROR) {
                break;
            }


            dwErr = MprInfoBlockFind(
                        pConfigCurIPInfo,
                        dwProtocolId,
                        &dwConfigProtoInfoSize,
                        &dwConfigProtoInfoCount,
                        &pConfigProtoInfo);

            if (dwErr != NO_ERROR) {
                break;
            }

            pNewProtoInfo       = pConfigProtoInfo;
            dwNewProtoInfoSize  = dwConfigProtoInfoSize;
            dwNewProtoInfoCount = dwConfigProtoInfoCount;

            // If we are restoring the router's protocol state to the 
            // state stored in the registry (config), we always set the
            // bModfied flag
            bModified = TRUE;
        }
        else {

            // Perform the desired update

            if ( dwProtocolId == MS_IP_DNS_PROXY ) {
                pDnsInfo = (PIP_DNS_PROXY_GLOBAL_INFO)pAdminProtoInfo; 

                //
                //  jwesth: added some NULL checking on pDnsInfo to pacify PREFIX.
                //
                
                if ( dwOperationId == UPI_OP_ENABLE ) {
                    if ( pDnsInfo && !(pDnsInfo->Flags & IP_DNS_PROXY_FLAG_ENABLE_DNS) ) {
                        pDnsInfo->Flags |= IP_DNS_PROXY_FLAG_ENABLE_DNS;
                        bModified = TRUE;
                    }
                }
                else if ( dwOperationId == UPI_OP_DISABLE ) {
                    if ( pDnsInfo && ( pDnsInfo->Flags & IP_DNS_PROXY_FLAG_ENABLE_DNS ) ) {
                        pDnsInfo->Flags &= ~IP_DNS_PROXY_FLAG_ENABLE_DNS;
                        bModified = TRUE;
                    }
                }                    
                else {
                    // The operation is invalid for the spcified protocol
                    dwErr = ERROR_INVALID_PARAMETER;
                    break;
                }

                pNewProtoInfo       = pAdminProtoInfo;
                dwNewProtoInfoSize  = dwAdminProtoInfoSize;
                dwNewProtoInfoCount = dwAdminProtoInfoCount;
            }
            else {
                // Invalid Protocol id
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }
        }


        // If any change was made, communicate that to the router
        if ( bModified ) {

            dwErr = MprInfoBlockSet(
                        pAdminCurIPInfo,
                        dwProtocolId,
                        dwNewProtoInfoSize,
                        dwNewProtoInfoCount,
                        pNewProtoInfo,
                        &pAdminModIPInfo);

            if ( dwErr != NO_ERROR ) {
                break;
            }

            // Set the modified IP info block back to the router
            dwErr = MprAdminTransportSetInfo(
                        hMprAdmin,
                        PID_IP,
                        pAdminModIPInfo,
                        dwAdminCurIPInfoSize,
                        NULL,
                        0);
            
            if ( dwErr != NO_ERROR ) {
                break;
            }

        }


    } while (FALSE);

    if ( pAdminCurIPInfo )
        MprAdminBufferFree(pAdminCurIPInfo);

    if ( pAdminModIPInfo )
        MprAdminBufferFree(pAdminModIPInfo);

    if ( pConfigCurIPInfo )
        MprConfigBufferFree(pConfigCurIPInfo);

    if ( hMprAdmin )
        MprAdminServerDisconnect(hMprAdmin);

    if ( hMprConfig )
        MprConfigServerDisconnect(hMprConfig);

   return dwErr;

#endif
}


DWORD WINAPI
InternalConfigUpdateProtocolInfo(
    DWORD dwProtocolId,
    DWORD dwOperationId,
    PVOID MoreInfo1,
    PVOID MoreInfo2)

/*++
    Routine Description:

        This routine is used to update protocol information stored in the 
        config (registry)
        e.g. it can be used to enable/disable DNS_PROXY.
        Also, can be extended to control other protocols like DHCP_ALLOCATOR.

    NOTE: Any functionality added to this routine should also be added to
          InternalRouterUpdateProtocolInfo 

    Arguments:

        dwProtocolId: 
            Protocol whose status is to be updated.
            Currently supported protocols:
                MS_IP_DNS_PROXY

        dwOperationId: 
            Possible values:
                UPI_OP_ENABLE
                    enables the specified protocol
                UPI_OP_DISABLE
                    disables the specified protocol

        MoreInfo1:
            Any extra information required to perform the specified operation

        MoreInfo2:
            Any extra information required to perform the specified operation


    Return Value:

        DWORD - status code
        
--*/

{
#if defined(NT4) || defined(CHICAGO)
    return ERROR_NOT_SUPPORTED;
#else
    BOOL  bModified = FALSE;
    DWORD dwErr = NO_ERROR;

    HANDLE hMprConfig = NULL, hTransport = NULL;

    LPBYTE pConfigCurIPInfo = NULL;
    LPBYTE pConfigModIPInfo = NULL;
    LPBYTE pConfigProtoInfo = NULL;

    PIP_DNS_PROXY_GLOBAL_INFO  pDnsInfo = NULL;

    DWORD  dwConfigCurIPInfoSize;
    DWORD  dwConfigProtoInfoSize, dwConfigProtoInfoCount;


    if ( dwProtocolId != MS_IP_DNS_PROXY ) {
        return ERROR_INVALID_PARAMETER;
    }

    do {

        dwErr = MprConfigServerConnect(
                    NULL,
                    &hMprConfig);
                    
        if (dwErr != NO_ERROR) {
            break;
        }


        dwErr = MprConfigTransportGetHandle(
                    hMprConfig,
                    PID_IP,
                    &hTransport);

        if (dwErr != NO_ERROR) {
            break;
        }


        dwErr = MprConfigTransportGetInfo(
                    hMprConfig,
                    hTransport,
                    (LPBYTE *) &pConfigCurIPInfo,
                    &dwConfigCurIPInfoSize,
                    NULL,
                    NULL,
                    NULL);

        if (dwErr != NO_ERROR) {
            break;
        }


        dwErr = MprInfoBlockFind(
                    pConfigCurIPInfo,
                    dwProtocolId,
                    &dwConfigProtoInfoSize,
                    &dwConfigProtoInfoCount,
                    &pConfigProtoInfo);

        if (dwErr != NO_ERROR) {
            break;
        }


        // Perform the desired update

        if ( dwProtocolId == MS_IP_DNS_PROXY ) {
            pDnsInfo = (PIP_DNS_PROXY_GLOBAL_INFO)pConfigProtoInfo; 

            if ( dwOperationId == UPI_OP_ENABLE ) {
                if ( !(pDnsInfo->Flags & IP_DNS_PROXY_FLAG_ENABLE_DNS) ) {
                    pDnsInfo->Flags |= IP_DNS_PROXY_FLAG_ENABLE_DNS;
                    bModified = TRUE;
                }
            }
            else if ( dwOperationId == UPI_OP_DISABLE ) {
                if ( pDnsInfo->Flags & IP_DNS_PROXY_FLAG_ENABLE_DNS ) {
                    pDnsInfo->Flags &= ~IP_DNS_PROXY_FLAG_ENABLE_DNS;
                    bModified = TRUE;
                }
            }                    
            else {
                // The operation is invalid for the spcified protocol
                dwErr = ERROR_INVALID_PARAMETER;
                break;
            }

        }
        else {
            // Invalid Protocol id
            dwErr = ERROR_INVALID_PARAMETER;
            break;
        }
                

        // If any change was made, save it to the config
        if ( bModified ) {

            dwErr = MprInfoBlockSet(
                        pConfigCurIPInfo,
                        dwProtocolId,
                        dwConfigProtoInfoSize,
                        dwConfigProtoInfoCount,
                        pConfigProtoInfo,
                        &pConfigModIPInfo);

            if ( dwErr != NO_ERROR ) {
                break;
            }

            // Set the modified IP info block back to the config
            dwErr = MprConfigTransportSetInfo(
                        hMprConfig,
                        hTransport,
                        pConfigModIPInfo,
                        dwConfigCurIPInfoSize,
                        NULL,
                        0,
                        NULL);
            
            if ( dwErr != NO_ERROR ) {
                break;
            }

        }

    } while (FALSE);


    if ( pConfigCurIPInfo )
        MprConfigBufferFree(pConfigCurIPInfo);

    if ( pConfigModIPInfo )
        MprConfigBufferFree(pConfigModIPInfo);

    if ( hMprConfig )
        MprConfigServerDisconnect(hMprConfig);

   return dwErr;

#endif
}


DWORD WINAPI
InternalUpdateProtocolStatus(
    DWORD dwProtocolId,
    DWORD dwOperationId,
    DWORD dwFlags)

/*++
    Routine Description:

        This routine is used to enable/disable a protocol 

    Arguments:

        dwProtocolId: 
            Protocol whose status is to be updated.
            Currently supported protocols:
                MS_IP_DNS_PROXY

        dwOperationId: 
            Possible values:
                UPI_OP_ENABLE
                    enables the specified protocol
                UPI_OP_DISABLE
                    disables the specified protocol
                UPI_OP_RESTORE_CONFIG
                    information (corresponding to the
                    specified protocol) stored in the config, is set to
                    the router

        dwFlags: 
            Possible values
                UPI_FLAG_WRITE_TO_CONFIG
                    When specified, the changes are made to both router and
                    the config

    Return Value:

        DWORD - status code
        
--*/

{
#if defined(NT4) || defined(CHICAGO)
    return ERROR_NOT_SUPPORTED;
#else

    DWORD dwRouterErr = NO_ERROR;
    DWORD dwConfigErr = NO_ERROR;

    dwRouterErr = InternalRouterUpdateProtocolInfo(
                        dwProtocolId,
                        dwOperationId,
                        NULL,
                        NULL);


    if ( dwFlags & UPI_FLAG_WRITE_TO_CONFIG ) {
        dwConfigErr = InternalConfigUpdateProtocolInfo(
                            dwProtocolId,
                            dwOperationId,
                            NULL,
                            NULL);
    }

   return (dwRouterErr ? dwRouterErr : dwConfigErr);

#endif
}


DWORD WINAPI
InternalUpdateDNSProxyStatus(
    DWORD dwOperationId,
    DWORD dwFlags)

/*++
    Routine Description:

        This routine is used to enable/disable/restore DNS proxy

    Arguments:

        dwOperationId: 
            Possible values:
                UPI_OP_ENABLE
                    enables the specified protocol
                UPI_OP_DISABLE
                    disables the specified protocol
                UPI_OP_RESTORE_CONFIG
                    information (corresponding to the
                    specified protocol) stored in the config, is set to
                    the router

        dwFlags: 
            Possible values
                UPI_FLAG_WRITE_TO_CONFIG
                    When specified, the changes are made to both router and
                    the config

    Return Value:

        DWORD - status code
        
--*/

{
#if defined(NT4) || defined(CHICAGO)
    return ERROR_NOT_SUPPORTED;
#else

    DWORD dwErr = NO_ERROR;

    dwErr = InternalUpdateProtocolStatus(
                MS_IP_DNS_PROXY,
                dwOperationId,
                dwFlags);

   return dwErr;

#endif
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\natlib\iprtrint.h ===
/*++

Copyright (c) 2001  Microsoft Corporation

Module Name:

    iprtrapi.h

Abstract:
    Some private APIs for ip router. These exported in static lib iprtrint.lib

Revision History:
    Anshul Dhir    Created


--*/

#ifndef __IPRTRINT_H__
#define __IPRTRINT_H__

DWORD WINAPI
InternalUpdateProtocolStatus(
    DWORD dwProtocolId,
    DWORD dwOperationId,
    DWORD dwFlags
    );

DWORD WINAPI
InternalUpdateDNSProxyStatus(
    DWORD dwOperationId,
    DWORD dwFlags);


//////////////////////////////////////////////////////////////////////////////
//                                                                          //
// Macros, Flags and operation codes for                                    // 
// InternalUpdateProtocolStatus function                                      //
//                                                                          //
//////////////////////////////////////////////////////////////////////////////

#define UPI_FLAG_WRITE_TO_CONFIG    0x0001

#define UPI_OP_ENABLE               1
#define UPI_OP_DISABLE              2
#define UPI_OP_RESTORE_CONFIG       3

#define DNSProxyEnable()            InternalUpdateDNSProxyStatus(  \
                                        UPI_OP_ENABLE,             \
                                        0)

#define DNSProxyDisable()           InternalUpdateDNSProxyStatus(  \
                                        UPI_OP_DISABLE,            \
                                        0)

#define DNSProxyRestoreConfig()     InternalUpdateDNSProxyStatus(  \
                                        UPI_OP_RESTORE_CONFIG,     \
                                        0)

#endif // __IPRTRINT_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\samples\dns\dummy.c ===
/**
    This is just a dummy C file for the compiler to have
**/

void dummy_main(void)
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\samples\pluginsample\dnspluginsample.h ===
/*++

Copyright (c) 1997-2002  Microsoft Corporation

Module Name:

    DnsPluginSample.h

Abstract:

    Domain Name System (DNS) Sample Plugin DLL

Author:

    Jeff Westhead   jwesth   January 2002

Revision History:

--*/


#ifndef _DNSPLUGINSAMPLE_INCLUDED_
#define _DNSPLUGINSAMPLE_INCLUDED_


#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <windows.h>
#include <windns.h>
#include <dnsapi.h>

#include "..\..\server\DnsPluginInterface.h"


#endif  //  _DNSPLUGINSAMPLE_INCLUDED_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\aging.c ===
/*++

Copyright (c) 1999 Microsoft Corporation

Module Name:

    aging.c

Abstract:

    Domain Name System (DNS) Server

    Implementation of Aging/Scavenging mechanism.

Author:

    Jim Gilroy      July 1999

Revision History:

--*/


#include "dnssrv.h"


#define DNS_MAX_SCAVENGE_FREQUENCY      ( 60 * 60 )     //  60 minutes


//
//  Scavenging context
//

typedef struct _SCAVENGE_CONTEXT
{
    PZONE_INFO      pZone;
    PDB_NODE        pTreeRoot;
    DWORD           dwExpireTime;
    DWORD           dwUpdateFlag;

    DWORD           dwVisitedZones;
    DWORD           dwVisitedNodes;
    DWORD           dwScavengeNodes;
    DWORD           dwScavengeRecords;

    UPDATE_LIST     UpdateList;
}
SCAVENGE_CONTEXT, *PSCAVENGE_CONTEXT;

//
//  Execute scavenge updates in batches of 100
//

#define MAX_SCAVENGE_UPDATE_COUNT   (100)


//
//  Global variables
//

DWORD   g_CurrentTimeHours = 0;

DWORD   g_LastScavengeTime = 0;
DWORD   g_NextScavengeTime = 0;

BOOL    g_bAbortScavenging = FALSE;


//
//  Scavenge lock
//
//  To handle with simple interlocked instructions lock will be
//  (-1) when open, zero when scavenging.
//

LONG    g_ScavengeLock;

#define SCAVENGE_LOCK_INITIAL_VALUE     (-1)

#define SCAVENGING_NOW()        (g_ScavengeLock == 0)


//
//  Zone scavenable after being "enabled" for scavenging for refresh interval
//

#define ZONE_ALLOW_SCAVENGE_TIME(pZone)   \
        ( (pZone)->dwAgingEnabledTime + (pZone)->dwRefreshInterval)


//
//  Keep aging time stamps in hours
//  Since we'll use FILETIME to get time, need conversion from
//  100ns intervals to hours (36 billion)
//

#define FILE_TIME_INTERVALS_IN_HOUR     (36000000000)
#define FILE_TIME_INTERVALS_IN_MINUTES  (600000000)

//
//  Scavenge interval in hours
//

#define SECONDS_IN_HOUR         (3600)
#define SECONDS_IN_MINUTE       (60)


//
//  Debug "minute" aging time globals
//
//  Will calculate time stamps and intervals in minutes, but
//  ONLY the offset from startup system time.  This keep the overall
//  value similar (just slightly bigger than) real hour times, so
//  the results would eventually be scavenged.
//

#if DBG
LONGLONG    g_AgingBaseHourTime = 0;
LONGLONG    g_AgingBaseFileTime = 0;
#endif

#define     SrvCfg_dwAgingTimeMinutes   SrvCfg_fTest2




//
//  Aging functions
//

#if DBG
VOID
Dbg_HourTimeAsSystemTime(
    IN      LPSTR           pszHeader,
    IN      DWORD           dwTime
    )
/*++

Routine Description:

    Debug print refresh time in system time format.

Arguments:

    pszHeader -- debug message header

    dwRefreshHr -- refresh time

Return Value:

    None

--*/
{
    SYSTEMTIME  st;
    LONGLONG    time64;

#if DBG
    if ( SrvCfg_dwAgingTimeMinutes )
    {
        time64 = (LONGLONG) dwTime;
        time64 -= g_AgingBaseHourTime;
        time64 = time64 * FILE_TIME_INTERVALS_IN_MINUTES;
        time64 += g_AgingBaseFileTime;
    }
    else
    {
        time64 = (LONGLONG)dwTime * FILE_TIME_INTERVALS_IN_HOUR;
    }
#else
    time64 = (LONGLONG)dwTime * FILE_TIME_INTERVALS_IN_HOUR;
#endif

    FileTimeToSystemTime( (PFILETIME)&time64, &st );

    DNS_DEBUG( AGING, (
        "%s %lu ([%d:%d:%d] %d/%d/%d)\n",
        pszHeader ? pszHeader : "Hour time:",
        dwTime,
        st.wHour,
        st.wMinute,
        st.wSecond,
        st.wMonth,
        st.wDay,
        st.wYear
        ));
}
#endif



LONGLONG
GetSystemTimeInSeconds64(
    VOID
    )
/*++

Routine Description:

    Get system time in seconds.

Arguments:

    None

Return Value:

    System time in seconds.

--*/
{
    LONGLONG    time64;

    GetSystemTimeAsFileTime( (PFILETIME) &time64 );

    //
    //  convert to seconds
    //      10 million 100ns FILETIME intervals in a second

    time64 = time64 / (10000000);

    return time64;
}



DWORD
GetSystemTimeHours(
    VOID
    )
/*++

Routine Description:

    Get system time in hours.

Arguments:

    None

Return Value:

    System time in hours.

--*/
{
    LONGLONG    time64;

    GetSystemTimeAsFileTime( (PFILETIME) &time64 );

    //
    //  convert to hours
    //      - file time is in 100ns intervals (since Jan 1, 1601)

#if DBG
    if ( SrvCfg_dwAgingTimeMinutes )
    {
        if ( g_AgingBaseFileTime == 0 )
        {
            g_AgingBaseFileTime = time64;
            g_AgingBaseHourTime = time64 / (FILE_TIME_INTERVALS_IN_HOUR);
        }
        time64 -= g_AgingBaseFileTime;
        time64 = time64 / (FILE_TIME_INTERVALS_IN_MINUTES);
        time64 += g_AgingBaseHourTime;
    }
    else
    {
        time64 = time64 / (FILE_TIME_INTERVALS_IN_HOUR);
    }
#else
    time64 = time64 / (FILE_TIME_INTERVALS_IN_HOUR);
#endif

    return (DWORD)time64;
}



DWORD
Aging_UpdateAgingTime(
    VOID
    )
/*++

Routine Description:

    Update aging time global.

Arguments:

    None

Globals:

    Resets g_CurrentTimeHours global.

Return Value:

    New current time in hours.

--*/
{
    DWORD   timeHours;

    timeHours = GetSystemTimeHours();
    if ( (INT)timeHours <= 0 )
    {
        //  this ASSERT is ok for the next 400,000 odd years
        ASSERT( FALSE );
        return timeHours;
    }

    g_CurrentTimeHours = timeHours;

    DNS_DEBUG( AGING, (
        "Reset current aging time = %d\n",
        timeHours ));

    return timeHours;
}



VOID
Aging_TimeStampRRSet(
    IN OUT  PDB_RECORD      pRRSet,
    IN      DWORD           dwFlag
    )
/*++

Routine Description:

    Set time stamp on records in RR set.

Arguments:

    pRR -- RR set to work on

    dwFlag -- update flag;
        if contains DNSUPDATE_AGING_OFF, then mark record for no-aging

Return Value:

    None

--*/
{
    PDB_RECORD  prr;

    DNS_DEBUG( AGING, (
        "Aging_TimeStampRRSet( %p, 0x%x)\n",
        pRRSet, dwFlag ));

    //
    //  set time stamp
    //      - if aging OFF (zero)
    //      - if aging ON, stamp with current time
    //

    prr = pRRSet;

    while ( prr )
    {
        if ( dwFlag & DNSUPDATE_AGING_OFF )
        {
            prr->dwTimeStamp = 0;
        }
        else
        {
            prr->dwTimeStamp = g_CurrentTimeHours;
        }
        prr = NEXT_RR(prr);
    }
    return;
}



DWORD
Aging_InitZoneUpdate(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PUPDATE_LIST    pUpdateList
    )
/*++

Routine Description:

    Set zone's refresh time stamp.

    This is the time stamp below which records need refresh.

Arguments:

    pZone -- ptr to zone info

    pUpdateList -- ptr to update list;

Return Value:

    Returns new zone refresh time.

--*/
{
    DWORD       refreshBelowTime;
    PUPDATE     pupdate;

    //
    //  get current aging time
    //  set "refresh below" time for zone
    //

    refreshBelowTime = Aging_UpdateAgingTime();
    refreshBelowTime -= pZone->dwNoRefreshInterval;

    pZone->dwRefreshTime = refreshBelowTime;

    DNS_DEBUG( AGING, (
        "New zone refresh below time = %d\n",
        refreshBelowTime ));

    //
    //  Timestamp "add" records in update. 
    //

    for ( pupdate = pUpdateList->pListHead;
          pupdate != NULL;
          pupdate = pupdate->pNext )
    {
        ASSERT( pupdate->pNode );

        if ( pupdate->pAddRR )
        {
            Aging_TimeStampRRSet( pupdate->pAddRR, pUpdateList->Flag );
        }
    }

    return refreshBelowTime;
}



//
//  Scavenging
//

VOID
executeScavengeUpdate(
    IN OUT  PSCAVENGE_CONTEXT   pContext,
    IN      BOOL                bForce
    )
/*++

Routine Description:

    Do update on any scavenging created so far.

    Only executes update IF have accumulated a reasonable number
    of updates OR at end of zone's scavenging.

Arguments:

    pContext -- scavenging context

    bForce -- force update;  TRUE if end of zone scavenging

Return Value:

    None

--*/
{
    DNS_STATUS  status;

    //
    //  do NOT execute if
    //      - not forcing and not at limit
    //      - forcing and no updates
    //

    if ( !bForce )
    {
        if ( pContext->UpdateList.dwCount < MAX_SCAVENGE_UPDATE_COUNT )
        {
            DNS_DEBUG( AGING, (
                "Delay scavenge update on zone %S -- below MAX count\n",
                pContext->pZone->pwsZoneName ));
            return;
        }
    }
    else    // forcing
    {
        if ( pContext->UpdateList.dwCount == 0 )
        {
            DNS_DEBUG( AGING, (
                "Skip final scavenge update on zone %S -- no remaining updates!\n",
                pContext->pZone->pwsZoneName ));
            return;
        }
    }

    //
    //  execute a scavenge update
    //

    status = Up_ExecuteUpdate(
                    pContext->pZone,
                    & pContext->UpdateList,
                    pContext->dwUpdateFlag );

    if ( status != ERROR_SUCCESS )
    {
        //  DEVNOTE-LOG: add log event for failed scavenge update

        DNS_DEBUG( ANY, (
            "ERROR:  Failed scavenging update on zone %S\n"
            "    status = %d (%p)\n",
            pContext->pZone->pwsZoneName,
            status, status ));
    }

    else
    {
        if ( pContext->UpdateList.iNetRecords < 0 )
        {
            pContext->dwScavengeRecords -= pContext->UpdateList.iNetRecords;

            DNS_DEBUG( AGING, (
                "Scavenged %d records in update to zone %S\n",
                - ( pContext->UpdateList.iNetRecords ),
                pContext->pZone->pwsZoneName ));
        }
        ELSE
        {
            ASSERT( pContext->UpdateList.iNetRecords == 0 );

            DNS_DEBUG( ANY, (
                "No records scavenged in scavenge update!\n" ));
        }
    }

    //  re-init update list
    //      - updates are freed in ExecuteUpdate() even on failure

    Up_InitUpdateList( &pContext->UpdateList );

    //  DEVNOTE: Could stop scavenging on failure and return status.
}



BOOL
scavengeNode(
    IN OUT  PDB_NODE            pNode,
    IN OUT  PSCAVENGE_CONTEXT   pContext
    )
/*++

Routine Description:

    Scavenge any expired records at this node.

    Recursive function call to scavenge zone.

Arguments:

    pNode -- node to scavenge

    pContext -- scavenging context

Return Value:

    TRUE if successful -- continue scavenging.
    FALSE on error -- stop scavenging.

--*/
{
    PDB_RECORD  prr;

    DNS_DEBUG( AGING, (
        "scavengeNode( %p <%s>, context=%p )\n",
        pNode,
        pNode->szLabel,
        pContext ));

    pContext->dwVisitedNodes++;

    //
    //  check service pause\shutdown
    //

    if ( fDnsThreadAlert )
    {
        if ( !Thread_ServiceCheck() )
        {
            DNS_DEBUG( SHUTDOWN, ( "Terminating scavenge thread due to shutdown\n" ));
            ExitThread( 0 );
            return FALSE;
        }
    }
    if ( g_bAbortScavenging )
    {
        DNS_DEBUG( AGING, ( "Terminating scavenge thread due to scavenge abort\n" ));
        return FALSE;
    }

    //
    //  check that tree not deleted out from under us
    //

    if ( IS_ZONE_DELETED( pContext->pZone ) ||
        pContext->pZone->pTreeRoot != pContext->pTreeRoot )
    {
        DNS_DEBUG( ANY, (
            "Zone %S (%p) deleted or reloaded during scavenging!\n",
            pContext->pZone->pwsZoneName,
            pContext->pZone ));
        return FALSE;
    }

    //
    //  walk child list -- depth first recursion
    //

    if ( pNode->pChildren )
    {
        PDB_NODE pchild = NTree_FirstChild( pNode );

        while ( pchild )
        {
            if ( ! scavengeNode(
                        pchild,
                        pContext ) )
            {
                return FALSE;
            }
            pchild = NTree_NextSiblingWithLocking( pchild );
        }
    }

    //  optimize return if no records -- skips locking
    //
    //  note:  NOEXIST could get added before we take the lock
    //      but this is extremely rare and just sends us through
    //      update path unnecessarily with no ill effect -- not
    //      worth checking for
    //

    if ( !pNode->pRRList || IS_NOEXIST_NODE(pNode) )
    {
        return TRUE;
    }

    //
    //  traverse node RRs
    //      - if any need scavenging, just append scavenge update to list
    //
    //  note:  instead of collecting records here, we create "scavenge updates"
    //  several advantages:
    //      1) fewer CPU cycles creating temp copies, update blobs, going through locks
    //      2) fewer net updates -- can bunch them up;  less IXFR, AXFR replication
    //      3) replication collision, as scavenge update operates on FRESH from DS data
    //

    LOCK_READ_RR_LIST(pNode);

    prr = START_RR_TRAVERSE( pNode );

    while ( prr = NEXT_RR(prr) )
    {
        //  skip empty record sets - should never find any here

        if ( IS_EMPTY_AUTH_RR( prr ) )
        {
            ASSERT( !IS_EMPTY_AUTH_RR( prr ) );
            continue;
        }

        //  if non-aging or not expired, continue

        if ( prr->dwTimeStamp == 0  ||
             prr->dwTimeStamp >= pContext->dwExpireTime )
        {
            continue;
        }

        //  need to scavenge this node

        break;
    }

    UNLOCK_READ_RR_LIST(pNode);

    //
    //  if scavenging node
    //      - create scavenge update
    //      - check and possibly execute update
    //      (see comment above on reason for batching them)
    //

    if ( prr )
    {
        DNS_DEBUG( AGING, (
            "Found scavenged record (%p) at node %s with dwTimeStamp = %lu\n",
            prr,
            pNode->szLabel,
            prr->dwTimeStamp ));

        Up_CreateAppendUpdate(
                & pContext->UpdateList,
                pNode,
                NULL,                   //  no add
                UPDATE_OP_SCAVENGE,     //  scavenge update
                NULL                    //  no delete record
                );

        pContext->dwScavengeNodes++;

        executeScavengeUpdate(
            pContext,
            FALSE );                //  no force
    }

    return TRUE;
}



DNS_STATUS
Scavenge_Thread(
    IN      PVOID           pvDummy
    )
/*++

Routine Description:

    Main entry point for scavenging. This thread will fire at regular
    intervals & perform scavenging.
    Potentially, it can be triggered by an admin via RPC interface.

Arguments:

    Unreferenced.

Return Value:

    Status in win32 error space

--*/
{
    DNS_STATUS          status = ERROR_SUCCESS;
    PZONE_INFO          pzone;
    SCAVENGE_CONTEXT    context;
    PDNS_ADDR_ARRAY     pscavengers;

    DNS_DEBUG( AGING, (
        "Entering Scavenge_Thread()\n"
        "    time =             %d\n"
        "    hour time =        %d\n",
        DNS_TIME(),
        Aging_UpdateAgingTime() ));

    //
    //  if already scavenging -- bail
    //

    if ( SCAVENGING_NOW() )
    {
        DNS_DEBUG( ANY, (
            "Entered scavenge thread while scavenging!\n" ));
        ASSERT( FALSE );
        goto Close;
    }

    //
    //  lock to avoid dual scavenging
    //
    //  do NOT hold lock during scavenging, as then admin coming in to
    //  reset scavenge timer can end up waiting on the lock
    //

    if ( InterlockedIncrement( &g_ScavengeLock ) != 0 )
    {
        InterlockedDecrement( &g_ScavengeLock );
        DNS_DEBUG( ANY, (
            "Entered scavenge thread while scavenging!\n" ));
        ASSERT( FALSE );
        goto Close;
    }
    g_bAbortScavenging = FALSE;

    //  init scavenge context

    RtlZeroMemory( &context, sizeof( SCAVENGE_CONTEXT ) );

    context.dwUpdateFlag = DNSUPDATE_SCAVENGE | DNSUPDATE_LOCAL_SYSTEM;

    //
    //  Protection against over-scavenging.
    //

    if ( DNS_TIME() < g_LastScavengeTime + DNS_MAX_SCAVENGE_FREQUENCY )
    {
        DNS_DEBUG( ANY, (
            "Not scavenging - last attempt was too recent\n" ));
        goto Finished;
    }

    g_LastScavengeTime = DNS_TIME();
    g_NextScavengeTime = MAXDWORD;

    //
    //  update aging hour time
    //

    Aging_UpdateAgingTime();

    IF_DEBUG( AGING )
    {
        Dbg_HourTimeAsSystemTime(
            "Scavenge_Thread() start",
            g_CurrentTimeHours );
    }

    //
    //  loop through DS zones / scavengable zones.
    //

    pzone = NULL;

    while ( pzone = Zone_ListGetNextZone( pzone ) )
    {
        //
        //  Do not scavenge this zone if:
        //      - scavenging not enabled on this zone, or
        //      - zone is the cache zone (may want to change), or
        //      - zone is paused
        //

        if ( !pzone->bAging ||
             ZONE_ALLOW_SCAVENGE_TIME( pzone ) > g_CurrentTimeHours ||
             IS_ZONE_CACHE( pzone ) ||
             IS_ZONE_PAUSED( pzone ) )
        {
            DNS_DEBUG( AGING, (
                "Warning: Skipping scavenging for zone %s\n",
                pzone->pszZoneName ));
            continue;
        }

        ++context.dwVisitedZones;

        //
        //  if specific scavenge servers specified, then must also be one of them
        //      - note take local instead of locking during reconfig
        //

        pscavengers = pzone->aipScavengeServers;
        if ( pscavengers )
        {
            if ( !DnsAddrArray_IsIntersection(
                    pscavengers,
                    g_ServerIp4Addrs,
                    DNSADDR_MATCH_IP ) )
            {
                DNS_DEBUG( AGING, (
                    "Warning:  skipping scavenging on zone %s\n"
                    "    this server NOT designated scavenger\n",
                    pzone->pszZoneName ));
                continue;
            }
            DNS_DEBUG( AGING, (
                "This server in scavenge server list for zone %s\n",
                pzone->pszZoneName ));
            DnsDbg_DnsAddrArray(
                "scavengers",
                NULL,
                pscavengers );
            DnsDbg_DnsAddrArray(
                "g_ServerIp4Addrs",
                NULL,
                g_ServerIp4Addrs );
        }

        //
        //  init for this zone
        //      - note must save ptr to tree we're in in case
        //      admin does reload during scavenging
        //

        context.pZone = pzone;
        context.pTreeRoot = pzone->pTreeRoot;
        if ( ! context.pTreeRoot )
        {
            DNS_DEBUG( AGING, (
                "Warning:  Skipped scavenging on zone %s -- no zone tree\n",
                pzone->pszZoneName ));
            continue;
        }
        context.dwExpireTime = AGING_ZONE_EXPIRE_TIME(pzone);

        Up_InitUpdateList( &context.UpdateList );

        //
        //  scavenge this zone
        //

        DNS_DEBUG( AGING, (
            "Scavenging zone %S\n"
            "    expire time  = %d\n"
            "    current time = %d\n",
            pzone->pwsZoneName,
            context.dwExpireTime,
            g_CurrentTimeHours ));

        if ( scavengeNode(
                context.pTreeRoot,
                & context ) )
        {
            //  execute update for any remaining scavenging

            executeScavengeUpdate(
                & context,
                TRUE );         //  force update

            DNS_DEBUG( AGING, (
               "Scavenging stats after zone %S:\n"
               "    Visited Nodes     = %lu\n"
               "    Scavenged Nodes   = %lu\n"
               "    Scavenged Records = %lu\n",
               pzone->pwsZoneName,
               context.dwVisitedNodes,
               context.dwScavengeNodes,
               context.dwScavengeRecords ));
        }
        else
        {
            context.UpdateList.Flag |= DNSUPDATE_NO_DEREF;
            Up_FreeUpdatesInUpdateList( &context.UpdateList );

            DNS_DEBUG( AGING, (
               "Zone %S scavenge failure\n",
               pzone->pwsZoneName ));

            if ( g_bAbortScavenging )
            {
                break;
            }
        }
    }

Finished:

    //
    //  log scavenging completion event
    //

    if ( context.dwVisitedNodes )
    {
        PCHAR   argArray[] =
        {
            (PCHAR) (DWORD_PTR) context.dwVisitedZones,
            (PCHAR) (DWORD_PTR) context.dwVisitedNodes,
            (PCHAR) (DWORD_PTR) context.dwScavengeNodes,
            (PCHAR) (DWORD_PTR) context.dwScavengeRecords,
            (PCHAR) (DWORD_PTR) (GetCurrentTimeInSeconds() - g_LastScavengeTime),
            (PCHAR) (DWORD_PTR) SrvCfg_dwScavengingInterval
        };

        DNS_LOG_EVENT(
            DNS_EVENT_AGING_SCAVENGING_END,
            6,
            argArray,
            EVENTARG_ALL_DWORD,
            status );
    }
    else
    {
        PCHAR   argArray[] =
        {
            (PCHAR) (DWORD_PTR) ( DNS_MAX_SCAVENGE_FREQUENCY / 60 ),
            (PCHAR) (DWORD_PTR) SrvCfg_dwScavengingInterval
        };

        DNS_LOG_EVENT(
            DNS_EVENT_AGING_SCAVENGING_END_NO_WORK,
            2,
            argArray,
            EVENTARG_ALL_DWORD,
            status );
    }

    //
    //  clear scavenge lock
    //  reset for next scavenge time
    //

    g_bAbortScavenging = FALSE;
    InterlockedDecrement( &g_ScavengeLock );
    Scavenge_TimeReset();

    DNS_DEBUG( AGING, (
        "Exit <%lu>: Scavenge_Thread\n",
        status ));

Close:

    //  clear thread from list

    Thread_Close( FALSE );
    return status;
}



DNS_STATUS
Scavenge_CheckForAndStart(
    IN      BOOL            fForce
    )
/*++

Routine Description:

    Main entry point for scavenging. This thread will fire at regular
    intervals & perform scavenging.
    Potentially, it can be triggered by an admin via RPC interface.

Arguments:

    Unreferenced.

Return Value:

    Status in win32 error space

--*/
{

    DNS_DEBUG( SCAVENGE, (
        "Scavenge_CheckForAndStart()\n"
        "    force = %d\n",
        fForce ));

    //
    //  if scavenge not to next time interval
    //

    if ( !fForce && DNS_TIME() < g_NextScavengeTime )
    {
        return ERROR_SUCCESS;;
    }

    //
    //  already scavenging?
    //  DEVNOTE-LOG:  for admin return a SCAVENGING_NOW error?
    //

    if ( SCAVENGING_NOW() )
    {
        DNS_DEBUG( AGING, (
            "Scavenging in progress, ignoring scavenge time check\n" ));
        return ERROR_SUCCESS;;
    }

    //
    //  create scavenge thread
    //

    if ( ! Thread_Create(
                "ScavengeThread",
                Scavenge_Thread,
                NULL,
                0 ) )
    {
        DNS_PRINT(( "ERROR:  Failed to create scavenge thread!\n" ));
        return GetLastError();
    }

    DNS_DEBUG( AGING, (
        "Dispatched scavenge thread\n" ));

    return ERROR_SUCCESS;;
}



DNS_STATUS
Scavenge_TimeReset(
    VOID
    )
/*++

Routine Description:

    Reset scavenge timer for next scavenging interval.

Arguments:

    None

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_DEBUG( SCAVENGE, ( "\nScavenge_TimeReset()\n" ));

    //
    //  already scavenging?
    //
    //  DEVNOTE-LOG: for admin return a SCAVENGING_NOW error?
    //

    if ( SCAVENGING_NOW() )
    {
        DNS_DEBUG( AGING, (
            "Scavenging in progress, ignoring scavenge time reset\n" ));
        return ERROR_SUCCESS;
    }

    //
    //  reset next scavenge time
    //

    if ( SrvCfg_dwScavengingInterval )
    {
#if DBG
        if ( SrvCfg_dwAgingTimeMinutes )
        {
            g_NextScavengeTime = g_LastScavengeTime +
                                (SrvCfg_dwScavengingInterval * SECONDS_IN_MINUTE);
        }
        else
        {
            g_NextScavengeTime = g_LastScavengeTime +
                                (SrvCfg_dwScavengingInterval * SECONDS_IN_HOUR);
        }
#else
        g_NextScavengeTime = g_LastScavengeTime +
                            (SrvCfg_dwScavengingInterval * SECONDS_IN_HOUR);
#endif
    }
    else
    {
        g_NextScavengeTime = MAXDWORD;
    }

    DNS_DEBUG( AGING, (
        "Set scavenge time\n"
        "    last scavenge    = %d\n"
        "    now              = %d\n"
        "    interval         = %d\n"
        "    next scavenge    = %d\n",
        g_LastScavengeTime,
        DNS_TIME(),
        SrvCfg_dwScavengingInterval,
        g_NextScavengeTime ));

    return ERROR_SUCCESS;;
}



DNS_STATUS
Scavenge_Initialize(
    VOID
    )
/*++

Routine Description:

    Initializes the scavenging system

Arguments:

    None.

Return Value:

    ERROR_SUCCESS if successful.
    ErrorCode on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    DWORD       scavengeTime;

    DNS_DEBUG ( AGING, (
        "Scavenge_Initialize()\n"
        ));

    //  init scavenge lock

    g_bAbortScavenging = FALSE;
    g_ScavengeLock = SCAVENGE_LOCK_INITIAL_VALUE;

    //  set current aging time global

    Aging_UpdateAgingTime();

    //  init scavenge time checks

    g_LastScavengeTime = DNS_TIME();
    Scavenge_TimeReset();
    g_LastScavengeTime = 0;

    return status;
}



VOID
Scavenge_Cleanup(
    VOID
    )
/*++

Routine Description:

    Cleanup scavenge globals for restart

Arguments:

    None

Return Value:

    None

--*/
{
}



DNS_STATUS
privateSetNoAgingRRs(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode
    )
/*++

Routine Description:

    Recursive worker function used by setNoAgingRRs.

Arguments:

    pZone -- zone to examine
    
    pNode -- current node

Return Value:

    Error code.

--*/
{
    DWORD       status = ERROR_SUCCESS;
    PDB_RECORD  prr;

    //
    //  Recurse on each child node.
    //
        
    if ( pNode->pChildren )
    {
        PDB_NODE    pchild = NTree_FirstChild( pNode );

        while ( pchild )
        {
            status = privateSetNoAgingRRs( pZone, pchild );
            if ( status != ERROR_SUCCESS )
            {
                return status;
            }
            pchild = NTree_NextSiblingWithLocking( pchild );
        }
    }

    //
    //  Optimization: return immediately if no RRs to avoid taking lock.
    //

    if ( !pNode->pRRList )
    {
        goto Done;
    }

    //
    //  Traverse node RRs.
    //

    LOCK_READ_RR_LIST( pNode );

    prr = START_RR_TRAVERSE( pNode );

    while ( ( prr = NEXT_RR( prr ) ) != NULL )
    {
        if ( prr->wType == DNS_TYPE_NS )
        {
            //
            //  Mark all address records in the zone node corresponding
            //  to the nameserver target as DO_NOT_AGE.
            //
            
            PDB_NODE        pglueNode;
            
            pglueNode = Lookup_FindNodeForDbaseName(
                            pZone,
                            &prr->Data.NS.nameTarget );
            if ( pglueNode )
            {
                PDB_RECORD      pglueRR = START_RR_TRAVERSE( pglueNode );

                while ( ( pglueRR = NEXT_RR( pglueRR ) ) != NULL )
                {
                    if ( IS_GLUE_ADDRESS_TYPE( pglueRR->wType ) )
                    {
                        SET_DO_NOT_AGE_RR( pglueRR );
                    }
                    
                    if ( pglueRR->wType > DNS_TYPE_AAAA )
                    {
                        break;  //  Optimization: early loop break.
                    }
                }
            }
        }
        else if ( prr->wType > DNS_TYPE_NS )
        {
            //  We're finished with this node.
            break;
        }
    }

    UNLOCK_READ_RR_LIST( pNode );
    
    Done:

    return status;
}



DNS_STATUS
setNoAgingRRs(
    IN OUT  PZONE_INFO      pZone
    )
/*++

Routine Description:

    Examine the zone, setting the NO_AGE flag on RRs as necessary.

    RRs that should not be aged include:
    
        --  A records for NS record host names
        
    Note: the NO_AGE flag is never cleared. Once an RR has been marked
    NO_AGE then it can never be force-aged until the server is restarted.
    This would only be a problem if NS records were deleted then the
    zone was force-aged to try and get the corresponding A records to be
    timestamped for scavenging. This seems unlikely and not a serious
    issue.

Arguments:

    pZone -- zone to examine

Return Value:

    Error code.

--*/
{
    DWORD       status = DNS_ERROR_RCODE_SERVER_FAILURE;
    
    if ( !pZone )
    {
        goto Done;
    }
    
    status = privateSetNoAgingRRs( pZone, pZone->pZoneRoot );
    
    Done:
    
    return status;
}



//
//  Force aging on nodes
//

BOOL
forceAgingOrNodeOrSubtreePrivate(
    IN OUT  PDB_NODE            pNode,
    IN      BOOL                fAgeSubtree,
    IN OUT  PSCAVENGE_CONTEXT   pContext
    )
/*++

Routine Description:

    Recursive database walk aging records from tree.

Arguments:

    pNode -- ptr to root of subtree to delete

    fAgeSubtree -- aging entire subtree

    pUpdateList -- update list, if aging zone nodes

Return Value:

    TRUE if subtree actually deleted.
    FALSE if subtree delete halted by undeletable records.

--*/
{
    PDB_RECORD  prr;

    DNS_DEBUG( RPC2, (
        "forceAgingOrNodeOrSubtreePrivate( %s )",
        pNode->szLabel ));

    ++pContext->dwVisitedNodes;

    //
    //  check service pause\shutdown
    //

    if ( fDnsThreadAlert )
    {
        if ( !Thread_ServiceCheck() )
        {
            DNS_DEBUG( SHUTDOWN, ( "Terminating force aging thread due to shutdown\n" ));
            return FALSE;
        }
    }

    //
    //  check that tree not deleted out from under us
    //

    if ( IS_ZONE_DELETED( pContext->pZone ) ||
        pContext->pZone->pTreeRoot != pContext->pTreeRoot )
    {
        DNS_DEBUG( ANY, (
            "Zone %S (%p) deleted or reloaded during scavenging!\n",
            pContext->pZone->pwsZoneName,
            pContext->pZone ));
        return FALSE;
    }

    //
    //  walk child list -- depth first recursion
    //

    if ( pNode->pChildren  &&  fAgeSubtree )
    {
        PDB_NODE pchild = NTree_FirstChild( pNode );

        while ( pchild )
        {
            if ( !forceAgingOrNodeOrSubtreePrivate(
                            pchild,
                            fAgeSubtree,
                            pContext ) )
            {
                return FALSE;
            }
            pchild = NTree_NextSiblingWithLocking( pchild );
        }
    }

    //  optimize return if no records -- skips locking

    if ( !pNode->pRRList || IS_NOEXIST_NODE(pNode) )
    {
        return TRUE;
    }

    //
    //  traverse node RRs
    //      - if non-aging of valid aging type, need update
    //
    //  note:  NOEXIST could get added before we take the lock
    //      but this is extremely rare and just sends us through
    //      update path unnecessarily with no ill effect -- not
    //      worth checking for
    //

    LOCK_READ_RR_LIST( pNode );

    prr = START_RR_TRAVERSE( pNode );

    while ( ( prr = NEXT_RR( prr ) ) != NULL )
    {
        //  skip empty record sets - should never find any here

        if ( IS_EMPTY_AUTH_RR( prr ) )
        {
            ASSERT( !IS_EMPTY_AUTH_RR( prr ) );
            continue;
        }
        
        //  if already aging or non-aging type, continue

        if ( prr->dwTimeStamp != 0  ||
             IS_NON_SCAVENGE_TYPE( prr->wType ) )
        {
            continue;
        }

        //  Skip RRs marked as DO_NOT_AGE.
        
        if ( IS_DO_NOT_AGE_RR( prr ) )
        {
            continue;
        }

        //  need to force aging on this node

        break;
    }

    UNLOCK_READ_RR_LIST( pNode );

    //
    //  if need to force aging on node
    //      - build update
    //      - possibly execute update if batch large enough
    //      (see comment above on reason for batching them)
    //

    if ( prr )
    {
        DNS_DEBUG( AGING, (
            "Found record (%p) at node %s with zero timestamp\n",
            prr,
            pNode->szLabel ));

        Up_CreateAppendUpdate(
            &pContext->UpdateList,
            pNode,
            NULL,                   //  no add
            UPDATE_OP_FORCE_AGING,  //  force aging update
            NULL );                 //  no delete record

        pContext->dwScavengeNodes++;

        executeScavengeUpdate(
            pContext,
            FALSE );                //  no force
    }

    return TRUE;
}



DNS_STATUS
Aging_ForceAgingOnNodeOrSubtree(
    IN OUT  PZONE_INFO      pZone,
    IN OUT  PDB_NODE        pNode,
    IN      BOOL            fAgeSubtree
    )
/*++

Routine Description:

    Age subtree for admin.

    If in zone, zone should be locked during delete.

Arguments:

    pNode -- ptr to root of subtree to delete

    pZone -- zone of deleted records

    fAgeSubtree -- aging subtree under node

Return Value:

    ERROR_SUCCESS on successful update.
    ErrorCode if unable to launch update.

--*/
{
    DWORD               status;
    SCAVENGE_CONTEXT    context;

    ASSERT( pZone );

    DNS_DEBUG( RPC, (
        "Aging_ForceAgingOnNodeOrSubtree()\n"
        "    zone         = %s\n"
        "    node         = %s\n"
        "    subtree op   = %d\n",
        pZone->pszZoneName,
        pNode ? pNode->szLabel : NULL,
        fAgeSubtree ));

    //
    //  if not aging zone -- pointless
    //

    if ( !pZone->bAging )
    {
        return DNS_ERROR_INVALID_ZONE_TYPE;
    }

    //
    //  init scavenge context
    //
    //  we use the scavenge context to do the same kind of update "batching"
    //  that we do for scavenging
    //

    RtlZeroMemory( &context, sizeof( SCAVENGE_CONTEXT ) );

    context.dwUpdateFlag = DNSUPDATE_ADMIN | DNSUPDATE_LOCAL_SYSTEM;

    Aging_UpdateAgingTime();
    
    //
    //  First pass: set DO_NOT_AGE RRs in the zone. This is an expensive
    //  step, but it's required because aging all records in the zone
    //  without exception is dangerous. For example, if we age A records
    //  in the zone for static NS hostnames, the zone will become 
    //  dysfunctional when the A records are scavenged.
    //
    
    status = setNoAgingRRs( pZone );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( RPC, (
           "Failed to set no-aging RRs in zone with error %d\n", status ));

        return status;
    }

    //  zone specific context
    //      - note must save ptr to tree we're in in case
    //      admin does reload during our processing

    context.pZone = pZone;
    context.pTreeRoot = pZone->pTreeRoot;

    Up_InitUpdateList( &context.UpdateList );

    //
    //  Second pass: call private function which does recursive delete.
    //

    if ( forceAgingOrNodeOrSubtreePrivate(
                    pNode,
                    fAgeSubtree,
                    &context ) )
    {
        //  execute update for any remaining scavenging

        executeScavengeUpdate(
            &context,
            TRUE );             //  force update

        DNS_DEBUG( RPC, (
           "Forced aging stats after zone %S:\n"
           "    Visited Nodes   = %lu\n"
           "    Forcing Nodes   = %lu\n"
           "    Forcing Records = %lu\n",
           pZone->pwsZoneName,
           context.dwVisitedNodes,
           context.dwScavengeNodes,
           context.dwScavengeRecords ));

        return ERROR_SUCCESS;;
    }
    else
    {
        //  free update list on failure

        context.UpdateList.Flag |= DNSUPDATE_NO_DEREF;
        Up_FreeUpdatesInUpdateList( &context.UpdateList );

        DNS_DEBUG( RPC, (
           "Zone %S failed force aging\n",
           pZone->pwsZoneName ));

        return DNS_ERROR_INVALID_ZONE_OPERATION;
    }
}

//
//  End of aging.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\autoconfigure.c ===
/*++

Copyright (c) 1995-2001 Microsoft Corporation

Module Name:

    autoconfigure.c

Abstract:

    Domain Name System (DNS) Server

    Auto-configuration of the DNS server on first start

Author:

    Jeff Westhead (jwesth)  October, 2001

Revision History:

    jwesth      10/2001     initial implementation

--*/


/****************************************************************************


****************************************************************************/


//
//  Includes
//


#include "dnssrv.h"

#include "iphlpapi.h"


//
//  Definitions
//


#define DNS_ROOT_HINT_TTL           0
#define DNS_ROOT_NAME               "."

//
//  Hide public information
//

//#undef DNS_ADAPTER_INFO
//#undef PDNS_ADAPTER_INFO

typedef struct _AdapterInfo
{
    struct _AdapterInfo *       pNext;
    PWSTR                       pwszAdapterName;
    PSTR                        pszAdapterName;
    PSTR                        pszInterfaceRegKey;
    HKEY                        hkeyRegInterface;
    PSTR                        pszDhcpDnsRegValue;
    CHAR                        szDhcpRegAddressDelimiter[ 2 ];
    PSTR                        pszStaticDnsRegValue;
    CHAR                        szStaticRegAddressDelimiter[ 2 ];
    BOOL                        fUsingStaticDnsServerList;
    PIP4_ARRAY                  pip4DnsServerList;
    IP_ADAPTER_INFO             IpHlpAdapterInfo;
}   ADAPTER_INFO, * PADAPTER_INFO;


#define SET_AUTOCONFIG_END_TIME()                                       \
                dwAutoConfigEndTime = UPDATE_DNS_TIME() + 300;

#define CHECK_AUTOCONFIG_TIME_OUT()                                     \
    if ( UPDATE_DNS_TIME() > dwAutoConfigEndTime )                      \
    {                                                                   \
        status = ERROR_TIMEOUT;                                         \
        DNS_DEBUG( INIT, ( "%s: operation timed out\n", fn ));          \
        goto Done;                                                      \
    }
    
//
//  Globals
//


DWORD       dwAutoConfigEndTime = 0;

//
//  Local functions
//



DNS_STATUS
allocateRegistryStringValue(
    IN      HKEY        hkey,
    IN      PSTR        pszValueName,
    OUT     PSTR *      ppszData,
    OUT     PSTR        pszRegDelimiter
    )
/*++

Routine Description:

    Free a linked list of adapter info structures previously created
    by allocateAdapterList.

Arguments:

    hkeyReg -- registry handle
    
    pszValueName -- value name to read
    
    ppszData -- newly allocated string read from registry
    
    pszRegDelimiter -- must point to a 2 character string buffer, which
        will be set to a one character string such as "," to match the
        character currently being used to delimit the IP addresses

Return Value:

    Status code.
    
--*/
{
    DBG_FN( "ReadRegString" )
    
    DNS_STATUS      status = ERROR_SUCCESS;
    DWORD           regType = 0;
    DWORD           dataSize = 0;
    
    ASSERT( ppszData );
    *ppszData = NULL;
    
    ASSERT( pszRegDelimiter );
    strcpy( pszRegDelimiter, " " );
    
    //
    //  Find out how big the string is.
    //
    
    status = RegQueryValueExA(
                    hkey,
                    pszValueName,
                    0,                                  //  reserved
                    &regType,
                    NULL,
                    &dataSize );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, (
            "%s: query failure %d on %s\n", fn, status, pszValueName ));
        goto Done;
    }
    if ( regType != REG_SZ )
    {
        DNS_DEBUG( INIT, (
            "%s: unexpected query type %d on %s\n", fn, regType, pszValueName ));
        status = ERROR_INVALID_DATA;
        goto Done;
    }
    
    //
    //  Allocate a buffer for the string.
    //
                    
    *ppszData = ALLOC_TAGHEAP_ZERO( dataSize + 10, MEMTAG_STUFF );
    if ( !*ppszData )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }
    
    //
    //  Read registry data.
    //

    status = RegQueryValueExA(
                    hkey,
                    pszValueName,
                    0,                                  //  reserved
                    &regType,
                    ( PBYTE ) *ppszData,
                    &dataSize );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, (
            "%s: read failure %d on %s\n", fn, status, pszValueName ));
        goto Done;
    }
    
    //
    //  Determine delimiter. We've noticed that on different machines
    //  using DHCP and static DNS servers that the delimiter can be
    //  either space or comma.
    //
    
    if ( *ppszData && strchr( *ppszData, ',' ) != NULL )
    {
        strcpy( pszRegDelimiter, "," );
    }

    Done:
    
    if ( status != ERROR_SUCCESS )
    {
        FREE_HEAP( *ppszData );
        *ppszData = NULL;
    }

    //
    //  If the key was missing, assume it is not set and return success
    //  (with a NULL string).
    //
    
    if ( status == ERROR_FILE_NOT_FOUND )
    {
        status = ERROR_SUCCESS;
    }
    
    return status;
}   //  allocateRegistryStringValue



void
freeAdapterList(
    IN      PADAPTER_INFO       pAdapterInfoListHead
    )
/*++

Routine Description:

    Free a linked list of adapter info structures previously created
    by allocateAdapterList.

Arguments:

    pAdapterInfoListHead -- ptr to list of adapter info blobs to free

Return Value:

    Status code.
    
--*/
{
    PADAPTER_INFO           padapterInfo;
    PADAPTER_INFO           pnext;
    
    for ( padapterInfo = pAdapterInfoListHead;
          padapterInfo != NULL;
          padapterInfo  = pnext )
    {
        pnext = padapterInfo->pNext;

        if ( padapterInfo->hkeyRegInterface )
        {
            RegCloseKey( padapterInfo->hkeyRegInterface );
        }

        FREE_HEAP( padapterInfo->pwszAdapterName );
        FREE_HEAP( padapterInfo->pszAdapterName );
        FREE_HEAP( padapterInfo->pszInterfaceRegKey );
        FREE_HEAP( padapterInfo->pszDhcpDnsRegValue );
        FREE_HEAP( padapterInfo->pszStaticDnsRegValue );

        FREE_HEAP( padapterInfo );
    }
}   //  freeAdapterList



DNS_STATUS
allocateAdapterList(
    IN      PADAPTER_INFO     * ppAdapterInfoListHead
    )
/*++

Routine Description:

    Allocates a linked list of adapter structures with information
    on each adatper.

Arguments:

    ppAdapterInfoListHead -- set to point to first element in list

Return Value:

    Status code.
    
--*/
{
    DBG_FN( "AdapterList" )
    
    DNS_STATUS          status = ERROR_SUCCESS;
    ULONG               bufflen = 0;
    PIP_ADAPTER_INFO    pipAdapterInfoList = NULL;
    PIP_ADAPTER_INFO    pipAdapterInfo;
    PADAPTER_INFO       pprevAdapter = NULL;
    PADAPTER_INFO       pnewAdapter = NULL;

    if ( !ppAdapterInfoListHead )
    {
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }
    *ppAdapterInfoListHead = NULL;

    //
    //  Allocate a buffer for the adapter list and retrieve it.
    //
        
    status = GetAdaptersInfo( NULL, &bufflen );
    if ( status != ERROR_BUFFER_OVERFLOW )
    {
        ASSERT( status == ERROR_BUFFER_OVERFLOW );
        goto Done;
    }
    
    pipAdapterInfoList = ALLOC_TAGHEAP( bufflen, MEMTAG_STUFF );
    if ( !pipAdapterInfoList )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    status = GetAdaptersInfo( pipAdapterInfoList, &bufflen );
    if ( status != ERROR_SUCCESS )
    {
        ASSERT( status == ERROR_SUCCESS );
        goto Done;
    }
    
    //
    //  Iterate through the adapter list, building a DNS version of
    //  the adapter list.
    //
    
    for ( pipAdapterInfo = pipAdapterInfoList;
          pipAdapterInfo != NULL;
          pipAdapterInfo = pipAdapterInfo->Next )
    {
        DWORD               i;
        PSTR                pszdnsServerList;
        PSTR                psztemp;
        PSTR                psztoken;
        int                 len;
        
        CHECK_AUTOCONFIG_TIME_OUT();
    
        DNS_DEBUG( INIT, ( "%s: found %s\n", fn, pipAdapterInfo->AdapterName ));
        
        //
        //  Allocate a new list element.
        //
        
        pnewAdapter = ALLOC_TAGHEAP_ZERO(
                            sizeof( ADAPTER_INFO ),
                            MEMTAG_STUFF );
        if ( !pnewAdapter )
        {
            status = DNS_ERROR_NO_MEMORY;
            break;
        }
        
        //
        //  Fill out parameters of list element, starting with adapter name.
        //
        
        RtlCopyMemory(
            &pnewAdapter->IpHlpAdapterInfo,
            pipAdapterInfo,
            sizeof( pnewAdapter->IpHlpAdapterInfo ) );
        pnewAdapter->IpHlpAdapterInfo.Next = NULL;

        pnewAdapter->pszAdapterName = Dns_StringCopyAllocate_A(
                                            pipAdapterInfo->AdapterName,
                                            0 );
        if ( !pnewAdapter->pszAdapterName )
        {
            status = DNS_ERROR_NO_MEMORY;
            break;
        }

        pnewAdapter->pwszAdapterName = Dns_StringCopyAllocate(
                                            pnewAdapter->pszAdapterName,
                                            0,                  //  length
                                            DnsCharSetUtf8,
                                            DnsCharSetUnicode );
        if ( !pnewAdapter->pwszAdapterName )
        {
            status = DNS_ERROR_NO_MEMORY;
            break;
        }
        
        #define DNS_INTERFACE_REGKEY_BASE       \
            "SYSTEM\\CurrentControlSet\\Services\\Tcpip\\Parameters\\Interfaces\\"
        #define DNS_INTERFACE_REGKEY_STATIC     "NameServer"
        #define DNS_INTERFACE_REGKEY_DHCP       "DhcpNameServer"

        len = strlen( DNS_INTERFACE_REGKEY_BASE ) +
              strlen( pnewAdapter->pszAdapterName ) + 20;
        pnewAdapter->pszInterfaceRegKey = ALLOC_TAGHEAP( len, MEMTAG_STUFF );
        if ( !pnewAdapter->pszInterfaceRegKey )
        {
            status = DNS_ERROR_NO_MEMORY;
            break;
        }

        status = StringCchCopyA(
                    pnewAdapter->pszInterfaceRegKey,
                    len,
                    DNS_INTERFACE_REGKEY_BASE );
        if ( FAILED( status ) )
        {
            break;
        }

        status = StringCchCatA(
                    pnewAdapter->pszInterfaceRegKey,
                    len,
                    pnewAdapter->pszAdapterName );
        if ( FAILED( status ) )
        {
            break;
        }

        //
        //  Open a registry handle to the interface.
        //
        
        status = RegOpenKeyExA( 
                        HKEY_LOCAL_MACHINE,
                        pnewAdapter->pszInterfaceRegKey,
                        0,                                      //  reserved
                        KEY_READ | KEY_WRITE,
                        &pnewAdapter->hkeyRegInterface );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( INIT, (
                "%s: RegOpen failed on %s\n", fn,
                pnewAdapter->pszInterfaceRegKey ) );
            break;
        }
        
        //
        //  Read static and DHCP DNS server values from the registry.
        //
        
        status = allocateRegistryStringValue(
                        pnewAdapter->hkeyRegInterface,
                        DNS_INTERFACE_REGKEY_STATIC,
                        &pnewAdapter->pszStaticDnsRegValue,
                        pnewAdapter->szStaticRegAddressDelimiter );
        if ( status != ERROR_SUCCESS )
        {
            break;
        }

        status = allocateRegistryStringValue(
                        pnewAdapter->hkeyRegInterface,
                        DNS_INTERFACE_REGKEY_DHCP,
                        &pnewAdapter->pszDhcpDnsRegValue,
                        pnewAdapter->szDhcpRegAddressDelimiter );
        if ( status != ERROR_SUCCESS )
        {
            break;
        }
        
        //
        //  Convert appropriate registry IP list string to IP array. If
        //  there is a static server list use it, else use the DHCP list.
        //  Estimate the required size of the server list from the length
        //  of the string.
        //
        
        if ( pnewAdapter->pszStaticDnsRegValue &&
                *pnewAdapter->pszStaticDnsRegValue )
        {
            pnewAdapter->fUsingStaticDnsServerList = TRUE;
            pszdnsServerList = pnewAdapter->pszStaticDnsRegValue;
        }
        else
        {
            pnewAdapter->fUsingStaticDnsServerList = FALSE;
            pszdnsServerList = pnewAdapter->pszDhcpDnsRegValue;
        }

        #define DNS_MIN_IP4_STRING_LEN      8       //  " 1.1.1.1"

        i = pszdnsServerList
            ? strlen( pszdnsServerList ) / DNS_MIN_IP4_STRING_LEN + 3
            : 1;

        pnewAdapter->pip4DnsServerList = 
            ALLOC_TAGHEAP_ZERO(
                sizeof( IP4_ARRAY ) + sizeof( IP4_ADDRESS ) * i,
                MEMTAG_STUFF );
        if ( !pnewAdapter->pip4DnsServerList )
        {
            status = DNS_ERROR_NO_MEMORY;
            break;
        }

        psztemp = Dns_StringCopyAllocate_A( pszdnsServerList, 0 );
        if ( !psztemp )
        {
            status = DNS_ERROR_NO_MEMORY;
            break;
        }
        
        #define DNS_SERVER_LIST_DELIMITERS      " ,\t;"
        
        for ( psztoken = strtok( psztemp, DNS_SERVER_LIST_DELIMITERS );
              psztoken;
              psztoken = strtok( NULL, DNS_SERVER_LIST_DELIMITERS ) )
        {
            pnewAdapter->pip4DnsServerList->AddrArray[
                pnewAdapter->pip4DnsServerList->AddrCount++ ] =
                inet_addr( psztoken );
        }

        FREE_HEAP( psztemp );
        
        #if DBG
        //  Log DNS server list for this adapter
        if ( pnewAdapter->pip4DnsServerList )
        {
            DWORD       iaddr;
            
            for ( iaddr = 0;
                  iaddr < pnewAdapter->pip4DnsServerList->AddrCount;
                  ++iaddr )
            {
                DNS_DEBUG( INIT, (
                    "%s: DNS server %s\n", fn,
                    IP_STRING( pnewAdapter->pip4DnsServerList->AddrArray[ iaddr ] ) ) );
            }
        }
        #endif
                
        //
        //  Add new list element to the list.
        //

        if ( pprevAdapter )
        {
            pprevAdapter->pNext = pnewAdapter;
        }
        else
        {
            *ppAdapterInfoListHead = pnewAdapter;
        }
        pprevAdapter = pnewAdapter;
        pnewAdapter = NULL;
    }
    
    //
    //  Cleanup up leftover adapter element on failure.
    //
    
    if ( pnewAdapter )
    {
        freeAdapterList( pnewAdapter );
    }
    
    Done:
    
    //
    //  Cleanup and return.
    //

    FREE_HEAP( pipAdapterInfoList );

    if ( status != ERROR_SUCCESS && ppAdapterInfoListHead )
    {
        freeAdapterList( *ppAdapterInfoListHead );
        *ppAdapterInfoListHead = NULL;
    }

    return status;    
}   //  allocateAdapterList



int
removeDnsServerFromAdapterList(
    IN      PADAPTER_INFO       pAdapterInfoListHead,
    IN      IP4_ADDRESS         ip4
    )
/*++

Routine Description:

    Replace the specified IP with INADDR_ANY in all DNS server
    lists for all adapters in the specified adapter list.

Arguments:

    pAdapterInfoListHead -- list of adapters
    
    ip4 -- DNS server to remove from all adapters

Return Value:

    Count of all DNS server addresses found in the list
    excluding addresses already set to INADDR_ANY.
    
--*/
{
    PADAPTER_INFO       padapter;
    int                 dnsServerCount = 0;

    for ( padapter = pAdapterInfoListHead;
          padapter != NULL;
          padapter = padapter->pNext )
    {
        DWORD       idx;
        
        for ( idx = 0;
              idx < padapter->pip4DnsServerList->AddrCount;
              ++idx )
        {
            if ( padapter->pip4DnsServerList->AddrArray[ idx ] == ip4 )
            {
                padapter->pip4DnsServerList->AddrArray[ idx ] = INADDR_ANY;
            }
            else
            {
                ++dnsServerCount;
            }
        }
    }
    return dnsServerCount;
}   //  removeDnsServerFromAdapterList



void
freeRecordSetArray(
    IN      PDNS_RECORD *       pRecordSetArray
    )
/*++

Routine Description:

    This function frees each query result in the NULL-terminated
    array then frees the array itself.

Arguments:

    pRecordSetArray -- ptr to array of record sets to free

Return Value:

    Status code.
    
--*/
{
    int         i;
    
    if ( pRecordSetArray )
    {
        for ( i = 0; pRecordSetArray[ i ] != NULL; ++i )
        {
            DnsRecordListFree( pRecordSetArray[ i ], 0 );
        }
        FREE_HEAP( pRecordSetArray );
    }
}



DNS_STATUS
queryForRootServers(
    IN      PADAPTER_INFO       pAdapterInfoListHead,
    OUT     PDNS_RECORD **      ppRecordSetArray
    )
/*++

Routine Description:

    Query each DNS server on each adapter for root NS. Be careful not
    to send query any DNS server more than once in case there are
    duplicates.

Arguments:

    pAdapterInfoListHead -- list of adapters
    
    ppRecordSetArray -- set to a pointer to a NULL-terminated array of 
        record sets returned by DnsQuery. Each array element must be 
        freed with DnsRecordListFree, and the array itself must be
        freed with FREE_HEAP.

Return Value:

    Status code.
    
--*/
{
    DBG_FN( "QueryForRootNS" )
    
    DNS_STATUS          status = ERROR_SUCCESS;
    PADAPTER_INFO       padapter;
    PDNS_RECORD *       precordArray = NULL;
    int                 recordArrayIdx = 0;
    DWORD               dnsServerCount;
    DWORD               loopbackIP4 = inet_addr( "127.0.0.1" );

    //
    //  Allocate an array for all the record set pointers.
    //

    dnsServerCount = removeDnsServerFromAdapterList(
                            pAdapterInfoListHead,
                            INADDR_ANY );
    if ( dnsServerCount == 0 )
    {
        ASSERT( dnsServerCount != 0 );
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }

    precordArray = ALLOC_TAGHEAP_ZERO(
                            ( dnsServerCount + 1 ) * sizeof( PDNS_RECORD ),
                            MEMTAG_STUFF );
    
    //
    //  Iterate adapters.
    //
    
    for ( padapter = pAdapterInfoListHead;
          status == ERROR_SUCCESS && padapter != NULL;
          padapter = padapter->pNext )
    {
        DWORD       idx;
        
        //
        //  Iterate DNS servers for this adapter.
        //

        for ( idx = 0;
              idx < padapter->pip4DnsServerList->AddrCount;
              ++idx )
        {
            IP4_ADDRESS     ip4 = padapter->pip4DnsServerList->AddrArray[ idx ];
            IP4_ARRAY       ip4Array;
            PDNS_RECORD     precordSet = NULL;
            
            CHECK_AUTOCONFIG_TIME_OUT();

            //
            //  Ignore addresses already marked as sent to.
            //
            
            if ( ip4 == INADDR_ANY )
            {
                continue;
            }
            
            //
            //  Mark this address at being sent to for all adapters.
            //
            
            removeDnsServerFromAdapterList( pAdapterInfoListHead, ip4 );
            
            //
            //  Ignore loopback and any addresses of the local machine.
            //
            
            if ( ip4 == loopbackIP4 ||
                 DnsAddrArray_ContainsIp4(
                        g_ServerIp4Addrs,
                        ip4 ) )
            {
                removeDnsServerFromAdapterList( pAdapterInfoListHead, ip4 );
                continue;
            }
            
            //
            //  Query this DNS server address for root NS.
            //
            
            DNS_DEBUG( INIT, ( "%s: querying %s\n", fn, IP_STRING( ip4 ) ));

            ip4Array.AddrCount = 1;
            ip4Array.AddrArray[ 0 ] = ip4;
            
            status = DnsQuery_UTF8(
                        DNS_ROOT_NAME,
                        DNS_TYPE_NS,
                        DNS_QUERY_BYPASS_CACHE,
                        &ip4Array,
                        &precordSet,
                        NULL );                     //  reserved

            DNS_DEBUG( INIT, (
                "%s: query to %s returned %d\n", fn,
                IP_STRING( ip4 ),
                status ));

            if ( status != ERROR_SUCCESS )
            {
                status = ERROR_SUCCESS;
                continue;
            }
            
            ASSERT( precordSet );

            #if DBG
            {
                PDNS_RECORD     p;
                
                for ( p = precordSet; p; p = p->pNext )
                {
                    switch ( p->wType )
                    {
                        case DNS_TYPE_A:
                            DNS_DEBUG( INIT, (
                                "%s: RR type A for name %s IP %s\n", fn,
                                p->pName,
                                IP_STRING( p->Data.A.IpAddress ) ));
                            break;
                        case DNS_TYPE_NS:
                            DNS_DEBUG( INIT, (
                                "%s: RR type NS for name %s NS %s\n", fn,
                                p->pName,
                                p->Data.PTR.pNameHost ));
                            break;
                        default:
                            DNS_DEBUG( INIT, (
                                "%s: RR type %d for name %s\n", fn,
                                p->wType,
                                p->pName ));
                            break;
                    }
                }
            }
            #endif

            //
            //  Save this query result in the record set array.
            //
            
            if ( precordSet )
            {
                precordArray[ recordArrayIdx++ ] = precordSet;
            }
        }
    }

    Done:
    
    //
    //  If we got no valid responses, fail.
    //
    
    if ( recordArrayIdx == 0 )
    {
        DNS_DEBUG( INIT, (
            "%s: got no valid responses - error %d\n", fn, status ));
        status = DNS_ERROR_CANNOT_FIND_ROOT_HINTS;
    }
    
    if ( status != ERROR_SUCCESS )
    {
        freeRecordSetArray( precordArray );
        precordArray = NULL;
    }
    *ppRecordSetArray = precordArray;
        
    DNS_DEBUG( INIT, ( "%s: returning %d\n", fn, status ));

    return status;
}   //  queryForRootServers



int
selectRootHints(
    IN      PDNS_RECORD *       pRecordSetArray
    )
/*++

Routine Description:

    Examine the root hint record set array and return the index
    with the best root hints. The best set of root hints is the
    largest single set. However, if there are any sets of root
    hints that do not share at least one NS with all other sets
    of root hints, return failure.

Arguments:

    pRecordSetArray -- NULL-terminated array of record sets, each
        record set is the response to a root hint query

Return Value:

    -1 or index of best set of root hints in array
    
--*/
{
    DBG_FN( "SelectRootHints" )

    BOOL    recordSetIsConsistent = FALSE;
    int     rootHintIdx;
    int     largestRootHintCount = 0;
    int     largestRootHintIdx = 0;
    LONG    infiniteIterationProtection = 100000000;
    
    //
    //  Iterate through all root hint record sets.
    //
    
    for ( rootHintIdx = 0;
          pRecordSetArray[ rootHintIdx ] != NULL;
          ++rootHintIdx )
    {
        PDNS_RECORD     prec;
        int             nsCount = 0;

        //
        //  Iterate through all NS records in the record set. When 
        //  an NS record is found that is present in all other record
        //  sets, this means that the root hints are consistent. When one
        //  NS record is found to be consistent, we can assume that
        //  everything is golden and select the set of root hints that
        //  is the largest as the best set. This is slightly kludgey
        //  and ignores set of root hints that might be possible
        //  be associated: A,B + C,D + B,C but that kind of configuration
        //  is pretty wacky. Even if this function handled more complex
        //  consistent root hints it isn't clear what set of root hints
        //  would be "best".
        //
        
        for ( prec = pRecordSetArray[ rootHintIdx ];
              prec != NULL;
              prec = prec->pNext )
        {
            int     innerRootHintIdx;
            BOOL    foundNsInAllRecordSets = TRUE;
            
            if ( prec->wType != DNS_TYPE_NS )
            {
                continue;
            }
            
            ++nsCount;
            
            //
            //  If we've already found an NS that is common to all
            //  record sets we don't need to test for further consistency.
            //  

            if ( recordSetIsConsistent )
            {
                continue;
            }
            
            //
            //  Search for this NS in all other NS lists.
            //

            for ( innerRootHintIdx = 0;
                  pRecordSetArray[ innerRootHintIdx ] != NULL;
                  ++innerRootHintIdx )
            {
                PDNS_RECORD     precInner;
                BOOL            foundNsInThisRecordSet = FALSE;

                if ( innerRootHintIdx == rootHintIdx )
                {
                    continue;
                }
                
                for ( precInner = pRecordSetArray[ innerRootHintIdx ];
                      !foundNsInThisRecordSet && precInner != NULL;
                      precInner = precInner->pNext )
                {
                    if ( --infiniteIterationProtection <= 0 )
                    {
                        DNS_DEBUG( INIT, ( "%s: detected infinite iteration of root hints!\n", fn ));
                        recordSetIsConsistent = FALSE;
                        ASSERT( infiniteIterationProtection > 0 );
                        goto Done;
                    }

                    if ( precInner->wType == DNS_TYPE_NS &&
                         _stricmp( ( PCHAR ) precInner->Data.NS.pNameHost,
                                   ( PCHAR ) prec->Data.NS.pNameHost ) == 0 )
                    {
                        foundNsInThisRecordSet = TRUE;
                    }
                }
                
                if ( !foundNsInThisRecordSet )
                {
                    foundNsInAllRecordSets = FALSE;
                }
            }
            
            //
            //  As soon as we find one NS in all record sets we know the
            //  root hint sets are consistent, but we'll continue the outer
            //  loops anyways because we still need to count NS records in
            //  each record set to find the largest.
            //
            
            if ( foundNsInAllRecordSets )
            {
                recordSetIsConsistent = TRUE;
            }
        }

        //
        //  Keep track of largest set of root hints.
        //
                
        if ( nsCount > largestRootHintCount )
        {
            largestRootHintCount = nsCount;
            largestRootHintIdx = rootHintIdx;
        }
    }
    
    Done:

    if ( recordSetIsConsistent )
    {    
        DNS_DEBUG( INIT, (
            "%s: found consistent root hints, best set is %d\n", fn,
            largestRootHintIdx ));
        return largestRootHintIdx;
    }
    DNS_DEBUG( INIT, ( "%s: found inconsistent root hints%d\n", fn ));
    return -1;
}   //  selectRootHints



DNS_STATUS
createNodeInZone(
    IN      PZONE_INFO          pZone,
    IN      PCHAR               pszNodeName,
    OUT     PDB_NODE *          ppNode
    )
/*++

Routine Description:

    The function creates a node in the zone for the specified name.

Arguments:

    pZone -- zone where node is to be added
    
    pszNodeName -- name of node to be added
    
    ppNode -- output pointer for new node

Return Value:

    Error code.
    
--*/
{
    DBG_FN( "CreateRootHintNode" )
    
    DNS_STATUS      status = ERROR_SUCCESS;

    ASSERT( ppNode );
    
    *ppNode = Lookup_ZoneNodeFromDotted(
                    pZone,
                    pszNodeName,
                    0,                      //  name length
                    LOOKUP_NAME_FQDN,
                    NULL,                   //  closest node ptr
                    &status );
    if ( !*ppNode || status != ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, (
            "%s: error %d creating node for NS %s\n", fn,
            status,
            pszNodeName ));
        ASSERT( *ppNode );
        if ( status == ERROR_SUCCESS )
        {
            status = ERROR_INVALID_DATA;
        }
        *ppNode = NULL;
    }
    return status;
}   //  createNodeInZone



DNS_STATUS
buildForwarderArray(
    IN      PADAPTER_INFO       pAdapterInfoListHead,
    OUT     PDNS_ADDR_ARRAY *   ppForwarderArray
    )
/*++

Routine Description:

    Allocates and builds a forwarder list from all available
    adapter DNS server lists, making sure that each DNS server
    address is added exactly once.

Arguments:

    pAdapterInfoListHead -- adapter info list

    ppForwarderArray -- set to pointer to newly allocated
        forwarder IP array which must be later passed to FREE_HEAP

Return Value:

    Error code.
    
--*/
{
    #define DNS_AUTOCONFIG_MAX_FORWARDERS   30

    DBG_FN( "BuildForwarderList" )
    
    DNS_STATUS          status = ERROR_SUCCESS;
    PDNS_ADDR_ARRAY     pforwarderArray = NULL;
    PADAPTER_INFO       padapterInfo;

    ASSERT( ppForwarderArray );
    *ppForwarderArray = NULL;
    
    //
    //  Allocate an array of IP addresses for forwarders.
    //
    
    pforwarderArray = DnsAddrArray_Create( DNS_AUTOCONFIG_MAX_FORWARDERS );
    if ( !pforwarderArray )
    {
        status = DNS_ERROR_NO_MEMORY;
        goto Done;
    }

    //
    //  Iterate adapters.
    //
    
    for ( padapterInfo = pAdapterInfoListHead;
          padapterInfo != NULL;
          padapterInfo  = padapterInfo->pNext )
    {
        //
        //  Iterate IPs in this adapters DNS server list.
        //
        
        DWORD       i;
        DWORD       loopbackIP4 = inet_addr( "127.0.0.1" );
        
        for ( i = 0; i < padapterInfo->pip4DnsServerList->AddrCount; ++i )
        {
            DWORD   j;

            //
            //  Skip invalid IPs and IPs of the local machine.
            //
            
            if ( padapterInfo->pip4DnsServerList->AddrArray[ i ] == 0 ||
                 padapterInfo->pip4DnsServerList->AddrArray[ i ] == loopbackIP4 ||
                 DnsAddrArray_ContainsIp4(
                        g_ServerIp4Addrs,
                        padapterInfo->pip4DnsServerList->AddrArray[ i ] ) )
            {
                continue;
            }
            
            //
            //  Add the IP to the forwarder array.
            //
            
            DnsAddrArray_AddIp4(
                pforwarderArray,
                padapterInfo->pip4DnsServerList->AddrArray[ i ],
                0 );        //  match flag
        }
    }
        
    Done:
    
    if ( status != ERROR_SUCCESS )
    {
        DnsAddrArray_Free( pforwarderArray );
        pforwarderArray = NULL;
    }

    DNS_DEBUG( INIT, ( "%s: returning %d - found %d forwarders\n", fn,
        status,
        pforwarderArray ? pforwarderArray->AddrCount : 0 ));

    *ppForwarderArray = pforwarderArray;

    return status;
}   //  buildForwarderArray



DNS_STATUS
buildServerRootHints(
    IN      PDNS_RECORD         pRecordSet
    )
/*++

Routine Description:

    The function takes a record set from DNSQuery and uses it to
    build a set of DNS server root hints. If the root hints are
    built successfully, the DNS server's root hints are replaced
    with the new set.
    
    If the record set does not contain additional A records for at
    least one NS record, this function will return failure.
    
    DEVNOTE: This function could be enhanced to query for missing A 
    records but at this time I don't think it's worth the time it 
    would take to implement. 

Arguments:

    pRecordSet -- list of DNSQuery result records, should be a
        list of NS records and additional A records

Return Value:

    Error code.
    
--*/
{
    DBG_FN( "BuildRootHints" )
    
    DNS_STATUS      status = ERROR_SUCCESS;
    PZONE_INFO      pzone = g_pRootHintsZone;
    BOOL            zoneLocked = FALSE;
    PDB_NODE        ptree = NULL;
    PDNS_RECORD     precNS;
    int             nsAddedCount = 0;

    if ( !pzone )
    {
        ASSERT( pzone );
        status = ERROR_INVALID_DATA;
        goto Done;
    }

    //
    //  Lock the zone for update and clean out existing root hints.
    //
    
    if ( !Zone_LockForAdminUpdate( pzone ) )
    {
        ASSERT( !"zone locked" );
        status = DNS_ERROR_ZONE_LOCKED;
        goto Done;
    }
    zoneLocked = TRUE;
    
    Zone_DumpData( pzone );

    //
    //  Add root hints to zone.
    //
    
    for ( precNS = pRecordSet; precNS != NULL; precNS = precNS->pNext )
    {
        PDNS_RECORD     precA;
        PDB_NODE        pnode;
        PDB_RECORD      prr;

        //
        //  Skip all non-NS records and records that look invalid.
        //
                
        if ( precNS->wType != DNS_TYPE_NS )
        {
            continue;
        }
        if ( !precNS->pName )
        {
            ASSERT( precNS->pName );
            continue;
        }
        if ( !precNS->Data.NS.pNameHost )
        {
            ASSERT( precNS->Data.NS.pNameHost );
            continue;
        }
        if ( _stricmp( ( PCHAR ) precNS->pName, DNS_ROOT_NAME  ) != 0 )
        {
            ASSERT( _stricmp( ( PCHAR ) precNS->pName, DNS_ROOT_NAME  ) == 0 );
            continue;
        }
        
        //
        //  Find the A record for this NS record. DEVNOTE: this
        //  will one day have to be expanded for IPv6.
        //
        
        for ( precA = pRecordSet; precA != NULL; precA = precA->pNext )
        {
            if ( precA->wType != DNS_TYPE_A || !precA->pName )
            {
                ASSERT( precA->pName );
                continue;
            }
            if ( _stricmp( ( PCHAR ) precA->pName,
                           ( PCHAR ) precNS->Data.NS.pNameHost ) == 0 )
            {
                break;
            }
        }
        if ( !precA )
        {
            DNS_DEBUG( INIT, (
                "%s: missing A for NS %s\n", fn,
                precNS->Data.NS.pNameHost ));
            ASSERT( precA );    //  Interesting but not critical.
            continue;
        }

        DNS_DEBUG( INIT, (
            "%s: adding NS %s with A %s\n", fn,
            precNS->Data.NS.pNameHost,
            IP_STRING( precA->Data.A.IpAddress ) ));
        
        //
        //  Add NS node to the zone.
        //

        status = createNodeInZone(
                    pzone,
                    DNS_ROOT_NAME,
                    &pnode );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( INIT, (
                "%s: error %d creating NS node for %s\n", fn,
                status,
                DNS_ROOT_NAME ));
            ASSERT( status == ERROR_SUCCESS );
            goto Done;
        }
        
        //
        //  Create NS RR and add it to the NS node.
        //

        prr = RR_CreatePtr(
                    NULL,                           //  dbase name
                    ( PCHAR ) precNS->Data.NS.pNameHost,
                    DNS_TYPE_NS,
                    DNS_ROOT_HINT_TTL,
                    MEMTAG_RECORD_AUTO );
        if ( !prr )
        {
            DNS_DEBUG( INIT, (
                "%s: unable to create NS RR for %s\n", fn,
                precNS->Data.NS.pNameHost ));
            ASSERT( prr );
            status = DNS_ERROR_NO_MEMORY;
            continue;
        }

        status = RR_AddToNode( pzone, pnode, prr );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( INIT, (
                "%s: unable to add NS RR to node for %s\n", fn,
                precNS->Data.NS.pNameHost ));
            ASSERT( status == ERROR_SUCCESS );
            continue;
        }
        
        //
        //  Add node for the A record to the zone.
        //

        status = createNodeInZone(
                    pzone,
                    ( PCHAR ) precA->pName,
                    &pnode );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( INIT, (
                "%s: error %d creating NS node for %s\n", fn,
                status,
                precA->pName ));
            ASSERT( status == ERROR_SUCCESS );
            goto Done;
        }
        
        //
        //  Create A RR and add it to the A node.
        //

        prr = RR_CreateARecord(
                    precA->Data.A.IpAddress,
                    DNS_ROOT_HINT_TTL,
                    MEMTAG_RECORD_AUTO );
        if ( !prr )
        {
            DNS_DEBUG( INIT, (
                "%s: unable to create A RR for %s\n", fn,
                precA->pName ));
            ASSERT( prr );
            status = DNS_ERROR_NO_MEMORY;
            continue;
        }

        status = RR_AddToNode( pzone, pnode, prr );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( INIT, (
                "%s: unable to add A RR to node for %s\n", fn,
                precA->pName ));
            ASSERT( status == ERROR_SUCCESS );
            continue;
        }
        
        //
        //  The NS and matching A record have been added to the root hints!
        //
        
        ++nsAddedCount;
        DNS_DEBUG( INIT, (
            "%s: added NS %s with A %s\n", fn,
            precNS->Data.NS.pNameHost,
            IP_STRING( precA->Data.A.IpAddress ) ));
    }

    Done:

    //
    //  Fail if no root hints were successfully added.
    //
    
    if ( nsAddedCount == 0 )
    {
        DNS_DEBUG( INIT, ( "%s: added no root hints!\n", fn ));
        ASSERT( nsAddedCount );
        status = ERROR_INVALID_DATA;
    }

    //
    //  On failure reload root hints. On success, write back.
    //
        
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, ( "%s: forcing root hint reload\n", fn ));
        Zone_DumpData( pzone );
        Zone_LoadRootHints();
    }
    else
    {
        DNS_DEBUG( INIT, ( "%s: forcing root hint writeback\n", fn ));
        Zone_WriteBackRootHints( TRUE );
    }
    
    if ( zoneLocked )
    {
        Zone_UnlockAfterAdminUpdate( pzone );
    }

    DNS_DEBUG( INIT, (
        "%s: returning %d - added %d root hints\n", fn,
        status,
        nsAddedCount ));

    return status;
}   //  buildServerRootHints



DNS_STATUS
selfPointDnsClient(
    IN      PADAPTER_INFO       pAdapterInfoListHead
    )
/*++

Routine Description:

    This function addes 127.0.0.1 to the start of the DNS
    server list for each adapter. If the adapter is currently
    using DNS server supplied by DHCP this will change the
    adapter to use a static DNS server list.

Arguments:

    pAdapterInfoListHead -- adapter info list

Return Value:

    Error code.
    
--*/
{
    DBG_FN( "SelfPointClient" )
    
    DNS_STATUS          status = ERROR_SUCCESS;
    PADAPTER_INFO       padapterInfo;

    ASSERT( pAdapterInfoListHead );
    
    //
    //  Iterate adapters.
    //
    
    for ( padapterInfo = pAdapterInfoListHead;
          padapterInfo != NULL;
          padapterInfo  = padapterInfo->pNext )
    {
        #define DNS_LOOPBACK    "127.0.0.1"

        PSTR        pszcurrentDnsServerList;
        PSTR        pszregDelimiter;
        PSTR        psznewString;
        BOOL        fconvertSpacesToCommas = FALSE;
        int         len;
        
        pszcurrentDnsServerList = padapterInfo->fUsingStaticDnsServerList
            ? padapterInfo->pszStaticDnsRegValue
            : padapterInfo->pszDhcpDnsRegValue;

        //
        //  If we are not using a static DNS server list currently,
        //  always use comma as the delimiter. I found through
        //  experimentation with .NET build 3590 that the
        //  DhcpNameServer key should use space as delimiter but the
        //  NameServer key should use comma as delimiter.
        //

        pszregDelimiter = ",";  //  padapterInfo->szDhcpRegAddressDelimiter;
        fconvertSpacesToCommas = TRUE;

        //
        //  If the current DNS server list is already self-pointing, skip
        //  this adapater.
        //
        
        if ( pszcurrentDnsServerList &&
             strstr( pszcurrentDnsServerList, DNS_LOOPBACK ) != NULL )
        {
            continue;
        }
        
        //
        //  Add loopback address to start of current DNS server list.
        //
        
        len = ( pszcurrentDnsServerList
                    ? strlen( pszcurrentDnsServerList )
                    : 0 ) +
              strlen( DNS_LOOPBACK ) + 5;
        psznewString = ALLOC_TAGHEAP( len, MEMTAG_STUFF );
        if ( !psznewString )
        {
            status = DNS_ERROR_NO_MEMORY;
            goto Done;
        }
        
        status = StringCchCopyA( psznewString, len, DNS_LOOPBACK );
        if ( FAILED( status ) )
        {
            goto Done;
        }

        if ( pszcurrentDnsServerList && *pszcurrentDnsServerList )
        {
            status = StringCchCatA( psznewString, len, pszregDelimiter );
            if ( FAILED( status ) )
            {
                goto Done;
            }

            status = StringCchCatA( psznewString, len, pszcurrentDnsServerList );
            if ( FAILED( status ) )
            {
                goto Done;
            }
        }
        
        //
        //  If necessary, convert space delimiters to commas but
        //  for multiple spaces only convert the first to comma.
        //
        
        if ( fconvertSpacesToCommas )
        {
            PSTR        psz;
            BOOL        lastWasComma = FALSE;
            
            for ( psz = psznewString; *psz; ++psz )
            {
                if ( *psz == ' ' && !lastWasComma )
                {
                    *psz = ',';
                }
                if ( *psz == ',' )
                {
                    lastWasComma = TRUE;
                }
                else if ( *psz != ' ' )
                {
                    lastWasComma = *psz == ',';
                }
            }
        }
        
        //
        //  Write the new string into the registry as the static DNS
        //  server list.
        //
        
        status = RegSetValueExA(
                    padapterInfo->hkeyRegInterface,
                    DNS_INTERFACE_REGKEY_STATIC,
                    0,                                  //  reserved
                    REG_SZ,
                    psznewString,
                    strlen( psznewString ) + 1 );

        FREE_HEAP( psznewString );
        
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( INIT, (
                "%s: error %d writing new DNS server list to registry \n", fn,
                status ));
            goto Done;
        }
    }
    
    Done:
    
    DNS_DEBUG( INIT, (
        "%s: returning %d\n", fn, status ));

    return status;
}   //  selfPointDnsClient



PWSTR
allocateMessageString(
    IN      DWORD       dwMessageId
    )
/*++

Routine Description:

    Allocates a string out of the message table with no
    replacement parameters. This function also NULLs out
    the trailing newline characters.

Arguments:

    dwMessageId -- message ID in message table

Return Value:

    Error code.
    
--*/
{
    PWSTR       pwszmsg = NULL;
    DWORD       err;
    
    err = FormatMessageW(
            FORMAT_MESSAGE_FROM_HMODULE |
                FORMAT_MESSAGE_ALLOCATE_BUFFER |
                FORMAT_MESSAGE_ARGUMENT_ARRAY,
            NULL,                                   //  module is this exe
            dwMessageId,
            0,                                      //  default language
            ( PWSTR ) &pwszmsg,
            0,                                      //  buff length
            NULL );                                 //  message inserts

    err = err == 0 ? GetLastError() : ERROR_SUCCESS;
    
    ASSERT( err == ERROR_SUCCESS );
    ASSERT( pwszmsg != NULL );

    //
    //  Remove trailing newline characters.
    //
        
    if ( pwszmsg )
    {
        int     len = wcslen( pwszmsg );
        
        if ( len > 1 )
        {
            if ( pwszmsg[ len - 1 ] == '\r' || pwszmsg[ len - 1 ] == '\n' )
            {
                pwszmsg[ len - 1 ] = '\0';
            }
            if ( pwszmsg[ len - 2 ] == '\r' || pwszmsg[ len - 2 ] == '\n' )
            {
                pwszmsg[ len - 2 ] = '\0';
            }
        }
    }

    return pwszmsg;
}   //  allocateMessageString


//
//  External functions
//



DNS_STATUS
Dnssrv_AutoConfigure(
    IN      DWORD       dwFlags
    )
/*++

Routine Description:

    Free module resources.

Arguments:

    dwFlags -- controls what is autoconfigured. Use
    DNS_RPC_AUTOCONFIG_XXX constants from dnsrpc.h.

Return Value:

    Error code.

--*/
{
    DBG_FN( "DnsAutoConfigure" )

    static      LONG    autoConfigLock = 0;
    
    DNS_STATUS          status = ERROR_SUCCESS;
    PADAPTER_INFO       padapters = NULL;
    PDNS_RECORD *       precordSetArray = NULL;
    int                 bestRootHintIdx = -1;
    PDNS_ADDR_ARRAY     pforwarderArray = NULL;
    PWSTR               pwszmessages[ 3 ] = { 0 };
    int                 imessageIdx = 0;

    DNS_DEBUG( INIT, ( "%s: auto-configuring with flags 0x%08X\n", fn, dwFlags ));
    
    if ( InterlockedIncrement( &autoConfigLock ) != 1 )
    {
        DNS_DEBUG( INIT, ( "%s: already auto-configuring!\n", fn ));
        status = DNS_ERROR_RCODE_REFUSED;
        goto Done;
    }
    
    SET_AUTOCONFIG_END_TIME();

    //
    //  Retrieve DNS server lists and other info for all adapters.
    //
    
    status = allocateAdapterList( &padapters );
    if ( status != ERROR_SUCCESS || !padapters )
    {
        DNS_DEBUG( INIT, (
            "%s: error %d retrieving adapter info\n", fn, status ));
        status = ERROR_INVALID_PARAMETER;
        goto Done;
    }
    
    //
    //  Build the forwarder list. This will be used later to set the DNS
    //  server to forward to all DNS servers currently in the DNS server
    //  list for each adapter.
    //
    
    status = buildForwarderArray( padapters, &pforwarderArray );
    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, (
            "%s: error %d building forwarder array\n", fn, status ));
        goto Done;
    }
    
    if ( dwFlags & DNS_RPC_AUTOCONFIG_ROOTHINTS )
    {
        //
        //  Query for root servers.
        //
        
        status = queryForRootServers( padapters, &precordSetArray );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( INIT, (
                "%s: error %d querying root servers\n", fn, status ));
            goto Done;
        }

        //
        //  Select the best set of root hints. This function may return
        //  failure if the root hints appear to be disjoint or inconsistent.
        //

        bestRootHintIdx = selectRootHints( precordSetArray );
        if ( bestRootHintIdx < 0 )
        {
            DNS_DEBUG( INIT, (
                "%s: inconsistent root hints!\n", fn ));
            status = DNS_ERROR_INCONSISTENT_ROOT_HINTS;
            goto Done;
        }
        
        //
        //  Take the best set of root hints and turn them into the DNS
        //  servers root hints.
        //
    
        status = buildServerRootHints( precordSetArray[ bestRootHintIdx ] );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( INIT, (
                "%s: error %d building DNS server root hints\n", fn, status ));
            goto Done;
        }

        DNS_DEBUG( INIT, (
            "%s: autoconfigured root hints\n", fn ));

        pwszmessages[ imessageIdx++ ] =
            allocateMessageString( DNSMSG_AUTOCONFIG_ROOTHINTS );
     }
    
    //
    //  Set the DNS server to forward in non-slave mode to the
    //  current DNS client settings. If there are multiple adapters
    //  set the DNS server to forward to all DNS servers on all
    //  adapters (random order is fine).
    //
    
    if ( dwFlags & DNS_RPC_AUTOCONFIG_FORWARDERS )
    {
        status = Config_SetupForwarders(
                    pforwarderArray,
                    DNS_DEFAULT_FORWARD_TIMEOUT,
                    FALSE );                        //  forwarder slave flag
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( INIT, (
                "%s: error %d setting forwarders\n", fn, status ));
            goto Done;
        }

        DNS_DEBUG( INIT, (
            "%s: autoconfigured forwarders\n", fn ));

        pwszmessages[ imessageIdx++ ] =
            allocateMessageString( DNSMSG_AUTOCONFIG_FORWARDERS );
     }

    //
    //  Munge the DNS resolver's settings to that the loopback
    //  address is at the start of each adapter's DNS server list.
    //
    
    if ( dwFlags & DNS_RPC_AUTOCONFIG_SELFPOINTCLIENT )
    {
        status = selfPointDnsClient( padapters );
        if ( status != ERROR_SUCCESS )
        {
            DNS_DEBUG( INIT, (
                "%s: error %d self-pointing DNS client\n", fn, status ));
            goto Done;
        }

        DNS_DEBUG( INIT, (
            "%s: autoconfigured local DNS resolver\n", fn ));

        pwszmessages[ imessageIdx++ ] =
            allocateMessageString( DNSMSG_AUTOCONFIG_RESOLVER );
    }

    //
    //  Perform cleanup
    //

    Done:
    
    freeAdapterList( padapters );
    freeRecordSetArray( precordSetArray );
    DnsAddrArray_Free( pforwarderArray );

    InterlockedDecrement( &autoConfigLock );
    
    DNS_DEBUG( INIT, ( "%s: returning %d\n", fn, status ));
    
    //
    //  Log success or failure event.
    //
    
    if ( status == ERROR_SUCCESS )
    {
        PWSTR   pargs[] =
        {
            pwszmessages[ 0 ] ? pwszmessages[ 0 ] : L"",
            pwszmessages[ 1 ] ? pwszmessages[ 1 ] : L"",
            pwszmessages[ 2 ] ? pwszmessages[ 2 ] : L""
        };

        Ec_LogEvent(
            g_pServerEventControl,
            DNS_EVENT_AUTOCONFIG_SUCCEEDED,
            0,
            sizeof( pargs ) / sizeof( pargs[ 0 ] ),
            pargs,
            EVENTARG_ALL_UNICODE,
            status );
    }
    else    
    {
        Ec_LogEvent(
            g_pServerEventControl,
            DNS_EVENT_AUTOCONFIG_FAILED,
            0,
            0,
            NULL,
            NULL,
            status );
    }

    return status;
}   //  Dnssrv_AutoConfigure


//
//  End autoconfigure.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\bootfile.c ===
/*++

Copyright (c) 1996-1999 Microsoft Corporation

Module Name:

    bootfile.c

Abstract:

    Domain Name System (DNS) Server

    Boot file write back (from registry) routines.

Author:

    Denise Yuxin Miller (denisemi)   December 3, 1996

Revision History:

--*/


#include "dnssrv.h"


//
//  Boot file info saved for post read processing
//

DNS_BOOT_FILE_INFO   BootInfo;

#define DNS_ZONE_TYPE_NAME_PRIMARY      "primary"
#define DNS_ZONE_TYPE_NAME_SECONDARY    "secondary"
#define DNS_ZONE_TYPE_NAME_STUB         "stub"
#define DNS_ZONE_TYPE_NAME_FORWARDER    "forward"
#define DNS_ZONE_TYPE_NAME_CACHE        "cache"


//
//  Private protos for read
//

DNS_STATUS
processBootFileLine(
    IN OUT  PPARSE_INFO  pParseInfo
    );

//
//  Private protos for write
//

LPSTR
createStringFromIpAddressArray(
    IN      PDNS_ADDR_ARRAY     pAddrArray
    );

VOID
removeTrailDotFromString(
    IN OUT  LPSTR           lpzString
    );




//
//  Boot file read routines
//

DNS_STATUS
File_ReadBootFile(
    IN      BOOL    fMustFindBootFile
    )
/*++

Routine Description:

    Read and process boot file.

    Builds list of zone files to process.

Arguments:

    fMustFindBootFile -- flag
        TRUE -- if explicitly configured for boot file
        FALSE -- not explicitly configured for boot file;  attempt boot
            file open, but no errors if fail

Return Value:

    TRUE if successful
    FALSE otherwise

--*/
{
    DNS_STATUS      status;
    PWSTR           pwsbootFile;
    MAPPED_FILE     mfBootFile;
    PARSE_INFO      ParseInfo;
    BOOLEAN         fDummy;

    //
    //  Get boot file name\path
    //      - currently fixed directory and boot file name
    //

    pwsbootFile = DNS_BOOT_FILE_PATH;

    //
    //  open and map boot file
    //

    DNS_DEBUG( INIT, (
        "Reading boot file %S\n",
        pwsbootFile ));

    status = OpenAndMapFileForReadW(
                    pwsbootFile,
                    & mfBootFile,
                    fMustFindBootFile );

    if ( status != ERROR_SUCCESS )
    {
        DNS_DEBUG( INIT, (
            "Could not open boot file: %S\n"
            "\terror = %d\n",
            pwsbootFile,
            status ));

        //
        //  doc mentions "boot.dns" so if we're supposed to use boot file
        //      use boot.dns if found
        //

        if ( !fMustFindBootFile )
        {
            return status;
        }

        status = OpenAndMapFileForReadW(
                        DNS_BOOTDNS_FILE_PATH,
                        & mfBootFile,
                        FALSE );        // don't log event if don't find
        if ( status != ERROR_SUCCESS )
        {
            DNS_LOG_EVENT(
                DNS_EVENT_BOOT_FILE_NOT_FOUND,
                1,
                &pwsbootFile,
                EVENTARG_ALL_UNICODE,
                status );
            return status;
        }
        pwsbootFile = DNS_BOOTDNS_FILE_PATH;
    }

    //  clear boot file post-processing info

    RtlZeroMemory(
        &BootInfo,
        sizeof( DNS_BOOT_FILE_INFO ) );

    //  setup parsing structure

    RtlZeroMemory(
        &ParseInfo,
        sizeof( PARSE_INFO ) );

    ParseInfo.pwsFileName = pwsbootFile;

    File_InitBuffer(
        &ParseInfo.Buffer,
        (PCHAR) mfBootFile.pvFileData,
        mfBootFile.cbFileBytes );

    //
    //  loop until all tokens in file are exhausted
    //

    while ( 1 )
    {
        DNS_DEBUG( INIT2, ( "\nBootLine %d: ", ParseInfo.cLineNumber ));

        //  get next tokenized line

        status = File_GetNextLine( &ParseInfo );
        if ( status != ERROR_SUCCESS )
        {
            if ( status == ERROR_NO_TOKEN )
            {
                break;
            }
            goto Failed;
        }

        //
        //  process boot file line
        //

        status = processBootFileLine( &ParseInfo );
        if ( status != ERROR_SUCCESS )
        {
            goto Failed;
        }

    }   //  loop until file read

    DNS_DEBUG( INIT, (
        "Closing boot file.\n\n" ));

    CloseMappedFile( & mfBootFile );

    //
    //  boot file post processing
    //      - load additional zone info from registry
    //          (but do NOT load other registry zones)
    //      - write boot file info to SrvCfg block and registry
    //

    status = Boot_ProcessRegistryAfterAlternativeLoad(
                TRUE,       //  boot file load
                FALSE );    //  do not load other zones, delete them

    Failed:

    return status;
}



//
//  Boot file line type specific processing functions
//

/*++

Routine Description:

    Process boot file line type line.

Arguments:

    pParseInfo - parsed line structure

Return Value:

    ERROR_SUCCESS if successful.
    Error code on line processing failure.

--*/

DNS_STATUS
processPrimaryLine(
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    PZONE_INFO  pzone;
    DNS_STATUS  status;
    CHAR        szfilename[ MAX_PATH + 1 ];
    CHAR        szzonename[ DNS_MAX_NAME_BUFFER_LENGTH ];
    int         len;

    //
    //  primary <zone name> <zone file>
    //

    if ( Argc != 2 )
    {
        return DNSSRV_ERROR_MISSING_TOKEN;
    }

    //
    //  The zone name may contain octal-escaped UTF-8 characters 
    //  we need to convert the octal escapes back into characters.
    //

    *szzonename = '\0';
    File_CopyFileTextData(
        szzonename,
        sizeof( szzonename ),
        Argv[ 0 ].pchToken,
        Argv[ 0 ].cchLength,
        FALSE );

    //
    //  Copy the boot file name.
    //

    len = min( sizeof( szfilename ) - 1, Argv[ 1 ].cchLength );
    memcpy( szfilename, Argv[ 1 ].pchToken, len );
    szfilename[ len ] = '\0';
        
    //
    //  create primary zone
    //

    status = Zone_Create(
                &pzone,
                DNS_ZONE_TYPE_PRIMARY,
                szzonename,
                0,
                0,                      //  flags
                NULL,                   //  no masters
                FALSE,                  //  use file
                NULL,                   //  naming context
                szfilename,
                0,
                NULL,
                NULL );                 //  existing zone
    if ( status != ERROR_SUCCESS )
    {
        File_LogFileParsingError(
            DNS_EVENT_ZONE_CREATION_FAILED,
            pParseInfo,
            Argv );

        DNS_DEBUG( INIT, (
            "ERROR:  Zone creation failed.\n" ));
    }
    return status;
}



/*
    This function is used to create any zone which has a master IP
    list. zoneType may be
        DNS_ZONE_TYPE_SECONDARY
        DNS_ZONE_TYPE_STUB
        DNS_ZONE_TYPE_FORWARDER
*/
DNS_STATUS
createSecondaryZone(
    IN      int             zoneType,
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    DWORD               i;
    PDNS_ADDR_ARRAY     arrayMasters = NULL;
    PTOKEN              zoneToken;
    PTOKEN              fileToken = NULL;
    PZONE_INFO          pzone;
    DNS_STATUS          status;

    //
    //  secondary <zone name> <master IPs> [<zone file>]
    //

    if ( Argc < 2 )
    {
        return DNSSRV_ERROR_MISSING_TOKEN;
    }

    //  save zone name token

    zoneToken = Argv;
    NEXT_TOKEN( Argc, Argv );

    //  allocate master IP array

    arrayMasters = DnsAddrArray_Create( Argc );
    if ( !arrayMasters )
    {
        return DNS_ERROR_NO_MEMORY;
    }

    HARD_ASSERT( Mem_VerifyHeapBlock( arrayMasters, MEMTAG_DNSLIB, 0 ) );

    //
    //  read in master IP addresses
    //
    //  if last string doesn't parse to IP and
    //  have successfully parsed at least one IP,
    //  then treat last string as file name
    //

    for( i = 0; i < Argc; ++i )
    {
        if ( !File_ParseIpAddress(
                    &arrayMasters->AddrArray[ i ],
                    Argv,
                    NULL ) )    //  conversion not required
        {
            if ( i == Argc - 1 && i > 0 )
            {
                fileToken = Argv;
                arrayMasters->AddrCount = i;
                break;
            }
            File_LogFileParsingError(
                DNS_EVENT_INVALID_IP_ADDRESS_STRING,
                pParseInfo,
                Argv );
            status = DNSSRV_PARSING_ERROR;
            goto Done;
        }
        ++arrayMasters->AddrCount;
        ++Argv;
    }

    //
    //  create secondary zone
    //

    status = Zone_Create(
                &pzone,
                zoneType,
                zoneToken->pchToken,
                zoneToken->cchLength,
                0,                      //  flags
                arrayMasters,
                FALSE,                  //  use file
                NULL,                   //  naming context
                fileToken ? fileToken->pchToken : NULL,
                fileToken ? fileToken->cchLength : 0,
                NULL,
                NULL );                 //  existing zone
    if ( status != ERROR_SUCCESS )
    {
        File_LogFileParsingError(
            DNS_EVENT_ZONE_CREATION_FAILED,
            pParseInfo,
            Argv );

        DNS_DEBUG( INIT, (
            "ERROR:  Secondary zone (type %d) creation failed.\n",
            zoneType ));
    }

Done:

    FREE_HEAP( arrayMasters );
    return status;
}



DNS_STATUS
processSecondaryLine(
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    return createSecondaryZone(
                DNS_ZONE_TYPE_SECONDARY,
                Argc,
                Argv,
                pParseInfo );
}



DNS_STATUS
processStubLine(
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    return createSecondaryZone(
                DNS_ZONE_TYPE_STUB,
                Argc,
                Argv,
                pParseInfo );
}



DNS_STATUS
processDomainForwarderLine(
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    return createSecondaryZone(
                DNS_ZONE_TYPE_FORWARDER,
                Argc,
                Argv,
                pParseInfo );
}



DNS_STATUS
processCacheLine(
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    DNS_STATUS  status;

    //
    //  cache . <cache file>
    //

    if ( Argc != 2 )
    {
        return DNSSRV_ERROR_MISSING_TOKEN;
    }

    //
    //  set cache file
    //

    status = Zone_DatabaseSetup(
                g_pCacheZone,
                FALSE,          //  use file
                Argv[1].pchToken,
                Argv[1].cchLength,
                0,              //  flags
                NULL,           //  DP pointer
                0,              //  DP flags
                NULL );         //  DP FQDN
    if ( status != ERROR_SUCCESS )
    {
        File_LogFileParsingError(
            DNS_EVENT_ZONE_CREATION_FAILED,
            pParseInfo,
            Argv );

        DNS_DEBUG( INIT, (
            "ERROR:  Cache zone creation failed.\n" ));
        return DNSSRV_PARSING_ERROR;
    }

    return ERROR_SUCCESS;
}



DNS_STATUS
processForwardersLine(
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    PDNS_ADDR_ARRAY     arrayForwarders;
    DWORD               i;

    if ( Argc == 0 )
    {
        File_LogFileParsingError(
            DNS_EVENT_NO_FORWARDING_ADDRESSES,
            pParseInfo,
            NULL );
        return DNSSRV_ERROR_MISSING_TOKEN;
    }

    //  allocate forwarders array

    arrayForwarders = DnsAddrArray_Create( Argc );
    if ( !arrayForwarders )
    {
        return DNS_ERROR_NO_MEMORY;
    }

    HARD_ASSERT( Mem_VerifyHeapBlock( arrayForwarders, MEMTAG_DNSLIB, 0 ) );

    //  read in forwarders IP addresses

    for( i = 0; i < Argc; ++i )
    {
        if ( !File_ParseIpAddress(
                    &arrayForwarders->AddrArray[i],
                    Argv,
                    pParseInfo ) )
        {
            return DNSSRV_PARSING_ERROR;
        }
        ++arrayForwarders->AddrCount;
        ++Argv;
    }

    BootInfo.aipForwarders = arrayForwarders;
    return ERROR_SUCCESS;
}



DNS_STATUS
processSlaveLine(
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    if ( Argc != 0 )
    {
        return DNSSRV_ERROR_EXCESS_TOKEN;
    }
    BootInfo.fSlave = TRUE;
    return ERROR_SUCCESS;
}



DNS_STATUS
processOptionsLine(
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    DWORD   index;

    if ( Argc == 0 )
    {
        return DNSSRV_ERROR_MISSING_TOKEN;
    }

    //
    //  read \ process all options
    //
    //  DEVNOTE: we could expose these options in the bootfile as well
    //      - would need to have positive as well as negative
    //      - would need to limit ourselves to binary options
    //

    while( Argc )
    {
        //  get option index
        //      currently just support "no-recursion" option

        if ( Argv->cchLength == 12 &&
            _stricmp( Argv->pchToken, "no-recursion" ) )
        {
            BootInfo.fNoRecursion = TRUE;
        }
        else
        {
            DNS_PRINT((
                "ERROR:  Unknown server property %*s.\n",
                Argv[0].cchLength,
                Argv[0].pchToken ));

            File_LogFileParsingError(
                DNS_EVENT_UNKNOWN_BOOTFILE_OPTION,
                pParseInfo,
                Argv );
        }
        NEXT_TOKEN( Argc, Argv );
    }
    return ERROR_SUCCESS;
}



DNS_STATUS
processDirectoryLine(
    IN      DWORD           Argc,
    IN      PTOKEN          Argv,
    IN OUT  PPARSE_INFO     pParseInfo
    )
{
    DNS_STATUS  status;

    //
    //  $directory <directory name>
    //

    if ( Argc == 0 )
    {
        File_LogFileParsingError(
            DNS_EVENT_MISSING_DIRECTORY_NAME,
            pParseInfo,
            NULL );
        return ERROR_SUCCESS;
    }

    //
    //  create directory
    //

    status = Config_ReadDatabaseDirectory(
                Argv->pchToken,
                Argv->cchLength
                );

    if ( status != ERROR_SUCCESS )
    {
        File_LogFileParsingError(
            DNS_EVENT_DIRECTORY_DIRECTIVE,
            pParseInfo,
            NULL );
    }

    return ERROR_SUCCESS;
}




//
//  Dispatching to boot file line type specific processing
//

typedef struct _DnsBootLineInfo
{
    DWORD       CharCount;
    PCHAR       String;
    DNS_STATUS  (* BootLineFunction)(DWORD, PTOKEN, PPARSE_INFO);
}
DNS_BOOT_LINE_INFO;

DNS_BOOT_LINE_INFO  DnsBootLineTable[] =
{
    7,  "primary",              processPrimaryLine,
    9,  "secondary",            processSecondaryLine,
    5,  "cache",                processCacheLine,
    7,  "options",              processOptionsLine,
    10, "forwarders",           processForwardersLine,
    5,  "slave",                processSlaveLine,
    9,  "directory",            processDirectoryLine,
    4,  "stub",                 processStubLine,
    7,  "forward",              processDomainForwarderLine,
    0,  NULL,                   NULL
};



DNS_STATUS
processBootFileLine(
    IN OUT  PPARSE_INFO     pParseInfo
    )
/*++

Routine Description:

    Process line from boot file.

Arguments:

    pParseInfo - parsed line structure

Return Value:

    ERROR_SUCCESS if successful.
    Error code on line processing failure.

--*/
{
    DWORD   argc;
    PTOKEN  argv;
    PCHAR   pch;
    DWORD   cch;
    DWORD   charCount;
    INT     i = 0;

    //  get register arg variables

    //
    //  dispatch based on line type
    //

    argc = pParseInfo->Argc;
    argv = pParseInfo->Argv;
    ASSERT( argc > 0 );
    pch = argv->pchToken;
    cch = argv->cchLength;

    while ( 1 )
    {
        charCount = DnsBootLineTable[i].CharCount;
        if ( charCount == 0 )
        {
            break;
        }

        if ( charCount == cch &&
            _strnicmp( pch, DnsBootLineTable[i].String, cch ) == 0 )
        {
            NEXT_TOKEN( argc, argv );
            return( DnsBootLineTable[i].BootLineFunction(
                        argc,
                        argv,
                        pParseInfo ) );
        }
        i++;
    }

    //  line type not matched
    //      - log the error
    //      - return SUCCESS to attempt to continue to load

    File_LogFileParsingError(
        DNS_EVENT_UNKNOWN_DIRECTIVE,
        pParseInfo,
        argv );

    //return( ERROR_INVALID_PARAMETER );
    return ERROR_SUCCESS;
}



//
//  Boot file writing routines
//

DNS_STATUS
writeForwardersToBootFile(
    IN      HANDLE          hFile
    )
/*++

Routine Description:

    Write forwarders from registry to file.

Arguments:

    hFile -- file handle.

Return Value:

    ERROR_SUCCESS if successful.
    Error code on failure.

--*/
{
    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       pszforwarders = NULL;

    //
    //  write forwarders to file
    //

    if ( !SrvCfg_aipForwarders )
    {
        DNS_DEBUG( INIT, ( "No forwarders found.\n" ));
        return status;
    }
    DNS_DEBUG( INIT, ( "Writing forwarders to boot file.\n" ));

    pszforwarders = createStringFromIpAddressArray( SrvCfg_aipForwarders );
    if ( pszforwarders )
    {
        FormattedWriteFile(
            hFile,
            "forwarders\t\t%s\r\n",
            pszforwarders);
        FREE_HEAP( pszforwarders );
    }

    //
    //  write slave
    //

    if ( SrvCfg_fSlave )
    {
        FormattedWriteFile(
            hFile,
            "slave\r\n");
    }
    return status;
}



DNS_STATUS
writeZoneToBootFile(
    IN      HANDLE          hFile,
    IN      PZONE_INFO      pZone
    )
/*++

Routine Description:

    Write back the zone info to boot file.

Arguments:

    hFile -- file handle for write

    pZone -- ptr to zone block

Return Value:

    TRUE if successful.
    FALSE otherwise.

--*/
{
#define LEN_ZONE_NAME_BUFFER    (4*DNS_MAX_NAME_LENGTH + 1)
#define LEN_FILE_NAME_BUFFER    (4*MAX_PATH + 1)

    DNS_STATUS  status = ERROR_SUCCESS;
    LPSTR       pszmasterIp = NULL;
    CHAR        szzoneName[ LEN_ZONE_NAME_BUFFER ];
    CHAR        szfileName[ LEN_FILE_NAME_BUFFER ] = "";
    PCHAR       pszZoneTypeString = NULL;

    DNS_DEBUG( INIT, (
        "\nWriting zone %s info to boot file.\n",
        pZone->pszZoneName ));

    //
    //  convert zone name and file name
    //      to handle printing of UTF8
    //

    File_PlaceStringInFileBuffer(
        szzoneName,
        szzoneName + LEN_ZONE_NAME_BUFFER,
        FILE_WRITE_DOTTED_NAME,
        pZone->pszZoneName,
        strlen(pZone->pszZoneName) );

    if ( pZone->pszDataFile )
    {
        File_PlaceStringInFileBuffer(
            szfileName,
            szfileName + LEN_FILE_NAME_BUFFER,
            FILE_WRITE_FILE_NAME,
            pZone->pszDataFile,
            strlen(pZone->pszDataFile) );
    }

    //
    //  write zone info based on zone type
    //

    switch ( pZone->fZoneType )
    {
    case DNS_ZONE_TYPE_PRIMARY:

        //  no DS zones get written back, must be file backed for bootfile

        if ( pZone->fDsIntegrated )
        {
            break;
        }
        FormattedWriteFile(
            hFile,
            "%-12s %-27s %s\r\n",
            DNS_ZONE_TYPE_NAME_PRIMARY,
            szzoneName,
            szfileName );
        break;

    case DNS_ZONE_TYPE_STUB:

        pszZoneTypeString = DNS_ZONE_TYPE_NAME_STUB;

        //  Fall through to DNS_ZONE_TYPE_FORWARDER processing.

    case DNS_ZONE_TYPE_FORWARDER:

        if ( !pszZoneTypeString )
        {
            pszZoneTypeString = DNS_ZONE_TYPE_NAME_FORWARDER;
        }

        //  Fall through to DNS_ZONE_TYPE_FORWARDER processing.

    case DNS_ZONE_TYPE_SECONDARY:

        if ( !pszZoneTypeString )
        {
            pszZoneTypeString = DNS_ZONE_TYPE_NAME_SECONDARY;
        }

        if ( !pZone->aipMasters )
        {
            DNS_PRINT(( "ERROR: %s zone without master array!!!\n",
                pszZoneTypeString ));
            ASSERT( FALSE );
            break;
        }
        pszmasterIp = createStringFromIpAddressArray( pZone->aipMasters );

        if ( pZone->pszDataFile )
        {
            FormattedWriteFile(
                    hFile,
                    "%-12s %-27s %s %s\r\n",
                    pszZoneTypeString,
                    szzoneName,
                    pszmasterIp,
                    szfileName );
        }
        else
        {
            FormattedWriteFile(
                    hFile,
                    "%-12s %-27s %s\r\n",
                    pszZoneTypeString,
                    szzoneName,
                    pszmasterIp );
        }
        FREE_HEAP( pszmasterIp );
        break;

    case DNS_ZONE_TYPE_CACHE:

        //  if empty cache file name -- converted from DS -- put in standard name

        if ( szfileName[ 0 ] == 0 )
        {
            status = StringCchCatA(
                            szfileName,
                            sizeofarray( szfileName ),
                            DNS_DEFAULT_CACHE_FILE_NAME_UTF8 );
            if ( FAILED( status ) )
            {
                return status;
            }
        }
        FormattedWriteFile(
            hFile,
            "%-12s %-27s %s\r\n",
            DNS_ZONE_TYPE_NAME_CACHE,
            ".",
            szfileName );
        break;

    default:
        return( DNS_ERROR_INVALID_ZONE_TYPE );
    }

    return status;
}



BOOL
File_WriteBootFilePrivate(
    IN      HANDLE          hFile
    )
/*++

Routine Description:

    Write boot info in the registry to file.

Arguments:

    hFile -- file handle of target file

Return Value:

    TRUE if successful write.
    FALSE on error.

--*/
{
    DWORD       status;
    PZONE_INFO  pzone = NULL;

    //
    //  lock out admin access
    //

    Config_UpdateLock();
    Zone_UpdateLock( NULL );

    //
    //  write server configuration data
    //      - forwarders \ slave
    //      - no BIND secondaries
    //      - no recursion option
    //

    status = writeForwardersToBootFile(hFile);
    if ( status != ERROR_SUCCESS )
    {
        return FALSE;
    }

    if ( SrvCfg_fNoRecursion )
    {
        FormattedWriteFile(
            hFile,
            "options no-recursion\r\n");
    }

        //
    //  walk zones -- write each back
    //      note continue on failure
    //

    while( pzone = Zone_ListGetNextZone(pzone) )
    {
        if ( pzone->fAutoCreated )
        {
            continue;
        }
        if ( IS_ZONE_CACHE(pzone) && IS_ROOT_AUTHORITATIVE() )
        {
            continue;
        }

        status = writeZoneToBootFile( hFile, pzone );
        if ( status != ERROR_SUCCESS )
        {
            DNS_PRINT((
                "ERROR:  Writing zone %s to boot file failed.\n",
                pzone->pszZoneName ));
        }
    }

    //
    //  unlock for admin access
    //  enable write back to registry from creation functions,
    //

    Config_UpdateUnlock();
    Zone_UpdateUnlock( NULL );
    return TRUE;
}



LPSTR
createStringFromIpAddressArray(
    IN      PDNS_ADDR_ARRAY     pAddrArray
    )
/*++

Routine Description:

    Create a IP string from IP address array.
    The caller is supposed to free the memory.

Arguments:

    dwIpAddrCount -- number of Ip address in the array.
    pIpAddrs --  array of Ip address

Return Value:

    Ptr to string copy -- if successful
    NULL on failure.

--*/
{
    DNS_STATUS      status;
    LPSTR           pszmasterIp;
    DWORD           i;
    DWORD           countChar = 0;
    int             len;

    if ( !pAddrArray || !pAddrArray->AddrCount )
    {
        return NULL;
    }

    //
    //  allocate memory
    //

    len = pAddrArray->AddrCount * ( IP6_ADDRESS_STRING_LENGTH + 1 ) + 1;
    pszmasterIp = ( LPSTR ) ALLOCATE_HEAP( len );
    if( !pszmasterIp )
    {
        return NULL;
    }
    *pszmasterIp = '\0';

    //
    //  copy IP address from pIpAddrs to string one by one
    //  use character print so works even if NOT DWORD aligned
    //

    for( i = 0; i < pAddrArray->AddrCount; ++i )
    {
        CHAR    szaddr[ IP6_ADDRESS_STRING_BUFFER_LENGTH ];
        
        //  DEVNOTE: strcat here is not efficient.
        
        if ( i > 0 )
        {
            status = StringCchCatA( pszmasterIp, len, " " );
            if ( FAILED( status ) )
            {
                goto ErrorReturn;
            }
        }
        DnsAddr_WriteIpString_A( szaddr, &pAddrArray->AddrArray[ i ] );
        status = StringCchCatA( pszmasterIp, len, szaddr );
        if ( FAILED( status ) )
        {
            goto ErrorReturn;
        }
    }
    return pszmasterIp;
    
    ErrorReturn:
    
    FREE_HEAP( pszmasterIp );
    return NULL;
}



VOID
removeTrailDotFromString(
    IN OUT  LPSTR           lpzString
    )
/*++

Routine Description:

    Remove the trailing dot from string.
    If the string only contains a dot then keep that dot.

Arguments:

    lpzString -- ptr to sting to copy

Return Value:

    None.

--*/
{
    DWORD   length;

    if ( !lpzString )
    {
        return;
    }

    //
    //  remove trailing dot ONLY if not root name (".")
    //

    length = strlen( lpzString );

    if ( length != 0 && length != 1 && lpzString[length - 1] == '.')
    {
        lpzString[length - 1] = 0;
    }
    return;
}



BOOL
File_WriteBootFile(
    VOID
    )
/*++

Routine Description:

    Write boot info in the registry back to boot file.

Arguments:

    None.

Return Value:

    ERROR_SUCCESS, if successful
    ErrorCode on failure.

--*/
{
    LPSTR   pwsbootFile;
    HANDLE  hfileBoot;

    DNS_DEBUG( WRITE, ( "\n\nWriteBootFile()\n" ));

    //
    //  save current boot file
    //      - save to first backup, if no existing (attempt to save
    //      last human created boot file
    //      - save existing to last backup no matter what
    //

    MoveFile(
        DNS_BOOT_FILE_PATH,
        DNS_BOOT_FILE_FIRST_BACKUP );
    MoveFileEx(
        DNS_BOOT_FILE_PATH,
        DNS_BOOT_FILE_LAST_BACKUP,
        MOVEFILE_REPLACE_EXISTING );

    //
    //  open boot file
    //

    hfileBoot = OpenWriteFileEx(
                    DNS_BOOT_FILE_PATH,
                    FALSE       // overwrite
                    );
    if ( ! hfileBoot )
    {
        DNS_PRINT(( "ERROR:  Unable to open boot file for write.\n" ));
        return FALSE;
    }

    //
    //  write boot info
    //

    FormattedWriteFile(
        hfileBoot,
        ";\r\n"
        ";  Boot information written back by DNS server.\r\n"
        ";\r\n\r\n");

    if ( ! File_WriteBootFilePrivate(hfileBoot) )
    {
        DNS_LOG_EVENT(
            DNS_EVENT_BOOTFILE_WRITE_ERROR,
            0,
            NULL,
            NULL,
            0 );

        DNS_DEBUG( ANY, ( "ERROR:  Failure writing boot file.\n" ));
        CloseHandle( hfileBoot );

        //  save write error file for debug
        //  then replace boot file with last backup

        MoveFileEx(
            DNS_BOOT_FILE_PATH,
            DNS_BOOT_FILE_WRITE_ERROR,
            MOVEFILE_REPLACE_EXISTING );
        MoveFileEx(
            DNS_BOOT_FILE_LAST_BACKUP,
            DNS_BOOT_FILE_PATH,
            MOVEFILE_REPLACE_EXISTING );
        return FALSE;
    }

    //
    //  close up file, reset dirty flag
    //

    SrvCfg_fBootFileDirty = FALSE;
    CloseHandle( hfileBoot );

    DNS_LOG_EVENT(
        DNS_EVENT_BOOTFILE_REWRITE,
        0,
        NULL,
        NULL,
        0 );
    return TRUE;
}

//
//  End of bootfile.c
//
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\ds\dns\server\server\answer.c ===
/*++

Copyright (c) 1995-1999 Microsoft Corporation

Module Name:

    answer.c

Abstract:

    Domain Name System (DNS) Server

    Build answers to DNS queries.

Author:

    Jim Gilroy (Microsoft)      February 1995

Revision History:

--*/


#include "dnssrv.h"

#ifdef DNSSRV_PLUGINS
#include "plugin.h"
#endif


//
//  Private protos
//

DNS_STATUS
FASTCALL
writeCachedNameErrorNodeToPacketAndSend(
    IN OUT  PDNS_MSGINFO    pQuery,
    IN OUT  PDB_NODE        pNode
    );

PDB_NODE
getNextAdditionalNode(
    IN OUT  PDNS_MSGINFO    pMsg
    );

VOID
FASTCALL
answerIQuery(
    IN OUT  PDNS_MSGINFO    pMsg
    );



VOID
FASTCALL
Answer_ProcessMessage(
    IN OUT  PDNS_MSGINFO    pMsg
    )
/*++

Routine Description:

    Process the DNS message received.

Arguments:

    pMsg - message received to process

Return Value:

    None

--*/
{
    PCHAR           pch;
    PDNS_QUESTION   pquestion;
    WORD            rejectRcode;
    DWORD           rejectFlags = 0;
    WORD            type;
    WORD            qclass;

    ASSERT( pMsg != NULL );

    DNS_DEBUG( LOOKUP, (
        "Answer_ProcessMessage() for packet at %p\n",
        pMsg ));

    DNS_MSG_ASSERT_BUFF_INTACT( pMsg );

    //  all packets recv'd set for delete on send

    ASSERT( pMsg->fDelete );

    //
    //  Conditional breakpoint based on sender IP. Also break if 
    //  the break list starts with a zero address.
    //

    #if DBG
    if ( SrvCfg_aipRecvBreakList )
    {
        if ( SrvCfg_aipRecvBreakList->AddrCount &&
            ( DnsAddr_IsClear( &SrvCfg_aipRecvBreakList->AddrArray[ 0 ] ) ||
              DnsAddrArray_ContainsAddr( 
                    SrvCfg_aipRecvBreakList,
                    &pMsg->RemoteAddr,
                    DNSADDR_MATCH_IP ) ) )
        {
            DNS_PRINT(( "HARD BREAK: " 
                DNS_REGKEY_BREAK_ON_RECV_FROM
                " %s\n",
                DNSADDR_STRING( &pMsg->RemoteAddr ) ));
            DebugBreak();
        }
    }
    #endif

    //
    //  response packet ?
    //
    //      - recursive respose
    //      - notify
    //      - SOA check
    //      - WINS query response
    //

    if ( pMsg->Head.IsResponse )
    {
        pMsg->dwMsQueryTime = GetCurrentTimeInMilliSeconds();

        DNS_DEBUG( LOOKUP, (
            "Processing response packet at %p\n",
            pMsg ));

        //
        //  standard query response?
        //
        //  check XID partitioning (host order) for type of response:
        //      - WINS lookup response
        //      - recursive response
        //      - secondary SOA check response
        //

        if ( pMsg->Head.Opcode == DNS_OPCODE_QUERY )
        {
            if ( IS_WINS_XID( pMsg->Head.Xid ) )
            {
                Wins_ProcessResponse( pMsg );
            }
            else if ( IS_RECURSION_XID( pMsg->Head.Xid ) )
            {
                Recurse_ProcessResponse( pMsg );
            }
            else
            {
                //  queue packet to secondary thread
                //      - return, since no message free required

                Xfr_QueueSoaCheckResponse( pMsg );
                goto Done;
            }
        }

        //
        //  DEVNOTE-DCR: 453103 - handle notify ACKs
        //

        else if ( pMsg->Head.Opcode == DNS_OPCODE_NOTIFY )
        {
            DNS_DEBUG( ZONEXFR, (
                "Dropping Notify ACK at %p (no processing yet) from %s\n",
                pMsg,
                DNSADDR_STRING( &pMsg->RemoteAddr ) ));

            //  Xfr_ProcessNotifyAck( pMsg );
        }

        //
        //  Forwarded update response
        //

        else if ( pMsg->Head.Opcode == DNS_OPCODE_UPDATE )
        {
            Up_ForwardUpdateResponseToClient( pMsg );
        }

        else
        {
            //
            //  DEVNOTE-LOG: could log unknown response, but would have to
            //  make sure throttling would prevent event long pollution or DoS
            //

            DNS_PRINT((
                "WARNING:  Unknown opcode %d in response packet %p\n",
                pMsg->Head.Opcode,
                pMsg ));

            Dbg_DnsMessage(
                "WARNING:  Message with bad opcode\n",
                pMsg );
            TEST_ASSERT( FALSE );
        }

        Packet_Free( pMsg );
        goto Done;

    }   // end response section


    //
    //  check opcode, dispatch IQUERY
    //  doing here as must handle before dereference question which IQUERY
    //      doesn't have
    //

    if ( pMsg->Head.Opcode != DNS_OPCODE_QUERY  &&
         pMsg->Head.Opcode != DNS_OPCODE_UPDATE &&
         pMsg->Head.Opcode != DNS_OPCODE_NOTIFY )
    {
        if ( pMsg->Head.Opcode == DNS_OPCODE_IQUERY )
        {
            answerIQuery( pMsg );
            goto Done;
        }
        DNS_DEBUG( ANY, (
            "Rejecting request %p [NOT IMPLEMENTED]: bad opcode in query\n",
            pMsg ));
        rejectRcode = DNS_RCODE_NOT_IMPLEMENTED;
        goto RejectIntact;
    }

    //
    //  reject multiple question queries
    //

    if ( pMsg->Head.QuestionCount != 1 )
    {
        DNS_DEBUG( ANY, (
            "Rejecting request %p [FORMERR]:  question count = %d\n",
            pMsg,
            pMsg->Head.QuestionCount ));
        rejectRcode = DNS_RCODE_FORMAT_ERROR;
        goto RejectIntact;
    }

    //
    //  break out internal pointers
    //      - do it once here, then use FASTCALL to pass down
    //
    //  save off question, in case request is requeued
    //

    pch = pMsg->MessageBody;

    //
    //  DEVNOTE-DCR: 453104 - looking through question name twice
    //
    //  It would be nice to avoid this.  We traverse question name, then must convert
    //  it to lookup name later.
    //
    //  Problem is we do lookup name right in database function.  We'd need
    //  to move that out, and have these rejections -- and kick out to
    //  zone transfer, right after lookup name conversion.  In the process
    //  we could probably ditch this top level function call.  Have to provide
    //  a clean interface to call, when trying to reresolve after recursive
    //  reponse.
    //
    //  These rejection cases and zone transfer are rare, so for 99% of the
    //  cases that would be faster.
    //

    pquestion = (PDNS_QUESTION) Wire_SkipPacketName( pMsg, (PCHAR)pch );
