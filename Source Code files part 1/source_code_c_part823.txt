/= (DWORDLONG)CONSTANT_MEGABYTE;
        uiMax = (dlTotal < CACHE_SIZE_CAP) ? (UINT)dlTotal : CACHE_SIZE_CAP;
    }
    SendDlgItemMessage(pTmp->hDlg, IDC_ADVANCED_CACHE_SIZE_SPIN, UDM_SETRANGE, FALSE, MAKELPARAM(uiMax, CACHE_SIZE_MIN));
}

BOOL InvokeCachevu(HWND hDlg)
{
    TCHAR szCache[MAX_PATH];

    HRESULT hres = SHGetFolderPath(NULL, CSIDL_INTERNET_CACHE | CSIDL_FLAG_CREATE, NULL, 0, szCache);
    if (hres == S_OK)
    {
        DWORD dwAttrib = GetFileAttributes(szCache);

        TCHAR szIniFile[MAX_PATH];
        PathCombine(szIniFile, szCache, TEXT("desktop.ini"));

        if (GetFileAttributes(szIniFile) == -1)
        {
            DWORD dwAttrib = GetFileAttributes(szCache);
            dwAttrib &= ~FILE_ATTRIBUTE_HIDDEN;
            dwAttrib |=  FILE_ATTRIBUTE_SYSTEM;

            // make sure system, but not hidden
            SetFileAttributes(szCache, dwAttrib);

            WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("ConfirmFileOp"), TEXT("0"), szIniFile);
            WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("UICLSID"), TEXT("{7BD29E00-76C1-11CF-9DD0-00A0C9034933}"), szIniFile);
        }

        // All seems well, launch it.
        SHELLEXECUTEINFO ei = { sizeof(SHELLEXECUTEINFO), 0};
        ei.hwnd = hDlg;
        ei.lpFile = szCache;
        ei.nShow = SW_SHOWNORMAL;
        return ShellExecuteEx(&ei);
    }

    return FALSE;
}

// Following flag swiped from wininet
#define FIND_FLAGS_RETRIEVE_ONLY_STRUCT_INFO    0x2

#define DISK_SPACE_MARGIN   4*1024*1024

// IsEnoughDriveSpace
// verifies that there will enough space for the current contents of the cache
// on the new destination

BOOL IsEnoughDriveSpace(DWORD dwClusterSize, DWORDLONG dlAvailable)
{
    // Adjust dlAvailable to leave some space free
    if ((DISK_SPACE_MARGIN/dwClusterSize) > dlAvailable)
    {
        return FALSE;
    }
    else
    {
        dlAvailable -= DISK_SPACE_MARGIN/dwClusterSize;
    };
    
    // Now, iterate through the cache to discover the actual size.
    INTERNET_CACHE_ENTRY_INFOA cei;
    DWORD dwSize = sizeof(cei);
    DWORDLONG dlClustersNeeded = 0;    
    BOOL fResult = FALSE;
    HANDLE hFind = FindFirstUrlCacheEntryExA(NULL, 
                                    FIND_FLAGS_RETRIEVE_ONLY_STRUCT_INFO,
                                    NORMAL_CACHE_ENTRY,
                                    NULL,
                                    &cei, 
                                    &dwSize,
                                    NULL,
                                    NULL,
                                    NULL);

    if (hFind!=NULL)
    {
        do
        {
            ULARGE_INTEGER ulFileSize;
            ulFileSize.LowPart = cei.dwSizeLow;
            ulFileSize.HighPart = cei.dwSizeHigh;
            dlClustersNeeded += (ulFileSize.QuadPart / (DWORDLONG)dwClusterSize) + 1;
            fResult = FindNextUrlCacheEntryExA(hFind, &cei, &dwSize, NULL, NULL, NULL) && (dlClustersNeeded < dlAvailable);
        } 
        while (fResult);
        FindCloseUrlCache(hFind);

        if (GetLastError()==ERROR_NO_MORE_ITEMS)
        {
            fResult = dlClustersNeeded < dlAvailable;
        } 
    }
    else
    {
        fResult = TRUE;
    }
    return fResult;
}


//
// SaveTemporarySettings
//
// Save the Temporary Files Dialog (Cache) settings.
//
// History:
//
// 6/14/96  t-gpease  created
//
BOOL SaveTemporarySettings(LPTEMPDLG pTmp)
{
    if ((pTmp->uiCacheQuota<1) || (pTmp->uiCacheQuota>pTmp->uiDiskSpaceTotal))
    {
        TCHAR szError[1024], szTemp[100];
        
        MLLoadShellLangString(IDS_SIZE_FORMAT, szTemp, ARRAYSIZE(szTemp));
        wnsprintf(szError, ARRAYSIZE(szError), szTemp, pTmp->uiDiskSpaceTotal);
        MLLoadShellLangString(IDS_ERROR, szTemp, ARRAYSIZE(szTemp));
        MessageBox(pTmp->hDlg, szError, szTemp, MB_OK | MB_ICONEXCLAMATION);
        SetFocus(GetDlgItem(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT));
        return FALSE;
    }
    
    if (pTmp->bChanged)
    {
        // derive the syncmode for the radio buttons
        if (IsDlgButtonChecked(pTmp->hDlg, IDC_ADVANCED_CACHE_AUTOMATIC))
            
            pTmp->iCacheUpdFrequency = WININET_SYNC_MODE_AUTOMATIC;
        
        else if (IsDlgButtonChecked(pTmp->hDlg, IDC_ADVANCED_CACHE_NEVER))

            pTmp->iCacheUpdFrequency = WININET_SYNC_MODE_NEVER;

        else if (IsDlgButtonChecked(pTmp->hDlg, IDC_ADVANCED_CACHE_ALWAYS))

            pTmp->iCacheUpdFrequency = WININET_SYNC_MODE_ALWAYS;

        else {
            ASSERT(IsDlgButtonChecked(pTmp->hDlg, IDC_ADVANCED_CACHE_ONCEPERSESS));
            pTmp->iCacheUpdFrequency = WININET_SYNC_MODE_ONCE_PER_SESSION;
        }

        // notify IE
        INTERNET_CACHE_CONFIG_INFOA cci;
        cci.dwContainer = CONTENT;
        cci.dwQuota = pTmp->uiCacheQuota * 1024; // Make into KB
        cci.dwSyncMode = pTmp->iCacheUpdFrequency;

        ASSERT(cci.dwQuota);
        SetUrlCacheConfigInfoA(&cci, CACHE_CONFIG_SYNC_MODE_FC | CACHE_CONFIG_QUOTA_FC);
    }

    if (pTmp->bChangedLocation)
    {
        OSVERSIONINFOA VerInfo;
        VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
        GetVersionExA(&VerInfo);

        if (g_hwndPropSheet)
        {
            PropSheet_Apply(g_hwndPropSheet);
        }
        
        BOOL fRunningOnNT = (VerInfo.dwPlatformId == VER_PLATFORM_WIN32_NT);
        // Well, we're going to have to force a reboot now. Ciao. Confirm.
        if (IDYES==DispMessage(pTmp->hDlg, 
                               fRunningOnNT ? IDS_LOGOFF_WARNING : IDS_REBOOTING_WARNING, 
                               fRunningOnNT ? IDS_LOGOFF_TITLE : IDS_REBOOTING_TITLE, 
                               MB_YESNO | MB_ICONEXCLAMATION))
        {
            // fix registry entries and add RunOnce command
            // NOTE: a REBOOT must be done for changes to take effect
            //       (see SetCacheLocation() ).
            // On NT, we must adjust the token privileges
            BOOL fSuccess = TRUE;
            if (fRunningOnNT) 
            {
                HANDLE hToken;
                TOKEN_PRIVILEGES tkp;
                // get a token from this process
                if (fSuccess=OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hToken))
                {
                    // get the LUID for the shutdown privilege
                    LookupPrivilegeValue(NULL, SE_SHUTDOWN_NAME, &tkp.Privileges[0].Luid);

                    tkp.PrivilegeCount = 1;
                    tkp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

                    //get the shutdown privilege for this proces
                    fSuccess = AdjustTokenPrivileges( hToken, FALSE, &tkp, 0, (PTOKEN_PRIVILEGES)NULL, 0 );
                }
            }
            if (fSuccess)
            {
#ifdef UNICODE  //UpdateUrlCacheContentPath takes LPSTR
                char szNewPath[MAX_PATH];
                SHTCharToAnsi(pTmp->szNewCacheLocation, szNewPath, ARRAYSIZE(szNewPath));
                UpdateUrlCacheContentPath(szNewPath);
#else
                UpdateUrlCacheContentPath(pTmp->szNewCacheLocation);
#endif
                ExitWindowsEx((fRunningOnNT ? EWX_LOGOFF : EWX_REBOOT), 0);
            }
            else
            {
                DispMessage(pTmp->hDlg, IDS_ERROR_MOVE_MSG, IDS_ERROR_MOVE_TITLE, MB_OK | MB_ICONEXCLAMATION);
            }
        }
    }
    return TRUE;
} // SaveTemporarySettings()

//
// IsValidDirectory()
//
// Checks out the path for mistakes... like just machine names...
// SHBrowseForFolder should NOT just return a machine name... BUG is
// shell code.
//
BOOL IsValidDirectory(LPTSTR szDir)
{
    if (szDir)
    {
        if (!*szDir)
            return FALSE;   // it's empty... that's not good
        if (*szDir!= DIR_SEPARATOR_CHAR)
            return TRUE;    // not a machine path... then OK

        // move forward two chars ( the '\''\')
        ++szDir;
        ++szDir;

        while ((*szDir) && (*szDir!=DIR_SEPARATOR_CHAR))
            szDir++;

        if (*szDir==DIR_SEPARATOR_CHAR)
            return TRUE;    // found another '\' so we are happy.

        return FALSE; // machine name only... ERROR!
    }

    return FALSE;

} // IsValidDirecotry()

#define NUM_LEVELS      3   // random dir + cachefile + safety (installed containers)

DWORD g_ccBrandName = 0;

int CALLBACK MoveFolderCallBack(
    HWND hwnd,
    UINT uMsg,
    LPARAM lParam,
    LPARAM lpData
    )
{
    if (uMsg==BFFM_SELCHANGED)
    {
        TCHAR szNewDest[1024];
        TCHAR szStatusText[256];
        UINT uErr = 0;
        LONG fValid = FALSE;
        
        if (SHGetPathFromIDList((LPCITEMIDLIST)lParam, szNewDest))
        {
            // Account for "Temporary Internet Files\Content.IE?\randmdir.ext" + NUM_LEVELS*10
            DWORD ccAvail = MAX_PATH - g_ccBrandName -1 - ARRAYSIZE("CONTENT.IE?\\") - (NUM_LEVELS*10);
            if ((DWORD)lstrlen(szNewDest)>ccAvail) // Win95 limit on how long paths can be
            {
                uErr = IDS_ERROR_ARCHITECTURE;
            }
            else if (StrStrI(szNewDest, TEXT("Content.IE")))
            {
                uErr = IDS_ERROR_WRONG_PLACE;
            }
            else if (!IsValidDirectory(szNewDest))
            {
                uErr = IDS_ERROR_INVALID_PATH_MSG;
            } 
            else if (GetFileAttributes(szNewDest) & FILE_ATTRIBUTE_READONLY)
            {
                uErr = IDS_ERROR_STRANGENESS;
            }
            else
            {
#ifdef UNICODE
                CHAR szAnsiPath[MAX_PATH];
                BOOL fProblems;
                WideCharToMultiByte(CP_ACP, NULL, szNewDest, -1, szAnsiPath, ARRAYSIZE(szAnsiPath),
                                    NULL, &fProblems);
                if (fProblems)
                {
                    uErr = IDS_ERROR_INVALID_PATH;
                }
                else
#endif
                {    
                TCHAR szSystemPath[MAX_PATH+1];

                GetSystemDirectory(szSystemPath, MAX_PATH);
                if (StrStrI(szNewDest, szSystemPath))
                {
                    uErr = IDC_ERROR_USING_SYSTEM_DIR;
                }
                else
                {
                    fValid = TRUE;
                }
                }
            }
        }
        else
        {
            uErr = IDS_ERROR_STRANGENESS;        
        }
        
        if (uErr)
        {
            MLLoadShellLangString(uErr, szStatusText, ARRAYSIZE(szStatusText));
        }
        else
        {
            szStatusText[0] = 0;
        }

        SendMessage(hwnd, BFFM_ENABLEOK, 0, (LPARAM)fValid);
        SendMessage(hwnd, BFFM_SETSTATUSTEXT, 0, (LPARAM)szStatusText);
    }

    return 0;
}


//
// MoveFolder()
//
// Handles the moving of the Temporary Files (Cache) Folder to
// another location. It checks for the existence of the new folder.
// It warns the user that a REBOOT is necessary before changes
// are made.
//
// History:
//
// 6/18/96  t-gpease    created.
//
void MoveFolder(LPTEMPDLG pTmp)
{
    TCHAR szTemp [1024];
    TCHAR szWindowsPath [MAX_PATH+1];
    BROWSEINFO biToFolder;

    biToFolder.hwndOwner = pTmp->hDlg;
    biToFolder.pidlRoot = NULL;                 // start on the Desktop
    biToFolder.pszDisplayName = szWindowsPath;  // not used, just making it happy...

    TCHAR szBrandName[MAX_PATH];
    MLLoadString(IDS_BRAND_NAME, szBrandName, ARRAYSIZE(szBrandName));
    g_ccBrandName = lstrlen(szBrandName);
    
    // load the title of the dialog box
    MLLoadShellLangString(IDS_SELECT_CACHE, szTemp, ARRAYSIZE(szTemp));
    biToFolder.lpszTitle = szTemp;

    biToFolder.ulFlags = BIF_RETURNONLYFSDIRS | BIF_STATUSTEXT;  // folders... nothing else
    biToFolder.lpfn = MoveFolderCallBack; // nothing special

    while (1)
    {
        // start shell dialog
        LPITEMIDLIST pidl = SHBrowseForFolder(&biToFolder);
        if (pidl)   // if everything went OK
        {
            DWORD dwClusterSize;
            DWORDLONG dlAvailable;
            DWORD dwError;

            // get the choice the user selected
            SHGetPathFromIDList(pidl, pTmp->szNewCacheLocation);
            SHFree(pidl);

            // Resolve local device to UNC if possible
            if ((GetDriveType(pTmp->szNewCacheLocation)==DRIVE_REMOTE) && (pTmp->szNewCacheLocation[0]!=DIR_SEPARATOR_CHAR))
            {
                TCHAR szPath[MAX_PATH];
                DWORD dwLen = ARRAYSIZE(szPath);

                pTmp->szNewCacheLocation[2] = '\0';

                dwError = WNetGetConnection(pTmp->szNewCacheLocation, szPath, &dwLen);
                if (dwError!=ERROR_SUCCESS)
                {
                    DispMessage(pTmp->hDlg, IDS_ERROR_CANT_CONNECT, IDS_ERROR_MOVE_TITLE, MB_OK | MB_ICONEXCLAMATION);
                    continue;
                }
                memcpy(pTmp->szNewCacheLocation, szPath, dwLen+1);
            }
            
            if (!GetDiskInfo(pTmp->szNewCacheLocation, &dwClusterSize, &dlAvailable, NULL))
            {
                DispMessage(pTmp->hDlg, IDS_ERROR_CANT_CONNECT, IDS_ERROR_MOVE_TITLE, MB_OK | MB_ICONEXCLAMATION);
                continue;
            }

            if (((*pTmp->szNewCacheLocation==*pTmp->szCacheLocation) && (pTmp->szNewCacheLocation[0]!=DIR_SEPARATOR_CHAR))
                ||
                (IsEnoughDriveSpace(dwClusterSize, dlAvailable)
                &&
                (GetLastError()==ERROR_NO_MORE_ITEMS)))
            {
                pTmp->bChangedLocation = TRUE;
            }
            else
            {
                DispMessage(pTmp->hDlg, IDS_ERROR_CANT_MOVE_TIF, IDS_ERROR_MOVE_TITLE, MB_OK | MB_ICONEXCLAMATION);
                continue;
            }
        }
        break;
    }

    if (pTmp->bChangedLocation)
    {
        DWORDLONG cbTotal;

        pTmp->uiDiskSpaceTotal = 0;
        if (GetDiskInfo(pTmp->szNewCacheLocation, NULL, NULL, &cbTotal))
        {
            pTmp->uiDiskSpaceTotal = (UINT)(cbTotal / (DWORDLONG)CONSTANT_MEGABYTE);
        }

        DWORD ccPath = lstrlen(pTmp->szNewCacheLocation);
        if (pTmp->szNewCacheLocation[ccPath-1]!=DIR_SEPARATOR_CHAR)
        {
            pTmp->szNewCacheLocation[ccPath] = DIR_SEPARATOR_CHAR;
            ccPath++;
        }
        memcpy(pTmp->szNewCacheLocation + ccPath, szBrandName, (g_ccBrandName+1)*sizeof(TCHAR));

        if (pTmp->uiCacheQuota > pTmp->uiDiskSpaceTotal)
        {
            pTmp->uiCacheQuota = pTmp->uiDiskSpaceTotal;
            SetDlgItemInt(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT, pTmp->uiCacheQuota, FALSE);
        }

        SetDlgItemText( pTmp->hDlg, IDC_ADVANCED_CACHE_LOCATION, pTmp->szNewCacheLocation);

        // set dialog text
        MLLoadString(IDS_STATUS_FOLDER_NEW, szTemp, ARRAYSIZE(szTemp));
        SetDlgItemText( pTmp->hDlg, IDC_ADVANCED_CACHE_STATUS, szTemp);

        UpdateCacheQuotaInfo(pTmp, FALSE);
        AdjustCacheRange(pTmp);
    }
} // MoveFolder()


//
// TemporaryInit()
//
// Handles the initialization of Temporary Files Dialog (Cache)
//
// History:
//
// 6/13/96  t-gpease  created
//
BOOL TemporaryInit(HWND hDlg)
{
    LPTEMPDLG pTmp;
    BOOL bAlways, bOnce, bNever, bAuto;

    pTmp = (LPTEMPDLG)LocalAlloc(LPTR, sizeof(*pTmp));
    if (!pTmp)
    {
        EndDialog(hDlg, 0);
        return FALSE;   // no memory?
    }

    // tell dialog where to get info
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pTmp);

    // get dialog item handles
    pTmp->hDlg = hDlg;
    pTmp->hwndTrack = GetDlgItem( hDlg, IDC_ADVANCED_CACHE_PERCENT );

    INTERNET_CACHE_CONFIG_INFOA icci;
    icci.dwContainer = CONTENT;
    if (GetUrlCacheConfigInfoA(&icci, NULL, CACHE_CONFIG_QUOTA_FC 
                                    | CACHE_CONFIG_DISK_CACHE_PATHS_FC
                                    | CACHE_CONFIG_SYNC_MODE_FC))
    {
        SHAnsiToTChar(icci.CachePath, pTmp->szCacheLocation, ARRAYSIZE(pTmp->szCacheLocation));
        pTmp->iCachePercent = 0;
        pTmp->uiCacheQuota = icci.dwQuota / 1024;
        pTmp->iCacheUpdFrequency = (WORD)icci.dwSyncMode;
    }
    else
    {
        // GUCCIEx CAN NEVER FAIL.
        ASSERT(FALSE);
        pTmp->iCacheUpdFrequency = WININET_SYNC_MODE_DEFAULT;
        pTmp->iCachePercent = 3;  // YUCK, magic number.
        pTmp->uiCacheQuota = 0;
    }
    SetDlgItemInt(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT, pTmp->uiCacheQuota, FALSE);
//    SendDlgItemMessage(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT, pTmp->uiCacheQuota, FALSE);
    SendDlgItemMessage(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT, EM_SETLIMITTEXT, 6, 0);

    // update cache fields
    SendMessage( pTmp->hwndTrack, TBM_SETTICFREQ, 5, 0 );
    SendMessage( pTmp->hwndTrack, TBM_SETRANGE, FALSE, MAKELONG(0, 100) );
    SendMessage( pTmp->hwndTrack, TBM_SETPAGESIZE, 0, 5 );

    DWORDLONG cbTotal;
    pTmp->uiDiskSpaceTotal = 0;
    if (GetDiskInfo(pTmp->szCacheLocation, NULL, NULL, &cbTotal))
    {
        pTmp->uiDiskSpaceTotal = (UINT)(cbTotal / (DWORDLONG)CONSTANT_MEGABYTE);
    }
    UpdateCacheQuotaInfo(pTmp, FALSE);
    AdjustCacheRange(pTmp);

    // set the rest of the dialog's items
    TCHAR szBuf[MAX_PATH];

    // Is the following line necessary? 
    ExpandEnvironmentStrings(pTmp->szCacheLocation,szBuf, ARRAYSIZE(szBuf));

    // NOTE NOTE NOTE The following code might have to be altered if we start using
    // shfolder.dll to gather the location of the cache
    // pszEnd = szBuf + 3 because UNCs are "\\x*" and local drives are "C:\*"

    // Move to the end of the string, before the traiiling slash. (This is how wininet works.)
    PTSTR pszLast = szBuf + lstrlen(szBuf) - 2;
    while ((pszLast>=szBuf) && (*pszLast!=DIR_SEPARATOR_CHAR))
    {
        pszLast--;
    }
    // The terminator should always be placed between the \Temporary Internet Files and the
    // \Content.IE?. This must always be present.
    *(pszLast+1) = TEXT('\0');
    
    SetDlgItemText( hDlg, IDC_ADVANCED_CACHE_LOCATION, szBuf );

    MLLoadString(IDS_STATUS_FOLDER_CURRENT, szBuf, ARRAYSIZE(szBuf));
    SetDlgItemText( hDlg, IDC_ADVANCED_CACHE_STATUS, szBuf );
    
    // activate the correct radio button
    bAlways = bOnce = bNever = bAuto = FALSE;
    if (pTmp->iCacheUpdFrequency == WININET_SYNC_MODE_AUTOMATIC)
        bAuto = TRUE;
    else if (pTmp->iCacheUpdFrequency == WININET_SYNC_MODE_NEVER)
        bNever = TRUE;
    else if (pTmp->iCacheUpdFrequency == WININET_SYNC_MODE_ALWAYS)
        bAlways = TRUE;
    else
        bOnce = TRUE;   // if something got messed up... reset to Once Per Session

    CheckDlgButton(hDlg, IDC_ADVANCED_CACHE_ALWAYS,      bAlways);
    CheckDlgButton(hDlg, IDC_ADVANCED_CACHE_ONCEPERSESS, bOnce);
    CheckDlgButton(hDlg, IDC_ADVANCED_CACHE_AUTOMATIC,   bAuto);
    CheckDlgButton(hDlg, IDC_ADVANCED_CACHE_NEVER,       bNever);

    // nothing has chagned yet...
    pTmp->bChanged = pTmp->bChangedLocation = FALSE;

    if( g_restrict.fCache )
    {
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_CACHE_ALWAYS), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_CACHE_ONCEPERSESS), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_CACHE_AUTOMATIC), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_CACHE_NEVER), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_CACHE_PERCENT), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_CACHE_PERCENT_ACC), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_CACHE_SIZE_SPIN), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_MOVE_CACHE_LOCATION), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_CACHE_EMPTY), FALSE );
    }

    return TRUE;    // worked!
}


//
// TemporaryOnCommand()
//
// Handles Temporary Files dialogs WM_COMMAND messages
//
// History:
//
// 6/13/96  t-gpease   created
//
void TemporaryOnCommand(LPTEMPDLG pTmp, UINT id, UINT nCmd)
{
    switch (id) {
        case IDC_ADVANCED_CACHE_TEXT_PERCENT:
        case IDC_ADVANCED_CACHE_SIZE_SPIN:
            if (pTmp && nCmd == EN_CHANGE)
            {
                UINT uiVal;
                BOOL fSuccess;
                uiVal = GetDlgItemInt(pTmp->hDlg, IDC_ADVANCED_CACHE_TEXT_PERCENT, &fSuccess, FALSE);
                if (fSuccess)
                {
                    pTmp->uiCacheQuota = uiVal;
                    UpdateCacheQuotaInfo(pTmp, FALSE);
                    pTmp->bChanged = TRUE;
                }
            }
            break;

        case IDC_ADVANCED_CACHE_ALWAYS:
        case IDC_ADVANCED_CACHE_ONCEPERSESS:
        case IDC_ADVANCED_CACHE_AUTOMATIC:
        case IDC_ADVANCED_CACHE_NEVER:
            pTmp->bChanged = TRUE;
            break;

        case IDOK:
            // save it
            if (!SaveTemporarySettings(pTmp))
            {
                break;
            }
            // Fall through

        case IDCANCEL:
            EndDialog(pTmp->hDlg, id);
            break; // IDCANCEL

        case IDC_ADVANCED_CACHE_BROWSE:
            InvokeCachevu(pTmp->hDlg);
            break;

        case IDC_ADVANCED_MOVE_CACHE_LOCATION:
            MoveFolder(pTmp);
            break; // IDC_ADVANCED_MOVE_CACHE_LOCATION

        case IDC_ADVANCED_DOWNLOADED_CONTROLS:
        {
            TCHAR szPath[MAX_PATH];
#ifdef UNIX
            TCHAR szExpPath[MAX_PATH];
#endif
            DWORD cb=SIZEOF(szPath);

            if (SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings"),
                           TEXT("ActiveXCache"), NULL, szPath, &cb) == ERROR_SUCCESS)
            {
                SHELLEXECUTEINFO ei;
#ifdef UNIX
                int cbExp = ExpandEnvironmentStrings(szPath,szExpPath,MAX_PATH);
#endif

                ei.cbSize       = sizeof(SHELLEXECUTEINFO);
                ei.hwnd         = pTmp->hDlg;
                ei.lpVerb       = NULL;
#ifndef UNIX
                ei.lpFile        = szPath;
#else
                if( cbExp > 0 && cbExp < MAX_PATH )
                    ei.lpFile = szExpPath;
                else
                    ei.lpFile = szPath;
#endif
                ei.lpParameters    = NULL;
                ei.lpDirectory    = NULL;
                ei.nShow        = SW_SHOWNORMAL;
                ei.fMask        = 0;
                ShellExecuteEx(&ei);
            }
            break;
        }

    } // switch

} // TemporaryOnCommand()

//
// TemporaryDlgProc
//
// Take care of "Temporary Files" (Cache)
//
// History:
//
// ??/??/??   God      created
// 6/13/96  t-gpease   cleaned up code, separated functions, and
//                     changed it into a Dialog (was property
//                     sheet).
//
INT_PTR CALLBACK TemporaryDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, 
                                  LPARAM lParam)
{
    LPTEMPDLG pTmp = (LPTEMPDLG) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) {

    case WM_INITDIALOG:
        return TemporaryInit(hDlg);

    case WM_HSCROLL:
        pTmp->iCachePercent = (WORD)SendMessage( pTmp->hwndTrack, TBM_GETPOS, 0, 0 );
        UpdateCacheQuotaInfo(pTmp, TRUE);
        pTmp->bChanged = TRUE;
        return TRUE;

    case WM_COMMAND:
        TemporaryOnCommand(pTmp, LOWORD(wParam), HIWORD(wParam));
        return TRUE;

    case WM_HELP:                   // F1
        ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                    HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
    break;

    case WM_CONTEXTMENU:        // right mouse click
        ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                    HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
    break;

    case WM_DESTROY:
        ASSERT(pTmp);
        LocalFree(pTmp);
        break;

   }
    return FALSE;
}

INT_PTR CALLBACK EmptyCacheDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                   LPARAM lParam)
{
    switch (uMsg) {
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDCANCEL:
            EndDialog(hDlg, 0);
            break;
        case IDOK:
#ifndef UNIX
            if (Button_GetCheck(GetDlgItem(hDlg, IDC_DELETE_SUB)))
                EndDialog(hDlg, 3);
            else
                EndDialog(hDlg, 1);
#else
            // On Unix we alway return from this dialog with delete channel content
            // option set, though we have removed this option from the UI.
            EndDialog(hDlg, 3);
#endif
            break;
        }
        return TRUE;
   }
    return FALSE;
}

INT_PTR CALLBACK EmptyCacheCookiesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                    LPARAM lParam)
{
    switch (uMsg) {
    case WM_COMMAND:
        switch (LOWORD(wParam)) {
        case IDCANCEL:
            EndDialog(hDlg, 0);
            break;
        case IDOK:
            EndDialog(hDlg, 1);
            break;
        }
        return TRUE;
   }
    return FALSE;
}

BOOL DeleteCacheCookies()
{
    BOOL bRetval = TRUE;
    DWORD dwEntrySize, dwLastEntrySize;
    LPINTERNET_CACHE_ENTRY_INFOA lpCacheEntry;
    
    HANDLE hCacheDir = NULL;
    dwEntrySize = dwLastEntrySize = MAX_CACHE_ENTRY_INFO_SIZE;
    lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) new BYTE[dwEntrySize];
    if( lpCacheEntry == NULL)
    {
        bRetval = FALSE;
        goto Exit;
    }
    lpCacheEntry->dwStructSize = dwEntrySize;

Again:
    if (!(hCacheDir = FindFirstUrlCacheEntryA("cookie:",lpCacheEntry,&dwEntrySize)))
    {
        delete [] lpCacheEntry;
        switch(GetLastError())
        {
            case ERROR_NO_MORE_ITEMS:
                goto Exit;
            case ERROR_INSUFFICIENT_BUFFER:
                lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) 
                                new BYTE[dwEntrySize];
                if( lpCacheEntry == NULL)
                {
                    bRetval = FALSE;
                    goto Exit;
                }
                lpCacheEntry->dwStructSize = dwLastEntrySize = dwEntrySize;
                goto Again;
            default:
                bRetval = FALSE;
                goto Exit;
        }
    }

    do 
    {
        if (lpCacheEntry->CacheEntryType & COOKIE_CACHE_ENTRY)
            DeleteUrlCacheEntryA(lpCacheEntry->lpszSourceUrlName);
            
        dwEntrySize = dwLastEntrySize;
Retry:
        if (!FindNextUrlCacheEntryA(hCacheDir,lpCacheEntry, &dwEntrySize))
        {
            delete [] lpCacheEntry;
            switch(GetLastError())
            {
                case ERROR_NO_MORE_ITEMS:
                    goto Exit;
                case ERROR_INSUFFICIENT_BUFFER:
                    lpCacheEntry = (LPINTERNET_CACHE_ENTRY_INFOA) 
                                    new BYTE[dwEntrySize];
                    if( lpCacheEntry == NULL)
                    {
                        bRetval = FALSE;
                        goto Exit;
                    }
                    lpCacheEntry->dwStructSize = dwLastEntrySize = dwEntrySize;
                    goto Retry;
                default:
                    bRetval = FALSE;
                    goto Exit;
            }
        }
    }
    while (TRUE);

Exit:
    if (hCacheDir)
        FindCloseUrlCache(hCacheDir);
    return bRetval;        
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\debug.cpp ===
#include "inetcplp.h"

// Define some things for debug.h
//
#define SZ_DEBUGINI         "shellext.ini"
#define SZ_DEBUGSECTION     "inetcpl"
#define SZ_MODULE           "INETCPL"
#define DECLARE_DEBUG
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\clsutil.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************

//
//  CLSUTIL.H - header file for utility C++ classes
//

//  HISTORY:
//  
//  12/07/94    jeremys     Borrowed from WNET common library
//

#ifndef _CLSUTIL_H_
#define _CLSUTIL_H_

/*************************************************************************

    NAME:       BUFFER_BASE

    SYNOPSIS:   Base class for transient buffer classes

    INTERFACE:  BUFFER_BASE()
                    Construct with optional size of buffer to allocate.

                Resize()
                    Resize buffer to specified size.  Returns TRUE if
                    successful.

                QuerySize()
                    Return the current size of the buffer in bytes.

                QueryPtr()
                    Return a pointer to the buffer.

    PARENT:     None

    USES:       None

    CAVEATS:    This is an abstract class, which unifies the interface
                of BUFFER, GLOBAL_BUFFER, etc.

    NOTES:      In standard OOP fashion, the buffer is deallocated in
                the destructor.

    HISTORY:
        03/24/93    gregj   Created base class

**************************************************************************/

class BUFFER_BASE
{
protected:
    UINT _cb;

    virtual BOOL Alloc( UINT cbBuffer ) = 0;
    virtual BOOL Realloc( UINT cbBuffer ) = 0;

public:
    BUFFER_BASE()
        { _cb = 0; }    // buffer not allocated yet
    ~BUFFER_BASE()
        { _cb = 0; }    // buffer size no longer valid
    BOOL Resize( UINT cbNew );
    UINT QuerySize() const { return _cb; };
};

#define GLOBAL_BUFFER   BUFFER

/*************************************************************************

    NAME:       BUFFER

    SYNOPSIS:   Wrapper class for new and delete

    INTERFACE:  BUFFER()
                    Construct with optional size of buffer to allocate.

                Resize()
                    Resize buffer to specified size.  Only works if the
                    buffer hasn't been allocated yet.

                QuerySize()
                    Return the current size of the buffer in bytes.

                QueryPtr()
                    Return a pointer to the buffer.

    PARENT:     BUFFER_BASE

    USES:       operator new, operator delete

    CAVEATS:

    NOTES:      In standard OOP fashion, the buffer is deallocated in
                the destructor.

    HISTORY:
        03/24/93    gregj   Created

**************************************************************************/

class BUFFER : public BUFFER_BASE
{
protected:
    TCHAR *_lpBuffer;

    virtual BOOL Alloc( UINT cbBuffer );
    virtual BOOL Realloc( UINT cbBuffer );

public:
    BUFFER( UINT cbInitial=0 );
    ~BUFFER();
    BOOL Resize( UINT cbNew );
    TCHAR * QueryPtr() const { return (TCHAR *)_lpBuffer; }
    operator TCHAR *() const { return (TCHAR *)_lpBuffer; }
};

class RegEntry
{
    public:
        RegEntry(const TCHAR *pszSubKey, HKEY hkey = HKEY_CURRENT_USER, REGSAM regsam = KEY_READ|KEY_WRITE);
        ~RegEntry();
        
        long    GetError()  { return _error; }
        long    SetValue(const TCHAR *pszValue, const TCHAR *string);
        long    SetValue(const TCHAR *pszValue, unsigned long dwNumber);
        TCHAR * GetString(const TCHAR *pszValue, TCHAR *string, unsigned long length);
        long    GetNumber(const TCHAR *pszValue, long dwDefault = 0);
        long    DeleteValue(const TCHAR *pszValue);
        long    FlushKey();
        long    MoveToSubKey(const TCHAR *pszSubKeyName);
        HKEY    GetKey()    { return _hkey; }

    private:
        HKEY    _hkey;
        long    _error;
        BOOL    bhkeyValid;
};

class RegEnumValues
{
    public:
        RegEnumValues(RegEntry *pRegEntry);
        ~RegEnumValues();
        long    Next();
        TCHAR * GetName()       {return pchName;}
        DWORD   GetType()       {return dwType;}
        LPBYTE  GetData()       {return pbValue;}
        DWORD   GetDataLength() {return dwDataLength;}
        long    GetError()  { return _error; }

    private:
        RegEntry * pRegEntry;
        DWORD   iEnum;
        DWORD   cEntries;
        TCHAR *  pchName;
        LPBYTE  pbValue;
        DWORD   dwType;
        DWORD   dwDataLength;
        DWORD   cMaxValueName;
        DWORD   cMaxData;
        LONG    _error;
};

/*************************************************************************

    NAME:       WAITCURSOR

    SYNOPSIS:   Sets the cursor to an hourclass until object is destructed

**************************************************************************/
class WAITCURSOR
{
private:
    HCURSOR m_curOld;
    HCURSOR m_curNew;

public:
    WAITCURSOR() { m_curNew = ::LoadCursor( NULL, IDC_WAIT ); m_curOld = ::SetCursor( m_curNew ); }
    ~WAITCURSOR() { ::SetCursor( m_curOld ); }
};





/*************************************************************************

    NAME:       CAccessibleWrapper

    SYNOPSIS:   Sets the cursor to an hourclass until object is destructed

**************************************************************************/

// Generic CAccessibleWrapper class - just calls through on all methods.
// Add overriding behavior in classes derived from this.

class CAccessibleWrapper: public IAccessible,
                         public IOleWindow,
                         public IEnumVARIANT
{
        // We need to do our own refcounting for this wrapper object
        ULONG          m_ref;

        // Need ptr to the IAccessible - also keep around ptrs to EnumVar and
        // OleWindow as part of this object, so we can filter those interfaces
        // and trap their QI's...
        // (We leave pEnumVar and OleWin as NULL until we need them)
        IAccessible *  m_pAcc;
        IEnumVARIANT * m_pEnumVar;
        IOleWindow *   m_pOleWin;
public:
        CAccessibleWrapper( IAccessible * pAcc );
        virtual ~CAccessibleWrapper();

        // IUnknown
        // (We do our own ref counting)
        virtual STDMETHODIMP            QueryInterface(REFIID riid, void** ppv);
        virtual STDMETHODIMP_(ULONG)    AddRef();
        virtual STDMETHODIMP_(ULONG)    Release();

        // IDispatch
        virtual STDMETHODIMP            GetTypeInfoCount(UINT* pctinfo);
        virtual STDMETHODIMP            GetTypeInfo(UINT itinfo, LCID lcid, ITypeInfo** pptinfo);
        virtual STDMETHODIMP            GetIDsOfNames(REFIID riid, OLECHAR** rgszNames, UINT cNames,
            LCID lcid, DISPID* rgdispid);
        virtual STDMETHODIMP            Invoke(DISPID dispidMember, REFIID riid, LCID lcid, WORD wFlags,
            DISPPARAMS* pdispparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo,
            UINT* puArgErr);

        // IAccessible
        virtual STDMETHODIMP            get_accParent(IDispatch ** ppdispParent);
        virtual STDMETHODIMP            get_accChildCount(long* pChildCount);
        virtual STDMETHODIMP            get_accChild(VARIANT varChild, IDispatch ** ppdispChild);

        virtual STDMETHODIMP            get_accName(VARIANT varChild, BSTR* pszName);
        virtual STDMETHODIMP            get_accValue(VARIANT varChild, BSTR* pszValue);
        virtual STDMETHODIMP            get_accDescription(VARIANT varChild, BSTR* pszDescription);
        virtual STDMETHODIMP            get_accRole(VARIANT varChild, VARIANT *pvarRole);
        virtual STDMETHODIMP            get_accState(VARIANT varChild, VARIANT *pvarState);
        virtual STDMETHODIMP            get_accHelp(VARIANT varChild, BSTR* pszHelp);
        virtual STDMETHODIMP            get_accHelpTopic(BSTR* pszHelpFile, VARIANT varChild, long* pidTopic);
        virtual STDMETHODIMP            get_accKeyboardShortcut(VARIANT varChild, BSTR* pszKeyboardShortcut);
        virtual STDMETHODIMP            get_accFocus(VARIANT * pvarFocusChild);
        virtual STDMETHODIMP            get_accSelection(VARIANT * pvarSelectedChildren);
        virtual STDMETHODIMP            get_accDefaultAction(VARIANT varChild, BSTR* pszDefaultAction);

        virtual STDMETHODIMP            accSelect(long flagsSel, VARIANT varChild);
        virtual STDMETHODIMP            accLocation(long* pxLeft, long* pyTop, long* pcxWidth, long* pcyHeight, VARIANT varChild);
        virtual STDMETHODIMP            accNavigate(long navDir, VARIANT varStart, VARIANT * pvarEndUpAt);
        virtual STDMETHODIMP            accHitTest(long xLeft, long yTop, VARIANT * pvarChildAtPoint);
        virtual STDMETHODIMP            accDoDefaultAction(VARIANT varChild);

        virtual STDMETHODIMP            put_accName(VARIANT varChild, BSTR szName);
        virtual STDMETHODIMP            put_accValue(VARIANT varChild, BSTR pszValue);

        // IEnumVARIANT
        virtual STDMETHODIMP            Next(ULONG celt, VARIANT* rgvar, ULONG * pceltFetched);
        virtual STDMETHODIMP            Skip(ULONG celt);
        virtual STDMETHODIMP            Reset(void);
        virtual STDMETHODIMP            Clone(IEnumVARIANT ** ppenum);

        // IOleWindow
        virtual STDMETHODIMP            GetWindow(HWND* phwnd);
        virtual STDMETHODIMP            ContextSensitiveHelp(BOOL fEnterMode);
};



#endif  // _CLSUTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\dlylddll.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1996               **
//*********************************************************************
//
// DLYLDDLL.H - globals for delay loading of DLLs
//

extern HINSTANCE g_hinstWinInet;
extern HINSTANCE g_hinstCrypt32;

extern HINSTANCE g_hinstCryptui;

extern HINSTANCE g_hinstRatings;
extern const TCHAR c_tszRatingsDLL[];

extern HINSTANCE g_hinstUrlMon;

extern HINSTANCE g_hinstMSHTML;
extern const TCHAR c_tszMSHTMLDLL[];

extern HINSTANCE g_hinstMPR;
extern const TCHAR c_tszMPRDLL[];

extern HINSTANCE g_hinstShdocvw;
extern const TCHAR c_tszShdocvw[];
#define URLSUB_ALL     0xFFFFFFFF

HRESULT URLSubRegQueryA(LPCSTR pszKey, LPCSTR pszValue, BOOL fUseHKCU, LPSTR pszUrlOut, DWORD cchSize, DWORD dwSubstitutions);

extern HINSTANCE g_hinstOCCache;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\dlylddll.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1996               **
//*********************************************************************
//
// DLYLDDLL.C - uses macros for delay loading of DLLs
//

#include "inetcplp.h"
#include <cryptui.h>

// coded copied from SHDOCVW's dllload.c file

#pragma warning(disable:4229)  // No warnings when modifiers used on data


// Exporting by ordinal is not available on UNIX.
// But we have all these symbols exported because it's UNIX default.
#ifdef UNIX
#define GET_PRIVATE_PROC_ADDRESS(_hinst, _fname, _ord) GetProcAddress(_hinst, #_fname)
#else
#define GET_PRIVATE_PROC_ADDRESS(_hinst, _fname, _ord) GetProcAddress(_hinst, (LPSTR) _ord)
#endif


#define ENSURE_LOADED(_hinst, _dll)   ( _hinst ? TRUE : NULL != (_hinst=LoadLibraryA(#_dll)) )
#define DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll))   \
    {                                   \
        ASSERT(_hinst); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        ASSERT(_pfn##_fn); \
        if (_pfn##_fn == NULL)      \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD(_hinst, _dll, _ret, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, _ret, _fn, _args, _nargs, 0)
#define DELAY_LOAD_HRESULT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, HRESULT, _fn, _args, _nargs, E_FAIL)
#define DELAY_LOAD_SAFEARRAY(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, SAFEARRAY *, _fn, _args, _nargs, NULL)
#define DELAY_LOAD_UINT(_hinst, _dll, _fn, _args, _nargs) DELAY_LOAD_ERR(_hinst, _dll, UINT, _fn, _args, _nargs, 0)

#define DELAY_LOAD_VOID(_hinst, _dll, _fn, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll))   \
    {                                   \
        ASSERT((BOOL)_hinst); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GetProcAddress(_hinst, #_fn); \
        ASSERT((BOOL)_pfn##_fn); \
        if (_pfn##_fn == NULL)      \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
 }



// For private entrypoints exported by ordinal.
#define DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, _err) \
_ret __stdcall _fn _args                \
{                                       \
    static _ret (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll))   \
    {                                   \
        ASSERT(_hinst); \
        return (_ret)_err;                      \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) = GET_PRIVATE_PROC_ADDRESS(_hinst, _fn, _ord); \
        ASSERT(_pfn##_fn); \
        if (_pfn##_fn == NULL)      \
            return (_ret)_err;          \
    }                                   \
    return _pfn##_fn _nargs;            \
 }

#define DELAY_LOAD_ORD_HRESULT(_hinst, _dll, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, HRESULT, _fn, _ord, _args, _nargs, E_FAIL)

#define DELAY_LOAD_ORD(_hinst, _dll, _ret, _fn, _ord, _args, _nargs) DELAY_LOAD_ORD_ERR(_hinst, _dll, _ret, _fn, _ord, _args, _nargs, 0)


#define DELAY_LOAD_VOID_ORD(_hinst, _dll, _fn, _ord, _args, _nargs) \
void __stdcall _fn _args                \
{                                       \
    static void (* __stdcall _pfn##_fn) _args = NULL;   \
    if (!ENSURE_LOADED(_hinst, _dll))   \
    {                                   \
        ASSERT((BOOL)_hinst); \
        return;                         \
    }                                   \
    if (_pfn##_fn == NULL)              \
    {                                   \
        *(FARPROC*)&(_pfn##_fn) =  GET_PRIVATE_PROC_ADDRESS(_hinst, _fn, _ord); \
        ASSERT((BOOL)_pfn##_fn); \
        if (_pfn##_fn == NULL)      \
            return;                     \
    }                                   \
    _pfn##_fn _nargs;                   \
 }

//--------- wininet.dll -----------------

HINSTANCE g_hinstWinInet = NULL;

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, InternetSetOption, 
           (IN HINTERNET hInternet OPTIONAL,IN DWORD dwOption,IN LPVOID lpBuffer,
            IN DWORD dwBufferLength),
           (hInternet,dwOption,lpBuffer,dwBufferLength));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, InternetQueryOption, 
           (IN HINTERNET hInternet OPTIONAL,IN DWORD dwOption,IN LPVOID lpBuffer,
            IN OUT LPDWORD lpdwBufferLength),
           (hInternet,dwOption,lpBuffer,lpdwBufferLength));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, DWORD, ShowX509EncodedCertificate, 
           (IN HWND    hWndParent,IN LPBYTE  lpCert,IN DWORD   cbCert),
           (hWndParent,lpCert,cbCert));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, DWORD, ParseX509EncodedCertificateForListBoxEntry,
           (IN LPBYTE  lpCert,IN DWORD  cbCert,OUT LPSTR lpszListBoxEntry,IN LPDWORD lpdwListBoxEntry),
           (lpCert,cbCert,lpszListBoxEntry,lpdwListBoxEntry));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, GetUrlCacheConfigInfoA,
           (
            OUT LPINTERNET_CACHE_CONFIG_INFOA lpCacheConfigInfo,
            IN OUT LPDWORD lpdwCacheConfigInfoBufferSize,
            IN DWORD dwFieldControl
           ),
           (lpCacheConfigInfo,lpdwCacheConfigInfoBufferSize,dwFieldControl));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, SetUrlCacheConfigInfoA,
           (
            IN LPINTERNET_CACHE_CONFIG_INFOA lpCacheConfigInfo,
            IN DWORD dwFieldControl
           ),
           (lpCacheConfigInfo,dwFieldControl));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, FreeUrlCacheSpaceA,
           (
            IN LPCSTR lpszCachePath,
            IN DWORD dwSize,
            IN DWORD dwReserved
           ),
           (lpszCachePath,dwSize,dwReserved));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, UpdateUrlCacheContentPath,
           (
            IN LPSTR lpszCachePath
           ),
           (lpszCachePath));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, FindCloseUrlCache,
           (
            IN HANDLE hEnumHandle
           ),
           (hEnumHandle));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, HANDLE, FindFirstUrlCacheEntryA,
           (
            IN     LPCSTR    lpszUrlSearchPattern,
            OUT    LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
            IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize
           ),
           (lpszUrlSearchPattern, lpFirstCacheEntryInfo, 
            lpdwFirstCacheEntryInfoBufferSize));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, FindNextUrlCacheEntryA,
           (
            IN     HANDLE    hEnumHandle,
            OUT    LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
            IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize
           ),
           (hEnumHandle, lpFirstCacheEntryInfo, 
            lpdwFirstCacheEntryInfoBufferSize));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, DeleteUrlCacheEntryA,
           (
            IN     LPCSTR    lpszUrlName
           ),
           (lpszUrlName));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, HANDLE, FindFirstUrlCacheEntryExA,
           (
            IN     LPCSTR    lpszUrlSearchPattern,
            IN     DWORD     dwFlags,
            IN     DWORD     dwFilter,
            IN     GROUPID   GroupId,
            OUT    LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
            IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize,
            OUT    LPVOID    lpReserved,     // must pass NULL
            IN OUT LPDWORD   pcbReserved2,   // must pass NULL
            IN     LPVOID    lpReserved3     // must pass NULL
           ),
           (lpszUrlSearchPattern, dwFlags, dwFilter, GroupId, lpFirstCacheEntryInfo, 
            lpdwFirstCacheEntryInfoBufferSize, lpReserved, pcbReserved2, lpReserved3));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, FindNextUrlCacheEntryExA,
           (
            IN     HANDLE    hEnumHandle,
            OUT    LPINTERNET_CACHE_ENTRY_INFOA lpFirstCacheEntryInfo,
            IN OUT LPDWORD   lpdwFirstCacheEntryInfoBufferSize,
            OUT    LPVOID    lpReserved,     // must pass NULL
            IN OUT LPDWORD   pcbReserved2,   // must pass NULL
            IN     LPVOID    lpReserved3     // must pass NULL
           ),
           (hEnumHandle, lpFirstCacheEntryInfo, lpdwFirstCacheEntryInfoBufferSize, lpReserved, pcbReserved2, lpReserved3));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, InternetGetConnectedStateExA,
            (
             OUT LPDWORD lpdwFlags,
             IN LPSTR lpszConnectionName,
             IN DWORD dwNameSize,
             IN DWORD dwReserved
            ),
            (lpdwFlags, lpszConnectionName, dwNameSize, dwReserved));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, IncrementUrlCacheHeaderData,
           (
            IN  DWORD nIdx,
            OUT LPDWORD lpdwData
           ),
           (nIdx, lpdwData));

DELAY_LOAD_ORD(g_hinstWinInet, WININET.DLL, BOOL, GetDiskInfoA, 102,
            (
             IN PSTR pszPath, 
             IN OUT PDWORD pdwClusterSize, 
             IN OUT PDWORDLONG pdlAvail, 
             IN OUT PDWORDLONG pdlTotal
            ),
            (pszPath, pdwClusterSize, pdlAvail, pdlTotal));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, DWORD, PrivacyGetZonePreferenceW,
            (
             DWORD      dwZone,
             DWORD      dwType,
             LPDWORD    pdwTemplate,
             LPWSTR     pszBuffer,
             LPDWORD    pdwBufferLength
            ),
            (dwZone, dwType, pdwTemplate, pszBuffer, pdwBufferLength));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, DWORD, PrivacySetZonePreferenceW,
            (
             DWORD      dwZone,
             DWORD      dwType,
             DWORD      dwTemplate,
             LPCWSTR    pszPreference
            ),
            (dwZone, dwType, dwTemplate, pszPreference));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, InternetEnumPerSiteCookieDecisionW,
            (
             OUT    LPWSTR pwszSiteName, 
             IN OUT unsigned long *pcbName, 
             OUT    unsigned long *pdwDecision, 
             IN     unsigned long dwIndex
            ),
            (pwszSiteName, pcbName, pdwDecision, dwIndex));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, InternetClearAllPerSiteCookieDecisions,
           (),
           ());

//BOOLAPI IsDomainLegalCookieDomainW( IN LPCWSTR pwchDomain, IN LPCWSTR pwchFullDomain)

DELAY_LOAD_ORD(g_hinstWinInet, WININET.DLL, BOOL, IsDomainLegalCookieDomainW, 117,
           (
            IN LPCWSTR pwchDomain,
            IN LPCWSTR pwchFullDomain
           ),
           (pwchDomain, pwchFullDomain));

DELAY_LOAD(g_hinstWinInet, WININET.DLL, BOOL, InternetSetPerSiteCookieDecisionW,
           (
            IN LPCWSTR pwchHostName, 
            DWORD dwDecision
           ),
           (pwchHostName, dwDecision));

//--------- urlmon.dll ------------------

HINSTANCE g_hinstUrlMon = NULL;

DELAY_LOAD(g_hinstUrlMon, URLMON.DLL, HRESULT, UrlMkSetSessionOption,
           (DWORD dwOption, LPVOID pBuffer, DWORD dwBufferLength, DWORD dwReserved),
           (dwOption, pBuffer, dwBufferLength, dwReserved));


DELAY_LOAD(g_hinstUrlMon, URLMON.DLL, HRESULT, CoInternetCreateZoneManager,
           (IServiceProvider *pSP, IInternetZoneManager **ppZM, DWORD dwReserved),
           (pSP, ppZM, dwReserved));

DELAY_LOAD(g_hinstUrlMon, URLMON.DLL, HRESULT, CoInternetCreateSecurityManager,
           (IServiceProvider *pSP, IInternetSecurityManager **ppSM, DWORD dwReserved),
           (pSP, ppSM, dwReserved));

DELAY_LOAD(g_hinstUrlMon, URLMON.DLL, HRESULT, CreateURLMoniker,
           (LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER FAR * ppmk),
           (pMkCtx,szURL,ppmk));

DELAY_LOAD(g_hinstUrlMon, URLMON.DLL, HRESULT, FaultInIEFeature,
            (HWND hWnd, uCLSSPEC *pClassSpec, QUERYCONTEXT *pQuery, DWORD dwFlags),
            (hWnd, pClassSpec, pQuery, dwFlags));

DELAY_LOAD(g_hinstUrlMon, URLMON.DLL, HRESULT, CoInternetParseUrl,
            (LPCWSTR pwzUrl, PARSEACTION ParseAction, DWORD dwFlags, LPWSTR pszResult, DWORD cchResult, DWORD *pcchResult, DWORD dwReserved),
            (pwzUrl, ParseAction, dwFlags, pszResult, cchResult, pcchResult, dwReserved));

DELAY_LOAD(g_hinstUrlMon, URLMON.DLL, HRESULT, CoInternetGetSecurityUrl,
           (LPCWSTR pwzUrl, LPWSTR *ppwzSecUrl, PSUACTION psuAction, DWORD dwReserved),
           (pwzUrl, ppwzSecUrl, psuAction, dwReserved));

DELAY_LOAD(g_hinstUrlMon, URLMON.DLL, HRESULT, GetAddSitesFileUrl,
           (LPWSTR pszUrl),
           (pszUrl));

// -------- crypt32.dll ----------------------------


HINSTANCE g_hinstCrypt32 = NULL;

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, HCERTSTORE, CertOpenSystemStoreA,
           (HCRYPTPROV hProv, LPCSTR szSubSystemProtocol),
           (hProv, szSubSystemProtocol));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL , CertCloseStore,
           (IN HCERTSTORE hCertStore, DWORD dwFlags),
           (hCertStore, dwFlags));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CertGetEnhancedKeyUsage,
           (IN PCCERT_CONTEXT pCertContext, IN DWORD dwFlags, OUT PCERT_ENHKEY_USAGE pUsage, IN OUT DWORD *pcbUsage),
           (pCertContext, dwFlags, pUsage, pcbUsage));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CertSetEnhancedKeyUsage,
           (IN PCCERT_CONTEXT pCertContext, IN PCERT_ENHKEY_USAGE pUsage),
           (pCertContext, pUsage));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CertDeleteCertificateFromStore,
           (IN PCCERT_CONTEXT pCertContext),
           (pCertContext));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CertAddEnhancedKeyUsageIdentifier,
           (IN PCCERT_CONTEXT pCertContext, IN LPCSTR pszUsageIdentifier),
           (pCertContext, pszUsageIdentifier));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CertRemoveEnhancedKeyUsageIdentifier,
           (IN PCCERT_CONTEXT pCertContext,IN LPCSTR pszUsageIdentifier),
           (pCertContext, pszUsageIdentifier));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL,  PCCERT_CONTEXT, CertFindCertificateInStore,
           (IN HCERTSTORE hCertStore, IN DWORD dwCertEncodingType, IN DWORD dwFindFlags,IN DWORD dwFindType,
            IN const void *pvFindPara, IN PCCERT_CONTEXT pPrevCertContext),
           (hCertStore, dwCertEncodingType, dwFindFlags, dwFindType, pvFindPara, pPrevCertContext));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CertAddEncodedCertificateToStore,
           (IN HCERTSTORE hCertStore,IN DWORD dwCertEncodingType,IN const BYTE *pbCertEncoded,
            IN DWORD cbCertEncoded,IN DWORD dwAddDisposition, OUT OPTIONAL PCCERT_CONTEXT *ppCertContext),
           (hCertStore, dwCertEncodingType, pbCertEncoded, cbCertEncoded, dwAddDisposition, ppCertContext));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL,  BOOL, CertFreeCertificateContext,
           (IN PCCERT_CONTEXT pCertContext),
           (pCertContext));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CertCompareCertificateName,
           (IN DWORD dwCertEncodingType,IN PCERT_NAME_BLOB pCertName1,IN PCERT_NAME_BLOB pCertName2),
           (dwCertEncodingType,pCertName1,pCertName2));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, PCCERT_CONTEXT, CertCreateCertificateContext,
           (IN DWORD dwCertEncodingType, IN const BYTE *pbCertEncoded, IN DWORD cbCertEncoded),
           (dwCertEncodingType,pbCertEncoded,cbCertEncoded));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CertAddCertificateContextToStore,
           (IN HCERTSTORE hCertStore,
            IN PCCERT_CONTEXT pCertContext,
            IN DWORD dwAddDisposition,
            OUT OPTIONAL PCCERT_CONTEXT *ppStoreContext),
           (hCertStore,pCertContext,dwAddDisposition,ppStoreContext));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, PCCERT_CONTEXT, CertEnumCertificatesInStore,
           (IN HCERTSTORE hCertStore,
            IN PCCERT_CONTEXT pPrevCertContext),
           (hCertStore,pPrevCertContext));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, PFXExportCertStore,
           (HCERTSTORE hStore,
            CRYPT_DATA_BLOB* pPFX,
            LPCWSTR szPassword,
            DWORD   dwFlags),
           (hStore,pPFX, szPassword, dwFlags));


DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, HCERTSTORE, PFXImportCertStore,
           (CRYPT_DATA_BLOB* pPFX,
            LPCWSTR szPassword,
            DWORD   dwFlags),
           (pPFX,szPassword,dwFlags));


DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, HCERTSTORE, CertOpenStore,
           (IN LPCSTR lpszStoreProvider,
            IN DWORD dwEncodingType,
            IN HCRYPTPROV hCryptProv,
            IN DWORD dwFlags,
            IN const void *pvPara),
           (lpszStoreProvider,
            dwEncodingType,
            hCryptProv,
            dwFlags,
            pvPara));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CryptHashCertificate,
           (IN HCRYPTPROV hCryptProv,
            IN ALG_ID Algid,
            IN DWORD dwFlags,
            IN const BYTE *pbEncoded,
            IN DWORD cbEncoded,
            OUT BYTE *pbComputedHash,
            IN OUT DWORD *pcbComputedHash
           ),
           (hCryptProv,Algid,dwFlags,pbEncoded,cbEncoded,pbComputedHash,pcbComputedHash));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, PCCERT_CONTEXT, CertDuplicateCertificateContext,
           (IN PCCERT_CONTEXT pCertContext),
           (pCertContext));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CertGetCertificateContextProperty,
            (IN PCCERT_CONTEXT pCertContext,
             IN DWORD dwPropId,
             OUT void *pvData,
             IN OUT DWORD *pcbData
            ),
            (pCertContext, dwPropId, pvData, pcbData));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, BOOL, CryptDecodeObject,
            (IN DWORD       dwCertEncodingType,
             IN LPCSTR      lpszStructType,
             IN const BYTE  *pbEncoded,
             IN DWORD       cbEncoded,
             IN DWORD       dwFlags,
             OUT void       *pvStructInfo,
             IN OUT DWORD   *pcbStructInfo
             ),
             (dwCertEncodingType, lpszStructType, pbEncoded, cbEncoded, dwFlags, pvStructInfo, pcbStructInfo));

DELAY_LOAD(g_hinstCrypt32, CRYPT32.DLL, PCERT_EXTENSION, CertFindExtension,
           (IN LPCSTR           pszObjId,
            IN DWORD            cExtensions,
            IN CERT_EXTENSION   rgExtensions[]
            ),
            (pszObjId, cExtensions, rgExtensions));

// -------- cryptui.dll ----------------------------

HINSTANCE g_hinstCryptui = NULL;

DELAY_LOAD(g_hinstCryptui, CRYPTUI.DLL, BOOL, CryptUIDlgCertMgr,
           (PCCRYPTUI_CERT_MGR_STRUCT pCryptUICertMgr),
           (pCryptUICertMgr));

//--------- shdocvw.dll ------------------

HINSTANCE g_hinstShdocvw = NULL;
const TCHAR c_tszShdocvw[] = TEXT("SHDOCVW.DLL");

// HRESULT URLSubRegQueryA(LPCSTR pszKey, LPCSTR pszValue, BOOL fUseHKCU, LPSTR pszUrlOut, DWORD cchSize, DWORD dwSubstitutions);
DELAY_LOAD_ORD_HRESULT(g_hinstShdocvw, SHDOCVW.DLL, URLSubRegQueryA, 151,
                       (LPCSTR pszKey, LPCSTR pszValue, BOOL fUseHKCU, LPSTR pszUrlOut, DWORD cchSize, DWORD dwSubstitutions),
                       (pszKey, pszValue, fUseHKCU, pszUrlOut, cchSize, dwSubstitutions));

// HRESULT ResetProfileSharing(HWND hwin);
DELAY_LOAD_ORD_HRESULT(g_hinstShdocvw, SHDOCVW.DLL, ResetProfileSharing, 164,
                        (HWND hwnd),
                        (hwnd));

// HRESULT ClearAutoSuggestForForms(DWORD dwClear);
DELAY_LOAD_ORD_HRESULT(g_hinstShdocvw, SHDOCVW.DLL, ClearAutoSuggestForForms, 211,
                        (DWORD dwClear),
                        (dwClear));

// HRESULT ResetWebSettings(HWND hwnd)
DELAY_LOAD_ORD_HRESULT(g_hinstShdocvw, SHDOCVW.DLL, ResetWebSettings, 223,
                        (HWND hwnd, BOOL *pfChangedHomePage),
                        (hwnd,pfChangedHomePage));

DELAY_LOAD( g_hinstShdocvw, SHDOCVW.DLL, BOOL, 
            ImportPrivacySettings,
            (LPCWSTR szFilename),
            (szFilename));

#ifdef UNIX_FEATURE_ALIAS
DELAY_LOAD_ORD_HRESULT(g_hinstShdocvw, SHDOCVW.DLL, RefreshGlobalAliasList, 164,
                        (),
                        ());
#endif /* UNIX_FEATURE_ALIAS */

//--------- msrating.dll ----------------

HINSTANCE g_hinstRatings = NULL;
const TCHAR c_tszRatingsDLL[] = TEXT("MSRATING.DLL");

DELAY_LOAD(g_hinstRatings, MSRATING.DLL, HRESULT, RatingEnable,
           (HWND hwndParent, LPCSTR pszUsername, BOOL fEnable),
           (hwndParent,pszUsername,fEnable));


DELAY_LOAD(g_hinstRatings, MSRATING.DLL, HRESULT, RatingSetupUI,
           (HWND hDlg, LPCSTR pszUsername),
           (hDlg, pszUsername));

DELAY_LOAD(g_hinstRatings, MSRATING.DLL, HRESULT, RatingEnabledQuery,
           (), ());

// --------- mshtml.dll --------------------

HINSTANCE g_hinstMSHTML = NULL;
const TCHAR c_tszMSHTMLDLL[] = TEXT("MSHTML.DLL");

DELAY_LOAD(g_hinstMSHTML, MSHTML.DLL, HRESULT, ShowModalDialog,
           (HWND hwndParent, IMoniker *pmk, VARIANT *pvarArgIn, TCHAR* pchOptions, VARIANT *pvarArgOut),
           (hwndParent,pmk,pvarArgIn,pchOptions,pvarArgOut));

//
//         We don't need to delay load anything from MSHTML, 
//         but we are using this still to determine if 
//         MSHTML.DLL is around.
//


HINSTANCE g_hinstOCCache = NULL;

DELAY_LOAD_HRESULT(g_hinstOCCache, OCCache.DLL, RemoveExpiredControls,
                   (DWORD dwFlags, DWORD dwReserved),
                   ( dwFlags, dwReserved));

// --------- mpr.dll --------------------

HINSTANCE g_hinstMPR = NULL;
const TCHAR c_tszMPRDLL[] = TEXT("MPR.DLL");

#ifndef UNICODE
DELAY_LOAD(g_hinstMPR, MPR.DLL, DWORD, WNetGetConnectionA,
           (LPCSTR pszLocalDevice, LPSTR pszUNC, LPDWORD pcbUNC),
           (pszLocalDevice, pszUNC, pcbUNC));
#else
DELAY_LOAD(g_hinstMPR, MPR.DLL, DWORD, WNetGetConnectionW,
           (LPCTSTR pszLocalDevice, LPTSTR pszUNC, LPDWORD pcbUNC),
           (pszLocalDevice, pszUNC, pcbUNC));
#endif
// ---------- end of DLL definitions --------

#pragma warning(default:4229)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\inetcpl.inc ===
#
# Common makefile include for this project
#

!include $(CCSHELL_DIR)\common.inc

C_DEFINES       = $(C_DEFINES) \
                  -DMLUI_SUPPORT \
                  -DMLUI_MESSAGEBOX \

!if !defined(TARGET_WIN95)
USE_NEW_COMMCTRL=1
!endif

!if defined(USE_NEW_COMMCTRL)
C_DEFINES= $(C_DEFINES) -DUXCTRL_VERSION=0x0100
!endif


SOURCES_USED    =  $(SOURCES_USED) $(CCSHELL_DIR)\common.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\fonts.cpp ===
//
// FONTS.C  - Selecting character set default fonts dialog
//
//      Copyright(c) Microsoft Corp., 1996 All rights reserved.
//
// History:
// 7/11/96  t-gpease    trashed old International subdialog to create the new
//                      improved codepage compatiable Fonts dialog.

// WAS

//
//  INTL.C - international dialog proc for inetcpl applet.
// 
//      Copyright(c) Microsoft Corp., 1996  All rights reserved.
//
//  HISTORY:
//  2/2/96  yutakan     created.
//  2/6/96  yutakan     ported most of functions from IE2.0i.
//  8/20/98 weiwu       add script base font dialog proc (UNICODE version only)

#include "inetcplp.h"

#include <mlang.h>
#include <mluisupp.h>

#ifdef UNIX
#include <mainwin.h>
#endif /*UNIX */

// Used for window property to remember the font created
static const TCHAR c_szPropDlgFont[] = TEXT("DefaultDlgFont");

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#ifdef UNICODE
PMIMECPINFO g_pCPInfo   = NULL;
#else
PMIMECPINFO g_pCPInfoW = NULL;

typedef struct tagMIMECPINFOA
{
    DWORD   dwFlags;
    UINT    uiCodePage;
    UINT    uiFamilyCodePage;
    CHAR    wszDescription[MAX_MIMECP_NAME];        // NOTE: 
    CHAR    wszWebCharset[MAX_MIMECSET_NAME];       // To make it simple, it has wsz 
    CHAR    wszHeaderCharset[MAX_MIMECSET_NAME];    // prefix even though it's CHAR. So,
    CHAR    wszBodyCharset[MAX_MIMECSET_NAME];      //  we don't need to put #ifdef UNICODE
    CHAR    wszFixedWidthFont[MAX_MIMEFACE_NAME];   // in below code anymore except 
    CHAR    wszProportionalFont[MAX_MIMEFACE_NAME]; // conversion time.
    BYTE    bGDICharset;                               
} MIMECPINFOA, *PMIMECPINFOA;

PMIMECPINFOA g_pCPInfo = NULL;
#endif

ULONG g_cCPInfo     = 0;
ULONG g_cSidInfo    = 0;
IMLangFontLink2     *g_pMLFlnk2 = NULL;

typedef HRESULT (* PCOINIT) (LPVOID);
typedef VOID (* PCOUNINIT) (VOID);
typedef VOID (* PCOMEMFREE) (LPVOID);
typedef HRESULT (* PCOCREINST) (REFCLSID, LPUNKNOWN, DWORD,     REFIID, LPVOID * );

extern HMODULE hOLE32;
extern PCOINIT pCoInitialize;
extern PCOUNINIT pCoUninitialize;
extern PCOMEMFREE pCoTaskMemFree;
extern PCOCREINST pCoCreateInstance;

BOOL _StartOLE32();

#define IsVerticalFont(p)    (*(p) == '@')

typedef struct {
    TCHAR   szPropFont[MAX_MIMEFACE_NAME];
    TCHAR   szFixedFont[MAX_MIMEFACE_NAME];
    TCHAR   szFriendlyName[MAX_MIMECP_NAME];
    TCHAR   szMIMEFont[MAX_MIMECP_NAME];
    DWORD   dwFontSize;
}   CODEPAGEDATA;

typedef struct {
    HWND    hDlg;
    HWND    hwndPropCB;
    HWND    hwndFixedCB;
    HWND    hwndSizeCB;
    HWND    hwndMIMECB;
    HWND    hwndNamesLB;

    DWORD   dwDefaultCodePage;

    BOOL    bChanged;

    CODEPAGEDATA    *page;

    LPCTSTR lpszKeyPath;

}   FONTSDATA, *LPFONTSDATA;


typedef struct {
    HWND        hDlg;
    HWND        hwndPropLB;
    HWND        hwndFixedLB;
    HWND        hwndNamesCB;

    SCRIPT_ID   sidDefault;

    BOOL        bChanged;

    PSCRIPTINFO pSidInfo;

    LPCTSTR     lpszKeyPath;

}   FONTSCRIPTDATA, *LPFONTSCRIPTDATA;

const struct {
    SCRIPT_ID   Sid;
    BYTE        nCharSet;
    UINT        uiCp;
} g_CharSetTransTable[] = 
{
    sidAsciiLatin,  ANSI_CHARSET,       1252,
    sidLatin,       ANSI_CHARSET,       1252,   
    sidCyrillic,    RUSSIAN_CHARSET,    1251,
    sidGreek,       GREEK_CHARSET,      1253,
    sidHebrew,      HEBREW_CHARSET,     1255,
    sidArabic,      ARABIC_CHARSET,     1256,
    sidThai,        THAI_CHARSET,       874,
    sidKana,        SHIFTJIS_CHARSET,   932,
    sidHan,         GB2312_CHARSET,     936,
    sidBopomofo,    CHINESEBIG5_CHARSET,950,
    sidHangul,      HANGEUL_CHARSET,    949,
};

//
// Map script ID to charset
// We should use MLang service when it is available
//
BYTE CharSetFromSid(SCRIPT_ID Sid)
{
    for (int i=0; i<ARRAYSIZE(g_CharSetTransTable); i++)
    {
        if (Sid == g_CharSetTransTable[i].Sid)
            return g_CharSetTransTable[i].nCharSet;
    }

    return DEFAULT_CHARSET;
}

// SHLWAPI StrCmp/StrCmpI doesn't work.
// Make this simple function to tell if string is equal in character value
BOOL IsStringEqual(LPCTSTR lpString1, LPCTSTR lpString2)
{
    
    if (lstrlen(lpString1) != lstrlen(lpString2))
        return FALSE;

    while(*lpString1 && *lpString2)
    {
        if (*lpString1 != *lpString2)
        {
            return FALSE;
        }
        lpString1++;
        lpString2++;
    }

    return TRUE;
}

//
// Initialize script table with resource string
//
BOOL InitScriptTable(LPFONTSCRIPTDATA pFnt)
{

    HRESULT hr;
    BOOL    bRet = FALSE;
    IMultiLanguage2 *   pML2;

    ASSERT(IS_VALID_CODE_PTR(pCoInitialize, PCOINIT));
    ASSERT(IS_VALID_CODE_PTR(pCoUninitialize, PCOUNINIT));
    ASSERT(IS_VALID_CODE_PTR(pCoTaskMemFree, PCOMEMFREE));
    ASSERT(IS_VALID_CODE_PTR(pCoCreateInstance, PCOCREINST));

    hr = pCoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (LPVOID *) &pML2);

    if (SUCCEEDED(hr))
    {
        hr = pML2->QueryInterface(IID_IMLangFontLink2, (LPVOID *) &g_pMLFlnk2);

        if (SUCCEEDED(hr))
        {
            IEnumScript *pEnumScript;

            if (SUCCEEDED(pML2->EnumScripts(SCRIPTCONTF_SCRIPT_USER, INETCPL_GetUILanguage(), &pEnumScript)))
            {
                UINT cNum = 0;

                pML2->GetNumberOfScripts(&cNum);

                pFnt->pSidInfo = (PSCRIPTINFO)LocalAlloc(LPTR, sizeof(SCRIPTINFO) * cNum);
                if (NULL != pFnt->pSidInfo)
                {
                    hr = pEnumScript->Next(cNum, pFnt->pSidInfo, &g_cSidInfo);
                    if (SUCCEEDED(hr))
                    {
                        bRet = TRUE;
                    }
                    else
                    {
                        LocalFree(pFnt->pSidInfo);
                        pFnt->pSidInfo = NULL;
                    }
                }
                pEnumScript->Release();
            }
        }

        if (pML2)
            pML2->Release();
    }

    return bRet;
}

//
// DrawSampleString()
//
// Draw the sample string with current font
//

void DrawSampleString(LPFONTSDATA pFnt, int idSample, LPCTSTR lpFace, SCRIPT_ID ScriptId)
{
    HDC hDC;
    HFONT hFont, hTemp;
    LOGFONT lf = {0};
    DWORD rgbText, rgbBack;
    RECT rc;
    SIZE TextExtent;
    TEXTMETRIC tm;
    int len, x, y;
    TCHAR szFontSample[1024];

    if (!lpFace)
        return;

    MLLoadString(IDS_FONT_SAMPLE_DEFAULT+ScriptId, szFontSample, ARRAYSIZE(szFontSample));

    GetWindowRect(GetDlgItem(pFnt->hDlg, idSample), &rc);
    // Use MapWindowPoints() as it works for mirrored windows as well.
    MapWindowRect(NULL, pFnt->hDlg, &rc);  
    // ScreenToClient(pFnt->hDlg, (LPPOINT)&rc.left);
    // ScreenToClient(pFnt->hDlg, (LPPOINT)&rc.right);

    hDC = GetDC(pFnt->hDlg);

    rgbBack = SetBkColor(hDC, GetSysColor(COLOR_3DFACE));
    rgbText = GetSysColor(COLOR_WINDOWTEXT);
    rgbText = SetTextColor(hDC, rgbText);

    hFont = GetWindowFont(pFnt->hDlg);
    GetObject(hFont, sizeof(LOGFONT), &lf);

    lf.lfCharSet = CharSetFromSid(ScriptId);
    lf.lfHeight += lf.lfHeight/2;
    lf.lfWidth += lf.lfWidth/2;

    StrCpyN(lf.lfFaceName, lpFace, LF_FACESIZE);
    hFont = CreateFontIndirect(&lf);
    hTemp = (HFONT)SelectObject(hDC, hFont);

    GetTextMetrics(hDC, &tm);

    len = lstrlen(szFontSample);
    
    GetTextExtentPoint32(hDC, szFontSample, len, &TextExtent);
    TextExtent.cy = tm.tmAscent - tm.tmInternalLeading;

    DrawEdge(hDC, &rc, BDR_SUNKENOUTER, BF_RECT | BF_ADJUST);

    if ((TextExtent.cx >= (rc.right - rc.left)) || (TextExtent.cx <= 0))
        x = rc.left;
    else
        x = rc.left + ((rc.right - rc.left) - TextExtent.cx) / 2;

    y = min(rc.bottom, rc.bottom - ((rc.bottom - rc.top) - TextExtent.cy) / 2);

    if (lpFace[0])
        ExtTextOut(hDC, x, y - (tm.tmAscent), ETO_OPAQUE | ETO_CLIPPED,
                &rc, szFontSample, len, NULL );
    else
        ExtTextOut(hDC, x, y - (tm.tmAscent), ETO_OPAQUE | ETO_CLIPPED,
               &rc, TEXT(" "), 1, NULL );

    SetBkColor(hDC, rgbBack);
    SetTextColor(hDC, rgbText);

    if (hTemp)
        DeleteObject(SelectObject(hDC, hTemp));

    ReleaseDC(pFnt->hDlg, hDC);
}


//
// FillCharsetListBoxes()
//
// Fills the Web page and Plain text ListBoxes with the appropriate
// font data
//
BOOL FillScriptListBoxes(LPFONTSCRIPTDATA pFnt, SCRIPT_ID sid)
{

    
    UINT    i;
    UINT    nFonts = 0;
    int     iSidInfo = -1;
    PSCRIPTFONTINFO pSidFont = NULL;

    if (!pFnt->pSidInfo)
        return FALSE;

    // erase all the listboxes to start fresh
    SendMessage(pFnt->hwndPropLB,  LB_RESETCONTENT, 0, 0);
    SendMessage(pFnt->hwndFixedLB, LB_RESETCONTENT, 0, 0);


    for(i=0; i < g_cSidInfo; i++)
    {
        if (pFnt->pSidInfo[i].ScriptId == sid)
        {
            iSidInfo = i; 
            break;
        }
    }

    if (-1 == iSidInfo)
        return FALSE;

    if (g_pMLFlnk2)
    {

        g_pMLFlnk2->GetScriptFontInfo(sid, SCRIPTCONTF_PROPORTIONAL_FONT, &nFonts, NULL);

        if (nFonts)
        {            

            pSidFont = (PSCRIPTFONTINFO) LocalAlloc(LPTR, sizeof(SCRIPTFONTINFO)*nFonts);
            if (pSidFont)
            {
                g_pMLFlnk2->GetScriptFontInfo(sid, SCRIPTCONTF_PROPORTIONAL_FONT, &nFonts, pSidFont);
                for (i=0; i<nFonts; i++)
                {
                    if (LB_ERR == SendMessage(pFnt->hwndPropLB, LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)((pSidFont+i)->wszFont)))
                    {
                        // add the font name to the combobox
                        SendMessage(pFnt->hwndPropLB, LB_ADDSTRING, 0, (LPARAM)((pSidFont+i)->wszFont));
                    }

                }
                // Hack PRC font problems on Win9x and NT4 (Bug #24641, #39946)
                // Win9x does not ship with GBK-supporting fixed-pitch fonts,
                // We provide user proportional fonts as plain text font candidates.
                if (sid == sidHan && GetACP() == 936 && !IsOS(OS_WIN2000ORGREATER))
                {
                    for (i=0; i<nFonts; i++)
                    {
                        // add the font name to the combobox
                        SendMessage(pFnt->hwndFixedLB, LB_ADDSTRING, 0, (LPARAM)((pSidFont+i)->wszFont));
                    }
                }

                LocalFree(pSidFont);
                pSidFont = NULL;
            }
        }

        // Get number of available fonts
        g_pMLFlnk2->GetScriptFontInfo(sid, SCRIPTCONTF_FIXED_FONT, &nFonts, NULL);
        if (nFonts)
        {
            pSidFont = (PSCRIPTFONTINFO) LocalAlloc(LPTR, sizeof(SCRIPTFONTINFO)*nFonts);
            if (pSidFont)
            {
                g_pMLFlnk2->GetScriptFontInfo(sid, SCRIPTCONTF_FIXED_FONT, &nFonts, pSidFont);

                if (!pFnt->pSidInfo[iSidInfo].wszFixedWidthFont[0])
                {
                    StrCpyN(pFnt->pSidInfo[iSidInfo].wszFixedWidthFont, pSidFont->wszFont, LF_FACESIZE);
                    pFnt->bChanged = TRUE;
                }

                // All fixedwidth and proportional fonts are web page font candidates
                for (i=0; i<nFonts; i++)
                {
                    if (LB_ERR == SendMessage(pFnt->hwndFixedLB, LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)((pSidFont+i)->wszFont)))
                    {
                        // add the font name to the combobox
                        SendMessage(pFnt->hwndFixedLB, LB_ADDSTRING, 0, (LPARAM)((pSidFont+i)->wszFont));
                    }
                    if (LB_ERR == SendMessage(pFnt->hwndPropLB, LB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)((pSidFont+i)->wszFont)))
                    {
                        // add the font name to the combobox
                        SendMessage(pFnt->hwndPropLB, LB_ADDSTRING, 0, (LPARAM)((pSidFont+i)->wszFont));
                    }
                }

                LocalFree(pSidFont);
            }
        }
    }



    // Add fonts to combobox

#ifdef UNIX
    /* We would have called EnumFontFamiliesEx wherein we would have
     * have populated the fonts list boxes with substitute fonts if any
     *
     * So, before we populate the proportional and the fixed fonts below,
     * we must query and use substitute fonts if avbl.
     */
     {
        CHAR szSubstFont[MAX_MIMEFACE_NAME+1];
        DWORD cchSubstFont = MAX_MIMEFACE_NAME + 1;
        CHAR szFont[MAX_MIMEFACE_NAME + 1];
           
        WideCharToMultiByte(CP_ACP, 0, pFnt->pSidInfo[iSidInfo].wszProportionalFont, -1, szFont, 
               MAX_MIMEFACE_NAME + 1, NULL, NULL);
        if ((ERROR_SUCCESS == MwGetSubstituteFont(szFont, szSubstFont, &cchSubstFont)) && 
            cchSubstFont) 
        {
            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szSubstFont, -1, 
               pFnt->pSidInfo[iSidInfo].wszProportionalFont, MAX_MIMEFACE_NAME + 1);
        }

        WideCharToMultiByte(CP_ACP, 0, pFnt->pSidInfo[iSidInfo].wszFixedWidthFont, -1, szFont, 
               MAX_MIMEFACE_NAME + 1, NULL, NULL);
        cchSubstFont = MAX_MIMEFACE_NAME + 1;
        if ((ERROR_SUCCESS == MwGetSubstituteFont(szFont, szSubstFont, &cchSubstFont)) && 
            cchSubstFont) 
        {
            MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szSubstFont, -1, 
               pFnt->pSidInfo[iSidInfo].wszFixedWidthFont, MAX_MIMEFACE_NAME + 1);
        }
    }
#endif /* UNIX */

    // select the current prop default
    if (pFnt->pSidInfo[iSidInfo].wszProportionalFont[0])
    {
        if (LB_ERR == SendMessage(pFnt->hwndPropLB, LB_SELECTSTRING, (WPARAM)-1,
            (LPARAM)pFnt->pSidInfo[iSidInfo].wszProportionalFont))
            pFnt->pSidInfo[iSidInfo].wszProportionalFont[0] = 0;
    }
    // Draw sample strings with current font
    DrawSampleString((FONTSDATA *)pFnt, IDC_FONTS_PROP_SAMPLE, pFnt->pSidInfo[iSidInfo].wszProportionalFont, pFnt->pSidInfo[iSidInfo].ScriptId);

    // select the current fixed default
    if (pFnt->pSidInfo[iSidInfo].wszFixedWidthFont[0])
    {
        if (LB_ERR == SendMessage(pFnt->hwndFixedLB, LB_SELECTSTRING, (WPARAM)-1,
            (LPARAM)pFnt->pSidInfo[iSidInfo].wszFixedWidthFont))
            pFnt->pSidInfo[iSidInfo].wszFixedWidthFont[0] = 0;
    }
    // Draw sample strings with current font
    DrawSampleString((FONTSDATA *)pFnt, IDC_FONTS_FIXED_SAMPLE, pFnt->pSidInfo[iSidInfo].wszFixedWidthFont, pFnt->pSidInfo[iSidInfo].ScriptId);


    // we handled it
    return TRUE;


}   // FillScriptListBoxes()

//
// FontsDlgInitEx()
//
// Initializes the script based font dialog, use same dialog box template.
//
BOOL FontsDlgInitEx(IN HWND hDlg, LPCTSTR lpszKeyPath)
{
    HKEY    hkey;
//  DWORD   dw;
    DWORD   cb;
    DWORD   i;

    TCHAR   szKey[1024];

    LPFONTSCRIPTDATA  pFnt;  // localize data

    if (!hDlg)
        return FALSE;   // nothing to initialize

    // get some space to store local data
    // NOTE: LocalAlloc already zeroes the memory
    pFnt = (LPFONTSCRIPTDATA)LocalAlloc(LPTR, sizeof(*pFnt));
    if (!pFnt)
    {
        EndDialog(hDlg, 0);
        return FALSE;
    }

    if (!InitScriptTable(pFnt))
    {
        EndDialog(hDlg, 0);
        return FALSE;
    }

    // associate the memory with the dialog window
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pFnt);

    // save the dialog handle
    pFnt->hDlg = hDlg;

    // get the dialog items
    pFnt->hwndPropLB  = GetDlgItem(pFnt->hDlg, IDC_FONTS_PROP_FONT_LIST);
    pFnt->hwndFixedLB = GetDlgItem(pFnt->hDlg, IDC_FONTS_FIXED_FONT_LIST);
    pFnt->hwndNamesCB = GetDlgItem(pFnt->hDlg, IDC_FONTS_CHAR_SET_COMBO);
    pFnt->lpszKeyPath = lpszKeyPath ? lpszKeyPath: REGSTR_PATH_INTERNATIONAL_SCRIPTS;

    if (!g_pMLFlnk2 || FAILED(g_pMLFlnk2->CodePageToScriptID(GetACP(), &(pFnt->sidDefault))))
        pFnt->sidDefault = sidAsciiLatin;
    
    // We shouldn't consider default script in registry since we no longer have UI to allow user to change default script
#if 0    
    // get values from registry
    if (RegOpenKeyEx(HKEY_CURRENT_USER, pFnt->lpszKeyPath, NULL, KEY_READ, &hkey)
        == ERROR_SUCCESS)
    {
        cb = sizeof(dw);
        if (RegQueryValueEx(hkey, REGSTR_VAL_DEFAULT_SCRIPT, NULL, NULL, (LPBYTE)&dw, &cb)
          == ERROR_SUCCESS)
        {
            pFnt->sidDefault = (SCRIPT_ID)dw;
        }
        RegCloseKey(hkey);
    }
#endif

    for (i = 0; i < g_cSidInfo; i++)
    {
        wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("%s\\%u"), pFnt->lpszKeyPath, pFnt->pSidInfo[i].ScriptId);
        if (RegOpenKeyEx(HKEY_CURRENT_USER, szKey, NULL, KEY_READ, &hkey) == ERROR_SUCCESS)
        {
            TCHAR szFont[MAX_MIMEFACE_NAME];

            cb = sizeof(szFont);

            if (RegQueryValueEx(hkey, REGSTR_VAL_FIXED_FONT, NULL, NULL,
                    (LPBYTE)szFont, &cb) == ERROR_SUCCESS)
            {
                StrCpyN(pFnt->pSidInfo[i].wszFixedWidthFont, szFont, ARRAYSIZE(pFnt->pSidInfo[i].wszFixedWidthFont));
            }
            
            cb = sizeof(szFont);
            if (RegQueryValueEx(hkey, REGSTR_VAL_PROP_FONT, NULL, NULL,
                    (LPBYTE)szFont, &cb) == ERROR_SUCCESS)
            {
                StrCpyN(pFnt->pSidInfo[i].wszProportionalFont, szFont, ARRAYSIZE(pFnt->pSidInfo[i].wszProportionalFont));
            }
            RegCloseKey(hkey);

        }

        // add the name to the listbox
        SendMessage(pFnt->hwndNamesCB, CB_ADDSTRING, 0, 
            (LPARAM)pFnt->pSidInfo[i].wszDescription);

        // check to see if it is the default code page
        if (pFnt->sidDefault == pFnt->pSidInfo[i].ScriptId)
        {
            SendMessage(pFnt->hwndNamesCB, CB_SELECTSTRING, (WPARAM)-1, (LPARAM)pFnt->pSidInfo[i].wszDescription);
        }

    }

    pFnt->bChanged = FALSE;

    FillScriptListBoxes(pFnt, pFnt->sidDefault);
    

    if( g_restrict.fFonts )
    {
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_PROP_FONT_LIST ), FALSE);
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_FIXED_FONT_LIST ), FALSE);
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_CHAR_SET_COMBO ), FALSE);
#ifdef UNIX
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_UPDATE_BUTTON ), FALSE);
#endif
    }

    // everything ok
    return TRUE;

}   // FontsDlgInit()

//
// SaveFontsDataEx()
//
// Save the new fonts settings into regestry
//
void SaveFontsDataEx(LPFONTSCRIPTDATA pFnt)
{
    HKEY    hkeyScript;
    TCHAR   szScript[MAX_SCRIPT_NAME];

    HKEY    hkey;
    DWORD   dw;

    // get values from registry
    if (RegCreateKeyEx(HKEY_CURRENT_USER, pFnt->lpszKeyPath, NULL, NULL, NULL, KEY_WRITE, NULL, &hkey, &dw)
        == ERROR_SUCCESS)
    {
        UINT i;
 
        RegSetValueEx(hkey, REGSTR_VAL_DEFAULT_SCRIPT, NULL, REG_BINARY, (LPBYTE)&pFnt->sidDefault, sizeof(pFnt->sidDefault));
        
        for(i = 0; i < g_cSidInfo; i++)
        {
            wnsprintf(szScript, ARRAYSIZE(szScript), TEXT("%u"), pFnt->pSidInfo[i].ScriptId);
            if (RegCreateKeyEx(hkey, szScript, NULL, NULL, NULL, KEY_WRITE, NULL, &hkeyScript, &dw) == ERROR_SUCCESS)
            {
                // Currently, no need for script name, save registry space
#if 0
                RegSetValueEx(hkeyScript, REGSTR_VAL_FONT_SCRIPT_NAME, NULL, REG_SZ,
                            (LPBYTE)&pFnt->pSidInfo[i].wszDescription, 
                            (lstrlen(pFnt->pSidInfo[i].wszDescription)+1)*sizeof(TCHAR));
#endif
                    
                RegSetValueEx(hkeyScript, REGSTR_VAL_SCRIPT_FIXED_FONT, NULL, REG_SZ,
                            (LPBYTE)pFnt->pSidInfo[i].wszFixedWidthFont, 
                            (lstrlen(pFnt->pSidInfo[i].wszFixedWidthFont)+1)*sizeof(TCHAR));
                    
                RegSetValueEx(hkeyScript, REGSTR_VAL_SCRIPT_PROP_FONT, NULL, REG_SZ,
                            (LPBYTE)pFnt->pSidInfo[i].wszProportionalFont, 
                            (lstrlen(pFnt->pSidInfo[i].wszProportionalFont)+1)*sizeof(TCHAR));

                RegCloseKey(hkeyScript);
                    
            }   // if RegCreateKeyEx


        }   // for

        RegCloseKey(hkey);
  
    }   // if RegCreateKeyEx

}   // SaveFontsDataEx()

//
// FontsOnCommandEx()
//
// Handles WM_COMMAND message for the script based Fonts subdialog
//
BOOL FontsOnCommandEx(LPFONTSCRIPTDATA pFnt, UINT id, UINT nCmd)
{
    switch(id)
    {
        case IDOK:
            if (pFnt->bChanged)
            {
                SaveFontsDataEx(pFnt);
                
                // tell MSHTML to pick up changes and update
                UpdateAllWindows();
            }
            return TRUE;    // exit dialog

        case IDCANCEL:
            return TRUE;    // exit dialog

        case IDC_FONTS_PROP_FONT_LIST:
        case IDC_FONTS_FIXED_FONT_LIST:
            if (nCmd==LBN_SELCHANGE)
            {
                UINT i;
                TCHAR   szScript[MAX_SCRIPT_NAME];

                pFnt->bChanged = TRUE;  // we need to save
                
                // find the currently selected item in the list box
                GetDlgItemText(pFnt->hDlg, IDC_FONTS_CHAR_SET_COMBO, szScript, ARRAYSIZE(szScript));
                
                // find the code page from the text
                for(i=0; i < g_cSidInfo; i++)
                {
                    INT_PTR j;
                    if (IsStringEqual(szScript, pFnt->pSidInfo[i].wszDescription))
                    {             
                        // grab the new values
                        j = SendMessage(pFnt->hwndPropLB, LB_GETCURSEL, 0, 0);
                        SendMessage(pFnt->hwndPropLB, LB_GETTEXT, j, (LPARAM)(pFnt->pSidInfo[i].wszProportionalFont));
                        j = SendMessage(pFnt->hwndFixedLB, LB_GETCURSEL, 0, 0);
                        SendMessage(pFnt->hwndFixedLB, LB_GETTEXT, j, (LPARAM)(pFnt->pSidInfo[i].wszFixedWidthFont));
                        break;
                    }
                }

                // Redraw sample strings                
                DrawSampleString((LPFONTSDATA)pFnt, IDC_FONTS_PROP_SAMPLE, pFnt->pSidInfo[i].wszProportionalFont, pFnt->pSidInfo[i].ScriptId);
                DrawSampleString((LPFONTSDATA)pFnt, IDC_FONTS_FIXED_SAMPLE, pFnt->pSidInfo[i].wszFixedWidthFont, pFnt->pSidInfo[i].ScriptId);

                // if we don't find it... we are going to keep the default

                ASSERT(i < g_cSidInfo);  // something went wrong

            }
            break;

        case IDC_FONTS_CHAR_SET_COMBO:
            if (nCmd==CBN_SELCHANGE)
            {
                UINT i;
                TCHAR   szScript[MAX_SCRIPT_NAME];

                GetDlgItemText(pFnt->hDlg, IDC_FONTS_CHAR_SET_COMBO, szScript, ARRAYSIZE(szScript));
                
                // find the code page from the text
                for(i=0; i < g_cSidInfo; i++)
                {
                    if (IsStringEqual(szScript, pFnt->pSidInfo[i].wszDescription))
                    {
                        FillScriptListBoxes(pFnt, pFnt->pSidInfo[i].ScriptId);
                        break;
                    }
                }
            }
            break;
#ifdef UNIX
        case IDC_FONTS_UPDATE_BUTTON: 
    {
        HCURSOR hOldCursor = NULL;
        HCURSOR hNewCursor = NULL;

        hNewCursor = LoadCursor(NULL, IDC_WAIT);
        if (hNewCursor) 
            hOldCursor = SetCursor(hNewCursor);

        DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_FONTUPD_PROG), pFnt->hDlg,FontUpdDlgProc, NULL);

        if(hOldCursor)
            SetCursor(hOldCursor);
    }
        break; 
#endif
    }
    
    // don't exit dialog
    return FALSE;
}

//
// FontsDlgProcEx()
//
// Message handler for the script based "Fonts" subdialog.
//
INT_PTR CALLBACK FontsDlgProcEx(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPFONTSCRIPTDATA pFnt = (LPFONTSCRIPTDATA) GetWindowLongPtr(hDlg, DWLP_USER);
    PAINTSTRUCT ps;

    switch (uMsg)
    {
        case WM_INITDIALOG:
            return FontsDlgInitEx(hDlg, (LPTSTR)lParam);
            break;

        case WM_DESTROY:
            // Free memory
            if (pFnt)
            {
                if (pFnt->pSidInfo)
                    LocalFree(pFnt->pSidInfo);
                LocalFree(pFnt);
            }

            break;
            
        case WM_PAINT:

            if (BeginPaint(hDlg, &ps))
            {
                UINT i;
                SCRIPT_ID sid = 0;
                TCHAR szScript[MAX_SCRIPT_NAME];

                GetDlgItemText(hDlg, IDC_FONTS_CHAR_SET_COMBO, szScript, ARRAYSIZE(szScript));
                
                // find the script id from the text
                for(i = 0; i < g_cSidInfo; i++)
                {
                    if (IsStringEqual(szScript, pFnt->pSidInfo[i].wszDescription))
                    {
                        sid = pFnt->pSidInfo[i].ScriptId;
                        break;
                    }
                }


                if (i < g_cSidInfo)
                {
                    // show sample strings with current font
                    DrawSampleString((LPFONTSDATA)pFnt, IDC_FONTS_PROP_SAMPLE, pFnt->pSidInfo[i].wszProportionalFont, pFnt->pSidInfo[i].ScriptId);
                    DrawSampleString((LPFONTSDATA)pFnt, IDC_FONTS_FIXED_SAMPLE, pFnt->pSidInfo[i].wszFixedWidthFont, pFnt->pSidInfo[i].ScriptId);
                }
                EndPaint(hDlg, &ps);
            }
            break;

        case WM_COMMAND:
            if (FontsOnCommandEx(pFnt, LOWORD(wParam), HIWORD(wParam)))
                EndDialog(hDlg, LOWORD(wParam) == IDOK? 1: 0);
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:    // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);        
            break;

#ifdef UNIX
        case WM_DRAWITEM:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
            case IDC_FONTS_UPDATE_BUTTON:
            DrawXFontButton(hDlg, (LPDRAWITEMSTRUCT)lParam);
            return TRUE;
        }
        return FALSE;
#endif

        default:
            return FALSE;
    }
    return TRUE;
}


//
// Back out old font dialog for OE4
//



//
// InitMimeCsetTable()
//
// Initialize MimeCharsetTable[]'s string field with resource string
//
BOOL InitMimeCsetTable(BOOL bIsOE5)
{
    IMultiLanguage *pML=NULL;
    IMultiLanguage2 *pML2=NULL;
    HRESULT hr;

    if(!hOLE32)
    {
        if(!_StartOLE32())
        {
            ASSERT(FALSE);
            return FALSE;
        }
    }
    hr = pCoInitialize(NULL);
    if (FAILED(hr))
        return FALSE;

    if (bIsOE5)        
        hr = pCoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (LPVOID *) &pML2);
    else
        hr = pCoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage, (LPVOID *) &pML);
    
    if (SUCCEEDED(hr))
    {
        IEnumCodePage *pEnumCP;

        if (bIsOE5)
        {
            // Ignore MUI if cross code page, otherwise, we won't be able to save data in registry
            char szUICP[1024] = {0};
            LANGID uiLangId = INETCPL_GetUILanguage();

            // We always support English (US)
            if (uiLangId != 0x0409)
                GetLocaleInfoA(MAKELCID(uiLangId, SORT_DEFAULT), LOCALE_IDEFAULTANSICODEPAGE, szUICP, ARRAYSIZE(szUICP));

            if (szUICP[0] && (UINT)StrToIntA(szUICP) != GetACP())
                hr = pML2->EnumCodePages(MIMECONTF_VALID, GetSystemDefaultLangID(), &pEnumCP);
            else
                hr = pML2->EnumCodePages(MIMECONTF_VALID, uiLangId, &pEnumCP);

        }
        else
            hr = pML->EnumCodePages(MIMECONTF_VALID, &pEnumCP);
        

        if (SUCCEEDED(hr))
        {
            UINT cNum = 0;
            if (bIsOE5)
                pML2->GetNumberOfCodePageInfo(&cNum);
            else
                pML->GetNumberOfCodePageInfo(&cNum);

#ifdef UNICODE
            g_pCPInfo = (PMIMECPINFO)LocalAlloc(LPTR, sizeof(MIMECPINFO) * cNum);
            if (NULL != g_pCPInfo)
            {
                hr = pEnumCP->Next(cNum, g_pCPInfo, &g_cCPInfo);
                if (SUCCEEDED(hr))
                {
                    HLOCAL pTemp;

                    pTemp = LocalReAlloc(g_pCPInfo, sizeof(MIMECPINFO) * g_cCPInfo, LMEM_MOVEABLE);
                    if (pTemp == NULL)
                    {
                        LocalFree(g_pCPInfo);
                        g_pCPInfo = NULL;
                    }
                    else
                    {
                        g_pCPInfo = (PMIMECPINFO)pTemp;
                    }
                }
                else
                {
                    LocalFree(g_pCPInfo);
                    g_pCPInfo = NULL;
                }
#else
            g_pCPInfoW = (PMIMECPINFO)LocalAlloc(LPTR, sizeof(MIMECPINFO) * cNum);
            if (NULL != g_pCPInfoW)
            {
                hr = pEnumCP->Next(cNum, g_pCPInfoW, &g_cCPInfo);
                if (SUCCEEDED(hr))
                {
                    g_pCPInfo = (PMIMECPINFOA)LocalAlloc(LPTR, sizeof(MIMECPINFOA) * g_cCPInfo);
                    if (NULL != g_pCPInfo)
                    {
                        UINT i;

                        for (i = 0; i < g_cCPInfo; i++)
                        {
                            g_pCPInfo[i].dwFlags = g_pCPInfoW[i].dwFlags;
                            g_pCPInfo[i].uiCodePage = g_pCPInfoW[i].uiCodePage;
                            g_pCPInfo[i].uiFamilyCodePage = g_pCPInfoW[i].uiFamilyCodePage;
                            WideCharToMultiByte(CP_ACP, 0, (WCHAR *)g_pCPInfoW[i].wszDescription, -1, g_pCPInfo[i].wszDescription, sizeof(g_pCPInfo[i].wszDescription), NULL, NULL);
                            WideCharToMultiByte(CP_ACP, 0, (WCHAR *)g_pCPInfoW[i].wszWebCharset, -1, g_pCPInfo[i].wszWebCharset, sizeof(g_pCPInfo[i].wszWebCharset), NULL, NULL);
                            WideCharToMultiByte(CP_ACP, 0, (WCHAR *)g_pCPInfoW[i].wszHeaderCharset, -1, g_pCPInfo[i].wszHeaderCharset, sizeof(g_pCPInfo[i].wszHeaderCharset), NULL, NULL);
                            WideCharToMultiByte(CP_ACP, 0, (WCHAR *)g_pCPInfoW[i].wszBodyCharset, -1, g_pCPInfo[i].wszBodyCharset, sizeof(g_pCPInfo[i].wszBodyCharset), NULL, NULL);
                            WideCharToMultiByte(CP_ACP, 0, (WCHAR *)g_pCPInfoW[i].wszFixedWidthFont, -1, g_pCPInfo[i].wszFixedWidthFont, sizeof(g_pCPInfo[i].wszFixedWidthFont), NULL, NULL);
                            WideCharToMultiByte(CP_ACP, 0, (WCHAR *)g_pCPInfoW[i].wszProportionalFont, -1, g_pCPInfo[i].wszProportionalFont, sizeof(g_pCPInfo[i].wszProportionalFont), NULL, NULL);
                            g_pCPInfo[i].bGDICharset = g_pCPInfoW[i].bGDICharset;                            
                        }
                    }                    
                }
                LocalFree(g_pCPInfoW);
                g_pCPInfoW = NULL;
#endif
            }
            pEnumCP->Release();
        }
        if (bIsOE5)        
            pML2->Release();
        else
            pML->Release();
    }
    pCoUninitialize();

    return TRUE;
}

//
// FreeMimeCsetTable()
//
// Free string buffer of MimeCharsetTable[]'s string field
//
void FreeMimeCsetTable(void)
{
    if (NULL != g_pCPInfo)
    {
        LocalFree(g_pCPInfo);
        g_pCPInfo = NULL;
        g_cCPInfo = 0;
    }
}

//
// EnumFontsProc()
//
// Selects only one font per style
//
int CALLBACK EnumFontsProc(
    ENUMLOGFONTEX FAR*  elf,    // address of logical-font data 
    TEXTMETRIC FAR*  tm,    // address of physical-font data 
    DWORD  dwFontType,  // type of font 
    LPARAM  lParam  // address of application-defined data  
   )
{
    LOGFONT FAR*  lf;
        LPFONTSDATA pFnt;

    ASSERT(lParam);
    ASSERT(elf);
    pFnt = (LPFONTSDATA)lParam;

    lf = &(elf->elfLogFont);
    if ( dwFontType == DEVICE_FONTTYPE || dwFontType == RASTER_FONTTYPE )
        return TRUE; // keep going but don't use this font

    /* We don't use the SYMBOL fonts */
    if( lf->lfCharSet == SYMBOL_CHARSET )
        return TRUE;

    // we don't handle Mac Charset
    if (lf->lfCharSet == MAC_CHARSET )
        return TRUE;

    if ( IsVerticalFont(lf->lfFaceName) )
        return TRUE;  // keep going but don't use this font

    if ( lf->lfPitchAndFamily & FIXED_PITCH  )
    {
        if (CB_ERR == SendMessage(pFnt->hwndFixedCB, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)elf->elfLogFont.lfFaceName))
        {
            // add the font name to the combobox
            SendMessage(pFnt->hwndFixedCB, CB_ADDSTRING, 0, (LPARAM)elf->elfLogFont.lfFaceName);            
        }
    }

    if (CB_ERR == SendMessage(pFnt->hwndPropCB, CB_FINDSTRINGEXACT, (WPARAM)-1, (LPARAM)elf->elfLogFont.lfFaceName))
    {
        // add the font name to the combobox
        SendMessage(pFnt->hwndPropCB, CB_ADDSTRING, 0, (LPARAM)elf->elfLogFont.lfFaceName);
    }
    return TRUE;
}

//
// FillFontComboBox()
//
// Fills hwndCB with the names of fonts of family dwCodePage.
//
BOOL FillFontComboBox(IN LPFONTSDATA pFnt, IN BYTE CodePage)
{
    HDC     hDC;
    LOGFONT lf;
    HWND    hWnd;
    BOOL    fReturn = FALSE;

    // get system font info
    hWnd = GetTopWindow(GetDesktopWindow());
    hDC = GetDC(hWnd);

    if (hDC)
    {
        lf.lfFaceName[0]    = 0;
        lf.lfPitchAndFamily = 0;
        lf.lfCharSet = CodePage;

        EnumFontFamiliesEx(hDC, &lf, (FONTENUMPROC)EnumFontsProc,
            (LPARAM)pFnt, 0);

        // everthing went fine
        fReturn = TRUE;
    }

    ReleaseDC(hWnd, hDC);

    return fReturn;

}   // FillFontComboBox()

//
// FillSizeComboBox()
//
// Fills font size combobox with the size of fonts.
//
BOOL FillSizeComboBox(IN LPFONTSDATA pFnt)
{
    int i;

    for (i = IDS_FONT_SIZE_SMALLEST; i <= IDS_FONT_SIZE_LARGEST ; i++)
    {
        TCHAR szSize[MAX_MIMEFACE_NAME];

        MLLoadString(i, szSize, sizeof(szSize));
        SendMessage(pFnt->hwndSizeCB, CB_ADDSTRING, 0, (LPARAM)szSize);
    }

    return TRUE;
}

//
// FillCharsetComboBoxes()
//
// Fills the Fixed, Prop, and MIME comboboxes with the appropriate
// font data
//
BOOL FillCharsetComboBoxes(LPFONTSDATA pFnt, DWORD dwCodePage)
{
    UINT i;
    int iPageInfo = -1;
    DWORD grfFlag;

    // erase all the comboboxes to start fresh
    SendMessage(pFnt->hwndPropCB,  CB_RESETCONTENT, 0, 0);
    SendMessage(pFnt->hwndFixedCB, CB_RESETCONTENT, 0, 0);
    SendMessage(pFnt->hwndSizeCB, CB_RESETCONTENT, 0, 0);
    SendMessage(pFnt->hwndMIMECB,  CB_RESETCONTENT, 0, 0);

    // What happens if other one calls OpenFontDialog except Athena?
    grfFlag = StrCmpI(pFnt->lpszKeyPath, REGSTR_PATH_INTERNATIONAL)? MIMECONTF_MAILNEWS: MIMECONTF_BROWSER;

    for(i=0; i < g_cCPInfo; i++)
    {
        // find the codepage in our table
        if (g_pCPInfo[i].uiFamilyCodePage == (UINT)dwCodePage)
        {
            //
            // populate MIME combobox
            //

            if (g_pCPInfo[i].uiCodePage == (UINT)dwCodePage)
                iPageInfo = i;          // we store info per family codepage here

            // add mime type to combobox
            if (grfFlag & g_pCPInfo[i].dwFlags)
            {
                // HACK: We need to remove Japanese JIS 1 Byte Kana and Korean for MAILNEWS.
                //         949 : Korean. We are using Korean (Auto Detect) instead
                //       50225 : Korean ISO
                //       50221 : Japanese JIS 1 byte Kana-ESC
                //       50222 : Japanese JIS 1 byte Kana-SIO
                if (grfFlag & MIMECONTF_MAILNEWS)
                {
                    if (g_pCPInfo[i].uiCodePage == 949 || g_pCPInfo[i].uiCodePage == 50221 || g_pCPInfo[i].uiCodePage == 50222 || g_pCPInfo[i].uiCodePage == 50225)
                        continue;
                }
                SendMessage(pFnt->hwndMIMECB, CB_ADDSTRING, 0, (LPARAM)g_pCPInfo[i].wszDescription);
            }

        }   // if CodePage

    }   // for i

    if (-1 != iPageInfo)
    {
        // if nothing is defined, then copy the first possible value that
        // we know of from our table
        if (!pFnt->page[iPageInfo].szMIMEFont[0])
        {
            if (grfFlag & g_pCPInfo[iPageInfo].dwFlags)
                StrCpyN(pFnt->page[iPageInfo].szMIMEFont, g_pCPInfo[iPageInfo].wszDescription, ARRAYSIZE(pFnt->page[iPageInfo].szMIMEFont));
            else
            {
                for (i = 0; i < g_cCPInfo; i++)
                {
                    if (g_pCPInfo[iPageInfo].uiCodePage == g_pCPInfo[i].uiFamilyCodePage)
                    {
                        if (grfFlag & g_pCPInfo[i].dwFlags)
                        {
                            StrCpyN(pFnt->page[iPageInfo].szMIMEFont, g_pCPInfo[i].wszDescription, ARRAYSIZE(pFnt->page[iPageInfo].szMIMEFont));
                            break;
                        }
                    }                        
                }
            }
        }

        // select the current default
        SendMessage(pFnt->hwndMIMECB, CB_SELECTSTRING, (WPARAM)-1,
            (LPARAM)pFnt->page[iPageInfo].szMIMEFont);

        // Enable/disable MIME is when there is only one possibility
        EnableWindow(pFnt->hwndMIMECB, (1 < SendMessage(pFnt->hwndMIMECB, CB_GETCOUNT, 0, (LPARAM)0)) && !g_restrict.fFonts);
                        
        // Add fonts to combobox
        FillFontComboBox(pFnt, g_pCPInfo[iPageInfo].bGDICharset);

#ifdef UNIX
        /* We would have called EnumFontFamiliesEx wherein we would have
         * have populated the fonts list boxes with substitute fonts if any
         *
         * So, before we populate the proportional and the fixed fonts below,
         * we must query and use substitute fonts if avbl.
         */
        {
            CHAR szSubstFont[MAX_MIMEFACE_NAME+1];
            DWORD cchSubstFont = MAX_MIMEFACE_NAME + 1;
        CHAR szFont[MAX_MIMEFACE_NAME + 1];
           
            WideCharToMultiByte(CP_ACP, 0, pFnt->page[iPageInfo].szPropFont, -1, szFont, 
                   MAX_MIMEFACE_NAME + 1, NULL, NULL);
            if ((ERROR_SUCCESS == MwGetSubstituteFont(szFont, szSubstFont, &cchSubstFont)) && 
                cchSubstFont) 
            {
                MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szSubstFont, -1, 
                   pFnt->page[iPageInfo].szPropFont, MAX_MIMEFACE_NAME + 1);
            }

            WideCharToMultiByte(CP_ACP, 0, pFnt->page[iPageInfo].szFixedFont, -1, szFont, 
                   MAX_MIMEFACE_NAME + 1, NULL, NULL);
            cchSubstFont = MAX_MIMEFACE_NAME + 1;
            if ((ERROR_SUCCESS == MwGetSubstituteFont(szFont, szSubstFont, &cchSubstFont)) && 
                cchSubstFont) 
            {
                MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szSubstFont, -1, 
                   pFnt->page[iPageInfo].szFixedFont, MAX_MIMEFACE_NAME + 1);
            }
        }
#endif /* UNIX */

        // select the current prop default
        SendMessage(pFnt->hwndPropCB, CB_SELECTSTRING, (WPARAM)-1,
            (LPARAM)pFnt->page[iPageInfo].szPropFont);

        // select the current fixed default
        SendMessage(pFnt->hwndFixedCB, CB_SELECTSTRING, (WPARAM)-1,
            (LPARAM)pFnt->page[iPageInfo].szFixedFont);

        // Add font sizes to combobox
        FillSizeComboBox(pFnt);

        // select the current size default
        SendMessage(pFnt->hwndSizeCB, CB_SETCURSEL, (WPARAM)pFnt->page[iPageInfo].dwFontSize, (LPARAM)0);

        // we handled it
        return TRUE;
    }

    return FALSE;

}   // FillCharsetComboBoxes()

//
// FontsDlgInit()
//
// Initializes the Fonts dialog.
//
BOOL FontsDlgInit(IN HWND hDlg, LPCTSTR lpszKeyPath)
{
    HKEY    hkey;
    DWORD   grfFlag;
    DWORD   dw;
    DWORD   cb;
    DWORD   i;
    BOOL    bIsOE5 = FALSE;

    TCHAR   szKey[1024];

    LPFONTSDATA  pFnt;  // localize data

    if (!hDlg)
        return FALSE;   // nothing to initialize

    // set system default character set where we possibly show
    // the strings in native language.
    SHSetDefaultDialogFont(hDlg, IDC_FONTS_PROP_FONT_COMBO);
    SHSetDefaultDialogFont(hDlg, IDC_FONTS_FIXED_FONT_COMBO);
    SHSetDefaultDialogFont(hDlg, IDC_FONTS_MIME_FONT_COMBO);
    SHSetDefaultDialogFont(hDlg, IDC_FONTS_DEFAULT_LANG_TEXT);
    SHSetDefaultDialogFont(hDlg, IDC_FONTS_CODE_PAGES_LIST);

    // get some space to store local data
    // NOTE: LocalAlloc already zeroes the memory
    pFnt = (LPFONTSDATA)LocalAlloc(LPTR, sizeof(*pFnt));
    if (!pFnt)
    {
        EndDialog(hDlg, 0);
        return FALSE;
    }

    // We distinguish OE5 and OE4 by searching for "5.0" in its registry path, 
    // It works as long as there is no spec. change in OE5
    if (NULL != StrStr(lpszKeyPath, TEXT("5.0")))
        bIsOE5 = TRUE;

    if (!InitMimeCsetTable(bIsOE5))
    {
        EndDialog(hDlg, 0);
        return FALSE;
    }

    if (NULL == pFnt->page)
    {
        pFnt->page = (CODEPAGEDATA*)LocalAlloc(LPTR, sizeof(CODEPAGEDATA) * g_cCPInfo);
        if (NULL == pFnt->page)
        {
            EndDialog(hDlg, 0);
            return FALSE;
        }
    }

    // associate the memory with the dialog window
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pFnt);

    // save the dialog handle
    pFnt->hDlg = hDlg;

    // get the dialog items
    pFnt->hwndPropCB  = GetDlgItem(pFnt->hDlg, IDC_FONTS_PROP_FONT_COMBO);
    pFnt->hwndFixedCB = GetDlgItem(pFnt->hDlg, IDC_FONTS_FIXED_FONT_COMBO);
    pFnt->hwndSizeCB = GetDlgItem(pFnt->hDlg, IDC_FONTS_SIZE_FONT_COMBO);
    pFnt->hwndMIMECB  = GetDlgItem(pFnt->hDlg, IDC_FONTS_MIME_FONT_COMBO);    
    pFnt->hwndNamesLB = GetDlgItem(pFnt->hDlg, IDC_FONTS_CODE_PAGES_LIST);    
    pFnt->lpszKeyPath = lpszKeyPath ? lpszKeyPath: REGSTR_PATH_INTERNATIONAL;
    pFnt->dwDefaultCodePage = GetACP();
    // get values from registry
    if (RegOpenKeyEx(HKEY_CURRENT_USER, pFnt->lpszKeyPath, NULL, KEY_READ, &hkey)
        == ERROR_SUCCESS)
    {
        cb = sizeof(dw);
        if (RegQueryValueEx(hkey, REGSTR_VAL_DEFAULT_CODEPAGE, NULL, NULL, (LPBYTE)&dw, &cb)
          == ERROR_SUCCESS)
        {
            pFnt->dwDefaultCodePage = dw;
        }
        RegCloseKey(hkey);
    }

    // What happens if other one calls OpenFontDialog except Athena?
    grfFlag = StrCmpI(pFnt->lpszKeyPath, REGSTR_PATH_INTERNATIONAL)? MIMECONTF_MAILNEWS: MIMECONTF_BROWSER;

    for (i = 0; i < g_cCPInfo; i++)
    {
        if (g_pCPInfo[i].uiCodePage == g_pCPInfo[i].uiFamilyCodePage)
        {
            int iDef;
            UINT j;

            iDef = -1;
            if (0 == (grfFlag & g_pCPInfo[i].dwFlags))
            {
                for (j = 0; j < g_cCPInfo; j++)
                {
                    if (g_pCPInfo[i].uiCodePage == g_pCPInfo[j].uiFamilyCodePage)
                    {
                        if (grfFlag & g_pCPInfo[j].dwFlags)
                        {
                            iDef = j;
                            break;
                        }
                    }
                }
                if (-1 == iDef)
                    continue;
            }

            if (g_pCPInfo[i].uiCodePage == 50001) // skip CP_AUTO
                continue;

            wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("%s\\%u"), pFnt->lpszKeyPath, g_pCPInfo[i].uiCodePage);
            if (RegOpenKeyEx(HKEY_CURRENT_USER, szKey, NULL, KEY_READ, &hkey) == ERROR_SUCCESS)
            {
                cb = sizeof(pFnt->page[i].szFriendlyName);
                if (RegQueryValueEx(hkey, REGSTR_VAL_FONT_SCRIPT, NULL, NULL,
                        (LPBYTE)&pFnt->page[i].szFriendlyName, &cb)
                    != ERROR_SUCCESS)
                {
                    TCHAR *p;

                    StrCpyN(pFnt->page[i].szFriendlyName, g_pCPInfo[i].wszDescription, ARRAYSIZE(pFnt->page[i].szFriendlyName));
                    for (p = pFnt->page[i].szFriendlyName; *p != TEXT('\0'); p = CharNext(p))
                    {
                        // We'd better have a source of this string else where.
                        if (*p == TEXT('('))
                        {
                            *p = TEXT('\0');
                            break;
                        }
                    }
                }

                cb = sizeof(dw);
                if (RegQueryValueEx(hkey, REGSTR_VAL_DEF_INETENCODING, NULL, NULL, (LPBYTE)&dw, &cb)
                    != ERROR_SUCCESS)
                {
                    dw = (DWORD)g_pCPInfo[i].uiCodePage;
                    // HACK ! It's only for Japanese Auto Select as Japanese default.
                    if (dw == 932)      // 932 : Japanese Windows CodePage
                        dw = 50932;     // 50932 : Japanese Auto Select InternetEncoding
                }
                for (j = 0; j < g_cCPInfo; j++)
                {
                    if (g_pCPInfo[j].uiCodePage == (UINT)dw)
                    {
                        if (grfFlag & g_pCPInfo[j].dwFlags)
                            StrCpyN(pFnt->page[i].szMIMEFont, g_pCPInfo[j].wszDescription, ARRAYSIZE(pFnt->page[i].szMIMEFont));
                        else if (-1 != iDef)
                            StrCpyN(pFnt->page[i].szMIMEFont, g_pCPInfo[iDef].wszDescription, ARRAYSIZE(pFnt->page[i].szMIMEFont));
                        else
                            pFnt->page[i].szMIMEFont[0] = TEXT('\0');
                        break;
                    }
                }
            
                cb = sizeof(pFnt->page[i].szFixedFont);
                if (RegQueryValueEx(hkey, REGSTR_VAL_FIXED_FONT, NULL, NULL,
                        (LPBYTE)pFnt->page[i].szFixedFont, &cb)
                    != ERROR_SUCCESS)
                {
                    StrCpyN(pFnt->page[i].szFixedFont, g_pCPInfo[i].wszFixedWidthFont, ARRAYSIZE(pFnt->page[i].szFixedFont));
                }
            
                cb = sizeof(pFnt->page[i].szPropFont);
                if (RegQueryValueEx(hkey, REGSTR_VAL_PROP_FONT, NULL, NULL,
                        (LPBYTE)pFnt->page[i].szPropFont, &cb)
                    != ERROR_SUCCESS)
                {
                    StrCpyN(pFnt->page[i].szPropFont, g_pCPInfo[i].wszProportionalFont, ARRAYSIZE(pFnt->page[i].szPropFont));
                }

                cb = sizeof(pFnt->page[i].dwFontSize);
                if (RegQueryValueEx(hkey, REGSTR_VAL_FONT_SIZE, NULL, NULL,
                        (LPBYTE)&pFnt->page[i].dwFontSize, &cb)
                    != ERROR_SUCCESS)
                {
                    pFnt->page[i].dwFontSize = REGSTR_VAL_FONT_SIZE_DEF;
                }
                RegCloseKey(hkey);

            }
            else
            {
                UINT j;
                TCHAR *p;

                StrCpyN(pFnt->page[i].szFriendlyName, g_pCPInfo[i].wszDescription, ARRAYSIZE(pFnt->page[i].szFriendlyName));
                for (p = pFnt->page[i].szFriendlyName; *p != TEXT('\0'); p = CharNext(p))
                {
                    if (*p == TEXT('('))
                    {
                        *p = TEXT('\0');
                        break;
                    }
                }
                j = (grfFlag & g_pCPInfo[i].dwFlags)? i: iDef;
                // HACK ! It's only for Japanese Auto Select as Japanese default.
                if (g_pCPInfo[j].uiCodePage == 932) // 932 : Japanese Windows CodePage
                {
                    for (j = 0; j < g_cCPInfo; j++)
                    {
                        if (g_pCPInfo[j].uiCodePage == 50932)   // 50932 : Japanese Auto Select InternetEncoding
                            break;
                    }
                }
                StrCpyN(pFnt->page[i].szMIMEFont, g_pCPInfo[j].wszDescription, ARRAYSIZE(pFnt->page[i].szMIMEFont));
                StrCpyN(pFnt->page[i].szFixedFont, g_pCPInfo[i].wszFixedWidthFont, ARRAYSIZE(pFnt->page[i].szFixedFont));
                StrCpyN(pFnt->page[i].szPropFont, g_pCPInfo[i].wszProportionalFont, ARRAYSIZE(pFnt->page[i].szPropFont));
                pFnt->page[i].dwFontSize = REGSTR_VAL_FONT_SIZE_DEF;
            }

            // add the name to the listbox            
            SendMessage(pFnt->hwndNamesLB, LB_ADDSTRING, 0, (LPARAM)pFnt->page[i].szFriendlyName);            

            // check to see if it is the default code page
            if (pFnt->dwDefaultCodePage == g_pCPInfo[i].uiCodePage)
            {
                if (LB_ERR == SendMessage(pFnt->hwndNamesLB, LB_SELECTSTRING, (WPARAM)-1, (LPARAM)pFnt->page[i].szFriendlyName))
                {
                    // Hack shlwapi problems for Win9x.
                    CHAR szAnsiString[1024] = {0};
                    WideCharToMultiByte(CP_ACP, 0, pFnt->page[i].szFriendlyName, -1, szAnsiString, 1024, NULL, NULL);
                    SendMessageA(pFnt->hwndNamesLB, LB_SELECTSTRING, (WPARAM)-1, (LPARAM)szAnsiString);
                }

                SetDlgItemText(pFnt->hDlg, IDC_FONTS_DEFAULT_LANG_TEXT, pFnt->page[i].szFriendlyName);
            }
        }
    }
    
    FillCharsetComboBoxes(pFnt, pFnt->dwDefaultCodePage);

    pFnt->bChanged = FALSE;

    if( g_restrict.fFonts )
    {
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_PROP_FONT_COMBO ), FALSE);
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_FIXED_FONT_COMBO ), FALSE);
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_SIZE_FONT_COMBO ), FALSE);
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_MIME_FONT_COMBO ), FALSE);
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_CODE_PAGES_LIST ), FALSE);
        EnableWindow( GetDlgItem( hDlg, IDC_FONTS_SETDEFAULT_BUTTON ), FALSE);

    }

    // everything ok
    return TRUE;

}   // FontsDlgInit()


//
// SaveFontsData()
//
// Save the new fonts settings into regestry
//
void SaveFontsData(LPFONTSDATA pFnt)
{
    HKEY    hkeyCodePage;
    TCHAR   szCodePage      [MAX_MIMEFACE_NAME];

    HKEY    hkey;
    DWORD   dw;

    // get values from registry
    if (RegCreateKeyEx(HKEY_CURRENT_USER, pFnt->lpszKeyPath, NULL, NULL, NULL, KEY_WRITE, NULL, &hkey, &dw)
        == ERROR_SUCCESS)
    {
        UINT i;
 
        RegSetValueEx(hkey, REGSTR_VAL_DEFAULT_CODEPAGE, NULL, REG_BINARY, (LPBYTE)&pFnt->dwDefaultCodePage, sizeof(pFnt->dwDefaultCodePage));
        
        for(i = 0; i < g_cCPInfo; i++)
        {
            if (g_pCPInfo[i].uiCodePage == g_pCPInfo[i].uiFamilyCodePage)
            {
                wnsprintf(szCodePage, ARRAYSIZE(szCodePage), TEXT("%u"), g_pCPInfo[i].uiCodePage);
                if (RegCreateKeyEx(hkey, szCodePage, NULL, NULL, NULL, KEY_WRITE, NULL, &hkeyCodePage, &dw) == ERROR_SUCCESS)
                {
                    UINT j;

                    RegSetValueEx(hkeyCodePage, REGSTR_VAL_FONT_SCRIPT, NULL, REG_SZ,
                            (LPBYTE)&pFnt->page[i].szFriendlyName, 
                            (lstrlen(pFnt->page[i].szFriendlyName)+1)*sizeof(TCHAR));
                    
                    for (j = 0; j < g_cCPInfo; j++)
                    {
                        if (!StrCmpI(g_pCPInfo[j].wszDescription, pFnt->page[i].szMIMEFont))
                        {
                            dw = g_pCPInfo[j].uiCodePage;
                            break;
                        }
                    }
                    RegSetValueEx(hkeyCodePage, REGSTR_VAL_DEF_INETENCODING, NULL, REG_BINARY,
                            (LPBYTE)&dw, sizeof(dw));
                    
                    RegSetValueEx(hkeyCodePage, REGSTR_VAL_FIXED_FONT, NULL, REG_SZ,
                            (LPBYTE)pFnt->page[i].szFixedFont, 
                            (lstrlen(pFnt->page[i].szFixedFont)+1)*sizeof(TCHAR));
                    
                    RegSetValueEx(hkeyCodePage, REGSTR_VAL_PROP_FONT, NULL, REG_SZ,
                            (LPBYTE)pFnt->page[i].szPropFont, 
                            (lstrlen(pFnt->page[i].szPropFont)+1)*sizeof(TCHAR));
                    
                    RegSetValueEx(hkeyCodePage, REGSTR_VAL_FONT_SIZE, NULL, REG_BINARY,
                            (LPBYTE)&pFnt->page[i].dwFontSize,
                            sizeof(pFnt->page[i].dwFontSize));

                    RegCloseKey(hkeyCodePage);
                    
                }   // if RegCreateKeyEx

            }   // if uiCodePage == uiFamilyCodePage

        }   // for

        RegCloseKey(hkey);

    }   // if RegCreateKeyEx

}   // SaveFontsData()

//
// FontsOnCommand()
//
// Handles WM_COMMAN Dmessage for the Fonts subdialog
//
BOOL FontsOnCommand(LPFONTSDATA pFnt, UINT id, UINT nCmd)
{
    switch(id)
    {
        case IDOK:
            if (pFnt->bChanged)
            {
                SaveFontsData(pFnt);
                
                // tell MSHTML to pick up changes and update
                UpdateAllWindows();
            }
            return TRUE;    // exit dialog

        case IDCANCEL:
            return TRUE;    // exit dialog

        case IDC_FONTS_MIME_FONT_COMBO:
            if (nCmd==CBN_SELCHANGE)
            {
                g_fChangedMime = TRUE;   // tell MSHTML that the Mime has changed
            }
            // fall thru...

        case IDC_FONTS_PROP_FONT_COMBO:
        case IDC_FONTS_FIXED_FONT_COMBO:
        case IDC_FONTS_SIZE_FONT_COMBO:
            if (nCmd==CBN_SELCHANGE)
            {
                UINT i;
                TCHAR   szCodePage[MAX_MIMECP_NAME];

                pFnt->bChanged = TRUE;  // we need to save
                
                // find the currently selected item in the list box
                INT_PTR itmp = SendMessage(pFnt->hwndNamesLB, LB_GETCURSEL, 0, 0);
                SendMessage(pFnt->hwndNamesLB, LB_GETTEXT, itmp, (LPARAM)szCodePage);
                
                // find the code page from the text
                for(i=0; i < g_cCPInfo; i++)
                {
                    if (!StrCmpI(szCodePage, pFnt->page[i].szFriendlyName))
                    {             
                        // grab the new values
                        GetDlgItemText(pFnt->hDlg, IDC_FONTS_PROP_FONT_COMBO,
                            pFnt->page[i].szPropFont, ARRAYSIZE(pFnt->page[i].szPropFont));
                        GetDlgItemText(pFnt->hDlg, IDC_FONTS_FIXED_FONT_COMBO,
                            pFnt->page[i].szFixedFont, ARRAYSIZE(pFnt->page[i].szFixedFont));
                        pFnt->page[i].dwFontSize = (int) SendMessage(pFnt->hwndSizeCB, CB_GETCURSEL, 0, 0);
                        GetDlgItemText(pFnt->hDlg, IDC_FONTS_MIME_FONT_COMBO,
                            pFnt->page[i].szMIMEFont, ARRAYSIZE(pFnt->page[i].szMIMEFont));
                        break;
                    }
                }
                // if we don't find it... we are going to keep the default

                ASSERT(i < g_cCPInfo);  // something went wrong

            }
            break;

        case IDC_FONTS_SETDEFAULT_BUTTON:
            {
                UINT i;
                TCHAR   szCodePage[MAX_MIMECP_NAME];

                pFnt->bChanged = TRUE;  // we need to save

                // get the newly selected charset
                INT_PTR itmp = SendMessage(pFnt->hwndNamesLB, LB_GETCURSEL, 0, 0);
                SendMessage(pFnt->hwndNamesLB, LB_GETTEXT, itmp, (LPARAM)szCodePage);

                // set the newly selected charset text
                SetDlgItemText(pFnt->hDlg, IDC_FONTS_DEFAULT_LANG_TEXT, szCodePage);

                // find the code page from the text
                for (i = 0; i < g_cCPInfo; i++)
                {
                    if (!StrCmpI(szCodePage, pFnt->page[i].szFriendlyName))
                    {
                        pFnt->dwDefaultCodePage = g_pCPInfo[i].uiFamilyCodePage;
                        g_fChangedMime = TRUE;
                        break;
                    }
                }
                // if we don't find it... we are going to keep the default

                ASSERT(i < g_cCPInfo);  // something went wrong
            }
            break;
        
        case IDC_FONTS_CODE_PAGES_LIST:
            if (nCmd==LBN_SELCHANGE)
            {
                UINT i;
                TCHAR   szCodePage[MAX_MIMECP_NAME];

                INT_PTR itmp = SendMessage(pFnt->hwndNamesLB, LB_GETCURSEL, 0, 0);
                SendMessage(pFnt->hwndNamesLB, LB_GETTEXT, itmp, (LPARAM)szCodePage);
                
                // find the code page from the text
                for(i=0; i < g_cCPInfo; i++)
                {
                    if (!StrCmpI(szCodePage, pFnt->page[i].szFriendlyName))
                    {
                        FillCharsetComboBoxes(pFnt, g_pCPInfo[i].uiFamilyCodePage);
                        break;
                    }
                }
            }
            break;

    }
    
    // don't exit dialog
    return FALSE;
}

//
// FontsDlgProc()
//
// Message handler for the "Fonts" subdialog.
//
INT_PTR CALLBACK FontsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPFONTSDATA pFnt = (LPFONTSDATA) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
            return FontsDlgInit(hDlg, (LPTSTR)lParam);
            
        case WM_DESTROY:
            // give back the memory
            FreeMimeCsetTable();

            // destroy font if we created
            SHRemoveDefaultDialogFont(hDlg);

            if (pFnt)
            {
                if (pFnt->page)
                    LocalFree(pFnt->page);
                LocalFree(pFnt);
            }
            break;

        case WM_COMMAND:
            if (FontsOnCommand(pFnt, LOWORD(wParam), HIWORD(wParam)))
                EndDialog(hDlg, LOWORD(wParam) == IDOK? 1: 0);
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:    // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        default:
            return FALSE;
    }
    return TRUE;
}


//
// EXTERNAL API
//
STDAPI_(INT_PTR) OpenFontsDialog(HWND hDlg, LPCSTR lpszKeyPath)
{
#ifdef UNICODE
    WCHAR   wszKeyPath[1024];
    MultiByteToWideChar(CP_ACP, 0, (char *)lpszKeyPath, -1, wszKeyPath, ARRAYSIZE(wszKeyPath));
    return DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_FONTS_IE4), hDlg, FontsDlgProc, (LPARAM) wszKeyPath);
#else
    return DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_FONTS_IE4), hDlg, FontsDlgProc, (LPARAM) lpszKeyPath);
#endif // UNICODE
}

// provide script based font dialog
STDAPI_(INT_PTR) OpenFontsDialogEx(HWND hDlg, LPCTSTR lpszKeyPath)
{
    INT_PTR nRet = -1;
    HRESULT hr;
    BOOL    fOLEPresent;

    if (hOLE32 != NULL)
    {
        fOLEPresent = TRUE;
    }
    else
    {
        fOLEPresent = _StartOLE32();
    }

    ASSERT(fOLEPresent);
    if (fOLEPresent)
    {
        ASSERT(IS_VALID_HANDLE(hOLE32, MODULE));
        ASSERT(IS_VALID_CODE_PTR(pCoInitialize, PCOINIT));

        hr = pCoInitialize(NULL);
        if (SUCCEEDED(hr))
        {
            nRet = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_FONTS), hDlg, FontsDlgProcEx, (LPARAM) lpszKeyPath);
        }
    }

    // Release interface
    if (g_pMLFlnk2)
    {
        g_pMLFlnk2->Release();
        g_pMLFlnk2 = NULL;
    }

    ASSERT(IS_VALID_CODE_PTR(pCoUninitialize, PCOUNIT));
    pCoUninitialize();

    return nRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\content.cpp ===
//*********************************************************************
//*          Microsoft Windows                                       **
//*        Copyright(c) Microsoft Corp., 1995                        **
//*********************************************************************

//
// content.cpp - "Content" property sheet
//

// HISTORY:
//
// 5/17/97  t-ashlm created

#include "inetcplp.h"
#include <wab.h>
#include <cryptui.h>
#include <msiehost.h>
#include <schannel.h>

#include <mluisupp.h>

//
// Private Functions and Structures
//

// WINTRUST / SOFTPUB
// definition from WINTRUST.H
// extern "C" BOOL WINAPI OpenPersonalTrustDBDialog(HWND hwndParent);
typedef BOOL (WINAPI *WINTRUSTDLGPROC)(HWND hwndParent);
WINTRUSTDLGPROC g_WinTrustDlgProc = (WINTRUSTDLGPROC)NULL;
SSL_EMPTY_CACHE_FN_W g_pfnSslEmptyCacheW = (SSL_EMPTY_CACHE_FN_W)NULL;
#ifdef WALLET
BOOL IsWallet3Installed();
BOOL IsWalletAddressAvailable(VOID);
BOOL IsWalletPaymentAvailable(VOID);
#endif
HRESULT ShowModalDialog(HWND hwndParent, IMoniker *pmk, VARIANT *pvarArgIn, TCHAR* pchOptions, VARIANT *pvArgOut);
HCERTSTORE PFXImportCertStore(CRYPT_DATA_BLOB* pPFX, LPCWSTR szPassword, DWORD   dwFlags);
BOOL PFXExportCertStore(HCERTSTORE hStore, CRYPT_DATA_BLOB* pPFX, LPCWSTR szPassword, DWORD   dwFlags);
BOOL _AorW_GetFileNameFromBrowse(HWND hDlg,
                                 LPWSTR pszFilename,
                                 UINT cchFilename,
                                 LPCWSTR pszWorkingDir,
                                 LPCWSTR pszExt,
                                 LPCWSTR pszFilter,
                                 LPCWSTR pszTitle);

INT_PTR CALLBACK AutoSuggestDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK WalletDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);


//BUBUG: The following prototype should be rermoved when we have updated our Crypto API to latest version
BOOL WINAPI WTHelperIsInRootStore(PCCERT_CONTEXT pCertContext);

//////////////////////////////////////////////
// stolen from \inet\schannel\sspi\spreg.h
#define REG_SITECERT_BASE     TEXT("System\\CurrentControlSet\\Control\\SecurityProviders\\SCHANNEL\\CertificationAuthorities")
#define REG_SITECERT_CERT_VAL TEXT("CACert")

#define SITECERTKEYLEN        80    // FEATURE: should probably grab this value somewhere
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#include <initguid.h>

// Use the wallet "payment" guid for JIT (different for alpha and x86...)
#ifdef _ALPHA_
// {B7FB4D5C-9FBE-11D0-8965-0000F822DEA9}
DEFINE_GUID(CLSID_WalletPayment, 0xb7fb4d5c, 0x9fbe, 0x11d0, 0x89, 0x65, 0x0, 0x0, 0xf8, 0x22, 0xde, 0xa9);
#else
// {87D3CB66-BA2E-11CF-B9D6-00A0C9083362}
DEFINE_GUID(CLSID_WalletPayment, 0x87d3cb66, 0xba2e, 0x11cf, 0xb9, 0xd6, 0x0, 0xa0, 0xc9, 0x08, 0x33, 0x62);
#endif

// WAB GUID for JIT
DEFINE_GUID(CLSID_WAB, 0x32714800, 0x2E5F, 0x11d0, 0x8B, 0x85, 0x00, 0xAA, 0x00, 0x44, 0xF9, 0x41);

#define EKU_CODESIGN_OFF    0
#define EKU_EMAIL_OFF       1
#define EKU_CLIENT_OFF      2
#define EKU_SERVER_OFF      3
#define EKU_DISABLE_OFF     4


const LPSTR g_rgszEnhkeyUsage[] =
{
    szOID_PKIX_KP_CODE_SIGNING,
    szOID_PKIX_KP_EMAIL_PROTECTION,
    szOID_PKIX_KP_CLIENT_AUTH,
    szOID_PKIX_KP_SERVER_AUTH,
    szOID_YESNO_TRUST_ATTR,
    NULL
};


typedef struct {
    HWND hDlg;              // handle to window
    HRESULT hrUseRatings;   // error=not installed; S_OK=enabled; S_FALSE=disabled
    HINSTANCE   hWinTrust;      // WINTRUST/SOFTPUB library handle
    HINSTANCE   hSChannel;  // schannel library handle

} CONTENTPAGE, *LPCONTENTPAGE;

BOOL ContentDlgApplyNow(  LPCONTENTPAGE pCon     );
BOOL ContentDlgEnableControls(   IN HWND hDlg  );
BOOL ContentDlgInit(  IN HWND hDlg  );

VOID DisplayWalletPaymentDialog(HWND hWnd);
VOID DisplayWalletAddressDialog(HWND hWnd);

STDAPI ResetProfileSharing(HWND hwnd);
EXTERN_C HRESULT ClearAutoSuggestForForms(DWORD dwClear);


//
// SecurityDlgEnableControls()
//
// Does initalization for Security Dlg.
//
// History:
//
// 6/17/96  t-gpease   moved
//
BOOL ContentDlgEnableControls( IN HWND hDlg  )
{
    HKEY hkey=NULL;
    
    if( g_restrict.fRatings )
    {
        EnableWindow( GetDlgItem(hDlg, IDC_RATINGS_TURN_ON), FALSE );
        EnableWindow( GetDlgItem(hDlg, IDC_ADVANCED_RATINGS_BUTTON), FALSE );
#if 0   // don't diable the text
        EnableDlgItem( hDlg, IDC_RATINGS_TEXT, FALSE);
        EnableDlgItem( hDlg, IDC_ADVANCED_RATINGS_GROUPBOX, FALSE);
#endif
    }

    if( g_restrict.fCertif || g_restrict.fCertifPub)
        EnableWindow( GetDlgItem(hDlg, IDC_SECURITY_PUBLISHERS_BUTTON), FALSE );

    if( g_restrict.fCertif || g_restrict.fCertifPers || g_restrict.fCertifSite)
        EnableWindow( GetDlgItem(hDlg, IDC_SECURITY_SITES_BUTTON), FALSE );
        
    if( g_restrict.fProfiles )
    {
        EnableWindow(GetDlgItem(hDlg,  IDC_EDIT_PROFILE), FALSE);
    }

    if (hkey)
        RegCloseKey(hkey);
    
#ifdef WALLET
    if (g_restrict.fWallet)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_PROGRAMS_WALLET_SETTINGS), FALSE);
    }
#endif

    return TRUE;
}


void InitRatingsButton(HWND hDlg, HRESULT hrEnabled)
{
    TCHAR szBuf[MAX_RES_LEN+1];

    UINT idString;
    BOOL fEnableSettingsButton;

    if (FAILED(hrEnabled)) {
        /* Ratings are not installed.  Disable the Settings button and
         * set the other button to say "Enable".
         */
        idString = IDS_RATINGS_TURN_ON;
        fEnableSettingsButton = FALSE;
    }
    else {
        idString = (hrEnabled == S_OK) ? IDS_RATINGS_TURN_OFF : IDS_RATINGS_TURN_ON;
        fEnableSettingsButton = TRUE;
    }
    EnableWindow(GetDlgItem(hDlg, IDC_ADVANCED_RATINGS_BUTTON), fEnableSettingsButton);

    if (MLLoadString(
                   idString,
                   szBuf, sizeof(szBuf)) > 0) {
        SetDlgItemText(hDlg, IDC_RATINGS_TURN_ON, szBuf);
    }

}

//
// ContentDlgInit()
//
// Does initalization for Content Dlg.
//
//
BOOL ContentDlgInit( HWND hDlg)
{
    LPCONTENTPAGE pCon;

    pCon = (LPCONTENTPAGE)LocalAlloc(LPTR, sizeof(*pCon));
    if (!pCon)
    {
        EndDialog(hDlg, 0);
        return FALSE;   // no memory?
    }

    // tell dialog where to get info
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pCon);

    // save the handle to the page
    pCon->hDlg = hDlg;

    // Load the Ratings DLL (if possible)
    g_hinstRatings = LoadLibrary(c_tszRatingsDLL);

    // if not..
    if (!g_hinstRatings)
        g_restrict.fRatings = TRUE;     // disable Ratings section


    // set ratings dialog items... 

    // if MSRATING.DLL not around, then don't do this call.  By not
    // doing this, it will keep the "Enable Ratings" text on the button 
    // but greyed off.
    if (g_hinstRatings)
        pCon->hrUseRatings = RatingEnabledQuery();

    InitRatingsButton(hDlg, pCon->hrUseRatings);


    // if we can't find WINTRUST or SOFTPUB disable the
    // "Publishers" button.
    pCon->hWinTrust = LoadLibrary(TEXT("wintrust.dll"));

    if ( pCon->hWinTrust )
    {
        g_WinTrustDlgProc =
                           (WINTRUSTDLGPROC) GetProcAddress(pCon->hWinTrust, "OpenPersonalTrustDBDialog");

        // didn't find the procecdure
        if (!g_WinTrustDlgProc)
        {
            // release library and try the other DLL.
            FreeLibrary(pCon->hWinTrust);

            //
            // We can also find the same function on NT machines (and
            // possibly future Win95s) in SOFTPUB.DLL so make another
            // check there too.
            //
            pCon->hWinTrust = LoadLibrary(TEXT("softpub.dll"));
        }
    }

    if (pCon->hWinTrust && !g_WinTrustDlgProc)
        g_WinTrustDlgProc = (WINTRUSTDLGPROC) 
                            GetProcAddress(pCon->hWinTrust, "OpenPersonalTrustDBDialog");

    // if after all this, we can't find the procedure...
    if (!g_WinTrustDlgProc)
    {
        // disable the button
        EnableDlgItem(hDlg, IDC_SECURITY_PUBLISHERS_BUTTON, FALSE);
    }

    // Only present UI for flushing the SSL cache on Whistler or greater
    // This is the minimum version which has the default behavior of
    // maintaining the SSL cache for all processes in a logon session.
    //
    // Note:  This support was also added for Win2K SP2, but no cache
    //        clearing functionality was added.  It's also not enabled
    //        by default.
    if (IsOS(OS_WHISTLERORGREATER))
    {
        pCon->hSChannel = LoadLibrary(TEXT("SCHANNEL.DLL"));
        if (pCon->hSChannel)
        {
            g_pfnSslEmptyCacheW = (SSL_EMPTY_CACHE_FN_W) GetProcAddress(pCon->hSChannel, "SslEmptyCacheW");
        }
    }
                    
    if(!g_pfnSslEmptyCacheW)
    {
        ShowWindow(GetDlgItem(hDlg, IDC_SECURITY_CLEAR_SSL_CACHE_BUTTON), SW_HIDE);
        EnableWindow( GetDlgItem(hDlg, IDC_SECURITY_CLEAR_SSL_CACHE_BUTTON), FALSE );
    }

#ifdef WALLET
    EnableDlgItem(hDlg, IDC_PROGRAMS_WALLET_SETTINGS, TRUE);    
#endif

    ContentDlgEnableControls(hDlg);

    return TRUE;
}



//
// ContentOnCommand()
//
// Handles Content Dialog's window messages
//
// History:
//
// 6/17/96  t-gpease   created
//
void ContentOnCommand(LPCONTENTPAGE pCon, UINT id, UINT nCmd)
{
    switch (id) {

        case IDC_ADVANCED_RATINGS_BUTTON:
        {
            RatingSetupUI(pCon->hDlg, (LPCSTR) NULL);        
        }
        break; // IDC_ADVANCED_RATINGS_BUTTON

        case IDC_RATINGS_TURN_ON:
        {
            if (SUCCEEDED(RatingEnable(pCon->hDlg, (LPCSTR)NULL,
                                       pCon->hrUseRatings != S_OK))) 
            {
                pCon->hrUseRatings = RatingEnabledQuery();
                InitRatingsButton(pCon->hDlg, pCon->hrUseRatings);
            }
        }
        break;

        case IDC_SECURITY_CLEAR_SSL_CACHE_BUTTON:
        {
            if (g_pfnSslEmptyCacheW && (*g_pfnSslEmptyCacheW)(NULL, 0))
            {
                DWORD dwCount;
                // Leverage a private cache header data counter
                // that was never used to avoid passing a reg value.
                if (IncrementUrlCacheHeaderData(CACHE_HEADER_DATA_DOWNLOAD_PARTIAL, &dwCount))
                {
                    // Display message about clearing the cache OK.
                    TCHAR szText[MAX_PATH], szTitle[80];

                    MLLoadShellLangString(IDS_CLEAR_SSL_CACHE_TEXT, szText, ARRAYSIZE(szText));
                    MLLoadShellLangString(IDS_CLEAR_SSL_CACHE_TITLE, szTitle, ARRAYSIZE(szTitle));
                    
                    MessageBox(pCon->hDlg, szText, szTitle, MB_ICONINFORMATION | MB_OK);
                }
            }
        }
        break;

        case IDC_SECURITY_SITES_BUTTON:
        {
            CRYPTUI_CERT_MGR_STRUCT ccm = {0};
            ccm.dwSize = sizeof(ccm);
            ccm.hwndParent = pCon->hDlg;
            CryptUIDlgCertMgr(&ccm);
//          if (!g_hinstCryptui)
//          {
//              EnableWindow(GetDlgItem(pCon->hDlg, IDC_SECURITY_SITES_BUTTON), FALSE);
//          }
        }
            break;

        case IDC_SECURITY_PUBLISHERS_BUTTON:
        {
            if (g_WinTrustDlgProc)
            {
                g_WinTrustDlgProc(pCon->hDlg);
            }
        }
        break;

#ifdef WALLET
        case IDC_PROGRAMS_WALLET_SETTINGS:
        {
            HRESULT hr = S_OK;

            // See if wallet is installed at all
            if (!IsWalletPaymentAvailable())
            {
                uCLSSPEC clsspec;

                clsspec.tyspec = TYSPEC_CLSID;
                clsspec.tagged_union.clsid = CLSID_WalletPayment;

                // If wallet isn't installed, ask user if they'd like to install it
                hr = FaultInIEFeature(NULL, &clsspec, NULL, FIEF_FLAG_FORCE_JITUI);
            }

            if (SUCCEEDED(hr))
            {
                // Wallet is installed
                if (IsWallet3Installed())
                {
                    // if wallet 3.0 is installed, we want to invoke the wallet UI directly
                    DisplayWalletPaymentDialog(pCon->hDlg);
                }
                else
                {
                    // otherwise we need to pop up this intermediate dialog
                    DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_WALLET_SETTINGS), pCon->hDlg, WalletDlgProc);
                }
            }
        }
        break;
#endif

        case IDC_AUTOSUGGEST_SETTINGS:
        {
            DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_AUTOSUGGEST_SETTINGS), pCon->hDlg, AutoSuggestDlgProc);
        }
        break;

        case IDC_EDIT_PROFILE:
        {
            HMODULE hInstWAB = NULL;
            LPWABOBJECT  lpWABObject = NULL;
            LPADRBOOK lpAdrBook = NULL;
            HRESULT hr=S_OK;

            // Ask user to JIT in WAB if it's not installed
            uCLSSPEC clsspec;

            clsspec.tyspec = TYSPEC_CLSID;
            clsspec.tagged_union.clsid = CLSID_WAB;

            // If WAB isn't installed, ask user if they'd like to install it
            hr = FaultInIEFeature(NULL, &clsspec, NULL, FIEF_FLAG_FORCE_JITUI);

            if (FAILED(hr))
            {
                break;
            }
                
            // Figure out the location of the wab dll and try opening it.
            TCHAR szWABDllPath[MAX_PATH];
            DWORD dwType = 0;
            ULONG cbData = sizeof(szWABDllPath);
            HKEY hKey = NULL;
            SBinary SBMe = { 0, 0};

            *szWABDllPath = '\0';
            if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, WAB_DLL_PATH_KEY, 0, KEY_READ, &hKey))
            {
                RegQueryValueEx( hKey, TEXT(""), NULL, &dwType, (LPBYTE) szWABDllPath, &cbData);
                RegCloseKey(hKey);
            }

            if (lstrlen(szWABDllPath) > 0 )
            {
                hInstWAB = LoadLibrary(szWABDllPath);
            }

            if (hInstWAB)
            {
                LPWABOPEN lpfnWABOpen = (LPWABOPEN) GetProcAddress(hInstWAB, "WABOpen");

                if (lpfnWABOpen)
                {
                    hr = lpfnWABOpen(&lpAdrBook, &lpWABObject, NULL, 0);

                    if (NULL == lpAdrBook || NULL == lpWABObject)
                        hr = E_UNEXPECTED;
                }
                else 
                {
                    hr = HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND);  // Not the right dll anyway!!
                }
            }
            else
            {
                hr = HRESULT_FROM_WIN32(ERROR_DLL_NOT_FOUND);
            }

            DWORD dwAction = 0;

            // Good so far, call GetMe. WAB may create a new entry in this call.
            if (SUCCEEDED(hr))
            {
                hr = lpWABObject->GetMe(lpAdrBook, 0, &dwAction, &SBMe, 0);

                if (0 == SBMe.cb || NULL == SBMe.lpb)
                    hr = E_UNEXPECTED;
            }     

            // This shows the final UI. If WAB created a new entry in GetMe, they
            //   already showed this UI and we don't need to do it again.
            if (SUCCEEDED(hr) && !(dwAction & WABOBJECT_ME_NEW))
            {
                hr = lpAdrBook->Details(  (LPULONG) &pCon->hDlg,
                                          NULL,
                                          NULL,
                                          SBMe.cb,
                                          (LPENTRYID)SBMe.lpb,
                                          NULL,
                                          NULL,
                                          NULL,
                                          0);

            }
            if (lpWABObject)
            {
                if (SBMe.lpb != NULL)
                    lpWABObject->FreeBuffer(SBMe.lpb);

                lpWABObject->Release();
            }

            if (lpAdrBook)
                lpAdrBook->Release();

            if (hInstWAB)
                FreeLibrary(hInstWAB);
        }        
    }

} // ContentOnCommand()


/****************************************************************
Name: ContentDlgProc

SYNOPSIS: Set various security issue settings.

****************************************************************/

INT_PTR CALLBACK ContentDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    LPCONTENTPAGE pCon;

    if (uMsg == WM_INITDIALOG)
        return ContentDlgInit( hDlg );
    else
        pCon = (LPCONTENTPAGE) GetWindowLongPtr(hDlg, DWLP_USER);

    if (!pCon)
        return FALSE;
    
    switch (uMsg)
    {
        case WM_COMMAND:
            ContentOnCommand(pCon, LOWORD(wParam), HIWORD(wParam));
            return TRUE;

        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR *) lParam;

            ASSERT(lpnm);
            switch (lpnm->code) {
                case PSN_QUERYCANCEL:
                case PSN_KILLACTIVE:
                case PSN_RESET:
                    SetWindowLongPtr( pCon->hDlg, DWLP_MSGRESULT, FALSE );
                    return TRUE;

                case PSN_APPLY:
                    break;
            }
            break;
        }

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
            ASSERT(pCon);
            if (pCon)
            {
                if (pCon->hWinTrust)
                {
                    FreeLibrary(pCon->hWinTrust);
                    g_WinTrustDlgProc = NULL;
                }
                if (pCon->hSChannel)
                {
                    FreeLibrary(pCon->hSChannel);
                    g_pfnSslEmptyCacheW = NULL;
                }
                LocalFree(pCon);
            }
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
            break;
    }
    return FALSE;
}


typedef struct tagSITECERTDIALOGINFO {    
    HWND hDlg;
    HWND hwndList;
    HWND hwndCombo;
    int  iSel;
    HCERTSTORE hCertStore;
    BOOL    fInitializing;
} SITECERTDIALOGINFO, *LPSITECERTDIALOGINFO;

BOOL _SearchKeyUsage(CERT_ENHKEY_USAGE *pUsage, LPSTR pszUsageIdentifier)
{
    DWORD   i;

    for (i = 0; i < pUsage->cUsageIdentifier; i++)
    {
        if (StrCmpA(pUsage->rgpszUsageIdentifier[i], pszUsageIdentifier) == 0)
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

BOOL _IsKnownUsage(char *pszTest)
{
    char    **ppszKnown;

    ppszKnown = (char **)g_rgszEnhkeyUsage;

    while (*ppszKnown)
    {
        if (StrCmpA(*ppszKnown, pszTest) == 0)
        {
            return(TRUE);
        }

        ppszKnown++;
    }

    return(FALSE);
}

void __AddAllKnownEKU(PCCERT_CONTEXT pCert)
{
    char    **ppszKnown;

    ppszKnown = (char **)g_rgszEnhkeyUsage;

    while (*ppszKnown)
    {
       CertAddEnhancedKeyUsageIdentifier(pCert, *ppszKnown);

       ppszKnown++;
    }
}

BOOL _AnyKnownUsage(CERT_ENHKEY_USAGE *pUsage)
{
    DWORD   i;

    for (i = 0; i < pUsage->cUsageIdentifier; i++)
    {
        if (_IsKnownUsage(pUsage->rgpszUsageIdentifier[i]))
        {
            return(TRUE);
        }
    }

    return(FALSE);
}

BOOL _IsUsageEnabled(PCCERT_CONTEXT pCertContext, LPSTR pszUsageIdentifier, BOOL * pfFound)
{
    CERT_ENHKEY_USAGE   *pUsage;
    DWORD               cbUsage;


    *pfFound = FALSE;

    //
    // first, check the Extensions to see if we should even display it!
    //
    cbUsage = 0;
    CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG, NULL, &cbUsage);

    if (cbUsage > 0)
    {
        //
        //  we have some... make sure ours is in the list
        //
        if (!(pUsage = (CERT_ENHKEY_USAGE *)LocalAlloc(LPTR, cbUsage)))
        {
            return(FALSE);
        }

        CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG, pUsage, &cbUsage);

        if (!(_SearchKeyUsage(pUsage, pszUsageIdentifier)))
        {
            LocalFree((void *)pUsage);
            return(FALSE);
        }

        LocalFree((void *)pUsage);
    }

    *pfFound = TRUE;    // the cert should go in the list!

    //
    //  ethier there where no assertions made by the CA or we found it!  continue on...
    //

    //
    //  second, check the properties to see if we should check the box
    //
    cbUsage = 0;
    CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG, NULL, &cbUsage);

    if (cbUsage > 0)
    {
        // 
        //  we have properties... make sure we aren't disabled
        //
        if (!(pUsage = (CERT_ENHKEY_USAGE *)LocalAlloc(LPTR, cbUsage)))
        {
            return(FALSE);
        }

        CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG, pUsage, &cbUsage);

        if (_SearchKeyUsage(pUsage, g_rgszEnhkeyUsage[EKU_DISABLE_OFF]))
        {
            //
            //  the user has disabled the cert... keep it in the list un-checked
            //
            LocalFree((void *)pUsage);

            return(FALSE);
        }

        if (!(_SearchKeyUsage(pUsage, pszUsageIdentifier)))
        {
            //
            //  the user has set some, but, disabled this one... keep in the list un-checked
            //
            LocalFree((void *)pUsage);

            return(FALSE);
        }

        LocalFree((void *)pUsage);
    }

    return(TRUE);
}


BOOL SiteCert_InitListView(LPSITECERTDIALOGINFO pscdi)
{
    PCCERT_CONTEXT  pCertContext = NULL;
    
    // delete all items currently in the listview
    // we'll get called back via LVN_DELETEITEM with the lParam so we can free the cert context
    ListView_DeleteAllItems(pscdi->hwndList);
    
    pscdi->hCertStore = CertOpenSystemStoreA(NULL, "ROOT");
    
    if (pscdi->hCertStore)
    {
        LPSTR pszEnhkeyUsage;
        
        INT_PTR iSel;
        
        iSel = SendMessage(pscdi->hwndCombo, CB_GETCURSEL, 0,0);
        
        pszEnhkeyUsage = (LPSTR)SendMessage(pscdi->hwndCombo, CB_GETITEMDATA, iSel, 0);
       
        while (pCertContext = CertEnumCertificatesInStore(pscdi->hCertStore, pCertContext))
        {
            CHAR  szCertA[MAX_PATH];
            TCHAR szCert[MAX_PATH];
            DWORD cbszCert = ARRAYSIZE(szCertA);
            DWORD dwEnabled;
            BOOL fFound;

            dwEnabled = _IsUsageEnabled(pCertContext, (LPSTR)pszEnhkeyUsage, &fFound);     

            // if not found, then continue with next
            if (!fFound)
                continue;
            
            //ParseX509EncodedCertificateForListBoxEntry(pCertContext->pbCertEncoded, pCertContext->cbCertEncoded, szCert, &cbszCert);
            ParseX509EncodedCertificateForListBoxEntry((BYTE *)pCertContext, -1, szCertA, &cbszCert);
#ifdef UNICODE
            SHAnsiToUnicode(szCertA, szCert, ARRAYSIZE(szCert));
#else
            StrCpy(szCert, szCertA);
#endif
            LV_ITEM lvi = { 0 };

            lvi.mask       = LVIF_TEXT | LVIF_STATE | LVIF_PARAM;
            lvi.iItem      = -1;
            lvi.pszText    = szCert; // (LPSTR)pCertContext->pCertInfo->Subject.pbData;
            lvi.cchTextMax = ARRAYSIZE(szCert); // pCertContext->pCertInfo->Subject.cbData;

            lvi.stateMask  = LVIS_STATEIMAGEMASK;
            lvi.state      = dwEnabled ? 0x00002000 : 0x00001000;
            lvi.lParam     = (LPARAM)CertDuplicateCertificateContext(pCertContext);
            
            // insert and set state
            ListView_SetItemState(pscdi->hwndList,
                                  ListView_InsertItem(pscdi->hwndList, &lvi),
                                  dwEnabled ? 0x00002000 : 0x00001000,
                                  LVIS_STATEIMAGEMASK);
            
        }
        // show the items
        ListView_RedrawItems(pscdi->hwndList, 0, ListView_GetItemCount(pscdi->hwndList));
    }
    return TRUE;
}

//////////////////////////////////////////////////////////////////////////
////
////    08-Sep-1997: pberkman
////
////    PRIVATE function: _SiteCertAdjustProperties
////
////        based on what the user just checked/unchecked, set the 
////        appropriate OID usage or remove it.
////        
void _SiteCertAdjustProperties(LPSITECERTDIALOGINFO pscdi, NM_LISTVIEW *pListView)
{
    DWORD_PTR           dwSel;
    char                *pszOID;
    DWORD               cbUsage;
    CERT_ENHKEY_USAGE   *pUsage;


    //
    //  if we are in the initdialog get out!
    //
    if (pscdi->fInitializing)
    {
        return;
    }

    // 
    // make sure we have the property set
    //
    dwSel = SendMessage(pscdi->hwndCombo, CB_GETCURSEL, 0, 0);

    if (dwSel == CB_ERR)
    {
        return;
    }

    pszOID = (char*) SendMessage(pscdi->hwndCombo, CB_GETITEMDATA, (WPARAM)dwSel, 0);

    if (!(pszOID) || ((DWORD_PTR)pszOID == CB_ERR))
    {
        return;
    }

    if (pListView->uNewState & 0x00001000)  // unchecked
    {

        //
        //  the user unchecked one of the certs.
        //  
        //  1. if there are no properties, add all others -- HACKHACK!
        //
        cbUsage = 0;
        CertGetEnhancedKeyUsage((PCCERT_CONTEXT)pListView->lParam, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG, 
                                NULL, &cbUsage);

        if (cbUsage == 0)
        {
            //  add all
            __AddAllKnownEKU((PCCERT_CONTEXT)pListView->lParam);

            //  remove this one
            CertRemoveEnhancedKeyUsageIdentifier((PCCERT_CONTEXT)pListView->lParam, pszOID);
        }
        else
        {
            if (!(pUsage = (CERT_ENHKEY_USAGE *)LocalAlloc(LPTR, cbUsage)))
            {
                return;
            }

            CertGetEnhancedKeyUsage((PCCERT_CONTEXT)pListView->lParam, CERT_FIND_PROP_ONLY_ENHKEY_USAGE_FLAG, 
                                        pUsage, &cbUsage);
            //
            //  2. if there are properties.
            //      a. if this is the last known one, and it matches this, delete it and add the "disable"
            //
            if (pUsage->cUsageIdentifier == 1)
            {
                if (StrCmpA(pUsage->rgpszUsageIdentifier[0], pszOID) ==  0)
                {
                    CertRemoveEnhancedKeyUsageIdentifier((PCCERT_CONTEXT)pListView->lParam, pszOID);
                    CertAddEnhancedKeyUsageIdentifier((PCCERT_CONTEXT)pListView->lParam, 
                                                        g_rgszEnhkeyUsage[EKU_DISABLE_OFF]);
                }
            }
            else
            {
                //
                //  b. if there are more than one, just try to remove this one
                //
                CertRemoveEnhancedKeyUsageIdentifier((PCCERT_CONTEXT)pListView->lParam, pszOID);
            }

            LocalFree((void *)pUsage);
        }

        return;
    }

    if (pListView->uNewState & 0x00002000)  // checked
    {
        CertAddEnhancedKeyUsageIdentifier((PCCERT_CONTEXT)pListView->lParam, pszOID);

        //
        //  just in case, remove the disable!
        //
        CertRemoveEnhancedKeyUsageIdentifier((PCCERT_CONTEXT)pListView->lParam, 
                                                    g_rgszEnhkeyUsage[EKU_DISABLE_OFF]);
    }
}

BOOL SiteCert_OnNotify(LPSITECERTDIALOGINFO pscdi, WPARAM wParam, LPARAM lParam)
{
    NM_LISTVIEW *pnmlv = (NM_LISTVIEW *)lParam;
    
    switch (pnmlv->hdr.code) {
        case LVN_ITEMCHANGED:
        {
            // check the current state of selection
            int iSel = ListView_GetNextItem(pscdi->hwndList, -1, LVNI_SELECTED);

            // check to see if we need to enable/disable the "DELETE" and "VIEW" buttons
            EnableWindow(GetDlgItem(pscdi->hDlg, IDC_DELETECERT), iSel != -1);
            EnableWindow(GetDlgItem(pscdi->hDlg, IDC_VIEWCERT), iSel != -1);
            
            if ((pnmlv->uChanged & LVIF_STATE) && (GetFocus() == pscdi->hwndList))
            {
                _SiteCertAdjustProperties(pscdi, pnmlv);
            }
            break;
        }
        case LVN_DELETEITEM:
            CertFreeCertificateContext((PCCERT_CONTEXT)pnmlv->lParam);
            break;
    }
    return TRUE;
}

typedef struct tagNEWSITECERTINFO
{
    LPVOID  lpvCertData;
    DWORD   cbCert;

    BOOL    fCertEnabled;
    BOOL    fNetworkClient;
    BOOL    fNetworkServer;
    BOOL    fSecureEmail;
    BOOL    fSoftwarePublishing; 

} NEWSITECERTINFO, *LPNEWSITECERTINFO;


BOOL NewSiteCert_AddCert(LPNEWSITECERTINFO pnsci)
{

    HCERTSTORE      hCertStore = NULL;
    PCCERT_CONTEXT  pCertContext;
    BOOL            fRet = FALSE;

    hCertStore = CertOpenSystemStoreA(NULL, "ROOT");

    if (hCertStore)
    {
        pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                    (LPBYTE)(pnsci->lpvCertData),
                                                    pnsci->cbCert);

        if (pCertContext)
        {
            if (CertCompareCertificateName(X509_ASN_ENCODING,
                                           &pCertContext->pCertInfo->Subject,
                                           &pCertContext->pCertInfo->Issuer))
            {

                CertFreeCertificateContext(pCertContext);
                
                fRet = CertAddEncodedCertificateToStore(hCertStore,
                                                        X509_ASN_ENCODING,
                                                        (LPBYTE)(pnsci->lpvCertData),
                                                        pnsci->cbCert,
                                                        CERT_STORE_ADD_REPLACE_EXISTING,
                                                        &pCertContext);
                if (fRet)
                {
#                   define l_USAGE_MAX      24

                    CERT_ENHKEY_USAGE ceku = {0};
                    LPSTR rgpszUsageIdentifier[l_USAGE_MAX];
                    
                    if (pnsci->fNetworkClient)
                    {
                        rgpszUsageIdentifier[ceku.cUsageIdentifier] = g_rgszEnhkeyUsage[EKU_CLIENT_OFF];
                        if (rgpszUsageIdentifier[ceku.cUsageIdentifier])
                            ceku.cUsageIdentifier++;
                    }
                    if (pnsci->fNetworkServer)
                    {
                        rgpszUsageIdentifier[ceku.cUsageIdentifier] = g_rgszEnhkeyUsage[EKU_SERVER_OFF];
                        if (rgpszUsageIdentifier[ceku.cUsageIdentifier])
                            ceku.cUsageIdentifier++;
                    }
                    if (pnsci->fSecureEmail)
                    {
                        rgpszUsageIdentifier[ceku.cUsageIdentifier] = g_rgszEnhkeyUsage[EKU_EMAIL_OFF];
                        if (rgpszUsageIdentifier[ceku.cUsageIdentifier])
                            ceku.cUsageIdentifier++;
                    }
                    if (pnsci->fSoftwarePublishing)
                    {
                        rgpszUsageIdentifier[ceku.cUsageIdentifier] = g_rgszEnhkeyUsage[EKU_CODESIGN_OFF];
                        if (rgpszUsageIdentifier[ceku.cUsageIdentifier])
                            ceku.cUsageIdentifier++;
                    }

                    if (!(pnsci->fCertEnabled))
                    {
                        // turn everything off!!!
                        rgpszUsageIdentifier[ceku.cUsageIdentifier] = g_rgszEnhkeyUsage[EKU_DISABLE_OFF];
                        if (rgpszUsageIdentifier[ceku.cUsageIdentifier])
                            ceku.cUsageIdentifier++;
                    }

                    //
                    //  now, add any "unknown" extensions that the CA may have put on just
                    //  so verification will succeed!
                    //
                    CERT_ENHKEY_USAGE   *pUsage;
                    DWORD               cbUsage;
                    DWORD               i;

                    pUsage  = NULL;
                    cbUsage = 0;
                    CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG, NULL, &cbUsage);

                    if (cbUsage > 0)
                    {
                        if (pUsage = (PCERT_ENHKEY_USAGE)LocalAlloc(LMEM_FIXED, cbUsage))
                        {
                            CertGetEnhancedKeyUsage(pCertContext, CERT_FIND_EXT_ONLY_ENHKEY_USAGE_FLAG, 
                                                    pUsage, &cbUsage);

                            for (i = 0; i < pUsage->cUsageIdentifier; i++)
                            {
                                if (ceku.cUsageIdentifier >= l_USAGE_MAX)
                                {
                                    break;
                                }

                                if (pUsage->rgpszUsageIdentifier[i])
                                {
                                    if (!(_IsKnownUsage(pUsage->rgpszUsageIdentifier[i])))
                                    {
                                        rgpszUsageIdentifier[ceku.cUsageIdentifier] = pUsage->rgpszUsageIdentifier[i];
                                        ceku.cUsageIdentifier++;
                                    }
                                }
                            }
                        }
                    }

                    ceku.rgpszUsageIdentifier = (LPSTR *)rgpszUsageIdentifier;
                    fRet = CertSetEnhancedKeyUsage(pCertContext, &ceku);
                    
                    if (pUsage)
                    {
                        LocalFree((void *)pUsage);
                    }

                    CertFreeCertificateContext(pCertContext);
                }
            }
        }
        CertCloseStore(hCertStore, CERT_CLOSE_STORE_CHECK_FLAG);
    }
    return fRet;
}

//////////////////////////////////////////////////////////////////////////
////
////    15-Aug-1997: pberkman
////
////    PRIVATE function: NewSiteCert_SetAvailableAuthorityCheckboxes
////
////        set the check boxes in the "New Site Certificate" dialog box
////        based on the Authority Extensions and Properties.
////
////        if there are no Authority Ext or Prop's, then the certificate
////        has the potential for the user to enable for all.  Otherwise,
////        the user can ONLY select the ones that the issuer (or MS) has
////        entrusted the certificate for.
////        
typedef struct l_CERTUSAGES_
{
    char        *pszOID;
    DWORD       dwControlId;
    BOOL        fEnabled;

} l_CERTUSAGES;

BOOL NewSiteCert_SetAvailableAuthorityCheckboxes(HWND hDlg, LPNEWSITECERTINFO pnsci,
                                                 BOOL fInitialize)
{
    l_CERTUSAGES    asUsages[] =
    {
        szOID_PKIX_KP_CLIENT_AUTH,      IDC_CHECK_NETWORK_CLIENT,       FALSE,
        szOID_PKIX_KP_SERVER_AUTH,      IDC_CHECK_NETWORK_SERVER,       FALSE,
        szOID_PKIX_KP_EMAIL_PROTECTION, IDC_CHECK_SECURE_EMAIL,         FALSE,
        szOID_PKIX_KP_CODE_SIGNING,     IDC_CHECK_SOFTWARE_PUBLISHING,  FALSE,
        NULL, 0, FALSE
    };

    l_CERTUSAGES        *psUsages;
    PCCERT_CONTEXT      pCertContext;
    DWORD               cbUsage;
    PCERT_ENHKEY_USAGE  pUsage;
    
    if (fInitialize)
    {
        CheckDlgButton(hDlg, IDC_CHECK_ENABLE_CERT,         BST_CHECKED);
        
        CheckDlgButton(hDlg, IDC_CHECK_NETWORK_CLIENT,      BST_CHECKED);
        CheckDlgButton(hDlg, IDC_CHECK_NETWORK_SERVER,      BST_CHECKED);
        CheckDlgButton(hDlg, IDC_CHECK_SECURE_EMAIL,        BST_CHECKED);
        CheckDlgButton(hDlg, IDC_CHECK_SOFTWARE_PUBLISHING, BST_CHECKED);
    }

    pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                (LPBYTE)(pnsci->lpvCertData),
                                                 pnsci->cbCert);

    if (!(pCertContext))
    {
        psUsages = &asUsages[0];

        while (psUsages->pszOID)
        {
            EnableWindow(GetDlgItem(hDlg, psUsages->dwControlId), TRUE);

            psUsages++;
        }

        return(FALSE);
    }

    cbUsage = 0;

    CertGetEnhancedKeyUsage(pCertContext, 0, NULL, &cbUsage);

    if (cbUsage < 1)
    {
        // none defined... leave all enabled.
        CertFreeCertificateContext(pCertContext);
        psUsages = &asUsages[0];

        while (psUsages->pszOID)
        {
            EnableWindow(GetDlgItem(hDlg, psUsages->dwControlId), TRUE);

            psUsages++;
        }

        return(TRUE);
    }

    if (!(pUsage = (PCERT_ENHKEY_USAGE)LocalAlloc(LMEM_FIXED, cbUsage)))
    {
        CertFreeCertificateContext(pCertContext);
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return(FALSE);
    }

    if (!(CertGetEnhancedKeyUsage(pCertContext, 0, pUsage, &cbUsage)))
    {
        CertFreeCertificateContext(pCertContext);
        LocalFree(pUsage);
        return(FALSE);
    }

    if (pUsage->cUsageIdentifier == 0)
    {
        CertFreeCertificateContext(pCertContext);
        LocalFree(pUsage);
        // none defined... leave all enabled.
        return(TRUE);
    }

    CertFreeCertificateContext(pCertContext);

    for (int i = 0; i < (int)pUsage->cUsageIdentifier; i++)
    {
        psUsages = &asUsages[0];

        while (psUsages->pszOID)
        {
            if (StrCmpA(pUsage->rgpszUsageIdentifier[i], psUsages->pszOID) == 0)
            {
                psUsages->fEnabled = TRUE;
            }
            psUsages++;
        }
    }

    LocalFree(pUsage);

    psUsages = &asUsages[0];

    while (psUsages->pszOID)
    {
        if (fInitialize)
        {
            CheckDlgButton(hDlg, psUsages->dwControlId,      
                           (psUsages->fEnabled) ? BST_CHECKED : BST_UNCHECKED);
        }

        EnableWindow(GetDlgItem(hDlg, psUsages->dwControlId), psUsages->fEnabled);

        psUsages++;
    }

    return(TRUE);
}

void NewSiteCert_CenterDialog(HWND hDlg)
{
    RECT    rcDlg;
    RECT    rcArea;
    RECT    rcCenter;
    HWND    hWndParent;
    HWND    hWndCenter;
    DWORD   dwStyle;
    int     w_Dlg;
    int     h_Dlg;
    int     xLeft;
    int     yTop;

    GetWindowRect(hDlg, &rcDlg);

    dwStyle = (DWORD)GetWindowLong(hDlg, GWL_STYLE);

    if (dwStyle & WS_CHILD)
    {
        hWndCenter = GetParent(hDlg);

        hWndParent = GetParent(hDlg);

        GetClientRect(hWndParent, &rcArea);
        GetClientRect(hWndCenter, &rcCenter);
        MapWindowPoints(hWndCenter, hWndParent, (POINT *)&rcCenter, 2);
    }
    else
    {
        hWndCenter = GetWindow(hDlg, GW_OWNER);

        if (hWndCenter)
        {
            dwStyle = (DWORD)GetWindowLong(hWndCenter, GWL_STYLE);

            if (!(dwStyle & WS_VISIBLE) || (dwStyle & WS_MINIMIZE))
            {
                hWndCenter = NULL;
            }
        }

        SystemParametersInfo(SPI_GETWORKAREA, NULL, &rcArea, NULL);

        if (hWndCenter)
        {
            GetWindowRect(hWndCenter, &rcCenter);
        }
        else
        {
            rcCenter = rcArea;
        }
        
    }

    w_Dlg   = rcDlg.right - rcDlg.left;
    h_Dlg   = rcDlg.bottom - rcDlg.top;

    xLeft   = (rcCenter.left + rcCenter.right) / 2 - w_Dlg / 2;
    yTop    = (rcCenter.top + rcCenter.bottom) / 2 - h_Dlg / 2;
    
    if (xLeft < rcArea.left)
    {
        xLeft = rcArea.left;
    }
    else if ((xLeft + w_Dlg) > rcArea.right)
    {
        xLeft = rcArea.right - w_Dlg;
    }

    if (yTop < rcArea.top)
    {
        yTop = rcArea.top;
    }
    else if ((yTop + h_Dlg) > rcArea.bottom)
    {
        yTop = rcArea.bottom - h_Dlg;
    }

    SetWindowPos(hDlg, NULL, xLeft, yTop, -1, -1, SWP_NOZORDER | SWP_NOSIZE | SWP_NOACTIVATE);
}


INT_PTR CALLBACK NewSiteCert_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    LPNEWSITECERTINFO pnsci = (LPNEWSITECERTINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) {
        case WM_INITDIALOG:
        {
            DWORD  dwFileSize;
            DWORD  cbRead;
            HANDLE hf;
            LPTSTR lpszCmdLine = (LPTSTR)lParam;
            DWORD  dwError;

            hf = CreateFile(lpszCmdLine, GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 0,  NULL);
            if (hf == INVALID_HANDLE_VALUE)
            {
                dwError = GetLastError();
                goto initError;
            }

            dwFileSize = GetFileSize(hf, NULL);
            if (dwFileSize == (unsigned)-1)
                goto initError;

            pnsci = (LPNEWSITECERTINFO)LocalAlloc(LPTR, sizeof(*pnsci));
            if (!pnsci)
                goto initError;

            pnsci->lpvCertData = LocalAlloc(LPTR, dwFileSize);
            if (!pnsci->lpvCertData)
                goto initError;

            pnsci->cbCert      = dwFileSize;

            if (!ReadFile(hf, pnsci->lpvCertData, dwFileSize, &cbRead, NULL) || cbRead != dwFileSize)
                goto initError;

            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pnsci);  // save pointer to cert

            //
            //  ok check to make sure that 1) it's a cert file and 2) it's a root!
            //
            PCCERT_CONTEXT  pCertContext;

            dwError = S_FALSE;

            pCertContext = CertCreateCertificateContext(X509_ASN_ENCODING,
                                                        (LPBYTE)(pnsci->lpvCertData),
                                                        pnsci->cbCert);

            if (pCertContext)
            {
                if (CertCompareCertificateName(X509_ASN_ENCODING,
                                               &pCertContext->pCertInfo->Subject,
                                               &pCertContext->pCertInfo->Issuer))
                {
                    dwError = S_OK;
                }
             
                CertFreeCertificateContext(pCertContext);
            }

            if (dwError != S_OK)
            {
                goto initError;
            }

            NewSiteCert_SetAvailableAuthorityCheckboxes(hDlg, pnsci, TRUE);

            NewSiteCert_CenterDialog(hDlg);

            break;

initError:
            TCHAR   szTitle[MAX_PATH + 1];
            TCHAR   szError[MAX_PATH + 1];

            MLLoadShellLangString(IDS_CERT_FILE_INVALID, &szError[0], MAX_PATH);
            MLLoadShellLangString(IDS_ERROR, &szTitle[0], MAX_PATH);
            MessageBox(GetFocus(), &szError[0], &szTitle[0], MB_OK | MB_ICONERROR);

            EndDialog(hDlg, IDCANCEL);
            return FALSE;            
        }

        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    pnsci->fCertEnabled         = IsDlgButtonChecked(hDlg, IDC_CHECK_ENABLE_CERT);
                    pnsci->fNetworkClient       = IsDlgButtonChecked(hDlg, IDC_CHECK_NETWORK_CLIENT);
                    pnsci->fNetworkServer       = IsDlgButtonChecked(hDlg, IDC_CHECK_NETWORK_SERVER);
                    pnsci->fSecureEmail         = IsDlgButtonChecked(hDlg, IDC_CHECK_SECURE_EMAIL);
                    pnsci->fSoftwarePublishing  = IsDlgButtonChecked(hDlg, IDC_CHECK_SOFTWARE_PUBLISHING);

                    NewSiteCert_AddCert(pnsci);

                    EndDialog(hDlg, IDOK);
                    break;
                }

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    break;

                case IDC_VIEWCERT:
                    ShowX509EncodedCertificate(hDlg, (LPBYTE)pnsci->lpvCertData, pnsci->cbCert);
                    break;

                case IDC_CHECK_ENABLE_CERT:

                    if (HIWORD(wParam) == BN_CLICKED)
                    {
                        BOOL    fEnableCert;

                        fEnableCert = IsDlgButtonChecked(hDlg, IDC_CHECK_ENABLE_CERT);

                        if (!(fEnableCert))
                        {
                            EnableWindow(GetDlgItem(hDlg, IDC_CHECK_NETWORK_CLIENT),        fEnableCert);
                            EnableWindow(GetDlgItem(hDlg, IDC_CHECK_NETWORK_SERVER),        fEnableCert);
                            EnableWindow(GetDlgItem(hDlg, IDC_CHECK_SECURE_EMAIL),          fEnableCert);
                            EnableWindow(GetDlgItem(hDlg, IDC_CHECK_SOFTWARE_PUBLISHING),   fEnableCert);
                        }
                        else
                        {
                            NewSiteCert_SetAvailableAuthorityCheckboxes(hDlg, pnsci, FALSE);
                        }
                    }

                    return(FALSE);

                default:
                    return FALSE;
            }
            return TRUE;                
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
            if (pnsci)
            {
                if (pnsci->lpvCertData)
                    LocalFree(pnsci->lpvCertData);
                LocalFree(pnsci);
            }
            break;
    }
    return FALSE;
}

STDAPI SiteCert_RunFromCmdLine(HINSTANCE hinst, HINSTANCE hPrevInstance, LPTSTR lpszCmdLine, int nCmdShow)
{

    if ((!lpszCmdLine) || (*lpszCmdLine == TEXT('\0')))
        return -1;

    DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_NEWSITECERT),
                   NULL, NewSiteCert_DlgProc, (LPARAM)lpszCmdLine);

    return 0;
}



// Helper function for ExportPFX
#define NUM_KNOWN_STORES 5
BOOL OpenAndAllocKnownStores(DWORD *pchStores, HCERTSTORE  **ppahStores)
{
    HCERTSTORE  hStore;
    int i;
    static const LPCTSTR rszStoreNames[NUM_KNOWN_STORES] = {
        TEXT("ROOT"), 
        TEXT("TRUST"),
        TEXT("CA"),
        TEXT("MY"),
        TEXT("SPC")
    };
    
    *pchStores = 0;

    if (NULL == ((*ppahStores) = (HCERTSTORE *) LocalAlloc(LPTR, sizeof(HCERTSTORE) * NUM_KNOWN_STORES)))
    {
         return (FALSE);
    }

    for (i=0; i< NUM_KNOWN_STORES; i++)
    {
        (*ppahStores)[i] = NULL;
        if (hStore = CertOpenStore( CERT_STORE_PROV_SYSTEM_A,
                                    0,
                                    0,
                                    CERT_SYSTEM_STORE_CURRENT_USER |
                                    CERT_STORE_READONLY_FLAG |
                                    CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                    rszStoreNames[i]))
            (*ppahStores)[(*pchStores)++] = hStore;
    }
    
    return(TRUE);
}

// Helper function for ExportPFX
void CloseAndFreeKnownStores(HCERTSTORE  *pahStores)
{ 
    int i;

    for (i=0; i<NUM_KNOWN_STORES; i++)
    {
        if (pahStores[i] != NULL)
        {
           CertCloseStore(pahStores[i], 0);
        }
    }

    LocalFree(pahStores);
}



enum {PFX_IMPORT, PFX_EXPORT};

typedef struct 
{
    HWND            hDlg;                     // handle to window
    DWORD           dwImportExport;           // import or export?
    BOOL            fUseExisting;             // use existing cert if collision on import
    PCCERT_CONTEXT  pCertContext;    // context to export or NULL
    LPWSTR          pwszPassword;             // password for import/export
    LPWSTR          pwszPassword2;          // prompt user twice on exports!
    LPTSTR          pszPath;                 // file for import/export

} IMPORTEXPORT, *LPIMPORTEXPORT;

#define MAX_PASSWORD 32

// CreateCertFile: change working directory to "MyDocs", do CreateFile, restore old working directory
HANDLE CreateCertFile(LPCTSTR lpFileName, DWORD dwDesiredAccess, DWORD dwShareMode, LPSECURITY_ATTRIBUTES lpSecurityAttributes, 
        DWORD dwCreationDistribution, DWORD dwFlagsAndAttributes, HANDLE hTemplateFile)
{
    TCHAR szOldDir[MAX_PATH];
    TCHAR szCertDir[MAX_PATH];
    HANDLE hFile;
    LPITEMIDLIST pidl;
    
    GetCurrentDirectory(ARRAYSIZE(szOldDir), szOldDir);
    if (SHGetSpecialFolderLocation(NULL, CSIDL_PERSONAL, &pidl) == NOERROR)
    {
        SHGetPathFromIDList(pidl, szCertDir);
        SetCurrentDirectory(szCertDir);
        ILFree(pidl);                        
    }
    hFile = CreateFile(lpFileName, dwDesiredAccess, dwShareMode, lpSecurityAttributes, 
        dwCreationDistribution, dwFlagsAndAttributes, hTemplateFile);
    SetCurrentDirectory(szOldDir);
    
    return hFile;
}

//////////////////////////////////////////////////////////////////////////
//
//  09-Sep-1997 pberkman:
//          determine if the exact cert is in the passed store
//

BOOL __IsCertInStore(PCCERT_CONTEXT pCertContext, HCERTSTORE hStore)
{
    //
    //  can't do it the fast way -- do it the slow way!
    //
    BYTE            *pbHash;
    DWORD           cbHash;
    CRYPT_HASH_BLOB sBlob;
    PCCERT_CONTEXT  pWorkContext;

    cbHash = 0;

    if (!(CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, NULL, &cbHash)))
    {
        return(FALSE);
    }

    if (cbHash < 1)
    {
        return(FALSE);
    }

    if (!(pbHash = new BYTE[cbHash]))
    {
        return(FALSE);
    }

    if (!(CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, pbHash, &cbHash)))
    {
        delete pbHash;
        return(FALSE);
    }

    sBlob.cbData    = cbHash;
    sBlob.pbData    = pbHash;

    pWorkContext = CertFindCertificateInStore(hStore, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,
                                              CERT_FIND_SHA1_HASH, &sBlob, NULL);

    delete pbHash;

    if (pWorkContext)
    {
        CertFreeCertificateContext(pWorkContext);
        return(TRUE);
    }

    return(FALSE);
}

//////////////////////////////////////////////////////////////////////////
//
//  09-Sep-1997 pberkman:
//          importing a cert from a file.
//

BOOL ImportPFX(LPIMPORTEXPORT pImp)
{   
#   define MY_STORE         0
#   define CA_STORE         1
#   define ROOT_STORE       2
#   define MAX_STORE        3
    HCERTSTORE          pahStores[MAX_STORE];
    HCERTSTORE          hCertStore;
    BOOL                fAdded;
    DWORD               dwAddFlags;
    
    HANDLE              hFile;
    CRYPT_DATA_BLOB     sData;  
    
    BOOL                fRet;
    PCCERT_CONTEXT      pCertCtxt;
    DWORD               cbRead;
    DWORD               dwImportFlags;
    int                 i;

    fRet            = FALSE;
    dwImportFlags   = CRYPT_EXPORTABLE;
    pCertCtxt       = NULL;
    hCertStore      = NULL;

    for (i = 0; i < MAX_STORE; i++)
    {
        pahStores[i] = NULL;
    }

    ZeroMemory(&sData, sizeof(CRYPT_DATA_BLOB));
    
    hFile = CreateCertFile(pImp->pszPath, GENERIC_READ, FILE_SHARE_READ,
                           NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (hFile == INVALID_HANDLE_VALUE)
    {
        goto Cleanup;
    }
        
    dwAddFlags      = (pImp->fUseExisting) ? CERT_STORE_ADD_USE_EXISTING :
                                             CERT_STORE_ADD_REPLACE_EXISTING;
    
    sData.cbData = GetFileSize(hFile, NULL);
    sData.pbData = (PBYTE)LocalAlloc(LMEM_FIXED, sData.cbData);

    if (!(sData.pbData))
    {
        goto Cleanup;
    }

    if (!(ReadFile(hFile, sData.pbData, sData.cbData, &cbRead, NULL)))
    {
        goto Cleanup;
    }
    
    if ((pImp->pwszPassword) && (!(*pImp->pwszPassword)))     // if no password, use null.
    {
        pImp->pwszPassword = NULL;
    }
    
    if (!(hCertStore = PFXImportCertStore(&sData, pImp->pwszPassword, dwImportFlags)))
    {
        goto Cleanup;
    }

    //
    //  now we have in memory hStore enumerate the cert contexts
    //  and drop them into destination store
    //
    if (!(pahStores[MY_STORE]   = CertOpenSystemStoreA(NULL, "MY")) ||
        !(pahStores[CA_STORE]   = CertOpenSystemStoreA(NULL, "CA")) ||
        !(pahStores[ROOT_STORE] = CertOpenSystemStoreA(NULL, "ROOT")))
    {
        goto Cleanup;
    }

    while (pCertCtxt = CertEnumCertificatesInStore(hCertStore, pCertCtxt))
    {
        fAdded = FALSE;
        cbRead = 0;
        CertGetCertificateContextProperty(pCertCtxt, CERT_KEY_PROV_INFO_PROP_ID, NULL, &cbRead);
        
        if (cbRead > 0) // pfx added a public key prop
        {
            CertAddCertificateContextToStore(pahStores[MY_STORE], pCertCtxt, dwAddFlags, NULL);
            continue;
        }

        //
        //  first, check if we already have this cert in one of our stores
        //
        for (i = 0; i < MAX_STORE; i++)
        {
            if (__IsCertInStore(pCertCtxt, pahStores[i]))
            {
                //
                // the same cert, exactly, is already in one of our stores!
                //
                fAdded = TRUE;
                break;
            }
        }

        if (!(fAdded))
        {
            CertAddCertificateContextToStore(pahStores[CA_STORE], pCertCtxt, dwAddFlags, NULL);
        }
    }

    fRet = TRUE;

Cleanup:
    
    if (sData.pbData)
    {
        LocalFree(sData.pbData);
    }

    if (hFile != INVALID_HANDLE_VALUE)
    {
        CloseHandle(hFile);
    }

    if (hCertStore)
    {
        CertCloseStore(hCertStore, 0);
    }

    for (i = 0; i < MAX_STORE; i++)
    {
        if (pahStores[i])
        {
            CertCloseStore(pahStores[i], 0);
        }
    }
    
    return(fRet);
}

typedef PCCERT_CONTEXT (* PFNWTHELPER) (PCCERT_CONTEXT /* pChildContext */, 
                                        DWORD          /* chStores      */,
                                        HCERTSTORE *   /* pahStores     */,
                                        FILETIME *     /* psftVerifyAsOf*/,
                                        DWORD          /* dwEncoding    */,
                                        DWORD *        /* pdwConfidence */,
                                        DWORD *        /* pdwError      */ );



BOOL ExportPFX(LPIMPORTEXPORT pImp)
{
    BOOL                    fRet = FALSE;
    HANDLE                  hFile = NULL;
    CRYPT_DATA_BLOB         sData;  
    DWORD                   cbRead;
    HCERTSTORE              hSrcCertStore;        
    DWORD                   dwExportFlags = 4; //  4 == EXPORT_PRIVATE_KEYS;
    TCHAR                   szText[MAX_PATH], szTitle[80];
    PCCERT_CONTEXT pTempCertContext;
    HCERTSTORE	*phCertStores = NULL;
    DWORD		chCertStores = 0;
    DWORD		dwConfidence;
    DWORD		dwError;
    HINSTANCE hiWintrust = NULL;
    PFNWTHELPER WTHelperCertFindIssuerCertificate;
    

    if (!pImp->pCertContext)
        return FALSE;

    ZeroMemory(&sData, sizeof(CRYPT_DATA_BLOB));

    // create an in memory store
    hSrcCertStore = CertOpenStore(CERT_STORE_PROV_MEMORY,
                                  PKCS_7_ASN_ENCODING | X509_ASN_ENCODING,
                                  0,
                                  0,
                                  NULL);

    if (!CertAddCertificateContextToStore(hSrcCertStore, pImp->pCertContext, CERT_STORE_ADD_REPLACE_EXISTING, NULL))
        goto Cleanup;
    
    // Load helper function from wintrust.dll
    hiWintrust = LoadLibrary(TEXT("WINTRUST.DLL"));
    WTHelperCertFindIssuerCertificate = (PFNWTHELPER) GetProcAddress(hiWintrust,"WTHelperCertFindIssuerCertificate");
    if (WTHelperCertFindIssuerCertificate)
    {
        // Load all the top level stores, so we can export from them if necessary
        if (OpenAndAllocKnownStores(&chCertStores, &phCertStores))
        {
            // Find the intermediate certifcates, and add them to the store that we will be exporting
            pTempCertContext = pImp->pCertContext;
            while (NULL != ( pTempCertContext = WTHelperCertFindIssuerCertificate(pTempCertContext,
                                                    chCertStores,
                                                    phCertStores,
                                                    NULL,
                                                    X509_ASN_ENCODING,
                                                    &dwConfidence,
                                                    &dwError)))
            {
                CertAddCertificateContextToStore(hSrcCertStore, pTempCertContext, CERT_STORE_ADD_REPLACE_EXISTING, NULL);

                // Break out if we find a root (self-signed) cert
                if (CertCompareCertificateName(X509_ASN_ENCODING,
                                               &pTempCertContext->pCertInfo->Subject,
                                               &pTempCertContext->pCertInfo->Issuer))
                    break;
            } 

            CloseAndFreeKnownStores(phCertStores);
        }
    }

    //
    //  This first call simply gets the size of the crypt blob
    //
    if (!PFXExportCertStore(hSrcCertStore, &sData, pImp->pwszPassword, dwExportFlags))
    {
        goto Cleanup;
    }

    //  Alloc based on cbData
    sData.pbData = (PBYTE)LocalAlloc(LMEM_FIXED, sData.cbData);

    //
    //  Now actually get the data
    //
    if (!(*pImp->pwszPassword))         // no password use null
        pImp->pwszPassword = NULL;
    
    if (!PFXExportCertStore(hSrcCertStore, &sData, pImp->pwszPassword, dwExportFlags))
    {
        goto Cleanup;
    }

    //  Open the PFX file
    hFile = CreateCertFile(pImp->pszPath,
                       GENERIC_WRITE,
                       FILE_SHARE_READ,
                       NULL,
                       OPEN_ALWAYS,
                       FILE_ATTRIBUTE_NORMAL,
                       NULL);

    if (hFile == INVALID_HANDLE_VALUE)  {
        goto Cleanup;
    }

    //  Write to it
    if (!WriteFile(hFile,
                   sData.pbData,
                   sData.cbData,
                   &cbRead,
                   NULL)) {
        goto Cleanup;
    }

    // Display message about certs exporting OK.
    MLLoadShellLangString(IDS_CERT_EXPORTOKTEXT, szText, ARRAYSIZE(szText));
    MLLoadShellLangString(IDS_CERT_EXPORTOKTITLE, szTitle, ARRAYSIZE(szTitle));

    MessageBox(pImp->hDlg, szText, szTitle, MB_ICONINFORMATION | MB_OK);

    fRet = TRUE;

Cleanup:
    if (hiWintrust)
        FreeLibrary(hiWintrust);
    if (hSrcCertStore)
        CertCloseStore(hSrcCertStore, 0);
    if (hFile != INVALID_HANDLE_VALUE)
        CloseHandle(hFile);
    if (sData.pbData)
        LocalFree(sData.pbData);

    return fRet;
}
 
INT_PTR CALLBACK ImportExportDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    LPIMPORTEXPORT pImp;

    if (uMsg == WM_INITDIALOG)
    {
        pImp = (LPIMPORTEXPORT)lParam;    // this is passed in to us
        if (!pImp)
        {
            EndDialog(hDlg, 0);
            return FALSE;
        }

        // tell dialog where to get info
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pImp);

        // save handle to the page
        pImp->hDlg           = hDlg;

        // limit the password to 32 chars
        SendMessage(GetDlgItem(hDlg, IDC_PASSWORD), EM_LIMITTEXT, MAX_PASSWORD, 0);

        //
        // 03-Oct-1997 pberkman: always verify password!
        //
        if (pImp->dwImportExport == PFX_EXPORT)
        {
            SendMessage(GetDlgItem(hDlg, IDC_PASSWORD2), EM_LIMITTEXT, MAX_PASSWORD, 0);
        }

        SHAutoComplete(GetDlgItem(hDlg, IDC_FILENAME), SHACF_DEFAULT);      // This control exists in both IDD_PFX_IMPORT and IDD_PFX_EXPORT
        
        // only set these on import, since they don't exist on export =)
        // =========================================================================
        //  03-Oct-1997 pberkman: no user decisions!
        //
        // if (pImp->dwImportExport == PFX_IMPORT)
        // {
        //     CheckRadioButton(hDlg, IDC_USE_EXISTING, IDC_USE_FILE, IDC_USE_EXISTING);                        
        // }            
        // ==========================================================================
        SetFocus(GetDlgItem(hDlg, IDC_PASSWORD));

    }   // WM_INITDIALOG
    
    else
        pImp = (LPIMPORTEXPORT)GetWindowLongPtr(hDlg, DWLP_USER);

    if (!pImp)
        return FALSE;
    
    switch (uMsg)
    {
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDC_CERT_BROWSE:
                {
                    TCHAR szFilenameBrowse[MAX_PATH];
                    TCHAR szExt[MAX_PATH];
                    TCHAR szFilter[MAX_PATH];
                    int   ret;
                    LPITEMIDLIST pidl;
                    TCHAR szWorkingDir[MAX_PATH];
                   
                    szFilenameBrowse[0] = 0;
                    MLLoadString(IDS_PFX_EXT, szExt, ARRAYSIZE(szExt));
                    int cchFilter = MLLoadString(IDS_PFX_FILTER, szFilter, ARRAYSIZE(szFilter)-1);

                    // Make sure we have a double null termination on the filter
                    szFilter[cchFilter + 1] = 0;

                    if (SHGetSpecialFolderLocation(hDlg, CSIDL_PERSONAL, &pidl) == NOERROR)
                    {
                        SHGetPathFromIDList(pidl, szWorkingDir);
                        ILFree(pidl);                        
                    }

                    ret = _AorW_GetFileNameFromBrowse(hDlg, szFilenameBrowse, ARRAYSIZE(szFilenameBrowse), szWorkingDir, 
                        szExt, szFilter, NULL);
                    
                    if (ret > 0)
                    {
                        SetDlgItemText(hDlg, IDC_FILENAME, szFilenameBrowse);
                    }
                    break;
                }
                
                case IDOK:
                {
                    TCHAR szPassword[MAX_PASSWORD];
                    TCHAR szPassword2[MAX_PASSWORD];
                    TCHAR szPath[MAX_PATH];
                    BOOL bRet;
                    
                    szPassword[0] = NULL;
                    GetWindowText(GetDlgItem(hDlg, IDC_PASSWORD), szPassword, ARRAYSIZE(szPassword));
                    GetWindowText(GetDlgItem(hDlg, IDC_FILENAME), szPath,     ARRAYSIZE(szPath));

                    //
                    //  03-Oct-1997 pberkman: always double check password!
                    //
                    if (pImp->dwImportExport == PFX_EXPORT)
                    {
                        szPassword2[0] = NULL;
                        GetWindowText(GetDlgItem(hDlg, IDC_PASSWORD2), szPassword2, ARRAYSIZE(szPassword2));

                        if (StrCmp(szPassword, szPassword2) != 0)
                        {
                            TCHAR   szTitle[MAX_PATH + 1];
                            TCHAR   szError[MAX_PATH + 1];

                            MLLoadShellLangString(IDS_PASSWORDS_NOMATCH, &szError[0], MAX_PATH);
                            MLLoadShellLangString(IDS_ERROR, &szTitle[0], MAX_PATH);
                            MessageBox(GetFocus(), &szError[0], &szTitle[0], MB_OK | MB_ICONERROR);

                            SetFocus(GetDlgItem(hDlg, IDC_PASSWORD));

                            break;
                        }
                    }

                    // Add a default extension on export
                    if (pImp->dwImportExport == PFX_EXPORT)
                        if (szPath[0] != TEXT('\0') && PathAddExtension(szPath, TEXT(".PFX")))
                            SetWindowText(GetDlgItem(hDlg, IDC_FILENAME), szPath);

#ifndef UNICODE
                    WCHAR wszPassword[MAX_PASSWORD];
                    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szPassword, -1, wszPassword, ARRAYSIZE(wszPassword));
                    pImp->pwszPassword = wszPassword;
#else
                    pImp->pwszPassword = szPassword;
#endif
                    pImp->pszPath = szPath;
                    
                    if (pImp->dwImportExport == PFX_IMPORT)
                    {
                        // =========================================================================
                        //  03-Oct-1997 pberkman: no user decisions!
                        //
                        // pImp->fUseExisting = IsDlgButtonChecked(hDlg, IDC_USE_EXISTING);
                        // =========================================================================
                        pImp->fUseExisting = FALSE;
                        bRet = ImportPFX(pImp);

                        if (!(bRet) && (GetLastError() == NTE_BAD_DATA))
                        {
                            // message....
                        }
                    }
                    else
                    {
                        bRet = ExportPFX(pImp);
                    }
                    
                    EndDialog(hDlg, bRet);
                    break;
                }
                
                case IDCANCEL:
                    EndDialog(hDlg, TRUE); // Cancel is not an error
                    break;

            }
            break;
            
        case WM_NOTIFY:
            break;
// No context sensitive help yet...
#if 0
        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;
#endif
        case WM_DESTROY:
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
            break;
    }
    return FALSE;
}


#ifdef UNIX
EXTERN_C
#endif
INT_PTR ImportExportPFX(HWND hwndParent, DWORD dwImportExport, LPBYTE pbCert, DWORD cbCert)
{
    IMPORTEXPORT    imp;

    if (pbCert)
    {
        CRYPT_HASH_BLOB  hashBlob;
        HCERTSTORE       hMy = CertOpenSystemStoreA(NULL, "MY");
        DWORD            cbSHA1Hash;
        LPBYTE           pbSHA1Hash;

        if (!hMy)
            return FALSE;
        
        if (CryptHashCertificate(NULL, 0, 0, pbCert, cbCert, NULL, &cbSHA1Hash))
        {
            pbSHA1Hash = (LPBYTE)LocalAlloc(LPTR, cbSHA1Hash);
            if (!pbSHA1Hash)
                return FALSE;

            if (CryptHashCertificate(NULL, 0, 0, pbCert, cbCert, pbSHA1Hash, &cbSHA1Hash))
            {                                
                hashBlob.cbData = cbSHA1Hash;
                hashBlob.pbData = pbSHA1Hash;
                imp.pCertContext = CertFindCertificateInStore(hMy, X509_ASN_ENCODING, 0, CERT_FIND_HASH, &hashBlob, NULL);
                if (!(imp.pCertContext))
                    return FALSE;
            }

            LocalFree(pbSHA1Hash);
        }

        CertCloseStore(hMy, 0);
    }

    imp.dwImportExport = dwImportExport;
    
    return DialogBoxParam(MLGetHinst(),
                   dwImportExport == PFX_IMPORT ? MAKEINTRESOURCE(IDD_PFX_IMPORT) : MAKEINTRESOURCE(IDD_PFX_EXPORT),
                   hwndParent, ImportExportDlgProc, (LPARAM)&imp);
}

//BUBUG: The following function should be rermoved when we have updated our Crypto API to latest
BOOL WINAPI WTHelperIsInRootStore(PCCERT_CONTEXT pCertContext)
{
    HCERTSTORE  hStore;

    if (!(hStore = CertOpenStore(   CERT_STORE_PROV_SYSTEM_A,
                                    0,
                                    NULL,
                                    CERT_SYSTEM_STORE_CURRENT_USER |
                                    CERT_STORE_READONLY_FLAG |
                                    CERT_STORE_NO_CRYPT_RELEASE_FLAG,
                                    "ROOT")))
    {
        return(FALSE);
    }


    //
    //  can't do it the fast way -- do it the slow way!
    //
    BYTE            *pbHash;
    DWORD           cbHash;
    CRYPT_HASH_BLOB sBlob;
    PCCERT_CONTEXT  pWorkContext;

    cbHash = 0;

    if (!(CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, NULL, &cbHash)))
    {
        CertCloseStore(hStore, 0);
        return(FALSE);
    }

    if (cbHash < 1)
    {
        CertCloseStore(hStore, 0);
        return(FALSE);
    }

    if (!(pbHash = new BYTE[cbHash]))
    {
        CertCloseStore(hStore, 0);
        return(FALSE);
    }

    if (!(CertGetCertificateContextProperty(pCertContext, CERT_SHA1_HASH_PROP_ID, pbHash, &cbHash)))
    {
        delete pbHash;
        CertCloseStore(hStore, 0);
        return(FALSE);
    }

    sBlob.cbData    = cbHash;
    sBlob.pbData    = pbHash;

    pWorkContext = CertFindCertificateInStore(hStore, X509_ASN_ENCODING | PKCS_7_ASN_ENCODING, 0,
                                              CERT_FIND_SHA1_HASH, &sBlob, NULL);

    delete pbHash;

    if (pWorkContext)
    {
        CertFreeCertificateContext(pWorkContext);
        CertCloseStore(hStore, 0);
        return(TRUE);
    }

    CertCloseStore(hStore, 0);

    return(FALSE);
}


//============================================================================
const TCHAR c_szRegKeySMIEM[] = TEXT("Software\\Microsoft\\Internet Explorer\\Main");
const TCHAR c_szRegValFormSuggest[] = TEXT("Use FormSuggest");
const TCHAR c_szRegValFormSuggestPW[] = TEXT("FormSuggest Passwords");
const TCHAR c_szRegValFormSuggestPWAsk[] = TEXT("FormSuggest PW Ask");

const TCHAR c_szYes[] = TEXT("yes");
const TCHAR c_szNo[] = TEXT("no");

inline void SetValueHelper(HWND hDlg, int id, LPTSTR *ppszData, DWORD *pcbData)
{
    if (IsDlgButtonChecked(hDlg, id))
    {
        *ppszData = (LPTSTR)c_szYes;
        *pcbData = sizeof(c_szYes);
    }
    else
    {
        *ppszData = (LPTSTR)c_szNo;
        *pcbData = sizeof(c_szNo);
    }
}

INT_PTR CALLBACK AutoSuggestDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            CheckDlgButton(hDlg, IDC_AUTOSUGGEST_ENABLEADDR,
                (SHRegGetBoolUSValue(REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOSUGGEST, FALSE, /*default:*/TRUE)) ?
                BST_CHECKED : BST_UNCHECKED);

            if (g_restrict.fFormSuggest)
            {
                EnableDlgItem(hDlg, IDC_AUTOSUGGEST_ENABLEFORM, FALSE);
            }
            else
            {
                CheckDlgButton(hDlg, IDC_AUTOSUGGEST_ENABLEFORM,
                    (SHRegGetBoolUSValue(c_szRegKeySMIEM, c_szRegValFormSuggest, FALSE, /*default:*/FALSE)) ?
                    BST_CHECKED : BST_UNCHECKED);
            }

            if (g_restrict.fFormPasswords)
            {
                EnableDlgItem(hDlg, IDC_AUTOSUGGEST_SAVEPASSWORDS, FALSE);
                EnableDlgItem(hDlg, IDC_AUTOSUGGEST_PROMPTPASSWORDS, FALSE);
            }
            else
            {
                CheckDlgButton(hDlg, IDC_AUTOSUGGEST_PROMPTPASSWORDS,
                    (SHRegGetBoolUSValue(c_szRegKeySMIEM, c_szRegValFormSuggestPWAsk, FALSE, /*default:*/TRUE)) ?
                    BST_CHECKED : BST_UNCHECKED);
            
                if (SHRegGetBoolUSValue(c_szRegKeySMIEM, c_szRegValFormSuggestPW, FALSE, /*default:*/TRUE))
                {
                    CheckDlgButton(hDlg, IDC_AUTOSUGGEST_SAVEPASSWORDS, BST_CHECKED);
                }
                else
                {
                    EnableDlgItem(hDlg, IDC_AUTOSUGGEST_PROMPTPASSWORDS, FALSE);
                }
            }
        }

        return TRUE;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDC_AUTOSUGGEST_SAVEPASSWORDS:
                    EnableDlgItem(hDlg, IDC_AUTOSUGGEST_PROMPTPASSWORDS,
                        IsDlgButtonChecked(hDlg, IDC_AUTOSUGGEST_SAVEPASSWORDS));
                    break;
                    
                case IDC_AUTOSUGGEST_CLEARFORM:
                case IDC_AUTOSUGGEST_CLEARPASSWORDS:
                {
                    BOOL fPasswords = (LOWORD(wParam) == IDC_AUTOSUGGEST_CLEARPASSWORDS);
                    DWORD dwClear = (fPasswords) ?
                            IECMDID_ARG_CLEAR_FORMS_PASSWORDS_ONLY : IECMDID_ARG_CLEAR_FORMS_ALL_BUT_PASSWORDS;

                    if (IDOK == MsgBox(hDlg, ((fPasswords) ? IDS_CLEAR_FORMPASSWORDS : IDS_CLEAR_FORMSUGGEST), MB_ICONQUESTION, MB_OKCANCEL))
                    {
                        HCURSOR hOldCursor = NULL;
                        HCURSOR hNewCursor = NULL;

#ifndef UNIX
                        hNewCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT));
#else
                        // IEUNIX - Getting rid of redundant MAKEINTRESOURCE 
                        hNewCursor = LoadCursor(NULL, IDC_WAIT);
#endif

                        if (hNewCursor) 
                            hOldCursor = SetCursor(hNewCursor);

                        // Clear all strings
                        ClearAutoSuggestForForms(dwClear);

                        // Also reset profile assistant sharing (very discoverable here)
                        if (!g_restrict.fProfiles)
                        {
                            ResetProfileSharing(hDlg);
                        }

                        if(hOldCursor)
                            SetCursor(hOldCursor);
                    }
                }
                break;

                case IDOK:
                {
                    DWORD cbData; LPTSTR pszData;

                    SetValueHelper(hDlg, IDC_AUTOSUGGEST_ENABLEADDR, &pszData, &cbData);
                    SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_AUTOCOMPLETE, REGSTR_VAL_USEAUTOSUGGEST,
                        REG_SZ, pszData, cbData);

                    if (!g_restrict.fFormSuggest)
                    {
                        SetValueHelper(hDlg, IDC_AUTOSUGGEST_ENABLEFORM, &pszData, &cbData);
                        SHSetValue(HKEY_CURRENT_USER, c_szRegKeySMIEM, c_szRegValFormSuggest,
                            REG_SZ, pszData, cbData);
                    }

                    if (!g_restrict.fFormPasswords)
                    {
                        SetValueHelper(hDlg, IDC_AUTOSUGGEST_SAVEPASSWORDS, &pszData, &cbData);
                        SHSetValue(HKEY_CURRENT_USER, c_szRegKeySMIEM, c_szRegValFormSuggestPW,
                            REG_SZ, pszData, cbData);
                            
                        SetValueHelper(hDlg, IDC_AUTOSUGGEST_PROMPTPASSWORDS, &pszData, &cbData);
                        SHSetValue(HKEY_CURRENT_USER, c_szRegKeySMIEM, c_szRegValFormSuggestPWAsk,
                            REG_SZ, pszData, cbData);
                    }
                }
                // fall through
                case IDCANCEL:
                {
                    EndDialog(hDlg, LOWORD(wParam));
                }
                break;
            }
        }
        return TRUE;

    case WM_HELP:                   // F1
        ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                    HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
    break;

    case WM_CONTEXTMENU:        // right mouse click
        ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                    HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
    break;

    case WM_DESTROY:
        break;

    }

    return FALSE;
}

#ifdef WALLET
// This intermediate dialog is only displayed for wallet 2.x users
INT_PTR CALLBACK WalletDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            EnableDlgItem(hDlg, IDC_PROGRAMS_WALLET_PAYBUTTON, IsWalletPaymentAvailable());
            EnableDlgItem(hDlg, IDC_PROGRAMS_WALLET_ADDRBUTTON, IsWalletAddressAvailable());
        }
        return TRUE;

        case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
                case IDC_PROGRAMS_WALLET_PAYBUTTON:
                    DisplayWalletPaymentDialog(hDlg);
                    break;

                case IDC_PROGRAMS_WALLET_ADDRBUTTON:
                    DisplayWalletAddressDialog(hDlg);
                    break;

                case IDOK:
                case IDCANCEL:
                {
                    EndDialog(hDlg, LOWORD(wParam));
                }
                break;
            }
        }
        return TRUE;

    case WM_HELP:                   // F1
        ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                    HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
    break;

    case WM_CONTEXTMENU:        // right mouse click
        ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                    HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
    break;

    case WM_DESTROY:
        break;

    }

    return FALSE;
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\inetcver.h ===
#if WINNT  // versioninfo
#include <winver.h>
#include <ntverp.h>
#else
#include <version.h>
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\general.cpp ===
///////////////////////////////////////////////////////////////////////
//           Microsoft Windows                   //
//         Copyright(c) Microsoft Corp., 1995            //
///////////////////////////////////////////////////////////////////////
//
// GENERAL.C - "General" property page for InetCpl
//

// HISTORY:
//
// 6/22/96  t-gpease    moved code from dialdlg.c - no changes
//

#include "inetcplp.h"

#include <urlhist.h>
#include <initguid.h>
#include <shlguid.h>
#include <cleanoc.h>

#include <mluisupp.h>

//#include <shdocvw.h>
SHDOCAPI_(BOOL) ParseURLFromOutsideSourceA (LPCSTR psz, LPSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL);
SHDOCAPI_(BOOL) ParseURLFromOutsideSourceW (LPCWSTR psz, LPWSTR pszOut, LPDWORD pcchOut, LPBOOL pbWasSearchURL);
#ifdef UNICODE
#define ParseURLFromOutsideSource ParseURLFromOutsideSourceW 
#else
#define ParseURLFromOutsideSource ParseURLFromOutsideSourceA 
#endif

// 
// See inetcplp.h for documentation on this flag
//
BOOL g_fReloadHomePage = FALSE;

// 
// Private Functions and Structures
//
// from cachecpl.c
#define CONTENT 0
BOOL InvokeCachevu(HWND hDlg);
INT_PTR CALLBACK EmptyCacheDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK EmptyCacheCookiesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);
BOOL DeleteCacheCookies();

INT_PTR CALLBACK ColorsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK AccessibilityDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);

/////// General Tab Info Structure ///////

typedef struct _GeneralTabInfo {
    HWND  hDlg;
    HWND  hwndUrl;
    TCHAR szCurrentURL[INTERNET_MAX_URL_LENGTH];   // current url in browser
    TCHAR szStartPageURL[INTERNET_MAX_URL_LENGTH]; // current url for start page

    BOOL    fInternalChange;
    BOOL    fChanged;

    HRESULT hrOle;                              // result of com initialization
} GeneralTabInfo, *LPGENERALTABINFO, GENERALTABINFO;

void SetandSelectText(LPGENERALTABINFO pgti, HWND hwnd, LPTSTR psz);
BOOL GetHistoryFolderPath(LPTSTR pszPath);
void EmptyHistory(LPGENERALTABINFO pgti);
void HistorySave(LPGENERALTABINFO pgti);
static DWORD GetDaysToKeep(VOID);
VOID SetDaysToKeep(DWORD dwDays);
void GetDefaultStartPage(LPGENERALTABINFO pgti);
HRESULT _GetStdLocation(LPTSTR pszPath, DWORD cbPathSize, UINT id);
HRESULT _SetStdLocation(LPTSTR szPath, UINT id);

// from shdocvw
#define IDS_DEF_HOME    998  //// WARNING!!! DO NOT CHANGE THESE VALUES
#define IDS_DEF_SEARCH  999 //// WARNING!!!  INETCPL RELIES ON THEM

#define IDS_SEARCHPAGE                  IDS_DEF_SEARCH
#define IDS_STARTPAGE                   IDS_DEF_HOME

#if defined(ux10) && defined(UNIX)
//Work around for mmap limitation in hp-ux10
#define MAX_HISTORY_DAYS        30
#else
#define MAX_HISTORY_DAYS        999
#endif

#define DEFAULT_DAYS_TO_KEEP    14
#define SAFERELEASE(p)      if(p) {(p)->Release(); (p) = NULL;}

TCHAR szDefURLValueNames[] = TEXT("Default_Page_URL");

//
// Functions
//
BOOL General_InitDialog(HWND hDlg)
{
    DWORD cb = sizeof(DWORD);
    LPGENERALTABINFO pgti;
#ifdef UNIX
    BOOL  bCacheIsReadOnly = FALSE;
#endif /* UNIX */

    // allocate memory for a structure which will hold all the info
    // gathered from this page
    //
    pgti = (LPGENERALTABINFO)LocalAlloc(LPTR, sizeof(GENERALTABINFO));
    if (!pgti)
    {
        EndDialog(hDlg, 0);
        return FALSE;
    }
    SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pgti);

    // NOTE (andrewgu): ie5.5 b#106468 - need to initialize COM before calling SHAutoComplete.
    // it will be uninitialized during WM_DESTROY.
    pgti->hrOle = SHCoInitialize();

    // cross-lang platform support
    SHSetDefaultDialogFont(hDlg, IDC_START_ADDRESS);
    SHAutoComplete(GetDlgItem(hDlg, IDC_START_ADDRESS), SHACF_DEFAULT);                

    pgti->hDlg = hDlg;
    // enable the "Use Current" button if we have a current url
    StrCpyN(pgti->szCurrentURL, g_szCurrentURL, ARRAYSIZE(pgti->szCurrentURL));
    EnableWindow(GetDlgItem(hDlg, IDC_USECURRENT), pgti->szCurrentURL[0]);

    // get the url edit control and set the text limit
    pgti->hwndUrl = GetDlgItem(hDlg, IDC_START_ADDRESS);
    SendMessage(pgti->hwndUrl, EM_LIMITTEXT, ARRAYSIZE(pgti->szStartPageURL)-1, 0);

    GetDefaultStartPage(pgti);
    _GetStdLocation(pgti->szStartPageURL, ARRAYSIZE(pgti->szStartPageURL), IDS_STARTPAGE);
    SetandSelectText(pgti, pgti->hwndUrl, (LPTSTR)pgti->szStartPageURL);
    // set restrictions on history controls
    SendDlgItemMessage(pgti->hDlg, IDC_HISTORY_SPIN,
                       UDM_SETRANGE, 0, MAKELPARAM(MAX_HISTORY_DAYS, 0));

    SendDlgItemMessage(pgti->hDlg, IDC_HISTORY_SPIN,
                       UDM_SETPOS, 0, MAKELPARAM((WORD) GetDaysToKeep(), 0));

    Edit_LimitText(GetDlgItem(hDlg,IDC_HISTORY_DAYS),3);    // limit edit ctrl to 3 chars

    // only when invoked from View|Options
    if (g_szCurrentURL[0])
    {
        TCHAR szTitle[128];
        MLLoadString(IDS_INTERNETOPTIONS, szTitle, ARRAYSIZE(szTitle));
        SendMessage(GetParent(hDlg), WM_SETTEXT, 0, (LPARAM)szTitle);
    }

    // disable stuff based on restrictions
    if (g_restrict.fPlaces)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_START_ADDRESS), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_USEDEFAULT), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_USEBLANK), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_USECURRENT), FALSE);
    }
    
    if (g_restrict.fCacheReadOnly)
    {
       EnableWindow(GetDlgItem(hDlg, IDC_CACHE_DELETE_COOKIES), FALSE);
       EnableWindow(GetDlgItem(hDlg, IDC_CACHE_DELETE_FILES), FALSE);
       EnableWindow(GetDlgItem(hDlg, IDC_CACHE_SETTINGS), FALSE);
    }
    
#ifdef UNIX
    bCacheIsReadOnly = IsCacheReadOnly();

    if (bCacheIsReadOnly)
    {
       EnableWindow(GetDlgItem(hDlg, IDC_CACHE_DELETE_COOKIES), FALSE);
       EnableWindow(GetDlgItem(hDlg, IDC_CACHE_DELETE_FILES), FALSE);
       EnableWindow(GetDlgItem(hDlg, IDC_CACHE_SETTINGS), FALSE);
    }

    if (g_restrict.fCache || bCacheIsReadOnly)
    {
       TCHAR szText[1024];
 
       MLLoadString(IDS_READONLY_CACHE_TEXT,  szText, ARRAYSIZE(szText));
 
       SetWindowText(GetDlgItem(hDlg, IDC_READONLY_CACHE_WARNING), szText);
       ShowWindow( GetDlgItem(hDlg, IDC_READONLY_CACHE_WARNING), SW_SHOW );
 
       ShowWindow( GetDlgItem(hDlg, IDC_TEMP_INTERNET_TEXT), SW_HIDE);
    }
#endif /* !UNIX */
    if (g_restrict.fHistory)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_HISTORY_DAYS), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_HISTORY_SPIN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_HISTORY_CLEAR), FALSE);
    }
    return TRUE;
}

BOOL General_OnCommand(LPGENERALTABINFO pgti, UINT id, UINT nCmd)
{
    switch (id)
    { 

        case IDC_START_ADDRESS:
            switch (nCmd)
            {
                case EN_CHANGE:
                    if (!pgti->fInternalChange)
                    {
                        PropSheet_Changed(GetParent(pgti->hDlg),pgti->hDlg);
                        pgti->fChanged = TRUE;
                    }
                    break;
            }
            break;

        case IDC_USECURRENT:
            if (nCmd == BN_CLICKED)
            {
                StrCpyN(pgti->szStartPageURL, pgti->szCurrentURL, ARRAYSIZE(pgti->szStartPageURL));
                SetandSelectText(pgti, pgti->hwndUrl,  pgti->szStartPageURL);
                PropSheet_Changed(GetParent(pgti->hDlg),pgti->hDlg);
                pgti->fChanged = TRUE;
            }
            break;

        case IDC_USEDEFAULT:
            if (nCmd == BN_CLICKED)
            {
                GetDefaultStartPage(pgti);
                SetandSelectText(pgti, pgti->hwndUrl,  pgti->szStartPageURL);
                PropSheet_Changed(GetParent(pgti->hDlg),pgti->hDlg);
                pgti->fChanged = TRUE;
            }
            break;

        case IDC_USEBLANK:
            if (nCmd == BN_CLICKED)
            {
                StrCpyN(pgti->szStartPageURL, TEXT("about:blank"), ARRAYSIZE(pgti->szStartPageURL));
                SetandSelectText(pgti, pgti->hwndUrl,  pgti->szStartPageURL);
                PropSheet_Changed(GetParent(pgti->hDlg),pgti->hDlg);
                pgti->fChanged = TRUE;
            }
            break;

        case IDC_HISTORY_SPIN:
        case IDC_HISTORY_DAYS:
            if (pgti && (nCmd == EN_CHANGE))
            {
                PropSheet_Changed(GetParent(pgti->hDlg),pgti->hDlg);
                pgti->fChanged = TRUE;
            }
            break;

        case IDC_HISTORY_VIEW:
        {
            TCHAR szPath[MAX_PATH];

            if (!GetHistoryFolderPath(szPath))
            {
                GetWindowsDirectory(szPath, ARRAYSIZE(szPath));
                PathAppend(szPath, TEXT("history"));
            }

            SHELLEXECUTEINFO shei= { 0 };

            shei.cbSize     = sizeof(shei);
            shei.lpFile     = szPath;
            shei.lpClass    = TEXT("Folder");
            shei.fMask      = SEE_MASK_CLASSNAME;
            shei.nShow      = SW_SHOWNORMAL;
            ShellExecuteEx(&shei);

            break;
        }

        case IDC_HISTORY_CLEAR:
            if (MsgBox(pgti->hDlg, IDS_ClearHistory, MB_ICONQUESTION,
                       MB_YESNO | MB_DEFBUTTON2 )
                == IDYES)
            {

                HCURSOR hOldCursor = NULL;
                HCURSOR hNewCursor = NULL;

                // IEUNIX-Removing redundant use of MAKEINTRESOURCE
#ifndef UNIX
                hNewCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT));
#else
                hNewCursor = LoadCursor(NULL, IDC_WAIT);
#endif

                if (hNewCursor) 
                    hOldCursor = SetCursor(hNewCursor);

                EmptyHistory(pgti);

                if(hOldCursor)
                    SetCursor(hOldCursor);

            }
            break;

        case IDC_CACHE_SETTINGS:
            DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_TEMP_FILES),
                      pgti->hDlg, TemporaryDlgProc);

            break; // IDC_ADVANCED_CACHE_FILES_BUTTON

        case IDC_CACHE_DELETE_COOKIES:
        {
            INT_PTR iRet = DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_CACHE_COOKIES_EMPTY),
                             pgti->hDlg, EmptyCacheCookiesDlgProc);

            if (iRet == 1)
            {
                HCURSOR hOldCursor      = NULL;
                HCURSOR hAdvancedCursor = NULL;
#ifndef UNIX
                hAdvancedCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT));
#else
                //IEUNIX-Removing redundant use of MAKEINTRESOURCE
                hAdvancedCursor = LoadCursor(NULL, IDC_WAIT);
#endif
                if (hAdvancedCursor)
                    hOldCursor = SetCursor(hAdvancedCursor);
                    
                DeleteCacheCookies();

                if (hOldCursor)
                    SetCursor(hOldCursor);
            }
            break;
        }
        case IDC_CACHE_DELETE_FILES:
        {
            INT_PTR iRet = DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_CACHE_EMPTY),
                             pgti->hDlg, EmptyCacheDlgProc);

            if ((iRet == 1) || (iRet == 3))
            {
                HCURSOR hOldCursor      = NULL;
                HCURSOR hAdvancedCursor = NULL;
                INTERNET_CACHE_CONFIG_INFOA icci;
                icci.dwContainer = CONTENT;

                GetUrlCacheConfigInfoA(&icci, NULL, CACHE_CONFIG_DISK_CACHE_PATHS_FC);

#ifndef UNIX
                hAdvancedCursor = LoadCursor(NULL, MAKEINTRESOURCE(IDC_WAIT));
#else
                //IEUNIX-Removing redundant use of MAKEINTRESOURCE
                hAdvancedCursor = LoadCursor(NULL, IDC_WAIT);
#endif

                if (hAdvancedCursor)
                    hOldCursor = SetCursor(hAdvancedCursor);

                switch (iRet)   {
                    case 1:
                        FreeUrlCacheSpaceA(icci.CachePath, 100, STICKY_CACHE_ENTRY);
                        TraceMsg(TF_GENERAL, "Call FreeUrlCacheSpace with 0x%x",STICKY_CACHE_ENTRY);
                        break;
                    case 3:
                        FreeUrlCacheSpaceA(icci.CachePath, 100, 0 /*remove all*/);
                        TraceMsg(TF_GENERAL, "Call FreeUrlCacheSpace with 0");
                        break;
                    default:
                        break;
                }

                // Remove expired controls from Downloaded Program Files ( OCCache )
                // We'll do this silently, which leaves uncertain stuff behing, cuz
                // this is preferrable to raising a variable number of confirmation dialogs.
                RemoveExpiredControls( REC_SILENT, 0);
                TraceMsg(TF_GENERAL, "Call RemoveExpiredControls (silent)");

                if (hOldCursor)
                    SetCursor(hOldCursor);

            } 
            break;
        }

        case IDC_LANGUAGES:
            if (nCmd == BN_CLICKED)
            {
                KickLanguageDialog(pgti->hDlg);
            }
            break;

        case IDC_FONTS:
            if (nCmd == BN_CLICKED)
                OpenFontsDialogEx( pgti->hDlg, NULL );
            break;

        case IDC_COLORS:
            if (nCmd == BN_CLICKED)
                DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_COLORS), pgti->hDlg, ColorsDlgProc);
            break;

        case IDC_ACCESSIBILITY:
            if (nCmd == BN_CLICKED)
                DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_ACCESSIBILITY), pgti->hDlg, AccessibilityDlgProc);
            break;            
        
    }
    return TRUE;
}


void General_Apply(HWND hDlg)
{
    LPGENERALTABINFO pgti = (LPGENERALTABINFO) GetWindowLongPtr(hDlg, DWLP_USER);

    if (pgti->fChanged)
    {
        INT_PTR iDays = SendDlgItemMessage(pgti->hDlg, IDC_HISTORY_SPIN, UDM_GETPOS, 0, 0 );
        TCHAR szStartPageURL[MAX_URL_STRING];
        
        SendMessage(pgti->hwndUrl, WM_GETTEXT, (WPARAM)ARRAYSIZE(szStartPageURL), (LPARAM)(szStartPageURL));
        
        if (szStartPageURL[0])
        {
            StrCpyN(pgti->szStartPageURL, szStartPageURL, ARRAYSIZE(pgti->szStartPageURL));
            PathRemoveBlanks(pgti->szStartPageURL);
            _SetStdLocation(pgti->szStartPageURL, IDS_STARTPAGE);
        }
        else
        {
            SendMessage(pgti->hwndUrl, WM_SETTEXT, (WPARAM)ARRAYSIZE(pgti->szStartPageURL), (LPARAM)(pgti->szStartPageURL));
        }

        // make sure that the edit box is not beyond the maximum allowed value
        if (iDays>=0xFFFF)
            iDays = MAX_HISTORY_DAYS;
        SetDaysToKeep((DWORD)iDays);

        UpdateAllWindows();
        // reset this flag, now that we've applied the changes
        pgti->fChanged = FALSE;
    }
}

void ReloadHomePageIfNeeded(LPGENERALTABINFO pgti)
{
    ASSERT(pgti);
    if (!pgti)
        return;

    if (g_fReloadHomePage)
    {
        //
        // If needed, reload the homepage url from the registry
        //
        _GetStdLocation(pgti->szStartPageURL, ARRAYSIZE(pgti->szStartPageURL), IDS_STARTPAGE);
        SetandSelectText(pgti, pgti->hwndUrl, (LPTSTR)pgti->szStartPageURL);

        g_fReloadHomePage = FALSE;
    }
}

INT_PTR CALLBACK General_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    // get our tab info structure
    LPGENERALTABINFO pgti;

    if (uMsg == WM_INITDIALOG)
        return General_InitDialog(hDlg);

    else
        pgti = (LPGENERALTABINFO) GetWindowLongPtr(hDlg, DWLP_USER);

    if (!pgti)
        return FALSE;
    
    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR *) lParam;

            switch (lpnm->code)
            {
                case PSN_SETACTIVE:
                    ReloadHomePageIfNeeded(pgti);
                    return TRUE;

                case PSN_KILLACTIVE:
#if defined(ux10) && defined(UNIX)
//Work around for mmap limitation in hp-ux10
                    INT_PTR iDays = SendDlgItemMessage(pgti->hDlg, IDC_HISTORY_SPIN, UDM_GETPOS, 0, 0 );
                    if (iDays > MAX_HISTORY_DAYS)
                    {
                      MessageBox(pgti->hDlg, TEXT("Days to keep pages in history cannot be greater 30."), NULL, MB_OK);
                      Edit_SetText(GetDlgItem(hDlg,IDC_HISTORY_DAYS), TEXT("30"));
                      SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);
                      return TRUE;
                    }
                    else
                    {
                      SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                      return TRUE;
                    }
#endif
                case PSN_QUERYCANCEL:
                case PSN_RESET:
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    return TRUE;

                case PSN_APPLY:
                    ReloadHomePageIfNeeded(pgti);
                    General_Apply(hDlg);
                    break;
            }
            break;                  
        }

        case WM_COMMAND:
            General_OnCommand(pgti, LOWORD(wParam), HIWORD(wParam));
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:    // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
            // destroying this deliberately flushes its update (see WM_DESTROY in the UpdateWndProc);
            SHRemoveDefaultDialogFont(hDlg);

#ifndef UNIX
            // Should only be destroyed in process detach
            if (g_hwndUpdate)
                DestroyWindow(g_hwndUpdate);
#endif

            SHCoUninitialize(pgti->hrOle);

            if (pgti)
                LocalFree(pgti);

            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);  // make sure we don't re-enter
            break;

    }
    return FALSE;
}


////////////////////////////////////////////////////////
//
// helper functions
//
////////////////////////////////////////////////////////

VOID SetDaysToKeep(DWORD dwDays)
{
    HKEY hk;
    DWORD dwDisp;

    DWORD Error = RegCreateKeyEx(
                                 HKEY_CURRENT_USER,
                                 REGSTR_PATH_URLHISTORY,
                                 0, NULL, 0,
                                 KEY_WRITE,
                                 NULL,
                                 &hk,
                                 &dwDisp);

    if(ERROR_SUCCESS != Error)
    {
        ASSERT(FALSE);
        return;
    }

    Error = RegSetValueEx(
                          hk,
                          REGSTR_VAL_DAYSTOKEEP,
                          0,
                          REG_DWORD,
                          (LPBYTE) &dwDays,
                          sizeof(dwDays));

    ASSERT(ERROR_SUCCESS == Error);

    RegCloseKey(hk);

    return;
}

static DWORD GetDaysToKeep(VOID)
{
    HKEY hk;
    DWORD cbDays = sizeof(DWORD);
    DWORD dwDays  = DEFAULT_DAYS_TO_KEEP;


    DWORD Error = RegOpenKeyEx(
                               HKEY_CURRENT_USER,
                               REGSTR_PATH_URLHISTORY,
                               0,
                               KEY_READ,
                               &hk);


    if(Error)
    {
        Error = RegOpenKeyEx(
                             HKEY_LOCAL_MACHINE,
                             REGSTR_PATH_URLHISTORY,
                             0,
                             KEY_READ,
                             &hk);
    }


    if(!Error)
    {

        Error = RegQueryValueEx(
                                hk,
                                REGSTR_VAL_DAYSTOKEEP,
                                0,
                                NULL,
                                (LPBYTE) &dwDays,
                                &cbDays);


        RegCloseKey(hk);
    }

    return dwDays;
}

typedef HRESULT (* PCOINIT) (LPVOID);
typedef VOID (* PCOUNINIT) (VOID);
typedef VOID (* PCOMEMFREE) (LPVOID);
typedef HRESULT (* PCOCREINST) (REFCLSID, LPUNKNOWN, DWORD,     REFIID, LPVOID * );

HMODULE hOLE32 = NULL;
PCOINIT pCoInitialize = NULL;
PCOUNINIT pCoUninitialize = NULL;
PCOMEMFREE pCoTaskMemFree = NULL;
PCOCREINST pCoCreateInstance = NULL;

BOOL _StartOLE32()
{
    if (!hOLE32)
        hOLE32 = LoadLibrary(TEXT("OLE32.DLL"));

    if(!hOLE32)
        return FALSE;

    pCoInitialize = (PCOINIT) GetProcAddress(hOLE32, "CoInitialize");
    pCoUninitialize = (PCOUNINIT) GetProcAddress(hOLE32, "CoUninitialize");
    pCoTaskMemFree = (PCOMEMFREE) GetProcAddress(hOLE32, "CoTaskMemFree");
    pCoCreateInstance = (PCOCREINST) GetProcAddress(hOLE32, "CoCreateInstance");


    if(!pCoInitialize || !pCoUninitialize || !pCoTaskMemFree || !pCoCreateInstance)
        return FALSE;

    return TRUE;
}


void EmptyHistory(LPGENERALTABINFO pgti)
{
    HRESULT hr = S_OK;
    IUrlHistoryStg2 *piuhs = NULL;

#ifdef UNIX
    LONG  lResult;
    HKEY  hkSubKey;
    DWORD dwIndex;
    TCHAR szSubKeyName[MAX_PATH + 1];
    DWORD cchSubKeyName = ARRAYSIZE(szSubKeyName);
    TCHAR szClass[MAX_PATH];
    DWORD cbClass = ARRAYSIZE(szClass);

    /* v-sriran: 12/18/97
     * In shdocvw/aclmru.cpp, we keep m_hKey as a handle to the key TypedURLs.
     * After deleting history, if somebody types something in the address bar,
     * we create the key again. So, here we are just deleting the contents of
     * the key TypedURLs and not the key itself.
     */
    /* Open the subkey so we can enumerate any children */
    lResult = RegOpenKeyEx(HKEY_CURRENT_USER,
                           TEXT("Software\\Microsoft\\Internet Explorer\\TypedURLs"),
                           0,
                           KEY_ALL_ACCESS,
                           &hkSubKey);
    if (ERROR_SUCCESS == lResult)
    {
       /* I can't just call RegEnumKey with an ever-increasing index, because */
       /* I'm deleting the subkeys as I go, which alters the indices of the   */
       /* remaining subkeys in an implementation-dependent way.  In order to  */
       /* be safe, I have to count backwards while deleting the subkeys.      */

       /* Find out how many subkeys there are */
       lResult = RegQueryInfoKey(hkSubKey,
                                 szClass,
                                 &cbClass,
                                 NULL,
                                 &dwIndex, /* The # of subkeys -- all we need */
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL,
                                 NULL);
         
       if (ERROR_SUCCESS == lResult) {
          /* dwIndex is now the count of subkeys, but it needs to be  */
          /* zero-based for RegEnumKey, so I'll pre-decrement, rather */
          /* than post-decrement. */
          while (ERROR_SUCCESS == RegEnumKey(hkSubKey, --dwIndex, szSubKeyName, cchSubKeyName))
          {
                RegDeleteKey(hkSubKey, szSubKeyName);
          }
       }
  
       RegCloseKey(hkSubKey);
    }
#else
    // Warning : if you ever have subkeys - this will fail on NT
    RegDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Internet Explorer\\TypedURLs"));
#endif

    // Warning : if you ever have subkeys - this will fail on NT
    RegDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU"));

    // this broadcast will nuke the address bars
    SendBroadcastMessage(WM_SETTINGCHANGE, 0, (LPARAM)TEXT("Software\\Microsoft\\Internet Explorer\\TypedURLs"));
    SendBroadcastMessage(WM_SETTINGCHANGE, 0, (LPARAM)TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\RunMRU"));

    //
    // As requested (bug 60089) we remove these reg values when history is
    // cleared.  This will reset the encoding menu UI to the defaults.
    //
    HKEY hkeyInternational = NULL;

    if (ERROR_SUCCESS == 
            RegOpenKeyEx(
                HKEY_CURRENT_USER,
                REGSTR_PATH_INTERNATIONAL,
                0,
                KEY_WRITE,
                &hkeyInternational))
    {

        ASSERT(hkeyInternational);

        RegDeleteValue(hkeyInternational, TEXT("CpCache"));
        RegDeleteValue(hkeyInternational, TEXT("CNum_CpCache"));
        
        RegCloseKey(hkeyInternational);

    }

    //  we will enumerate and kill each entry.  <gryn>
    //  this way we only kill peruser
    if (FAILED(pgti->hrOle))
        return;

    hr = SHCoCreateInstance(NULL, &CLSID_CUrlHistory, NULL, IID_IUrlHistoryStg2, (LPVOID *)&piuhs);
    if (SUCCEEDED(hr))
        piuhs->ClearHistory();

    else
        AssertMsg(FALSE, TEXT("Couldn't create CLSID_CUrlHistory object!"));

    SAFERELEASE(piuhs);
}

#define HISTORY 2

BOOL GetHistoryFolderPath(LPTSTR pszPath)
{
    INTERNET_CACHE_CONFIG_INFOA cci;
    cci.dwContainer = HISTORY;

    if (GetUrlCacheConfigInfoA(&cci, NULL, CACHE_CONFIG_DISK_CACHE_PATHS_FC))
    {
#ifdef UNICODE
        SHAnsiToUnicode(cci.CachePath, pszPath, MAX_PATH);
#else
        StrCpyN(pszPath, cci.CachePath, MAX_PATH);
#endif
        return TRUE;
    }
    return FALSE;
}

void SetandSelectText(LPGENERALTABINFO pgti, HWND hwnd, LPTSTR psz)
{
    pgti->fInternalChange = TRUE;
    SendMessage(hwnd, WM_SETTEXT, 0, (LPARAM)psz);
    Edit_SetSel(hwnd, 0, 0);    // makesure everything is scrolled over first
    Edit_SetSel(hwnd, 0, -1);    // select everything
    pgti->fInternalChange = FALSE;
}

void GetDefaultStartPage(LPGENERALTABINFO pgti)
{
#ifdef UNICODE
    CHAR szPath[MAX_PATH];
    CHAR szValue[MAX_PATH];
    CHAR szURL[INTERNET_MAX_URL_LENGTH];

    SHUnicodeToAnsi(REGSTR_PATH_MAIN,szPath,ARRAYSIZE(szPath));
    SHUnicodeToAnsi(szDefURLValueNames,szValue,ARRAYSIZE(szValue));
    URLSubRegQueryA(szPath,
                    szValue,
                    TRUE,
                    szURL,
                    ARRAYSIZE(pgti->szStartPageURL),
                    URLSUB_ALL);
    SHAnsiToUnicode(szURL,pgti->szStartPageURL,ARRAYSIZE(pgti->szStartPageURL)); 
#else
    URLSubRegQueryA(REGSTR_PATH_MAIN,
                    szDefURLValueNames,
                    TRUE,
                    pgti->szStartPageURL,
                    ARRAYSIZE(pgti->szStartPageURL),
                    URLSUB_ALL);
#endif
}

HRESULT _GetStdLocation(LPTSTR pszPath, DWORD cbPathSize, UINT id)
{
    HRESULT hres = E_FAIL;
    LPCTSTR pszName;

    switch(id) {
        case IDS_STARTPAGE:
            pszName = REGSTR_VAL_STARTPAGE;
            break;

        case IDS_SEARCHPAGE:
            pszName = REGSTR_VAL_SEARCHPAGE;
            break;
#if 0
        case IDM_GOLOCALPAGE:
            pszName = REGSTR_VAL_LOCALPAGE;
            break;
#endif
        default:
            return E_INVALIDARG;
    }

#ifdef UNICODE
    CHAR szPath[MAX_PATH];
    CHAR szValue[MAX_PATH];
    CHAR szURL[INTERNET_MAX_URL_LENGTH];

    SHUnicodeToAnsi(REGSTR_PATH_MAIN,szPath,ARRAYSIZE(szPath));
    SHUnicodeToAnsi(pszName,szValue,ARRAYSIZE(szValue));
    if (SUCCEEDED(hres = URLSubRegQueryA(szPath, szValue, TRUE, 
                                         szURL, ARRAYSIZE(szURL), URLSUB_ALL)))
#else
    TCHAR szPath[MAX_URL_STRING];
    if (SUCCEEDED(hres = URLSubRegQueryA(REGSTR_PATH_MAIN, pszName, TRUE, 
                                         szPath, ARRAYSIZE(szPath), URLSUB_ALL)))
#endif
    {
#ifdef UNICODE
        SHAnsiToUnicode(szURL,pszPath,cbPathSize); 
#else
        StrCpyN(pszPath, szPath, cbPathSize);
#endif
    }
    return hres;
}

HRESULT _SetStdLocation(LPTSTR szPath, UINT id)
{
    HRESULT hres = E_FAIL;
    HKEY hkey;
    TCHAR szPage[MAX_URL_STRING];
    TCHAR szNewPage[MAX_URL_STRING];

    DWORD cchNewPage = ARRAYSIZE(szNewPage);
    BOOL bSearch = FALSE;

    // FEATURE: Share this code!!!
    // This is Internet Explorer Specific

    _GetStdLocation(szPage, ARRAYSIZE(szPage), IDS_STARTPAGE);

    if ( ParseURLFromOutsideSource(szPath, szNewPage, &cchNewPage, &bSearch) &&
            (StrCmp(szPage, szNewPage) != 0) )
    {
        if (RegOpenKeyEx(HKEY_CURRENT_USER,
                         REGSTR_PATH_MAIN,
                         0,
                         KEY_WRITE,
                         &hkey)==ERROR_SUCCESS)
        {
            DWORD cbSize = (lstrlen(szNewPage)+1)*sizeof(TCHAR);
            if (RegSetValueEx(hkey,
                              REGSTR_VAL_STARTPAGE,
                              0,
                              REG_SZ,
                              (LPBYTE)szNewPage, cbSize)==ERROR_SUCCESS)
            {
                hres = S_OK;
            }
            RegCloseKey(hkey);
        }
    }
    return hres;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\inetcplp.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994-1995               **
//*********************************************************************
//
//      INETCPL.H - central header file for Internet control panel
//
//      HISTORY:
//
//      4/3/95      jeremys         Created.
//      6/25/96     t-ashlem        condensed most header files into here
//                                    and other cleanup
//

#ifndef _INETCPL_H_
#define _INETCPL_H_

// Extra error checking (catches false errors, but useful to run every so often)
#if 1
#pragma warning(3:4701)   // local may be used w/o init
#pragma warning(3:4702)   // Unreachable code
#pragma warning(3:4705)   // Statement has no effect
#pragma warning(3:4709)   // command operator w/o index expression
#endif

// IEUNIX - removing warning for redefinition of STRICT
#ifdef STRICT
#undef STRICT
#endif

#define STRICT                      // Use strict handle types
#define _SHELL32_

#define _CRYPT32_    // get DECLSPEC_IMPORT stuff right for Cert API


#include <windows.h>
#include <windowsx.h>

#ifdef WINNT
#include <shellapi.h>
#endif // WINNT


#include <shlobj.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <prsht.h>
#include <cpl.h>
#include <regstr.h>
#include <ccstock.h>
#include <validate.h>
#include <debug.h>
#include <mshtml.h>
#include <wincrypt.h>
#include <shfusion.h>
    //
    // All HKEYs are defined in this library: INETREG.LIB
    // please change/add any HKEYs to this library. Thanks!
    //
#include <inetreg.h>

    //
    // Delay load DLLs' globals (see DLYLDDLL.C for details)
    //
#include "dlylddll.h"

#include <ratings.h>

#include <commdlg.h>
#include <olectl.h>

#define _WINX32_  // get DECLSPEC_IMPORT stuff right for WININET API
#include <urlmon.h>
#include <wininet.h>

#define _URLCACHEAPI_  // get DECLSPEC_IMPORT stuff right for wininet urlcache
#ifdef WINNT
#include <winineti.h>
#endif // WINNT

#define MAX_URL_STRING    INTERNET_MAX_URL_LENGTH
#include <shlwapi.h>

#include "ieguidp.h"

#include "oleacc.h"
// Hack. winuserp.h and winable.h both define the flag WINEVENT_VALID. Since
// no one in inetcpl uses this value we undef it to make the compile work.
#undef WINEVENT_VALID
#include "winable.h"

#ifdef UNICODE
#define POST_IE5_BETA
#include <w95wraps.h>
#endif


#include <ras.h>
#include <raserror.h>

//
// When a user clicks "reset web defaults" (on the programs tab), we may need
// to update the url shown in the general tab.  The general tab will check this
// flag each time it's made active, and also when we hit ok or apply.
//
extern BOOL g_fReloadHomePage;

///////////////////////////////////////////////////////////////////////
//
// Structure Defintions and other typedefs
//
///////////////////////////////////////////////////////////////////////

typedef struct _RESTRICT_FLAGS
{
    BOOL fGeneralTab;               // Enable/disable "General" tab
    BOOL fSecurityTab;              // Enable/disable "Security" tab
    BOOL fContentTab;               // Enable/disable "Content" tab
    BOOL fConnectionsTab;           // Enable/disable "Programs" tab
    BOOL fProgramsTab;              // Enable/disable "Connections" tab
    BOOL fAdvancedTab;              // Enable/disable "Advanced" tab
    BOOL fPrivacyTab;               // Enable/disable "Privacy" tab
    BOOL fColors;                   // Colors section of Colors dialog
    BOOL fLinks;                    // Links section of Links dialog
    BOOL fFonts;                    // Fonts dialog
    BOOL fInternational;            // Languages dialog
    BOOL fDialing;                  // Connection section of Connection tab (incl Settings subdialog)
    BOOL fProxy;                    // Proxy section of Connection tab (incl Advanced subdialog)
    BOOL fPlaces;                   // Home page section of General tab
    BOOL fHistory;                  // History section of General tab
    BOOL fMailNews;                 // Messaging section of the Programs tab
    BOOL fRatings;                  // Ratings buttons on Content tab
    BOOL fCertif;                   // Certificate section of Content tab
    BOOL fCertifPers;               // Personal Cert button
    BOOL fCertifSite;               // Site Cert button
    BOOL fCertifPub;                // Publishers button
    BOOL fCache;                    // Temporary Internet Files section of General tab
    BOOL fAutoConfig;               // Autoconig section of Connection tab
    BOOL fAccessibility;            // Accessibility dialog
    BOOL fSecChangeSettings;        // can't change level
    BOOL fSecAddSites;              // can't add/remove sites
    BOOL fProfiles;                 // Profile Asst section of Content tab
    BOOL fFormSuggest;              // AutoSuggest for forms on Content tab
    BOOL fFormPasswords;            // AutoSuggest for form passwords on Content tab
#ifdef WALLET
    BOOL fWallet;                   // MS Wallet section of Content tab
#endif
    BOOL fConnectionWizard;         // Connection Wizard section of Connection tab
    BOOL fCalContact;               // Cal/Contact section of Programs tab
    BOOL fAdvanced;                 // Advanced page
    BOOL fCacheReadOnly;            // Disables the delete and Settings buttons on the general panel
    BOOL fResetWebSettings;         // Disables the "reset web settings" feature
    BOOL fDefault;                  // IE should check if it's the default browser
    BOOL fPrivacySettings;          // Disables privacy settings

#if 0
    BOOL fMultimedia;               // OBSOLETE: do not use
    BOOL fToolbar;                  // OBSOLETE: do not use
    BOOL fFileTypes;                // OBSOLETE: do not use
    BOOL fActiveX;                  // OBSOLETE: do not use
    BOOL fActiveDownload;           // OBSOLETE: do not use
    BOOL fActiveControls;           // OBSOLETE: do not use
    BOOL fActiveScript;             // OBSOLETE: do not use
    BOOL fActiveJava;               // OBSOLETE: do not use
    BOOL fActiveSafety;             // OBSOLETE: do not use
    BOOL fWarnings;                 // OBSOLETE: do not use
    BOOL fOther;                    // OBSOLETE: do not use
    BOOL fCrypto;                   // OBSOLETE: do not use
    BOOL fPlacesDefault;            // OBSOLETE: do not use
#endif

} RESTRICT_FLAGS, *LPRESTRICT_FLAGS;

typedef struct tagPROXYINFO
{
    BOOL    fEnable;
    BOOL    fEditCurrentProxy;
    BOOL    fOverrideLocal;
    BOOL    fCustomHandler;
    TCHAR   szProxy[MAX_URL_STRING];
    TCHAR   szOverride[MAX_URL_STRING];
} PROXYINFO, *LPPROXYINFO;


// function pointer typedefs
typedef DWORD   (WINAPI * RASENUMENTRIESA) (LPSTR, LPSTR, LPRASENTRYNAMEA, LPDWORD, LPDWORD);
typedef DWORD   (WINAPI * RASENUMENTRIESW) (LPSTR, LPSTR, LPRASENTRYNAMEW, LPDWORD, LPDWORD);
typedef DWORD   (WINAPI * RASCREATEPHONEBOOKENTRYA) (HWND,LPSTR);
typedef DWORD   (WINAPI * RASEDITPHONEBOOKENTRYA) (HWND,LPSTR,LPSTR);
typedef DWORD   (WINAPI * RASEDITPHONEBOOKENTRYW) (HWND,LPWSTR,LPWSTR);
typedef DWORD   (WINAPI * RASGETENTRYDIALPARAMSA) (LPSTR, LPRASDIALPARAMSA, LPBOOL);
typedef DWORD   (WINAPI * RASGETENTRYDIALPARAMSW) (LPWSTR, LPRASDIALPARAMSW, LPBOOL);
typedef DWORD   (WINAPI * RASSETENTRYDIALPARAMSA) (LPSTR, LPRASDIALPARAMSA, BOOL);
typedef DWORD   (WINAPI * RASSETENTRYDIALPARAMSW) (LPWSTR, LPRASDIALPARAMSW, BOOL);
typedef DWORD   (WINAPI * RASDELETEENTRYA) (LPSTR, LPSTR);
typedef DWORD   (WINAPI * RASDELETEENTRYW) (LPWSTR, LPWSTR);
typedef DWORD   (WINAPI * RASGETENTRYPROPERTIESW) (LPCWSTR, LPCWSTR, LPRASENTRYW, LPDWORD, LPBYTE, LPDWORD);
typedef DWORD   (WINAPI * RNAACTIVATEENGINE) (void);
typedef DWORD   (WINAPI * RNADEACTIVATEENGINE) (void);
typedef DWORD   (WINAPI * RNADELETEENTRY) (LPSTR);

///////////////////////////////////////////////////////////////////////
//
// #defines
//
///////////////////////////////////////////////////////////////////////

#define IDC_NOTUSED             ((unsigned) IDC_UNUSED)
#define INM_UPDATE              (WM_USER + 100)

#define MAX_RES_LEN             255
#define SMALL_BUF_LEN           48
#define MAX_PATH_URL            INETERNET_MAX_URL_LENGTH

// NOTE: If you change these max values to something other than two digits, then you'll need to change
// the call in connectn.cpp:DialupDlgInit which sets the limittext to 2 chars.
#define DEF_AUTODISCONNECT_TIME 20      // default disconnect timeout is 20 mins
#define MIN_AUTODISCONNECT_TIME 3       // minimum disconnect timeout is 3 mins
#define MAX_AUTODISCONNECT_TIME 59      // maximum disconnect timeout is 59 mins

// NOTE: If you change these max values to something other than two digits, then you'll need to change
// the call in connectn.cpp:DialupDlgInit which sets the limittext to 2 chars.
#define DEF_REDIAL_TRIES        10
#define MAX_REDIAL_TRIES        99
#define MIN_REDIAL_TRIES        1

#define CO_INTERNET             1
#define CO_INTRANET             2

// NOTE: If you change these max values to something other than two digits, then you'll need to change
// the call in connectn.cpp:DialupDlgInit which sets the limittext to 2 chars.
#define DEF_REDIAL_WAIT         5
#define MAX_REDIAL_WAIT         99
#define MIN_REDIAL_WAIT         5

#define MESSAGE_SIZE    255
#define BITMAP_WIDTH    16
#define BITMAP_HEIGHT   16
#define NUM_BITMAPS     5
#define MAX_KEY_NAME    64
#define COLOR_BG        0
//
#define IDCHECKED       0
#define IDUNCHECKED     1
#define IDRADIOON       2
#define IDRADIOOFF      3
#define IDUNKNOWN       4
//
#define SZDEFAULTBITMAP TEXT("DefaultBitmap")
#define SZHT_RADIO      TEXT("radio")
#define SZHT_CHECKBOX   TEXT("checkbox")
//
#define RET_CHECKBOX    0
#define RET_RADIO       1
//
#define TREE_NEITHER    1
#define TREE_CHECKBOX   2
#define TREE_RADIO      4
//
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
//
#define RCS_GETSTATE    1
#define RCS_SETSTATE    2

// Used with the various registry functions to detect when a value isn't
// present
#define VALUE_NOT_PRESENT   -255

#define DEFAULT_CPL_PAGE    -1

#define REGSTR_PATH_SECURITY_LOCKOUT  TEXT("Software\\Policies\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
#define REGSTR_VAL_OPTIONS_EDIT       TEXT("Security_options_edit")
#define REGSTR_VAL_ZONES_MAP_EDIT     TEXT("Security_zones_map_edit")
#define REGSTR_VAL_HKLM_ONLY          TEXT("Security_HKLM_only")


///////////////////////////////////////////////////////////////////////
//
// Macros
//
///////////////////////////////////////////////////////////////////////

#define ENABLEAPPLY(hDlg) SendMessage( GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L )
#define SetPropSheetResult( hwnd, result ) SetWindowLongPtr(hwnd, DWLP_MSGRESULT, result)

#undef DATASEG_READONLY
#define DATASEG_READONLY        ".rdata"
#include "resource.h"
#include "clsutil.h"

///////////////////////////////////////////////////////////////////////
//
// Read-Only Global Variables
//
///////////////////////////////////////////////////////////////////////

extern HINSTANCE      ghInstance;       // global module instance handle
extern const DWORD    mapIDCsToIDHs[];  // Help IDC to IDH map
extern RESTRICT_FLAGS g_restrict;       // var to restrict access to pages


// functions in UTIL.C
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons);
int MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons);
int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons,...);
LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf);
BOOL EnableDlgItem(HWND hDlg,UINT uID,BOOL fEnable);
VOID _cdecl DisplayErrorMessage(HWND hWnd,UINT uStrID,UINT uError,
                                UINT uErrorClass,UINT uIcon,...);
BOOL WarnFieldIsEmpty(HWND hDlg,UINT uCtrlID,UINT uStrID);
VOID DisplayFieldErrorMsg(HWND hDlg,UINT uCtrlID,UINT uStrID);
VOID GetErrorDescription(CHAR * pszErrorDesc,UINT cbErrorDesc,
                         UINT uError,UINT uErrorClass);
BOOL IsNTSPx(BOOL fEqualOrGreater, UINT uMajorVer, UINT uSPVer);

// functions in RNACALL.C
BOOL InitRNA(HWND hWnd);
VOID DeInitRNA();

// structure for getting proc addresses of api functions
typedef struct APIFCN {
    PVOID * ppFcnPtr;
    LPCSTR pszName;
} APIFCN;


#undef  DATASEG_PERINSTANCE
#define DATASEG_PERINSTANCE     ".instance"
#undef  DATASEG_SHARED
#define DATASEG_SHARED          ".data"
#define DATASEG_DEFAULT         DATASEG_SHARED


///////////////////////////////////////////////////////////////////////
//
// Global Variables
//
///////////////////////////////////////////////////////////////////////

extern TCHAR g_szCurrentURL[INTERNET_MAX_URL_LENGTH];
extern HWND g_hwndUpdate;
extern HWND g_hwndPropSheet;
extern BOOL g_fChangedMime;

///////////////////////////////////////////////////////////////////////
//
// Dialog Procs
//
///////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK AdvancedDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                              LPARAM lParam);

INT_PTR CALLBACK TemporaryDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                               LPARAM lParam);

INT_PTR CALLBACK ConnectionDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                                LPARAM lParam);

INT_PTR CALLBACK General_DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                              LPARAM lParam);

#ifdef UNIX
BOOL CALLBACK AssocDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                              LPARAM lParam);
BOOL CALLBACK AliasDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                              LPARAM lParam);
#endif

STDAPI_(INT_PTR) OpenFontsDialog(HWND hDlg, LPCSTR lpszKeyPath);
STDAPI_(INT_PTR) OpenFontsDialogEx(HWND hDlg, LPCTSTR lpszKeyPath);

INT_PTR CALLBACK FontsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR CALLBACK LanguageDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK PlacesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);

INT_PTR CALLBACK ProgramsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                              LPARAM lParam);

INT_PTR CALLBACK ProxyDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                           LPARAM lParam);

INT_PTR CALLBACK SafetyDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);

INT_PTR CALLBACK SecurityDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);

INT_PTR CALLBACK PrintDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK ContentDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

INT_PTR CALLBACK PrivacyDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

extern "C" void CALLBACK OpenLanguageDialog(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow);
void KickLanguageDialog(HWND hDlg);
///////////////////////////////////////////////////////////////////////
//
// Dialog Proc Helpers
//
///////////////////////////////////////////////////////////////////////

// hunts down all windows and notifies them that they should update themselves
void UpdateAllWindows();

// Windows Help helper
void ResWinHelp( HWND hwnd, int ids, int id2, DWORD_PTR dwp);

#ifdef UNIX

void FindEditClient(LPTSTR szProtocol, HWND hwndDlg, int nIDDlgItem, LPTSTR szPath);
BOOL EditScript(HKEY hkeyProtocol);
BOOL FindScript(HWND hwndLable, HKEY hkeyProtocol);
#define DIR_SEPR FILENAME_SEPARATOR

#include <tchar.h>
#include <platform.h>
#include "unixstuff.h"

inline
BOOL
HAS_DRIVE_LETTER(LPCTSTR pszPath)
{
    ASSERT(pszPath!=NULL);
    return (pszPath[0] == '/');
}

#else

#define DIR_SEPR '\\'
inline
BOOL
HAS_DRIVE_LETTER(LPCTSTR pszPath)
{
    ASSERT(pszPath!=NULL);
    ASSERT(pszPath[0]!='\0');
    return (pszPath[1] == ':');
}

#endif

//
// We can be hung if we use sendMessage, and you can not use pointers with asynchronous
// calls such as PostMessage or SendNotifyMessage.  So we resort to using a timeout.
// This function should be used to broadcast notification messages, such as WM_SETTINGCHANGE,
// that pass pointers.
//
inline LRESULT SendBroadcastMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return SHSendMessageBroadcastW(uMsg, wParam, lParam);
}

// struct used in security.cpp as tls in a hack to get around bad dialog creation situation
struct SECURITYINITFLAGS
{
    DWORD    dwZone;
    BOOL     fForceUI;
    BOOL     fDisableAddSites;
    SECURITYINITFLAGS()
    {
        dwZone = 0;
        fForceUI = FALSE;
        fDisableAddSites = FALSE;
    }
};

LANGID INETCPL_GetUILanguage();

#endif // _INETCPL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\inethelp.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp.,                     **
//*********************************************************************

//
// HELP.C - Mappings for IDHs to IDCs
//

#include "inetcplp.h"
#include "iehelpid.h"

#define IDH_IGNORE  (-1)

const DWORD mapIDCsToIDHs[] = {

    IDC_PLACES_CUSTOMIZE_GROUPBOX       , IDH_GROUPBOX,
    IDC_START_ADDRESS                   , IDH_CUST_ADDRESS,
    IDC_USECURRENT                      , IDH_CUST_CURR,
    IDC_USEDEFAULT                      , IDH_CUST_DEF,
    IDC_USEBLANK                        , IDH_CPL_GEN_USEBLANK,
    IDC_CACHE_VIEW_FILES                , IDH_TIF_VIEW,
    IDC_CACHE_DELETE_FILES              , IDH_TEMP_EMPTY,
    IDC_CACHE_DELETE_COOKIES            , IDH_DEL_COOKIE_THIRD_PARTY,
    IDC_CACHE_SETTINGS                  , IDH_TIF_SETTINGS,

    IDC_ADVANCED_CACHE_STATUS           , IDH_IGNORE,
    IDC_ADVANCED_CACHE_LOCATION         , IDH_IGNORE,
    IDC_ADVANCED_CACHE_SIZE_SPIN        , IDH_IGNORE,

    IDC_TEMPORARY_INTERNET_FILES_SETTINGS_GROUPBOX         ,IDH_GROUPBOX,
    IDC_ADVANCED_TEMP_FILES_GROUPBOX                       ,IDH_GROUPBOX,
    IDC_ADVANCED_CACHE_BROWSE                              ,IDH_TIF_VIEW,
    IDC_ADVANCED_CACHE_PERCENT_ACC                         ,IDH_TEMP_AMOUNT,
    IDC_ADVANCED_CACHE_PERCENT                             ,IDH_TEMP_AMOUNT,
    IDC_ADVANCED_CACHE_TEXT_PERCENT                        ,IDH_TEMP_AMOUNT,
    IDC_ADVANCED_CACHE_MB                                  ,IDH_TEMP_AMOUNT,
    IDC_ADVANCED_CACHE_EMPTY                               ,IDH_TEMP_EMPTY,
    IDC_ADVANCED_CACHE_ONCEPERSESS                         ,IDH_TEMP_START,
    IDC_ADVANCED_CACHE_AUTOMATIC                           ,IDH_TEMP_AUTO,
    IDC_ADVANCED_CACHE_NEVER                               ,IDH_TEMP_NEVER,
    IDC_ADVANCED_CACHE_ALWAYS                              ,IDH_TEMP_EVERY,
    IDC_ADVANCED_DOWNLOADED_CONTROLS                       ,IDH_TEMP_INTERNET_VIEW_OBJECTS_BTN,
    IDC_ADVANCED_MOVE_CACHE_LOCATION                       ,IDH_TEMP_MOVE,
    IDC_PLACES_HISTORY_GROUPBOX         , IDH_GROUPBOX,
    IDC_HISTORY_DAYS                    , IDH_HIST_NUM,
    IDC_HISTORY_SPIN                    , IDH_HIST_NUM,
//    IDC_HISTORY_VIEW                    , IDH_HIST_VIEW,
    IDC_HISTORY_CLEAR                   , IDH_HIST_CLEAR,
    //------------------------------------------------------------------------
    // Security tab
    //------------------------------------------------------------------------
    IDC_COMBO_ZONE                      , IDH_CPL_SEC_ZONE_DROPLIST,
    IDC_ZONE_RESET                      , IDH_SECURITY_RESET_ZONE_DEFAULTS,
    IDC_ZONE_GROUPBOX                   , IDH_GROUPBOX,
    IDC_LIST_ZONE                       , IDH_SEC_ZONE_LIST,
    IDC_BUTTON_ADD_SITES                , IDH_CPL_SEC_ADDSITES,
    IDC_SLIDER                          , IDH_SEC_LVL_SLIDER,
    IDC_LEVEL_NAME                      , IDH_SEC_LVL_SLIDER,
    IDC_LEVEL_DESCRIPTION               , IDH_SEC_LVL_SLIDER,
    IDC_RADIO_HIGH                      , IDH_SAFE_EXPERT,
    IDC_RADIO_MEDIUM                    , IDH_SAFE_NORM,
    IDC_RADIO_LOW                       , IDH_SAFE_NONE,
    IDC_RADIO_CUSTOM                    , IDH_CPL_SEC_CUSTOM_LEVEL,
    IDC_BUTTON_SETTINGS                 , IDH_CPL_SEC_SETTINGS,
    IDC_ZONE_ICON                       , IDH_GROUPBOX,
    IDC_ZONELABEL                       , IDH_GROUPBOX,
    IDC_STATIC_EMPTY                    , IDH_GROUPBOX,
    IDC_ZONE_DESCRIPTION                , IDH_GROUPBOX,
    IDC_LEVEL_GROUPBOX                  , IDH_GROUPBOX,
    IDC_STATIC_SLIDERMOVETEXT           , IDH_IGNORE,

    IDC_LIST_WEBSITES                   , IDH_CPL_WEB_SITES_LIST,
    IDC_BUTTON_REMOVE                   , IDH_CPL_WEB_SITES_REMOVE,
    IDC_CHECK_REQUIRE_SERVER_VERIFICATION, IDH_CPL_REQ_VERIFICATION_CHKBOX,
    IDC_EDIT_ADD_SITE                   , IDH_CPL_WEB_SITES_ADD_THIS_TXT,
    IDC_BUTTON_ADD                      , IDH_CPL_WEB_SITES_ADD_BUTTON,

    IDC_GROUP_CURRENT_SETTINGS          , IDH_GROUPBOX,
    IDC_TREE_SECURITY_SETTINGS          , IDH_CPL_SEC_SETTINGS_CURRENT,

    //------------------------------------------------------------------------
    // Content tab
    //------------------------------------------------------------------------
    IDC_ADVANCED_RATINGS_GROUPBOX       , IDH_GROUPBOX,
    IDC_RATINGS_TURN_ON                 , IDH_RATE_TOGGLE,
    IDC_ADVANCED_RATINGS_BUTTON         , IDH_RATE_PROP,
    IDC_RATINGS_TEXT                    , IDH_GROUPBOX,
    IDC_RATINGS_ICON                    , IDH_GROUPBOX,
    IDC_SECURITY_ACTIVE_CONTENT_GROUPBOX, IDH_GROUPBOX,
    IDC_SECURITY_SITES_BUTTON           , IDH_CERT_SITE,
    IDC_SECURITY_PUBLISHERS_BUTTON      , IDH_CERT_PUB,
    IDC_SECURITY_CLEAR_SSL_CACHE_BUTTON , IDH_ADV_CLEAR_SSL_CACHE,
    IDC_PROGRAMS_WALLET_GROUPBOX        , IDH_GROUPBOX,
    IDC_RESET_SHARING                   , IDH_RESET_SHARING_OPS,    // n/a
    IDC_EDIT_PROFILE                    , IDH_EDIT_PROFILE_BTN,
    IDC_AUTOSUGGEST_SETTINGS            , IDH_OPTS_PROG_AUTOSUGGEST_BUT,
    IDC_AUTOSUGGEST_ENABLEADDR          , IDH_AUTOCOMP,
    IDC_AUTOSUGGEST_ENABLEFORM          , IDH_INTELLIFORM,
    IDC_AUTOSUGGEST_SAVEPASSWORDS       , IDH_INTELLIFORM_PW,
    IDC_AUTOSUGGEST_PROMPTPASSWORDS     , IDH_INTELLIFORM_PW_PROMPT,
    IDC_AUTOSUGGEST_CLEARFORM           , IDH_CLEAR_INTELLIFORM,
    IDC_AUTOSUGGEST_CLEARPASSWORDS      , IDH_CLEAR_INTELLIFORM_PW,
    IDC_AUTOSUGGEST_CLEAR_TEXT          , IDH_IGNORE,
    IDC_AUTOSUGGEST_STATIC_TEXT         , IDH_IGNORE,
    IDC_AUTOSUGGEST_FOR_GROUP           , IDH_GROUPBOX,
    IDC_AUTOSUGGEST_HISTORY_GROUP       , IDH_GROUPBOX,
#ifdef WALLET
    IDC_PROGRAMS_WALLET_SETTINGS        , IDH_OPTS_PROG_WALLET_BUT,
    IDC_PROGRAMS_WALLET_ADDRBUTTON      , IDH_OPTS_PROG_ADDRMGR_BUT,
    IDC_PROGRAMS_WALLET_PAYBUTTON       , IDH_OPTS_PROG_PAYMENTMGR_BUT,
#endif
    IDC_COMBO_RESETLEVEL                , IDH_SECURITY_RESET_LEVEL_DEFAULTS,
    IDC_BUTTON_APPLY                    , IDH_SECURITY_RESET_LEVEL_DEFAULTS,

    IDC_DEFAULT_SETTINGS_GROUPBOX       , IDH_GROUPBOX,
    IDC_GRP_DIALUPSETTINGS              , IDH_GROUPBOX,
    IDC_GRP_LANSETTINGS                 , IDH_GROUPBOX,
    IDC_CONNECTION_WIZARD               , IDH_CPL_CNX_WIZARD,
    IDC_LAN_SETTINGS                    , IDH_PROX_SETTINGS,
    IDC_CON_SHARING                     , IDH_CONNECTION_SHARING,
    IDC_CONN_LIST                       , IDH_CONNECTION_TAB_CONNECTOID_LIST,
    IDC_DIALUP                          , IDH_DIAL_USE,
    IDC_DIALUP_NEVER                    , IDH_NEVERDIAL,
    IDC_DIALUP_ON_NONET                 , IDH_DIALIF_NETCNX_GONE,
    IDC_DIALUP_ADD                      , IDH_DIAL_ADD,
    IDC_DIALUP_REMOVE                   , IDH_CONNECTION_TAB_REMOVE_CONNECTOID,
    IDC_SET_DEFAULT                     , IDH_DIAL_DEFAULT,
    IDC_DIAL_DEF_TXT                    , IDH_CNX_CURRENT_DEFAULT_LBL_N_DISP,
    IDC_DIAL_DEF_ISP                    , IDH_CNX_CURRENT_DEFAULT_LBL_N_DISP,
    IDC_MODEM_SETTINGS                  , IDH_CPL_CNX_SETTINGS,
    IDC_ENABLE_SECURITY                 , IDH_CONNECT_TAB_PERFORM_SECUR_CHECKB4_DIALING,
    IDC_CON_SHARING                     , IDH_CONNECTION_SHARING,

    IDC_PROXY_ICON1                     , IDH_IGNORE,
    IDC_PROXY_ICON2                     , IDH_IGNORE,
    IDC_GRP_SETTINGS2                   , IDH_GROUPBOX,
    IDC_PROXY_EXCEPTIONS_GROUPBOX       , IDH_GROUPBOX,
    IDC_GRP_AUTO                        , IDH_GROUPBOX,
    IDC_AUTODISCOVER                    , IDH_PROX_SERV_AUTO,
    IDC_CONFIGSCRIPT                    , IDH_AUTOCONFIG_BUTTON,
    IDC_CONFIG_ADDR                     , IDH_AUTOCONFIG_TEXT,
    IDC_CONFIGADDR_TX                   , IDH_AUTOCONFIG_TEXT,
    IDC_GRP_PROXY                       , IDH_GROUPBOX,
    IDC_MANUAL                          , IDH_PROX_SERV,
    IDC_ADDRESS_TEXT                    , IDH_CPL_CNX_PROXY_ADDR_PORT,
    IDC_PROXY_ADDR                      , IDH_CPL_CNX_PROXY_ADDR_PORT,
    IDC_PORT_TEXT                       , IDH_CPL_CNX_PROXY_ADDR_PORT,
    IDC_PROXY_PORT                      , IDH_CPL_CNX_PROXY_ADDR_PORT,
    IDC_PROXY_ADVANCED                  , IDH_PROX_SETTINGS_ADV,
    IDC_PROXY_OMIT_LOCAL_ADDRESSES      , IDH_EXCEPT_LOCAL,
    IDC_GRP_DIAL                        , IDH_GROUPBOX,
    IDC_USER                            , IDH_CPL_DUN_USERNAME,
    IDC_TX_USER                         , IDH_CPL_DUN_USERNAME,
    IDC_PASSWORD                        , IDH_CPL_DUN_PASSWORD,
    IDC_TX_PASSWORD                     , IDH_CPL_DUN_PASSWORD,
    IDC_DOMAIN                          , IDH_CPL_DUN_DOMAIN,
    IDC_TX_DOMAIN                       , IDH_CPL_DUN_DOMAIN,
    IDC_RAS_SETTINGS                    , IDH_DIAL_PROP,
    IDC_DIAL_ADVANCED                   , IDH_DIAL_PROP_ADV,
    IDC_DONT_USE_CONNECTION             , IDH_CPL_DUN_SEND_MY_LOGIN,

    IDC_TX_CONNECT                      , IDH_CPL_DUN_ATTEMPT_X_TIMES,
    IDC_TX_TIMES                        , IDH_CPL_DUN_ATTEMPT_X_TIMES,
    IDC_CONNECT                         , IDH_CPL_DUN_ATTEMPT_X_TIMES,
    IDC_CONNECT_SPIN                    , IDH_CPL_DUN_ATTEMPT_X_TIMES,
    IDC_TX_INTERVAL                     , IDH_CPL_DUN_WAIT_X_SECS,
    IDC_INTERVAL                        , IDH_CPL_DUN_WAIT_X_SECS,
    IDC_INTERVAL_SPIN                   , IDH_CPL_DUN_WAIT_X_SECS,
    IDC_TX_SECONDS                      , IDH_CPL_DUN_WAIT_X_SECS,
    IDC_IDLE_TIMEOUT                    , IDH_DIAL_DIS,
    IDC_IDLE_SPIN                       , IDH_DIAL_DIS,
    IDC_ENABLE_AUTODISCONNECT           , IDH_DIAL_DIS,
    IDC_TX_AUTODISCONNECT               , IDH_DIAL_DIS,
    IDC_EXIT_DISCONNECT                 , IDH_DISCONNECT_ON_IEEXIT,

    IDC_TYPE_TEXT                       , IDH_SERV_INFO,
    IDC_ADDR_TEXT                       , IDH_SERV_INFO,
    IDC_PROXY_ENABLE                                       ,IDH_PROX_SERV,
    IDC_PROXY_HTTP_ADDRESS                                 ,IDH_SERV_INFO,
    IDC_EXCEPT_TEXT                                        ,IDH_EXCEPT_PROX,
    IDC_EXCEPT2_TEXT                                       ,IDH_EXCEPT_PROX,
    IDC_PROXY_OVERRIDE                                     ,IDH_EXCEPT_PROX,
    IDC_PROXY_SECURITY_ADDRESS                             ,IDH_SERV_INFO,
    IDC_PROXY_FTP_ADDRESS                                  ,IDH_SERV_INFO,
    IDC_PROXY_GOPHER_ADDRESS                               ,IDH_SERV_INFO,
    IDC_PROXY_HTTP_PORT                                    ,IDH_SERV_INFO,
    IDC_PROXY_SECURITY_PORT                                ,IDH_SERV_INFO,
    IDC_PROXY_FTP_PORT                                     ,IDH_SERV_INFO,
    IDC_PROXY_GOPHER_PORT                                  ,IDH_SERV_INFO,
    IDC_PROXY_SOCKS_ADDRESS                                ,IDH_SERV_INFO,
    IDC_PROXY_SOCKS_PORT                                   ,IDH_SERV_INFO,
    IDC_PROXY_HTTP_CAPTION                                 ,IDH_SERV_INFO,
    IDC_PROXY_SECURITY_CAPTION                             ,IDH_SERV_INFO,
    IDC_PROXY_FTP_CAPTION                                  ,IDH_SERV_INFO,
    IDC_PROXY_GOPHER_CAPTION                               ,IDH_SERV_INFO,
    IDC_PROXY_USE_SAME_SERVER                              ,IDH_SERV_SAME,
    IDC_PROXY_OMIT_LOCAL_ADDRESSES                         ,IDH_EXCEPT_LOCAL,
    IDC_PROXY_SOCKS_CAPTION                                ,IDH_SERV_INFO,

    IDC_PROGRAMS_MAILANDNEWS_GROUPBOX   , IDH_GROUPBOX,
#ifndef UNIX
    IDC_PROGRAMS_MAIL_COMBO             , IDH_MAIL,
    IDC_PROGRAMS_NEWS_COMBO             , IDH_NEWS,
    IDC_PROGRAMS_CALL_COMBO             , IDH_CPL_PROGRAMS_INTERNET_CALL,
    IDC_PROGRAMS_HTMLEDITOR_COMBO       , IDH_HTML_EDITOR,
#else
    IDC_EDIT_PROGRAMS_MAIL              , IDH_MAIL,
    IDC_EDIT_PROGRAMS_NEWS              , IDH_NEWS,
#endif
    IDC_CONTACT_LIST_GROUPBOX           , IDH_GROUPBOX,
    IDC_PROGRAMS_CONTACT_COMBO          , IDH_CPL_PROGRAMS_CONTACTS,
    IDC_PROGRAMS_CALENDAR_COMBO         , IDH_CPL_PROGRAMS_CAL,
    IDC_INTERNET_CALLS_GROUPBOX         , IDH_GROUPBOX,
    IDC_CHECK_ASSOCIATIONS_CHECKBOX     , IDH_IE_DEF,

    IDC_ADVANCED_STATIC                 , IDH_IGNORE,
//    IDC_ADVANCEDTREE                    , IDH_OPTS_PROG_ADV_ADV,
    IDC_COLORS                          , IDH_CPL_ADV_COLORS,
    IDC_FONTS                           , IDH_FONT_INT,
    IDC_LANGUAGES                       , IDH_OPTS_GEN_LANG_BUT,
    IDC_ACCESSIBILITY                   , IDH_CPL_ADV_ACCESSIBILITY,
    IDC_RESTORE_DEFAULT                 , IDH_RESTORE_DEFS,

    IDC_GENERAL_APPEARANCE_GROUPBOX                        ,IDH_GROUPBOX,
    IDC_GENERAL_APPEARANCE_COLOR_TEXT_LABEL                ,IDH_APPEAR_OPTION,
    IDC_GENERAL_APPEARANCE_COLOR_TEXT                      ,IDH_APPEAR_OPTION,
    IDC_GENERAL_APPEARANCE_COLOR_BACKGROUND_LABEL          ,IDH_APPEAR_OPTION,
    IDC_GENERAL_APPEARANCE_COLOR_BACKGROUND                ,IDH_APPEAR_OPTION,
    IDC_GENERAL_APPEARANCE_USE_CUSTOM_COLORS_CHECKBOX      ,IDH_APPEAR_OPTION,

    IDC_GENERAL_LINKS_GROUPBOX                             ,IDH_GROUPBOX,
    IDC_GENERAL_APPEARANCE_COLOR_LINKS                     ,IDH_APPEAR_LINK,
    IDC_GENERAL_APPEARANCE_COLOR_VISITED_LINKS             ,IDH_APPEAR_LINK,
//    IDC_GENERAL_APPEARANCE_UNDERLINE_LINKS_CHECKBOX        ,IDH_APPEAR_UNDERLINE,
    IDC_GENERAL_APPEARANCE_USE_HOVER_COLOR_CHECKBOX        ,IDH_HOVERCOLOR,
    IDC_GENERAL_APPEARANCE_COLOR_HOVER                     ,IDH_HOVERCOLOR,
    IDC_FONTS_SCRIPTS_GROUPBOX          , IDH_GROUPBOX,
    IDC_FONTS_CHAR_SET_COMBO            , IDH_CHAR_SET,
    IDC_FONTS_PROP_FONT_LIST            , IDH_INTL_FONT_PROP,
    IDC_FONTS_FIXED_FONT_LIST           , IDH_INTL_FONT_FIXED,

    IDC_FONTS_SETDEFAULT_BUTTON         , IDH_INTL_DEFAULT_OE,
    IDC_FONTS_CODE_PAGES_LIST           , IDH_CHAR_SET_OE,
    IDC_FONTS_PROP_FONT_COMBO           , IDH_INTL_FONT_PROP_OE,
    IDC_FONTS_FIXED_FONT_COMBO          , IDH_INTL_FONT_FIXED_OE,
    IDC_FONTS_SIZE_FONT_COMBO           , IDH_OPTS_GEN_FONTS_FONTSIZE,
    IDC_FONTS_MIME_FONT_COMBO           , IDH_FONT_MIME_OE,

    IDC_LANG_ACCEPT_LIST                , IDH_LANG_PREFS_LIST,
    IDC_LANG_MOVE_UP_BUTTON             , IDH_LANG_PREFS_UP,
    IDC_LANG_MOVE_DOWN_BUTTON           , IDH_LANG_PREFS_DOWN,
    IDC_LANG_REMOVE_BUTTON              , IDH_LANG_PREFS_REMOVE,
    IDC_LANG_ADD_BUTTON                 , IDH_LANG_PREFS_ADD,
    IDC_LANG_UI_PREF                    , IDH_LANG_UI_PREF,
    IDC_LANG_ADDSPK                     , IDH_LANG_ADDSPK,

    IDC_LANG_AVAILABLE_LIST             , IDH_ADD_LANGUAGE_LANGUAGE_LIST,
    IDC_LANG_USER_DEFINED_EDIT          , IDH_ADD_LANGUAGE_USER_DEFINED,

    IDC_COMBO_UILANG                    , IDH_COMBO_UILANG,

    IDC_GROUP_FORMATTING                , IDH_GROUPBOX,
    IDC_GROUP_STYLESHEET                , IDH_GROUPBOX,
    IDC_CHECK_COLOR                     , IDH_CPL_ACCESS_USE_MY_COLORS,
    IDC_CHECK_FONT_SIZE                 , IDH_CPL_ACCESS_USE_MY_F_SIZE,
    IDC_CHECK_FONT_STYLE                , IDH_CPL_ACCESS_USE_MY_F_STYLE,
    IDC_CHECK_USE_MY_STYLESHEET         , IDH_CPL_ACCESS_USE_MY_STYLESHEETS,
    IDC_STATIC_STYLESHEET               , IDH_IGNORE,
    IDC_EDIT_STYLESHEET                 , IDH_CPL_ACCESS_USE_MY_STYLESHEETS,
    IDC_STYLESHEET_BROWSE               , IDH_RUNBROWSE,

    IDC_VIEWCERT                        ,IDH_VIEW_CERT,
    IDC_DELETECERT                      ,IDH_DEL_CERT,
    IDC_CERTLIST                        ,IDH_LIST_CERT,
    IDC_COMBO_SERVICE                   ,IDH_SITE_CERTS_ISSUER_TYPE,

    IDC_INTRANET_ADVANCED               ,IDH_ADD_SITES_ADVANCED_BTN,
    IDC_CHECK_USEINTRANET               ,IDH_LOCAL_INTRA_INCLUDE_ALL_NOT_LISTED,
    IDC_CHECK_PROXY                     ,IDH_LOCAL_INTRA_INCLUDE_ALL_THAT_BYPASS_PROXY,
    IDC_CHECK_UNC                       ,IDH_LOCAL_INTRA_INCLUDE_ALL_UNCS,

    IDC_JAVACUSTOM                      ,IDH_JAVA_CUST_SETTINGS_BTN,

    IDC_RESETWEBSETTINGS                ,IDH_RESET_WEBSTGS_BUTTON,
    IDC_RESETWEBSETTINGS_TEXT           ,IDH_RESET_WEBSTGS_BUTTON,

//------------------------------------------------------------------------
// Privacy tab
//------------------------------------------------------------------------

    IDC_LEVEL_SLIDER,                   IDH_PRIVACY_SLIDER,
    IDC_PRIVACY_IMPORT,                 IDH_PRIVACY_IMPORT,
    IDC_PRIVACY_DEFAULT,                IDH_PRIVACY_RESET_DEFAULTS,
    IDC_PRIVACY_ADVANCED,               IDH_PRIVACY_ADVANCED,

    IDC_USE_ADVANCED,                   IDH_PRIVADV_OVERRIDE,
    IDC_SESSION_OVERRIDE,               IDH_PRIVACYADV_ALLOW_SESSION,
    IDC_FIRST_ACCEPT,                   IDH_PRIVADV_FIRST_PARTY,
    IDC_FIRST_DENY,                     IDH_PRIVADV_FIRST_PARTY,
    IDC_FIRST_PROMPT,                   IDH_PRIVADV_FIRST_PARTY,
    IDC_THIRD_ACCEPT,                   IDH_PRIVACYADV_THIRD_PARTY,
    IDC_THIRD_DENY,                     IDH_PRIVACYADV_THIRD_PARTY,
    IDC_THIRD_PROMPT,                   IDH_PRIVACYADV_THIRD_PARTY,
    IDC_PRIVACY_EDIT,                   IDH_PRIVACYADV_EDIT,

    IDC_PRIVACYPS_ACCEPTBTN,            IDH_PRIVADV_ALLOW,
    IDC_PRIVACYPS_REJECTBTN,            IDH_PRIVADV_REJECT,
    IDC_PRIVACYPS_REMOVEBTN,            IDH_PRIVADV_REMOVE,
    IDC_PRIVACYPS_SITETOSET,            IDH_PRIVADV_ADDRESS,
    IDC_PRIVACYPS_LISTBOX,              IDH_PRIVADV_WEBSITES,
    IDC_PRIVACYPS_REMOVEALLBTN,         IDH_PRIVADV_REMOVE_ALL,
0,0
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\pch.cpp ===
#include "inetcplp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\process.cpp ===
///////////////////////////////////////////////////////////////////////
//                     Microsoft Windows	                         //
//              Copyright(c) Microsoft Corp., 1998                   //
///////////////////////////////////////////////////////////////////////
//
// processs ID related routines 
//

#include "inetcplp.h"

#include <tchar.h>

#include "psapi.h"
#include "tlhelp32.h"
#include "process.h"

CProcessInfo::CProcessInfo()
{
    _fNT = IsOS(OS_NT4ORGREATER);
    // init w95 func pointers
    _lpfnCreateToolhelp32Snapshot = NULL;
    _lpfnProcess32First = NULL;
    _lpfnProcess32Next  = NULL;
    
    // init NT func pointers
    _hPsapiDLL = NULL;
    _lpfnEnumProcesses = NULL;
    _lpfnGetModuleBaseName = NULL;

    // process info array
    _pProcInfoArray  = NULL;
    _nAlloced        = 0;
    _iProcInfoCount  = 0;
}

CProcessInfo::~CProcessInfo()
{
    if(_pProcInfoArray)
        LocalFree(_pProcInfoArray);

    if(_hPsapiDLL)
	    FreeLibrary (_hPsapiDLL);
}

#define ALLOC_STEP 50
HRESULT CProcessInfo::MakeRoomForInfoArray(int n)
{
    HRESULT hr = S_OK;
    if (n > _nAlloced)
    {
        PROCESSINFO *p;
        int nSaved = _nAlloced;

        while(n > _nAlloced)
            _nAlloced += ALLOC_STEP;

        if (!_pProcInfoArray)
        {
            p = (PROCESSINFO *)LocalAlloc(LPTR, sizeof(PROCESSINFO)*_nAlloced);
        }
        else
        {
            p = (PROCESSINFO *)LocalReAlloc(_pProcInfoArray, 
                                            sizeof(PROCESSINFO)*_nAlloced, 
                                            LMEM_MOVEABLE|LMEM_ZEROINIT);
        }

        if (p)
            _pProcInfoArray = p;
        else
        {
            hr        = E_FAIL;
            _nAlloced = nSaved; 
        }
    }
    return hr;
}

HRESULT CProcessInfo::EnsureProcessInfo()
{
    HRESULT hr = S_OK;
    if (!_pProcInfoArray)
    {
        if (_fNT)
        {
            NTCreateProcessList();
        }
        else
        {
            W95CreateProcessList();
        }
    }
    return hr;
}
HRESULT CProcessInfo::GetExeNameFromPID(DWORD dwPID, LPTSTR szFile, int cchFile)
{
    HRESULT hr;

    hr = EnsureProcessInfo();
    if (hr == S_OK)
    {
        for (int i = 0; i < _iProcInfoCount; i++)
        {
            if (_pProcInfoArray[i].dwPID == dwPID)
            {
                _tcsncpy(szFile, _pProcInfoArray[i].szExeName, cchFile);
                break;
            }
        }
    }
    return hr;
}
HRESULT CProcessInfo::NTCreateProcessList()
// Testing routine to see if we can get Process IDs.
{
	HRESULT hr = E_FAIL;

    hr = NTInitPsapi();
    if (hr == S_OK)
    {

        UINT iIndex;

        DWORD aProcesses[100], cbNeeded;

        if (_lpfnEnumProcesses((DWORD * )aProcesses, sizeof(aProcesses), (DWORD *)&cbNeeded))
        {
            // Calculate how many process IDs were returned
            DWORD cProcesses = cbNeeded / sizeof(DWORD);
            
            hr = MakeRoomForInfoArray(cProcesses);
            if (S_OK == hr)
            {
                // Spit out the information for each ID
                for ( iIndex = 0; iIndex < cProcesses; iIndex++ )
                {
                    hr = NTFillProcessList(aProcesses[iIndex], iIndex);
                }

                if (hr == S_OK)
                    _iProcInfoCount = iIndex;
            }
        }
    }
    return hr;
}

HRESULT CProcessInfo::NTInitPsapi()
{
    HRESULT hr;
    // First, load the NT specific library, PSAPI.DLL.
    if (!_hPsapiDLL)
        _hPsapiDLL = LoadLibrary(TEXT("PSAPI.DLL"));

    if (_hPsapiDLL)
    {
        _lpfnEnumProcesses 
        = (LPFNENUMPROCESSES)GetProcAddress(_hPsapiDLL, "EnumProcesses");


        _lpfnGetModuleBaseName 
        = (LPFNGETMODULEBASENAMEW)GetProcAddress(_hPsapiDLL, "GetModuleBaseNameW");
    }

    Assert(_lpfnEnumProcesses && _lpfnGetModuleBaseName);

    hr = (_lpfnEnumProcesses 
        && _lpfnGetModuleBaseName) ? S_OK : E_FAIL;

    return hr;
}

HRESULT CProcessInfo::NTFillProcessList(DWORD dwProcessID, int iIndex)
{
	HRESULT hr = E_FAIL;
    TCHAR szProcessName[MAX_PATH] = TEXT("unknown");
	int i = -1;

    HANDLE hProcess = OpenProcess(  PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, dwProcessID );
    if ( hProcess )
    {
        DWORD dw = _lpfnGetModuleBaseName( hProcess, NULL, szProcessName, sizeof(szProcessName) );
        if (dw > 0)
                hr = S_OK;
        CloseHandle (hProcess);
    }

    if (hr == S_OK)
    {
        // Add PID and associated .EXE file info to list...
        _pProcInfoArray[iIndex].dwPID = dwProcessID;
        
        _tcsncpy (_pProcInfoArray[iIndex].szExeName, szProcessName, 
                  ARRAYSIZE(_pProcInfoArray[iIndex].szExeName));
    }	
    return hr;
}

HRESULT CProcessInfo::W95CreateProcessList()
{
	HRESULT hr = E_FAIL;

	if (S_OK == W95InitToolhelp32())
	{
		hr = W95FillProcessList();
	}

	return (hr);
}

HRESULT CProcessInfo::W95InitToolhelp32()
// Win95 specific, sets up the things we need to get the process IDs.
{
    HRESULT hr      = E_FAIL;
    HMODULE hKernel = NULL;

    // Obtain a module handle to KERNEL so that we can get the addresses of
    // the 32-bit Toolhelp functions we need.

    hKernel = GetModuleHandle(TEXT("KERNEL32.DLL"));

    if (hKernel)
    {
        _lpfnCreateToolhelp32Snapshot =
          (CREATESNAPSHOT)GetProcAddress(hKernel, "CreateToolhelp32Snapshot");

        _lpfnProcess32First = (PROCESSWALK)GetProcAddress(hKernel, "Process32First");
        _lpfnProcess32Next  = (PROCESSWALK)GetProcAddress(hKernel, "Process32Next");

        // All of our addresses must be non-NULL in order for us to be
        // successful.  If even one of these addresses is NULL, then we
        // must fail because we won't be able to walk one of the lists
        // we need to.
        if (_lpfnProcess32First && _lpfnProcess32Next && _lpfnCreateToolhelp32Snapshot)
            hr = S_OK;
    }

    return (hr);
}
#ifdef UNICODE
#undef PROCESSENTRY32
#endif  // !UNICODE
HRESULT CProcessInfo::W95FillProcessList()
// Fills in the array of process info, and also set the count of the items
{
    HRESULT hr = E_FAIL;
    HANDLE         hProcessSnap = NULL;
    PROCESSENTRY32 pe32         = {0};

    // Take a snapshot of all processes currently in the system.
    hProcessSnap = _lpfnCreateToolhelp32Snapshot(TH32CS_SNAPPROCESS, 0);
    if (hProcessSnap == (HANDLE)-1)
        return hr;

    // Size of the PROCESSENTRY32 structure must be filled out before use.
    pe32.dwSize = sizeof(PROCESSENTRY32);

    // Walk the snapshot of processes and for each process, get information
    // to display.
    if (_lpfnProcess32First(hProcessSnap, &pe32))
    {
        int iIndex = 0;

        do // Add PID and associated .EXE file info to list...
        {
            hr = MakeRoomForInfoArray(iIndex+1);
            if (hr != S_OK)
                break;

            _pProcInfoArray[iIndex].dwPID = pe32.th32ProcessID;
            LPSTR pszFile = PathFindFileNameA(pe32.szExeFile);
            if (pszFile)
            {
                SHAnsiToUnicode( pszFile, _pProcInfoArray[iIndex].szExeName, 
                                 ARRAYSIZE(_pProcInfoArray[iIndex].szExeName)); 
            }
            iIndex++;
        }
        while (_lpfnProcess32Next(hProcessSnap, &pe32));

        _iProcInfoCount = iIndex; // takes care of the last failure
        hr = S_OK;
    }

    CloseHandle (hProcessSnap);
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\privacy.cpp ===
//*********************************************************************
//*          Microsoft Windows                                       **
//*        Copyright(c) Microsoft Corp., 1995                        **
//*********************************************************************

//
// PRIVACY.cpp - "Privacy" Property Sheet and support dialogs
//

// HISTORY:
//
// 2/26/2001  darrenmi    new code
// 4/05/2001  jeffdav     did per-site cookie dialog ui stuff

#include "inetcplp.h"

#include <urlmon.h>
#include <mluisupp.h>

#include <htmlhelp.h>

BOOL DeleteCacheCookies();
INT_PTR CALLBACK EmptyCacheCookiesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);

#define REGSTR_PATH_SETTINGS        TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings")
#define REGSTR_VAL_PRIVADV          TEXT("PrivacyAdvanced")

#define REGSTR_PRIVACYPS_PATHEDIT   TEXT("Software\\Policies\\Microsoft\\Internet Explorer")
#define REGSTR_PRIVACYPS_VALUEDIT   TEXT("PrivacyAddRemoveSites")  //  this key is duplicated in shdocvw\privacyui.cpp

#define REGSTR_PRIVACYPS_PATHPANE   TEXT("Software\\Policies\\Microsoft\\Internet Explorer\\Control Panel")
#define REGSTR_PRIVACYPS_VALUPANE   TEXT("Privacy Settings")  //  this key is duplicated in shdocvw\privacyui.cpp

///////////////////////////////////////////////////////////////////////////////////////
//
// Per-site list dialog
//
///////////////////////////////////////////////////////////////////////////////////////

///////////////////////////////////////////////////////////////////////////////////////
//
// Per-site list utility function to minimize the domain name
//

WCHAR *GetMinCookieDomainFromUrl(WCHAR *bstrFullUrl)
{
    WCHAR *pMinimizedDomain = NULL;

    if(bstrFullUrl == NULL)
        goto doneGetMinimizedCookieDomain;

    if(bstrFullUrl[0] == '\0')
        goto doneGetMinimizedCookieDomain;

    WCHAR *pBeginUrl = bstrFullUrl;

    WCHAR *pEndUrl = pBeginUrl;    // pEndUrl will find the '/path/path..' and clip it from pBeginUrl

    while(*pEndUrl != L'\0' && *pEndUrl != L'/')
        pEndUrl++;

    *pEndUrl = L'\0';
    pMinimizedDomain = pEndUrl;   

    do
    {
        pMinimizedDomain--;
        while(pBeginUrl < pMinimizedDomain
              && *(pMinimizedDomain-1) != L'.')
        {
            pMinimizedDomain--;
        }
    } while(!IsDomainLegalCookieDomain( pMinimizedDomain, pBeginUrl)
            && pBeginUrl < pMinimizedDomain);

doneGetMinimizedCookieDomain:

    return pMinimizedDomain;
}

///////////////////////////////////////////////////////////////////////////////////////
//
// Per-site list sorting function and data structure
//

struct LVCOMPAREINFO
{
    HWND    hwndLV;         //hwnd for listview
    int     iCol;           //column (0 based)
    BOOL    fAscending;     //true if ascending, false if descending
};

int CALLBACK CompareByAlpha(LPARAM lParam1, LPARAM lParam2, LPARAM lParamSort)
{
    struct LVCOMPAREINFO   *plvci = (struct LVCOMPAREINFO *)lParamSort;
    WCHAR  wz1[INTERNET_MAX_URL_LENGTH];
    WCHAR  wz2[INTERNET_MAX_URL_LENGTH];

    ListView_GetItemText(plvci->hwndLV, lParam1, plvci->iCol, wz1, ARRAYSIZE(wz1));
    ListView_GetItemText(plvci->hwndLV, lParam2, plvci->iCol, wz2, ARRAYSIZE(wz2));

    int iVal = _wcsicmp(wz1, wz2);

    if (iVal < 0)
        return (plvci->fAscending ? -1 : 1);

    if (iVal == 0)
        return (0);

    // only thing left is if (iVal > 0)...
    return (plvci->fAscending ? 1 : -1);

}

///////////////////////////////////////////////////////////////////////////////////////
//
// Per-site list defines and prototypes
//

#define PRIVACYPS_ACTION_ACCEPT   0
#define PRIVACYPS_ACTION_REJECT   1
#define PRIVACYPS_ACTION_NOACTION 2

void OnContextMenu(HWND hDlg, LPARAM lParam);
void OnInvalidDomain(HWND hDlg);
void OnSiteSet(HWND hDlg);
void OnSiteDelete(HWND hDlg);
void OnSiteClear(HWND hDlg);
void PerSiteInit(HWND hDlg);

LRESULT CALLBACK PrivPerSiteEBProc(HWND hWnd, UINT uMsg, WPARAM wParam,LPARAM lParam);

///////////////////////////////////////////////////////////////////////////////////////
//
// Per-site list functions
//

void OnContextMenu(HWND hWnd, int iIndex, POINT pointClick)
{

    HMENU  hMenu0 = LoadMenu(MLGetHinst(), MAKEINTRESOURCE(IDR_PERSITE_CONTEXT_MENU));
    HMENU  hMenu1 = GetSubMenu(hMenu0, 0);
    DWORD  dwAction = PRIVACYPS_ACTION_NOACTION;
    WCHAR  wzUrl[INTERNET_MAX_URL_LENGTH];
    WCHAR  wzAction[32];
    LVITEM lvi;

    if(!hMenu1)
        return;

    if(pointClick.x == -1 && pointClick.y == -1)
    {
        RECT rectListRect;
        RECT rectSelectionRect;
        if(   0 != GetWindowRect(hWnd, &rectListRect) &&
           TRUE == ListView_GetItemRect(hWnd, iIndex, &rectSelectionRect, LVIR_LABEL))
        {
            pointClick.x = rectListRect.left + (rectSelectionRect.left + rectSelectionRect.right) / 2;
            pointClick.y = rectListRect.top  + (rectSelectionRect.top + rectSelectionRect.bottom) / 2;
        }
        else
            return;
    }

    // display it, get choice (if any)
    int iPick = TrackPopupMenu(hMenu1, 
                               TPM_LEFTALIGN | TPM_RIGHTBUTTON | TPM_RETURNCMD,
                               pointClick.x,
                               pointClick.y,
                               0,
                               hWnd,
                              (RECT *)NULL);

    DestroyMenu(hMenu0);
    DestroyMenu(hMenu1);

    if (iPick) 
    {
        switch(iPick) 
        {
            case IDM_PRIVACYPS_CTXM_ACCEPT:
                
                // set the action...
                dwAction = PRIVACYPS_ACTION_ACCEPT;
                MLLoadString(IDS_PRIVACYPS_ACCEPT, wzAction, ARRAYSIZE(wzAction));
                
                // then fall-through...

            case IDM_PRIVACYPS_CTXM_REJECT:
                
                // set the action IFF its reject
                if (PRIVACYPS_ACTION_NOACTION == dwAction)
                {
                    dwAction = PRIVACYPS_ACTION_REJECT;
                    MLLoadString(IDS_PRIVACYPS_REJECT, wzAction, ARRAYSIZE(wzAction));
                }

                // update the ui...
                lvi.iItem = iIndex;
                lvi.iSubItem = 1;
                lvi.mask = LVIF_TEXT;
                lvi.pszText = wzAction;
                ListView_SetItem(hWnd, &lvi);
            
                // get the text...
                ListView_GetItemText(hWnd, iIndex, 0, wzUrl, ARRAYSIZE(wzUrl));

                // update the internal list...
                InternetSetPerSiteCookieDecisionW(
                    wzUrl, 
                    ((PRIVACYPS_ACTION_ACCEPT == dwAction) ? COOKIE_STATE_ACCEPT : COOKIE_STATE_REJECT)
                );

                break;

            case IDM_PRIVACYPS_CTXM_DELETE:
                OnSiteDelete(GetParent(hWnd));
                break;

            default:
                break;
        }
    }
}

void OnInvalidDomain(HWND hDlg)
{

    WCHAR       szError[256];
    WCHAR       szTitle[64];

    // error message here
    MLLoadString(IDS_PRIVACYPS_ERRORTTL, szTitle, ARRAYSIZE(szTitle));
    MLLoadString(IDS_PRIVACYPS_ERRORTXT, szError, ARRAYSIZE(szError));
    MessageBox(hDlg, szError, szTitle, MB_ICONEXCLAMATION | MB_OK);

    // select the editbox text so the user can try again...
    SendMessage(GetDlgItem(hDlg, IDC_PRIVACYPS_SITETOSET), EM_SETSEL, (WPARAM)0, (LPARAM)-1);
}

void AutosizeStatusColumnWidth(HWND hwndList)
{
    int  iColWidth = 0;
    RECT rc;

    if (0 == ListView_GetItemCount(hwndList))
    {
        // auto size it based on header text...
        ListView_SetColumnWidth(hwndList, 1, LVSCW_AUTOSIZE_USEHEADER);
    }
    else
    {
        // auto size it based on content...
        ListView_SetColumnWidth(hwndList, 1, LVSCW_AUTOSIZE);
    }

    // see how big that was...
    iColWidth = ListView_GetColumnWidth(hwndList, 1);

    // size the 1st col...
    GetClientRect(hwndList, &rc);
    ListView_SetColumnWidth(hwndList, 0, rc.right-rc.left-iColWidth-GetSystemMetrics(SM_CXVSCROLL));
    
}

void OnSiteSet(HWND hDlg, UINT uiChoice)
{
    WCHAR      wzUrl[INTERNET_MAX_URL_LENGTH];
    WCHAR      wzUrlDomain[INTERNET_MAX_URL_LENGTH];
    WCHAR      wzUrlMinimized[INTERNET_MAX_URL_LENGTH];
    WCHAR      wzSchema[INTERNET_MAX_URL_LENGTH];
    WCHAR      wzAction[32];
    LVFINDINFO lvfi;
    LVITEM     lvi;
    DWORD      dwAction = 0;
    DWORD      dwCount  = 0;
    int        iIndex;
    HWND       hwndList = GetDlgItem(hDlg, IDC_PRIVACYPS_LISTBOX);

    // the enter key and dbl click should do the same thing, so if the listbox has focus
    // and we got called, then they hit enter in the listbox, so let the listbox process
    // a WM_KEYDOWN/VK_RETURN message.
    if (GetFocus() == hwndList)
    {
        INT_PTR iIndx = ListView_GetSelectionMark(GetDlgItem(hDlg, IDC_PRIVACYPS_LISTBOX));
        if (-1 != iIndx)
        {
            SendMessage(hwndList, WM_KEYDOWN, VK_RETURN, NULL);
            return;
        }
    }

    // read url and setting from ui
    GetWindowText(GetDlgItem(hDlg, IDC_PRIVACYPS_SITETOSET), wzUrl, INTERNET_MAX_URL_LENGTH);

    // if it came from AutoComplete it'll have an http:// or https:// in it...
    if(wcsstr(_wcslwr(wzUrl), TEXT("http://")) || 
       wcsstr(_wcslwr(wzUrl), TEXT("https://")))
    {
        // ...and we found it, so get just the domain name...
        if(S_OK != CoInternetParseUrl(wzUrl, PARSE_DOMAIN, NULL, wzUrlDomain, ARRAYSIZE(wzUrlDomain), &dwCount, 0))
        {
            OnInvalidDomain(hDlg);
            return;
        }
        else if(wcslen(wzUrlDomain) < 2)
        {
            OnInvalidDomain(hDlg);
            return;
        }
    }
    else if (wcslen(wzUrl) < 2)
    {
        // we don't want null strings.  in fact, the smallest a domain could theoretically be would be something like "f."
        // so, to avoid null strings and stuff we check...
        OnInvalidDomain(hDlg);
        return;
    }
    else
    {
        // ...otherwise just use it
        wcsncpy(wzUrlDomain, wzUrl, wcslen(wzUrl)+1);
    }

    // only http:// or https:// domains in the internet zone are valid, so if we still have a schema after asking for just
    // the domain (see above) then we must have something like file:/// or some junk like that.
    CoInternetParseUrl(wzUrlDomain, PARSE_SCHEMA, NULL, wzSchema, ARRAYSIZE(wzSchema), &dwCount, 0);
    if (wcslen(wzSchema) != 0)
    {
        OnInvalidDomain(hDlg);
        return;
    }

    // minimize the domain
    wcsncpy(wzUrlMinimized, GetMinCookieDomainFromUrl(wzUrlDomain), wcslen(wzUrlDomain)+1);

    for (unsigned int i=0;i<wcslen(wzUrlMinimized);i++)
    {
        if (iswalnum(wzUrlMinimized[i]))
        {
            continue;
        }
        else
        {
            switch(wzUrlMinimized[i])
            {
                case L'.':
                    if (i >= 1) 
                        if (L'.' == wzUrlMinimized[i-1]) //prevent duplicate periods like "www..net"
                            break;
                    // (fallthrough)

                case L'-':
                    if (i == 0) // first character cannot be a dash
                        break;
                    // (fallthrough)

                case L'/':
                    continue;

                default:
                    break;
            }
            
            OnInvalidDomain(hDlg);
            return;
        }
    }

    if (!wcschr(_wcslwr(wzUrlMinimized), L'.'))
    {
        OnInvalidDomain(hDlg);
        return;
    }

    // valid domain?
    if(FALSE == IsDomainLegalCookieDomainW(wzUrlMinimized, wzUrlMinimized))
    {
        OnInvalidDomain(hDlg);
        return;
    }

    // are we accepting or rejecting this site?
    if (IDC_PRIVACYPS_ACCEPTBTN == uiChoice)
    {
        dwAction = PRIVACYPS_ACTION_ACCEPT;
        MLLoadString(IDS_PRIVACYPS_ACCEPT, wzAction, ARRAYSIZE(wzAction));
    }
    else 
    if (IDC_PRIVACYPS_REJECTBTN == uiChoice)
    {
        dwAction = PRIVACYPS_ACTION_REJECT;
        MLLoadString(IDS_PRIVACYPS_REJECT, wzAction, ARRAYSIZE(wzAction));
    }
    else
    {
        return;
    }
   
    // update UI...
    lvfi.flags = LVFI_STRING;
    lvfi.psz = wzUrlMinimized;
    iIndex = ListView_FindItem(hwndList, -1, &lvfi);

    if(iIndex != -1)
    {
        // found it, ensure correct subitem...
        lvi.iItem = iIndex;
        lvi.iSubItem = 1;
        lvi.pszText = wzAction;
        lvi.mask = LVIF_TEXT;
        ListView_SetItem(hwndList, &lvi);

        AutosizeStatusColumnWidth(hwndList);
    }
    else 
    {
        // add a new item...
        lvi.iItem = 0;
        lvi.iSubItem = 0;
        lvi.mask = LVIF_TEXT;
        lvi.pszText = wzUrlMinimized;
        iIndex = ListView_InsertItem(hwndList, &lvi);

        lvi.iItem = iIndex;
        lvi.iSubItem = 1;
        lvi.mask = LVIF_TEXT;
        lvi.pszText = wzAction;
        ListView_SetItem(hwndList, &lvi);

        AutosizeStatusColumnWidth(hwndList);

        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEALLBTN), TRUE);
    }

    // update internal list...
    InternetSetPerSiteCookieDecisionW(
        wzUrlMinimized, 
        ((PRIVACYPS_ACTION_ACCEPT == dwAction) ? COOKIE_STATE_ACCEPT : COOKIE_STATE_REJECT)
    );

    // clear the edit box...
    SetWindowText(GetDlgItem(hDlg, IDC_PRIVACYPS_SITETOSET), TEXT(""));
    SetFocus(GetDlgItem(hDlg, IDC_PRIVACYPS_SITETOSET));
}

void OnSiteDelete(HWND hDlg)
{
    WCHAR       wzUrl[INTERNET_MAX_URL_LENGTH];
    HWND        hwndList = GetDlgItem(hDlg, IDC_PRIVACYPS_LISTBOX);
    INT_PTR     iIndex;
    
    // get the current selection in the list view...
    iIndex = ListView_GetSelectionMark(hwndList);

    // if we got something get the URL and delete it...
    if(iIndex != -1)
    {
        // remove from listview...
        ListView_GetItemText(hwndList, iIndex, 0, wzUrl, ARRAYSIZE(wzUrl));
        ListView_DeleteItem(hwndList, iIndex);

        // disable buttons if the listbox is now empty...
        if(0 == ListView_GetItemCount(hwndList))
        {
            EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEBTN), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEALLBTN), FALSE);
        }

        InternetSetPerSiteCookieDecisionW(wzUrl, COOKIE_STATE_UNKNOWN);
        
        // clear selection
        SetFocus(GetDlgItem(hDlg, IDC_PRIVACYPS_LISTBOX));
        iIndex = ListView_GetSelectionMark(hwndList);
        ListView_SetItemState(hwndList, iIndex, NULL, LVIS_FOCUSED | LVIS_SELECTED);
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEBTN), FALSE);
    }
}

void OnSiteClear(HWND hDlg)
{
    // empty the list...
    ListView_DeleteAllItems(GetDlgItem(hDlg, IDC_PRIVACYPS_LISTBOX));
    InternetClearAllPerSiteCookieDecisions();
    
    // disable the remove buttons...
    EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEBTN), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEALLBTN), FALSE);

    // set focus back to the edit box so they can add more if they feel like it...
    SetFocus(GetDlgItem(hDlg, IDC_PRIVACYPS_SITETOSET));
}

void PerSiteInit(HWND hDlg)
{

    HWND          hwndList       = GetDlgItem(hDlg, IDC_PRIVACYPS_LISTBOX);
    LVITEM        lviEntry;
    DWORD         dwSizeOfBuffer = 0; // in bytes
    DWORD         dwDecision     = 0;
    DWORD         dwIndex        = 0;
    WCHAR         wzSiteNameBuffer[INTERNET_MAX_URL_LENGTH];
    LONG_PTR      wndprocOld     = NULL;
    WCHAR         wzTitle[64];
    WCHAR         wzAccept[32];
    WCHAR         wzReject[32];
    int           iItem;
    DWORD         dwRet, dwType, dwValue, dwSize;

    // subclass the editbox
    wndprocOld = SetWindowLongPtr(GetDlgItem(hDlg, IDC_PRIVACYPS_SITETOSET), GWLP_WNDPROC, (LONG_PTR)PrivPerSiteEBProc);

    // put a pointer to the old proc in GWLP_USERDATA so we can call it...
    SetWindowLongPtr(GetDlgItem(hDlg, IDC_PRIVACYPS_SITETOSET), GWLP_USERDATA, wndprocOld);


    if (!hwndList)
        return;

    // empty the listview...
    ListView_DeleteAllItems(hwndList);

    // initialize domain column in the listview...
    LV_COLUMN   lvColumn;        
    RECT rc;

    // load the accept and reject strings...
    MLLoadString(IDS_PRIVACYPS_ACCEPT, wzAccept, ARRAYSIZE(wzAccept));
    MLLoadString(IDS_PRIVACYPS_REJECT, wzReject, ARRAYSIZE(wzReject));

    lvColumn.mask = LVCF_FMT | LVCF_TEXT;
    lvColumn.fmt = LVCFMT_LEFT;

    if( 0 != GetClientRect( hwndList, &rc))
    {
        lvColumn.cx = rc.right - rc.left - GetSystemMetrics(SM_CXVSCROLL) - 75;
        lvColumn.mask |= LVCF_WIDTH;
    }

    MLLoadString(IDS_PRIVACYPS_COLSITE, wzTitle, ARRAYSIZE(wzTitle));
    lvColumn.pszText = wzTitle;
    
    ListView_InsertColumn(hwndList, 0, &lvColumn);

    // initialize setting column
    lvColumn.mask = LVCF_FMT | LVCF_TEXT;
    lvColumn.fmt = LVCFMT_LEFT;

    if( 0 != GetClientRect( hwndList, &rc))
    {
        lvColumn.cx = 75;
        lvColumn.mask |= LVCF_WIDTH;
    }

    MLLoadString(IDS_PRIVACYPS_COLSET, wzTitle, ARRAYSIZE(wzTitle));
    lvColumn.pszText = wzTitle;
    
    ListView_InsertColumn(hwndList, 1, &lvColumn);

    // enumerate elements...
    while(InternetEnumPerSiteCookieDecision(wzSiteNameBuffer,
                                            (dwSizeOfBuffer = ARRAYSIZE(wzSiteNameBuffer), &dwSizeOfBuffer),
                                            &dwDecision,dwIndex))
    {

        lviEntry.iItem = dwIndex;
        lviEntry.iSubItem = 0;
        lviEntry.mask = LVIF_TEXT /*| LVIF_IMAGE*/;
        lviEntry.pszText = wzSiteNameBuffer;

        // don't display crap users may hack into the registry themselves, or hosed entries we may write :)
        if(FALSE == IsDomainLegalCookieDomainW(wzSiteNameBuffer, wzSiteNameBuffer))
        {
            dwIndex++;
            continue;
        }

        iItem = ListView_InsertItem(hwndList, &lviEntry);

        lviEntry.iItem = iItem;
        lviEntry.iSubItem = 1;
        lviEntry.mask = LVIF_TEXT;
        if (dwDecision == COOKIE_STATE_ACCEPT)
            lviEntry.pszText = wzAccept;
        else if (dwDecision == COOKIE_STATE_REJECT)
            lviEntry.pszText = wzReject;
        else
        {
            dwIndex++;
            continue;
        }

        ListView_SetItem(hwndList, &lviEntry);

        dwIndex++;
    }

    AutosizeStatusColumnWidth(hwndList);

    // enable the remove all button if we enumerated anything...
    if (dwIndex > 0)
    {
        ListView_SetItemState(hwndList, 0, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEALLBTN), TRUE);
    }

    // enable autocomplete for the editbox...
    SHAutoComplete(GetDlgItem(hDlg, IDC_PRIVACYPS_SITETOSET), SHACF_DEFAULT);

    // check for policy to make this dialog read-only...
    dwSize = sizeof(dwValue);
    dwRet = SHGetValue(HKEY_CURRENT_USER, REGSTR_PRIVACYPS_PATHPANE, REGSTR_PRIVACYPS_VALUPANE, &dwType, &dwValue, &dwSize);

    if (ERROR_SUCCESS == dwRet && dwValue && REG_DWORD == dwType)
    {
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)TRUE);

        // disable all buttons and stuff...
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_SITETOSET), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REJECTBTN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_ACCEPTBTN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEBTN), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEALLBTN), FALSE);
    }
}

void OnDoubleClick(HWND hWnd)
{
    
    int   iIndex = ListView_GetSelectionMark(hWnd);
    WCHAR wzUrl[INTERNET_MAX_URL_LENGTH];

    // on dbl clicks we want to enter the item in the edit box so the user can edit it, or cut & paste, or whatever
    // but only if we actually have a selected item...
    if (-1 == iIndex)
        return;

    // get the current selection...
    ListView_GetItemText(hWnd, iIndex, 0, wzUrl, ARRAYSIZE(wzUrl));
    
    // enter the text into the edit box...
    SetDlgItemText(GetParent(hWnd), IDC_PRIVACYPS_SITETOSET, wzUrl);

    // select it for the user...
    SendMessage(GetDlgItem(GetParent(hWnd), IDC_PRIVACYPS_SITETOSET), EM_SETSEL, (WPARAM)0, (LPARAM)-1);

    // set focus to the edit box...
    SetFocus(GetDlgItem(GetParent(hWnd), IDC_PRIVACYPS_SITETOSET));

    // unselect the listview item...
    ListView_SetItemState(hWnd, iIndex, NULL, LVIS_FOCUSED | LVIS_SELECTED);

}

///////////////////////////////////////////////////////////////////////////////////////
//
// Per-site list window proc's
//

LRESULT CALLBACK PrivPerSiteEBProc(HWND hWnd, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    HWND hDlg     = GetParent(hWnd);
    HWND hwndList = GetDlgItem(hDlg, IDC_PRIVACYPS_LISTBOX);
    int  iIndex   = ListView_GetSelectionMark(hwndList);

    switch (uMsg)
    {
        case WM_SETFOCUS:
            // disable the remove button and unselect whatever in the listview...
            EnableWindow(GetDlgItem(GetParent(hWnd), IDC_PRIVACYPS_REMOVEBTN), FALSE);
            ListView_SetItemState(hwndList, iIndex, NULL, LVIS_FOCUSED | LVIS_SELECTED);
            break;

        default:
            break;
    }

    return (CallWindowProc((WNDPROC)GetWindowLongPtr(hWnd, GWLP_USERDATA), hWnd, uMsg, wParam, lParam));
}

INT_PTR CALLBACK PrivPerSiteDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{

    HWND hwndList = GetDlgItem(hDlg, IDC_PRIVACYPS_LISTBOX);
    
    switch (uMsg)
    {
        case WM_INITDIALOG:
            PerSiteInit(hDlg);

            if( IsOS(OS_WHISTLERORGREATER))
            {
                HICON hIcon = LoadIcon(MLGetHinst(), MAKEINTRESOURCE(IDI_PRIVACY_XP));
                if( hIcon != NULL)
                    SendDlgItemMessage(hDlg, IDC_PRIVACY_ICON, STM_SETICON, (WPARAM)hIcon, 0);
                // icons loaded with LoadIcon never need to be released
            }
            
            return TRUE;

        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDCANCEL:
                case IDOK:
                    return EndDialog(hDlg, 0);

                case IDC_PRIVACYPS_REMOVEALLBTN:
                    OnSiteClear(hDlg);
                    return TRUE;

                case IDC_PRIVACYPS_REMOVEBTN:
                    OnSiteDelete(hDlg);
                    return TRUE;

                case IDC_PRIVACYPS_ACCEPTBTN:
                    OnSiteSet(hDlg, IDC_PRIVACYPS_ACCEPTBTN);
                    return TRUE;
                
                case IDC_PRIVACYPS_REJECTBTN:
                    OnSiteSet(hDlg, IDC_PRIVACYPS_REJECTBTN);
                    return TRUE;

            }
            break;
        
        case WM_NOTIFY:
            if (IDC_PRIVACYPS_LISTBOX == ((LPNMHDR)lParam)->idFrom)
            {
                switch (((LPNMHDR)lParam)->code)
                {
                    case NM_KILLFOCUS:

                        // lost focus, turn off remove button
                        if ((GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEBTN) != GetFocus()) ||
                            (-1 == ListView_GetSelectionMark(hwndList)))
                        {
                            EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEBTN), FALSE);
                        }

                        return TRUE;

                    case NM_SETFOCUS:
                        {
                            // if there is nothing in the list we have nothing to do
                            if (0 == ListView_GetItemCount(hwndList))
                                break;

                            // if this is true a policy has been set making per-site list read-only, so do nothing...
                            if ((BOOL)GetWindowLongPtr(hDlg, DWLP_USER))
                                break;

                            int iIndex = ListView_GetSelectionMark(hwndList);

                            if (-1 == iIndex)
                            {
                                iIndex = 0;
                            }

                            // select|focus the correct item...
                            ListView_SetItemState(hwndList, iIndex, LVIS_FOCUSED | LVIS_SELECTED, LVIS_FOCUSED | LVIS_SELECTED);
                            EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEBTN), TRUE);

                        }
                        return TRUE;

                    case NM_CLICK:
                        
                        if (-1 != ListView_GetSelectionMark(hwndList) &&
                            !((BOOL)GetWindowLongPtr(hDlg, DWLP_USER)))
                        {
                            EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEBTN), TRUE);
                        }
                        else
                        {
                            EnableWindow(GetDlgItem(hDlg, IDC_PRIVACYPS_REMOVEBTN), FALSE);
                        }
                        return TRUE;
                    
                    case NM_DBLCLK:
                        
                        OnDoubleClick(hwndList);
                        return TRUE;

                    case NM_RCLICK:
                        {
                            // if this is true a policy has been set making per-site list read-only, so don't show the context menu,
                            // since all it does is allow you to change or remove things...
                            if ((BOOL)GetWindowLongPtr(hDlg, DWLP_USER))
                                break;

                            int iItem = ((LPNMITEMACTIVATE)lParam)->iItem;

                            if (-1 != iItem)
                            {
                                POINT pointClick = ((LPNMITEMACTIVATE)lParam)->ptAction;
                                RECT  rc;

                                if(0 != GetWindowRect(hwndList, &rc))
                                {
                                    pointClick.x += rc.left;
                                    pointClick.y += rc.top;
                                }
                                else
                                {  
                                    pointClick.x = -1;
                                    pointClick.y = -1;
                                }
                                
                                OnContextMenu(hwndList, iItem, pointClick);
                            }

                            return TRUE;
                        }

                    case LVN_KEYDOWN:

                        switch (((LPNMLVKEYDOWN)lParam)->wVKey)
                        {
                            case VK_DELETE:

                                OnSiteDelete(hDlg);
                                return TRUE;

                            case VK_RETURN:
                                
                                OnDoubleClick(hwndList);
                                return TRUE;

                            default:
                                break;
                        }
                        break;

                    case LVN_COLUMNCLICK:
                        {
                            struct LVCOMPAREINFO lvci;
                            static BOOL fAscending = TRUE;

                            fAscending = !fAscending;

                            lvci.fAscending = fAscending;                            
                            lvci.hwndLV = hwndList;
                            lvci.iCol   = ((LPNMLISTVIEW)lParam)->iSubItem;
                            
                            return ListView_SortItemsEx(hwndList, CompareByAlpha, &lvci);
                        }
                        
                    default:
                        break;
                }
            }
            break;

        case WM_HELP:               // F1
            ResWinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                       HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            if ((HWND)wParam != hwndList)
            {
                ResWinHelp((HWND) wParam, IDS_HELPFILE, HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            }
            else if (-1 == GET_X_LPARAM(lParam) && -1 == GET_Y_LPARAM(lParam))
            {
                POINT pointClick;
                pointClick.x = -1; pointClick.y = -1;
                OnContextMenu(hwndList, ListView_GetSelectionMark(hwndList), pointClick);
            }
            break;

    }
    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////////////
//
// Advanced privacy settings dialog
//
///////////////////////////////////////////////////////////////////////////////////////

BOOL IsAdvancedMode(void)
{
    DWORD   dwTemplate, dwError;
    BOOL    fAdvanced = FALSE;

    dwError = PrivacyGetZonePreferenceW(
                URLZONE_INTERNET,
                PRIVACY_TYPE_FIRST_PARTY,
                &dwTemplate,
                NULL,
                NULL);

    if(ERROR_SUCCESS == dwError && PRIVACY_TEMPLATE_ADVANCED == dwTemplate)
    {
        fAdvanced = TRUE;
    }

    return fAdvanced;
}

DWORD MapPrefToIndex(WCHAR wcPref)
{
    switch(wcPref)
    {
    case 'r':   return 1;       // reject
    case 'p':   return 2;       // prompt
    default:    return 0;       // default is accept
    }
}

WCHAR MapRadioToPref(HWND hDlg, DWORD dwResource)
{
    if(IsDlgButtonChecked(hDlg, dwResource + 1))        // deny
    {
        return 'r';
    }

    if(IsDlgButtonChecked(hDlg, dwResource + 2))        // prompt
    {
        return 'p';
    }

    // deafult is accept
    return 'a';
}


void OnAdvancedInit(HWND hDlg)
{
    BOOL    fSession = FALSE;
    DWORD   dwFirst = IDC_FIRST_ACCEPT;
    DWORD   dwThird = IDC_THIRD_ACCEPT;

    if(IsAdvancedMode())
    {
        WCHAR   szBuffer[MAX_PATH];  
        // MAX_PATH is sufficent for advanced mode setting strings, MaxPrivacySettings is overkill.
        WCHAR   *pszAlways;
        DWORD   dwBufferSize, dwTemplate;
        DWORD   dwError;

        //
        // turn on advanced check box
        //
        CheckDlgButton(hDlg, IDC_USE_ADVANCED, TRUE);

        //
        // Figure out first party setting and session
        //
        dwBufferSize = ARRAYSIZE( szBuffer);
        dwError = PrivacyGetZonePreferenceW(
                    URLZONE_INTERNET,
                    PRIVACY_TYPE_FIRST_PARTY,
                    &dwTemplate,
                    szBuffer,
                    &dwBufferSize);

        if(ERROR_SUCCESS == dwError)
        {
            pszAlways = StrStrW(szBuffer, L"always=");
            if(pszAlways)
            {
                dwFirst = IDC_FIRST_ACCEPT + MapPrefToIndex(*(pszAlways + 7));
            }

            if(StrStrW(szBuffer, L"session"))
            {
                fSession = TRUE;
            }
        }

        //
        // Figure out third party setting
        //
        dwBufferSize = ARRAYSIZE( szBuffer);
        dwError = PrivacyGetZonePreferenceW(
                    URLZONE_INTERNET,
                    PRIVACY_TYPE_THIRD_PARTY,
                    &dwTemplate,
                    szBuffer,
                    &dwBufferSize);

        if(ERROR_SUCCESS == dwError)
        {
            WCHAR *pszAlways;

            pszAlways = StrStrW(szBuffer, L"always=");
            if(pszAlways)
            {
                dwThird = IDC_THIRD_ACCEPT + MapPrefToIndex(*(pszAlways + 7));
            }
        }
    }

    CheckRadioButton(hDlg, IDC_FIRST_ACCEPT, IDC_FIRST_PROMPT, dwFirst);
    CheckRadioButton(hDlg, IDC_THIRD_ACCEPT, IDC_THIRD_PROMPT, dwThird);
    CheckDlgButton( hDlg, IDC_SESSION_OVERRIDE, fSession);
}

void OnAdvancedOk(HWND hDlg)
{
    BOOL    fWasAdvanced = IsAdvancedMode();
    BOOL    fAdvanced = IsDlgButtonChecked(hDlg, IDC_USE_ADVANCED);

    // if advanced, build first and third party strings
    if(fAdvanced)
    {
        WCHAR   szBuffer[MAX_PATH];

        wnsprintf(szBuffer, ARRAYSIZE( szBuffer), L"IE6-P3PV1/settings: always=%c%s",
                        MapRadioToPref(hDlg, IDC_FIRST_ACCEPT),
                        IsDlgButtonChecked(hDlg, IDC_SESSION_OVERRIDE) ? L" session=a" : L""
                        );

        PrivacySetZonePreferenceW(
                    URLZONE_INTERNET,
                    PRIVACY_TYPE_FIRST_PARTY,
                    PRIVACY_TEMPLATE_ADVANCED,
                    szBuffer);

        wnsprintf(szBuffer, ARRAYSIZE( szBuffer), L"IE6-P3PV1/settings: always=%c%s",
                        MapRadioToPref(hDlg, IDC_THIRD_ACCEPT),
                        IsDlgButtonChecked(hDlg, IDC_SESSION_OVERRIDE) ? L" session=a" : L""
                        );

        PrivacySetZonePreferenceW(
                    URLZONE_INTERNET,
                    PRIVACY_TYPE_THIRD_PARTY,
                    PRIVACY_TEMPLATE_ADVANCED,
                    szBuffer);

        // tell wininet to refresh itself
        InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
    }
    else if ( fWasAdvanced && !fAdvanced)
    {
        PrivacySetZonePreferenceW(
            URLZONE_INTERNET,
            PRIVACY_TYPE_FIRST_PARTY,
            PRIVACY_TEMPLATE_MEDIUM, NULL);
        PrivacySetZonePreferenceW(
            URLZONE_INTERNET,
            PRIVACY_TYPE_THIRD_PARTY,
            PRIVACY_TEMPLATE_MEDIUM, NULL);

        // tell wininet to refresh itself
        InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);
    }
}

void OnAdvancedEnable(HWND hDlg)
{
    BOOL fEnabled = IsDlgButtonChecked(hDlg, IDC_USE_ADVANCED);

    // if restricted, disable checkbox and force all others disabled
    if(g_restrict.fPrivacySettings)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_USE_ADVANCED), FALSE);
        fEnabled = FALSE;
    }

    EnableWindow(GetDlgItem(hDlg, IDC_FIRST_ACCEPT), fEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_FIRST_DENY), fEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_FIRST_PROMPT), fEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_THIRD_ACCEPT), fEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_THIRD_DENY), fEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_THIRD_PROMPT), fEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_SESSION_OVERRIDE), fEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_TX_FIRST), fEnabled);
    EnableWindow(GetDlgItem(hDlg, IDC_TX_THIRD), fEnabled);
}

INT_PTR CALLBACK PrivAdvancedDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            OnAdvancedInit(hDlg);
            OnAdvancedEnable(hDlg);
           
            if( IsOS(OS_WHISTLERORGREATER))
            {
                HICON hIcon = LoadIcon(MLGetHinst(), MAKEINTRESOURCE(IDI_PRIVACY_XP));
                if( hIcon != NULL)
                    SendDlgItemMessage(hDlg, IDC_PRIVACY_ICON, STM_SETICON, (WPARAM)hIcon, 0);
                // icons loaded with LoadIcon never need to be released
            }
           
            return TRUE;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;
         
        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDOK:
                    if(FALSE == g_restrict.fPrivacySettings)
                    {
                        OnAdvancedOk(hDlg);
                    }
                    // fall through

                case IDCANCEL:
                    EndDialog(hDlg, IDOK == LOWORD(wParam));
                    return 0;

                case IDC_FIRST_ACCEPT:
                case IDC_FIRST_PROMPT:
                case IDC_FIRST_DENY:
                    CheckRadioButton(hDlg, IDC_FIRST_ACCEPT, IDC_FIRST_PROMPT, LOWORD(wParam));
                    return 0;

                case IDC_THIRD_ACCEPT:
                case IDC_THIRD_PROMPT:
                case IDC_THIRD_DENY:
                    CheckRadioButton(hDlg, IDC_THIRD_ACCEPT, IDC_THIRD_PROMPT, LOWORD(wParam));
                    return 0;

                case IDC_USE_ADVANCED:
                    OnAdvancedEnable(hDlg);
                    return 0;

                case IDC_PRIVACY_EDIT:
                    DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_PRIVACY_PERSITE),
                             hDlg, PrivPerSiteDlgProc);
                    return 0;
            }
            break;
    }
    return FALSE;
}



///////////////////////////////////////////////////////////////////////////////////////
//
// Privacy pane
//
///////////////////////////////////////////////////////////////////////////////////////

#define PRIVACY_LEVELS          6
#define SLIDER_LEVEL_CUSTOM     6

TCHAR szPrivacyLevel[PRIVACY_LEVELS + 1][30];
TCHAR szPrivacyDescription[PRIVACY_LEVELS + 1][400];

typedef struct _privslider {

    DWORD_PTR   dwLevel;
    BOOL        fAdvanced;
    BOOL        fCustom;
    HFONT       hfontBolded;
    BOOL        fEditDisabled;

} PRIVSLIDER, *PPRIVSLIDER;

void EnablePrivacyControls(HWND hDlg, BOOL fCustom)
{
    WCHAR szBuffer[256];

    if( fCustom)
        MLLoadString( IDS_PRIVACY_SLIDERCOMMANDDEF, szBuffer, ARRAYSIZE( szBuffer));
    else
        MLLoadString( IDS_PRIVACY_SLIDERCOMMANDSLIDE, szBuffer, ARRAYSIZE( szBuffer));

    SendMessage(GetDlgItem(hDlg, IDC_PRIVACY_SLIDERCOMMAND), WM_SETTEXT, 
                0, (LPARAM)szBuffer);
     
    // slider disabled when custom
    EnableWindow(GetDlgItem(hDlg, IDC_LEVEL_SLIDER),       !fCustom);
    ShowWindow(GetDlgItem(hDlg, IDC_LEVEL_SLIDER),         !fCustom);

    // default button enabled with custom
    EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_DEFAULT),     fCustom);

    // if restricted, force slider and defaults disabled
    if(g_restrict.fPrivacySettings)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_DEFAULT), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_LEVEL_SLIDER),    FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_IMPORT),  FALSE);
    }
}

PPRIVSLIDER OnPrivacyInit(HWND hDlg)
{
    DWORD   i;
    PPRIVSLIDER pData;
    DWORD dwRet, dwType, dwSize, dwValue;

    // allocate storage for the font and current level
    pData = new PRIVSLIDER;
    if(NULL == pData)
    {
        // doh
        return NULL;
    }
    pData->dwLevel = -1;
    pData->hfontBolded = NULL;
    pData->fAdvanced = IsAdvancedMode();
    pData->fCustom = FALSE;
    pData->fEditDisabled = FALSE;

    // 
    // Set the font of the name to the bold font
    //

    // find current font
    HFONT hfontOrig = (HFONT) SendDlgItemMessage(hDlg, IDC_LEVEL, WM_GETFONT, (WPARAM) 0, (LPARAM) 0);
    if(hfontOrig == NULL)
        hfontOrig = (HFONT) GetStockObject(SYSTEM_FONT);

    // build bold font
    if(hfontOrig)
    {
        LOGFONT lfData;
        if(GetObject(hfontOrig, SIZEOF(lfData), &lfData) != 0)
        {
            // The distance from 400 (normal) to 700 (bold)
            lfData.lfWeight += 300;
            if(lfData.lfWeight > 1000)
                lfData.lfWeight = 1000;
            pData->hfontBolded = CreateFontIndirect(&lfData);
            if(pData->hfontBolded)
            {
                // the zone level and zone name text boxes should have the same font, so this is okat
                SendDlgItemMessage(hDlg, IDC_LEVEL, WM_SETFONT, (WPARAM) pData->hfontBolded, (LPARAM) MAKELPARAM(FALSE, 0));
            }
        }
    }

    // initialize slider
    SendDlgItemMessage(hDlg, IDC_LEVEL_SLIDER, TBM_SETRANGE, (WPARAM) (BOOL) FALSE, (LPARAM) MAKELONG(0, PRIVACY_LEVELS - 1));
    SendDlgItemMessage(hDlg, IDC_LEVEL_SLIDER, TBM_SETTICFREQ, (WPARAM) 1, (LPARAM) 0);

    // initialize strings for levels and descriptions
    for(i=0; i<PRIVACY_LEVELS + 1; i++)
    {
        MLLoadString(IDS_PRIVACY_LEVEL_NO_COOKIE + i, szPrivacyLevel[i], ARRAYSIZE(szPrivacyLevel[i]));
        MLLoadString(IDS_PRIVACY_DESC_NO_COOKIE + i,  szPrivacyDescription[i], ARRAYSIZE(szPrivacyDescription[i]));
    }

    //
    // Get current internet privacy level
    //
    DWORD dwError, dwTemplateFirst, dwTemplateThird;


    // read first party setting
    dwError = PrivacyGetZonePreferenceW(
                    URLZONE_INTERNET,
                    PRIVACY_TYPE_FIRST_PARTY,
                    &dwTemplateFirst,
                    NULL,
                    NULL);

    if(dwError != ERROR_SUCCESS)
    {
        dwTemplateFirst = PRIVACY_TEMPLATE_CUSTOM;
    }

    // read third party setting
    dwError = PrivacyGetZonePreferenceW(
                    URLZONE_INTERNET,
                    PRIVACY_TYPE_THIRD_PARTY,
                    &dwTemplateThird,
                    NULL,
                    NULL);

    if(dwError != ERROR_SUCCESS)
    {
        dwTemplateThird = PRIVACY_TEMPLATE_CUSTOM;
    }

    if(dwTemplateFirst == dwTemplateThird && dwTemplateFirst != PRIVACY_TEMPLATE_CUSTOM)
    {
        // matched template values, set slider to template level
        pData->dwLevel = dwTemplateFirst;

        if(dwTemplateFirst == PRIVACY_TEMPLATE_ADVANCED)
        {
            pData->fAdvanced = TRUE;
            pData->dwLevel = SLIDER_LEVEL_CUSTOM;
        }
    }
    else
    {
        // make custom end of list
        pData->dwLevel = SLIDER_LEVEL_CUSTOM;
        pData->fCustom = TRUE;
    }

    // move slider to right spot
    SendDlgItemMessage(hDlg, IDC_LEVEL_SLIDER, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)pData->dwLevel);

    // Enable stuff based on mode
    EnablePrivacyControls(hDlg, ((pData->fAdvanced) || (pData->fCustom)));

    // save off struct
    SetWindowLongPtr(hDlg, DWLP_USER, (DWORD_PTR)pData);

    dwSize = sizeof(dwValue);
    dwRet = SHGetValue(HKEY_CURRENT_USER, REGSTR_PRIVACYPS_PATHEDIT, REGSTR_PRIVACYPS_VALUEDIT, &dwType, &dwValue, &dwSize);

    if (ERROR_SUCCESS == dwRet && 1 == dwValue && REG_DWORD == dwType)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_EDIT), FALSE);
        pData->fEditDisabled = TRUE;
    }

    return pData;
}

void OnPrivacyApply(HWND hDlg, PPRIVSLIDER pData)
{
    if(pData->fCustom || pData->fAdvanced)
    {
        // nothing else to do
        return;
    }

    DWORD_PTR dwPos = SendDlgItemMessage(hDlg, IDC_LEVEL_SLIDER, TBM_GETPOS, 0, 0);

    if(pData->dwLevel != dwPos)
    {
        DWORD   dwCookieAction = URLPOLICY_DISALLOW;

        // Set privacy settings
        PrivacySetZonePreferenceW(
                URLZONE_INTERNET,
                PRIVACY_TYPE_FIRST_PARTY,
                (DWORD)dwPos,
                NULL);

        PrivacySetZonePreferenceW(
                URLZONE_INTERNET,
                PRIVACY_TYPE_THIRD_PARTY,
                (DWORD)dwPos,
                NULL);

        // tell wininet to refresh itself
        InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);

        // save new level as "current"
        pData->dwLevel = dwPos;
    }
}

void OnPrivacySlider(HWND hDlg, PPRIVSLIDER pData)
{
    DWORD dwPos;

    if(pData->fCustom || pData->fAdvanced)
    {
        dwPos = SLIDER_LEVEL_CUSTOM;
    }
    else
    {
        dwPos = (DWORD)SendDlgItemMessage(hDlg, IDC_LEVEL_SLIDER, TBM_GETPOS, 0, 0);

        if(dwPos != pData->dwLevel)
        {
            ENABLEAPPLY(hDlg);
        }

        // enable default button if slider moved off medium
        BOOL fEnable = FALSE;

        if(dwPos != PRIVACY_TEMPLATE_MEDIUM && FALSE == g_restrict.fPrivacySettings)
        {
            fEnable = TRUE;
        }
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_DEFAULT), fEnable);
    }

    if (PRIVACY_TEMPLATE_NO_COOKIES == dwPos || PRIVACY_TEMPLATE_LOW == dwPos || pData->fEditDisabled)
    {
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_EDIT), FALSE);
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg, IDC_PRIVACY_EDIT), TRUE);
    }

    // on Mouse Move, change the level description only
    SetDlgItemText(hDlg, IDC_LEVEL_DESCRIPTION, szPrivacyDescription[dwPos]);
    SetDlgItemText(hDlg, IDC_LEVEL, szPrivacyLevel[dwPos]);
}

void OnPrivacyDefault( HWND hDlg, PPRIVSLIDER pData)
{
    // enable controls correctly
    pData->fAdvanced = FALSE;
    pData->fCustom = FALSE;
    EnablePrivacyControls(hDlg, FALSE);

    // set slider to medium
    SendDlgItemMessage(hDlg, IDC_LEVEL_SLIDER, TBM_SETPOS, (WPARAM)TRUE, (LPARAM)PRIVACY_TEMPLATE_MEDIUM);

    // update descriptions
    pData->dwLevel = SLIDER_LEVEL_CUSTOM;       // difference from medium so we get apply button
    OnPrivacySlider(hDlg, pData);

    //  Give slider focus (if default button has focus and gets disabled, 
    //    alt-key dialog control breaks)
    SendMessage( hDlg, WM_NEXTDLGCTL, 
                 (WPARAM)GetDlgItem( hDlg, IDC_LEVEL_SLIDER), 
                 MAKELPARAM( TRUE, 0)); 

}

INT_PTR CALLBACK PrivacyDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PPRIVSLIDER pData = (PPRIVSLIDER)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
        case WM_INITDIALOG:
            // initialize slider
            pData = OnPrivacyInit(hDlg);
            if(pData)
            {
                OnPrivacySlider(hDlg, pData);
            }

            if( IsOS(OS_WHISTLERORGREATER))
            {
                HICON hIcon = LoadIcon(MLGetHinst(), MAKEINTRESOURCE(IDI_PRIVACY_XP));
                if( hIcon != NULL)
                    SendDlgItemMessage(hDlg, IDC_PRIVACY_ICON, STM_SETICON, (WPARAM)hIcon, 0);
                // icons loaded with LoadIcon never need to be released
            }
            return TRUE;

        case WM_VSCROLL:
            // Slider Messages
            OnPrivacySlider(hDlg, pData);
            return TRUE;

        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR *) lParam;

            ASSERT(lpnm);

            switch (lpnm->code)
            {
                case PSN_QUERYCANCEL:
                case PSN_KILLACTIVE:
                case PSN_RESET:
                    return TRUE;

                case PSN_APPLY:
                    // Hitting the apply button runs this code
                    OnPrivacyApply(hDlg, pData);
                    break;
            }
            break;
        }
        case WM_DESTROY:
        {
            if(pData)
            {
                if(pData->hfontBolded)
                    DeleteObject(pData->hfontBolded);

                delete pData;
            }
            break;
        }
        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;
         
        case WM_COMMAND:
            switch(LOWORD(wParam))
            {
                case IDC_PRIVACY_DEFAULT:
                    OnPrivacyDefault( hDlg, pData);
                    return 0;

                case IDC_PRIVACY_ADVANCED:
                {
                    BOOL fWasAdvanced = IsAdvancedMode();
                    
                    // show advanced
                    if( DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_PRIVACY_ADVANCED),
                                  hDlg, PrivAdvancedDlgProc))
                    {
                        // refresh advanced and reset slider/controls
                        pData->fAdvanced = IsAdvancedMode();
                        if(pData->fAdvanced)
                        {
                            // no longer have a slider template
                            pData->fCustom = FALSE;
                            pData->dwLevel = SLIDER_LEVEL_CUSTOM;

                            EnablePrivacyControls(hDlg, (pData->fCustom || pData->fAdvanced));
                            OnPrivacySlider(hDlg, pData);

                            //  Give advanced button focus (if slider has focus and gets disabled, 
                            //    alt-key dialog control breaks)
                            SendMessage( hDlg, WM_NEXTDLGCTL, 
                                         (WPARAM)GetDlgItem( hDlg, IDC_PRIVACY_ADVANCED), 
                                         MAKELPARAM( TRUE, 0)); 
                        }
                        else if (!pData->fAdvanced && fWasAdvanced)
                        {
                            OnPrivacyDefault( hDlg, pData);
                        }
                    }
                    return 0;
                }
                case IDC_PRIVACY_IMPORT:
                {
                    WCHAR szDialogTitle[INTERNET_MAX_URL_LENGTH];
                    WCHAR szFileExpr[INTERNET_MAX_URL_LENGTH];
                    MLLoadString( IDS_PRIVACYIMPORT_TITLE, szDialogTitle, ARRAYSIZE(szDialogTitle));
                    int iFileExprLength = MLLoadString( IDS_PRIVACYIMPORT_FILEEXPR, szFileExpr, ARRAYSIZE(szFileExpr));
                    szFileExpr[ iFileExprLength + 1] = L'\0';  // the extra \0 in the resource gets clipped.. replace it.
                    WCHAR szFile[INTERNET_MAX_URL_LENGTH];
                    szFile[0] = L'\0';
                    OPENFILENAME ofn;
                    memset((void*)&ofn, 0, sizeof(ofn));
                    ofn.lStructSize = sizeof( ofn);
                    ofn.hwndOwner = hDlg;
                    ofn.lpstrFilter = szFileExpr;
                    ofn.lpstrFile = szFile;
                    ofn.nMaxFile = ARRAYSIZE(szFile);
                    ofn.lpstrTitle = szDialogTitle;
                    ofn.Flags = OFN_FILEMUSTEXIST | OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;

                    if( 0 != GetOpenFileName(&ofn))
                    {
                        BOOL fParsePrivacyPreferences = TRUE;
                        BOOL fParsePerSiteRules = TRUE;
                        BOOL fResults;

                        fResults = ImportPrivacySettings( ofn.lpstrFile, 
                                     &fParsePrivacyPreferences, &fParsePerSiteRules);
                                     
                        if( fResults == FALSE
                            || (fParsePrivacyPreferences == FALSE 
                                && fParsePerSiteRules == FALSE))
                        {
                            MLShellMessageBox( hDlg, MAKEINTRESOURCE(IDS_PRIVACYIMPORT_FAILURE), 
                                    MAKEINTRESOURCE(IDS_PRIVACYIMPORT_TITLE),
                                    MB_OK | MB_APPLMODAL | MB_ICONEXCLAMATION | MB_SETFOREGROUND);
                        }
                        else
                        {
                            if( fParsePrivacyPreferences)
                            {
                                pData->fCustom = TRUE;
                                pData->fAdvanced = FALSE;
                                EnablePrivacyControls( hDlg, pData->fCustom);
                                OnPrivacySlider(hDlg, pData);
                            }
                            MLShellMessageBox( hDlg, MAKEINTRESOURCE(IDS_PRIVACYIMPORT_SUCCESS), 
                                    MAKEINTRESOURCE(IDS_PRIVACYIMPORT_TITLE),
                                    MB_OK | MB_APPLMODAL | MB_SETFOREGROUND);
                        }
                    }
                    return 0;       
                }
                case IDC_PRIVACY_EDIT:
                    DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_PRIVACY_PERSITE),
                              hDlg, PrivPerSiteDlgProc);
                    return 0;
            }
            break;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\init.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1995                    **
//*********************************************************************

//
//    INIT.C - Initialization code for Internet control panel
//

//    HISTORY:
//    
//    4/3/95    jeremys        Created.
//

#include "inetcplp.h"
// external calls and defs
#include <inetcpl.h>

#define MLUI_INIT
#include <mluisupp.h>

//
// Downlevel delay load support (we forward to shlwapi)
//
#include <delayimp.h>

PfnDliHook __pfnDliFailureHook;

HINSTANCE ghInstance=NULL;

extern HMODULE hOLE32;
DWORD g_dwtlsSecInitFlags;
BOOL g_bMirroredOS = FALSE;
HMODULE g_hOleAcc;
BOOL g_fAttemptedOleAccLoad = FALSE;

STDAPI_(BOOL) LaunchInternetControlPanelAtPage(HWND hDlg, UINT nStartPage);
BOOL IsCompatModeProcess(void);

void SetupDelayloadErrorHandler()
{
    __pfnDliFailureHook = (PfnDliHook)GetProcAddress(GetModuleHandleA("shlwapi.dll"), "DelayLoadFailureHook");
}

/*******************************************************************

    NAME:        DllEntryPoint

    SYNOPSIS:    Entry point for DLL.

********************************************************************/
STDAPI_(BOOL) DllMain(HINSTANCE hInstDll, DWORD fdwReason, LPVOID lpReserved)
{
    if( fdwReason == DLL_PROCESS_ATTACH )
    {
        SHFusionInitializeFromModule(hInstDll);
        SetupDelayloadErrorHandler();

        if (IsCompatModeProcess())
            // Fail loading in compat mode process
            return 0;
        ghInstance = hInstDll;
        MLLoadResources(ghInstance, TEXT("inetcplc.dll"));
#ifndef REPLACE_PROPSHEET_TEMPLATE
        InitMUILanguage(INETCPL_GetUILanguage());
#endif

#ifdef DEBUG
        CcshellGetDebugFlags();
#endif
        // Thread local storage used in security.cpp
        g_dwtlsSecInitFlags = TlsAlloc();
        g_bMirroredOS = IS_MIRRORING_ENABLED();
        TlsSetValue(g_dwtlsSecInitFlags, (void *) new SECURITYINITFLAGS);

    }
    else if (fdwReason == DLL_PROCESS_DETACH) 
    {
        MLFreeResources(ghInstance);

        if (g_hwndUpdate) 
        {
            // we've got this subclassed.
            // if it's still valid as we leave, we need 
            // to destroy it so that it doesn't fault trying to access our info
            DestroyWindow(g_hwndUpdate);
        }
        
        if(hOLE32)
        {
            FreeLibrary(hOLE32);
            hOLE32 = NULL;

        }

        if (g_hOleAcc)
        {
            FreeLibrary(g_hOleAcc);
            g_hOleAcc = NULL;
            g_fAttemptedOleAccLoad = FALSE;
        }

        // free tls used in security.cpp
        if(g_dwtlsSecInitFlags != (DWORD) -1)
        {
            SECURITYINITFLAGS * psif = NULL;
            psif = (SECURITYINITFLAGS *) TlsGetValue(g_dwtlsSecInitFlags);
            if(psif)
            {
                delete psif;
                psif = NULL;
            }
            TlsFree(g_dwtlsSecInitFlags);
        }
        SHFusionUninitialize();
    }
    return TRUE;
}


BOOL RunningOnNT()
{
    return !(::GetVersion() & 0x80000000);
}


/*******************************************************************

    NAME:        CPlApplet

    SYNOPSIS:    Entry point for control panel.

********************************************************************/
STDAPI_(LRESULT) CPlApplet         // Control panel applet procedure
(
    HWND        hwndCpl,            // Control panel parent window
    UINT        uMsg,               // message
    LPARAM      lParam1,            // value depends on message
    LPARAM      lParam2             // value depends on message
)
{

    LPNEWCPLINFO lpNewCplInfo = (LPNEWCPLINFO) lParam2;
    LPCPLINFO lpCplInfo = (LPCPLINFO) lParam2;
    DWORD dwNIcons;

    switch (uMsg)
    {
    case CPL_INIT:
        //  Initialization message from Control Panel
        return TRUE;

    case CPL_GETCOUNT:
        /* We always have the main internet CPL icon; on Win95 platforms,
         * we also have the Users icon if mslocusr.dll is present.
         */
        dwNIcons = 1;
        if (!RunningOnNT())
        {
            TCHAR szPath[MAX_PATH];

            // check if mslocusr.dll is present in the system dir
            if (GetSystemDirectory(szPath, ARRAYSIZE(szPath)))
            {
                PathAppend(szPath, TEXT("mslocusr.dll"));
                if (PathFileExists(szPath))
                    dwNIcons++;
            }
        }
        return dwNIcons;

    case CPL_INQUIRE:
        /* CPL #0 is the main Internet CPL, #1 (the only other one we'll ever
         * be asked about) is the Users CPL.
         */
        if (!lParam1) {
            lpCplInfo->idIcon = IDI_INTERNET;
            lpCplInfo->idName = IDS_INTERNET;
            lpCplInfo->idInfo = IDS_DESCRIPTION;
            lpCplInfo->lData = 0;
        }
        else {
            lpCplInfo->idIcon = IDI_USERS;
            lpCplInfo->idName = IDS_USERS;
            lpCplInfo->idInfo = IDS_USERS_DESCRIPTION;
            lpCplInfo->lData = 0;
        }
        return FALSE;

    case CPL_NEWINQUIRE:

        // Return new-style info structure for Control Panel

        // By not responding to NEWINQUIRE, Win95 will not preload our
        // .cpl file; by extension, since we are statically linked to MSHTML's
        // import library, MSHTML will also not be loaded.  If we respond to
        // this, then our cpl and MSHTML (>600k) are both loaded when the
        // control panel is just open.  (IE, they will be loaded even if the
        // user has not selected to invoke our specific cpl applet.

        return TRUE;   // TRUE == we are NOT responding to this
        break;

    case CPL_DBLCLK:

        //
        // This means the user did not specify a particular page
        //
        lParam2 = 0;

        // fall through

    case CPL_STARTWPARMSA:
    case CPL_STARTWPARMSW:

        /* CPL #0 is the main Internet CPL, #1 (the only other one we'll ever
         * be asked about) is the Users CPL.  The Users CPL is loaded from
         * mslocusr.dll dynamically.  The entrypoint is structured as a
         * rundll32 entrypoint.
         */
        if (!lParam1) {
        
            //
            // If lParam2!=NULL, then the user specified a page on the command line
            //
            if (lParam2)
            {
                UINT nPage;
                if (CPL_STARTWPARMSA == uMsg)
                    nPage = StrToIntA((LPSTR)lParam2);
                else
                    nPage = StrToIntW((LPWSTR)lParam2);

                LaunchInternetControlPanelAtPage(hwndCpl, nPage);
                
            }

            //
            // Otherwise request the default page
            //
            else
                LaunchInternetControlPanelAtPage(hwndCpl,DEFAULT_CPL_PAGE);
            
            

        }
        else {
            HINSTANCE hinstMSLU = LoadLibrary(TEXT("mslocusr.dll"));
            if (hinstMSLU != NULL) {
                typedef void (*PFNRUNDLL)(HWND hwndParent, HINSTANCE hinstEXE, LPSTR pszCmdLine, int nCmdShow);
                PFNRUNDLL pfn = (PFNRUNDLL)GetProcAddress(hinstMSLU, "UserCPL");
                if (pfn != NULL) {
                    (*pfn)(hwndCpl, NULL, "", SW_SHOW);
                }
                FreeLibrary(hinstMSLU);
            }
        }
        return TRUE;

    case CPL_EXIT:
        // Control Panel is exiting
        break;

    default:
        break;
    }

    return 0L;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\process.h ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1998-                   **
//*********************************************************************
//
// created 8-19-1998
//
//

// class definition for the process information handler
// the class is to wrap NT/Win95 specific debugging aid APIs
#ifdef UNICODE
#undef Process32First 
#undef Process32Next 
#undef PROCESSENTRY32 
#undef PPROCESSENTRY32
#undef LPPROCESSENTRY32
#endif  // !UNICODE
class CProcessInfo
{
public:
    CProcessInfo(); 
    ~CProcessInfo();     
    HRESULT GetExeNameFromPID(DWORD dwPID, LPTSTR szFile, int cchFile);

    BOOL _fNT;
protected:
    HRESULT MakeRoomForInfoArray(int n);
    HRESULT EnsureProcessInfo();
    // 
    // win95 toolhelp stuff
    //
    HRESULT W95InitToolhelp32();
    HRESULT W95CreateProcessList();
    HRESULT W95FillProcessList();

    typedef BOOL (WINAPI* PROCESSWALK)(HANDLE, LPPROCESSENTRY32);
    typedef HANDLE (WINAPI* CREATESNAPSHOT)(DWORD, DWORD);
    CREATESNAPSHOT _lpfnCreateToolhelp32Snapshot;
    PROCESSWALK _lpfnProcess32First;
    PROCESSWALK _lpfnProcess32Next;
    //
    // NT PSAPI stuff
    //
    HRESULT NTInitPsapi();
    HRESULT NTCreateProcessList();
    HRESULT NTFillProcessList(DWORD dwProcessID, int iIndex);
    
    
    typedef BOOL  (CALLBACK* LPFNENUMPROCESSES)(DWORD *,DWORD,DWORD *);
    typedef BOOL  (CALLBACK* LPFNENUMPROCESSMODULES)(HANDLE,HMODULE *,DWORD,LPDWORD);
    typedef DWORD (CALLBACK* LPFNGETMODULEBASENAMEW)(HANDLE,HMODULE,LPWSTR,DWORD);
    HINSTANCE                 _hPsapiDLL; 
    LPFNENUMPROCESSES      _lpfnEnumProcesses; 
    LPFNENUMPROCESSMODULES _lpfnEnumProcessModules; 
    LPFNGETMODULEBASENAMEW  _lpfnGetModuleBaseName;
    //
    // place to hold processs information
    //
    struct PROCESSINFO {
        DWORD dwPID;
        TCHAR szExeName[MAX_PATH];
    } *_pProcInfoArray;
    int _iProcInfoCount;
    int _nAlloced;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\mainwnd.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1995                    **
//*********************************************************************

//
//      OPENCPL.C - The is the heart of starting the "Internet Control Panel".
//  was DIALDLG.C

//      HISTORY:
//
//      4/5/95  jeremys         Created.
//
//      6/22/96 t-gpease        Moved everything that wasn't need (or global) 
//                              to start the control panel into separate, 
//                              managable pieces. This was part of the massive 
//                              (now defuncted) "dialdlg.c" that had just 
//                              about every property sheet written into it. 
//                              This completes the tearing apart of this 
//                              ("dialdlg.c") file. Whew!
//
//
// [arthurbi]
// WARNING - DO NOT ADD "static" variables to Dlg Procs!!!!
//      This code is designed to put up the same dlg in multi
//      threaded environments.  Using globals that maintain
//      state is dangerous.
//
//      State needs to be maintained in the hWin otherwise
//      it will generate bugs.
//

//
// [arthurbi]
// "REMOVED_ID", or DEAD Id: are based on PM decisions to no longer
//      have URLs Underlined.  Left around because PMs may always
//      change their mind.  In the meantime registry is always
//      there for people to change things.
//

#include "inetcplp.h"
#include <inetcpl.h>   // public header for INETCPL
#include "apithk.h"

#include <mluisupp.h>

extern HMODULE hOLE32;
typedef HRESULT (* PCOINIT) (LPVOID);
extern PCOINIT pCoInitialize;
extern BOOL _StartOLE32(); // initializes OLE

#define MAX_NUM_OPTION_PAGES    24

#ifndef UNIX
#define NUM_OPTION_PAGES        6
#else

#ifdef UNIX_FEATURE_ALIAS
#define NUM_OPTION_PAGES        8
#else
#define NUM_OPTION_PAGES        7
#endif /* UNIX_FEATURE_ALIAS */

#endif

RESTRICT_FLAGS g_restrict = {0};

//
// Warning!  LaunchConnectionDialog() below is sensitive to the order of
// this list - it assumes connection tab is 4th in list.  If you change it,
// fix the function.
//
#ifdef UNIX
extern INT_PTR CALLBACK DialupDlgProc(HWND hDlg,UINT uMsg,WPARAM wParam,LPARAM lParam);
#endif
const struct {
    DWORD dwPageFlag;
    int idRes;
    DLGPROC pfnDlgProc;
    BOOL *pfDisabled;
} c_PropInfo[] = {
    { INET_PAGE_GENERAL,    IDD_GENERAL,       General_DlgProc,     &g_restrict.fGeneralTab     },
    { INET_PAGE_SECURITY,   IDD_SECURITY,      SecurityDlgProc,     &g_restrict.fSecurityTab    },
    { INET_PAGE_PRIVACY,    IDD_PRIVACY,       PrivacyDlgProc,      &g_restrict.fPrivacyTab     },
    { INET_PAGE_CONTENT,    IDD_CONTENT,       ContentDlgProc,      &g_restrict.fContentTab     },
#ifndef UNIX
    { INET_PAGE_CONNECTION, IDD_CONNECTION,    ConnectionDlgProc,   &g_restrict.fConnectionsTab },
#else
    { INET_PAGE_CONNECTION, IDD_CONNECTION,    DialupDlgProc,       &g_restrict.fConnectionsTab },
#endif
    { INET_PAGE_PROGRAMS,   IDD_PROGRAMS,      ProgramsDlgProc,     &g_restrict.fProgramsTab    },
    { INET_PAGE_ADVANCED,   IDD_ADVANCED,      AdvancedDlgProc,     &g_restrict.fAdvancedTab    },
#ifdef UNIX
    { INET_PAGE_ASSOC,      IDD_ASSOCIATIONS,  AssocDlgProc,        NULL                        },
#ifdef UNIX_FEATURE_ALIAS
    { INET_PAGE_ALIAS,      IDD_ALIASDLG,      AliasDlgProc,        NULL                        },
#endif /* UNIX_FEATURE_ALIAS */
#endif
};

#define IsPropPageEnabled(iPage)  (c_PropInfo[iPage].pfDisabled==NULL || *c_PropInfo[iPage].pfDisabled==FALSE)

#ifdef ARRAYSIZE
#undef ARRAYSIZE
#endif

#define ARRAYSIZE(arr) (sizeof(arr)/sizeof(arr[0]))


TCHAR g_szCurrentURL[INTERNET_MAX_URL_LENGTH] = {0};


WNDPROC pfnStaticWndProc = NULL;
HWND g_hwndUpdate = NULL;
BOOL g_fChangedMime = FALSE;     // needed to indicate to MSHTML to
// refresh the current page with a 
// new MIME and/or code page.
BOOL g_fSecurityChanged = FALSE;    // needed to indicate if a Active Security
// has changed.

HWND g_hwndPropSheet = NULL;
PFNPROPSHEETCALLBACK g_PropSheetCallback2 = NULL;

int CALLBACK PropSheetCallback(
    HWND hwndDlg,
    UINT uMsg,
    LPARAM lParam
)
{
    if (uMsg==PSCB_INITIALIZED)
    {
        ASSERT(hwndDlg);
        g_hwndPropSheet = hwndDlg;
    }
#ifdef REPLACE_PROPSHEET_TEMPLATE
    return g_PropSheetCallback2 ? g_PropSheetCallback2(hwndDlg, uMsg, lParam)
                                 : PropSheetProc(hwndDlg, uMsg, lParam);
#else
    return g_PropSheetCallback2 ? g_PropSheetCallback2(hwndDlg, uMsg, lParam)
                                 : 0;
#endif
}


// begin ui restrictions stuff 
// key below used to be \software\microsoft\intenet explorer\restrictui
//
const TCHAR c_szKeyRestrict[]       = REGSTR_PATH_INETCPL_RESTRICTIONS;

const TCHAR c_szGeneralTab[]        = REGSTR_VAL_INETCPL_GENERALTAB;
const TCHAR c_szSecurityTab[]       = REGSTR_VAL_INETCPL_SECURITYTAB;
const TCHAR c_szContentTab[]        = REGSTR_VAL_INETCPL_CONTENTTAB;
const TCHAR c_szConnectionsTab[]    = REGSTR_VAL_INETCPL_CONNECTIONSTAB;
const TCHAR c_szProgramsTab[]       = REGSTR_VAL_INETCPL_PROGRAMSTAB;
const TCHAR c_szAdvancedTab[]       = REGSTR_VAL_INETCPL_ADVANCEDTAB;
const TCHAR c_szPrivacyTab[]        = REGSTR_VAL_INETCPL_PRIVACYTAB;
const TCHAR c_szColors[]            = TEXT("Colors");        
const TCHAR c_szLinks[]             = TEXT("Links");         
const TCHAR c_szFonts[]             = TEXT("Fonts");         
const TCHAR c_szInternational[]     = TEXT("Languages");                   // used to be International
const TCHAR c_szDialing[]           = TEXT("Connection Settings");         // used to be Dialing
const TCHAR c_szProxy[]             = TEXT("Proxy");         
const TCHAR c_szPlaces[]            = TEXT("HomePage");                    // used to be Places
const TCHAR c_szHistory[]           = TEXT("History");       
const TCHAR c_szMailNews[]          = TEXT("Messaging");                   // used to be MailNews
const TCHAR c_szResetWebSettings[]  = TEXT("ResetWebSettings");
const TCHAR c_szDefault[]           = TEXT("Check_If_Default");            // used to be Default
const TCHAR c_szRatings[]           = TEXT("Ratings");       
const TCHAR c_szCertif[]            = TEXT("Certificates");                // used to be Certif
const TCHAR c_szCertifPers[]        = TEXT("CertifPers");    
const TCHAR c_szCertifSite[]        = TEXT("CertifSite");    
const TCHAR c_szCertifPub[]         = TEXT("CertifPub");     
const TCHAR c_szCache[]             = TEXT("Cache");         
const TCHAR c_szAutoConfig[]        = TEXT("AutoConfig");
const TCHAR c_szAccessibility[]     = TEXT("Accessibility");
const TCHAR c_szSecChangeSettings[] = TEXT("SecChangeSettings");
const TCHAR c_szSecAddSites[]       = TEXT("SecAddSites");
const TCHAR c_szProfiles[]          = TEXT("Profiles");
const TCHAR c_szFormSuggest[]       = TEXT("FormSuggest");
const TCHAR c_szFormPasswords[]     = TEXT("FormSuggest Passwords");
#ifdef WALLET
const TCHAR c_szWallet[]            = TEXT("Wallet");
#endif
const TCHAR c_szConnectionWizard[]  = TEXT("Connwiz Admin Lock");
const TCHAR c_szCalContact[]        = TEXT("CalendarContact");             // used to be CalContact
const TCHAR c_szAdvanced[]          = TEXT("Advanced");
const TCHAR c_szSettings[]          = TEXT("Settings");
const TCHAR c_szPrivacySettings[]   = TEXT("Privacy Settings");

#if 0       // obsolete keys
const TCHAR c_szMultimedia[]     = TEXT("Multimedia");
const TCHAR c_szToolbar[]        = TEXT("Toolbar");       
const TCHAR c_szActiveX[]        = TEXT("ActiveX");       
const TCHAR c_szActiveDownload[] = TEXT("ActiveDownload");
const TCHAR c_szActiveControls[] = TEXT("ActiveControls");
const TCHAR c_szActiveScript[]   = TEXT("ActiveScript");  
const TCHAR c_szActiveJava[]     = TEXT("ActiveJava");    
const TCHAR c_szActiveSafety[]   = TEXT("ActiveSafety");  
const TCHAR c_szWarnings[]       = TEXT("Warnings");      
const TCHAR c_szOther[]          = TEXT("Other");         
const TCHAR c_szCrypto[]         = TEXT("Crypto");        
const TCHAR c_szFileTypes[]      = TEXT("FileTypes");     
#endif

// end ui restrictions stuff 

#ifdef REPLACE_PROPSHEET_TEMPLATE
// Used for modifying propsheet template
const TCHAR c_szComctl[] = TEXT("comctl32.dll");
#define DLG_PROPSHEET 1006 // Bad hack...assumes comctl's res id

typedef struct 
{
    int inumLang;
    WORD wLang;
} ENUMLANGDATA;

//
// EnumResLangProc
//
// purpose: a callback function for EnumResourceLanguages().
//          look into the type passed in and if it is RT_DIALOG
//          copy the lang of the first resource to our buffer 
//          this also counts # of lang if more than one of them 
//          are passed in
//
// IN:      lparam: ENUMLANGDATA - defined at the top of this file
//
BOOL CALLBACK EnumResLangProc(HINSTANCE hinst, LPCTSTR lpszType, LPCTSTR lpszName, WORD wIdLang, LPARAM lparam)
{
    ENUMLANGDATA *pel = (ENUMLANGDATA *)lparam;

    ASSERT(pel);

    if (lpszType == RT_DIALOG)
    {
        if (pel->inumLang == 0)
            pel->wLang = wIdLang;

        pel->inumLang++;
    }
    return TRUE;   // continue until we get all langs...
}

//
// GetDialogLang
//
// purpose: fill out the ENUMLANGDATA (see top of this file) with the
//          # of available langs in the module passed in, and the langid
//          of what system enumerates first. i.e, the langid eq. to what
//          the module localized if the module is localized in single 
//          language
//
// IN:      hinstCpl - this is supposed to be a instance handle of inetcpl.
//          pel - a pointer to the buffer we fill out
//
// RESULT:  TRUE  - everything cool, continue with adjusting property sheet
//          FALSE - somethings wrong, abort adjusting property sheet.
//
BOOL GetDialogLang(HMODULE hinstCpl, ENUMLANGDATA *pel)
{
    ASSERT(pel);
    OSVERSIONINFOA osvi;

    // Determine which version of NT or Windows we're running on
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionExA(&osvi);

    // Get the possible languages the template localized in.
    if (VER_PLATFORM_WIN32_NT == osvi.dwPlatformId)
        EnumResourceLanguages(hinstCpl, RT_DIALOG, MAKEINTRESOURCE(IDD_GENERAL), EnumResLangProc, (LPARAM)pel);
    else    
        EnumResourceLanguagesA(hinstCpl, (LPSTR)RT_DIALOG, MAKEINTRESOURCEA(IDD_GENERAL), (ENUMRESLANGPROCA)EnumResLangProc, (LPARAM)pel);

    return TRUE;
}
//
// PropSheetProc
//
// purpose: the callback function to modify resource template
//          in order to make DLG_PROPSHEET's lang mathed with ours.
//          there could be a general way but for now this is
//          an ugly hack from inetcpl.
//
//
int CALLBACK PropSheetProc (HWND hwndDlg, UINT uMsg, LPARAM lParam)
{
    LPVOID pTemplate = (LPVOID)lParam;
    LPVOID pTmpInLang = NULL;
    ENUMLANGDATA el = {0,0};
    HINSTANCE hComctl;
    HRSRC hrsrc;
    HGLOBAL hgmem;
    DWORD cbNewTmp;

    // Comm ctrl gives us a chance to recreate resource by this msg.
    if (uMsg==PSCB_PRECREATE && pTemplate)
    {
        // enumrate any possible language used in this cpl for dialogs
        if (!GetDialogLang(ghInstance, &el))
            return 0; // failed to get resouce name

        if (el.inumLang > 1)
        {
            // we've got multi-language templates
            // let comctl load the one that matches our thread langid.
            return 0;
        }
        if (GetSystemDefaultLangID() != el.wLang)
        {
            // Get comctl32's module handle
            hComctl = GetModuleHandle(c_szComctl);
            if (hComctl)
            {
                // this is a horrible hack because we assume DLG_PROPSHEET
                hrsrc = FindResourceExA(hComctl, (LPSTR)RT_DIALOG, MAKEINTRESOURCEA(DLG_PROPSHEET), el.wLang);
                if (hrsrc)
                {
                    if (hgmem = LoadResource(hComctl, hrsrc))
                    {
                        pTmpInLang = LockResource(hgmem);
                    } 
                    if (pTmpInLang)
                    {
                        cbNewTmp = SizeofResource(hComctl, hrsrc);
                        hmemcpy(pTemplate, pTmpInLang, cbNewTmp);
                    }    
                    if (hgmem && pTmpInLang)
                    {
                        UnlockResource(hgmem);
                        return 1; // everything went ok.
                    }
                }
            }
        }
    }
    return 0;
}
#endif // REPLACE_PROPSHEET_TEMPLATE

void ResWinHelp( HWND hwnd, int ids, int id2, DWORD_PTR dwp)
{
    TCHAR szSmallBuf[SMALL_BUF_LEN+1];
    SHWinHelpOnDemandWrap((HWND)hwnd, LoadSz(ids,szSmallBuf,sizeof(szSmallBuf)),
            id2, (DWORD_PTR)dwp);
}

/*******************************************************************

NAME:       _AddPropSheetPage

SYNOPSIS:   Adds a property sheet page to a property sheet
header's array of property sheet pages.

********************************************************************/
BOOL CALLBACK _AddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    BOOL bResult;
    LPPROPSHEETHEADER ppsh = (LPPROPSHEETHEADER)lParam;

    bResult = (ppsh->nPages < MAX_NUM_OPTION_PAGES);

    if (bResult)
        ppsh->phpage[ppsh->nPages++] = hpage;

    return(bResult);
}

// hunts down all windows and notifies them that they should update themselves
// a-msadek; Use SendMessage instead of PostMessage to work around a syncronization problem causing the system to
// hang when changing security settings
void UpdateAllWindows()
{
    SendMessage(g_hwndUpdate, INM_UPDATE, 0, 0);
    // PostMessage(g_hwndUpdate, INM_UPDATE, 0, 0);
}



// walk the window list and post a message to it telling the windows to
// update (borrowed from MSHTML and slightly modified)
void WINAPI MSHTMLNotifyAllRefresh()
{
    TCHAR szClassName[32];
    TCHAR *Hidden_achClassName;
    HWND hwnd = GetTopWindow(GetDesktopWindow());

    //
    // FEATURE: These should be gotten from some place that is public
    //         to both MSHTML and INETCPL.
    //
    Hidden_achClassName = TEXT("Internet Explorer_Hidden");
#define WM_DO_UPDATEALL     WM_USER + 338

    while (hwnd) {
        GetClassName(hwnd, szClassName, ARRAYSIZE(szClassName));

        // is this our hidden window?
        if (!StrCmpI(szClassName, Hidden_achClassName))
        {
            // yes...  post it a message..
            PostMessage(hwnd, WM_DO_UPDATEALL, 0, g_fSecurityChanged );
        }

        hwnd = GetNextWindow(hwnd, GW_HWNDNEXT);
    }

    //
    // Notify top level windows that registry changed.
    // Defview monitors this message to update the listview
    // font underline settings on the fly.
    //
    SendBroadcastMessage(WM_WININICHANGE, SPI_GETICONTITLELOGFONT, (LPARAM)REGSTR_PATH_IEXPLORER);

    g_fSecurityChanged = FALSE;
}

// this window's sole purpose is to collect all the posted messages
// saying that we should update everything and collapse it down so that
// we only do it once
LRESULT WINAPI UpdateWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    MSG msg;

    switch(uMsg) {
        case WM_DESTROY:
            g_hwndUpdate = NULL;
            // update everything as needed.. remove all messages
            if (PeekMessage(&msg, hwnd, 0, 0, PM_REMOVE)) {
                MSHTMLNotifyAllRefresh();
                SetWindowLongPtr(hwnd, GWLP_WNDPROC, (LONG_PTR)pfnStaticWndProc);
            }
            // since EXPLORER.EXE can hang on to us for a long while
            // we should bail as many of these as we possibly can.
            if (g_hinstWinInet)
            {
                FreeLibrary(g_hinstWinInet);
                g_hinstWinInet = NULL;
            }

            if (g_hinstRatings)
            {
                FreeLibrary(g_hinstRatings);
                g_hinstRatings = NULL;
            }

            if (g_hinstUrlMon)
            {
                FreeLibrary(g_hinstUrlMon);
                g_hinstUrlMon = NULL;
            }

            if (g_hinstMSHTML)
            {
                FreeLibrary(g_hinstMSHTML);
                g_hinstMSHTML = NULL;
            }
            if (hOLE32)
            {
                FreeLibrary(hOLE32);
                hOLE32 = NULL;
            }
            if (g_hinstShdocvw)
            {
                FreeLibrary(g_hinstShdocvw);
                g_hinstShdocvw = NULL;
            }
            if (g_hinstCrypt32)
            {
                FreeLibrary(g_hinstCrypt32);
                g_hinstCrypt32 = NULL;
            }
                        
                        
            break;

        case INM_UPDATE:
            // remove any other posted messages of this type
            while( PeekMessage(&msg, hwnd, INM_UPDATE, INM_UPDATE, PM_REMOVE))
            {
            }
            MSHTMLNotifyAllRefresh();
            break;

        default:
            return CallWindowProc(pfnStaticWndProc, hwnd, uMsg, wParam, lParam);
    }
    return 0L;
}

// this creates our private message window that we use to collapse notifies
// of updates
void CreatePrivateWindow(HWND hDlg)
{
    // Don't allow creation of more than one Private Window per Instance
    if(g_hwndUpdate) { 
        return;
    }

    g_hwndUpdate = CreateWindow(TEXT("static"), NULL, WS_OVERLAPPED, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT,
                                NULL, NULL, ghInstance, NULL);
    if (g_hwndUpdate) {
        // subclass it
        pfnStaticWndProc = (WNDPROC) GetWindowLongPtr(g_hwndUpdate, GWLP_WNDPROC);
        SetWindowLongPtr(g_hwndUpdate, GWLP_WNDPROC, (LONG_PTR)UpdateWndProc);
    }
}


BOOL IsRestricted( HKEY hkey, const TCHAR * pszValue )
{
    LONG  lResult;
    DWORD lSize;
    DWORD  lValue;

    lValue = 0; // clear it
    lSize = sizeof(lValue);
    lResult = RegQueryValueEx( hkey, pszValue, NULL, NULL, (LPBYTE)&lValue, &lSize );
    if( ERROR_SUCCESS != lResult )
        return FALSE;

    return (0 != lValue);
}
void GetRestrictFlags( RESTRICT_FLAGS *pRestrict )
{
    LONG lResult;
    HKEY hkey;
    // key is wrong!
    lResult = RegOpenKeyEx( HKEY_CURRENT_USER, c_szKeyRestrict, (DWORD)0, KEY_READ, &hkey );
    if( ERROR_SUCCESS != lResult )
    {
        return;
    }

#if 0
    pRestrict->fMultimedia    = IsRestricted( hkey, c_szMultimedia     );
    pRestrict->fToolbar       = IsRestricted( hkey, c_szToolbar        );
    pRestrict->fFileTypes     = IsRestricted( hkey, c_szFileTypes      );
    pRestrict->fActiveX       = IsRestricted( hkey, c_szActiveX        );
    pRestrict->fActiveDownload= IsRestricted( hkey, c_szActiveDownload );
    pRestrict->fActiveControls= IsRestricted( hkey, c_szActiveControls );
    pRestrict->fActiveScript  = IsRestricted( hkey, c_szActiveScript   );
    pRestrict->fActiveJava    = IsRestricted( hkey, c_szActiveJava     );
    pRestrict->fActiveSafety  = IsRestricted( hkey, c_szActiveSafety   );
    pRestrict->fWarnings      = IsRestricted( hkey, c_szWarnings       );
    pRestrict->fOther         = IsRestricted( hkey, c_szOther          );
    pRestrict->fCrypto        = IsRestricted( hkey, c_szCrypto         );
#endif
    
    pRestrict->fGeneralTab    = IsRestricted( hkey, c_szGeneralTab     );
    pRestrict->fSecurityTab   = IsRestricted( hkey, c_szSecurityTab    );
    pRestrict->fContentTab    = IsRestricted( hkey, c_szContentTab     );
    pRestrict->fConnectionsTab= IsRestricted( hkey, c_szConnectionsTab );
    pRestrict->fProgramsTab   = IsRestricted( hkey, c_szProgramsTab    );
    pRestrict->fAdvancedTab   = IsRestricted( hkey, c_szAdvancedTab    );
    pRestrict->fPrivacyTab    = IsRestricted( hkey, c_szPrivacyTab     );
    pRestrict->fColors        = IsRestricted( hkey, c_szColors         );
    pRestrict->fLinks         = IsRestricted( hkey, c_szLinks          );
    pRestrict->fFonts         = IsRestricted( hkey, c_szFonts          );
    pRestrict->fInternational = IsRestricted( hkey, c_szInternational  );
    pRestrict->fDialing       = IsRestricted( hkey, c_szDialing        );
    pRestrict->fProxy         = IsRestricted( hkey, c_szProxy          );
    pRestrict->fPlaces        = IsRestricted( hkey, c_szPlaces         );
    pRestrict->fHistory       = IsRestricted( hkey, c_szHistory        );
    pRestrict->fMailNews      = IsRestricted( hkey, c_szMailNews       );
    pRestrict->fRatings       = IsRestricted( hkey, c_szRatings        );
    pRestrict->fCertif        = IsRestricted( hkey, c_szCertif         );
    pRestrict->fCertifPers    = IsRestricted( hkey, c_szCertifPers     );
    pRestrict->fCertifSite    = IsRestricted( hkey, c_szCertifSite     );
    pRestrict->fCertifPub     = IsRestricted( hkey, c_szCertifPub      );
    pRestrict->fCache         = IsRestricted( hkey, c_szCache          );
    pRestrict->fAutoConfig    = IsRestricted( hkey, c_szAutoConfig     );
    pRestrict->fAccessibility = IsRestricted( hkey, c_szAccessibility  );
    pRestrict->fSecChangeSettings = IsRestricted( hkey, c_szSecChangeSettings );
    pRestrict->fSecAddSites   = IsRestricted( hkey, c_szSecAddSites    );
    pRestrict->fProfiles      = IsRestricted( hkey, c_szProfiles       );
    pRestrict->fFormSuggest   = IsRestricted( hkey, c_szFormSuggest    );
    pRestrict->fFormPasswords = IsRestricted( hkey, c_szFormPasswords  );
#ifdef WALLET
    pRestrict->fWallet        = IsRestricted( hkey, c_szWallet         );
#endif
    pRestrict->fConnectionWizard = IsRestricted( hkey, c_szConnectionWizard );
    pRestrict->fCalContact    = IsRestricted( hkey, c_szCalContact     );
    pRestrict->fAdvanced      = IsRestricted( hkey, c_szAdvanced       );
    pRestrict->fCacheReadOnly = IsRestricted( hkey, c_szSettings       );
    pRestrict->fResetWebSettings = IsRestricted( hkey, c_szResetWebSettings );
    pRestrict->fDefault       = IsRestricted( hkey, c_szDefault        );
    pRestrict->fPrivacySettings = IsRestricted( hkey, c_szPrivacySettings );
    
    RegCloseKey( hkey );        

}

// this sets up any globals that need to be init'ed before the prop sheets come up
void PreInitPropSheets(HWND hDlg)
{
    INITCOMMONCONTROLSEX icex;

    //
    // initialize the ieak restrictions data
    //
    GetRestrictFlags(&g_restrict);

    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_USEREX_CLASSES|ICC_NATIVEFNTCTL_CLASS;
    InitCommonControlsEx(&icex);
    CreatePrivateWindow(hDlg);
}


/*******************************************************************

NAME:       AddInternetPropertySheetsEx

SYNOPSIS:   Adds the Internet property sheets through a provided
callback function.  Allows caller to specify common
parent reference count pointer and common callback
function for those property sheets.

********************************************************************/
STDAPI AddInternetPropertySheetsEx(LPFNADDPROPSHEETPAGE pfnAddPage,
                                   LPARAM lparam, PUINT pucRefCount,
                                   LPFNPSPCALLBACK pfnCallback,
                                   LPIEPROPPAGEINFO piepi)
{
    HRESULT hr = S_OK;
    PROPSHEETPAGE* ppsPage;
    int nPageIndex;
    LPPROPSHEETHEADER ppsh = (LPPROPSHEETHEADER)lparam;

    PreInitPropSheets(NULL);

    // if REPLACE_PROPSHEET_TEMPLATE is defined, then this
    // callback will call another proc
    // this is to modify a resource template so we can use 
    // the resource in matched language for property sheet
    g_PropSheetCallback2 = NULL;
    if (ppsh)
    {
        if (!(ppsh->dwFlags & PSH_USECALLBACK))
        {
            ppsh->dwFlags |= PSH_USECALLBACK;
        }
        else
        {
            g_PropSheetCallback2 = ppsh->pfnCallback;
        }
        ppsh->pfnCallback = PropSheetCallback;
    }

    if (piepi->pszCurrentURL)
    {
#ifdef UNICODE
        SHAnsiToUnicode(piepi->pszCurrentURL, g_szCurrentURL, ARRAYSIZE(g_szCurrentURL));
#else
        StrCpyN(g_szCurrentURL, piepi->pszCurrentURL, ARRAYSIZE(g_szCurrentURL));
#endif
    }
    else
        g_szCurrentURL[0] = 0;

    // fill out common data property sheet page struct

    hr = E_OUTOFMEMORY;
    ppsPage = Whistler_CreatePropSheetPageStruct(MLGetHinst()); // Get the right version
    if (ppsPage)
    {
        if (pucRefCount)
        {
            ppsPage->pcRefParent = pucRefCount;
            ppsPage->dwFlags |= PSP_USEREFPARENT;
        }
        if (pfnCallback)
        {
            ppsPage->pfnCallback = pfnCallback;
            ppsPage->dwFlags |= PSP_USECALLBACK;
        }

        // if old IE30 users specify the old security page, then we'll show the new security page and the content page
        if (piepi->dwFlags & INET_PAGE_SECURITY_OLD)
            piepi->dwFlags |= INET_PAGE_SECURITY | INET_PAGE_CONTENT;

        // create a property sheet page for each page
        for (nPageIndex = 0; nPageIndex < ARRAYSIZE(c_PropInfo); nPageIndex++)
        {
            if (c_PropInfo[nPageIndex].dwPageFlag & piepi->dwFlags &&
                IsPropPageEnabled(nPageIndex))
            {
                HPROPSHEETPAGE hpage;

                ppsPage->pfnDlgProc  = c_PropInfo[nPageIndex].pfnDlgProc;
                ppsPage->pszTemplate = MAKEINTRESOURCE(c_PropInfo[nPageIndex].idRes);

                // set a pointer to the PAGEINFO struct as the private data for this page
                ppsPage->lParam = (LPARAM)nPageIndex;

                hpage = CreatePropertySheetPage((LPCPROPSHEETPAGE)ppsPage);

                if (hpage)
                {
                    if (pfnAddPage(hpage, lparam))
                        hr = S_OK;
                    else
                    {
                        DestroyPropertySheetPage(hpage);
                        hr = E_FAIL;
                    }
                }
                else
                    hr = E_OUTOFMEMORY;

                if (hr != S_OK)
                    break;
            }
        }

        LocalFree(ppsPage);
    }

    // this must be done after the pre-init prop sheet which has first
    // crack at initializing g_restrict
    if (piepi->cbSize == sizeof(IEPROPPAGEINFO))
    {
        //
        // blast in the new settings
        //
        if (piepi->dwRestrictMask & (R_MULTIMEDIA | R_WARNINGS | R_CRYPTOGRAPHY | R_ADVANCED))
            g_restrict.fAdvanced = (piepi->dwRestrictFlags & (R_MULTIMEDIA | R_WARNINGS | R_CRYPTOGRAPHY | R_ADVANCED));

        if (piepi->dwRestrictMask & R_DIALING)
            g_restrict.fDialing    = (piepi->dwRestrictFlags & R_DIALING);

        if (piepi->dwRestrictMask & R_PROXYSERVER)        
            g_restrict.fProxy      = (piepi->dwRestrictFlags & R_PROXYSERVER);

        if (piepi->dwRestrictMask & R_CUSTOMIZE)       
            g_restrict.fPlaces     = (piepi->dwRestrictFlags & R_CUSTOMIZE);

        if (piepi->dwRestrictMask & R_HISTORY)
            g_restrict.fHistory    = (piepi->dwRestrictFlags & R_HISTORY);

        if (piepi->dwRestrictMask & R_MAILANDNEWS)
            g_restrict.fMailNews   = (piepi->dwRestrictFlags & R_MAILANDNEWS);

        if (piepi->dwRestrictMask & R_CHECKBROWSER )
            g_restrict.fDefault = (piepi->dwRestrictFlags & R_CHECKBROWSER);

        if (piepi->dwRestrictMask & R_COLORS)
            g_restrict.fColors  = (piepi->dwRestrictFlags & R_COLORS);

        if (piepi->dwRestrictMask & R_LINKS)
            g_restrict.fLinks    = (piepi->dwRestrictFlags & R_LINKS);

        if (piepi->dwRestrictMask & R_FONTS)        
            g_restrict.fFonts      = (piepi->dwRestrictFlags & R_FONTS);

        if (piepi->dwRestrictMask & R_RATINGS)       
            g_restrict.fRatings     = (piepi->dwRestrictFlags & R_RATINGS);

        if (piepi->dwRestrictMask & R_CERTIFICATES) {
            g_restrict.fCertif    = (piepi->dwRestrictFlags & R_CERTIFICATES);
            g_restrict.fCertifPers = g_restrict.fCertif;
            g_restrict.fCertifSite = g_restrict.fCertif;
            g_restrict.fCertifPub  = g_restrict.fCertif;
        }
        
        if (piepi->dwRestrictMask & (R_ACTIVECONTENT | R_SECURITY_CHANGE_SETTINGS))
            g_restrict.fSecChangeSettings   = (piepi->dwRestrictFlags & (R_ACTIVECONTENT | R_SECURITY_CHANGE_SETTINGS ));

        if (piepi->dwRestrictMask & (R_ACTIVECONTENT | R_SECURITY_CHANGE_SITES))
            g_restrict.fSecAddSites = (piepi->dwRestrictFlags & (R_ACTIVECONTENT | R_SECURITY_CHANGE_SITES));

        if (piepi->dwRestrictMask & R_CACHE)
            g_restrict.fCache  = (piepi->dwRestrictFlags & R_CACHE);

        if (piepi->dwRestrictMask & R_LANGUAGES )
            g_restrict.fInternational  = (piepi->dwRestrictFlags & R_LANGUAGES );
        
        if (piepi->dwRestrictMask & R_ACCESSIBILITY )
            g_restrict.fAccessibility = (piepi->dwRestrictFlags & R_ACCESSIBILITY);
        
        if (piepi->dwRestrictMask & R_PROFILES)
        {
            g_restrict.fFormSuggest=    // piggyback on "profile assistant" restriction
            g_restrict.fProfiles   = (piepi->dwRestrictFlags & R_PROFILES);
        }
        
#ifdef WALLET
        if (piepi->dwRestrictMask & R_WALLET)
            g_restrict.fWallet  = (piepi->dwRestrictFlags & R_WALLET);
#endif
        
        if (piepi->dwRestrictMask & R_CONNECTION_WIZARD)
            g_restrict.fConnectionWizard  = (piepi->dwRestrictFlags & R_CONNECTION_WIZARD);
        
        if (piepi->dwRestrictMask & R_AUTOCONFIG)
            g_restrict.fAutoConfig  = (piepi->dwRestrictFlags & R_AUTOCONFIG);
        
        if (piepi->dwRestrictMask & R_CAL_CONTACT)
            g_restrict.fCalContact  = (piepi->dwRestrictFlags & R_CAL_CONTACT);
        
        if (piepi->dwRestrictMask & R_ADVANCED)
            g_restrict.fAdvanced  = (piepi->dwRestrictFlags & R_ADVANCED);

        }

    return(hr);
}

STDAPI AddInternetPropertySheets(LPFNADDPROPSHEETPAGE pfnAddPage,
                                 LPARAM lparam, PUINT pucRefCount,
                                 LPFNPSPCALLBACK pfnCallback)
{
    IEPROPPAGEINFO iepi;

    iepi.cbSize = sizeof(iepi);
    iepi.pszCurrentURL = NULL;

    // if not loaded, try to load
    if (!g_hinstMSHTML)
        g_hinstMSHTML = LoadLibrary(c_tszMSHTMLDLL);

    // if MSHTML found, then do the standard INETCPL
    if (g_hinstMSHTML)
    {
        iepi.dwFlags = (DWORD)-1;
        iepi.dwRestrictFlags = (DWORD)0;
        iepi.dwRestrictMask  = (DWORD)0;
    }
    else
    {
        // adjust these flags for the "special" inetcpl for the office guys.
        iepi.dwFlags = (DWORD) 
                       INET_PAGE_CONNECTION | INET_PAGE_PROGRAMS
                       | INET_PAGE_SECURITY | INET_PAGE_ADVANCED;
        iepi.dwRestrictFlags = (DWORD)
                               R_HISTORY | R_OTHER | R_CHECKBROWSER;
        iepi.dwRestrictMask  = (DWORD)
                               R_HISTORY | R_OTHER | R_CHECKBROWSER;
    }

    return AddInternetPropertySheetsEx(pfnAddPage, lparam, pucRefCount, pfnCallback, &iepi);
}

void DestroyPropertySheets(LPPROPSHEETHEADER ppsHeader)
{
    UINT nFreeIndex;

    for (nFreeIndex = 0; nFreeIndex < ppsHeader->nPages; nFreeIndex++)
        DestroyPropertySheetPage(ppsHeader->phpage[nFreeIndex]);

}




/*******************************************************************

NAME:       LaunchInternetControlPanel

SYNOPSIS:   Runs the Internet control panel.


WARNING:  This needs to be as bare bones as possible.
the pages are also added in from the internet (iShellFolder)
property page extension which means it doesn't come into this
code.  if you do any initialization/destruction here,
it won't get called on all cases.

********************************************************************/
STDAPI_(BOOL) LaunchInternetControlPanelAtPage(HWND hDlg, UINT nStartPage)
{
    HPROPSHEETPAGE hOptPage[ MAX_NUM_OPTION_PAGES ];  // array to hold handles to pages
    PROPSHEETHEADER     psHeader;
    BOOL fRet;
    HPSXA hpsxa;
    HRESULT hrOle = SHCoInitialize();
    // OLE Needs to be initialized for AutoComplete and the FTP URL association.

    // Don't need to test for nStartPage < 0 since UINTs are never negative
    if (nStartPage != DEFAULT_CPL_PAGE &&
       (nStartPage >= ARRAYSIZE(c_PropInfo)))
    {
        nStartPage = DEFAULT_CPL_PAGE;
    }
    
    //
    // initialize the ieak restrictions data
    //
    GetRestrictFlags(&g_restrict);

    //
    // The caller will pass DEFAULT_CPL_PAGE for nStartPage when it doesn't care
    // which tab should be displayed first.  In this case, we just
    // display the first tab that's not disabled via IEAK
    //
    if (DEFAULT_CPL_PAGE == nStartPage)
    {
        int iPage;

        for (iPage=0; iPage<ARRAYSIZE(c_PropInfo); iPage++)
        {
            if (IsPropPageEnabled(iPage))
                break;
        }

        //
        // If the ieak has disabled ALL the pages, then we don't
        // can't display the inetcpl.  Show a message.
        //
        if (iPage == ARRAYSIZE(c_PropInfo))
        {
            MLShellMessageBox(
                hDlg, 
                MAKEINTRESOURCEW(IDS_RESTRICTED_MESSAGE), 
                MAKEINTRESOURCEW(IDS_RESTRICTED_TITLE), 
                MB_OK);
            return FALSE;
        }
        else
        {
            nStartPage = 0;
        }

    }

    //
    // This means the caller has requested that a specific start
    // page for the propsheet
    //
    else
    {
        int iPage;

        //
        // If the caller has requested a specific page, and that 
        // page is disabled due to IEAK restrictions, then don't 
        // display the inetcpl at all.  Show a messagebox.
        //
        if (!IsPropPageEnabled(nStartPage))
        {
            MLShellMessageBox(
                hDlg, 
                MAKEINTRESOURCE(IDS_RESTRICTED_MESSAGE), 
                MAKEINTRESOURCE(IDS_RESTRICTED_TITLE),
                MB_OK);
            return FALSE;

        }

        //
        // Due to IEAK restrictions, there may be one or more pages
        // before nStartPage that are actually missing.  We need to
        // decrement nStartPage to take that into account.
        //
        for (iPage=nStartPage-1; iPage>=0; iPage--)
            if (!IsPropPageEnabled(iPage))
                nStartPage--;

    }


    memset(&psHeader,0,sizeof(psHeader));

    psHeader.dwSize = sizeof(psHeader);
    psHeader.dwFlags = PSH_PROPTITLE;
    psHeader.hwndParent = hDlg;
    psHeader.hInstance = MLGetHinst();
    psHeader.nPages = 0;
    psHeader.nStartPage = nStartPage;
    psHeader.phpage = hOptPage;
    psHeader.pszCaption = MAKEINTRESOURCE(IDS_INTERNET_LOC);

    if (AddInternetPropertySheets(&_AddPropSheetPage, (LPARAM)&psHeader, NULL,
                                  NULL) == S_OK)
    {
        // add any extra pages from hooks in the registry
        if( ( hpsxa = SHCreatePropSheetExtArray( HKEY_LOCAL_MACHINE, 
            REGSTR_PATH_INETCPL_PS_EXTENTIONS, MAX_NUM_OPTION_PAGES - NUM_OPTION_PAGES ) ) != NULL )
        {
            SHAddFromPropSheetExtArray( hpsxa, _AddPropSheetPage, (LPARAM)&psHeader );
        }

        // bring it up
        PropertySheet( &psHeader );

        // free the hooks if we loaded them 
        if ( hpsxa )
            SHDestroyPropSheetExtArray( hpsxa );

        fRet = TRUE;
    }
    else
    {
        DestroyPropertySheets(&psHeader);

        MsgBox(NULL, IDS_ERROutOfMemory, MB_ICONEXCLAMATION, MB_OK);
        fRet = FALSE;
    }

    SHCoUninitialize(hrOle);

    return fRet;
}

STDAPI_(BOOL) LaunchInternetControlPanel(HWND hDlg)
{
    return LaunchInternetControlPanelAtPage(hDlg, DEFAULT_CPL_PAGE);
}

STDAPI_(BOOL) LaunchConnectionDialog(HWND hDlg)
{
    ASSERT(INET_PAGE_CONNECTION == c_PropInfo[4].dwPageFlag);

    return LaunchInternetControlPanelAtPage(hDlg, 4);
}

STDAPI_(BOOL) LaunchPrivacyDialog(HWND hDlg)
{
    ASSERT(INET_PAGE_PRIVACY == c_PropInfo[2].dwPageFlag);
                                            
    return LaunchInternetControlPanelAtPage(hDlg, 2);
}

BOOL ShowAddSitesDialog(HWND hwnd, DWORD dwZone, LPCWSTR pszUrl);

BOOL AddSitesRestricted()
{
    BOOL fRestricted = FALSE;

    GetRestrictFlags(&g_restrict);
    if (/*!g_restrict.fSecurityTab &&*/ !g_restrict.fSecAddSites)
    {
        DWORD dwVal = 0;
        DWORD cbVal = sizeof(dwVal);
        SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_SECURITY_LOCKOUT, REGSTR_VAL_OPTIONS_EDIT, NULL, &dwVal, &cbVal);
        if (0 == dwVal)
        {
            dwVal = 0;
            cbVal = sizeof(dwVal);
            SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_SECURITY_LOCKOUT, REGSTR_VAL_ZONES_MAP_EDIT, NULL, &dwVal, &cbVal);
            fRestricted = (0 != dwVal);
        }
        else
        {
            fRestricted = TRUE;
        }
    }
    else
    {
        fRestricted = TRUE;
    }

    return fRestricted;
}

STDAPI_(BOOL) LaunchAddSitesDialog(HWND hwnd, DWORD dwZone, LPCWSTR pszUrl)
{
    BOOL fRet;

    if (!AddSitesRestricted())
    {
        fRet = ShowAddSitesDialog(hwnd, dwZone, pszUrl);
    }
    else
    {
        MLShellMessageBox(hwnd, MAKEINTRESOURCE(IDS_RESTRICTED_MESSAGE), MAKEINTRESOURCE(IDS_RESTRICTED_TITLE), MB_OK);
        fRet = FALSE;
    }

    return fRet;
}

HRESULT _GetAddSitesDisplayUrl(LPCWSTR pszUrl, LPWSTR pszUrlDisplay, DWORD cchUrlDisplay);

STDAPI_(BOOL) GetAddSitesDisplayUrl(LPCWSTR pszUrl, LPWSTR pszUrlDisplay, DWORD cchUrlDisplay)
{
    return SUCCEEDED(_GetAddSitesDisplayUrl(pszUrl, pszUrlDisplay, cchUrlDisplay));
}


BOOL IsCompatModeProcess()
{
    if (GetModuleHandle(TEXT("IE4.EXE")) || GetModuleHandle(TEXT("IESQRL.EXE")))
    {
        // If we are running in compat mode, exit because we don't want users
        // mucking with control panel from here.
        WinExec("control.exe", SW_NORMAL);
        
        return TRUE;
    }

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\lang.cpp ===
///////////////////////////////////////////////////////////////////////
//                     Microsoft Windows                             //
//              Copyright(c) Microsoft Corp., 1995                   //
///////////////////////////////////////////////////////////////////////
//
// LANG.CPP - "Language" property page for InetCpl
//

// HISTORY:
//
// 1/10/97  beomoh      created
//

#include "inetcplp.h"

#include <tchar.h>
#include <mlang.h>
#include "psapi.h"
#include "tlhelp32.h"
#include "process.h"
#include <mluisupp.h>
#include <shdocvw.h>

#define ARRAYSIZE(a)        (sizeof(a)/sizeof(a[0]))
#define FORMAT_STR          TEXT("%s [%s]")
#define MAX_LIST_STRING_LEN MAX_LOCALE_NAME + MAX_RFC1766_NAME + 3
#define MAX_ACCEPT_LANG_LEN 2048

#define CP_THAI     874
#define CP_ARABIC   1256
#define CP_HEBREW   1255

// used as the return value from setlang dialog
#define RETURN_SETLANG_ENDLANGDIALOG    2
#define RETURN_SETLANG_CLOSEDNORMAL     1
#define RETURN_SETLANG_CANCELED         0

typedef HRESULT (* PCOINIT) (LPVOID);
typedef VOID (* PCOUNINIT) (VOID);
typedef VOID (* PCOMEMFREE) (LPVOID);
typedef HRESULT (* PCOCREINST) (REFCLSID, LPUNKNOWN, DWORD,     REFIID, LPVOID * );

extern HMODULE hOLE32;
extern PCOINIT pCoInitialize;
extern PCOUNINIT pCoUninitialize;
extern PCOMEMFREE pCoTaskMemFree;
extern PCOCREINST pCoCreateInstance;

extern BOOL _StartOLE32();

class CUILangList;
INT_PTR KickSetLang(HWND hDlg, CUILangList * pLangList);

static const TCHAR s_szResourceLocale[] = TEXT("ResourceLocale");
// HKLM\Software\Microsoft\Internet Explorer\International used for url string
static const TCHAR s_szUrlSPK[] 
= TEXT("http://www.microsoft.com/isapi/redir.dll?prd=ie&pver=6&ar=plugui&sba=install");
static const TCHAR c_szInstall[] 
= TEXT("Software\\Microsoft\\Active Setup\\Installed Components\\{89820200-ECBD-11CF-8B85-00AA005B4383}");
static const TCHAR c_szLocale[] = TEXT("Locale");
static const TCHAR s_szLangPackPath[]   = TEXT("Software\\Microsoft\\Internet Explorer");
static const TCHAR s_szVersion[] = TEXT("LPKInstalled");

typedef struct 
{
    WORD wlangid;
    BOOL fValid;
    TCHAR szName[MAX_LOCALE_NAME];
} LANGLIST;

static LANGLIST s_arryLangList[] = 
{
    {0x0409, FALSE, {0}},
    {0x0407, FALSE, {0}},
    {0x0411, FALSE, {0}},
    {0x0412, FALSE, {0}},
    {0x0404, FALSE, {0}},
    {0x0804, FALSE, {0}},
    {0x040c, FALSE, {0}},
    {0x0c0a, FALSE, {0}},
    {0x0416, FALSE, {0}},
    {0x0410, FALSE, {0}},
    {0x0413, FALSE, {0}},
    {0x041d, FALSE, {0}},
    {0x0406, FALSE, {0}},
    {0x040b, FALSE, {0}},
    {0x040e, FALSE, {0}},
    {0x0414, FALSE, {0}},
    {0x0408, FALSE, {0}},
    {0x0415, FALSE, {0}},
    {0x0419, FALSE, {0}},
    {0x0405, FALSE, {0}},
    {0x0816, FALSE, {0}},
    {0x041f, FALSE, {0}},
    {0x041b, FALSE, {0}},
    {0x0424, FALSE, {0}},
    {0x0401, FALSE, {0}},
    {0x040d, FALSE, {0}},
    {0x042d, FALSE, {0}},
    {0x040f, FALSE, {0}},
};

//
//  ISO639 ID table
//
typedef struct tagISO639
{
    LPCTSTR ISO639;
    LANGID LangID;
}   ISO639, *LPISO639;

const ISO639 c_ISO639[] =
{
    { TEXT("EN"), 0x0409 },
    { TEXT("DE"), 0x0407 },
    { TEXT("JA"), 0x0411 },
    { TEXT("KO"), 0x0412 },
    { TEXT("TW"), 0x0404 },
    { TEXT("CN"), 0x0804 },
    { TEXT("FR"), 0x040C },
    { TEXT("ES"), 0x0C0A },
    { TEXT("BR"), 0x0416 },
    { TEXT("IT"), 0x0410 },
    { TEXT("NL"), 0x0413 },
    { TEXT("SV"), 0x041D },
    { TEXT("DA"), 0x0406 },
    { TEXT("FI"), 0x040B },
    { TEXT("HU"), 0x040E },
    { TEXT("NO"), 0x0414 },
    { TEXT("EL"), 0x0408 },
    { TEXT("PL"), 0x0415 },
    { TEXT("RU"), 0x0419 },
    { TEXT("CS"), 0x0405 },
    { TEXT("PT"), 0x0816 },
    { TEXT("TR"), 0x041F },
    { TEXT("SK"), 0x041B },
    { TEXT("SL"), 0x0424 },
    { TEXT("AR"), 0x0401 },
    { TEXT("HE"), 0x040D },
    { TEXT("EU"), 0x042D },
    { TEXT("IS"), 0x040F },
};

// GetInstallLanguage
//
// synopsis - borrowed this function from shlwapi. we can remove this
//            once we have it exported from shlwapi.dll
//
LANGID GetInstallLanguage(void)
{
    static LANGID LangID = 0;
    TCHAR szISO639[3];
    DWORD cb;

    if (0 == LangID)
    {
        cb = sizeof(szISO639);
        if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, c_szInstall, c_szLocale, NULL, szISO639, &cb))
        {
            int i;

            for (i = 0; i < ARRAYSIZE(c_ISO639); i++)
            {
                if (!StrCmpNI(szISO639, c_ISO639[i].ISO639, ARRAYSIZE(szISO639)))
                {
                    LangID = c_ISO639[i].LangID;
                    break;
                }
            }
        }
    }
    return LangID;
}

// CUILangList
// 
// maintains the list of UI languages for user to choose
//
class CUILangList
{
public:
    CUILangList() {_iLangIdx = -1; lang = s_arryLangList; 
                   _nLangList = ARRAYSIZE(s_arryLangList);
                   _fOffice9Installed = -1;};
    
    void    ValidateLangList();
    BOOL    IsValidLang(int idx) { return (idx < _nLangList) ? lang[idx].fValid: FALSE; };
    int     GetCurrentLangIdx();
    void    SetCurrentLangIdx(int idx);
    LPCTSTR GetCurrentLangName();
    LPCTSTR GetLangNameOfIdx(int idx);
    WORD    GetLangIdOfIdx(int idx) { return (idx < _nLangList) ? lang[idx].wlangid:0; };
    UINT    GetIds(int idx); 
    int     GetListSize() {return _nLangList;};
    BOOL    IsOffice9Installed();
    static  HRESULT GetLangList(HWND hdlg, CUILangList ** ppLangList);
    static  HRESULT RemoveLangList(HWND hdlg);
private:
    int _iLangIdx;
    int _nLangList;
    int _fOffice9Installed;
    LANGLIST *lang;
};

// CShutDownProcInfo
// 
// manages information about processes we want
// to shutdown/restart.
//
typedef enum 
{
    PS_UNKNOWN=0, 
    PS_CANDIDATE, 
    PS_TO_BE_SHUTDOWN, 
    PS_IGNORE, 
    PS_SHUTDOWN_OK, 
    PS_WAITING, 
    PS_TO_BE_SHUTDOWN_WITH_NO_RELAUNCH, 
    PS_SHUTDOWN_OK_NO_RELAUNCH_NEEDED, 
} PROCSTATE; 

class CShutDownProcInfo : public CProcessInfo
{
public:
    CShutDownProcInfo(HWND hdlgParent);
    ~CShutDownProcInfo();
    HRESULT EnsureProcList();
    HRESULT IncreaseProcList();
    HRESULT NotifyShutDownToFolks(int *nProccess);
    HRESULT AddToProcList(HWND hwndShutDown);
    HRESULT WaitForOneProcess(int iProc);
    HRESULT WaitForFolksShutDown();
    HRESULT GetRestartAppPath(LPTSTR szPath, int cchPath, int iProc);
    HRESULT RestartFolks();
    static DWORD CALLBACK ShutDownThreadProc(void *pv);
protected:
    typedef struct
    {
        DWORD dwPID;
        TCHAR szExeName[32];
        PROCSTATE State; 
    } PROCLIST;
    PROCLIST *_pProcList;
    int _nAlloced;
    int _iProcList;
    HWND _hdlgParent;
    BOOL _fAllShutDown;
};
// this always fills '0' to empty digits
// caller has to make sure sz has cdigit+1 of buffer
void IntToHex(OUT LPTSTR sz, IN int cdigit, IN int value)
{
    int i, idigit;

    if (sz && value > 0 && cdigit > 0)
    {
        // nul terminate the buffer
        sz[cdigit] = TEXT('\0');
        
        for (i = cdigit-1; i >= 0; i--, value /= 16)
        {
            idigit = value%16;
            if (idigit < 10)
                sz[i] = (TCHAR)idigit + TEXT('0');
            else 
                sz[i] = (TCHAR)idigit - 10 + TEXT('A');
        }
    }
} 

// set valid flags for the lang list
// very expensive so expects to be called only once in a session
// from CUILangList::GetLangList
//
#define MAX_SATELLITEPACKS 30 // 30 must be a practical number for satellite packs
void CUILangList::ValidateLangList()
{
    HKEY hKey;
    HRESULT hr;
    TCHAR szValueName[32];
    WORD aryValidLang[MAX_SATELLITEPACKS +1+1] = {0}; // +1 for install lang, 
                                                      // +1 for terminator

    int  nMaxValidLang = ARRAYSIZE(aryValidLang)-1;   // -1 for terminator
    WORD *pwValid = aryValidLang;
    
    // make the install language always valid
    *pwValid = GetInstallLanguage();
    if (*pwValid != 0)
    {
       *(pwValid+1) = 0; // terminator
       pwValid++;
       nMaxValidLang--;
    }

    if (ERROR_SUCCESS == 
    RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_INTERNATIONAL, NULL, KEY_READ, &hKey))
    {
        int i = 0;
        do {
            // see if the value has a match in the list
            DWORD dwType;
            DWORD cb = ARRAYSIZE(szValueName)-2;

            hr = SHEnumValue(hKey, i++, szValueName+2, &cb, &dwType, NULL, NULL);
            if (SUCCEEDED(hr) && dwType == REG_SZ)
            {
                UINT uiInstalled ;

                szValueName[0] = TEXT('0');
                szValueName[1] = TEXT('x');
                StrToIntEx(szValueName, STIF_SUPPORT_HEX, (LPINT)&uiInstalled);
                if (uiInstalled > 0)
                {
                    *pwValid     = (unsigned short) uiInstalled;
                    *(pwValid+1) = 0; // terminator
                    pwValid++;
                }
            }
        } while(hr == ERROR_SUCCESS && i < nMaxValidLang);
        RegCloseKey(hKey);
    }

    // this assumes we can use StrChrW to search a value in 
    // a word array, it also assumes we never have 0 as a langid
    //
    Assert(sizeof(WORD) == sizeof(WCHAR)); // unix?

    int nValidLang = (int)(pwValid-aryValidLang);
    for(int idx = 0; idx < GetListSize(); idx++ )
    {
        // abusing the string function but this is a fast way
        if (StrChrW((WCHAR *)aryValidLang, (WCHAR)lang[idx].wlangid))
        {
            lang[idx].fValid = TRUE;
            if(--nValidLang <= 0)
                break;
        }
    }
}

static const TCHAR s_szPropLangList[] = TEXT("langlist");
HRESULT CUILangList::GetLangList(HWND hdlg, CUILangList ** ppLangList)
{
    HRESULT hr=S_OK;
    
    CUILangList *pLangList = (CUILangList *)GetProp(hdlg, s_szPropLangList);
    if (!pLangList)
    {
        pLangList = new CUILangList();
        if (pLangList)
        {
            pLangList->ValidateLangList();
            SetProp(hdlg, s_szPropLangList, (HANDLE)pLangList);
        }
        else
            hr = E_FAIL;
    }
    
    ASSERT(ppLangList);
    if (ppLangList)
        *ppLangList = pLangList;
    
    return hr;
}

HRESULT CUILangList::RemoveLangList(HWND hdlg)
{
    HRESULT hr = S_OK;
    CUILangList *pLangList = (CUILangList *)GetProp(hdlg, s_szPropLangList);

    if (pLangList)
    {
        delete pLangList;
        RemoveProp(hdlg, s_szPropLangList);    
    }
    else
        hr = S_FALSE;

    return hr;
}

void CUILangList::SetCurrentLangIdx(int idx)
{
    TCHAR sz[4+1];
    if (idx != _iLangIdx)
    {
        // the resource id is always 4 digit
        IntToHex(sz, 4, lang[idx].wlangid);
        SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_INTERNATIONAL, 
                   s_szResourceLocale, REG_SZ, (void *)sz, sizeof(sz));
        _iLangIdx = idx;
    }
}
// returns idx to the lang array
int CUILangList::GetCurrentLangIdx()
{
    // show the current selection
    TCHAR sz[64];
    DWORD dwType;
    int   isel;
    
    // see if it's cached already
    if (_iLangIdx == -1)
    {
        // We basically wants what we've set in the registry,
        // but if Office9 is installed we'll show whatever
        // Office sets, and we can't change the Office setting anyway
        // MLGetUILanguage returns Office's setting if its there
        // Also I suppose we want to show NT5's UI language here
        //
        if (IsOffice9Installed() || IsOS(OS_WIN2000ORGREATER))
            isel = INETCPL_GetUILanguage();
        else
        {
            DWORD dwcbData = sizeof(sz);

            HRESULT hr =  SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_INTERNATIONAL, 
                                  s_szResourceLocale, &dwType, (void *)&sz[2], &dwcbData);
                   
            if (hr == ERROR_SUCCESS && dwType == REG_SZ)
            {
                sz[0] = TEXT('0');
                sz[1] = TEXT('x');
                StrToIntEx(sz, STIF_SUPPORT_HEX, (LPINT)&isel);
            }
            else
            {
                isel = GetInstallLanguage();
            }
        }
        
        for(int i = 0; i < GetListSize(); i++ )
        {
            if (isel == lang[i].wlangid)
            {
                _iLangIdx = i;
                break;
            }
        }
            
        // english for error case
        if (_iLangIdx < 0) 
            _iLangIdx = 0;
    }
    return _iLangIdx;
}

LPCTSTR CUILangList::GetLangNameOfIdx(int idx)
{
    LPCTSTR pszRet = NULL;
    IMultiLanguage2 *pML2;
    HRESULT hr;
    RFC1766INFO Rfc1766Info={0};

    if(!hOLE32)
    {
        if(!_StartOLE32())
        {
            ASSERT(FALSE);
            return NULL;
        }
    }
    hr = pCoInitialize(NULL);

    if (FAILED(hr))
        return NULL;

    hr = pCoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (LPVOID *) &pML2);

    if (SUCCEEDED(hr))
    {
        if (idx >= 0)
        {
            if (!lang[idx].szName[0])
            {
                pML2->GetRfc1766Info(lang[idx].wlangid, INETCPL_GetUILanguage(), &Rfc1766Info);
                StrCpyNW(lang[idx].szName, Rfc1766Info.wszLocaleName, ARRAYSIZE(lang[0].szName));            
            }
            pszRet = lang[idx].szName;        
        }
        pML2->Release();
    }

    pCoUninitialize();
    return pszRet;
}
 
LPCTSTR CUILangList::GetCurrentLangName()
{
    int idx = GetCurrentLangIdx();
    return GetLangNameOfIdx(idx);
}

BOOL CUILangList::IsOffice9Installed()
{
    DWORD dwVersion;
    DWORD cb = sizeof(dwVersion);
    if (_fOffice9Installed < 0)
    {
        _fOffice9Installed ++;
        if (ERROR_SUCCESS ==
            SHGetValue(HKEY_LOCAL_MACHINE, s_szLangPackPath, s_szVersion, NULL, &dwVersion, &cb)
          && dwVersion > 0) // magic number - christw tells me so
            _fOffice9Installed ++;
    }
    return (BOOL)_fOffice9Installed;
}

void InitCurrentUILang(HWND hDlg)
{
    BOOL fChanged = FALSE;
    CUILangList *pLangList;  
    LPCTSTR pszLangSel = NULL;
    HRESULT hr;
    
    hr = CUILangList::GetLangList(hDlg, &pLangList);
    
    if (SUCCEEDED(hr))
        pszLangSel = pLangList->GetCurrentLangName();
    
    if (pszLangSel)
    {
        TCHAR szBig[1024], szSmall[256];

        GetDlgItemText(hDlg, IDC_LANG_CURSEL, szBig, ARRAYSIZE(szBig));
        if (szBig[0])
            fChanged = (StrStr(szBig, pszLangSel) == NULL); 

        if (MLLoadString((fChanged)? IDS_LANG_FUTUREUSE: IDS_LANG_CURRENTUSE, szSmall, ARRAYSIZE(szSmall)) > 0)
        {
            wnsprintf(szBig, ARRAYSIZE(szBig), szSmall, pszLangSel);
            Static_SetText(GetDlgItem(hDlg, IDC_LANG_CURSEL), szBig);
        }
    }
}


//
// FillAcceptListBox()
//
// Fills the accept language listbox with names of selected language
//
void FillAcceptListBox(IN HWND hDlg)
{
    IMultiLanguage2 *pML2;
    HRESULT hr;
    HKEY hKey;
    DWORD cb;
    TCHAR sz[MAX_LIST_STRING_LEN], szBuf[MAX_ACCEPT_LANG_LEN], *p1, *p2, *p3;
    HWND hwndList = GetDlgItem(hDlg, IDC_LANG_ACCEPT_LIST);

    if(!hOLE32)
    {
        if(!_StartOLE32())
        {
            ASSERT(FALSE);
            return;
        }
    }
    hr = pCoInitialize(NULL);
    if (FAILED(hr))
        return;

    hr = pCoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (LPVOID *) &pML2);
    if (SUCCEEDED(hr))
    {
        if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_INTERNATIONAL, NULL, NULL, NULL, KEY_SET_VALUE|KEY_READ, NULL, &hKey, NULL))
        {
            LCID lcid;
            RFC1766INFO Rfc1766Info;
            TCHAR sz1[MAX_LIST_STRING_LEN], sz2[MAX_RFC1766_NAME];

            cb = sizeof(szBuf);
            if (ERROR_SUCCESS == RegQueryValueEx(hKey, REGSTR_VAL_ACCEPT_LANGUAGE, NULL, NULL, (LPBYTE)szBuf, &cb))
            {
                p1 = p2 = szBuf;
                while (NULL != *p1)
                {
                    WCHAR wsz[MAX_LIST_STRING_LEN];
                    BOOL bEnd = FALSE;

                    while (TEXT(',') != *p2 && NULL != *p2)
                        p2 = CharNext(p2);
                    if (NULL != *p2)
                        *p2 = NULL;
                    else
                        bEnd = TRUE;
                    p3 = p1;
                    while (TEXT(';') != *p3 && NULL != *p3)
                        p3 = CharNext(p3);
                    if (NULL != *p3)
                        *p3 = NULL;
#ifdef UNICODE
                    StrCpyN(wsz, p1, ARRAYSIZE(wsz));
#else
                    MultiByteToWideChar(CP_ACP, 0, p1, -1, wsz, MAX_RFC1766_NAME);
#endif
                    hr = pML2->GetLcidFromRfc1766(&lcid, wsz);
                    if (SUCCEEDED(hr))
                    {
                        hr = pML2->GetRfc1766Info(lcid, INETCPL_GetUILanguage(), &Rfc1766Info);
                        if (SUCCEEDED(hr))
                        {
#ifdef UNICODE
                            StrCpyN(sz1, Rfc1766Info.wszLocaleName, ARRAYSIZE(sz1));
#else
                            WideCharToMultiByte(CP_ACP, 0, Rfc1766Info.wszLocaleName, -1, sz1, MAX_LIST_STRING_LEN, NULL, NULL);
#endif
                            wnsprintf(sz, ARRAYSIZE(sz), FORMAT_STR, sz1, p1);
                        }
                    }
                    else
                    {
                        MLLoadString(IDS_USER_DEFINED, sz1, ARRAYSIZE(sz1));
                        wnsprintf(sz, ARRAYSIZE(sz), FORMAT_STR, sz1, p1);
                    }
                    ListBox_AddString(hwndList, sz);
                    if (TRUE == bEnd)
                        p1 = p2;
                    else
                        p1 = p2 = p2 + 1;
                }
            }
            else
            {
                lcid = GetUserDefaultLCID();

                hr = pML2->GetRfc1766Info(lcid, INETCPL_GetUILanguage(), &Rfc1766Info);
                if (SUCCEEDED(hr))
                {
#ifdef UNICODE
                    StrCpyN(sz1, Rfc1766Info.wszLocaleName,  ARRAYSIZE(sz1));
                    StrCpyN(sz2, Rfc1766Info.wszRfc1766,  ARRAYSIZE(sz2));
#else
                    WideCharToMultiByte(CP_ACP, 0, Rfc1766Info.wszLocaleName, -1, sz1, MAX_LIST_STRING_LEN, NULL, NULL);
                    WideCharToMultiByte(CP_ACP, 0, Rfc1766Info.wszRfc1766, -1, sz2, MAX_RFC1766_NAME, NULL, NULL);
#endif
                    wnsprintf(sz, ARRAYSIZE(sz), FORMAT_STR, sz1, sz2);
                    ListBox_AddString(hwndList, sz);
                }
            }
            RegCloseKey(hKey);
        }
        pML2->Release();
    }
    pCoUninitialize();
}

//
// LanguageDlgInit()
//
// Initializes the Language dialog.
//
BOOL LanguageDlgInit(IN HWND hDlg)
{
    if (!hDlg)
        return FALSE;   // nothing to initialize

    FillAcceptListBox(hDlg);

    EnableWindow(GetDlgItem(hDlg, IDC_LANG_REMOVE_BUTTON), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_LANG_MOVE_UP_BUTTON), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_LANG_MOVE_DOWN_BUTTON), FALSE);
    EnableWindow(GetDlgItem(hDlg, IDC_LANG_ADD_BUTTON), !g_restrict.fInternational);
    
    // On NT5, we use NT5's MUI feature instead of IE5 plugui
    if (IsOS(OS_WIN2000ORGREATER))
        ShowWindow(GetDlgItem(hDlg, IDC_LANG_UI_PREF), SW_HIDE);
    else
    {
        UINT uiACP = GetACP();

        // We don't support PlugUI on these platforms
        if (uiACP == CP_ARABIC || uiACP == CP_HEBREW || uiACP == CP_THAI)
            ShowWindow(GetDlgItem(hDlg, IDC_LANG_UI_PREF), SW_HIDE);
        else
            EnableWindow(GetDlgItem(hDlg, IDC_LANG_UI_PREF), !g_restrict.fInternational);
    }

    // show the current UI lang
    InitCurrentUILang(hDlg);
    
    // everything ok
    return TRUE;
}

//
// SaveLanguageData()
//
// Save the new language settings into regestry
//
void SaveLanguageData(IN HWND hDlg)
{
    HKEY hKey;
    DWORD dw;
    int i, iNumItems, iQ, n;
    TCHAR szBuf[MAX_ACCEPT_LANG_LEN];

    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_INTERNATIONAL, NULL, NULL, NULL, KEY_WRITE, NULL, &hKey, &dw ))
    {
        HWND hwndList = GetDlgItem(hDlg, IDC_LANG_ACCEPT_LIST);

        iNumItems = ListBox_GetCount(hwndList);

        for (n = 1, iQ = 10; iQ < iNumItems; iQ *= 10, n++)
            ;

        szBuf[0] = NULL;
        for (i = 0; i < iNumItems; i++)
        {
            TCHAR sz[MAX_LIST_STRING_LEN], *p1, *p2;

            ListBox_GetText(hwndList, i, sz);
            p1 = sz;
            // We can assume safely there is '[' and ']' in this string.
            while (TEXT('[') != *p1)
                p1 = CharNext(p1);
            p1 = p2 = p1 + 1;
            while (TEXT(']') != *p2)
                p2 = CharNext(p2);
            *p2 = NULL;
            if (0 == i)
                StrCpyN(szBuf, p1, ARRAYSIZE(szBuf));
            else
            {
                TCHAR szF[MAX_ACCEPT_LANG_LEN], szQ[MAX_ACCEPT_LANG_LEN];

                int len = lstrlen(szBuf);
                StrCpyN(szBuf + len, TEXT(","), ARRAYSIZE(szBuf) - len);
                len++;
                StrCpyN(szBuf + len, p1, ARRAYSIZE(szBuf) - len);
                wnsprintf(szF, ARRAYSIZE(szF), TEXT(";q=0.%%0%dd"), n);
                wnsprintf(szQ, ARRAYSIZE(szQ), szF, ((iNumItems - i) * iQ + (iNumItems / 2)) / iNumItems);
                len = lstrlen(szBuf);
                StrCpyN(szBuf + len , szQ, ARRAYSIZE(szBuf) - len);
            }
        }
        RegSetValueEx(hKey, REGSTR_VAL_ACCEPT_LANGUAGE, NULL, REG_SZ, (LPBYTE)szBuf, (lstrlen(szBuf)+1)*sizeof(TCHAR));
        RegCloseKey(hKey);
    }
}

// MoveUpDownListItem()
//
// Move selected list item up or down
//
void MoveUpDownListItem(HWND hDlg, HWND hwndList, BOOL bUp)
{
    int i, iNumItems;
    TCHAR sz[MAX_LIST_STRING_LEN];

    i = ListBox_GetCurSel(hwndList);
    iNumItems = ListBox_GetCount(hwndList);
    ListBox_GetText(hwndList, i, sz);
    ListBox_DeleteString(hwndList, i);

    i += (bUp)? -1: 1;
    if (i < 0)
        i = 0;
    else if (i >= iNumItems)
        i = iNumItems - 1;
    ListBox_InsertString(hwndList, i, sz);
    ListBox_SetSel(hwndList, TRUE, i);
    ListBox_SetCurSel(hwndList, i);

    EnableWindow(GetDlgItem(hDlg, IDC_LANG_MOVE_UP_BUTTON), i != 0);
    EnableWindow(GetDlgItem(hDlg, IDC_LANG_MOVE_DOWN_BUTTON), i < iNumItems - 1);

    if (NULL == GetFocus()) // This prevent keyboard access disable
        SetFocus(hwndList);
}


//
// FillLanguageListBox()
//
// Fills the language listbox with the names of available languages
//
BOOL FillLanguageListBox(IN HWND hDlg)
{
    IMultiLanguage2 *pML2;
    HRESULT hr;
    TCHAR sz[MAX_LIST_STRING_LEN], sz1[MAX_LOCALE_NAME], sz2[MAX_RFC1766_NAME];
    HWND hwndEdit = GetDlgItem(hDlg, IDC_LANG_USER_DEFINED_EDIT);
    HWND hwndList = GetDlgItem(hDlg, IDC_LANG_AVAILABLE_LIST);
    HWND hwndAccept = GetDlgItem(GetParent(hDlg), IDC_LANG_ACCEPT_LIST);
    
    SendMessage(hwndEdit, EM_SETLIMITTEXT, 16, 0L); // Set Limit text as 16 characters

    if(!hOLE32)
    {
        if(!_StartOLE32())
        {
            ASSERT(FALSE);
            return FALSE;
        }
    }
    hr = pCoInitialize(NULL);
    if (FAILED(hr))
        return FALSE;

    hr = pCoCreateInstance(CLSID_CMultiLanguage, NULL, CLSCTX_INPROC_SERVER, IID_IMultiLanguage2, (LPVOID *) &pML2);
    if (SUCCEEDED(hr))
    {
        IEnumRfc1766 *pEnumRfc1766;
        RFC1766INFO Rfc1766Info;

        if (SUCCEEDED(pML2->EnumRfc1766(INETCPL_GetUILanguage(), &pEnumRfc1766)))
        {
            while (S_OK == pEnumRfc1766->Next(1, &Rfc1766Info, NULL))
            {
#ifdef UNICODE
                StrCpyN(sz1, Rfc1766Info.wszLocaleName, ARRAYSIZE(sz1));
                StrCpyN(sz2, Rfc1766Info.wszRfc1766,  ARRAYSIZE(sz2));
#else
                WideCharToMultiByte(CP_ACP, 0, Rfc1766Info.wszLocaleName, -1, sz1, MAX_LOCALE_NAME, NULL, NULL);
                WideCharToMultiByte(CP_ACP, 0, Rfc1766Info.wszRfc1766, -1, sz2, MAX_RFC1766_NAME, NULL, NULL);
#endif
                wnsprintf(sz, ARRAYSIZE(sz), FORMAT_STR, sz1, sz2);
                if (LB_ERR == ListBox_FindStringExact(hwndAccept, -1, sz))
                    ListBox_AddString(hwndList, sz);
            }
            pEnumRfc1766->Release();
        }
        pML2->Release();
    }
    pCoUninitialize();
    
    // everything ok
    return TRUE;
}

//
// AddLanguage()
//
// Add selected language to accept language listbox.
//
void AddLanguage(IN HWND hDlg)
{
    int i, j, *pItems, iNumItems, iIndex;
    TCHAR sz[MAX_LIST_STRING_LEN];
    HWND hdlgParent = GetParent(hDlg);
    HWND hwndFrom = GetDlgItem(hDlg, IDC_LANG_AVAILABLE_LIST);
    HWND hwndTo = GetDlgItem(hdlgParent, IDC_LANG_ACCEPT_LIST);

    i = ListBox_GetSelCount(hwndFrom);
    if (0 < i && (pItems = (PINT)LocalAlloc(LPTR, sizeof(int)*i)))
    {
        ListBox_GetSelItems(hwndFrom, i, pItems);
        for (j = 0; j < i; j++)
        {
            ListBox_GetText(hwndFrom, pItems[j], sz);
            ListBox_AddString(hwndTo, sz);
        }
        LocalFree(pItems);
    }
    if (GetWindowTextLength(GetDlgItem(hDlg, IDC_LANG_USER_DEFINED_EDIT)))
    {
        TCHAR *p, sz1[MAX_LIST_STRING_LEN], sz2[MAX_LIST_STRING_LEN];
        BOOL fValid = TRUE;

        GetWindowText(GetDlgItem(hDlg, IDC_LANG_USER_DEFINED_EDIT), sz2, ARRAYSIZE(sz2));
        p = sz2;
        while (NULL != *p && TRUE == fValid)
        {
            switch (*p)
            {
                // Invalid characters for user-defined string
                case TEXT(','):
                case TEXT(';'):
                case TEXT('['):
                case TEXT(']'):
                case TEXT('='):
                    fValid = FALSE;
                    break;

                default:
                    p = CharNext(p);
            }
        }
        if (FALSE == fValid)
        {
            TCHAR szTitle[256], szErr[1024];

            MLLoadShellLangString(IDS_USER_DEFINED_ERR, szErr, ARRAYSIZE(szErr));
            GetWindowText(hDlg, szTitle, ARRAYSIZE(szTitle));
            MessageBox(hDlg, szErr, szTitle, MB_OK | MB_ICONHAND);
        }
        else
        {
            MLLoadString(IDS_USER_DEFINED, sz1, ARRAYSIZE(sz1));
            wnsprintf(sz, ARRAYSIZE(sz), FORMAT_STR, sz1, sz2);
            ListBox_AddString(hwndTo, sz);
        }
    }
    iIndex = ListBox_GetCurSel(hwndTo);
    if (LB_ERR != iIndex)
    {
        iNumItems = ListBox_GetCount(hwndTo);
        EnableWindow(GetDlgItem(hdlgParent, IDC_LANG_REMOVE_BUTTON), iNumItems > 0);
        EnableWindow(GetDlgItem(hdlgParent, IDC_LANG_MOVE_UP_BUTTON), iIndex > 0);
        EnableWindow(GetDlgItem(hdlgParent, IDC_LANG_MOVE_DOWN_BUTTON), iIndex < iNumItems - 1);
    }
}

int ComboBoxEx_AddString(IN HWND hwndCtl, IN LPCTSTR sz)
{
    COMBOBOXEXITEM cbexItem = {0};
    
    int csz = _tcslen(sz);

    cbexItem.mask = CBEIF_TEXT;
    cbexItem.pszText = (LPTSTR)sz;
    cbexItem.cchTextMax = csz;
    
    // sort the string based on the current locale
    // we don't bother to use binary search because
    // the list is up to 25 item
    TCHAR szItem[MAX_LOCALE_NAME];
    int i, itemCount = ComboBox_GetCount(hwndCtl);
    for (i = 0; i < itemCount; i++)
    {
        ComboBox_GetLBText(hwndCtl, i, szItem);
        if (CompareString(INETCPL_GetUILanguage(), 
                          0,
                          sz,
                          csz,
                          szItem,
                          ARRAYSIZE(szItem)) == CSTR_LESS_THAN)
        {
            break;
        }
    }
    cbexItem.iItem = i;
    
    SendMessage(hwndCtl, CBEM_INSERTITEM, (WPARAM)0, (LPARAM)(LPVOID)&cbexItem);
    return i;
}

BOOL FillUILangListBox(IN HWND hDlg, CUILangList *pLangList)
{
    HWND hwndCombo = GetDlgItem(hDlg, IDC_COMBO_UILANG);
    BOOL bNT5 = IsOS(OS_WIN2000ORGREATER);
    DWORD dwAcp = GetACP();
    LPCTSTR pszLangName;
    
    if (!pLangList)
        return FALSE;

    // fill the list up.
    for (int i = 0; i < pLangList->GetListSize(); i++)
    {
        if (!pLangList->IsValidLang(i))
            continue;

        if (!bNT5)
        {
            LANGID lid = pLangList->GetLangIdOfIdx(i);

            if (dwAcp == CP_THAI || dwAcp == CP_ARABIC || dwAcp == CP_HEBREW)
            {
                // do not support cross codepage PlugUI
                // on Thai or Middle East platform(Arabic/Hebrew)
                static DWORD dwDefCP = 0;

                if (dwDefCP == 0)
                {
                    TCHAR szLcData[6+1]; // +2 for '0x' +1 for terminator

                    GetLocaleInfo( MAKELCID(lid, SUBLANG_NEUTRAL),
                        LOCALE_IDEFAULTANSICODEPAGE, szLcData, ARRAYSIZE(szLcData));
                                       
                    dwDefCP = StrToInt(szLcData);
                }
                if (dwDefCP != dwAcp && lid != 0x0409 && lid != GetInstallLanguage())
                    continue;
            }
            else
            {
                // skip Arabic and Hebrew on non-supporting platform
                if (lid == 0x401 || lid == 0x40d)
                    continue;
            }
        }

        pszLangName = pLangList->GetLangNameOfIdx(i);

        // ComboBox_FindStringExact has problems to handle DBCS Unicode characters 
        if (pszLangName)
        {
            int ipos = ComboBoxEx_AddString(hwndCombo, pszLangName);
            if (ipos >= 0)
            {
                ComboBox_SetItemData(hwndCombo, ipos, i);
            }
        }
    }

    // show the current selection
    int iLangIdx = pLangList->GetCurrentLangIdx();
    if (iLangIdx >= 0)
    {
        int iCBPos;
        int iCBSize = ComboBox_GetCount(hwndCombo);
        for (iCBPos = 0; iCBPos < iCBSize; iCBPos++)
        {
            if (iLangIdx == ComboBox_GetItemData(hwndCombo, iCBPos))
                break;
        }

        if (iCBPos < iCBSize)
            ComboBox_SetCurSel(hwndCombo, iCBPos);
    }
    return TRUE;
}

//
// Shutdown/reboot procedures implementation
//
// synopsis: CShutDownInfo class implements the method and the process list
//           which handle the sequence.
//           s_arryClsNames[] holds the list of target application
//           ChangeLanguage() (global) triggers the sequence being called from
//           LangChangeDlgProc().
//
static const LPTSTR s_arryClsNames[] =  
{
    TEXT("IEFrame"),                       // browser instance
    TEXT("ThorBrowserWndClass"),           // OE 
    TEXT("HH Parent"),                     // Html Help
    TEXT("MPWClass"),                      // 
    TEXT("Outlook Express Browser Class"), // OE
    TEXT("ATH_Note"),                      // OE?
    TEXT("WABBrowseView"),                 // WAB
    TEXT("Afx:400000:8:10008:0:900d6"),
    TEXT("Media Player 2"),
    TEXT("FrontPageExpressWindow"), 
    TEXT("MSBLUIManager"),                 // Messenger
};

//
// CShutDownInfo
// class methods implementation
//
#define SHUTDOWN_TIMEOUT 2000 // 2 sec
#define RELAUNCH_TIMEOUT 1000 // 1 sec
CShutDownProcInfo::CShutDownProcInfo(HWND hDlg)
{
    _pProcList = NULL;
    _nAlloced = 0;
    _iProcList = 0;
    _hdlgParent = hDlg;
    _fAllShutDown = FALSE;
}

CShutDownProcInfo::~CShutDownProcInfo()
{
    if (_pProcList)
        LocalFree(_pProcList);
}


HRESULT CShutDownProcInfo::EnsureProcList()
{
    HRESULT hr = S_OK;
    if (!_pProcList)
    {
        // alloc mem for practical # of processes
        _nAlloced = ARRAYSIZE(s_arryClsNames);
        _pProcList = (PROCLIST *)LocalAlloc(LPTR, sizeof(PROCLIST)*_nAlloced);
    }
    if (!_pProcList) 
    {
        _nAlloced = 0;
        hr = E_FAIL;
    }

    return hr;
}
HRESULT CShutDownProcInfo::IncreaseProcList()
{
    HRESULT hr = S_OK;
    PROCLIST * pl = NULL;
    // realloc mem every so often
    if (_iProcList+1 > _nAlloced)
    {
        pl = (PROCLIST *)LocalReAlloc(_pProcList, sizeof(PROCLIST)*(ARRAYSIZE(s_arryClsNames)+_nAlloced), 
                                      LMEM_MOVEABLE | LMEM_ZEROINIT);
        if (pl)
        {
            _nAlloced += ARRAYSIZE(s_arryClsNames);
            _pProcList =  pl;
        }
        else
           hr = E_FAIL;
    }

    if (hr == S_OK)
        _iProcList++;

    return hr;
}
// CShutDownProcInfo::AddToProcList()
//
// synopsis: Get process info from given window handle
//           store it for shutdown procedure
//
//
//
HRESULT CShutDownProcInfo::AddToProcList(HWND hwnd)
{
    HRESULT hr = S_OK;

    hr = EnsureProcList();
    if (SUCCEEDED(hr) && hwnd)
    {
        DWORD dwPID;
        BOOL  fFoundDup = FALSE;

        GetWindowThreadProcessId(hwnd, &dwPID);
        
        // check to see if we already have the PID in the list
        for (int i=0; i < _iProcList; i++)
        {
            if (_pProcList[i].dwPID == dwPID)
            {
                fFoundDup = TRUE;
                break;
            }
        }

        // add proccess info only if we don't have it already
        if (!fFoundDup)
        {
            hr = IncreaseProcList();
            if (SUCCEEDED(hr))
            {
                int iCur = _iProcList-1;

                GetExeNameFromPID(dwPID, 
                    _pProcList[iCur].szExeName, 
                    ARRAYSIZE(_pProcList[iCur].szExeName));

                _pProcList[iCur].dwPID = dwPID;
                _pProcList[iCur].State = PS_UNKNOWN;
            }
        }
    }
    return hr;    
}

// CShutDownProcInfo::WaitForOneProcess
//
// synopsis: ensures the given process 
//           has terminated
//
//
HRESULT CShutDownProcInfo::WaitForOneProcess(int iProc)
{
    HRESULT hr = S_OK;
    if (iProc < _iProcList && _pProcList[iProc].State != PS_SHUTDOWN_OK)
    {
        DWORD dwProcessFlags = PROCESS_ALL_ACCESS | 
                               (_fNT ? SYNCHRONIZE : 0 );

        HANDLE hProc = OpenProcess(dwProcessFlags,
                                   FALSE,    
                                   _pProcList[iProc].dwPID);

        // pressume it has terminated, get it marked so
        _pProcList[iProc].State = PS_SHUTDOWN_OK;

        if (hProc) 
        {
            // if the proccess in query is still alive,
            // we'll wait with time out here
            //
            DWORD dwRet = WaitForSingleObject (hProc, SHUTDOWN_TIMEOUT);
            if (dwRet == WAIT_TIMEOUT)
            {
                _pProcList[iProc].State = PS_WAITING;
            }
            
            CloseHandle(hProc);
        }
    }
    return hr;
}

// CShutDownProcInfo::WaitForFolksShutDown
//
// synopsis: ensure the nominated processes terminate. If anyone 
//           doesn't want to terminate, wait for her retrying a couple of
//           times and note her name so we can show it to the user. 
//          
//
#define MAXSHUTDOWNTRY 10
HRESULT CShutDownProcInfo::WaitForFolksShutDown()
{
    HRESULT hr = S_OK;
    int    iTry = 0;
    do
    {
        // pressume all will be fine
        _fAllShutDown = TRUE;
        // waiting loop
        for (int i = 0; i < _iProcList; i++)
        {
            WaitForOneProcess(i);
            if (_pProcList[i].State != PS_SHUTDOWN_OK)
                _fAllShutDown = FALSE;
        }
    }
    while( !_fAllShutDown && iTry++ < MAXSHUTDOWNTRY  );
    // FEATURE: here we should put up a dialog
    //         to ask user if they want to wait
    //         for the apps 

    return hr;
}

// CShutDownProcInfo::NotifyShutDownToFolks
//
// synopsis: send POI_OFFICE_COMMAND to possible candidates on the desktop
//           if a candidate replies with valid value, save the proccess
//           information for the later restart procedure.
//
HRESULT CShutDownProcInfo::NotifyShutDownToFolks(int *pnProcess)
{
    HWND hwndShutDown, hwndAfter;
    PLUGUI_QUERY pq;
    HRESULT hr = S_OK;
    int     nProcToShutDown = 0;

    for (int i = 0; i < ARRAYSIZE(s_arryClsNames); i++)
    {
        hwndAfter = NULL; 
        while (hwndShutDown = FindWindowEx(NULL, hwndAfter, s_arryClsNames[i], NULL))
        {
            pq.uQueryVal = (UINT)SendMessage(hwndShutDown, PUI_OFFICE_COMMAND, PLUGUI_CMD_QUERY, 0);
            if (pq.uQueryVal)
            {
                if(pq.PlugUIInfo.uMajorVersion == OFFICE_VERSION_9)
                {
                    PostMessage(hwndShutDown, PUI_OFFICE_COMMAND, (WPARAM)PLUGUI_CMD_SHUTDOWN, 0);

                    // store the information about the process which this window belongs to
                    // we only need to remember non OLE processes here for re-starting.
                    if (!pq.PlugUIInfo.uOleServer)
                    {
                        AddToProcList(hwndShutDown);
                        nProcToShutDown ++;
                    }
                }
            }
            hwndAfter = hwndShutDown;
        }
    }
    if (!nProcToShutDown)
        hr = S_FALSE;

    if (pnProcess)
        *pnProcess = nProcToShutDown;

    return hr;
}

const TCHAR c_szRegAppPaths[] = TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Paths\\");
HRESULT CShutDownProcInfo::GetRestartAppPath(LPTSTR szPath, int cchPath, int iProc)
{
    HRESULT hr = S_OK;
    TCHAR szAppPath[MAX_PATH];
    TCHAR szRegKey[MAX_PATH];

    ASSERT(szPath && cchPath > 0);

    if (iProc < _iProcList)
    {
        _tcscpy(szRegKey, c_szRegAppPaths);
        _tcscat(szRegKey, _pProcList[iProc].szExeName);
        
        DWORD cb = sizeof(szAppPath);
        if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, szRegKey, NULL, NULL, szAppPath, &cb))
        {
            szPath[0] = TEXT('0');
            hr = E_FAIL;
        }
        else
            _tcsncpy(szPath, szAppPath, cchPath);
    }
    return hr;
}

HRESULT CShutDownProcInfo::RestartFolks()
{
    PROCESS_INFORMATION pi;
    for (int i = 0; i < _iProcList; i++)
    {
        STARTUPINFO si = {0};
        si.cb = sizeof(si);
        if (_pProcList[i].State == PS_SHUTDOWN_OK)
        {
            TCHAR szAppPath[MAX_PATH];    
            HRESULT hr = GetRestartAppPath(szAppPath, ARRAYSIZE(szAppPath), i);
            if (hr == S_OK)
            {
                BOOL fLaunchedOK = 
                CreateProcess (szAppPath,               // name of app to launch
                                NULL,                   // lpCmdLine
                                NULL,                   // lpProcessAttributes
                                NULL,                   // lpThreadAttributes
                                TRUE,                   // bInheritHandles
                                NORMAL_PRIORITY_CLASS,  // dwCreationFlags
                                NULL,                   // lpEnvironment
                                NULL,                   // lpCurrentDirectory
                                &si,                    // lpStartupInfo
                                &pi);                   // lpProcessInformation

                if (fLaunchedOK)
                { 
                    DWORD dwRet = WaitForInputIdle (pi.hProcess,
                                                    RELAUNCH_TIMEOUT);
                    CloseHandle(pi.hProcess);
                    CloseHandle(pi.hThread);
                }
            }
        }
    }
    return S_OK;
}



// 
//   CShutDownProcInfo::ShutDownThreadProc
//
//   synopsis: launched from changelang dialog so the dialog
//             wouldn't get blocked when we're waiting for our apps
//             to shutdown/restart. this is a static proc
//             so we should be able to delete the class instance
//             in this proc.
//
DWORD CALLBACK CShutDownProcInfo::ShutDownThreadProc(void *pv)
{
    CShutDownProcInfo *pspi = (CShutDownProcInfo *)pv;
    
    if (pspi)
    {
        HRESULT hr;
        int     nToShutDown;
        // send PUI_OFFICE_COMMAND to corresponding folks...
        hr = pspi->NotifyShutDownToFolks(&nToShutDown);

        // and wait until all processes shutdown
        if (SUCCEEDED(hr) && nToShutDown > 0)
        {
            hr = pspi->WaitForFolksShutDown();

            // then restart here
            if (SUCCEEDED(hr))
               pspi->RestartFolks();
        }
    
        // now the parent dialog should go away
        int iret = (nToShutDown > 0) ? 
                   RETURN_SETLANG_ENDLANGDIALOG: RETURN_SETLANG_CLOSEDNORMAL;
        
        EndDialog(pspi->_hdlgParent, iret);
    
        // delete this class instance
        delete pspi;
    }
    return 0;
}

void OpenSatelliteDownloadUrl(HWND hDlg)
{
    // get the default Url from registry
    TCHAR szSatelliteUrl[INTERNET_MAX_URL_LENGTH];

    // reg api needs size in byte
    DWORD dwType, dwcbData = sizeof(szSatelliteUrl);
    
    DWORD dwRet =  SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_INTERNATIONAL, 
                             NULL, &dwType, (void *)szSatelliteUrl, &dwcbData);
    if (dwRet != ERROR_SUCCESS || !szSatelliteUrl[0])
    {
       // use the hard coded Url instead
       _tcscpy(szSatelliteUrl, s_szUrlSPK);
    }

    if(!hOLE32)
    {
        if(!_StartOLE32())
        {
            ASSERT(FALSE);
            return;
        }
    }

    HRESULT hr = pCoInitialize(NULL);
    if (SUCCEEDED(hr))
    {
        NavToUrlUsingIE(szSatelliteUrl, TRUE);
        pCoUninitialize();
    }
}

INT_PTR CALLBACK LangMsgDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_COMMAND:
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDYES:
                case IDNO:
                case IDOK:
                case IDCANCEL:
                    EndDialog(hDlg, GET_WM_COMMAND_ID(wParam, lParam));
                    break;
            }
            return TRUE;
        }

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:    // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);        
            break;
    }
    return FALSE;
}

BOOL ChangeLanguage(IN HWND hDlg, CUILangList *pLangList)
{
    HWND hwndCombo = GetDlgItem(hDlg, IDC_COMBO_UILANG);
    int iSel = ComboBox_GetCurSel(hwndCombo);
    INT_PTR idxSel = 0;
    int idxCur;
    
    if (iSel != CB_ERR)
        idxSel = ComboBox_GetItemData(hwndCombo, iSel);

    if ( idxSel != CB_ERR 
        && idxSel < pLangList->GetListSize())
    {
        idxCur = pLangList->GetCurrentLangIdx();

        if (idxCur != idxSel)
        {
            INT_PTR iRet = DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_LANG_WARNING), hDlg, LangMsgDlgProc);

            if (IDCANCEL != iRet)
            {
                pLangList->SetCurrentLangIdx((int)idxSel);

                if (IDYES == iRet)
                {
                    CShutDownProcInfo  *pspi = new CShutDownProcInfo(hDlg);
                    if (!SHCreateThread(pspi->ShutDownThreadProc, (void *)pspi, 0, NULL))
                        delete pspi;

                    // returning TRUE to indicate that we do shutdown/restart
                    return TRUE;
                }
                else
                {
                    DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_LANG_INFO), hDlg, LangMsgDlgProc);
                }
            }
        }
    }
    // returning FALSE to indicate that we haven't changed the language
    return FALSE;
}

//
// LangChangeDlgProc()
//
// Message handler for the "Change Language" subdialog.
//
INT_PTR CALLBACK LangChangeDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CUILangList *pLangList;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            CUILangList::GetLangList(GetParent(hDlg), &pLangList);
            return FillUILangListBox(hDlg, pLangList);
    
        case WM_DESTROY:
            break;

        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_LANG_ADDSPK:
                    // open url from resource
                    OpenSatelliteDownloadUrl(hDlg);
                    EndDialog(hDlg, RETURN_SETLANG_ENDLANGDIALOG);
                    break;
                case IDOK:
                    if(!SUCCEEDED(CUILangList::GetLangList(GetParent(hDlg), &pLangList))
                      || !ChangeLanguage(hDlg, pLangList))
                      EndDialog(hDlg, 0);

                    // EndDialog() is called in separate thread 
                    // when shutdown/restart is done
                    // 
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, 0);
                    break;
            }
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:    // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);        
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

//
// LangAddDlgProc()
//
// Message handler for the "Add Language" subdialog.
//
INT_PTR CALLBACK LangAddDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return FillLanguageListBox(hDlg);
    
        case WM_DESTROY:
            break;

        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDOK:
                    AddLanguage(hDlg);
                    EndDialog(hDlg, 0);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, 0);
                    break;
            }
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:    // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);        
            break;

        default:
            return FALSE;
    }
    return TRUE;
}

// put any cleanup procedures for language dialog here
void LangDlgCleanup(HWND hDlg)
{
    // also delete and remove the instance of
    // UI language list from window prop
    CUILangList::RemoveLangList(hDlg);
}
//
// LanguageDlgProc()
//
// Message handler for the "Language Preference" subdialog.
//
INT_PTR CALLBACK LanguageDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CUILangList *pLangList;
    switch (uMsg)
    {
        case WM_INITDIALOG:
            return LanguageDlgInit(hDlg);
    
        case WM_DESTROY:
            LangDlgCleanup(hDlg);
            break;

        case WM_COMMAND:
            switch(GET_WM_COMMAND_ID(wParam, lParam))
            {
                HWND hwndList;
                int iIndex, iNumItems;
                INT_PTR iret;

                case IDOK:
                    SaveLanguageData(hDlg);
                    EndDialog(hDlg, 0);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, 0);
                    break;

                case IDC_LANG_ADD_BUTTON:
                    DialogBox(MLGetHinst(), MAKEINTRESOURCE(IDD_LANG_ADD), hDlg, LangAddDlgProc);
                    break;

                case IDC_LANG_UI_PREF:
                    CUILangList::GetLangList(hDlg, &pLangList);
                    iret = KickSetLang(hDlg, pLangList);
                    if (iret == RETURN_SETLANG_ENDLANGDIALOG)
                    {
                        // we're outa job
                        EndDialog(hDlg, 0);
                    }
                    else
                    {
                        InitCurrentUILang(hDlg);
                    }
                    break;

                case IDC_LANG_REMOVE_BUTTON:
                    hwndList = GetDlgItem(hDlg, IDC_LANG_ACCEPT_LIST);
                    iIndex = ListBox_GetCurSel(hwndList);
                    ListBox_DeleteString(hwndList, iIndex);
                    iNumItems = ListBox_GetCount(hwndList);
                    if (iNumItems == iIndex)
                        iIndex--;
                    ListBox_SetCurSel(hwndList, iIndex);
                    EnableWindow(GetDlgItem(hDlg, IDC_LANG_REMOVE_BUTTON), (iNumItems > 0) && !g_restrict.fInternational);
                    EnableWindow(GetDlgItem(hDlg, IDC_LANG_MOVE_UP_BUTTON), (iIndex > 0) && !g_restrict.fInternational);
                    EnableWindow(GetDlgItem(hDlg, IDC_LANG_MOVE_DOWN_BUTTON), (iIndex < iNumItems - 1) && !g_restrict.fInternational);

                    if (NULL == GetFocus()) // This prevent keyboard access disable
                        SetFocus(hwndList);
                    break;

                case IDC_LANG_ACCEPT_LIST:
                    hwndList = GetDlgItem(hDlg, IDC_LANG_ACCEPT_LIST);
                    iIndex = ListBox_GetCurSel(hwndList);
                    if (0 <= iIndex)
                    {
                        iNumItems = ListBox_GetCount(hwndList);
                        EnableWindow(GetDlgItem(hDlg, IDC_LANG_REMOVE_BUTTON), (iNumItems > 0) && !g_restrict.fInternational);
                        EnableWindow(GetDlgItem(hDlg, IDC_LANG_MOVE_UP_BUTTON), (iIndex > 0) && !g_restrict.fInternational);
                        EnableWindow(GetDlgItem(hDlg, IDC_LANG_MOVE_DOWN_BUTTON), (iIndex < iNumItems - 1) && !g_restrict.fInternational);
                    }
                    break;

                case IDC_LANG_MOVE_UP_BUTTON:
                    MoveUpDownListItem(hDlg, GetDlgItem(hDlg, IDC_LANG_ACCEPT_LIST), TRUE);
                    break;

                case IDC_LANG_MOVE_DOWN_BUTTON:
                    MoveUpDownListItem(hDlg, GetDlgItem(hDlg, IDC_LANG_ACCEPT_LIST), FALSE);
                    break;
            }
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:    // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);        
            break;

        default:
            return FALSE;
    }
    return TRUE;
}


//
// KickLanguageDialog
//
// synopsis : used for launching Language Preference sub dialog.
//            we need to launch the dialogbox as a separate process if inetcpl is 
//            invoked from Tools->Internet options. 
//            The reason: we shutdown every browser instances on desktop
//                        user chooses different UI language than the current,
//                        including the browser that launched inetcpl.
//
static const TCHAR  s_szRunDll32[] = TEXT("RunDll32.exe");
static const TCHAR  s_szKickLangDialog[] = TEXT(" inetcpl.cpl,OpenLanguageDialog");
void KickLanguageDialog(HWND hDlg)
{
    // 1: here we want to check to see if inetcpl was launched 
    //         as a rundll32 process already, which would happen if user 
    //         clicks on it at control panel folder
    //
    //
    BOOL fLaunchedOnBrowser = FALSE;
    
    // this tells me whether we got invoked from Tools->Internet Options...
    if (g_szCurrentURL[0])
    {
        fLaunchedOnBrowser = TRUE;
    }
    
    if (fLaunchedOnBrowser)
    {
        TCHAR szCommandLine[MAX_PATH];
        TCHAR szTitle[MAX_PATH];

        HWND hwndParent = GetParent(hDlg);
        
        StrCpy(szCommandLine, s_szRunDll32);
        StrCat(szCommandLine, s_szKickLangDialog);
        
        if (GetWindowText(hwndParent, szTitle, ARRAYSIZE(szTitle)) > 0)
        {
            StrCat(szCommandLine, TEXT(" "));
            StrCat(szCommandLine, szTitle);
        }
        
#ifdef USE_CREATE_PROCESS
        PROCESS_INFORMATION pi;
        STARTUPINFO si = {0};

        si.cb = sizeof(si);
        BOOL fLaunchedOK = 
        CreateProcess (szCommandLine,          // name of app to launch
                       NULL,                   // lpCmdLine
                       NULL,                   // lpProcessAttributes
                       NULL,                   // lpThreadAttributes
                       TRUE,                   // bInheritHandles
                       NORMAL_PRIORITY_CLASS,  // dwCreationFlags
                       NULL,                   // lpEnvironment
                       NULL,                   // lpCurrentDirectory
                       &si,                    // lpStartupInfo
                       &pi);                   // lpProcessInformation
#else
        char szAnsiPath[MAX_PATH];
        SHUnicodeToAnsi(szCommandLine, szAnsiPath, ARRAYSIZE(szAnsiPath));
        WinExec(szAnsiPath, SW_SHOWNORMAL);
#endif
    }
    else
    {
        DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_LANG), hDlg, LanguageDlgProc, NULL);
    }
}

//
// KickSetLang
//
// synopsis : tries to find setlang.exe of Office9 first, if found it'll be kicked
//            if not, it uses our own setlang dialog.
//
//
static const TCHAR s_szOfficeInstallRoot[] = TEXT("Software\\Microsoft\\Office\\9.0\\Common\\InstallRoot");
static const TCHAR s_szOffice10InstallRoot[] = TEXT("Software\\Microsoft\\Shared");
static const TCHAR s_szPath[] = TEXT("Path");
static const TCHAR s_szOffice10Path[] = TEXT("OfficeSetLangInstallLocation");
static const TCHAR s_szSetLangExe[] = TEXT("setlang.exe");

INT_PTR KickSetLang(HWND hDlg, CUILangList *pLangList)
{
    BOOL fOfficeSetLangInstalled = FALSE;
    INT_PTR iret;
    
    TCHAR szSetLangPath[MAX_PATH];    
    
    //  deleting the key this way makes the key invalid for this process
    //  this way the inetcpl doesnt get bogus cached values
    SHDeleteKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\ShellNoRoam\\MUICache"));

    // try to get Office's setlang path
    if(pLangList && pLangList->IsOffice9Installed()) 
    {
        DWORD cb = sizeof(szSetLangPath);
        DWORD dwRet = SHGetValue(HKEY_LOCAL_MACHINE, s_szOffice10InstallRoot, s_szOffice10Path, NULL, szSetLangPath, &cb);

        // fall back to Office9 langpack setting if Office10 langpack setting isn't there
        if (ERROR_SUCCESS != dwRet)
        {
            cb = sizeof(szSetLangPath);            
            dwRet = SHGetValue(HKEY_LOCAL_MACHINE, s_szOfficeInstallRoot, s_szPath, NULL, szSetLangPath, &cb);
        }

        if (ERROR_SUCCESS == dwRet)
        {
            // If last character is a backslash
            if (szSetLangPath[lstrlen(szSetLangPath)-1] == TEXT('\\'))
            {
                // Then concatenate the exe name
                //
                StrCat(szSetLangPath, s_szSetLangExe);
            }
            if (PathFileExists(szSetLangPath) == TRUE)
                fOfficeSetLangInstalled = TRUE;
        }
    }
    
    if (fOfficeSetLangInstalled)
    {
        PROCESS_INFORMATION pi;
        STARTUPINFO si = {0};

        si.cb = sizeof(si);
        BOOL fLaunchedOK = CreateProcess(
                              szSetLangPath,     // name of app to launch
                                       NULL,     // lpCmdLine
                                       NULL,     // lpProcessAttributes
                                       NULL,     // lpThreadAttributes
                                       TRUE,     // bInheritHandles
                      NORMAL_PRIORITY_CLASS,     // dwCreationFlags
                                       NULL,     // lpEnvironment
                                       NULL,     // lpCurrentDirectory
                                       &si,      // lpStartupInfo
                                       &pi);     // lpProcessInformation
        // just wait a while
        if (fLaunchedOK)
        { 
            WaitForInputIdle (pi.hProcess, RELAUNCH_TIMEOUT);
            CloseHandle(pi.hProcess);
            CloseHandle(pi.hThread);
        }
        iret = RETURN_SETLANG_ENDLANGDIALOG;
    }
    else
    {
        iret = DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_LANG_CHANGE), hDlg, LangChangeDlgProc, NULL);
    }

    return iret;
}

//
// entry point for rundll32
// NOTE: the following function was written intentionally as non-Unicode
//       mainly because we don't have Wide wrapper mechanism for rundll32
//       function on win95
//
extern void GetRestrictFlags(RESTRICT_FLAGS *pRestrict);
void CALLBACK OpenLanguageDialog(HWND hwnd, HINSTANCE hinst, LPSTR lpszCmdLine, int nCmdShow)
{
    // hinst is ignored because we set it at our LibMain()
    INITCOMMONCONTROLSEX icex;

    GetRestrictFlags(&g_restrict);
    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_USEREX_CLASSES|ICC_NATIVEFNTCTL_CLASS;
    InitCommonControlsEx(&icex);
    
    if (lpszCmdLine && *lpszCmdLine)
    {
        HWND hwndParent = FindWindowA(NULL, lpszCmdLine);
        if (hwndParent)
            hwnd = hwndParent;
    }
    DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_LANG), hwnd, LanguageDlgProc, NULL);
}

// MLGetUILanguage in shlwapi returns current MUI language regardless version.
// MUI architecture doesn't display string correctly when main dll and satellite
// pack versions are mismatched.
// A good example is IE version upgrade without upgrading satellite.
// So here is more clever way to get the MUI language.
//
// 1. Get MLGetUILangauge from shlwapi
// 2. Compare it with current installed language.
// 3. if those are different, try to get resource dll.
// 4. if the resource dll is not in correct path just return current installed
//    language.
// 5. Or return the langid of MLGetUILanguage.
LANGID INETCPL_GetUILanguage()
{
    HINSTANCE hMLInst;
    TCHAR szPath[MAX_PATH], szMUI[16];
    LANGID lidUI = MLGetUILanguage();

    if (IsOS(OS_WIN2000ORGREATER))
        return lidUI;

    if (lidUI != GetInstallLanguage())
    {
        hMLInst = MLGetHinst();
        if (GetModuleFileName(hMLInst, szPath, ARRAYSIZE(szPath)))
        {
            IntToHex(szMUI, 4, lidUI);
            if (StrStrI(szPath, szMUI) == NULL)
                lidUI = GetInstallLanguage();
        }
    }

    return lidUI;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\programs.cpp ===
//*********************************************************************
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1995                    **
//*********************************************************************

//
// PROGRAMS.C - "Programs" property sheet UI handlers doe InetCpl
//
//

//
// History:
//
// 6/20/96  t-gpease    created
//

#include "inetcplp.h"

#include <mluisupp.h>
#include <advpub.h>

//
// Private Functions and Structures
//
BOOL ProgramsDlgInit( HWND hDlg);
void UpdateMailIconLabel();


typedef struct {
    HWND hDlg;          // dialog windows handle
    HWND hwndMail;      // Mail dropdown
    HWND hwndNews;      // News dropdown
    HWND hwndCalendar;  // Calendar dropdown
    HWND hwndContact;   // Contact dropdown
    HWND hwndCall;      // Internet call dropdown
    HWND hwndHtmlEdit;  // HTML Editors dropdown

    BOOL bAssociationCheck;     // Is IE the default browser?
#ifndef UNIX
    BOOL bIEIsFTPClient;  // Is IE the default FTP Client?
    IFtpInstaller * pfi;  // FTP Installer
#endif // UNIX

    int iHtmlEditor;
    int iMail;
    int iNews;
    int iCalendar;
    int iContact;
    int iCall;
    BOOL fChanged;

#ifdef UNIX
    HWND hwndVSource;   // View Source
    HWND hwndMailEdit;
    HWND hwndMailFind;
    HWND hwndNewsFind;
    HWND hwndNewsEdit;
    DWORD dwUseOEMail;
    DWORD dwUseOENews;
    HWND hwndEnableUseOEMail;
    HWND hwndEnableUseOENews;
    int  iVSource;
#endif

} PROGRAMSPAGE, *LPPROGRAMSPAGE;

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#ifdef WALLET

typedef int (*PFN_DISPLAYWALLETPAYDIALOG_PROC)(HWND, HINSTANCE, LPTSTR, int);
typedef int (*PFN_DISPLAYWALLETADDRDIALOG_PROC)(HWND, HINSTANCE, LPTSTR, int);

// NOTE: This is dumb.  Wallet uses different GUIDs for Alpha and x86 versions
//
#ifdef _ALPHA_
static const TCHAR g_szWalletPaymentDirKey[] = TEXT("CLSID\\{B7FB4D5C-9FBE-11D0-8965-0000F822DEA9}\\InprocServer32");
static const TCHAR g_szWalletAddressDirKey[] = TEXT("CLSID\\{B7FB4D5C-9FBE-11D0-8965-0000F822DEA9}\\InprocServer32");
#else
static const TCHAR g_szWalletPaymentDirKey[] = TEXT("CLSID\\{87D3CB66-BA2E-11CF-B9D6-00A0C9083362}\\InprocServer32");
static const TCHAR g_szWalletAddressDirKey[] = TEXT("CLSID\\{87D3CB63-BA2E-11CF-B9D6-00A0C9083362}\\InprocServer32");
#endif

static const char g_szWalletPaymentFN[] = "DisplayWalletPaymentDialog";
static const char g_szWalletAddressFN[] = "DisplayWalletAddressDialog";

HINSTANCE GetWalletPaymentDProc(PFN_DISPLAYWALLETPAYDIALOG_PROC * ppfnDialogProc)
{
    TCHAR   szDLLFile[MAX_PATH];
    DWORD   dwType;
    DWORD   dwSize = SIZEOF(szDLLFile);
    HINSTANCE hInst = NULL;

    *ppfnDialogProc = NULL;
    if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, g_szWalletPaymentDirKey, NULL, &dwType, (LPVOID)szDLLFile, &dwSize))
    {
        hInst = LoadLibrary(szDLLFile);
        // Will Fail if OCX is not installed.
        if (hInst)
        {
            *ppfnDialogProc = (PFN_DISPLAYWALLETPAYDIALOG_PROC) GetProcAddress(hInst, g_szWalletPaymentFN);
        }
    }

    if (!*ppfnDialogProc && hInst)
    {
        FreeLibrary(hInst);
        hInst = NULL;
    }

    return hInst;
}


BOOL IsWalletPaymentAvailable(VOID)
{
    HINSTANCE hInst;
    PFN_DISPLAYWALLETPAYDIALOG_PROC pfnDialogProc;
    BOOL fIsAvailable = FALSE;

    hInst = GetWalletPaymentDProc(&pfnDialogProc);
    if (hInst)
    {
        fIsAvailable = TRUE;
        FreeLibrary(hInst);
    }

    return fIsAvailable;
}

VOID DisplayWalletPaymentDialog(HWND hWnd)
{
    HINSTANCE hInst;
    PFN_DISPLAYWALLETPAYDIALOG_PROC pfnDialogProc;

    hInst = GetWalletPaymentDProc(&pfnDialogProc);
    if (hInst)
    {
        (*pfnDialogProc)(hWnd, NULL, NULL, 0);
        FreeLibrary(hInst);
    }
}


HINSTANCE GetWalletAddressDProc(PFN_DISPLAYWALLETADDRDIALOG_PROC * ppfnDialogProc)
{
    TCHAR   szDLLFile[MAX_PATH];
    DWORD   dwType;
    DWORD   dwSize = SIZEOF(szDLLFile);
    HINSTANCE hInst = NULL;

    *ppfnDialogProc = NULL;
    if (ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, g_szWalletAddressDirKey, NULL, &dwType, (LPVOID)szDLLFile, &dwSize))
    {
        hInst = LoadLibrary(szDLLFile);
        // Will Fail if OCX is not installed.
        if (hInst)
        {
            *ppfnDialogProc = (PFN_DISPLAYWALLETADDRDIALOG_PROC) GetProcAddress(hInst, g_szWalletAddressFN);
        }
    }

    if (!*ppfnDialogProc && hInst)
    {
        FreeLibrary(hInst);
        hInst = NULL;
    }

    return hInst;
}

BOOL IsWallet3Installed()
{
    HINSTANCE hInst;
    PFN_DISPLAYWALLETADDRDIALOG_PROC pfnDialogProc;
    BOOL fWallet3 = FALSE;
    
    hInst = GetWalletAddressDProc(&pfnDialogProc);
    if (hInst)
    {
        CHAR chPath[MAX_PATH];
        
        if (GetModuleFileNameA(hInst, chPath, ARRAYSIZE(chPath)))
        {
            DWORD dwMSVer, dwLSVer;
            
            if (SUCCEEDED(GetVersionFromFile(chPath, &dwMSVer, &dwLSVer, TRUE)))
            {
                if (dwMSVer >= 3)
                {
                    fWallet3 = TRUE;
                }
            }
        }
        
        FreeLibrary(hInst);
    }

    return fWallet3;
}

BOOL IsWalletAddressAvailable(VOID)
{
    HINSTANCE hInst;
    PFN_DISPLAYWALLETADDRDIALOG_PROC pfnDialogProc;
    BOOL fIsAvailable = FALSE;

    hInst = GetWalletAddressDProc(&pfnDialogProc);
    if (hInst)
    {
        fIsAvailable = TRUE;
        FreeLibrary(hInst);
    }

    return fIsAvailable;
}

VOID DisplayWalletAddressDialog(HWND hWnd)
{
    HINSTANCE hInst;
    PFN_DISPLAYWALLETADDRDIALOG_PROC pfnDialogProc;

    hInst = GetWalletAddressDProc(&pfnDialogProc);
    if (hInst)
    {
        (*pfnDialogProc)(hWnd, NULL, NULL, 0);
        FreeLibrary(hInst);
    }
}
#endif // WALLET

//
//
//
// "Programs" Tab
//
//
//


//
// RegPopulateComboBox()
//
// Takes an open HKEY (hkeyProtocol) and populates hwndCB with the friendly
// names of clients. The currently selected client is the "(default)" key of
// hkeyProtocol. The clients are sub-keys under the open key. The friendly
// names of the clients are in the "(default)" value of these sub-keys. This
// function also makes the currently selected client the selected item in
// hwndCB and returns the index number to the item.
//
// History:
//
// 7/ 8/96  t-gpease    created
//
UINT RegPopulateComboBox(HWND hwndCB, HKEY hkeyProtocol)
{
    TCHAR           szFriendlyName      [MAX_PATH];
    TCHAR           szKeyName           [MAX_PATH];
    TCHAR           szCurrent           [MAX_PATH];
    TCHAR           szFriendlyCurrent   [MAX_PATH];
    FILETIME        ftLastWriteTime;

    DWORD   i;              // Index counter

    HKEY    hkeyClient;
    DWORD   cb;

    // find the currently selected client
    cb = sizeof(szCurrent);
    if (RegQueryValueEx(hkeyProtocol, NULL, NULL, NULL, (LPBYTE)szCurrent, &cb)
        != ERROR_SUCCESS)
    {
        // if not found then blank the friendly name and keyname.
        szCurrent[0]=0;
        szFriendlyCurrent[0]=0;
    }

    // populate the dropdown
    for(i=0;                    // always start with 0
        cb=ARRAYSIZE(szKeyName),   // string size
        ERROR_SUCCESS==RegEnumKeyEx(hkeyProtocol, i, szKeyName, &cb, NULL, NULL, NULL, &ftLastWriteTime);
        i++)                    // get next entry
    {
        // get the friendly name of the client
        if (RegOpenKeyEx(hkeyProtocol, szKeyName, 0, KEY_READ, &hkeyClient)==ERROR_SUCCESS)
        {
            cb = sizeof(szFriendlyName);
            if (RegQueryValueEx(hkeyClient, NULL, NULL, NULL, (LPBYTE)szFriendlyName, &cb)
                == ERROR_SUCCESS)
            {
                // add name to dropdown
                SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM)szFriendlyName);

                // check to see if it's the current default
                if (!StrCmp(szKeyName, szCurrent))
                {
                    // save its the friendly name which we'll use later to
                    // select the current client and what index it is.
                    StrCpyN(szFriendlyCurrent, szFriendlyName, ARRAYSIZE(szFriendlyCurrent));
                }
            }

            // close key
            RegCloseKey(hkeyClient);
        }

    }   // for

    // select current client and get index number... just in case listboxes are sorted we
    // are doing this last.
    return (unsigned int) SendMessage(hwndCB, CB_SELECTSTRING, (WPARAM) 0, (LPARAM) szFriendlyCurrent);
}   // RegPopulateComboBox()

//
// Adds the item and its associated HKEY in the combobox.  Stores the hkey
// as data associated with the item. Frees hkey if the item is already present
// or if an error occurs.
//
BOOL AddItemToEditorsCombobox
(
    HWND hwndCB, 
    LPTSTR pszFriendlyName, // friendly name of the app
    HKEY hkey               // location of assoc shell\edit verb
)
{
    ASSERT(pszFriendlyName);
    ASSERT(hkey);

    BOOL fRet = FALSE;

    // Only add if not already in combo
    if (SendMessage(hwndCB, CB_FINDSTRINGEXACT, -1, (LPARAM)pszFriendlyName) == CB_ERR)
    {
        // Add name to dropdown
        INT_PTR i = SendMessage(hwndCB, CB_ADDSTRING, 0, (LPARAM)pszFriendlyName);
        if (i >= 0)
        {
            fRet = (SendMessage(hwndCB, CB_SETITEMDATA, i, (LPARAM)hkey) != CB_ERR);
        }
    }

    if (!fRet)
    {
        RegCloseKey(hkey);
    }
    return fRet;
}

//
// Adds the edit verb to the OpenWithList associated with .htm files.
//
void AddToOpenWithList(LPCTSTR pszFriendly, HKEY hkeyFrom, HKEY hkeyOpenWithList)
{
    ASSERT(pszFriendly);
    ASSERT(hkeyFrom);

    if (NULL == hkeyOpenWithList)
    {
        return;
    }

    TCHAR szBuf[MAX_PATH];
    StrCpyN(szBuf, pszFriendly, ARRAYSIZE(szBuf));
    StrCatBuff(szBuf, TEXT("\\shell\\edit"), ARRAYSIZE(szBuf));

    DWORD dwDisposition;
    HKEY hkeyDest;
    if (hkeyOpenWithList &&
        ERROR_SUCCESS == RegCreateKeyEx(hkeyOpenWithList, szBuf, 0,
                            NULL, 0, KEY_READ | KEY_WRITE, NULL, &hkeyDest, &dwDisposition))
    {
        // Copy everything under shell if this item did not exist
        if (dwDisposition == REG_CREATED_NEW_KEY)
        {
            SHCopyKey(hkeyFrom, L"shell\\edit", hkeyDest, 0); 
        }
        RegCloseKey(hkeyDest);
    }
}

//
// Returns TRUE if the verb
//
BOOL IsHtmlStub
(
    HKEY hkeyVerb,  // reg location of the shell\verb\command
    LPCWSTR pszVerb // verb to check for ("edit" or "open")
)
{
    BOOL fRet = FALSE;

    // We don't display programs that are simple redirectors (such as Office's msohtmed.exe)
    TCHAR sz[MAX_PATH];
    if (SUCCEEDED(AssocQueryStringByKey(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, hkeyVerb, pszVerb, sz, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(sz)))))
    {
        // Get the MULTISZ list of known redirectors 
        TCHAR szRedir[MAX_PATH];
        ZeroMemory(szRedir, sizeof(szRedir)); // Protect against non-multisz strings in the reg
        DWORD dwType;
        DWORD cb = sizeof(szRedir) - 4;
        if (ERROR_SUCCESS != SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_DEFAULT_HTML_EDITOR, L"Stubs", &dwType, szRedir, &cb))
        {
            // Nothing in registry, so default to ignore the Office redirector
            StrCpyN(szRedir, L"msohtmed.exe\0", ARRAYSIZE(szRedir));
        }

        // Compare exe name with list of redirectors 
        LPCTSTR pszFile = PathFindFileName(sz);
        for (LPTSTR p = szRedir; *p != NULL; p += lstrlen(p) + 1)
        {
            if (StrCmpI(p, pszFile) == 0)
            {
                fRet = TRUE;
                break;
            }
        }
    }
    return fRet;
}


BOOL GetAppKey(LPCWSTR pszApp, HKEY *phkApp)
{
    ASSERT(pszApp && *pszApp);
    WCHAR szKey[MAX_PATH];
    StrCpy(szKey, L"Applications\\");
    StrCatBuff(szKey, pszApp, SIZECHARS(szKey));

    return (NOERROR == RegOpenKeyEx(
        HKEY_CLASSES_ROOT,
        szKey,
        0L,
        MAXIMUM_ALLOWED,
        phkApp));
}

//
// Adds the html editors to the combobox. Looks for edit verbs associated
// with the .htm extension, the .htm OpenWithList, and the current default
// editor.
//
void PopulateEditorsCombobox(HWND hwndCB)
{
    //
    // Add items from the OpenWithList for .htm
    //
    DWORD dw;
    HKEY hkeyOpenWithList = NULL;
    TCHAR szOpenWith[MAX_PATH];
    if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CLASSES_ROOT, L".htm\\OpenWithList", 0,
                            NULL, 0, KEY_READ | KEY_WRITE, NULL, &hkeyOpenWithList, &dw))
    {
        //
        // First enumerate the entries in the OpenWithList
        //
        HKEY hkeyOpenWith = NULL;
        DWORD dwIndex = 0;
        DWORD dwSize = ARRAYSIZE(szOpenWith);
        while (ERROR_SUCCESS == RegEnumKeyEx(hkeyOpenWithList, dwIndex, szOpenWith, &dwSize, NULL, NULL, NULL, NULL))
        {
            if (GetAppKey(szOpenWith, &hkeyOpenWith))
            {
                // We only accept items that have an edit verb
                TCHAR sz[MAX_PATH];
                if (SUCCEEDED(AssocQueryStringByKey(ASSOCF_VERIFY, ASSOCSTR_FRIENDLYAPPNAME, hkeyOpenWith, L"edit", sz, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(sz)))))
                {
                    // Note that we store hkeyOpenWith in the combo so don't close it
                    AddItemToEditorsCombobox(hwndCB, sz, hkeyOpenWith);
                }
                else
                {
                    RegCloseKey(hkeyOpenWith);
                }
            }

            ++dwIndex;
            dwSize = ARRAYSIZE(szOpenWith);
        }

        // hkeyOpenWithList is closed below
    }

    //
    // Add the editor associated with .htm
    //
    HKEY hkeyHtm;

    //  FEATURE - should use AssocCreate(IQueryAssociations) here instead
    if (SUCCEEDED(AssocQueryKey(0, ASSOCKEY_SHELLEXECCLASS, L".htm", NULL, &hkeyHtm)))
    {
        TCHAR sz[MAX_PATH];
        if (!IsHtmlStub(hkeyHtm, L"edit") &&
             SUCCEEDED(AssocQueryStringByKey(ASSOCF_VERIFY, ASSOCSTR_FRIENDLYAPPNAME, hkeyHtm, L"edit", sz, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(sz)))))
        {
            AddItemToEditorsCombobox(hwndCB, sz, hkeyHtm);
            AddToOpenWithList(sz, hkeyHtm, hkeyOpenWithList);

            // Don't free the key we cached away
            hkeyHtm = NULL;
        }
        
        if (hkeyHtm)
        {
            RegCloseKey(hkeyHtm);
        }
    }

    //
    //  Get the default editor.  We check both hkcu & hklm.
    //
    HKEY hkeyDefault;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_DEFAULT_HTML_EDITOR, 0, KEY_READ, &hkeyDefault) ||
        ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_DEFAULT_HTML_EDITOR, 0, KEY_READ, &hkeyDefault))
    {
        TCHAR sz[MAX_PATH];
        if (SUCCEEDED(AssocQueryStringByKey(ASSOCF_VERIFY, ASSOCSTR_FRIENDLYAPPNAME, hkeyDefault, L"edit", sz, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(sz)))))
        {
            // Add name to dropdown and save hkeyDefault in the combobox (so don't close it)
            AddItemToEditorsCombobox(hwndCB, sz, hkeyDefault);

            // Select this item
            SendMessage(hwndCB, CB_SELECTSTRING, -1, (LPARAM)sz);

            //
            // Make sure the default editor is in the htm OpenWithList so it doesn't dissapear
            // if we change it
            //
            AddToOpenWithList(sz, hkeyDefault, hkeyOpenWithList);
        }
        else
        {
            RegCloseKey(hkeyDefault);
        }

    }

    if (hkeyOpenWithList)
    {
        RegCloseKey(hkeyOpenWithList);
    }
}
    

//
// ProgramsDlgInit()
//
// Does initalization for Programs Dlg.
//

// History:
//
// 6/17/96  t-gpease   created
// 7/ 8/96  t-gpease   added Mail and News initialization
//
BOOL ProgramsDlgInit( HWND hDlg)
{
    LPPROGRAMSPAGE  pPrg;
    DWORD           dw;
    HKEY            hkey;

    pPrg = (LPPROGRAMSPAGE)LocalAlloc(LPTR, sizeof(*pPrg));
    if (!pPrg)
    {
        EndDialog(hDlg, 0);
        return FALSE;   // no memory?
    }

    // tell dialog where to get info
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pPrg);

    // save the handle to the page
    pPrg->hDlg = hDlg;

    //
    // Set default values.
    //

    pPrg->bAssociationCheck = TRUE;     // we want everybody to use IE!
    SUCCEEDED(CoCreateInstance(CLSID_FtpInstaller, NULL, CLSCTX_INPROC_SERVER, IID_IFtpInstaller, (void **) &pPrg->pfi));
    if (pPrg->pfi)
        pPrg->bIEIsFTPClient = ((S_OK == pPrg->pfi->IsIEDefautlFTPClient()) ? TRUE : FALSE);

    pPrg->iMail = -1;                   // nothing selected
    pPrg->iNews = -1;                   // nothing selected

    pPrg->bAssociationCheck = SHRegGetBoolUSValue(REGSTR_PATH_MAIN,REGSTR_VAL_CHECKASSOC,FALSE,TRUE);

    //
    // Get the html editors
    //
    pPrg->hwndHtmlEdit = GetDlgItem(pPrg->hDlg, IDC_PROGRAMS_HTMLEDITOR_COMBO);
    PopulateEditorsCombobox(pPrg->hwndHtmlEdit);
    // Sundown: coercion to int because 32b is sufficient for cursor selection
    pPrg->iHtmlEditor = (int) SendMessage(pPrg->hwndHtmlEdit, CB_GETCURSEL, 0, 0);


    //
    // Get the Mail Clients
    //
    pPrg->hwndMail = GetDlgItem(pPrg->hDlg, IDC_PROGRAMS_MAIL_COMBO);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_MAILCLIENTS,
                       0, NULL, 0, KEY_READ, NULL, &hkey, &dw) == ERROR_SUCCESS)
    {
        // populate the combobox
        pPrg->iMail = RegPopulateComboBox(pPrg->hwndMail, hkey);

        // close the keys
        RegCloseKey(hkey);
    }

    //
    // Get the News Clients
    //
    pPrg->hwndNews = GetDlgItem(pPrg->hDlg, IDC_PROGRAMS_NEWS_COMBO);

    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_NEWSCLIENTS,
                       0, NULL, 0, KEY_READ, NULL, &hkey, &dw) == ERROR_SUCCESS)
    {
        // populate the combobox
        pPrg->iNews = RegPopulateComboBox(pPrg->hwndNews, hkey);

        // close the keys
        RegCloseKey(hkey);
    }

    //
    // get the calendar clients
    //
    pPrg->hwndCalendar = GetDlgItem(pPrg->hDlg, IDC_PROGRAMS_CALENDAR_COMBO);
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_CALENDARCLIENTS,
                       0, NULL, 0, KEY_READ, NULL, &hkey, &dw) == ERROR_SUCCESS)
    {
        // populate the combobox
        pPrg->iCalendar = RegPopulateComboBox(pPrg->hwndCalendar, hkey);

        // close the keys
        RegCloseKey(hkey);
    }

    //
    // get the contacts clients
    //
    pPrg->hwndContact = GetDlgItem(pPrg->hDlg, IDC_PROGRAMS_CONTACT_COMBO);
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_CONTACTCLIENTS,
                       0, NULL, 0, KEY_READ, NULL, &hkey, &dw) == ERROR_SUCCESS)
    {
        // populate the combobox
        pPrg->iContact = RegPopulateComboBox(pPrg->hwndContact, hkey);

        // close the keys
        RegCloseKey(hkey);
    }

    //
    // get the internet call clients
    //
    pPrg->hwndCall = GetDlgItem(pPrg->hDlg, IDC_PROGRAMS_CALL_COMBO);
    if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, REGSTR_PATH_CALLCLIENTS,
                       0, NULL, 0, KEY_READ, NULL, &hkey, &dw) == ERROR_SUCCESS)
    {
        // populate the combobox
        pPrg->iCall = RegPopulateComboBox(pPrg->hwndCall, hkey);

        // close the keys
        RegCloseKey(hkey);
    }

    // Set dialog items
    CheckDlgButton(hDlg, IDC_CHECK_ASSOCIATIONS_CHECKBOX, pPrg->bAssociationCheck);

    HRESULT hrIEDefaultFTPClient = E_FAIL;
    if (pPrg->pfi)
    {
        hrIEDefaultFTPClient = pPrg->pfi->IsIEDefautlFTPClient();
        // Is this option not applicable because only the IE FTP client is installed?
        if (SUCCEEDED(hrIEDefaultFTPClient))
            CheckDlgButton(hDlg, IDC_PROGRAMS_IE_IS_FTPCLIENT, pPrg->bIEIsFTPClient);
    }
    if (FAILED(hrIEDefaultFTPClient))
    {
        // Yes, so remove the option.
        ShowWindow(GetDlgItem(hDlg, IDC_PROGRAMS_IE_IS_FTPCLIENT), SW_HIDE);
    }


    if( g_restrict.fMailNews )
    {
        EnableWindow( GetDlgItem(hDlg, IDC_PROGRAMS_MAIL_COMBO), FALSE);
        EnableWindow( GetDlgItem(hDlg, IDC_PROGRAMS_NEWS_COMBO), FALSE);
        EnableWindow( GetDlgItem(hDlg, IDC_PROGRAMS_CALL_COMBO), FALSE);
    }

    if ( g_restrict.fCalContact )
    {
        EnableWindow( GetDlgItem(hDlg, IDC_PROGRAMS_CALENDAR_COMBO), FALSE);
        EnableWindow( GetDlgItem(hDlg, IDC_PROGRAMS_CONTACT_COMBO), FALSE);
    }

    EnableWindow( GetDlgItem(hDlg, IDC_RESETWEBSETTINGS), !g_restrict.fResetWebSettings );
    EnableWindow( GetDlgItem(hDlg, IDC_CHECK_ASSOCIATIONS_CHECKBOX), !g_restrict.fDefault );

    return TRUE;    // success

} // ProgramsDlgInit()

//
// RegCopyKey()
//
// Copies all the keys from hkeySrc down into hkeyRoot:pszDest.
//
// History:
//
// 7/ 8/96  t-gpease    created
//
void RegCopyKey(HKEY hkeyRoot, const TCHAR *pszDest, HKEY hkeySrc)
{
    HKEY    hkeyDest;
    HKEY    hkey;
    DWORD   dw;
    DWORD   i;
    DWORD   cb;
    DWORD   cbData;
    DWORD   Type;
    TCHAR   szName[MAX_PATH];
    TCHAR   szData[MAX_URL_STRING+1];

    // open/create the destination key
    if (RegCreateKeyEx(hkeyRoot, pszDest,
                       NULL, 0, NULL, KEY_READ|KEY_WRITE, NULL, &hkeyDest, &dw) == ERROR_SUCCESS)
    {
        i=0;
        // copy values of the key
        while(1)
        {
            // find next value
            cb=ARRAYSIZE(szName);
            cbData=sizeof(szData);
            if (RegEnumValue(hkeySrc, i, szName, &cb, NULL, &Type, (LPBYTE)&szData, &cbData)!=ERROR_SUCCESS)
                break;  // not found... exit loop

            // make a copy of the value in new location
            RegSetValueEx(hkeyDest, szName, NULL, Type, (CONST BYTE *)szData, cbData);


            // increase index count
            i++;

        }   // while

        // look for more sub-keys in the source
        for(i=0;
            cb=ARRAYSIZE(szName),
            RegEnumKey(hkeySrc, i, szName, cb)==ERROR_SUCCESS;
            i++)
        {
            // open the sub-key
            if (RegCreateKeyEx(hkeySrc, szName,
                               NULL, 0, NULL, KEY_READ, NULL, &hkey, &dw) == ERROR_SUCCESS)
            {
                // copy the sub-key
                RegCopyKey(hkeyDest, szName, hkey);

                // close the key
                RegCloseKey(hkey);

            }   // if RegCreateKey()

        }   // for

        // close the key
        RegCloseKey(hkeyDest);

    }   // if RegCreateKey()

} // RegCopyKey()

//
// CopyInfoTo()
//
// Copies the information needed to run a mailto: or news: protocol
//
// History:
//
// 7/ 8/96  t-gpease    created
//
void CopyInfoTo(const TCHAR *pszKeyName, HKEY hkeyClient)
{
    HKEY    hkey;
    TCHAR   szName[MAX_PATH];

    // create the protocol sub-key path
    StrCpyN(szName, TSZPROTOCOLSPATH, ARRAYSIZE(szName));
    int len = lstrlen(szName);
    StrCpyN(szName + len, pszKeyName, ARRAYSIZE(szName) - len);

    // make sure it has the protocol we are looking for
    if (RegOpenKeyEx(hkeyClient, szName, NULL, KEY_READ|KEY_WRITE, &hkey)
        ==ERROR_SUCCESS)
    {
        // Netscape Messenger registry patch: they are missing "URL Protocol" in the HKLM mailto branch 
        // and we should set this value, otherwise we get the 68992 bug.  The source is changed rather 
        // than the destination to protect against other programs copying the tree without the value.
        // Might as well check this for all clients rather than look for Netscape, since we don't
        // change any data if it exists.

        if (lstrcmpi(pszKeyName, TSZMAILTOPROTOCOL) == 0 && 
            RegQueryValueEx(hkey, TEXT("URL Protocol"), NULL, NULL, NULL, NULL) != ERROR_SUCCESS) 
        {    
            RegSetValueEx(hkey, TEXT("URL Protocol"), 0, REG_SZ, (BYTE *) TEXT(""), sizeof(TCHAR));
        }

        // start by deleting all the old info
        if ( lstrcmpi(pszKeyName, TSZLDAPPROTOCOL) )
            SHDeleteKey(HKEY_CLASSES_ROOT, pszKeyName);

        // recreate key and copy the protocol info
        RegCopyKey(HKEY_CLASSES_ROOT, pszKeyName, hkey);

        // close the key
        RegCloseKey(hkey);

    }   // if RegOpenKey()

}   // CopyInfoTo()


//
// FindClient()
//
// Finds the currently selected item in hwndComboBox and locates it
// in the szPath's subkeys. If found it will then make a call to copy
// the information to szProtocol key under HKCR.
//
// History:
//
// 7/ 8/96  t-gpease    created
//
void FindClient(LPCTSTR szProtocol, HWND hwndComboBox, int iSelected, LPCTSTR szPath)
{
    TCHAR           szFriendlyName[MAX_PATH];
    TCHAR           szKeyName[MAX_PATH];
    TCHAR           szCurrent[MAX_PATH];
    FILETIME        ftLastWriteTime;

    DWORD   i;              // Index counter
    HKEY    hkeyClient;
    HKEY    hkey;
    DWORD   dw;

    // get the name of the new client
    if (CB_ERR!=SendMessage(hwndComboBox, CB_GETLBTEXT, (WPARAM)iSelected, (LPARAM)szCurrent))
    {
        // got the friendly name... now lets find the internal name
        if (RegCreateKeyEx(HKEY_LOCAL_MACHINE, szPath,
                           0, NULL, 0, KEY_READ|KEY_WRITE, NULL, &hkey, &dw) == ERROR_SUCCESS)
        {
            DWORD   cb;

            // we must search all the sub-keys for the correct friendly name
            for(i=0;                    // always start with 0
                cb=ARRAYSIZE(szKeyName),   // string size
                ERROR_SUCCESS==RegEnumKeyEx(hkey, i, szKeyName, &cb, NULL, NULL, NULL, &ftLastWriteTime);
                i++)                    // get next entry
            {
                // get more info on the entry
                if (RegOpenKeyEx(hkey, szKeyName, 0, KEY_READ, &hkeyClient)==ERROR_SUCCESS)
                {
                    // get the friendly name of the client
                    cb = sizeof(szFriendlyName);
                    if (RegQueryValueEx(hkeyClient, NULL, NULL, NULL, (LPBYTE)szFriendlyName, &cb)
                        == ERROR_SUCCESS)
                    {
                        // is it the one we are looking for?
                        if (!StrCmp(szFriendlyName, szCurrent))
                        {
                            // yep... copy its info
                            CopyInfoTo(szProtocol, hkeyClient);

                            // make it the default handler
                            cb = (lstrlen(szKeyName) + 1)*sizeof(TCHAR);
                            RegSetValueEx(hkey, NULL, NULL, REG_SZ, (LPBYTE)szKeyName, cb);
                        }
                    }

                    // close key
                    RegCloseKey(hkeyClient);

                }   // if RegOpenKey()

            }   // for

            // close the keys
            RegCloseKey(hkey);

        }   // if RegCreateKeyEx()
    }
}   // FindClient()

//
// ProgramsDlgApplyNow()
//
// Enters "Programs" changes into registry.
//
// History:
//
// 6/20/96  t-gpease    created
// 7/ 8/96  t-gpease    added Mail and News
//
void ProgramsDlgApplyNow(LPPROGRAMSPAGE pPrg)
{
    int tmp;

    if (pPrg->fChanged)
    {
        // Did the user have a chance to change this option?
        if (pPrg->pfi)
        {
            HRESULT hrIEDefaultFTPClient = pPrg->pfi->IsIEDefautlFTPClient();
            if (IsWindowVisible(GetDlgItem(pPrg->hDlg, IDC_PROGRAMS_IE_IS_FTPCLIENT)))
            {
                // Yes, so see if they changed it.
                pPrg->bIEIsFTPClient = IsDlgButtonChecked(pPrg->hDlg, IDC_PROGRAMS_IE_IS_FTPCLIENT);

                // Did they user want IE as default and currently someone else is?
                if (pPrg->bIEIsFTPClient && (S_FALSE == hrIEDefaultFTPClient))
                    pPrg->pfi->MakeIEDefautlFTPClient();

                // Did they user NOT want IE as default and it currently is?
                if (!pPrg->bIEIsFTPClient && (S_OK == hrIEDefaultFTPClient))
                    pPrg->pfi->RestoreFTPClient();
            }
        }

        pPrg->bAssociationCheck = IsDlgButtonChecked(pPrg->hDlg, IDC_CHECK_ASSOCIATIONS_CHECKBOX);
        TCHAR szYesNo[5];

        StrCpyN(szYesNo, (pPrg->bAssociationCheck ? TEXT("yes") : TEXT("no")), ARRAYSIZE(szYesNo));

        SHRegSetUSValue(REGSTR_PATH_MAIN,
                        REGSTR_VAL_CHECKASSOC,
                        REG_SZ,
                        (LPVOID)szYesNo,
                        (lstrlen(szYesNo)+1)*sizeof(TCHAR),
                        SHREGSET_DEFAULT);
        //
        // Save the new default editor
        //
        // See if the selection was changed
        tmp = (int) SendMessage(pPrg->hwndHtmlEdit, CB_GETCURSEL, 0, 0);
        if (tmp != pPrg->iHtmlEditor)
        {
            pPrg->iHtmlEditor = tmp;

            // Get the text and hkey for the selected item
            WCHAR szDefault[MAX_PATH];
            SendMessage(pPrg->hwndHtmlEdit, CB_GETLBTEXT, tmp, (LPARAM)szDefault);
            HKEY hkeyFrom = (HKEY)SendMessage(pPrg->hwndHtmlEdit, CB_GETITEMDATA, tmp, 0);

            if (hkeyFrom && (INT_PTR)hkeyFrom != CB_ERR)
            {
                //
                // Save the selected item as the default editor
                //
                DWORD dw;
                HKEY hkeyDest;
                if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_DEFAULT_HTML_EDITOR, 0,
                        NULL, 0, KEY_READ | KEY_WRITE, NULL, &hkeyDest, &dw))
                {
                    // Update the name of the default editor
                    SHSetValue(hkeyDest, NULL, L"Description", REG_SZ, szDefault, CbFromCch(lstrlen(szDefault)+1));

                    // Delete the old shell command (and all subkeys).  This purges keys such as DDEEXEC.
                    SHDeleteKey(hkeyDest, L"shell");

                    // Update the verb of the default editor
                    HKEY hkeyEdit;
                    if (ERROR_SUCCESS == RegCreateKeyEx(hkeyDest, L"shell\\edit", 0,
                            NULL, 0, KEY_READ | KEY_WRITE, NULL, &hkeyEdit, &dw))
                    {
                        SHCopyKey(hkeyFrom, L"shell\\edit", hkeyEdit, 0);
                        RegCloseKey(hkeyEdit);
                    }
                    RegCloseKey(hkeyDest);
                }

                //
                // Also update Office's default editor
                //
                if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_CURRENT_USER, L"Software\\Microsoft\\Shared\\HTML\\Default Editor", 0,
                        NULL, 0, KEY_READ | KEY_WRITE, NULL, &hkeyDest, &dw))
                {
                    // Delete the old shell command (and all subkeys).  This purges keys such as DDEEXEC.
                    SHDeleteKey(hkeyDest, L"shell\\edit");

                    // Update the verb of the default editor
                    HKEY hkeyEdit;
                    if (ERROR_SUCCESS == RegCreateKeyEx(hkeyDest, L"shell\\edit", 0,
                            NULL, 0, KEY_READ | KEY_WRITE, NULL, &hkeyEdit, &dw))
                    {
                        SHCopyKey(hkeyFrom, L"shell\\edit", hkeyEdit, 0);
                        RegCloseKey(hkeyEdit);
                    }
                    RegCloseKey(hkeyDest);
                }

                //
                // Finally, update the edit verb for .htm files so that the shell honors the change.
                // But if .htm uses a stub like moshtmed, we leave it alone and assume that it
                // uses one of the above keys as the default editor.
                //
                HKEY hkeyHtm;
                if (SUCCEEDED(AssocQueryKey(0, ASSOCKEY_SHELLEXECCLASS, L".htm", NULL, &hkeyHtm)))
                {
                    if (!IsHtmlStub(hkeyHtm, L"edit"))
                    {
                        // Delete the old shell command (and all subkeys).  This purges keys such as DDEEXEC.
                        SHDeleteKey(hkeyHtm, L"shell\\edit");

                        // Copy the edit verb to the .htm
                        HKEY hkeyEdit;
                        if (ERROR_SUCCESS == RegCreateKeyEx(hkeyHtm, L"shell\\edit", 0,
                                NULL, 0, KEY_READ | KEY_WRITE, NULL, &hkeyEdit, &dw))
                        {
                            SHCopyKey(hkeyFrom, L"shell\\edit", hkeyEdit, 0);
                            RegCloseKey(hkeyEdit);
                        }
                    }
    
                    RegCloseKey(hkeyHtm);
                }
            }
        }

        //
        // Save Mail Client Info
        //

        // is there a new client?
        tmp = (int) SendMessage(pPrg->hwndMail, CB_GETCURSEL, 0, 0);
        if (tmp!=pPrg->iMail)
        {
            pPrg->iMail = tmp;

            // find it and copy its info
            FindClient(TSZMAILTOPROTOCOL, pPrg->hwndMail, tmp, REGSTR_PATH_MAILCLIENTS);

            //Update the mail icon label
            UpdateMailIconLabel();
            // tell the world that something has changed
            SendBroadcastMessage(WM_WININICHANGE, 0, (LPARAM)REGSTR_PATH_MAILCLIENTS);
        }

        //
        // Save News Client Info
        //

        // is there a new client?
        tmp = (int) SendMessage(pPrg->hwndNews, CB_GETCURSEL, 0, 0);
        if (tmp!=pPrg->iNews)
        {
            pPrg->iNews = tmp;

            // find it and copy its info
            FindClient(TSZNEWSPROTOCOL, pPrg->hwndNews, tmp, REGSTR_PATH_NEWSCLIENTS);
            FindClient(TEXT("snews"), pPrg->hwndNews, tmp, REGSTR_PATH_NEWSCLIENTS);
            FindClient(TEXT("nntp"), pPrg->hwndNews, tmp, REGSTR_PATH_NEWSCLIENTS);

            // tell the world that something has changed
            SendBroadcastMessage(WM_WININICHANGE, 0, (LPARAM)REGSTR_PATH_NEWSCLIENTS);
        }

        //
        // Save Internet Call Client info
        //

        // is there a new client?
        tmp = (int) SendMessage(pPrg->hwndCall, CB_GETCURSEL, 0, 0);
        if (tmp!=pPrg->iCall)
        {
            pPrg->iCall = tmp;

            // find it and copy its info
            FindClient(TSZCALLTOPROTOCOL, pPrg->hwndCall, tmp, REGSTR_PATH_CALLCLIENTS);

            // tell the world that something has changed
            SendBroadcastMessage(WM_WININICHANGE, 0, (LPARAM)REGSTR_PATH_CALLCLIENTS);
        }
        //
        // Save Contacts Client Info
        //

        // is there a new client?
        tmp = (int) SendMessage(pPrg->hwndContact, CB_GETCURSEL, 0, 0);
        if (tmp!=pPrg->iContact)
        {
            pPrg->iContact = tmp;

            // find it and copy its info
            FindClient(TSZLDAPPROTOCOL, pPrg->hwndContact, tmp, REGSTR_PATH_CONTACTCLIENTS);

            // tell the world that something has changed
            SendBroadcastMessage(WM_WININICHANGE, 0, (LPARAM)REGSTR_PATH_CONTACTCLIENTS);
        }

        //
        // Save Calendar Client Info
        //

        // is there a new client?
        tmp = (int) SendMessage(pPrg->hwndCalendar, CB_GETCURSEL, 0, 0);
        if (tmp!=pPrg->iCalendar)
        {
            pPrg->iCalendar = tmp;

            // find it and copy its info
            FindClient(TSZCALENDARPROTOCOL, pPrg->hwndCalendar, tmp, REGSTR_PATH_CALENDARCLIENTS);

            // tell the world that something has changed
            SendBroadcastMessage(WM_WININICHANGE, 0, (LPARAM)REGSTR_PATH_CALENDARCLIENTS);
        }
        UpdateAllWindows();
        pPrg->fChanged = FALSE;
    }
} // ProgramsDlgApplyNow()

    
extern HRESULT ResetWebSettings(HWND hwnd, BOOL *pfChangedHomePage);

//
// ProgramsOnCommand()
//
// Handles "Programs" property page's window commands
//
// History:
//
// 6/20/96  t-gpease    created
//
void ProgramsOnCommand(LPPROGRAMSPAGE pPrg, UINT id, UINT nCmd)
{

    switch (id) {

        case IDC_PROGRAMS_HTMLEDITOR_COMBO:
        {
            INT_PTR tmp;

            // Is there a new editor?
            tmp = SendMessage(pPrg->hwndHtmlEdit, CB_GETCURSEL, 0, 0);
            if (tmp != pPrg->iHtmlEditor)
            {
                ENABLEAPPLY(pPrg->hDlg);
                pPrg->fChanged = TRUE;
            }
        }
        break;

        case IDC_PROGRAMS_NEWS_COMBO:
        {
            INT_PTR tmp;
            // is there a new client?
            tmp = SendMessage(pPrg->hwndNews, CB_GETCURSEL, 0, 0);
            if (tmp != pPrg->iNews)
            {
                ENABLEAPPLY(pPrg->hDlg);
                pPrg->fChanged = TRUE;
            }
        }
        break;


        case IDC_PROGRAMS_MAIL_COMBO:
        {
            INT_PTR tmp;
            // is there a new client?
            tmp = SendMessage(pPrg->hwndMail, CB_GETCURSEL, 0, 0);
            if (tmp != pPrg->iMail)
            {
                ENABLEAPPLY(pPrg->hDlg);
                pPrg->fChanged = TRUE;
            }
        }
        break;

        case IDC_PROGRAMS_CALENDAR_COMBO:
        {
            INT_PTR tmp;
            // is there a new client?
            tmp = SendMessage(pPrg->hwndCalendar, CB_GETCURSEL, 0, 0);
            if (tmp != pPrg->iCalendar)
            {
                ENABLEAPPLY(pPrg->hDlg);
                pPrg->fChanged = TRUE;
            }
        }
        break;

        case IDC_PROGRAMS_CONTACT_COMBO:
        {
            INT_PTR tmp;
            // is there a new client?
            tmp = SendMessage(pPrg->hwndContact, CB_GETCURSEL, 0, 0);
            if (tmp != pPrg->iContact)
            {
                ENABLEAPPLY(pPrg->hDlg);
                pPrg->fChanged = TRUE;
            }
        }
        break;

        case IDC_PROGRAMS_CALL_COMBO:
        {
            INT_PTR tmp;
            // is there a new client?
            tmp = SendMessage(pPrg->hwndCall, CB_GETCURSEL, 0, 0);
            if (tmp != pPrg->iCall)
            {
                ENABLEAPPLY(pPrg->hDlg);
                pPrg->fChanged = TRUE;
            }
        }
        break;

        case IDC_RESETWEBSETTINGS:
            {
                BOOL fReloadHomePage;
                ResetWebSettings(pPrg->hDlg,&fReloadHomePage);
                if (fReloadHomePage)
                    g_fReloadHomePage = TRUE;
            }
            break;

        case IDC_PROGRAMS_IE_IS_FTPCLIENT:
        case IDC_CHECK_ASSOCIATIONS_CHECKBOX:
            ENABLEAPPLY(pPrg->hDlg);
            pPrg->fChanged = TRUE;
            break;
    } // switch

} // ProgramsOnCommand()

//
// ProgramsDlgProc()
//
// Handles window messages sent to the Programs Property Sheet.
//
// History:
//
// 6/20/96  t-gpease    created
//
INT_PTR CALLBACK ProgramsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
                              LPARAM lParam)
{
    LPPROGRAMSPAGE pPrg;

    if (uMsg == WM_INITDIALOG)
        return ProgramsDlgInit( hDlg );
    else
        pPrg= (LPPROGRAMSPAGE) GetWindowLongPtr(hDlg, DWLP_USER);

    if (!pPrg)
        return FALSE;

    switch (uMsg) {

        case WM_COMMAND:
            ProgramsOnCommand(pPrg, LOWORD(wParam), HIWORD(wParam));
            return TRUE;

        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR *) lParam;

            ASSERT(lpnm);
            switch (lpnm->code)
            {
                case PSN_KILLACTIVE:
                case PSN_QUERYCANCEL:
                case PSN_RESET:
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);
                    return TRUE;

                case PSN_APPLY:
                    //
                    // Save Programs Dlg Stuff.
                    //
                    ProgramsDlgApplyNow(pPrg);
                    break;
            }
        }
        break;

        case WM_HELP:                   // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
        {
            // Free the data stored the HTML editor combo
            int iMax = (int) SendMessage(pPrg->hwndHtmlEdit, CB_GETCOUNT, 0, 0);
            HKEY hkey;
            for (int i = 0; i < iMax; ++i)
            {
                hkey = (HKEY) SendMessage(pPrg->hwndHtmlEdit, CB_GETITEMDATA, i, 0);
                if (hkey && (INT_PTR)hkey != CB_ERR)
                {
                    RegCloseKey(hkey);
                }
            }

            if (pPrg)
            {
                if (pPrg->pfi)
                    pPrg->pfi->Release();
                LocalFree(pPrg);
            }
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG)NULL);
            break;
        }
    }
    return FALSE;
}

static const TCHAR c_szMailIcon[] = TEXT("Software\\Microsoft\\MailIcon");
static const TCHAR c_szMailIconGuid[] = TEXT("CLSID\\{dacf95b0-0a3f-11d1-9389-006097d503d9}");
static const TCHAR c_szKeyMail[] = TEXT("Software\\Clients\\Mail");
static const TCHAR c_szRegFmt2[] = TEXT("%s\\%s");
static const TCHAR c_szFormatClient[] = TEXT("FormatClient");
static const TCHAR c_szFormatNoClient[] = TEXT("FormatNoClient");
static       WCHAR c_wszMailIconGuid[] = L"::{dacf95b0-0a3f-11d1-9389-006097d503d9}";

void UpdateMailIconLabel()
{
    TCHAR szOldLabel[MAX_PATH];
    TCHAR szNewLabel[MAX_PATH];
    TCHAR szDefClient[MAX_PATH];
    TCHAR szTemp[MAX_PATH];
    DWORD cbSize;
    HKEY  hKey;

    *szNewLabel = 0;
    *szOldLabel = 0;

    // check if the mail icon is even installed
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szMailIcon, 0, KEY_READ, &hKey))
    {
        cbSize = sizeof(szOldLabel);
        // get the current mail icon label
        if (ERROR_SUCCESS == RegQueryValue(HKEY_CLASSES_ROOT, c_szMailIconGuid, szOldLabel, (PLONG)&cbSize))
        {
            cbSize = sizeof(szDefClient);
            // get the default client's reg key
            if (ERROR_SUCCESS == RegQueryValue(HKEY_LOCAL_MACHINE, c_szKeyMail, szDefClient, (PLONG)&cbSize) && cbSize)
            {
                wnsprintf(szTemp, ARRAYSIZE(szTemp), c_szRegFmt2, c_szKeyMail, szDefClient);
                cbSize = sizeof(szDefClient);
                // get the default client's display name
                if (ERROR_SUCCESS == RegQueryValue(HKEY_LOCAL_MACHINE, szTemp, szDefClient, (PLONG)&cbSize) && cbSize)
                {
                    cbSize = sizeof(szTemp);
                    // get the mail icon label format string
                    if (ERROR_SUCCESS == RegQueryValueEx(hKey, c_szFormatClient, 0, NULL, (LPBYTE)szTemp, &cbSize))
                    {
                        wnsprintf(szNewLabel, ARRAYSIZE(szNewLabel), szTemp, szDefClient);
                    }
                }
            }
            else
            {
                cbSize = sizeof(szNewLabel);
                // get the mail icon label format string
                RegQueryValueEx(hKey, c_szFormatNoClient, 0, NULL, (LPBYTE)szNewLabel, &cbSize);
            }
        }
        // if the above succeeded, and the label is different
        if (*szNewLabel && StrCmp(szNewLabel, szOldLabel))
        {
             IShellFolder *psf;

            // set the new label
            RegSetValue(HKEY_CLASSES_ROOT, c_szMailIconGuid, REG_SZ, szNewLabel, (lstrlen(szNewLabel)+1)*sizeof(TCHAR));

            // let the shell know that it changed
            if (SUCCEEDED(SHGetDesktopFolder(&psf)))
            {
                LPITEMIDLIST pidl;
                ULONG        chEaten;

                if (SUCCEEDED(psf->ParseDisplayName(NULL, NULL, c_wszMailIconGuid, &chEaten, &pidl, NULL)))
                {
                    SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_IDLIST, pidl, NULL);
                    SHFree(pidl);
                }
                psf->Release();
            }
        }
        RegCloseKey(hKey);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\proxysup.cpp ===
/*++


Copyright (c) 1996  Microsoft Corporation

Module Name:

    proxysup.c

Abstract:

    Contains implementation for proxy server and proxy bypass list
    dialog interface.

    WARNING: Changes in this code need to be syncronizated
    with changes in proxysup.cxx in the WININET project.

    Contents:

Author:

    Arthur L Bierer (arthurbi) 18-Apr-1996

Revision History:

    18-Apr-1996 arthurbi
    Created

--*/

#include "inetcplp.h"

#include <mluisupp.h>

// Disable warning for VC6 (ASSERT macro causing the problem)
#pragma warning(4:4509) // nonstandard extension used: 'ftn' uses SEH and 'object' has destructor

//
// Don't use CRTs so define our own isdigit
//

#undef isdigit
#define isdigit(ch) (ch >= '0' && ch <= '9')

//
// ARRAY_ELEMENTS - returns number of elements in array
//

#define ARRAY_ELEMENTS(array)   (sizeof(array)/sizeof(array[0]))

#define GET_TERMINATOR(string)  while(*string != '\0') string++

#define IS_BLANK(string)        (*string == '\0')


//
// private types
//
typedef enum {
    STATE_START,
    STATE_PROTOCOL,
    STATE_SCHEME,
    STATE_SERVER,
    STATE_PORT,
    STATE_END,
    STATE_ERROR
} PARSER_STATE;

typedef struct tagMY_URL_SCHEME
{
    LPSTR           SchemeName;
    DWORD           SchemeLength;
    INTERNET_SCHEME SchemeType;
    DWORD           dwControlId;
    DWORD           dwPortControlId;
} MY_URL_SCHEME;

const MY_URL_SCHEME UrlSchemeList[] =
{
    NULL,       0,  INTERNET_SCHEME_DEFAULT,IDC_NOTUSED,                  IDC_NOTUSED,
    "ftp",      3,  INTERNET_SCHEME_FTP,    IDC_PROXY_FTP_ADDRESS,        IDC_PROXY_FTP_PORT,
    "gopher",   6,  INTERNET_SCHEME_GOPHER, IDC_PROXY_GOPHER_ADDRESS,     IDC_PROXY_GOPHER_PORT,
    "http",     4,  INTERNET_SCHEME_HTTP,   IDC_PROXY_HTTP_ADDRESS,       IDC_PROXY_HTTP_PORT,
    "https",    5,  INTERNET_SCHEME_HTTPS,  IDC_PROXY_SECURITY_ADDRESS,   IDC_PROXY_SECURITY_PORT,
    "socks",    5,  INTERNET_SCHEME_SOCKS,  IDC_PROXY_SOCKS_ADDRESS,      IDC_PROXY_SOCKS_PORT,
};

#define INTERNET_MAX_PORT_LENGTH    sizeof("123456789")

typedef struct tagBEFOREUSESAME
{
    // addresses
    TCHAR szFTP      [ INTERNET_MAX_URL_LENGTH + 1 ];
    TCHAR szGOPHER   [ INTERNET_MAX_URL_LENGTH + 1 ];
    TCHAR szSECURE   [ INTERNET_MAX_URL_LENGTH + 1 ];
    TCHAR szSOCKS    [ INTERNET_MAX_URL_LENGTH + 1 ];

    // ports
    TCHAR szFTPport      [ INTERNET_MAX_PORT_LENGTH + 1 ];
    TCHAR szGOPHERport   [ INTERNET_MAX_PORT_LENGTH + 1 ];
    TCHAR szSECUREport   [ INTERNET_MAX_PORT_LENGTH + 1 ];
    TCHAR szSOCKSport    [ INTERNET_MAX_PORT_LENGTH + 1 ];

} BEFOREUSESAME, *LPBEFOREUSESAME;

static const int g_iProxies[] = {IDC_PROXY_HTTP_ADDRESS, IDC_PROXY_FTP_ADDRESS, IDC_PROXY_GOPHER_ADDRESS, IDC_PROXY_SECURITY_ADDRESS, IDC_PROXY_SOCKS_ADDRESS};


typedef struct tagPROXYPAGE
{
    LPBEFOREUSESAME lpOldSettings;
    BOOL            fNT;
    LPPROXYINFO     lpi;
    HINSTANCE       hinstUrlMon;    // runtime load URLMON.DLL
} PROXYPAGE, *LPPROXYPAGE;

extern const TCHAR cszLocalString[] = TEXT("<local>");

#define MAX_SCHEME_NAME_LENGTH  sizeof("gopher")

#define MAX_TITLE           80
#define MAX_DIALOG_MESSAGE  300


//
// private function prototypes
//


LPBEFOREUSESAME SaveCurrentSettings(HWND hDlg);
void RestorePreviousSettings(HWND hDlg, LPBEFOREUSESAME lpSave);

BOOL
ProxyDlgInitProxyServers(
    IN HWND hDlg
    );

BOOL
ProxyDlgOK(
    IN HWND hDlg
    );

BOOL
ProxyDlgInit(
    IN HWND hDlg, LPARAM lParam
    );

VOID
EnableProxyControls(
    IN HWND hDlg
    );

BOOL
IsProxyValid(
    IN HWND     hDlg
    );


BOOL
ParseEditCtlForPort(
    IN OUT LPSTR   lpszProxyName,
    IN HWND        hDlg,
    IN DWORD       dwProxyNameCtlId,
    IN DWORD       dwProxyPortCtlId
    );

BOOL
FormatOutProxyEditCtl(
    IN HWND        hDlg,
    IN DWORD       dwProxyNameCtlId,
    IN DWORD       dwProxyPortCtlId,
    OUT LPSTR     lpszOutputStr,
    IN OUT LPDWORD lpdwOutputStrSize,
    IN DWORD       dwOutputStrLength,
    IN BOOL        fDefaultProxy
    );

INTERNET_SCHEME
MapUrlSchemeName(
    IN LPSTR lpszSchemeName,
    IN DWORD dwSchemeNameLength
    );

DWORD
MapUrlSchemeTypeToCtlId(
    IN INTERNET_SCHEME SchemeType,
    IN BOOL        fIdForPortCtl
    );


BOOL
MapCtlIdUrlSchemeName(
    IN DWORD    dwEditCtlId,
    OUT LPSTR   lpszSchemeOut
    );


DWORD
MapAddrCtlIdToPortCtlId(
    IN DWORD    dwEditCtlId
    );

BOOL
RemoveLocalFromExceptionList(
    IN LPTSTR lpszExceptionList
    );



//
// functions
//


/*******************************************************************

    NAME:       ProxyDlgProc

    SYNOPSIS:   Proxy property sheet dialog proc.

********************************************************************/
INT_PTR CALLBACK ProxyDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,
    LPARAM lParam)
{
    LPPROXYPAGE pPxy= (LPPROXYPAGE) GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
        
        case WM_INITDIALOG:
        {
            BOOL fInited;
            
            fInited = ProxyDlgInit(hDlg, lParam);
            return fInited;
        }
        
        case WM_NOTIFY:
        {
            NMHDR * lpnm = (NMHDR *) lParam;
            switch (lpnm->code)
            {
                case PSN_APPLY:
                {
                    BOOL fRet = ProxyDlgOK(hDlg);
                    SetPropSheetResult(hDlg,!fRet);
                    return !fRet;
                    break;
                }
                
                case PSN_RESET:
                    SetPropSheetResult(hDlg,FALSE);
                    break;
            }
            break;
        }
        
        case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case IDC_PROXY_ENABLE:
                    EnableProxyControls(hDlg);
                    break;

                case IDC_PROXY_HTTP_ADDRESS:
                case IDC_PROXY_GOPHER_ADDRESS:
                case IDC_PROXY_SECURITY_ADDRESS:
                case IDC_PROXY_FTP_ADDRESS:
                case IDC_PROXY_SOCKS_ADDRESS:

                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS )
                    {
                        ParseEditCtlForPort(NULL, hDlg, (GET_WM_COMMAND_ID(wParam, lParam)), 0);
                        EnableProxyControls(hDlg);
                    }
                    break;

                case IDC_PROXY_HTTP_PORT:
                case IDC_PROXY_GOPHER_PORT:
                case IDC_PROXY_SECURITY_PORT:
                case IDC_PROXY_FTP_PORT:
                case IDC_PROXY_SOCKS_PORT:

                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == EN_KILLFOCUS )
                    {
                        EnableProxyControls(hDlg);
                    }
                    break;


                case IDC_PROXY_USE_SAME_SERVER:

                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        if (IsDlgButtonChecked(hDlg, IDC_PROXY_USE_SAME_SERVER))
                            pPxy->lpOldSettings = SaveCurrentSettings(hDlg);
                        else if (pPxy->lpOldSettings !=NULL)
                        {
                            RestorePreviousSettings(hDlg, pPxy->lpOldSettings);
                            pPxy->lpOldSettings = NULL;
                        }

                        EnableProxyControls(hDlg);
                    }
                    break;

                case IDOK:

                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        BOOL fLeaveDialog = TRUE;

                        if (!IsProxyValid(hDlg))
                        {
                            // The proxy is invalid, so we need to ask the user if they want to turn it off.
                            TCHAR szTitle[MAX_TITLE];
                            TCHAR szMessage[MAX_DIALOG_MESSAGE];
                            int nUserResponce;

                            MLLoadShellLangString(IDS_INVALID_PROXY_TITLE, szTitle, ARRAYSIZE(szTitle));
                            MLLoadShellLangString(IDS_INVALID_PROXY, szMessage, ARRAYSIZE(szMessage));

                            // Ask the user if they want to turn off the proxy.
                            nUserResponce = MessageBox(hDlg, szMessage, szTitle, MB_YESNOCANCEL | MB_ICONERROR);
                            if (IDYES == nUserResponce)
                                pPxy->lpi->fEnable = FALSE;
                            else if (IDCANCEL == nUserResponce)
                                fLeaveDialog = FALSE;   // The user hit cancel, so let's not leave the dialog.
                        }

                        if (fLeaveDialog)
                        {
                            //
                            // Read the Ctls and Save out to the proxy..
                            //
                            ProxyDlgOK(hDlg);
                            EndDialog(hDlg, IDOK);
                        }
                    }
                    break;

                case IDCANCEL:
                    if ( GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED )
                    {
                        EndDialog(hDlg, IDCANCEL);
                    }
                    break;

            }
            break;

        case WM_DESTROY:
            if (pPxy->lpOldSettings)
                LocalFree(pPxy->lpOldSettings);

            if (pPxy->hinstUrlMon)
                FreeLibrary(pPxy->hinstUrlMon);

            LocalFree(pPxy);
            return TRUE;

        case WM_HELP:      // F1
            ResWinHelp((HWND) ((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            ResWinHelp((HWND)wParam, IDS_HELPFILE,
                HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        default:
            return FALSE;
    }
    return TRUE;
}


//
// Private Functions.
//

VOID
EnableProxyControls(HWND hDlg)

/*++

Routine Description:

    Enables controls appropriately depending on what
    checkboxes are checked.

Arguments:

    hDlg        - Page Dialog Box.

Return Value:

    VOID

--*/


{
    BOOL fNT = ((LPPROXYPAGE)GetWindowLongPtr(hDlg, DWLP_USER))->fNT;
    
    BOOL fEnable = !g_restrict.fProxy;
            
    BOOL fUseOneProxy = IsDlgButtonChecked(hDlg,IDC_PROXY_USE_SAME_SERVER);
    
    EnableDlgItem(hDlg,IDC_GRP_SETTINGS2, fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_EXCEPTIONS_GROUPBOX, fEnable);

    EnableDlgItem(hDlg,IDC_TYPE_TEXT, fEnable);
    EnableDlgItem(hDlg,IDC_ADDR_TEXT, fEnable);
    EnableDlgItem(hDlg,IDC_PORT_TEXT, fEnable);
    EnableDlgItem(hDlg,IDC_EXCEPT_TEXT, fEnable);
    EnableDlgItem(hDlg,IDC_EXCEPT2_TEXT, fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_ICON1, fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_ICON2, fEnable);
    
    EnableDlgItem(hDlg,IDC_PROXY_HTTP_CAPTION, fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_SECURITY_CAPTION, fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_FTP_CAPTION, fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_GOPHER_CAPTION, fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_SOCKS_CAPTION, fEnable);

    EnableDlgItem(hDlg, IDC_PROXY_USE_SAME_SERVER, fEnable);

    EnableDlgItem(hDlg,IDC_PROXY_HTTP_ADDRESS,fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_HTTP_PORT,fEnable);
           
    EnableDlgItem(hDlg,IDC_PROXY_OVERRIDE,fEnable);

    //
    // If we only want one Proxy, then make all others use the same
    //  proxy.
    //

    EnableDlgItem(hDlg,IDC_PROXY_SECURITY_ADDRESS,!fUseOneProxy && fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_SECURITY_PORT,!fUseOneProxy && fEnable);

    EnableDlgItem(hDlg,IDC_PROXY_FTP_ADDRESS,!fUseOneProxy && fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_FTP_PORT,!fUseOneProxy && fEnable);

    EnableDlgItem(hDlg,IDC_PROXY_GOPHER_ADDRESS,!fUseOneProxy && fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_GOPHER_PORT,!fUseOneProxy && fEnable);

    EnableDlgItem(hDlg,IDC_PROXY_SOCKS_ADDRESS,!fUseOneProxy && fEnable);
    EnableDlgItem(hDlg,IDC_PROXY_SOCKS_PORT,!fUseOneProxy && fEnable);

    //
    // If we only want one proxy, prepopulate the other fields
    //  so they use the the mirror of the first one.
    //

    if (fUseOneProxy)
    {
        TCHAR szProxyName[MAX_URL_STRING+1];
        TCHAR szProxyPort[INTERNET_MAX_PORT_LENGTH];

        GetDlgItemText(hDlg,
            IDC_PROXY_HTTP_ADDRESS,
            szProxyName,
            ARRAYSIZE(szProxyName));

        GetDlgItemText(hDlg,
            IDC_PROXY_HTTP_PORT,
            szProxyPort,
            ARRAYSIZE(szProxyPort));

        SetDlgItemText(hDlg,IDC_PROXY_SECURITY_ADDRESS,szProxyName);
        SetDlgItemText(hDlg,IDC_PROXY_SECURITY_PORT,szProxyPort);

        SetDlgItemText(hDlg,IDC_PROXY_FTP_ADDRESS,szProxyName);
        SetDlgItemText(hDlg,IDC_PROXY_FTP_PORT,szProxyPort);

        SetDlgItemText(hDlg,IDC_PROXY_GOPHER_ADDRESS,szProxyName);
        SetDlgItemText(hDlg,IDC_PROXY_GOPHER_PORT,szProxyPort);

        SetDlgItemText(hDlg,IDC_PROXY_SOCKS_ADDRESS,TEXT(""));
        SetDlgItemText(hDlg,IDC_PROXY_SOCKS_PORT,TEXT(""));
    }
}

//
// SaveCurrentSettings()
//
// Saves current settings... just in case user changes their mind.
//
// Returns a pointer to a structure filled with current settings.
//
LPBEFOREUSESAME SaveCurrentSettings(HWND hDlg)
{
    LPBEFOREUSESAME lpSave = (LPBEFOREUSESAME)LocalAlloc(LPTR, sizeof(*lpSave));

    if (!lpSave)
        return lpSave; // if NULL return NULL

    GetDlgItemText(hDlg, IDC_PROXY_FTP_ADDRESS,      lpSave->szFTP,    INTERNET_MAX_URL_LENGTH);
    GetDlgItemText(hDlg, IDC_PROXY_GOPHER_ADDRESS,   lpSave->szGOPHER, INTERNET_MAX_URL_LENGTH);
    GetDlgItemText(hDlg, IDC_PROXY_SECURITY_ADDRESS, lpSave->szSECURE, INTERNET_MAX_URL_LENGTH);
    GetDlgItemText(hDlg, IDC_PROXY_SOCKS_ADDRESS,    lpSave->szSOCKS,  INTERNET_MAX_URL_LENGTH);

    GetDlgItemText(hDlg, IDC_PROXY_FTP_PORT,      lpSave->szFTPport,    INTERNET_MAX_URL_LENGTH);
    GetDlgItemText(hDlg, IDC_PROXY_GOPHER_PORT,   lpSave->szGOPHERport, INTERNET_MAX_URL_LENGTH);
    GetDlgItemText(hDlg, IDC_PROXY_SECURITY_PORT, lpSave->szSECUREport, INTERNET_MAX_URL_LENGTH);
    GetDlgItemText(hDlg, IDC_PROXY_SOCKS_PORT,    lpSave->szSOCKSport,  INTERNET_MAX_URL_LENGTH);

    return lpSave;

} // SaveCurrentSettings()


//
// RestorePreviousSettings()
//
// Restores settings... just in case user changes their mind.
//
void RestorePreviousSettings(HWND hDlg, LPBEFOREUSESAME lpSave)
{

    if (!lpSave)
    return; // nothing to do

    SetDlgItemText(hDlg, IDC_PROXY_FTP_ADDRESS,      lpSave->szFTP    );
    SetDlgItemText(hDlg, IDC_PROXY_GOPHER_ADDRESS,   lpSave->szGOPHER );
    SetDlgItemText(hDlg, IDC_PROXY_SECURITY_ADDRESS, lpSave->szSECURE );
    SetDlgItemText(hDlg, IDC_PROXY_SOCKS_ADDRESS,    lpSave->szSOCKS  );

    SetDlgItemText(hDlg, IDC_PROXY_FTP_PORT,      lpSave->szFTPport    );
    SetDlgItemText(hDlg, IDC_PROXY_GOPHER_PORT,   lpSave->szGOPHERport );
    SetDlgItemText(hDlg, IDC_PROXY_SECURITY_PORT, lpSave->szSECUREport );
    SetDlgItemText(hDlg, IDC_PROXY_SOCKS_PORT,    lpSave->szSOCKSport  );

    LocalFree(lpSave);  // give back the memory

} // RestorePreviousSettings()


BOOL
ProxyDlgInit(
    IN HWND hDlg, LPARAM lParam
    )

/*++

Routine Description:

    Initialization proc for proxy prop page

Arguments:

    hDlg        - Page Dialog Box.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

--*/


{
    BOOL fSuccess;
    LPPROXYPAGE pPxy;

    pPxy = (LPPROXYPAGE)LocalAlloc(LPTR, sizeof(*pPxy));
    // NOTE: this NULLS lpOldSettings

    if (!pPxy)
        return FALSE;   // no memory?

    OSVERSIONINFOA osvi;
    osvi.dwOSVersionInfoSize = sizeof(osvi);
    GetVersionExA(&osvi);
    
    pPxy->fNT = (osvi.dwPlatformId == VER_PLATFORM_WIN32_NT);
    ASSERT(pPxy->lpOldSettings == NULL);
        
    // tell dialog where to get info
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pPxy);

    pPxy->lpi = (LPPROXYINFO)lParam;
    //
    // Begin by reading and setting the list of proxy
    //  servers we have.
    //

    fSuccess = ProxyDlgInitProxyServers( hDlg );

    if (!fSuccess)
        return FALSE;

    //
    // read settings from registry, for the list of Exclusion Hosts.
    //

    RegEntry re(REGSTR_PATH_INTERNETSETTINGS,HKEY_CURRENT_USER);

    if (re.GetError() == ERROR_SUCCESS)
    {
        BUFFER bufProxyString(MAX_URL_STRING+1);
        
        if (!bufProxyString)
        {
            MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
            return FALSE;
        }

        //  
        // get proxy override settings from registry and stuff fields
        // Prevent entry of more than (MAX_URL_STRING - ("<local>" + safety))
        SendMessage(GetDlgItem(hDlg, IDC_PROXY_OVERRIDE), EM_SETLIMITTEXT, (WPARAM)ARRAYSIZE(pPxy->lpi->szOverride)-20, 0);
        SetDlgItemText(hDlg, IDC_PROXY_OVERRIDE, pPxy->lpi->szOverride);
    }

    //
    // initialize the UI appropriately
    //

    EnableProxyControls(hDlg);
    
    return TRUE;
}

BOOL
ProxyDlgOK(
    IN HWND hDlg
    )

/*++

Routine Description:

    OK button handler for proxy prop page

Arguments:

    hDlg        - Page Dialog Box.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

--*/


{
    LPPROXYPAGE pPxy = (LPPROXYPAGE)GetWindowLongPtr(hDlg, DWLP_USER);       
    TCHAR szProxyListOutputBuffer[MAX_URL_STRING];
    CHAR  szProxyListOutputBufferA[MAX_URL_STRING];
    DWORD dwBufferOffset = 0;

    //
    // Get the state of our two check boxes.
    //

    BOOL fUseOneProxy =
        IsDlgButtonChecked(hDlg,IDC_PROXY_USE_SAME_SERVER);
    //
    // Open our Registry Key.
    //
    
    RegEntry re(REGSTR_PATH_INTERNETSETTINGS,HKEY_CURRENT_USER);
    if (re.GetError() == ERROR_SUCCESS)
    {       
        //
        //  Now Format, and write out the list of proxies to
        //  the registry.  We special case the case of
        //  only proxy.
        //

        szProxyListOutputBufferA[dwBufferOffset] = '\0';

        if ( fUseOneProxy )
        {
            FormatOutProxyEditCtl(
                                  hDlg,
                                  IDC_PROXY_HTTP_ADDRESS,
                                  IDC_PROXY_HTTP_PORT,
                                  szProxyListOutputBufferA,
                                  &dwBufferOffset,
                                  ARRAY_ELEMENTS(szProxyListOutputBufferA),
                                  TRUE
                                 );
        }
        else
        {
            for (int i = 1; i < ARRAY_ELEMENTS(UrlSchemeList); ++i)
            {
                FormatOutProxyEditCtl(
                                      hDlg,
                                      UrlSchemeList[i].dwControlId,
                                      UrlSchemeList[i].dwPortControlId,
                                      szProxyListOutputBufferA,
                                      &dwBufferOffset,
                                      ARRAY_ELEMENTS(szProxyListOutputBufferA),
                                      FALSE
                                     );

            }
        }

        szProxyListOutputBufferA[dwBufferOffset] = '\0';

#ifdef UNICODE
        SHAnsiToUnicode(szProxyListOutputBufferA, szProxyListOutputBuffer, MAX_URL_STRING);
#else
        lstrcpy(szProxyListOutputBuffer, szProxyListOutputBufferA);
#endif
        StrCpyN(pPxy->lpi->szProxy, szProxyListOutputBuffer, MAX_URL_STRING);

        //
        // Now Write out the Proxy Exception List
        //  (list of addresses to use for local connections)
        //

        szProxyListOutputBuffer[0] = '\0';
        
        GetDlgItemText(hDlg,
                       IDC_PROXY_OVERRIDE,
                       szProxyListOutputBuffer,
                       ARRAY_ELEMENTS(szProxyListOutputBuffer));
                
        StrCpyN(pPxy->lpi->szOverride, szProxyListOutputBuffer, MAX_URL_STRING);
    }
    
    else    
    {
        AssertMsg(0, TEXT("Couldn't save settings to registry!"));
    }


    // let any active (participating) wininet's get notified
    //
    InternetSetOption(NULL, INTERNET_OPTION_SETTINGS_CHANGED, NULL, 0);

    return TRUE;
}


INTERNET_SCHEME
MapUrlSchemeName(
    IN LPSTR lpszSchemeName,
    IN DWORD dwSchemeNameLength
    )

/*++

Routine Description:

    Maps a scheme name/length to a scheme name type

Arguments:

    lpszSchemeName  - pointer to name of scheme to map

    dwSchemeNameLength  - length of scheme (if -1, lpszSchemeName is ASCIZ)

Return Value:

    INTERNET_SCHEME

--*/

{
    if (dwSchemeNameLength == (DWORD)-1)
    {
        dwSchemeNameLength = (DWORD)lstrlenA(lpszSchemeName);
    }
    
    for (int i = 0; i < ARRAY_ELEMENTS(UrlSchemeList); ++i)
    {
        if (UrlSchemeList[i].SchemeLength == dwSchemeNameLength)
        {   
            CHAR chBackup = lpszSchemeName[dwSchemeNameLength];
            lpszSchemeName[dwSchemeNameLength] = '\0';
            
            if(StrCmpIA(UrlSchemeList[i].SchemeName,lpszSchemeName) == 0)
            {
                lpszSchemeName[dwSchemeNameLength] = chBackup;
                return UrlSchemeList[i].SchemeType;
            }
            
            lpszSchemeName[dwSchemeNameLength] = chBackup;
        }
    }
    return INTERNET_SCHEME_UNKNOWN;
}



DWORD
MapUrlSchemeTypeToCtlId(
    IN INTERNET_SCHEME SchemeType,
    IN BOOL        fIdForPortCtl
    )

/*++

Routine Description:

    Maps a scheme to a dlg child control id.

Arguments:

    Scheme    - Scheme to Map

    fIdForPortCtl - If TRUE, means we really want the ID for a the PORT control
            not the ADDRESS control.

Return Value:

    DWORD

--*/

{
    for (int i = 0; i < ARRAY_ELEMENTS(UrlSchemeList); ++i)
    {
        if (SchemeType == UrlSchemeList[i].SchemeType)
        {
            return (fIdForPortCtl ? UrlSchemeList[i].dwPortControlId :
                    UrlSchemeList[i].dwControlId );
        }
    }
    return IDC_NOTUSED;
}

BOOL
MapCtlIdUrlSchemeName(
    IN DWORD    dwEditCtlId,
    OUT LPSTR   lpszSchemeOut
    )

/*++

Routine Description:

    Maps a dlg child control id to String represnting
    the name of the scheme.

Arguments:

    dwEditCtlId   - Edit Control to Map Out.

    lpszSchemeOut - Scheme to Map Out.
            WARNING: ASSUMED to be size of largest scheme type.

Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

--*/

{
    ASSERT(lpszSchemeOut);

    for (int i = 0; i < ARRAY_ELEMENTS(UrlSchemeList); ++i)
    {
        if (dwEditCtlId == UrlSchemeList[i].dwControlId )
        {
            StrCpyA(lpszSchemeOut, UrlSchemeList[i].SchemeName);
            return TRUE;
        }
    }
    return FALSE;
}


DWORD
MapAddrCtlIdToPortCtlId(
    IN DWORD    dwEditCtlId
    )

/*++

Routine Description:

    Maps a dlg child control id for addresses to
    a dlg control id for ports.

Arguments:

    dwEditCtlId   - Edit Control to Map Out.

Return Value:

    DWORD
    Success - Correctly mapped ID.

    Failure - 0.

--*/

{

    for (int i = 0; i < ARRAY_ELEMENTS(UrlSchemeList); ++i)
    {
        if (dwEditCtlId == UrlSchemeList[i].dwControlId )
        {
            return UrlSchemeList[i].dwPortControlId ;
        }
    }
    return FALSE;
}


BOOL
ProxyDlgInitProxyServers(
    IN HWND hDlg
    )

/*++

Routine Description:

    Parses a list of proxy servers and sets them into the newly created
    Proxy Dialog.

    Ruthlessly stolen from RFirth's proxysup.cxx in WININET by
    ArthurBi.

Arguments:

    hDlg    -      HWin to add our stuff to.


Return Value:

    BOOL
    Success - TRUE

    Failure - FALSE

Comments:

    Designed to handle Proxy string entry of the Form:

      pointer to list of proxies of the form:

      [<protocol>=][<scheme>"://"]<server>[":"<port>][";"*]

      The list can is read from the registry.


--*/

{
    DWORD error = !ERROR_SUCCESS;
    DWORD entryLength;
    LPSTR protocolName;
    DWORD protocolLength;
    LPSTR schemeName;
    DWORD schemeLength;
    LPSTR serverName;
    DWORD serverLength;
    PARSER_STATE state;
    DWORD nSlashes;
    INTERNET_PORT port;
    BOOL done;
    LPSTR lpszList;

    entryLength = 0;
    protocolLength = 0;
    schemeName = NULL;
    schemeLength = 0;
    serverName = NULL;
    serverLength = 0;
    state = STATE_PROTOCOL;
    nSlashes = 0;
    port = 0;
    done = FALSE;


    //
    // Open the Reg Key.
    //

    RegEntry re(REGSTR_PATH_INTERNETSETTINGS,HKEY_CURRENT_USER);

    if (re.GetError() != ERROR_SUCCESS)
        return FALSE; // no REG values..


    //
    // Crack the Registry values, read the proxy list
    //


    BUFFER bufProxyString(MAX_URL_STRING+1);
    BOOL   fProxyEnabled;

    if (!bufProxyString)
    {
        MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
        return FALSE;
    }

    //
    // is proxy enabled?
    // It should if we got into this dialog.
    //

    fProxyEnabled = (BOOL)re.GetNumber(REGSTR_VAL_PROXYENABLE,0);

    //
    // get proxy server and override settings from registry and stuff fields
    //

    re.GetString(REGSTR_VAL_PROXYSERVER,bufProxyString.QueryPtr(),
        bufProxyString.QuerySize());


    LPPROXYPAGE pPxy = (LPPROXYPAGE)GetWindowLongPtr(hDlg, DWLP_USER);

    // if there's a proxy passed in from the main page, then use it; otherwise use the registry val
#ifndef UNICODE
    lpszList = pPxy->lpi->szProxy;
#else
    char*  szList = NULL;
    LPTSTR lpTmp = pPxy->lpi->szProxy;
    DWORD  cch = lstrlen(lpTmp) + 1;
    szList = new char[2 * cch];
    if (szList)
    {
        SHUnicodeToAnsi(lpTmp, szList, 2 * cch);
        lpszList = szList;
    }
    else
    {
        MsgBox(NULL,IDS_ERROutOfMemory,MB_ICONEXCLAMATION,MB_OK);
        return FALSE;
    }
#endif

    protocolName = lpszList;

    //
    // walk the list, pulling out the various scheme parts
    //

    do
    {
        char ch = *lpszList++;

        if ((nSlashes == 1) && (ch != '/'))
        {
            state = STATE_ERROR;
            break;
        }
        
        switch (ch)
        {
            case '=':
                if ((state == STATE_PROTOCOL) && (entryLength != 0))
                {
                    protocolLength = entryLength;
                    entryLength = 0;
                    state = STATE_SCHEME;
                    schemeName = lpszList;
                }
                else
                {
                    //
                    // '=' can't legally appear anywhere else
                    //
                    state = STATE_ERROR;
                }
                break;
                
            case ':':
                switch (state)
                {
                    case STATE_PROTOCOL:
                        if (*lpszList == '/')
                        {
                            schemeName = protocolName;
                            protocolName = NULL;
                            schemeLength = entryLength;
                            protocolLength = 0;
                            state = STATE_SCHEME;
                        }
                        else if (*lpszList != '\0')
                        {
                            serverName = protocolName;
                            serverLength = entryLength;
                            state = STATE_PORT;
                        }
                        else
                        {
                            state = STATE_ERROR;
                        }
                        entryLength = 0;
                        break;
                        
                    case STATE_SCHEME:
                        if (*lpszList == '/')
                        {
                            schemeLength = entryLength;
                        }
                        else if (*lpszList != '\0')
                        {
                            serverName = schemeName;
                            serverLength = entryLength;
                            state = STATE_PORT;
                        }
                        else
                        {
                            state = STATE_ERROR;
                        }
                        entryLength = 0;
                        break;
                        
                    case STATE_SERVER:
                        serverLength = entryLength;
                        state = STATE_PORT;
                        entryLength = 0;
                        break;

                    default:
                        state = STATE_ERROR;
                        break;
                }
                break;

            case '/':
                if ((state == STATE_SCHEME) && (nSlashes < 2) && (entryLength == 0))
                {
                    if (++nSlashes == 2)
                    {
                        state = STATE_SERVER;
                        serverName = lpszList;
                    }
                }
                else
                {
                    state = STATE_ERROR;
                }
                break;

            case '\v':  // vertical tab, 0x0b
            case '\f':  // form feed, 0x0c
                if (!((state == STATE_PROTOCOL) && (entryLength == 0)))
                {
                    //
                    // can't have embedded whitespace
                    //

                    state = STATE_ERROR;
                }
                break;

            default:
                if (state != STATE_PORT)
                {
                    ++entryLength;
                }
                else if (isdigit(ch))
                {
                    //
                    // we will overflow if >65535
                    //
                    Assert(port < 65535);
                    port = port * 10 + (ch - '0');
                }
                else
                {                   
                    //
                    // STATE_PORT && non-digit character - error
                    //
                    state = STATE_ERROR;
                }
                break;

            case '\0':
                done = TRUE;

                //
                // fall through
                //
            case ' ':
            case '\t':
            case '\n':
            case '\r':
            case ';':
            case ',':
                if (serverLength == 0)
                {
                    serverLength = entryLength;
                }
                if (serverLength != 0)
                {
                    if (serverName == NULL)
                    {
                        serverName = (schemeName != NULL)
                            ? schemeName : protocolName;
                    }

                    ASSERT(serverName != NULL);

                    INTERNET_SCHEME protocol;

                    if (protocolLength != 0)
                    {
                        protocol = MapUrlSchemeName(protocolName, protocolLength);
                    }
                    else
                    {
                        protocol = INTERNET_SCHEME_DEFAULT;
                    }

                    INTERNET_SCHEME scheme;

                    if (schemeLength != 0)
                    {
                        scheme = MapUrlSchemeName(schemeName, schemeLength);
                    }
                    else
                    {
                        scheme = INTERNET_SCHEME_DEFAULT;
                    }

                    //
                    // add an entry if this is a protocol we handle and we don't
                    // already have an entry for it
                    //

                    if ((protocol != INTERNET_SCHEME_UNKNOWN)
                        && (scheme != INTERNET_SCHEME_UNKNOWN))
                    {
                        DWORD dwCtlId = IDC_NOTUSED;
                        DWORD dwPortCtlId = IDC_NOTUSED;
                        CHAR chBackup;

                        error = ERROR_SUCCESS;
                        //
                        // we can only currently handle CERN proxies (unsecure or
                        // secure) so kick out anything that wants to go via a different
                        // proxy scheme
                        //

                        if (protocol == INTERNET_SCHEME_DEFAULT)
                        {
                            CheckDlgButton( hDlg, IDC_PROXY_USE_SAME_SERVER, TRUE );
                            dwCtlId     = IDC_PROXY_HTTP_ADDRESS;
                            dwPortCtlId = IDC_PROXY_HTTP_PORT;
                        }
                        else
                        {
                            dwCtlId     = MapUrlSchemeTypeToCtlId(protocol,FALSE);
                            dwPortCtlId = MapUrlSchemeTypeToCtlId(protocol,TRUE);
                        }

                        //
                        // Set the Field Entry.
                        //

                        LPSTR lpszProxyNameText;

                        if (scheme != INTERNET_SCHEME_DEFAULT)
                        {
                            ASSERT(schemeLength != 0);
                            lpszProxyNameText = schemeName;
                        }
                        else
                            lpszProxyNameText = serverName;

                        chBackup = serverName[serverLength];
                        serverName[serverLength] = '\0';
                        
                        SetDlgItemTextA( hDlg, dwCtlId, lpszProxyNameText );
                        if ( port )
                            SetDlgItemInt( hDlg, dwPortCtlId, port, FALSE );

                        serverName[serverLength] = chBackup;
                        
                    }
                    
                    else
                    {                      
                        //
                        // bad/unrecognised protocol or scheme. Treat it as error
                        // for now
                        //
                        error = !ERROR_SUCCESS;
                    }
                }

                entryLength = 0;
                protocolName = lpszList;
                protocolLength = 0;
                schemeName = NULL;
                schemeLength = 0;
                serverName = NULL;
                serverLength = 0;
                nSlashes = 0;
                port = 0;
                if (error == ERROR_SUCCESS)
                {
                    state = STATE_PROTOCOL;
                }
                else
                {
                    state = STATE_ERROR;
                }
                break;
        }

        if (state == STATE_ERROR)
        {
            break;
        }
        
    } while (!done);

#ifdef UNICODE
    delete [] szList;
#endif

    if (state == STATE_ERROR)
    {
        error = ERROR_INVALID_PARAMETER;
    }

    if ( error == ERROR_SUCCESS )
        error = TRUE;
    else
        error = FALSE;

    return error;
}


BOOL
IsProxyValid(
    IN HWND     hDlg
    )

/*++

Routine Description:

    Determines if the Proxy is valid.  The proxy is invalid if
    all of the proxy entries are empty.

Arguments:

    hDlg      - HWIN of the dialog to play with.

Return Value:

    BOOL
    Success TRUE - Valid.

    FALSE - Invalid.


--*/

{
    BOOL  fProxyIsValid = FALSE;
    TCHAR szProxyUrl[MAX_URL_STRING+1];
    int   iCurrentProxy = 0;

    ASSERT(IsWindow(hDlg));

    for (int iIndex = 0; iIndex < ARRAYSIZE(g_iProxies); iIndex++)
    {
        szProxyUrl[0] = '\0';
        GetDlgItemText(hDlg,
                       g_iProxies[iIndex],
                       szProxyUrl,
                       sizeof(szProxyUrl));
        
        if (szProxyUrl[0])
        {
            fProxyIsValid = TRUE;
            break;
        }
    }

    return fProxyIsValid;
}



BOOL
ParseEditCtlForPort(
    IN OUT LPSTR   lpszProxyName,
    IN HWND        hDlg,
    IN DWORD       dwProxyNameCtlId,
    IN DWORD       dwProxyPortCtlId
    )

/*++

Routine Description:

    Parses a Port Number off then end of a Proxy Server URL that is
    located either in the Proxy Name Edit Box, or passed in as
    a string pointer.

Arguments:

    lpszProxyName - (OPTIONAL) string pointer with Proxy Name to parse, and
            set into the Proxy Name edit ctl field.

    hDlg      - HWIN of the dialog to play with.

    dwProxyNameCtlId -  Res Ctl Id to play with.

    dwProxyPortCtlId -  Res Ctl Id of Port Number Edit Box.

Return Value:

    BOOL
    Success TRUE -

    Failure FALSE


--*/

{
    CHAR   szProxyUrl[MAX_URL_STRING+1];
    LPSTR  lpszPort;
    LPSTR  lpszProxyUrl;

    ASSERT(IsWindow(hDlg));

    if ( dwProxyPortCtlId == 0 )
    {
        dwProxyPortCtlId = MapAddrCtlIdToPortCtlId(dwProxyNameCtlId);
        ASSERT(dwProxyPortCtlId);
    }

    //
    // Get the Proxy String from the Edit Control
    //  (OR) from the Registry [passed in]
    //

    if ( lpszProxyName )
        lpszProxyUrl = lpszProxyName;
    else
    {
    //
    // Need to Grab it out of the edit control.
    //
        GetDlgItemTextA(hDlg,
            dwProxyNameCtlId,
            szProxyUrl,
            sizeof(szProxyUrl));

        lpszProxyUrl = szProxyUrl;
    }

    //
    // Now find the port.
    //

    lpszPort = lpszProxyUrl;

    GET_TERMINATOR(lpszPort);

    lpszPort--;

    //
    // Walk backwards from the end of url looking
    //  for a port number sitting on the end like this
    //  http://proxy:1234
    //

    while ( (lpszPort > lpszProxyUrl) &&
        (*lpszPort != ':')         &&
        (isdigit(*lpszPort))  )
    {
        lpszPort--;
    }

    //
    // If we found a match for our rules
    //  then set the port, otherwise
    //  we assume the user knows what he's
    //  doing.
    //

    if ( *lpszPort == ':'   &&   isdigit(*(lpszPort+1)) )
    {
        *lpszPort = '\0';

        SetDlgItemTextA(hDlg, dwProxyPortCtlId, (lpszPort+1));
    }

    SetDlgItemTextA(hDlg, dwProxyNameCtlId, lpszProxyUrl);
    return TRUE;
}


BOOL
FormatOutProxyEditCtl(
    IN HWND    hDlg,
    IN DWORD       dwProxyNameCtlId,
    IN DWORD       dwProxyPortCtlId,
    OUT LPSTR      lpszOutputStr,
    IN OUT LPDWORD lpdwOutputStrSize,
    IN DWORD       dwOutputStrLength,
    IN BOOL    fDefaultProxy
    )

/*++

Routine Description:

    Combines Proxy URL components into a string that can be saved
    in the registry.  Can be called multiple times to build
    a list of proxy servers, or once to special case a "default"
    proxy.

Arguments:

    hDlg      - HWIN of the dialog to play with.

    dwProxyNameCtlId -  Res Ctl Id to play with.

    dwProxyPortCtlId -  Res Ctl Id of Port Number Edit Box.

    lpszOutputStr    -  The start of the output string to send
            the product of this function.

    lpdwOutputStrSize - The amount of used space in lpszOutputStr
            that is already used.  New output should
            start from (lpszOutputStr + *lpdwOutputStrSize)

    fDefaultProxy     - Default Proxy, don't add scheme= in front of the proxy
            just use plop one proxy into the registry.


Return Value:

    BOOL
    Success TRUE

    Failure FALSE


--*/

{
    LPSTR lpszOutput;
    LPSTR lpszEndOfOutputStr;

    ASSERT(IsWindow(hDlg));
    ASSERT(lpdwOutputStrSize);

    lpszOutput = lpszOutputStr + *lpdwOutputStrSize;
    lpszEndOfOutputStr = lpszOutputStr + dwOutputStrLength;

    ASSERT( lpszEndOfOutputStr > lpszOutput );

    if ( lpszEndOfOutputStr <= lpszOutput )
        return FALSE; // bail out, ran out of space

    //
    // Plop ';' if we're not the first in this string buffer.
    //

    if (*lpdwOutputStrSize != 0  )
    {
        *lpszOutput = ';';

        lpszOutput++;

        if ( lpszEndOfOutputStr <= lpszOutput )
            return FALSE; // bail out, ran out of space
    }

    //
    // Put the schemetype= into the string
    //  ex:  http=
    //

    if ( ! fDefaultProxy )
    {
        if ( lpszEndOfOutputStr <= (MAX_SCHEME_NAME_LENGTH + lpszOutput + 1) )
            return FALSE; // bail out, ran out of space
        
        if (!MapCtlIdUrlSchemeName(dwProxyNameCtlId,lpszOutput))
            return FALSE;
        
        lpszOutput += lstrlenA(lpszOutput);
    
        *lpszOutput = '=';
        lpszOutput++;
    }
    
    //
    // Need to Grab ProxyUrl out of the edit control.
    //
    
    GetDlgItemTextA(hDlg, dwProxyNameCtlId, lpszOutput, (int)(lpszEndOfOutputStr - lpszOutput));

    if ( IS_BLANK(lpszOutput) )
        return FALSE;

    //
    // Now seperate out the port so we can save them seperately.
    //   But go past the Proxy Url while we're at it.
    //      ex: http=http://netscape-proxy
    //

    if (!ParseEditCtlForPort(lpszOutput, hDlg, dwProxyNameCtlId, dwProxyPortCtlId))
        return FALSE;

    lpszOutput += lstrlenA(lpszOutput);

    //
    // Now, add in a ':" for the port number, if we don't
    //  have a port we'll remove it.
    //
    {
        *lpszOutput = ':';
        
        lpszOutput++;
        
        if ( lpszEndOfOutputStr <= lpszOutput )
            return FALSE; // bail out, ran out of space
    }

    //
    // Grab Proxy Port if its around.
    //  Back out the ':' if its not.
    //

    GetDlgItemTextA(hDlg, dwProxyPortCtlId,lpszOutput, (int)(lpszEndOfOutputStr - lpszOutput));

    if ( IS_BLANK(lpszOutput) )
    {
        lpszOutput--;
        
        ASSERT(*lpszOutput == ':');

        *lpszOutput = '\0';
    }
    
    lpszOutput += lstrlenA(lpszOutput);
    
    //
    // Now we're done return our final sizes.
    //
    
    *lpdwOutputStrSize = (DWORD)(lpszOutput - lpszOutputStr);

    return TRUE;
}

BOOL
RemoveLocalFromExceptionList(
    IN LPTSTR lpszExceptionList
    )

/*++

Routine Description:

    Scans a delimited list of entries, and removed "<local>
    if found.  If <local> is found we return TRUE.

Arguments:

    lpszExceptionList - String List of proxy excepion entries.


Return Value:

    BOOL
    TRUE - If found <local>

    FALSE - If local was not found.


--*/

{
    LPTSTR lpszLocalInstToRemove;
    BOOL   fFoundLocal;

    if ( !lpszExceptionList || ! *lpszExceptionList )
    return FALSE;

    fFoundLocal = FALSE;
    lpszLocalInstToRemove = lpszExceptionList;

    //
    // Loop looking "<local>" entries in the list.
    //

    do {

        lpszLocalInstToRemove =
                               StrStrI(lpszLocalInstToRemove,cszLocalString);
        
        
        if ( lpszLocalInstToRemove )
        {
            
            fFoundLocal = TRUE;
            
            //
            // Nuke <local> out of the string. <local>;otherstuff\0
            //  Dest is: '<'local>;otherstuff\0
            //     ??? (OR) ';'<local> if the ; is the first character.???
            //  Src  is: >'o'therstuff\0
            //  size is: sizeof(';otherstuff\0')
            //
            
            MoveMemory(
                       lpszLocalInstToRemove,
                       (lpszLocalInstToRemove+lstrlen(cszLocalString)),
                       lstrlen(lpszLocalInstToRemove+lstrlen(cszLocalString))*sizeof(TCHAR)+sizeof(TCHAR)
                      );
            
        }
        
    } while (lpszLocalInstToRemove && *lpszLocalInstToRemove);

    //
    // If we produced a ; on the end, nuke it.
    //

    lpszLocalInstToRemove = lpszExceptionList;

    GET_TERMINATOR(lpszLocalInstToRemove);

    if ( lpszLocalInstToRemove != lpszExceptionList &&
         *(lpszLocalInstToRemove-1) == ';' )
    {
        *(lpszLocalInstToRemove-1) = '\0';
    }
    
    return fFoundLocal;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\shassoc.cpp ===
/****************************************************************************
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1994
 *  All rights reserved
 *
 * This module handles the File Association UI
 *
 ***************************************************************************/

#include "inetcplp.h"
#include "mluisupp.h"
#include <unistd.h>

// For definition of FTA_OpenIsSafe
// the file class's open verb may be safely invoked for downloaded files
#include "../inc/filetype.h"

// Macros required for default button processing
#define REMOVE_DEF_BORDER(hDlg, cntrl )  \
    SendMessage( hDlg,  DM_SETDEFID, -1, 0 ); \
    SendDlgItemMessage( hDlg, cntrl, BM_SETSTYLE, BS_PUSHBUTTON, TRUE );  \

#define SET_DEF_BORDER(hDlg, cntrl )  \
    SendMessage( hDlg, DM_SETDEFID, cntrl, 0 );   \
    SendDlgItemMessage( hDlg, cntrl, BM_SETSTYLE, BS_DEFPUSHBUTTON, TRUE );  \

// Editing modes
#define NORMAL   0x00
#define ADDING   0x01
#define UPDATING 0x02

// Association status
#define NEW      0x01
#define UPD      0x02
#define UNM      0x03

#define LocalRealloc(a, b) LocalReAlloc(a, b, LMEM_MOVEABLE)

static TCHAR g_szDefaultIcon[]  = TEXT("shell32.dll,3");
static TCHAR g_szIEUnix[]       = TEXT("IEUNIX");
static TCHAR g_szIEUnixEntry[]   = TEXT("IEUNIX Specific entry");
static TCHAR g_szEditFlags[]    = TEXT("EditFlags");
static TCHAR g_szDocClass[]     = TEXT("DocClass");
static TCHAR g_szMimeKey[]      = TEXT("MIME\\Database\\Content Type");
static TCHAR g_szCmndSubKey[]   = TEXT("Shell\\Open\\Command");
static TCHAR g_szPolicySubKey[] = REGSTR_PATH_INETCPL_RESTRICTIONS;
static TCHAR g_szPolicyName[]   = TEXT("Mappings");

int SwitchToAddMode( HWND hDlg );
int SwitchToNrmlMode( HWND hDlg );
BOOL CALLBACK EnterAssocDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);


BOOL IsAssocEnabled()
{
    HKEY  hKey = NULL;

    LONG lResult = RegOpenKey(HKEY_CURRENT_USER, g_szPolicySubKey, &hKey);

    if( lResult == ERROR_SUCCESS )
    {
	// Get then size first
	DWORD dwPolicy, dwType, dwSize = sizeof(DWORD);
	if (RegQueryValueEx( hKey, g_szPolicyName, NULL, &dwType, (LPBYTE)&dwPolicy, &dwSize ) == ERROR_SUCCESS )
	{
	    if( dwPolicy )
	    {
	        RegCloseKey( hKey );
	        return FALSE;
	    }
	}
	RegCloseKey( hKey );
    }
    return TRUE;
}

/*
** AddStringToComboBox()
**
** Adds a string to a combo box.  Does not check to see if the string has
** already been added.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
BOOL AddStringToComboBox(HWND hwndComboBox, LPCTSTR pcsz)
{
   BOOL bResult;
   LONG lAddStringResult;

   lAddStringResult = SendMessage(hwndComboBox, CB_ADDSTRING, 0, (LPARAM)pcsz);

   bResult = (lAddStringResult != CB_ERR &&
              lAddStringResult != CB_ERRSPACE);

   return(bResult);
}


/*
** SafeAddStringToComboBox()
**
** Adds a string to a combo box.  Checks to see if the string has already been
** added.
**
** Arguments:
**
** Returns:
**
** Side Effects:  none
*/
BOOL SafeAddStringToComboBox(HWND hwndComboBox, LPCTSTR pcsz)
{
   BOOL bResult;

   if (SendMessage(hwndComboBox, CB_FINDSTRINGEXACT, 0, (LPARAM)pcsz) == CB_ERR)
      bResult = AddStringToComboBox(hwndComboBox, pcsz);
   else
   {
      bResult = TRUE;
   }

   return(bResult);
}

typedef struct ASSOCIATION
{
    HWND hDlg;
    int  mode;
    BOOL fInternalChange;
    BOOL fChanged;
} ASSOCINFO, * LPASSOCTABINFO;

typedef struct ENTERASSOC
{
    LPASSOCTABINFO pgti;
    TCHAR *pszAssoc;
} ENTERASSOC, * LPENTERASSOC;

#define PGTI_FROM_HDLG( hDlg ) \
    ((LPASSOCTABINFO)GetWindowLong(hDlg, DWL_USER)) \

#define PGTI_FROM_PARENT_HDLG( hDlg ) \
    ((LPASSOCTABINFO)GetWindowLong(GetParent(hDlg), DWL_USER)) \

class CMime
{
public:
    TCHAR * m_mime;
    TCHAR * m_exts;

    CMime( TCHAR * name );
   ~CMime();

    // Operations defined for Asscociation

};

CMime::CMime( TCHAR * name )
{
    m_mime = (TCHAR *) LocalAlloc( LPTR, (lstrlen(name) + 1)*sizeof(TCHAR) );
    StrCpy( m_mime, name );
    m_exts = NULL;
}

CMime::~CMime()
{
    if( m_mime ) LocalFree( m_mime );
    if( m_exts ) LocalFree( m_exts );
}


HDPA mimeList = NULL;

BOOL FreeExtensions( HDPA dpa )
{
    if( dpa == (HDPA)NULL ) return FALSE;

    int count = DPA_GetPtrCount( dpa );

    for(int i=0; i<count; i++ )
    {
        LPTSTR ptr = (LPTSTR)DPA_FastGetPtr( dpa, i );
        if(ptr) LocalFree(ptr);
    }

    DPA_Destroy( dpa );
    return TRUE;
}

class CAssoc
{
public:
    TCHAR * m_type;  // File Type class
    TCHAR * m_desc;  // File TYpe Description
    TCHAR * m_mime;  // File Type Mime
    TCHAR * m_cmnd;  // Shell/open/command
    BOOL    m_safe;  // protected or not
    DWORD   m_edit;  // EditFlags value
    UINT    m_stat;  // Status

    HDPA    m_exts;  // Dynamic array for extensions

    CAssoc( TCHAR * name );
   ~CAssoc();
    
    // Operations defined for Asscociation

    Load();
    Save(); 
    Print();
    Delete();

    // Some helper functions

    HDPA   GetExtsOfAssoc( );
    LPTSTR GetDescOfAssoc( );
    LPTSTR GetMimeOfAssoc( );
    LPTSTR GetCmndOfAssoc( );
    DWORD  GetEditOfAssoc( );

};

// Some Helper Function Prototypes

BOOL     FAR PASCAL InitAssocDialog(HWND hDlg, CAssoc * current = NULL);
void     HandleSelChange( LPASSOCTABINFO pgti , BOOL bChangeAppl = TRUE);
TCHAR *  EatSpaces( TCHAR * str );
TCHAR *  ChopSpaces( TCHAR * str );
TCHAR *  DuplicateString( TCHAR * str );
CAssoc * GetCurrentAssoc( HWND hDlg );

// Member function definitions for CAssoc.

CAssoc::CAssoc( TCHAR * name )
{
    m_type = (TCHAR *) LocalAlloc( LPTR, (lstrlen(name) + 1)*sizeof(TCHAR) );
    StrCpy( m_type, name );
    m_desc = NULL;
    m_mime = NULL;
    m_cmnd = NULL;
    m_stat = NEW ;
    m_safe = TRUE; // Internal Assoc, Dont mess with this
    m_exts = NULL;
    m_edit = 0;
}

CAssoc::~CAssoc()
{
    if( m_type ) LocalFree( m_type );
    if( m_desc ) LocalFree( m_desc );
    if( m_mime ) LocalFree( m_mime );
    if( m_cmnd ) LocalFree( m_cmnd );

    if( m_exts ) FreeExtensions( m_exts );
}

CAssoc::Load()
{
    if(m_type)
    {
       TCHAR * ptr = NULL;

       m_exts = GetExtsOfAssoc();
       m_edit = GetEditOfAssoc();

       if ((ptr = GetDescOfAssoc( )) != NULL)
       { 
          m_desc = (TCHAR *)LocalAlloc( LPTR, (lstrlen(ptr) + 1)*sizeof(TCHAR));
          StrCpy( m_desc, ptr );
          ptr = NULL;
       }
       else 
           // Each type must have a description. (Required)
           return FALSE;

       if ((ptr = GetMimeOfAssoc()) != NULL)
       {
          m_mime = (TCHAR *)LocalAlloc( LPTR, (lstrlen(ptr) + 1)*sizeof(TCHAR));
          StrCpy( m_mime, ptr );
          ptr = NULL;
       }

       if ((ptr = GetCmndOfAssoc()) != NULL)
       {
          m_cmnd = (TCHAR *)LocalAlloc( LPTR, (lstrlen(ptr) + 1)*sizeof(TCHAR));
          StrCpy( m_cmnd, ptr );
          ptr = NULL;
       }

       m_stat = UNM;
       m_safe = FALSE;
    }

    return TRUE;
}

CAssoc::Save()
{

    if( m_safe ) return TRUE;

    if( m_stat != UPD ) return TRUE;

    // Create a Key for DocType in HKEY_CLASSES_ROOT
    // [doctype
    //   (--reg-val-- "Description")
    //   [defaulticon
    //      (reg-val "shell32.dll,3")
    //   ]
    //   [shell
    //     [open
    //       [command
    //         (--reg-val-- "Command" )
    //       ]
    //     ]
    //   ]
    // ]

    HKEY hKey1, hKey2, hKey3, hKey4;

    LONG lResult = RegOpenKeyEx(
            HKEY_CLASSES_ROOT,
            m_type,
            0,
            KEY_QUERY_VALUE|KEY_WRITE,
            &hKey1);

    if (lResult != ERROR_SUCCESS)
    {
        lResult = RegCreateKey(
        HKEY_CLASSES_ROOT,
        m_type,
        &hKey1);
    }

    if (lResult == ERROR_SUCCESS)
    {
        DWORD dwType = REG_SZ;
        DWORD dwLen  = (lstrlen(m_desc)+1)*sizeof(TCHAR);
        RegSetValue( hKey1, NULL, dwType, m_desc, dwLen );

        // Add IEUNIX tag to this entry
        dwLen  = (lstrlen(g_szIEUnixEntry)+1)*sizeof(TCHAR);
        RegSetValueEx( hKey1, g_szIEUnix, 0,
            dwType, (LPBYTE)g_szIEUnixEntry, dwLen );
        
        // Add Edit flags to this entry
        DWORD value = m_edit;
        RegSetValueEx( hKey1, g_szEditFlags, 0,
            REG_DWORD, (LPBYTE)(&value), sizeof(DWORD) ); 

        HKEY hKey2;

        RegDeleteKey( hKey1, TEXT("defaulticon" ) );
       
        lResult = RegCreateKey(
            hKey1,
            TEXT("defaulticon"),
            &hKey2);

        if(lResult == ERROR_SUCCESS)
        {
            DWORD dwType = REG_SZ;
            DWORD dwLen  = (lstrlen(g_szDefaultIcon)+1)*sizeof(TCHAR);
            RegSetValue( hKey2, NULL, dwType, g_szDefaultIcon, dwLen );
            RegCloseKey( hKey2);
        }

        RegDeleteKey( hKey1, g_szCmndSubKey );

        lResult = RegOpenKeyEx(
                hKey1,
                TEXT("shell"),
                0,
                KEY_QUERY_VALUE| KEY_WRITE,
                &hKey2);
       
        if(lResult != ERROR_SUCCESS)
        {
            lResult = RegCreateKey(
                hKey1,
                TEXT("shell"),
                &hKey2);      
        }

        if(lResult == ERROR_SUCCESS)
        {
            lResult = RegOpenKeyEx(
                hKey2,
                TEXT("open"),
                0,
                KEY_QUERY_VALUE| KEY_WRITE,
                &hKey3);

            if( lResult != ERROR_SUCCESS )
            {
                lResult = RegCreateKey(
                    hKey2,
                    TEXT("open"),
                    &hKey3);      
            }

            if( lResult == ERROR_SUCCESS )
            {
                lResult = RegOpenKeyEx(
                    hKey3,
                    TEXT("command"),
                    0,
                    KEY_QUERY_VALUE| KEY_WRITE,
                    &hKey4);

                if( lResult != ERROR_SUCCESS )
                {
                    lResult = RegCreateKey(
                        hKey3,
                        TEXT("command"),
                        &hKey4);      
                }

                if( lResult == ERROR_SUCCESS )
                {
                    DWORD dwType = REG_SZ;
                    DWORD dwLen  = (lstrlen(m_cmnd)+1)*sizeof(TCHAR);

                    RegSetValue( hKey4, NULL, dwType, m_cmnd, dwLen );
                    RegCloseKey( hKey4);
                }
               
                RegCloseKey(hKey3);
            }

            RegCloseKey(hKey2);
        }   

        RegCloseKey(hKey1);
    }    
  
    // Add mime type to the mimetype data base if it doesn't exist
    LPTSTR mimeKey = (LPTSTR)LocalAlloc( LPTR, (lstrlen(m_mime)+lstrlen(g_szMimeKey) + 3)*sizeof(TCHAR));
    
    if(mimeKey && m_mime)
    {
        StrCpy( mimeKey, g_szMimeKey );
        StrCat( mimeKey, TEXT("\\")  );
        StrCat( mimeKey, m_mime      );
        
        lResult = RegOpenKeyEx(
                HKEY_CLASSES_ROOT,
                mimeKey,
                0,
                KEY_QUERY_VALUE| KEY_WRITE,
                &hKey1);
    
        if(lResult != ERROR_SUCCESS)
        {
            lResult = RegCreateKey(
                HKEY_CLASSES_ROOT,
                mimeKey,
                &hKey1);

            if(lResult == ERROR_SUCCESS && m_exts)
            {
                int count    = DPA_GetPtrCount( m_exts );
                if(count > 0 )
                {
                    LPTSTR firstExt = (LPTSTR)DPA_FastGetPtr( m_exts, 0 );
                    RegSetValueEx( hKey1, TEXT("extension"), NULL,
                        REG_SZ, (LPBYTE)firstExt, (lstrlen(firstExt)+1)*sizeof(TCHAR) );
                }

                RegCloseKey( hKey1 );
            }
        }
        else
        {
            RegCloseKey( hKey1 );
        }

    }

    if(mimeKey) 
         LocalFree(mimeKey);

    // Add extention/document type association
    // [.ext
    //   (--reg-val-- "Application")
    //   (content.type "mimetype"  )
    // ]

    // First remove all the extensions for the current assoc from the
    // registry.

    HDPA prevExts = GetExtsOfAssoc();
    if( prevExts )
    {
        int extCount = DPA_GetPtrCount( prevExts );
        for( int i=0; i< extCount; i++ )
           RegDeleteKey( HKEY_CLASSES_ROOT, (LPTSTR)DPA_FastGetPtr( prevExts, i ) ); 

        FreeExtensions( prevExts );
    }


    if( m_exts )
    {
        int count = DPA_GetPtrCount( m_exts );

        for( int i=0; i<count; i++ )
        { 
            LPTSTR ptr = (LPTSTR)DPA_FastGetPtr( m_exts, i );
            if( ptr && *ptr == TEXT('.') )
            {
                lResult = RegOpenKeyEx(
                    HKEY_CLASSES_ROOT,
                    ptr,
                    0,
                    KEY_QUERY_VALUE| KEY_WRITE,
                    &hKey1);

                if( lResult != ERROR_SUCCESS )
                {
                    lResult = RegCreateKey(
                        HKEY_CLASSES_ROOT,
                        ptr, 
                        &hKey1);      
                }

                if( lResult == ERROR_SUCCESS )
                {
                    DWORD dwType = REG_SZ;
                    DWORD dwLen  = (lstrlen(m_type)+1)*sizeof(TCHAR);
                    RegSetValue( hKey1, NULL, dwType, m_type, dwLen );
                       
                    EatSpaces(m_mime ); 
                    dwLen  = lstrlen(m_mime);
                    if(m_mime && (dwLen=lstrlen(m_mime))>0)
                        RegSetValueEx( hKey1, TEXT("Content Type"), 0,
                            dwType, (LPBYTE)m_mime, (dwLen+1)*sizeof(TCHAR) );

                    // Add IEUNIX tag to this entry
                    dwLen  = (lstrlen(g_szIEUnixEntry)+1)*sizeof(TCHAR);
                    RegSetValueEx( hKey1, g_szIEUnix, 0,
                        dwType, (LPBYTE)g_szIEUnixEntry, dwLen );

                    RegCloseKey( hKey1);
                    hKey1 = NULL;
                }
            }
        }
    } 
    else
        return FALSE; 
    
    return TRUE;
}


CAssoc::Delete()
{
    HKEY hKey;
    
    // Don't touch the safe keys
    if( m_safe ) return FALSE;

    // Delete Application from HKEY_CLASSES_ROOT
    EatSpaces(m_type);
    if(m_type && *m_type)
    {
        // NT restrictions
        TCHAR * key = (TCHAR *)LocalAlloc(LPTR, (lstrlen(m_type) + 200)*sizeof(TCHAR) ) ;

        if(!key) return FALSE;
        
        StrCpy( key, m_type );        
        StrCat( key, TEXT("\\defaulticon") );        
        RegDeleteKey(HKEY_CLASSES_ROOT, key);

        StrCpy( key, m_type );        
        StrCat( key, TEXT("\\") );        
        StrCat( key, g_szCmndSubKey );
        RegDeleteKey(HKEY_CLASSES_ROOT, key);

        StrCpy( key, m_type );        
        StrCat( key, TEXT("\\shell\\open") );        
        RegDeleteKey(HKEY_CLASSES_ROOT, key);

        StrCpy( key, m_type );        
        StrCat( key, TEXT("\\shell") );        
        RegDeleteKey(HKEY_CLASSES_ROOT, key);

        RegDeleteKey(HKEY_CLASSES_ROOT, m_type);

        LocalFree( key );
    }
    else
        return FALSE; 

    // Delete Extensions  from HKEY_CLASSES_ROOT
    if( m_exts )
    {
        int count = DPA_GetPtrCount( m_exts );

        for( int i=0; i<count; i++ )
        { 
            LPTSTR ptr = (LPTSTR)DPA_FastGetPtr( m_exts, i );
            if( ptr && *ptr == TEXT('.') )
            {
                RegDeleteKey(HKEY_CLASSES_ROOT, ptr);
            }
        }
    } 
    else
        return FALSE; 

    return TRUE;
}

CAssoc::Print()
{
#ifndef UNICODE
    if( m_type ) printf( m_type );
    printf(",");
    if( m_desc ) printf( m_desc );
    printf(",");
    if( m_mime ) printf( m_mime );
    printf(",");
    if( m_cmnd ) printf( m_cmnd );

    if( m_exts )
    {
        int count = DPA_GetPtrCount( m_exts );
        for( int i=0; i<count; i++ )
        { 
            LPTSTR ptr = (LPTSTR)DPA_FastGetPtr( m_exts, i );
            if( ptr && *ptr == TEXT('.') )
            {
                printf("%s;", ptr );
            }
        }
    }

    printf("\n");
#endif
    return TRUE;
}

HDPA CAssoc::GetExtsOfAssoc()
{
    TCHAR buffer[MAX_PATH];

    DWORD index  = 0;
    DWORD type   = REG_SZ;
    long  dwLen  = MAX_PATH;
    DWORD dwLen2 = MAX_PATH;

    HDPA  exts = DPA_Create(4);
    
    *buffer = TEXT('\0');

    if( !m_type ) return NULL;

    TCHAR * key   = (TCHAR *)LocalAlloc( LPTR, (MAX_PATH+1)*sizeof(TCHAR) );
    TCHAR * value = (TCHAR *)LocalAlloc( LPTR, (MAX_PATH+1)*sizeof(TCHAR) );

    if( !key || !value  ) goto EXIT;

    while( RegEnumKey( HKEY_CLASSES_ROOT, index, key, MAX_PATH ) != ERROR_NO_MORE_ITEMS ) 
    {    
        if( *key == TEXT('.') )
        {
            HKEY  hKey = NULL;

            LONG lResult = RegOpenKeyEx(
                HKEY_CLASSES_ROOT,
                key,
                0,
                KEY_QUERY_VALUE,
                &hKey);

            if( lResult == ERROR_SUCCESS )
            {
                // Get then size first
	        dwLen = (MAX_PATH+1)*sizeof(TCHAR);
		if (RegQueryValue( hKey, NULL, value,  &dwLen )
		    == ERROR_SUCCESS )
		{
		    if( !StrCmpIC( value, m_type ) )
		    {
			DPA_InsertPtr( exts, 0x7FFF, (LPVOID)DuplicateString(key) );
		    }
		}

                RegCloseKey( hKey );
            }
        }
        index++;
    }

EXIT:
    if( key )
        LocalFree( key );
    if( value)
        LocalFree( value );

    return exts;
}


LPTSTR CAssoc::GetDescOfAssoc()
{
    HKEY hKey;

    static TCHAR buffer[MAX_PATH];
    DWORD type  = REG_SZ;
    DWORD dwLen = sizeof(buffer);

    *buffer = TEXT('\0');

    if( !m_type ) return NULL;

    LONG lResult = RegOpenKeyEx(
        HKEY_CLASSES_ROOT,
        m_type,
        0,
        KEY_QUERY_VALUE | KEY_READ,
        &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        lResult = RegQueryValueEx(
           hKey,
           NULL,
           NULL,
           (LPDWORD) &type,
           (LPBYTE)  buffer,
           (LPDWORD) &dwLen);

        RegCloseKey( hKey );

        if( lResult == ERROR_SUCCESS ) 
        {
            return buffer;
        }
        
    }
    return NULL;
}

DWORD CAssoc::GetEditOfAssoc()
{
    HKEY hKey;

    DWORD buffer = 0;
    DWORD type  = REG_DWORD;
    DWORD dwLen = sizeof(buffer);

    if( !m_type ) return NULL;

    LONG lResult = RegOpenKeyEx(
        HKEY_CLASSES_ROOT,
        m_type,
        0,
        KEY_QUERY_VALUE | KEY_READ,
        &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        lResult = RegQueryValueEx(
           hKey,
           g_szEditFlags, 
           NULL,
           (LPDWORD) &type,
           (LPBYTE)  &buffer,
           (LPDWORD) &dwLen);

        RegCloseKey( hKey );

        if( lResult == ERROR_SUCCESS )
        {
            return buffer;
        }

    }

    return 0;
}

LPTSTR CAssoc::GetMimeOfAssoc()
{
    HKEY hKey;

    static TCHAR buffer[MAX_PATH];
    DWORD type  = REG_SZ;
    DWORD dwLen = sizeof(buffer);

    *buffer = TEXT('\0');

    if( !m_type || !m_exts ) return NULL;

    int count = DPA_GetPtrCount( m_exts );

    for( int i=0; i< count; i++ )
    {
        LPTSTR str = (LPTSTR)DPA_FastGetPtr( m_exts, i );

        if( !str ) continue;

        LONG lResult = RegOpenKeyEx(
            HKEY_CLASSES_ROOT,
            str,
            0,
            KEY_QUERY_VALUE | KEY_READ,
            &hKey);

        if (lResult == ERROR_SUCCESS)
        {
            lResult = RegQueryValueEx(
               hKey,
               TEXT("Content Type"),
               NULL,
               (LPDWORD) &type,
               (LPBYTE)  buffer,
               (LPDWORD) &dwLen);

            RegCloseKey( hKey );

            if( lResult == ERROR_SUCCESS ) 
            {
                return buffer;
            }
        }
    }

    return NULL;
}

LPTSTR CAssoc::GetCmndOfAssoc()
{
    HKEY hKey;

    static TCHAR buffer [MAX_PATH];
    TCHAR keyName[MAX_PATH+40];
    DWORD type  = REG_SZ;
    DWORD dwLen = sizeof(buffer);

    *buffer = TEXT('\0');

    if( !m_type ) return NULL;

    StrCpy( keyName, m_type );
    StrCat( keyName, TEXT("\\") );
    StrCat( keyName, g_szCmndSubKey );

    LONG lResult = RegOpenKeyEx(
        HKEY_CLASSES_ROOT,
        keyName,
        0,
        KEY_QUERY_VALUE | KEY_READ,
        &hKey);

    if (lResult == ERROR_SUCCESS)
    {
        lResult = RegQueryValueEx(
           hKey,
           NULL,
           NULL,
           (LPDWORD) &type,
           (LPBYTE)  buffer,
           (LPDWORD) &dwLen);

        RegCloseKey( hKey );

        if( lResult == ERROR_SUCCESS ) 
        {
            return buffer;
        }
    }
    return NULL;
}

HDPA assocList    = (HDPA)NULL;
HDPA assocDelList = (HDPA)NULL;

SetEditLimits(HWND hDlg )
{
    SendMessage(GetDlgItem( hDlg, IDC_DOC_TYPE ), EM_LIMITTEXT, (WPARAM) MAX_PATH-1, 0);
    SendMessage(GetDlgItem( hDlg, IDC_DOC_MIME ), EM_LIMITTEXT, (WPARAM) MAX_PATH-1, 0);
    SendMessage(GetDlgItem( hDlg, IDC_DOC_EXTS ), EM_LIMITTEXT, (WPARAM) MAX_PATH-1, 0);
    SendMessage(GetDlgItem( hDlg, IDC_DOC_DESC ), EM_LIMITTEXT, (WPARAM) MAX_PATH-1, 0);
    SendMessage(GetDlgItem( hDlg, IDC_DOC_CMND ), EM_LIMITTEXT, (WPARAM) MAX_PATH-1, 0);

    return TRUE;
}

TCHAR *DuplicateString( TCHAR *orig )
{
    TCHAR * newStr;
    if( !orig ) return NULL;

    newStr  = (TCHAR *)LocalAlloc( LPTR, (lstrlen(orig) + 1)*sizeof(TCHAR));
    if(newStr) StrCpy( newStr, orig );

    return newStr;
}

TCHAR * EatSpaces( TCHAR * str )
{
    if( !str ) return NULL;

    TCHAR *ptr = str, *tmpStr = DuplicateString( str );
    TCHAR *tmpPtr = tmpStr;

    while( *tmpStr )
    {
        if(*tmpStr == TEXT(' ')  || *tmpStr == TEXT('\t') || 
           *tmpStr == TEXT('\n') || *tmpStr == TEXT('\r') || 
            // Remove special characters.
            (int)(*tmpStr) >= 127)
            tmpStr++; 
        else
            *ptr++ = *tmpStr++;
    }

    *ptr = TEXT('\0');

    LocalFree( tmpPtr );

    return str;
}

TCHAR * ChopSpaces( TCHAR * str )
{
    if( !str ) return NULL;

    TCHAR *ptr = str;

    while( *ptr && 
         (*ptr == TEXT(' ')  || *ptr == TEXT('\t')) ||
         (*ptr == TEXT('\n') || *ptr == TEXT('\r')) 
         ) ptr++;

    TCHAR *tmpStr = DuplicateString( ptr );
    TCHAR *tmpPtr = tmpStr + lstrlen(tmpStr);

    tmpPtr--;

    while( tmpPtr>= tmpStr && 
         (*tmpPtr == TEXT(' ')  || *tmpPtr == TEXT('\t')) ||
         (*tmpPtr == TEXT('\n') || *tmpPtr == TEXT('\r'))
         ) tmpPtr--;

    tmpPtr++;

    *tmpPtr = TEXT('\0');

    StrCpy( str, tmpStr );
    
    LocalFree( tmpStr );

    return str;
}


BOOL FreeAssociations( )
{
    if( assocList == (HDPA)NULL ) return FALSE;

    int assocCount = DPA_GetPtrCount( assocList );

    for(int i=0; i<assocCount; i++ )
    {
        CAssoc * ptr = (CAssoc *)DPA_FastGetPtr( assocList, i );
        if(ptr) delete ptr;
    }

    DPA_Destroy( assocList );
    assocList = (HDPA)NULL;
    return TRUE;
}

BOOL LoadAssociations( )
{
    HKEY hKey;
    int index = 0;
    DWORD dwLen  = MAX_PATH;

    if(assocList) 
        FreeAssociations();

    if((assocList = DPA_Create(4)) == (HDPA)NULL ) 
        return FALSE;

    TCHAR * buffer = (TCHAR *)LocalAlloc( LPTR, (MAX_PATH+1)*sizeof(TCHAR) );
    TCHAR * tmpKey = (TCHAR *)LocalAlloc( LPTR, (MAX_PATH+MAX_PATH+2)*sizeof(TCHAR) );

    while( buffer && tmpKey )
    {
        dwLen  = (MAX_PATH+sizeof(g_szCmndSubKey)+2)*sizeof(TCHAR); 
        if( RegEnumKeyEx( HKEY_CLASSES_ROOT, index, buffer, &dwLen,
                              NULL, NULL, NULL, NULL )
                == ERROR_NO_MORE_ITEMS ) break;
        {
            // Skip Extensions and *.
            if( *buffer == TEXT('.') || *buffer == TEXT('*')) 
            {
                index++;
                continue;
            }

            CAssoc * ptr = NULL;

            StrCpy( tmpKey, buffer );
            StrCat( tmpKey, TEXT("\\"));
            StrCat( tmpKey, g_szCmndSubKey);

            LONG lResult = RegOpenKeyEx(
                    HKEY_CLASSES_ROOT,
                    tmpKey,
                    0,       
                    KEY_QUERY_VALUE | KEY_READ,
                    &hKey);
            if( lResult == ERROR_SUCCESS )
            {
                ptr=new CAssoc(buffer);
                if( ptr->Load() == TRUE ) 
                    DPA_InsertPtr( assocList, 0x7FFF, (LPVOID)ptr);
                else 
                {
                    delete ptr;
                    ptr = NULL;
                }
                RegCloseKey( hKey ); 
            }
   
            // Check if this association needs to be protected.
            //  - uses DDE
            //  - has clsid
            //  - has protected key.
            if(ptr)
            {
                StrCpy(tmpKey, buffer);
                StrCat(tmpKey, TEXT("\\shell\\open\\ddeexec") );
                // wnsprintf(tmpKey, ARRAYSIZE(tmpKey), TEXT("%s\\shell\\open\\ddeexec"), buffer);

                lResult = RegOpenKeyEx(
                        HKEY_CLASSES_ROOT,
                        tmpKey,
                        0,
                        KEY_QUERY_VALUE | KEY_READ,
                        &hKey);
                if( lResult == ERROR_SUCCESS )
                {
                    ptr->m_safe = TRUE;
                    RegCloseKey( hKey );
                    goto Cont;
                }

                StrCpy(tmpKey, buffer);
                StrCat(tmpKey, TEXT("\\clsid") );
                //wnsprintf(tmpKey, ARRAYSIZE(tmpKey), TEXT("%s\\clsid"), buffer);

                lResult = RegOpenKeyEx(
                        HKEY_CLASSES_ROOT,
                        tmpKey,
                        0,
                        KEY_QUERY_VALUE | KEY_READ,
                        &hKey);
                if( lResult == ERROR_SUCCESS )
                {
                    ptr->m_safe = TRUE;
                    RegCloseKey( hKey );
                    goto Cont;
                }

                StrCpy(tmpKey, buffer);
                StrCat(tmpKey, TEXT("\\protected") );
                // wnsprintf(tmpKey, ARRAYSIZE(tmpKey), TEXT("%s\\protected"), buffer);

                lResult = RegOpenKeyEx(
                        HKEY_CLASSES_ROOT,
                        tmpKey,
                        0,
                        KEY_QUERY_VALUE | KEY_READ,
                        &hKey);
                if( lResult == ERROR_SUCCESS )
                {
                    ptr->m_safe = TRUE;
                    RegCloseKey( hKey );
                }
            }

Cont:

            index++;
        }
    }

    if( tmpKey ) LocalFree( tmpKey );
    if( buffer ) LocalFree( buffer );

    return TRUE;
}


BOOL FreeMimeTypes( )
{
    if( mimeList == NULL ) return FALSE;

    int mimeCount = DPA_GetPtrCount( mimeList );

    for(int i=0; i<mimeCount; i++ )
    {
        CMime * ptr = (CMime *)DPA_FastGetPtr( mimeList, i );
        if(ptr) delete ptr;
    }
    
    DPA_Destroy( mimeList );
    mimeList = (HDPA)NULL;
    return TRUE;
}


BOOL LoadMimeTypes( )
{
    HKEY hKeyMime, hKey;
    int index = 0;
    DWORD dwLen  = MAX_PATH;

    if(mimeList) FreeMimeTypes();

    if((mimeList = DPA_Create(4)) == (HDPA)NULL) return FALSE;

    // TODO : Get Max length of the key from registry and use it
    // instead of MAX_PATH.
    TCHAR * buffer = (TCHAR *)LocalAlloc( LPTR, (MAX_PATH+1)*sizeof(TCHAR) );

    LONG lResult = RegOpenKeyEx(
                HKEY_CLASSES_ROOT,
                g_szMimeKey,
                0,
                KEY_QUERY_VALUE | KEY_READ,
                &hKeyMime);
    
    if( lResult == ERROR_SUCCESS )
    {

    while( buffer )
    {
        dwLen  = MAXPATH;
        if( RegEnumKeyEx( hKeyMime, index, buffer, &dwLen,
                              NULL, NULL, NULL, NULL )
                == ERROR_NO_MORE_ITEMS ) break;
        {
            CMime * ptr = new CMime( buffer );

            lResult = RegOpenKeyEx(
                    hKeyMime,
                    buffer,
                    0,
                    KEY_QUERY_VALUE | KEY_READ,
                    &hKey);
            if( lResult == ERROR_SUCCESS )
            {
                dwLen = MAX_PATH;
                if (RegQueryValue( hKey, TEXT("extension"), buffer,  (long *)&dwLen ) 
                    == ERROR_SUCCESS )
                {
                    ptr->m_exts = (TCHAR *)LocalAlloc( LPTR, (dwLen+1)*sizeof(TCHAR));
                    StrCpy(ptr->m_exts, buffer);
                }
                
                RegCloseKey( hKey );
            }

            DPA_InsertPtr(mimeList, 0x7FFF, (LPVOID)ptr);

            index++;
        }
    }

    RegCloseKey( hKeyMime );

    }

    if( buffer ) LocalFree( buffer );

    return TRUE;
}


BOOL PrintAssociations()
{
    printf("Listing Associations:\n");

    if( !assocList ) return FALSE;

    int assocCount = DPA_GetPtrCount( assocList );
    for(int i=0; i<assocCount; i++ )
    {
       CAssoc * ptr = (CAssoc *)DPA_FastGetPtr( assocList, i );
       ptr->Print();
    }

    return TRUE;
}

BOOL FindCommand(HWND hDlg)
{
    TCHAR szFile[MAX_PATH] = TEXT("");
    TCHAR szFilter[5];
    OPENFILENAME ofn;

    HWND hCmnd = GetDlgItem(hDlg, IDC_DOC_CMND );

    memset((void*)&szFilter, 0, 5*sizeof(TCHAR));
    szFilter[0] = TCHAR('*');
    szFilter[2] = TCHAR('*');

    memset((void*)&ofn, 0, sizeof(ofn));
    ofn.lpstrFilter = szFilter;
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hDlg;
    ofn.lpstrFile = szFile;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrInitialDir = NULL;
    ofn.Flags = OFN_HIDEREADONLY|OFN_CREATEPROMPT;

    if (GetOpenFileName(&ofn))
    {
        SendMessage(hCmnd, EM_SETSEL, 0, -1);
        SendMessage(hCmnd, EM_REPLACESEL, 0, (LPARAM)szFile);
    }

    return TRUE;
}

int FindIndex(LPTSTR doc)
{
    if( ! assocList ) return -1;

    int assocCount = DPA_GetPtrCount( assocList );
    for(int i = 0; i< assocCount;i++ )
    {
        CAssoc * ptr = (CAssoc *)DPA_FastGetPtr( assocList, i );
        if( !StrCmp(doc, ptr->m_type ) )
            return i;
    }

    return -1;
}

HDPA CreateDPAForExts( TCHAR * strPassed, int * error, CAssoc * existing)
{
    HKEY hKey;
    int  bFound = 0;
    HDPA hdpaExts = NULL;

    // Check for existing associations not created by IEUNIX
    // [.ext
    //   (--reg-val--  "Application")
    //   (content.type "mimetype"   )
    //   (g_szIEUnix   "g_szIEUnixTag" )
    // ]

    EatSpaces(strPassed);
    if(strPassed && *strPassed)
    {
        TCHAR *strExt = DuplicateString( strPassed );
        TCHAR *pos, *ptr = strExt;
        BOOL  bCont = TRUE;
         
        while(bCont && *ptr)
        {   
            pos = StrChr(ptr, TEXT(';'));

            if(pos)
            {
                bCont = ( *pos == TEXT(';') )? TRUE : FALSE;
                *pos = TEXT('\0');
            }
            else
            {
               bCont = FALSE;
            }
             
            if( !hdpaExts ) hdpaExts = DPA_Create(4);
            DPA_InsertPtr( hdpaExts, 0x7FFF, (LPVOID)DuplicateString( ptr ) );

            if(*ptr == TEXT('.') && *(ptr+1) )
            {
                int  assocCount, extCount;
                assocCount = DPA_GetPtrCount( assocList );
                for( int i = 0; i< assocCount; i++ )
                {
                    CAssoc * pAssoc = (CAssoc*)DPA_FastGetPtr( assocList, i );
                    
                    if( pAssoc->m_exts == NULL || pAssoc == existing ) continue;

                    extCount = DPA_GetPtrCount(pAssoc->m_exts) ;
                    for(int j=0;j<extCount;j++ )
                    {
                       if( !StrCmpI(ptr, (LPTSTR)DPA_FastGetPtr( pAssoc->m_exts, j ) ) )
                       {
                          bFound = IDS_ERROR_EXTS_ALREADY_EXISTS;
                          break;
                       }
                    }
                   
                    if( bFound ) break;
                }
            }
            else
            {
                // Extension must start with a '.'
                bFound = IDS_ERROR_NOT_AN_EXT;
                break;
            }
            ptr = pos+1;
        }

        if(strExt) LocalFree(strExt);
    } 
    else
        bFound = IDS_ERROR_MISSING_EXTS;

    *error = bFound;

    // Error occured while checking extensions
    if( bFound )
    {
        if(hdpaExts) FreeExtensions( hdpaExts );
        return NULL;
    }

    return hdpaExts;
}

// Following functions are called in response to the 
// actions performed on the associations.

AssocDel( HWND hDlg )
{
    int index    = 0;
    int lbindex  = 0;
    HWND lb      = GetDlgItem( hDlg, IDC_DOC_LIST );

    if( (lbindex = SendMessage( lb, LB_GETCURSEL, 0, 0 ) )!= LB_ERR )
    {
        LPTSTR str = (LPTSTR)SendMessage(lb, LB_GETITEMDATA, lbindex, 0 );
        if(str)
        {
            if( (index = FindIndex( str ) ) != -1 )
            {
                 CAssoc * ptr = (CAssoc *)DPA_FastGetPtr( assocList, index );
                 TCHAR question[MAX_PATH];
                 wnsprintf( question, ARRAYSIZE(question), TEXT("Are you Sure you want to delete '%s'?"), ptr->m_desc );
                 if( MessageBox( GetParent(hDlg), question, TEXT("Delete Association"), MB_YESNO ) == IDYES )
                 {
                     CAssoc *pAssoc = (CAssoc *)DPA_DeletePtr( assocList, index );

                    // Add to List of deleted entries
                    if( assocDelList == NULL ) assocDelList = DPA_Create(4);
                    if( assocDelList != NULL ) DPA_InsertPtr( assocDelList, 0x7FFF, pAssoc );

                    SendMessage( lb, LB_DELETESTRING, lbindex, 0 );
                    InitAssocDialog( hDlg ); 
                    SwitchToNrmlMode( hDlg );
                    PropSheet_Changed(GetParent(hDlg),hDlg);
                    LocalFree( str );
                } 
            }
        }
    }

    return TRUE;
}

#ifdef 0
AssocUpd( HWND hDlg )
{
    BOOL bFound = FALSE;
    TCHAR szTemp [1024];
    TCHAR szTitle [80];
    CAssoc *ptr = NULL;
    TCHAR *str;
    int    index, len;
    HDPA   hdpaExts = NULL;

    HWND lb   = GetDlgItem( hDlg, IDC_DOC_LIST );
    HWND exts = GetDlgItem( hDlg, IDC_DOC_EXTS );
    HWND desc = GetDlgItem( hDlg, IDC_DOC_DESC );
    HWND mime = GetDlgItem( hDlg, IDC_DOC_MIME );
    HWND cmnd = GetDlgItem( hDlg, IDC_DOC_CMND );

    MLLoadString(IDS_ERROR_REGISTRY_TITLE, szTitle, sizeof(szTitle));

    // Get the pointer to existing associations.
    if(PGTI_FROM_HDLG(hDlg)->mode == UPDATING)
    {
         ptr = GetCurrentAssoc( hDlg );
    }

    //Check for Description
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_DESC), WM_GETTEXTLENGTH, 0, 0 );
    if( len > 0 )
    {
        str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
        SendMessage(GetDlgItem(hDlg, IDC_DOC_DESC), WM_GETTEXT, len+1, (LPARAM)str );
        ChopSpaces( str );
        if( *str == TEXT('\0') )
        {    
            LocalFree(str);
            MLLoadString(IDS_ERROR_MISSING_DESC, szTemp, sizeof(szTemp));
            MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
            SetFocus( GetDlgItem(hDlg, IDC_DOC_DESC) );
            return FALSE;
        }

        int assocCount = DPA_GetPtrCount( assocList );
        for( int i= 0; i<assocCount; i++ )
        {
            CAssoc * pAssoc ;
            if((pAssoc= (CAssoc *)DPA_FastGetPtr( assocList, i )) == ptr ) continue;
            
            if( StrCmpI( str, pAssoc->m_cmnd ) == NULL )
            {
                LocalFree(str);
                MLLoadString(IDS_ERROR_DESC_ALREADY_EXISTS, szTemp, sizeof(szTemp));
                MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
                SetFocus( GetDlgItem(hDlg, IDC_DOC_DESC) );
                return FALSE;
            }
        }

        LocalFree(str);
    }
    else
    {
        MLLoadString(IDS_ERROR_MISSING_DESC, szTemp, sizeof(szTemp));
        MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
        SetFocus( GetDlgItem(hDlg, IDC_DOC_DESC) );
        return FALSE;
    }

    //Check for MIME
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_MIME), WM_GETTEXTLENGTH, 0, 0 );
    if( len > 0 )
    {
        str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
        SendMessage(GetDlgItem(hDlg, IDC_DOC_MIME), WM_GETTEXT, len+1, (LPARAM)str );
        ChopSpaces( str );
        if( *str != TEXT('\0') )
        {
            if( !StrChr( str, TEXT('/') ) )
            {
                LocalFree(str);
                MLLoadString(IDS_ERROR_INVALID_MIME, szTemp, sizeof(szTemp));
                MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
                SetFocus( GetDlgItem(hDlg, IDC_DOC_MIME) );
                return FALSE;
            }
        }
        LocalFree(str);
    }
    

    //Check for command line
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_CMND), WM_GETTEXTLENGTH, 0, 0 );
    if( len > 0 )
    {
        str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
        SendMessage(GetDlgItem(hDlg, IDC_DOC_CMND), WM_GETTEXT, len+1, (LPARAM)str );
        ChopSpaces( str );
        if( *str == TEXT('\0') )
        {
            LocalFree(str);
            MLLoadString(IDS_ERROR_MISSING_CMND, szTemp, sizeof(szTemp));
            MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
            SetFocus( GetDlgItem(hDlg, IDC_DOC_CMND) );
            return FALSE;
        }    

        LocalFree(str);
    }
    else
    {
        MLLoadString(IDS_ERROR_MISSING_CMND, szTemp, sizeof(szTemp));
        MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
        SetFocus( GetDlgItem(hDlg, IDC_DOC_CMND) );
        return FALSE;
    }

    // Check for extensions.
    // User entered may already have associations in the
    // registry.
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_EXTS), WM_GETTEXTLENGTH, 0, 0 );
    str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
    SendMessage(GetDlgItem(hDlg, IDC_DOC_EXTS), WM_GETTEXT, len+1, (LPARAM)str );

    int error;
    if(!(hdpaExts = CreateDPAForExts(EatSpaces(str), &error, ptr)))
    {
        LocalFree( str );
        MLLoadString(error, szTemp, sizeof(szTemp));
        MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
        SetFocus( GetDlgItem(hDlg, IDC_DOC_EXTS) );
        return FALSE;
    }
    LocalFree( str );

  
    // Check and Add CAssoc if we are inserting a new entry.

    if(PGTI_FROM_HDLG(hDlg)->mode == ADDING)
    {
         LPTSTR firstExt = (LPTSTR)DPA_FastGetPtr( hdpaExts, 0 );
         int len = lstrlen( firstExt ) + lstrlen(g_szDocClass) + 1;
         str = (TCHAR *)LocalAlloc( LPTR, len*sizeof(TCHAR) );

         StrCpy( str, firstExt+1   );
         StrCat( str, g_szDocClass );

         ptr = new CAssoc( str );
         ptr->m_safe = FALSE; // Since we are adding this entry.
         DPA_InsertPtr( assocList, 0x7FFF, ptr );
         LocalFree( str );
    }

    // We are not able to add or retrieve Assoc from the List
    if( ptr == NULL || ptr->m_safe == TRUE )
    {
        FreeExtensions( hdpaExts );
        return FALSE;
    }

    // Start replacing components of the Associations.

    // Replace Extensions
    if(ptr->m_exts) FreeExtensions( ptr->m_exts );
    ptr->m_exts = hdpaExts;
 
    // Replace mime type
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_MIME), WM_GETTEXTLENGTH, 0, 0 );
    str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
    SendMessage(GetDlgItem(hDlg, IDC_DOC_MIME), WM_GETTEXT, len+1, (LPARAM)str );
    if( ptr->m_mime ) LocalFree( ptr->m_mime );
    ptr->m_mime = EatSpaces(str);

    // Replace Description
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_DESC), WM_GETTEXTLENGTH, 0, 0 );
    str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
    SendMessage(GetDlgItem(hDlg, IDC_DOC_DESC), WM_GETTEXT, len+1, (LPARAM)str );
    if( ptr->m_desc ) LocalFree( ptr->m_desc);
    ptr->m_desc = ChopSpaces(str);

    // Replace Command Line
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_CMND), WM_GETTEXTLENGTH, 0, 0 );
    str = (TCHAR *)LocalAlloc( LPTR, (len+4)*sizeof(TCHAR) );
    SendMessage(GetDlgItem(hDlg, IDC_DOC_CMND), WM_GETTEXT, len+1, (LPARAM)str );
    if( ptr->m_cmnd ) LocalFree( ptr->m_cmnd );
    ptr->m_cmnd = ChopSpaces(str);
    if (ptr->m_stat == NEW)
	if (!StrStr(ptr->m_cmnd, TEXT("%1")))
	    lstrcat(ptr->m_cmnd, TEXT(" %1"));
    {
        DWORD dwCurChar;
        BOOL  bPath = FALSE;
	    
        for (dwCurChar = 0; dwCurChar < lstrlen(ptr->m_cmnd); dwCurChar++)
        {
	    if (ptr->m_cmnd[dwCurChar] == TEXT('/'))
            {
		bPath = TRUE;
	    }
	    if (ptr->m_cmnd[dwCurChar] == TEXT(' '))
            {
		break;
	    }
	}
	if (bPath)  // if it's file name with no path we assume it's in the user's PATH
    {    
        CHAR szExeFile[MAX_PATH];
        TCHAR szWarning[MAX_PATH + 128];

#ifndef UNICODE
        lstrcpyn(szExeFile, ptr->m_cmnd, dwCurChar + 1);
#else
        WCHAR wszExeFile[MAX_PATH];
        lstrcpyn(wszExeFile, ptr->m_cmnd, dwCurChar + 1);
        SHUnicodeToAnsi(wszExeFile, szExeFile, ARRAYSIZE(szExeFile));
#endif
        if (access(szExeFile, X_OK) != 0)
	    {
#ifndef UNICODE
            wsprintf(szWarning, TEXT("File %s is not an executable file."), szExeFile);
#else
            wsprintf(szWarning, TEXT("File %s is not an executable file."), wszExeFile);
#endif
		    MessageBox( GetParent(hDlg), szWarning, TEXT("Warning"), MB_OK);
	    }
	}
    }

    if (Button_GetCheck(GetDlgItem(hDlg, IDC_ASSOC_EDIT)) != BST_UNCHECKED)
       ptr->m_edit &= (~FTA_OpenIsSafe );
    else
       ptr->m_edit |= FTA_OpenIsSafe;

    ptr->m_stat = UPD;

    InitAssocDialog( hDlg, ptr );
    SwitchToNrmlMode( hDlg);
    
    // SetFocus to Ok button again
    SetFocus( GetDlgItem(GetParent( hDlg ), IDOK ) );

    PropSheet_Changed(GetParent(hDlg),hDlg);
    return TRUE;
}


AssocAdd( HWND hDlg)
{
    SwitchToAddMode( hDlg );
    PropSheet_Changed(GetParent(hDlg),hDlg);
    return TRUE;
}
#endif // 0

CAssoc * GetCurrentAssoc( HWND hDlg )
{
    int index = 0;
    HWND lb   = GetDlgItem( hDlg, IDC_DOC_LIST );

    if( (index = SendMessage( lb, LB_GETCURSEL, 0, 0 ) )!= LB_ERR )
    {
        TCHAR * str = (LPTSTR)SendMessage( lb, LB_GETITEMDATA, index, 0 );
        if(!str) return NULL;

        if(str && *str)
        {

            if( (index = FindIndex( str ) ) != -1 )
            {
                CAssoc * ptr = (CAssoc *)DPA_FastGetPtr( assocList, index );
                return ptr;
            }
        }
    }
    return NULL;
}

SwitchToNrmlMode( HWND hDlg )
{
    PGTI_FROM_HDLG(hDlg)->mode = NORMAL;

    EnableWindow(GetDlgItem(hDlg,IDC_DOC_DESC), FALSE );
    EnableWindow(GetDlgItem(hDlg,IDC_DOC_EXTS), FALSE );
    EnableWindow(GetDlgItem(hDlg,IDC_DOC_MIME), FALSE );
    EnableWindow(GetDlgItem(hDlg,IDC_DOC_CMND), FALSE );
    EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_EDIT), FALSE );

    if (IsAssocEnabled())
    {
	CAssoc *pAssoc = GetCurrentAssoc( hDlg );
        EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_ADD), TRUE );
	if( pAssoc ) 
        {
	    if( pAssoc->m_safe )
	    {
		EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_DEL), FALSE);
		EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_UPD), FALSE );
	    }
	    else
	    {
		EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_DEL), TRUE );
		EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_UPD), TRUE );
	    }
	}
    }
    else
    {
        EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_DEL), FALSE);
        EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_UPD), FALSE );
        EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_ADD), FALSE );
    }


    REMOVE_DEF_BORDER(hDlg, IDC_ASSOC_ADD );
    REMOVE_DEF_BORDER(hDlg, IDC_ASSOC_UPD );
    REMOVE_DEF_BORDER(hDlg, IDC_ASSOC_DEL );
    SET_DEF_BORDER( GetParent(hDlg), IDOK );

    return TRUE;
}


SwitchToAddMode( HWND hDlg )
{
    PGTI_FROM_HDLG(hDlg)->mode = ADDING;

    LPASSOCTABINFO pgti = (LPASSOCTABINFO)GetWindowLong(hDlg, DWL_USER);

    // Remove Selection from Listbox.
    SendMessage( GetDlgItem(hDlg, IDC_DOC_LIST), LB_SETCURSEL,
           (WPARAM)-1, 0);

    pgti->fInternalChange = TRUE;
    
    // Clear all the fields
    SendMessage( GetDlgItem(hDlg, IDC_DOC_DESC), WM_SETTEXT,
           0, LPARAM( TEXT("")) );
    SendMessage( GetDlgItem(hDlg, IDC_DOC_MIME), WM_SETTEXT,
           0, LPARAM( TEXT("")) );
    SendMessage( GetDlgItem(hDlg, IDC_DOC_EXTS), WM_SETTEXT,
           0, LPARAM( TEXT("")) );
    SendMessage( GetDlgItem(hDlg, IDC_DOC_CMND), WM_SETTEXT,
           0, LPARAM( TEXT("")) );
    
    // Default value
    Button_SetCheck( GetDlgItem( hDlg, IDC_ASSOC_EDIT),  TRUE ); 

    pgti->fInternalChange = FALSE;

    // Enable all edit windows
    EnableWindow(GetDlgItem(hDlg,IDC_DOC_DESC), TRUE);
    EnableWindow(GetDlgItem(hDlg,IDC_DOC_MIME), TRUE);
    EnableWindow(GetDlgItem(hDlg,IDC_DOC_EXTS), TRUE);
    EnableWindow(GetDlgItem(hDlg,IDC_DOC_CMND), TRUE);
    EnableWindow(GetDlgItem(hDlg,IDC_BROWSE  ), TRUE);
    EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_EDIT  ), TRUE);

    // Enable Add option
    EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_ADD), FALSE);
    EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_UPD), TRUE );
    EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_DEL), FALSE);

    // Remove Default Border
    REMOVE_DEF_BORDER( GetParent(hDlg), IDOK );
    REMOVE_DEF_BORDER( hDlg, IDC_ASSOC_ADD);
    REMOVE_DEF_BORDER( hDlg, IDC_ASSOC_DEL);
    SET_DEF_BORDER( hDlg, IDC_ASSOC_UPD );
    SetFocus( GetDlgItem( hDlg, IDC_ASSOC_UPD ) );

    return TRUE;
}

SwitchToUpdMode( HWND hDlg )
{
    if(PGTI_FROM_HDLG(hDlg)->mode != NORMAL )
       return FALSE;

    PGTI_FROM_HDLG(hDlg)->mode = UPDATING;

    // Enable Upd option
    EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_ADD), TRUE );
    EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_UPD), TRUE );
    EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_DEL), TRUE );

    // Remove Default Border
    REMOVE_DEF_BORDER( GetParent(hDlg), IDOK );
    REMOVE_DEF_BORDER( hDlg, IDC_ASSOC_ADD);
    REMOVE_DEF_BORDER( hDlg, IDC_ASSOC_DEL);
    SET_DEF_BORDER( hDlg, IDC_ASSOC_UPD);

    return TRUE;
}

void ListBoxResetContents(HWND listBox)
{
    int count = SendMessage( listBox, LB_GETCOUNT, 0, 0 );

    for( int i= 0; i< count; i++ )
    {
        LPSTR data = (LPSTR)SendMessage( listBox, LB_GETITEMDATA, i, 0 );
        if( data ) LocalFree( data );
    }
    SendMessage( listBox, LB_RESETCONTENT, 0, 0 );
}

BOOL FAR PASCAL InitAssocDialog(HWND hDlg, CAssoc * current)
{
    HRESULT  hr = E_FAIL;
    HKEY     hKey;
    HWND     listBox = GetDlgItem( hDlg, IDC_DOC_LIST );
    TCHAR *  displayString;

    // Allocate memory for a structure which will hold all the info
    // gathered from this page
    //
    LPASSOCTABINFO pgti = (LPASSOCTABINFO)GetWindowLong(hDlg, DWL_USER);
    pgti->fInternalChange = FALSE;

    ListBoxResetContents( listBox );

    if( assocList == NULL ) return FALSE;

    int assocCount = DPA_GetPtrCount( assocList );

    for(int i = 0; i< assocCount; i++ )
    {
        CAssoc * ptr = (CAssoc *)DPA_FastGetPtr( assocList, i );
        int index = SendMessage( listBox, LB_ADDSTRING, 0, (LPARAM)ptr->m_desc );
        SendMessage( listBox, LB_SETITEMDATA, index, (LPARAM)DuplicateString( ptr->m_type ) );
    }

    if( i>0 )
        SendMessage( listBox, LB_SETCURSEL, 0, 0 );
    else
    {
        SendMessage( GetDlgItem(hDlg, IDC_DOC_DESC), WM_SETTEXT,
           0, LPARAM( TEXT("")) );
        SendMessage( GetDlgItem(hDlg, IDC_DOC_MIME), WM_SETTEXT,
           0, LPARAM( TEXT("")) );
        SendMessage( GetDlgItem(hDlg, IDC_DOC_EXTS), WM_SETTEXT,
           0, LPARAM( TEXT("")) );
        SendMessage( GetDlgItem(hDlg, IDC_DOC_CMND), WM_SETTEXT,
           0, LPARAM( TEXT("")) );

        // Default value
        Button_SetCheck( GetDlgItem( hDlg, IDC_ASSOC_EDIT),  TRUE ); 
    }

    // Add Strings to Mimetype dialog
    int mimeCount = 0;

    if( mimeList && (mimeCount = DPA_GetPtrCount(mimeList)))
    {
        for(i=0; i< mimeCount; i++)
        {
            CMime * ptr = (CMime *)DPA_FastGetPtr( mimeList , i );
		    SafeAddStringToComboBox( GetDlgItem(hDlg, IDC_DOC_MIME) , ptr->m_mime) ;
        }   
    }

    if( current )
        SendMessage( listBox, LB_SELECTSTRING, -1, (LPARAM)current->m_desc );

    HandleSelChange( pgti );

    SwitchToNrmlMode( hDlg );

    if( IsAssocEnabled() && i > 0 )
        EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_DEL), TRUE);
    else
        EnableWindow(GetDlgItem(hDlg,IDC_ASSOC_DEL), FALSE);

    return TRUE;
}

void HandleSelChange( LPASSOCTABINFO pgti, BOOL bApplChange )
{
    int index = 0;
    HWND hDlg = pgti->hDlg;
    TCHAR str[MAX_PATH] = TEXT("");

    if( hDlg == NULL ) return;

    HWND exts = GetDlgItem( hDlg, IDC_DOC_EXTS );
    HWND desc = GetDlgItem( hDlg, IDC_DOC_DESC );
    HWND mime = GetDlgItem( hDlg, IDC_DOC_MIME );
    HWND cmnd = GetDlgItem( hDlg, IDC_DOC_CMND );
    HWND brws = GetDlgItem( hDlg, IDC_BROWSE   );
    HWND edit = GetDlgItem( hDlg, IDC_ASSOC_EDIT );

    CAssoc * ptr = GetCurrentAssoc( hDlg );
 
    if(ptr)
    {
        SendMessage( desc, WM_SETTEXT, 0, (LPARAM)ptr->m_desc );
        SendMessage( mime, WM_SETTEXT, 0, (LPARAM)ptr->m_mime );
        SendMessage( cmnd, WM_SETTEXT, 0, (LPARAM)ptr->m_cmnd );

        // Create Extension List
        if( ptr->m_exts )
        {
            int i, count = DPA_GetPtrCount( ptr->m_exts );
            for(i=0;i<count;i++)
            {
                StrCat( str, (LPTSTR)DPA_FastGetPtr( ptr->m_exts, i ) );
                StrCat( str, TEXT(";") );
            }
            SendMessage( exts, WM_SETTEXT, 0, (LPARAM)str );
        }
                
        Button_SetCheck( GetDlgItem( hDlg, IDC_ASSOC_EDIT), !(ptr->m_edit & FTA_OpenIsSafe) ); 

        EnableWindow( desc, !(ptr->m_safe) );
        EnableWindow( exts, !(ptr->m_safe) );
        EnableWindow( mime, !(ptr->m_safe) );
        EnableWindow( cmnd, !(ptr->m_safe) );
        EnableWindow( brws, !(ptr->m_safe) );
        EnableWindow( edit, !(ptr->m_safe) );

        pgti->fInternalChange = FALSE;

        // Change back to the NORMAL mode if not coming from 
        // edit.
        SwitchToNrmlMode( hDlg );
    }
}

BOOL AssocOnCommand(LPASSOCTABINFO pgti, UINT id, UINT nCmd)
{
    switch (id)
    { 
        case IDC_BROWSE:
            switch (nCmd )
            {
               case BN_CLICKED:
               {
                    FindCommand( pgti->hDlg );
                    break;
               }
            }
            break;

        case IDC_ASSOC_ADD:
            switch (nCmd )
            {
                case BN_CLICKED:
                {
		    ENTERASSOC enter;
		    enter.pgti = pgti;
		    enter.pszAssoc = NULL;
		    DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_ENTER_ASSOC), 
					 pgti->hDlg, EnterAssocDlgProc, (LPARAM) &enter);
		    InitAssocDialog( pgti->hDlg, GetCurrentAssoc( pgti->hDlg ) );
		    SwitchToNrmlMode( pgti->hDlg);
		    // SetFocus to Ok button again
		    SetFocus( GetDlgItem(GetParent( pgti->hDlg ), IDOK ) );
		    if (pgti->fChanged)
		    {
		        pgti->fChanged = FALSE;
			PropSheet_Changed(GetParent(pgti->hDlg),pgti->hDlg);
		    }
                    //AssocAdd( pgti->hDlg );
                    break;
               }
            }
            break;

        case IDC_ASSOC_UPD:
            switch (nCmd )
            {
               case BN_CLICKED:
               {
		    HWND lb   = GetDlgItem( pgti->hDlg, IDC_DOC_LIST );
		    int  index;

		    if( (index = SendMessage( lb, LB_GETCURSEL, 0, 0 ) )!= LB_ERR )
		    {
		        TCHAR * str = (LPTSTR)SendMessage( lb, LB_GETITEMDATA, index, 0 );
			ENTERASSOC enter;
			if(!str) return FALSE;
			enter.pgti = pgti;
			enter.pszAssoc = str;
			DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_ENTER_ASSOC), 
					     pgti->hDlg, EnterAssocDlgProc, (LPARAM) &enter);
			InitAssocDialog( pgti->hDlg, GetCurrentAssoc( pgti->hDlg ) );
			SwitchToNrmlMode( pgti->hDlg);
			// SetFocus to Ok button again
			SetFocus( GetDlgItem(GetParent( pgti->hDlg ), IDOK ) );
			if (pgti->fChanged)
			{
			    pgti->fChanged = FALSE;
			    PropSheet_Changed(GetParent(pgti->hDlg),pgti->hDlg);
			}
		    }
                    //AssocUpd( pgti->hDlg );
                    break;
               }
            }
            break;

        case IDC_ASSOC_DEL:
            switch (nCmd )
            {
               case BN_CLICKED:
               {
                    AssocDel( pgti->hDlg ); 
                    break;
               }
            }
            break;

        case IDC_DOC_LIST:
            switch (nCmd )
            {
                case LBN_SELCHANGE:
                     HandleSelChange( pgti );
                     break;
	        case LBN_DBLCLK:
               {
		    HWND lb   = GetDlgItem( pgti->hDlg, IDC_DOC_LIST );
		    int  index;

		    if( (index = SendMessage( lb, LB_GETCURSEL, 0, 0 ) )!= LB_ERR )
		    {
		        TCHAR * str = (LPTSTR)SendMessage( lb, LB_GETITEMDATA, index, 0 );
			ENTERASSOC enter;
			CAssoc *pAssoc = GetCurrentAssoc( pgti->hDlg );
			if(!IsAssocEnabled() || pAssoc->m_safe || !str) return FALSE;
			enter.pgti = pgti;
			enter.pszAssoc = str;
			DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_ENTER_ASSOC), 
					     pgti->hDlg, EnterAssocDlgProc, (LPARAM) &enter);
			InitAssocDialog( pgti->hDlg, GetCurrentAssoc( pgti->hDlg ) );
			SwitchToNrmlMode( pgti->hDlg);
			// SetFocus to Ok button again
			SetFocus( GetDlgItem(GetParent( pgti->hDlg ), IDOK ) );
			if (pgti->fChanged)
			{
			    pgti->fChanged = FALSE;
			    PropSheet_Changed(GetParent(pgti->hDlg),pgti->hDlg);
			}
		    }
                    //AssocUpd( pgti->hDlg );
                    break;
               }
            }
            break;
#ifdef 0
        case IDC_DOC_MIME:
            switch (nCmd)
            {
                case CBN_SELCHANGE:
                case CBN_EDITCHANGE:
                    if (!pgti->fInternalChange)
                    {
                        pgti->fChanged = TRUE;
                        SwitchToUpdMode( pgti->hDlg );
                    }
                    break;
            }
            break;

        case IDC_ASSOC_EDIT:
            switch (nCmd )
            {
               case BN_CLICKED:
               {
                    if (!pgti->fInternalChange)
                    {
                        pgti->fChanged = TRUE;
                        SwitchToUpdMode( pgti->hDlg );
                    }
                    break;
               }
            }
            break;

        case IDC_DOC_TYPE:
        case IDC_DOC_EXTS:
        case IDC_DOC_DESC:
        case IDC_DOC_CMND:
            switch (nCmd)
            {
                case EN_CHANGE:
                    if (!pgti->fInternalChange)
                    {
                        pgti->fChanged = TRUE;
                        SwitchToUpdMode( pgti->hDlg );
                    }
                    break;
                case EN_SETFOCUS:
                    if ( pgti->mode == ADDING)
                    {
                        SET_DEF_BORDER( pgti->hDlg, IDC_ASSOC_UPD );
                        break; 
                    }
            }
            break;
#endif //0
    }

    return FALSE;
}

void AssocApply(HWND hDlg)
{
    // Delete the associations removed by the user.
    if( assocDelList )
    {
        int count = DPA_GetPtrCount( assocDelList );
        
        for(int i=0;i<count;i++)
        {
            CAssoc * pAssoc = (CAssoc *)DPA_FastGetPtr( assocDelList, i );
            if(pAssoc) 
            {
                pAssoc->Delete();
                delete pAssoc;
            }
        }

        DPA_Destroy( assocDelList );
        assocDelList = NULL;
    }

    // Save the currently changed associations.
    if( assocList )
    {
        int count = DPA_GetPtrCount( assocList );
        
        for(int i=0;i<count;i++)
        {
            CAssoc * pAssoc = (CAssoc *)DPA_FastGetPtr( assocList, i );
            if(pAssoc) 
            {  
                pAssoc->Save();
            }
        }
    }
}

/****************************************************************************
 *
 * AssocDlgProc
 *
 *
 ***************************************************************************/
 
BOOL CALLBACK AssocDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    // get our tab info structure
    LPASSOCTABINFO pgti;

    if (uMsg == WM_INITDIALOG)
    {
        // Set Limits for edit fields
        SetEditLimits( hDlg );
  
        // Allocate memory for a structure which will hold all the info
        // gathered from this page
        //
        LPASSOCTABINFO pgti = (LPASSOCTABINFO)LocalAlloc(LPTR, sizeof(ASSOCINFO));
        if (!pgti)
        {
            EndDialog(hDlg, 0);
            return FALSE;
        }

        pgti->hDlg = hDlg;
        pgti->mode = NORMAL;

        pgti->fInternalChange = FALSE;
        SetWindowLong(hDlg, DWL_USER, (LPARAM)pgti);
        
        // Create an association array from registry
        LoadAssociations();
        LoadMimeTypes();

        // Initailize dialog 
        if( InitAssocDialog(hDlg) ) 
        {
            HandleSelChange(pgti);
            return TRUE;
        }
        else
        {
            TCHAR szTitle[MAX_PATH];
            MLLoadString(IDS_ERROR_REGISTRY_TITLE, szTitle, sizeof(szTitle));
            MessageBox( GetParent(hDlg), TEXT("Cannot read associations from registry."), szTitle, MB_OK ); 
            return FALSE;
        }
    }
    else
        pgti = (LPASSOCTABINFO)GetWindowLong(hDlg, DWL_USER);

    if (!pgti)
        return FALSE;

    switch (uMsg)
    {
        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR *) lParam;

            switch (lpnm->code)
            {
                case PSN_QUERYCANCEL:
                case PSN_KILLACTIVE:
                case PSN_RESET:
                    SetWindowLong( hDlg, DWL_MSGRESULT, FALSE );
                    return TRUE;

                case PSN_APPLY:
                    AssocApply(hDlg);
                    break;
            }
            break;
        }

        case WM_COMMAND:
            AssocOnCommand(pgti, LOWORD(wParam), HIWORD(wParam));
            break;

        case WM_HELP:           // F1
            //ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
            //            HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:    // right mouse click
            //ResWinHelp( (HWND) wParam, IDS_HELPFILE,
            //            HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
#if 0
            RemoveDefaultDialogFont(hDlg);
#endif

            if (pgti)
                LocalFree(pgti);

            // Remove Associated data items for the listbos items.
            ListBoxResetContents( GetDlgItem( hDlg, IDC_DOC_LIST ) );
  
            // Delete registry information
            FreeAssociations();
            FreeMimeTypes();

            SetWindowLong(hDlg, DWL_USER, (LONG)NULL);  // make sure we don't re-enter
            break;
    }
    return FALSE;
}

BOOL AssocEnter( HWND hDlg )
{
    LPASSOCTABINFO pgti = ((LPENTERASSOC)GetWindowLong(hDlg, DWL_USER))->pgti;
    BOOL bFound = FALSE;
    TCHAR szTemp [1024];
    TCHAR szTitle [80];
    CAssoc *ptr = NULL;
    TCHAR *str;
    int    index, len;
    HDPA   hdpaExts = NULL;

    HWND exts = GetDlgItem( hDlg, IDC_DOC_EXTS );
    HWND desc = GetDlgItem( hDlg, IDC_DOC_DESC );
    HWND mime = GetDlgItem( hDlg, IDC_DOC_MIME );
    HWND cmnd = GetDlgItem( hDlg, IDC_DOC_CMND );

    MLLoadString(IDS_ERROR_REGISTRY_TITLE, szTitle, sizeof(szTitle));

    // Get the pointer to existing associations.
    if(GetWindowLong(hDlg, DWL_USER))
    {
        TCHAR *pszAssoc = ((LPENTERASSOC)GetWindowLong(hDlg, DWL_USER))->pszAssoc;
	if(pszAssoc && *pszAssoc)
	    if( (index = FindIndex( pszAssoc ) ) != -1 )
	        ptr = (CAssoc *)DPA_FastGetPtr( assocList, index );
    }

    //Check for Description
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_DESC), WM_GETTEXTLENGTH, 0, 0 );
    if( len > 0 )
    {
        str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
        SendMessage(GetDlgItem(hDlg, IDC_DOC_DESC), WM_GETTEXT, len+1, (LPARAM)str );
        ChopSpaces( str );
        if( *str == TEXT('\0') )
        {    
            LocalFree(str);
            MLLoadString(IDS_ERROR_MISSING_DESC, szTemp, sizeof(szTemp));
            MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
            SetFocus( GetDlgItem(hDlg, IDC_DOC_DESC) );
            return FALSE;
        }

        int assocCount = DPA_GetPtrCount( assocList );
        for( int i= 0; i<assocCount; i++ )
        {
            CAssoc * pAssoc ;
            if((pAssoc= (CAssoc *)DPA_FastGetPtr( assocList, i )) == ptr ) continue;
            
            if( StrCmpI( str, pAssoc->m_cmnd ) == NULL )
            {
                LocalFree(str);
                MLLoadString(IDS_ERROR_DESC_ALREADY_EXISTS, szTemp, sizeof(szTemp));
                MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
                SetFocus( GetDlgItem(hDlg, IDC_DOC_DESC) );
                return FALSE;
            }
        }

        LocalFree(str);
    }
    else
    {
        MLLoadString(IDS_ERROR_MISSING_DESC, szTemp, sizeof(szTemp));
        MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
        SetFocus( GetDlgItem(hDlg, IDC_DOC_DESC) );
        return FALSE;
    }

    //Check for MIME
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_MIME), WM_GETTEXTLENGTH, 0, 0 );
    if( len > 0 )
    {
        str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
        SendMessage(GetDlgItem(hDlg, IDC_DOC_MIME), WM_GETTEXT, len+1, (LPARAM)str );
        ChopSpaces( str );
        if( *str != TEXT('\0') )
        {
            if( !StrChr( str, TEXT('/') ) )
            {
                LocalFree(str);
                MLLoadString(IDS_ERROR_INVALID_MIME, szTemp, sizeof(szTemp));
                MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
                SetFocus( GetDlgItem(hDlg, IDC_DOC_MIME) );
                return FALSE;
            }
        }
        LocalFree(str);
    }
    

    //Check for command line
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_CMND), WM_GETTEXTLENGTH, 0, 0 );
    if( len > 0 )
    {
        str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
        SendMessage(GetDlgItem(hDlg, IDC_DOC_CMND), WM_GETTEXT, len+1, (LPARAM)str );
        ChopSpaces( str );
        if( *str == TEXT('\0') )
        {
            LocalFree(str);
            MLLoadString(IDS_ERROR_MISSING_CMND, szTemp, sizeof(szTemp));
            MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
            SetFocus( GetDlgItem(hDlg, IDC_DOC_CMND) );
            return FALSE;
        }    

        LocalFree(str);
    }
    else
    {
        MLLoadString(IDS_ERROR_MISSING_CMND, szTemp, sizeof(szTemp));
        MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
        SetFocus( GetDlgItem(hDlg, IDC_DOC_CMND) );
        return FALSE;
    }

    // Check for extensions.
    // User entered may already have associations in the
    // registry.
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_EXTS), WM_GETTEXTLENGTH, 0, 0 );
    str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
    SendMessage(GetDlgItem(hDlg, IDC_DOC_EXTS), WM_GETTEXT, len+1, (LPARAM)str );

    int error;
    if(!(hdpaExts = CreateDPAForExts(EatSpaces(str), &error, ptr)))
    {
        LocalFree( str );
        MLLoadString(error, szTemp, sizeof(szTemp));
        MessageBox(GetParent(hDlg), szTemp, szTitle, MB_OK);
        SetFocus( GetDlgItem(hDlg, IDC_DOC_EXTS) );
        return FALSE;
    }
    LocalFree( str );

  
    // Check and Add CAssoc if we are inserting a new entry.

    if(!((LPENTERASSOC)GetWindowLong(hDlg, DWL_USER))->pszAssoc)
    {
         LPTSTR firstExt = (LPTSTR)DPA_FastGetPtr( hdpaExts, 0 );
         int len = lstrlen( firstExt ) + lstrlen(g_szDocClass) + 1;
         str = (TCHAR *)LocalAlloc( LPTR, len*sizeof(TCHAR) );

         StrCpy( str, firstExt+1   );
         StrCat( str, g_szDocClass );

         ptr = new CAssoc( str );
         ptr->m_safe = FALSE; // Since we are adding this entry.
         DPA_InsertPtr( assocList, 0x7FFF, ptr );
         LocalFree( str );
    }

    // We are not able to add or retrieve Assoc from the List
    if( ptr == NULL || ptr->m_safe == TRUE )
    {
        FreeExtensions( hdpaExts );
        return FALSE;
    }

    // Start replacing components of the Associations.

    // Replace Extensions
    if(ptr->m_exts) FreeExtensions( ptr->m_exts );
    ptr->m_exts = hdpaExts;
 
    // Replace mime type
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_MIME), WM_GETTEXTLENGTH, 0, 0 );
    str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
    SendMessage(GetDlgItem(hDlg, IDC_DOC_MIME), WM_GETTEXT, len+1, (LPARAM)str );
    if( ptr->m_mime ) LocalFree( ptr->m_mime );
    ptr->m_mime = EatSpaces(str);

    // Replace Description
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_DESC), WM_GETTEXTLENGTH, 0, 0 );
    str = (TCHAR *)LocalAlloc( LPTR, (len+1)*sizeof(TCHAR) );
    SendMessage(GetDlgItem(hDlg, IDC_DOC_DESC), WM_GETTEXT, len+1, (LPARAM)str );
    if( ptr->m_desc ) LocalFree( ptr->m_desc);
    ptr->m_desc = ChopSpaces(str);

    // Replace Command Line
    len = SendMessage( GetDlgItem(hDlg, IDC_DOC_CMND), WM_GETTEXTLENGTH, 0, 0 );
    str = (TCHAR *)LocalAlloc( LPTR, (len+4)*sizeof(TCHAR) );
    SendMessage(GetDlgItem(hDlg, IDC_DOC_CMND), WM_GETTEXT, len+1, (LPARAM)str );
    if( ptr->m_cmnd ) LocalFree( ptr->m_cmnd );
    ptr->m_cmnd = ChopSpaces(str);
    if (ptr->m_stat == NEW)
	if (!StrStr(ptr->m_cmnd, TEXT("%1")))
	    lstrcat(ptr->m_cmnd, TEXT(" %1"));
    {
        DWORD dwCurChar;
        BOOL  bPath = FALSE;
	    
        for (dwCurChar = 0; dwCurChar < lstrlen(ptr->m_cmnd); dwCurChar++)
        {
	    if (ptr->m_cmnd[dwCurChar] == TEXT('/'))
            {
		bPath = TRUE;
	    }
	    if (ptr->m_cmnd[dwCurChar] == TEXT(' '))
            {
		break;
	    }
	}
	if (bPath)  // if it's file name with no path we assume it's in the user's PATH
    {    
        CHAR szExeFile[MAX_PATH];
        TCHAR szWarning[MAX_PATH + 128];

#ifndef UNICODE
        lstrcpyn(szExeFile, ptr->m_cmnd, dwCurChar + 1);
#else
        WCHAR wszExeFile[MAX_PATH];
        lstrcpyn(wszExeFile, ptr->m_cmnd, dwCurChar + 1);
        SHUnicodeToAnsi(wszExeFile, szExeFile, ARRAYSIZE(szExeFile));
#endif
        if (access(szExeFile, X_OK) != 0)
	    {
#ifndef UNICODE
            wsprintf(szWarning, TEXT("File %s is not an executable file."), szExeFile);
#else
            wsprintf(szWarning, TEXT("File %s is not an executable file."), wszExeFile);
#endif
		    MessageBox( GetParent(hDlg), szWarning, TEXT("Warning"), MB_OK);
	    }
	}
    }

    if (Button_GetCheck(GetDlgItem(hDlg, IDC_ASSOC_EDIT)) != BST_UNCHECKED)
       ptr->m_edit &= (~FTA_OpenIsSafe );
    else
       ptr->m_edit |= FTA_OpenIsSafe;

    ptr->m_stat = UPD;

    pgti->fChanged = TRUE;

    return TRUE;
}

BOOL FAR PASCAL InitEnterAssocDialog(HWND hDlg, LPENTERASSOC penter)
{
    LPASSOCTABINFO pgti = penter->pgti;
    int index = 0;
    HWND hDlgParent = pgti->hDlg;
    TCHAR str[MAX_PATH] = TEXT("");

    if( hDlg == NULL ) return;

    HWND exts = GetDlgItem( hDlg, IDC_DOC_EXTS );
    HWND desc = GetDlgItem( hDlg, IDC_DOC_DESC );
    HWND mime = GetDlgItem( hDlg, IDC_DOC_MIME );
    HWND cmnd = GetDlgItem( hDlg, IDC_DOC_CMND );
    HWND brws = GetDlgItem( hDlg, IDC_BROWSE   );
    HWND edit = GetDlgItem( hDlg, IDC_ASSOC_EDIT );

    CAssoc * ptr = NULL;

    if(penter->pszAssoc && *(penter->pszAssoc))
	if( (index = FindIndex( penter->pszAssoc ) ) != -1 )
	    ptr = (CAssoc *)DPA_FastGetPtr( assocList, index );
 
    if(ptr)
    {
        SendMessage( desc, WM_SETTEXT, 0, (LPARAM)ptr->m_desc );
        SendMessage( mime, WM_SETTEXT, 0, (LPARAM)ptr->m_mime );
        SendMessage( cmnd, WM_SETTEXT, 0, (LPARAM)ptr->m_cmnd );

        // Create Extension List
        if( ptr->m_exts )
        {
            int i, count = DPA_GetPtrCount( ptr->m_exts );
            for(i=0;i<count;i++)
            {
                StrCat( str, (LPTSTR)DPA_FastGetPtr( ptr->m_exts, i ) );
                StrCat( str, TEXT(";") );
            }
            SendMessage( exts, WM_SETTEXT, 0, (LPARAM)str );
        }
                
        Button_SetCheck( GetDlgItem( hDlg, IDC_ASSOC_EDIT), !(ptr->m_edit & FTA_OpenIsSafe) ); 

        EnableWindow( desc, !(ptr->m_safe) );
        EnableWindow( exts, !(ptr->m_safe) );
        EnableWindow( mime, !(ptr->m_safe) );
        EnableWindow( cmnd, !(ptr->m_safe) );
        EnableWindow( brws, !(ptr->m_safe) );
        EnableWindow( edit, !(ptr->m_safe) );

        pgti->fInternalChange = FALSE;
    }

    SetWindowLong(hDlg, DWL_USER, (LPARAM)penter);

    int mimeCount = 0;

    if( mimeList && (mimeCount = DPA_GetPtrCount(mimeList)))
    {
        for(int i=0; i< mimeCount; i++)
        {
            CMime * ptr = (CMime *)DPA_FastGetPtr( mimeList , i );
	    SafeAddStringToComboBox( GetDlgItem(hDlg, IDC_DOC_MIME) , ptr->m_mime) ;
        }   
    }


}

BOOL EnterAssocOnCommand(HWND hDlg, UINT id, UINT nCmd, BOOL *pbChanged)
{
    switch (id)
    { 
        case IDC_BROWSE:
            switch (nCmd )
            {
               case BN_CLICKED:
               {
                    FindCommand( hDlg );
                    break;
               }
            }
            break;
        case IDOK:
            switch (nCmd )
            {
                case BN_CLICKED:
                {
		    SwitchToUpdMode(GetParent(hDlg));
		    if (!*pbChanged || AssocEnter(hDlg))
		        return EndDialog(hDlg, 0);
		    else
		        break;
                }
            }
            break;
        case IDCANCEL:
            switch (nCmd )
            {
                case BN_CLICKED:
                {
		    return EndDialog(hDlg, 0);
                }
            }
            break;
        case IDC_DOC_MIME:
            switch (nCmd)
            {
                case CBN_SELCHANGE:
                case CBN_EDITCHANGE:
		    if (!*pbChanged)
		    {
		        *pbChanged = TRUE;
		    }
                    break;
            }
            break;

        case IDC_ASSOC_EDIT:
            switch (nCmd )
            {
               case BN_CLICKED:
               {
		    if (!*pbChanged)
		    {
		        *pbChanged = TRUE;
		    }
                    break;
               }
            }
            break;

        case IDC_DOC_TYPE:
        case IDC_DOC_EXTS:
        case IDC_DOC_DESC:
        case IDC_DOC_CMND:
            switch (nCmd)
            {
                case EN_CHANGE:
		    if (!*pbChanged)
		    {
		        *pbChanged = TRUE;
		    }
                    break;
            }
            break;
    }

    return FALSE;
}

BOOL CALLBACK EnterAssocDlgProc( HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL bChanged;
    if (uMsg == WM_INITDIALOG)
    {
        SendMessage(GetDlgItem( hDlg, IDC_DOC_MIME ), EM_LIMITTEXT, (WPARAM) MAX_PATH-1, 0);
	SendMessage(GetDlgItem( hDlg, IDC_DOC_EXTS ), EM_LIMITTEXT, (WPARAM) MAX_PATH-1, 0);
	SendMessage(GetDlgItem( hDlg, IDC_DOC_DESC ), EM_LIMITTEXT, (WPARAM) MAX_PATH-1, 0);
	SendMessage(GetDlgItem( hDlg, IDC_DOC_CMND ), EM_LIMITTEXT, (WPARAM) MAX_PATH-1, 0);
	InitEnterAssocDialog(hDlg, (LPENTERASSOC)lParam);
	bChanged = FALSE;
    }

    switch (uMsg)
    {
        case WM_COMMAND:
            return EnterAssocOnCommand(hDlg, LOWORD(wParam), HIWORD(wParam), &bChanged);
            break;
    }
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\security.cpp ===
//*********************************************************************
//*          Microsoft Windows                                       **
//*        Copyright(c) Microsoft Corp., 1995                        **
//*********************************************************************

//
// SECURITY.cpp - "Security" Property Sheet
//

// HISTORY:
//
// 6/22/96  t-gpease    moved to this file
// 5/14/97  t-ashlm     new dialog

#include "inetcplp.h"
#include "inetcpl.h"   // for LSDFLAGS
#include "intshcut.h"
#include "permdlg.h"   // java permissions
#include "pdlgguid.h"  // guids for Java VM permissions dlg
#include "advpub.h"
#include <cryptui.h>

#include <mluisupp.h>

void LaunchSecurityDialogEx(HWND hDlg, DWORD dwZone, BOOL bForceUI, BOOL bDisableAddSites);

//
// Private Functions and Structures
//
INT_PTR CALLBACK SecurityAddSitesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK SecurityCustomSettingsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);
INT_PTR CALLBACK SecurityAddSitesIntranetDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam);
void SecurityChanged();

TCHAR *MyIntToStr(TCHAR *pBuf, BYTE iVal);
BOOL SecurityDlgInit(HWND hDlg);


#define WIDETEXT(x) L ## x
#define REGSTR_PATH_SO                TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\SO")
#define REGSTR_PATH_SOIEAK            TEXT("Sofwtare\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\SOIEAK")

///////////////////////////////////////////////////////////////////////////////////////
//
// Structures
//
///////////////////////////////////////////////////////////////////////////////////////

typedef struct tagSECURITYZONESETTINGS
{
    BOOL    dwFlags;            // from the ZONEATTRIBUTES struct
    DWORD   dwZoneIndex;        // as defined by ZoneManager
    DWORD   dwSecLevel;         // current level (High, Medium, Low, Custom)
    DWORD   dwPrevSecLevel;
    DWORD   dwMinSecLevel;      // current min level (High, Medium, Low, Custom)
    DWORD   dwRecSecLevel;      // current recommended level (High, Medium, Low, Custom)
    TCHAR   szDescription[MAX_ZONE_DESCRIPTION];
    TCHAR   szDisplayName[MAX_ZONE_PATH];
    HICON   hicon;
} SECURITYZONESETTINGS, *LPSECURITYZONESETTINGS;

// structure for main security page
typedef struct tagSECURITYPAGE
{
    HWND                    hDlg;                   // handle to window
    LPURLZONEMANAGER        pInternetZoneManager;   // pointer to InternetZoneManager
    IInternetSecurityManager *pInternetSecurityManager; // pointer to InternetSecurityManager
    HIMAGELIST              himl;                   // imagelist for Zones combobox
    HWND                    hwndZones;              // zones combo box hwnd
    LPSECURITYZONESETTINGS  pszs;                   // current settings for displayed zone
    INT                     iZoneSel;               // selected zone (as defined by ComboBox)
    DWORD                   dwZoneCount;            // number of zones
    BOOL                    fChanged;
    BOOL                    fPendingChange;         // to prevent the controls sending multiple sets (for cancel, mostly)
    HINSTANCE               hinstUrlmon;
    BOOL                    fNoEdit;                // hklm lockout of level edit
    BOOL                    fNoAddSites;            // hklm lockout of addsites
    BOOL                    fNoZoneMapEdit;         // hklm lockout of zone map edits
    HFONT                   hfontBolded;            // special bolded font created for the zone title
    BOOL                    fForceUI;               // Force every zone to show ui?
    BOOL                    fDisableAddSites;       // Automatically diable add sites button?
    TCHAR                   szPageUrl[INTERNET_MAX_URL_LENGTH];
} SECURITYPAGE, *LPSECURITYPAGE;

// structure for Intranet Add Sites
typedef struct tagADDSITESINTRANETINFO {
    HWND hDlg;                                      // handle to window
    BOOL fUseIntranet;                              // Use local defined intranet addresses (in reg)
    BOOL fUseProxyExclusion;                        // Use proxy exclusion list
    BOOL fUseUNC;                                   // Include UNC in intranet
    LPSECURITYPAGE pSec;            
} ADDSITESINTRANETINFO, *LPADDSITESINTRANETINFO;

// structure for Add Sites
typedef struct tagADDSITESINFO {
    HWND hDlg;                                      // handle to window
    BOOL fRequireServerVerification;                // Require Server Verification on sites in zone
    HWND hwndWebSites;                              // handle to list
    HWND hwndAdd;                                   // handle to edit
    TCHAR szWebSite[MAX_ZONE_PATH];                 // text in edit control
    BOOL fRSVOld;
    LPSECURITYPAGE pSec;            
} ADDSITESINFO, *LPADDSITESINFO;

// structure for Custom Settings 
typedef struct tagCUSTOMSETTINGSINFO {
    HWND  hDlg;                                     // handle to window
    HWND hwndTree;

    LPSECURITYPAGE pSec;
    HWND hwndCombo;
    INT iLevelSel;
    IRegTreeOptions *pTO;
    BOOL fUseHKLM;          // get/set settings from HKLM
    DWORD dwJavaPolicy;     // Java policy selected
    BOOL fChanged;
} CUSTOMSETTINGSINFO, *LPCUSTOMSETTINGSINFO;


BOOL SecurityEnableControls(LPSECURITYPAGE pSec, BOOL fSetFocus);
BOOL SecurityDlgApplyNow(LPSECURITYPAGE pSec, BOOL bPrompt);
void SiteAlreadyInZoneMessage(HWND hwnd, DWORD dwZone);

// global variables
extern DWORD g_dwtlsSecInitFlags;

extern BOOL g_fSecurityChanged; // flag indicating that Active Security has changed.

//////////////////////////////////////////////////////////////////////////////
//
// Main Security Page Helper Functions
//
//////////////////////////////////////////////////////////////////////////////

#define NUM_TEMPLATE_LEVELS      4
TCHAR g_szLevel[3][64];
TCHAR LEVEL_DESCRIPTION0[300];
TCHAR LEVEL_DESCRIPTION1[300];
TCHAR LEVEL_DESCRIPTION2[300];
TCHAR LEVEL_DESCRIPTION3[300];
LPTSTR LEVEL_DESCRIPTION[NUM_TEMPLATE_LEVELS] = {
    LEVEL_DESCRIPTION0,
    LEVEL_DESCRIPTION1,
    LEVEL_DESCRIPTION2,
    LEVEL_DESCRIPTION3
};
TCHAR CUSTOM_DESCRIPTION[300];

TCHAR LEVEL_NAME0[30];
TCHAR LEVEL_NAME1[30];
TCHAR LEVEL_NAME2[30];
TCHAR LEVEL_NAME3[30];
LPTSTR LEVEL_NAME[NUM_TEMPLATE_LEVELS] = {
    LEVEL_NAME0,
    LEVEL_NAME1,
    LEVEL_NAME2,
    LEVEL_NAME3
};
TCHAR CUSTOM_NAME[30];

// Some accessibility related prototypes.

// Our override of the slider window proc. 
LRESULT CALLBACK SliderSubWndProc (HWND hwndSlider, UINT uMsg, WPARAM wParam, LPARAM lParam, WPARAM uID, ULONG_PTR dwRefData );

extern BOOL g_fAttemptedOleAccLoad ;
extern HMODULE g_hOleAcc;


// Can't find value for WM_GETOBJECT in the headers. Need to figure out the right header to include
// here. 
#ifndef WM_GETOBJECT
#define WM_GETOBJECT        0x03d
#endif

// Prototype for CreateStdAccessibleProxy.
// A and W versions are available - pClassName can be ANSI or UNICODE
// string. This is a TCHAR-style prototype, but you can do a A or W
// specific one if desired.
typedef HRESULT (WINAPI *PFNCREATESTDACCESSIBLEPROXY) (
    HWND     hWnd,
    LPTSTR   pClassName,
    LONG     idObject,
    REFIID   riid,
    void **  ppvObject 
    );
/*
 * Arguments:
 *
 * HWND hWnd
 *   Handle of window to return IAccessible for.
 *
 * LPTSTR pClassName
 *   Class name indicating underlying class of the window. For
 *   example, if "LISTBOX" is used here, the returned object will
 *   behave appropriately for a listbox, and will expect the given
 *   hWnd to support listbox messages and styles. This argument
 *   nearly always reflects the window class from which the control
 *   is derived.
 *
 * LONG idObject
 *   Always OBJID_CLIENT
 *
 * REFIID riid
 *   Always IID_IAccessible
 *
 * void ** ppvObject
 *   Out pointer used to return an IAccessible to a newly-created
 *   object which represents the control hWnd as though it were of
 *   window class pClassName.
 *
 * If successful,
 * returns S_OK, *ppvObject != NULL;
 * otherwise returns error HRESULT.
 *
 *
 */



// Same for LresultFromObject...
typedef LRESULT (WINAPI *PFNLRESULTFROMOBJECT)(
    REFIID riid,
    WPARAM wParam,
    LPUNKNOWN punk 
    );


PRIVATE PFNCREATESTDACCESSIBLEPROXY s_pfnCreateStdAccessibleProxy = NULL;
PRIVATE PFNLRESULTFROMOBJECT s_pfnLresultFromObject = NULL;

// Simple accessibility wrapper class which returns the right string values

class CSecurityAccessibleWrapper: public CAccessibleWrapper
{
                // Want to remember the hwnd of the trackbar...
                HWND m_hWnd;
public:
                CSecurityAccessibleWrapper( HWND hWnd, IAccessible * pAcc );
               ~CSecurityAccessibleWrapper();

                STDMETHODIMP get_accValue(VARIANT varChild, BSTR* pszValue);
};

// Ctor - pass through the IAccessible we're wrapping to the
// CAccessibleWrapper base class; also remember the trackbar hwnd.
CSecurityAccessibleWrapper::CSecurityAccessibleWrapper( HWND hWnd, IAccessible * pAcc )
    : CAccessibleWrapper( pAcc ),
      m_hWnd( hWnd )

{
    // Do nothing
}

// Nothing to do here - but if we do need to do cleanup, this is the
// place for it.
CSecurityAccessibleWrapper::~CSecurityAccessibleWrapper()
{
    // Do nothing
}


// Overridden get_accValue method...
STDMETHODIMP   CSecurityAccessibleWrapper::get_accValue(VARIANT varChild, BSTR* pszValue)
{
    // varChild.lVal specifies which sub-part of the component
    // is being queried.
    // CHILDID_SELF (0) specifies the overall component - other
    // non-0 values specify a child.

    // In a trackbar, CHILDID_SELF refers to the overall trackbar
    // (which is what we want), whereas other values refer to the
    // sub-components - the actual slider 'thumb', and the 'page
    // up/page down' areas to the left/right of it.
    if( varChild.vt == VT_I4 && varChild.lVal == CHILDID_SELF )
    {
        // Get the scrollbar value...
        int iPos = (int)SendMessage( m_hWnd, TBM_GETPOS , 0, 0 );

        // Check that it's in range...
        // (It's possible that we may get this request after the
        // trackbar has been created, bu before we've set it to
        // a meaningful value.)
        if( iPos < 0 || iPos >= NUM_TEMPLATE_LEVELS )
        {
            TCHAR rgchUndefined[40];
            int cch = MLLoadString(IDS_TEMPLATE_NAME_UNDEFINED, rgchUndefined, ARRAYSIZE(rgchUndefined));
            if (cch != 0)
            {
                *pszValue = SysAllocString(rgchUndefined);
            }
            else
            {
                // Load String failed, for some reason.
                return HRESULT_FROM_WIN32(GetLastError());
            }
    
        }
        else
        {
            *pszValue = SysAllocString( LEVEL_NAME[iPos]);
        }
        
        // All done!
        return S_OK;

    }
    else
    {
        // Pass requests about the sub-components to the
        // base class (which will forward to the 'original'
        // IAccessible for us).
        return CAccessibleWrapper::get_accValue(varChild, pszValue);
    }
}


// Converting the Security Level DWORD identitifiers to slider levels, and vice versa
int SecLevelToSliderPos(DWORD dwLevel)
{
    switch(dwLevel)
    {
        case URLTEMPLATE_LOW:
            return 3;
        case URLTEMPLATE_MEDLOW:
            return 2;
        case URLTEMPLATE_MEDIUM:
            return 1;
        case URLTEMPLATE_HIGH:
            return 0;        
        case URLTEMPLATE_CUSTOM:
            return -1;            
        default:
            return -2;
    }
}

DWORD SliderPosToSecLevel(int iPos)
{
    switch(iPos)
    {
        case 3:
            return URLTEMPLATE_LOW;
        case 2:
            return URLTEMPLATE_MEDLOW;
        case 1:
            return URLTEMPLATE_MEDIUM;
        case 0:
            return URLTEMPLATE_HIGH;
        default:
            return URLTEMPLATE_CUSTOM;
    }
}

int ZoneIndexToGuiIndex(DWORD dwZoneIndex)
// Product testing asked for the zones in a specific order in the list box;
// This function returns the desired gui position for a given zone
// Unrecognized zones are added to the front
{
    int iGuiIndex = -1;
    switch(dwZoneIndex)
    {
        // Intranet: 2nd spot
        case 1:
            iGuiIndex = 1;
            break;

        // Internet: 1st spot
        case 3:
            iGuiIndex = 0;
            break;

        // Trusted Sites: 3rd Spot
        case 2:
            iGuiIndex = 2;
            break;

        // Restricted Sites: 4th Spot
        case 4:
            iGuiIndex = 3;
            break;

        // unknown zone
        default:
            iGuiIndex = -1;   
            break;
    }


    return iGuiIndex;
}



// Initialize the global variables (to be destroyed at WM_DESTROY)
// pSec, Urlmon, pSec->pInternetZoneManager, pSec->hIml
// and set up the proper relationships among them
BOOL SecurityInitGlobals(LPSECURITYPAGE * ppSec, HWND hDlg, SECURITYINITFLAGS * psif)
{
    DWORD cxIcon;
    DWORD cyIcon;

    LPSECURITYPAGE pSec = NULL;

    *ppSec = (LPSECURITYPAGE)LocalAlloc(LPTR, sizeof(SECURITYPAGE));
    pSec = *ppSec;
    if (!pSec)
    {
        return FALSE;   // no memory?
    }

    // make sure Urlmon stays around until we're done with it.
    pSec->hinstUrlmon = LoadLibrary(TEXT("URLMON.DLL"));
    if(pSec->hinstUrlmon == NULL)
    {
        return FALSE;  // no urlmon?
    }

    // Get the zone manager
    if (FAILED(CoInternetCreateZoneManager(NULL, &(pSec->pInternetZoneManager),0)))
    {
        return FALSE;  // no zone manager?
    }

    // get our zones hwnd
    if (hDlg)
    {
        pSec->hwndZones = GetDlgItem(hDlg, IDC_LIST_ZONE);
        if(! pSec->hwndZones)
        {
            ASSERT(FALSE);
            return FALSE;  // no list box?
        }
    }

    // Get the internet secrity manager (for telling if a zone is empty, 
    // and deciphering the current URL
    if(FAILED(CoInternetCreateSecurityManager(NULL, &(pSec->pInternetSecurityManager), 0)))
        pSec->pInternetSecurityManager = NULL;

    // Store the URL for use by the Add Sites sub-dialog
    StrCpyN(pSec->szPageUrl, g_szCurrentURL, ARRAYSIZE(pSec->szPageUrl));    

    // tell dialog where to get info
    if (hDlg)
    {
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pSec);
    }

    // save the handle to the page
    pSec->hDlg = hDlg;
    pSec->fPendingChange = FALSE;

    // set dialog options: force ui and disable add sites
    if(psif)
    {
        pSec->fForceUI = psif->fForceUI;
        pSec->fDisableAddSites = psif->fDisableAddSites;
    }
    
    // create an imagelist for the ListBox            
    cxIcon = GetSystemMetrics(SM_CXICON);
    cyIcon = GetSystemMetrics(SM_CYICON);
#ifndef UNIX
    UINT flags = ILC_COLOR32|ILC_MASK;
    
    if(IS_WINDOW_RTL_MIRRORED(hDlg))
    {
        flags |= ILC_MIRROR;
    }
    pSec->himl = ImageList_Create(cxIcon, cyIcon, flags, pSec->dwZoneCount, 0);
#else
    pSec->himl = ImageList_Create(cxIcon, cyIcon, ILC_COLOR|ILC_MASK, pSec->dwZoneCount, 0);
#endif
    if(! pSec->himl)
    {
        return FALSE;  // Image list not created
    }
    if (hDlg)
    {
        SendMessage(pSec->hwndZones, LVM_SETIMAGELIST, (WPARAM)LVSIL_NORMAL, (LPARAM)pSec->himl);
    }

    return TRUE;    
}

void FreePszs(SECURITYZONESETTINGS* pszs)
{
    if (pszs->hicon)
        DestroyIcon(pszs->hicon);
    LocalFree((HLOCAL)pszs);
}

void SecurityFreeGlobals(SECURITYPAGE* pSec)
{
    if(pSec->hwndZones)
    {
        for (int iIndex = (int)SendMessage(pSec->hwndZones, LVM_GETITEMCOUNT, 0, 0) - 1;
                iIndex >= 0; iIndex--)
        {
            LV_ITEM lvItem;

            // get security zone settings object for this item and release it
            lvItem.mask = LVIF_PARAM;
            lvItem.iItem = iIndex;
            lvItem.iSubItem = 0;
            if (SendMessage(pSec->hwndZones, LVM_GETITEM, (WPARAM)0, (LPARAM)&lvItem) == TRUE)
            {
                LPSECURITYZONESETTINGS pszs = (LPSECURITYZONESETTINGS)lvItem.lParam;
                if (pszs)
                {
                    FreePszs(pszs);
                    pszs = NULL;
                }
            }                 
        }   
    }

    if(pSec->pInternetZoneManager)
        pSec->pInternetZoneManager->Release();

    if(pSec->pInternetSecurityManager)
        pSec->pInternetSecurityManager->Release();

    if(pSec->himl)
        ImageList_Destroy(pSec->himl);

    if(pSec->hfontBolded)
        DeleteObject(pSec->hfontBolded);

    // ok, we're done with URLMON
    if(pSec->hinstUrlmon)
        FreeLibrary(pSec->hinstUrlmon);

    LocalFree(pSec);
}

// Set up the variables in pSec about whether the zone settings can be editted
void SecuritySetEdit(LPSECURITYPAGE pSec)
{
    // if these calls fail then we'll use the default of zero which means no lockout
    DWORD cb;
    

    cb = SIZEOF(pSec->fNoEdit);  
    SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_SECURITY_LOCKOUT, REGSTR_VAL_OPTIONS_EDIT, 
                NULL, &(pSec->fNoEdit), &cb);

    // also allow g_restrict to restrict changing settings
    pSec->fNoEdit += g_restrict.fSecChangeSettings;
    
    SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_SECURITY_LOCKOUT, REGSTR_VAL_OPTIONS_EDIT, 
                NULL, &(pSec->fNoAddSites), &cb);

    cb = SIZEOF(pSec->fNoZoneMapEdit);
    SHGetValue(HKEY_LOCAL_MACHINE, REGSTR_PATH_SECURITY_LOCKOUT, REGSTR_VAL_ZONES_MAP_EDIT, 
                NULL, &(pSec->fNoZoneMapEdit), &cb);

    // also allow the g_restrict to restrict edit
    pSec->fNoAddSites += g_restrict.fSecAddSites;
}


// Fill a zone with information from the zone manager and add it to the
// ordered list going to the listbox
// REturn values:
//  S_OK indicates success
//  S_FALSE indicates a good state, but the zone was not added (example: flag ZAFLAGS_NO_UI)
//  E_OUTOFMEMORY
//  E_FAIL - other failure
HRESULT SecurityInitZone(DWORD dwIndex, LPSECURITYPAGE pSec, DWORD dwZoneEnumerator, 
                         LV_ITEM * plviZones, BOOL * pfSpotTaken)
{
        DWORD                   dwZone;
        ZONEATTRIBUTES          za = {0};
        HICON                   hiconSmall = NULL;
        HICON                   hiconLarge = NULL;
        LPSECURITYZONESETTINGS  pszs;
        WORD                    iIcon=0;
        LPWSTR                  psz;
        TCHAR                   szIconPath[MAX_PATH];
        int                     iSpot;
        LV_ITEM *               plvItem;
        HRESULT                 hr = 0;



        // get the zone attributes for this zone
        za.cbSize = sizeof(ZONEATTRIBUTES);
        pSec->pInternetZoneManager->GetZoneAt(dwZoneEnumerator, dwIndex, &dwZone);
        hr = pSec->pInternetZoneManager->GetZoneAttributes(dwZone, &za);
        if(FAILED(hr))
        {
            return S_FALSE;
        }

        // if no ui, then ignore
        if ((za.dwFlags & ZAFLAGS_NO_UI) && !pSec->fForceUI)
        {
            return S_FALSE;
        }



        // create a structure for zone settings
        pszs = (LPSECURITYZONESETTINGS)LocalAlloc(LPTR, sizeof(*pszs));
        if (!pszs)
        {
            return E_OUTOFMEMORY;
        }



        // store settings for later use
        pszs->dwFlags       = za.dwFlags;
        pszs->dwZoneIndex   = dwZone;
        pszs->dwSecLevel    = za.dwTemplateCurrentLevel;    
        pszs->dwMinSecLevel = za.dwTemplateMinLevel;
        pszs->dwRecSecLevel = za.dwTemplateRecommended;                 
        StrCpyN(pszs->szDescription, za.szDescription, ARRAYSIZE(pszs->szDescription));
        StrCpyN(pszs->szDisplayName, za.szDisplayName, ARRAYSIZE(pszs->szDisplayName));
        // load the icon                
        psz = za.szIconPath;
        if (*psz)
        {
            // search for the '#'
            while ((psz[0] != WIDETEXT('#')) && (psz[0] != WIDETEXT('\0')))
                psz++;
            
            // if we found it, then we have the foo.dll#00001200 format
            if (psz[0] == WIDETEXT('#'))
            {
                psz[0] = WIDETEXT('\0');
                StrCpyN(szIconPath, za.szIconPath, ARRAYSIZE(szIconPath));
                iIcon = (WORD)StrToIntW(psz+1);
                CHAR szPath[MAX_PATH];
                SHUnicodeToAnsi(szIconPath, szPath, ARRAYSIZE(szPath));
                ExtractIconExA(szPath,(UINT)(-1*iIcon), &hiconLarge, &hiconSmall, 1);
            }
            else
            {
                hiconLarge = (HICON)ExtractAssociatedIcon(ghInstance, szIconPath, (LPWORD)&iIcon);
            }
        }
        // no icons?!  well, just use the generic icon
        if (!hiconSmall && !hiconLarge)
        {
            hiconLarge = LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_ZONE));
            if(! hiconLarge)
            {
                LocalFree((HLOCAL)pszs);
                return S_FALSE;  // no icon found for this zone, not even the generic one
            }
        }
        // we want to save the Large icon if possible for use in the subdialogs
        pszs->hicon = hiconLarge ? hiconLarge : hiconSmall;

        
        if (plviZones && pfSpotTaken)
        {
            // Find the proper index for the zone in the listbox (there is a user-preferred order)
            iSpot = ZoneIndexToGuiIndex(dwIndex);
            if(iSpot == -1)
            {
                // if not a recognized zone, add it to the end of the list
                iSpot = pSec->dwZoneCount - 1;
            }
            // Make sure there are no collisisons
            while(iSpot >= 0 && pfSpotTaken[iSpot] == TRUE)
            {
                iSpot--;
            }
            // Don't go past beginning of array
            if(iSpot < 0)
            {
                // It can be proven that it is impossible to get here, unless there is
                // something wrong with the function ZoneIndexToGuiIndex
                ASSERT(FALSE);
                LocalFree((HLOCAL)pszs);
                if(hiconSmall)
                    DestroyIcon(hiconSmall);
                if(hiconLarge)
                    DestroyIcon(hiconLarge);
                return E_FAIL;
            }

            plvItem = &(plviZones[iSpot]);
            pfSpotTaken[iSpot] = TRUE;


            // init the List Box item and save it for later addition
            plvItem->mask           = LVIF_TEXT | LVIF_IMAGE | LVIF_PARAM;
            plvItem->iItem          = iSpot;
            plvItem->iSubItem       = 0;
            // large icons prefered for the icon view (if switch back to report view, prefer small icons)
            plvItem->iImage         = ImageList_AddIcon(pSec->himl, hiconLarge ? hiconLarge : hiconSmall);

            plvItem->pszText        = new TCHAR[MAX_PATH];
            if(! plvItem->pszText)
            {
                LocalFree((HLOCAL)pszs);
                if(hiconSmall)
                    DestroyIcon(hiconSmall);   
                if(hiconLarge)
                    DestroyIcon(hiconLarge);
                return E_OUTOFMEMORY;
            }

            MLLoadString( IDS_ZONENAME_LOCAL + dwIndex, plvItem->pszText, MAX_PATH);

            plvItem->lParam         = (LPARAM)pszs;       // save the zone settings here
        }
        else
        {
            pSec->pszs = pszs;
        }
        

        // if we created a small icon, destroy it, since the system does not save the handle
        // when it is added to the imagelist (see ImageList_AddIcon in VC help)
        // Keep it around if we had to use it in place of the large icon
        if (hiconSmall && hiconLarge)
            DestroyIcon(hiconSmall);   

        return S_OK;
}

// Find the current zone from, in order of preference,
// Current URL
// Parameter passed in through dwZone
// Default of internet
void SecurityFindCurrentZone(LPSECURITYPAGE pSec, SECURITYINITFLAGS * psif)
{
    INT_PTR iItem;
    DWORD dwZone=0;
    HRESULT hr = E_FAIL;

    // Check for zone selection in psif
    if(psif)
    {
        dwZone = psif->dwZone;
        hr = S_OK;
    }

    // check for current url, and if found, make it's zone the current (overwriting any request from
    // psif)
    if (g_szCurrentURL[0] && (pSec->pInternetSecurityManager != NULL))
    {
        LPWSTR pwsz;

#ifndef UNICODE
        WCHAR wszCurrentURL[MAX_URL_STRING];
        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, g_szCurrentURL, -1, wszCurrentURL, ARRAYSIZE(wszCurrentURL));
        pwsz = wszCurrentURL;
#else
        pwsz = g_szCurrentURL;
#endif
        hr = pSec->pInternetSecurityManager->MapUrlToZone(pwsz, (LPDWORD)&dwZone, 0);        
    }
    

    // If there is an active zone, then dwZone now holds the zone's identifier
    // if there is no active zone, check to see if there was a zone requested in dwZone
    iItem = -1;
    if (SUCCEEDED(hr)) // then we have a zone to display
    {
        ZONEATTRIBUTES za = {0};
        LPTSTR pszText;
        LV_FINDINFO lvfiName;
       
        za.cbSize = (ULONG) sizeof(ZONEATTRIBUTES);
        if(pSec->pInternetZoneManager->GetZoneAttributes(dwZone, &za) != E_FAIL)
        {
#ifdef UNICODE    
            pszText        = za.szDisplayName;
#else    
            CHAR szDisplayName[MAX_ZONE_PATH];
            WideCharToMultiByte(CP_ACP, 0, za.szDisplayName, -1, szDisplayName, ARRAYSIZE(szDisplayName), NULL, NULL);
            pszText        = szDisplayName;
#endif // UNICODE

            // Create a find info structure to find the index of the Zone
            lvfiName.flags = LVFI_STRING;
            lvfiName.psz = pszText;
            iItem = SendMessage(pSec->hwndZones, LVM_FINDITEM, (WPARAM)-1, (LPARAM)&lvfiName);
        }
    }

    if (iItem < 0)
    {
        iItem = 0;
        // 0 is the the index (in the listbox) of the "Internet" zone, which we want to come up by default
    }
    // Sundown: typecast OK since zone values restricted
    pSec->iZoneSel = (int) iItem;
}

// To make the slider control accessbile we have to subclass it and over-ride 
// the accessiblity object 

void SecurityInitSlider(LPSECURITYPAGE pSec)
{
    HWND hwndSlider = GetDlgItem(pSec->hDlg, IDC_SLIDER);
    ASSERT(hwndSlider != NULL);

    // Sub-class the control
    BOOL fSucceeded = SetWindowSubclass(hwndSlider, SliderSubWndProc, 0, NULL);

    // Shouldn't fail normally. If we fail we will just fall through and use the
    // base slider control.
    ASSERT(fSucceeded);

    // Initialize the slider control (set number of levels, and frequency one tick per level)
    SendDlgItemMessage(pSec->hDlg, IDC_SLIDER, TBM_SETRANGE, (WPARAM) (BOOL) FALSE, (LPARAM) MAKELONG(0, NUM_TEMPLATE_LEVELS - 1));
    SendDlgItemMessage(pSec->hDlg, IDC_SLIDER, TBM_SETTICFREQ, (WPARAM) 1, (LPARAM) 0);
}
                    
void SecurityInitControls(LPSECURITYPAGE pSec)
{
    LV_COLUMN lvCasey;
    LV_ITEM lvItem;

    // select the item in the listbox
    lvItem.mask = LVIF_STATE;
    lvItem.stateMask = LVIS_SELECTED;
    lvItem.state = LVIS_SELECTED;
    SendMessage(pSec->hwndZones, LVM_SETITEMSTATE, (WPARAM)pSec->iZoneSel, (LPARAM)&lvItem);
    


    // get the zone settings for the selected item
    lvItem.mask  = LVIF_PARAM;
    lvItem.iItem = pSec->iZoneSel;
    lvItem.iSubItem = 0;
    SendMessage(pSec->hwndZones, LVM_GETITEM, (WPARAM)0, (LPARAM)&lvItem);
    pSec->pszs = (LPSECURITYZONESETTINGS)lvItem.lParam;


    // Initialize the local strings to carry the Level Descriptions
    MLLoadString(IDS_TEMPLATE_DESC_HI, LEVEL_DESCRIPTION0, ARRAYSIZE(LEVEL_DESCRIPTION0));
    MLLoadString(IDS_TEMPLATE_DESC_MED, LEVEL_DESCRIPTION1, ARRAYSIZE(LEVEL_DESCRIPTION1));
    MLLoadString(IDS_TEMPLATE_DESC_MEDLOW, LEVEL_DESCRIPTION2, ARRAYSIZE(LEVEL_DESCRIPTION2));
    MLLoadString(IDS_TEMPLATE_DESC_LOW, LEVEL_DESCRIPTION3, ARRAYSIZE(LEVEL_DESCRIPTION3));
    MLLoadString(IDS_TEMPLATE_DESC_CUSTOM, CUSTOM_DESCRIPTION, ARRAYSIZE(CUSTOM_DESCRIPTION));

    MLLoadString(IDS_TEMPLATE_NAME_HI, LEVEL_NAME0, ARRAYSIZE(LEVEL_NAME0));
    MLLoadString(IDS_TEMPLATE_NAME_MED, LEVEL_NAME1, ARRAYSIZE(LEVEL_NAME1));
    MLLoadString(IDS_TEMPLATE_NAME_MEDLOW, LEVEL_NAME2, ARRAYSIZE(LEVEL_NAME2));
    MLLoadString(IDS_TEMPLATE_NAME_LOW, LEVEL_NAME3, ARRAYSIZE(LEVEL_NAME3));
    MLLoadString(IDS_TEMPLATE_NAME_CUSTOM, CUSTOM_NAME, ARRAYSIZE(CUSTOM_NAME));

    // Initialize text boxes and icons for the current zone
    WCHAR wszBuffer[ MAX_PATH*2];
    MLLoadString( IDS_ZONEDESC_LOCAL + pSec->pszs->dwZoneIndex, wszBuffer, ARRAYSIZE(wszBuffer));
    SetDlgItemText(pSec->hDlg, IDC_ZONE_DESCRIPTION, wszBuffer);
    MLLoadString( IDS_ZONENAME_LOCAL + pSec->pszs->dwZoneIndex, wszBuffer, ARRAYSIZE(wszBuffer));
    SetDlgItemText(pSec->hDlg, IDC_ZONELABEL, wszBuffer);
    SendDlgItemMessage(pSec->hDlg, IDC_ZONE_ICON, STM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)pSec->pszs->hicon);

    // Initialize the slider control
    SecurityInitSlider(pSec);

    // Initialize the list view (add column 0 for icon and text, and autosize it)
    lvCasey.mask = 0;
    SendDlgItemMessage(pSec->hDlg, IDC_LIST_ZONE, LVM_INSERTCOLUMN, (WPARAM) 0, (LPARAM) &lvCasey);
    SendDlgItemMessage(pSec->hDlg, IDC_LIST_ZONE, LVM_SETCOLUMNWIDTH, (WPARAM) 0, (LPARAM) MAKELPARAM(LVSCW_AUTOSIZE, 0));

    // Set the font of the name to the bold font
    pSec->hfontBolded = NULL;
    HFONT hfontOrig = (HFONT) SendDlgItemMessage(pSec->hDlg, IDC_STATIC_EMPTY, WM_GETFONT, (WPARAM) 0, (LPARAM) 0);
    if(hfontOrig == NULL)
        hfontOrig = (HFONT) GetStockObject(SYSTEM_FONT);

    // set the zone name and level font to bolded
    if(hfontOrig)
    {
        LOGFONT lfData;
        if(GetObject(hfontOrig, SIZEOF(lfData), &lfData) != 0)
        {
            // The distance from 400 (normal) to 700 (bold)
            lfData.lfWeight += 300;
            if(lfData.lfWeight > 1000)
                lfData.lfWeight = 1000;
            pSec->hfontBolded = CreateFontIndirect(&lfData);
            if(pSec->hfontBolded)
            {
                // the zone level and zone name text boxes should have the same font, so this is okat
                SendDlgItemMessage(pSec->hDlg, IDC_ZONELABEL, WM_SETFONT, (WPARAM) pSec->hfontBolded, (LPARAM) MAKELPARAM(FALSE, 0));
                SendDlgItemMessage(pSec->hDlg, IDC_LEVEL_NAME, WM_SETFONT, (WPARAM) pSec->hfontBolded, (LPARAM) MAKELPARAM(FALSE, 0));

            }
        }
    }

/*
    {
        // calculate the postions of the static text boxes for the "The current level is:" "<bold>(Level)</bold>" message
        TCHAR * pszText = NULL;
        LONG lLength = 30;
        HDC hdc = NULL;
        SIZE size;
        RECT rect;
        LONG lNameLeftPos = 0;

        // Get the text from the "The current level is" box.
        lLength = SendDlgItemMessage(pSec->hDlg, IDC_SEC_STATIC_CURRENT_LEVEL, WM_GETTEXTLENGTH, 
                                     (WPARAM) 0, (LPARAM) 0);
        pszText = new TCHAR[lLength + 1];
        if(!pszText)
            goto Exit; // E_OUTOFMEMORY
        SendDlgItemMessage(pSec->hDlg, IDC_SEC_STATIC_CURRENT_LEVEL, WM_GETTEXT, (WPARAM) lLength, 
                           (LPARAM) pszText);

        // get the device context
        hdc = GetDC(GetDlgItem(pSec->hDlg, IDC_SEC_STATIC_CURRENT_LEVEL));
        if(! hdc)
            goto Exit;
        // get the length of the text from the device context; assumes the proper font is already in
        if(GetTextExtentPoint32(hdc, pszText, lLength, &size) == 0)
            goto Exit;

        // set the width of the "The current level is" box
        GetClientRect(GetDlgItem(pSec->hDlg, IDC_SEC_STATIC_CURRENT_LEVEL), &rect);
        rect.right = rect.left + size.cx;
        lNameLeftPos = rect.right;
        if(MoveWindow(GetDlgItem(pSec->hDlg, IDC_SEC_STATIC_CURRENT_LEVEL), rect.left, rect.top, 
                      rect.right - rect.left, rect.top - rect.bottom, FALSE) == 0)
            goto Exit;

        // set the x position of the level name box
        GetClientRect(GetDlgItem(pSec->hDlg, IDC_LEVEL_NAME), &rect);
        rect.left = lNameLeftPos;
        if(MoveWindow(GetDlgItem(pSec->hDlg, IDC_LEVEL_NAME), rect.left, 
                      rect.top, rect.right - rect.left, rect.top - rect.bottom, FALSE) == 0)
            goto Exit;

Exit:
        if(hdc)
            ReleaseDC(GetDlgItem(pSec->hDlg, IDC_SEC_STATIC_CURRENT_LEVEL), hdc);
        if(pszText)
            delete pszText;
    }
    */
}


//
// SecurityDlgInit()
//
// Does initalization for Security Dlg.
//
// History:
//
// 6/17/96  t-gpease   remove 'gPrefs', cleaned up code
// 6/20/96  t-gpease   UI changes
// 5/14/97  t-ashlm    UI changes 
//
// 7/02/97  t-mattp    UI changes (slider, listbox)
//
// hDlg is the handle to the SecurityDialog window
// psif holds initialization parameters.  In the case of our entry point
//      from shdocvw (ie, double click browser zone icon, view-internetoptions-security, or right click
//      on desktop icon), it can be NULL

BOOL SecurityDlgInit(HWND hDlg, SECURITYINITFLAGS * psif)
{
    LPSECURITYPAGE  pSec = NULL;
    UINT iIndex = 0;
    HRESULT hr = 0;
    DWORD dwZoneEnumerator;
    
    // Initialize globals variables (to be destroyed at WM_DESTROY)
    if(SecurityInitGlobals(&pSec, hDlg, psif) == FALSE)
    {
        EndDialog(hDlg, 0);
        return FALSE;  // Initialization failed
    }

    // Get a (local) enumerator for the zones
    if (FAILED(pSec->pInternetZoneManager->
                     CreateZoneEnumerator(&dwZoneEnumerator, &(pSec->dwZoneCount), 0)))
    {
        EndDialog(hDlg, 0);
        return FALSE;  // no zone enumerator?
    }


    // Set up the variables in pSec about whether the zone settings can be editted
    SecuritySetEdit(pSec);

         
    // Add the Listbox items for the zones


    // The zones have to be added in a particular order
    // Array used to order zones for adding
    LV_ITEM * plviZones = new LV_ITEM[pSec->dwZoneCount];
    BOOL * pfSpotTaken = new BOOL[pSec->dwZoneCount];
    // bail out if there were any allocation failures
    if ((plviZones == NULL) || (pfSpotTaken == NULL))
    {
        if (plviZones)
            delete [] plviZones;
        if (pfSpotTaken)
            delete [] pfSpotTaken;
        pSec->pInternetZoneManager->DestroyZoneEnumerator(dwZoneEnumerator);
        EndDialog(hDlg, 0);
        return FALSE;
    }

    for(iIndex =0; iIndex < pSec->dwZoneCount; iIndex++)
        pfSpotTaken[iIndex] = FALSE;

    // propogate zone dropdown
    for (DWORD dwIndex=0; dwIndex < pSec->dwZoneCount; dwIndex++)
    {
        if(FAILED(SecurityInitZone(dwIndex, pSec, dwZoneEnumerator, plviZones, pfSpotTaken)))
        {
            // Delete all memory allocated for any previous zones (which have not yet been added to
            // the listbox)
            for(iIndex = 0; iIndex < pSec->dwZoneCount; iIndex++)
            {
                if(pfSpotTaken[iIndex] && (LPSECURITYZONESETTINGS) (plviZones[iIndex].lParam) != NULL)
                {
                    LocalFree((LPSECURITYZONESETTINGS) (plviZones[iIndex].lParam));
                    plviZones[iIndex].lParam = NULL;
                    if(plviZones[iIndex].pszText)
                        delete [] plviZones[iIndex].pszText;
                }
            }
            delete [] plviZones;
            delete [] pfSpotTaken;
            pSec->pInternetZoneManager->DestroyZoneEnumerator(dwZoneEnumerator);
            EndDialog(hDlg, 0);
            return FALSE;
        }
    }
    pSec->pInternetZoneManager->DestroyZoneEnumerator(dwZoneEnumerator);


    // Add all of the arrayed listitems to the listbox
    for(iIndex = 0; iIndex < pSec->dwZoneCount; iIndex++)
    {
        if(pfSpotTaken[iIndex])
        {
            SendMessage(pSec->hwndZones, LVM_INSERTITEM, (WPARAM)0, (LPARAM)&(plviZones[iIndex]));
            delete [] plviZones[iIndex].pszText;
        }
    }
    delete [] plviZones;
    delete [] pfSpotTaken;



    SecurityFindCurrentZone(pSec, psif);
    SecurityInitControls(pSec);
    SecurityEnableControls(pSec, FALSE);
    return TRUE;
}

void SecurityChanged()
{
    TCHAR szClassName[32];
    HWND hwnd = GetTopWindow(GetDesktopWindow());

    //
    // FEATURE: These should be gotten from some place that is public
    //         to both MSHTML and INETCPL.
    //
    while (hwnd) {
        GetClassName(hwnd, szClassName, ARRAYSIZE(szClassName));

        // notify all "browser" windows that security has changed            
        if (!StrCmpI(szClassName, TEXT("ExploreWClass"))            ||
            !StrCmpI(szClassName, TEXT("IEFrame"))                  ||
            !StrCmpI(szClassName, TEXT("CabinetWClass")))
        {
            // yes...  post it a message..
            PostMessage(hwnd, CWM_GLOBALSTATECHANGE, CWMF_SECURITY, 0L );
        }

        hwnd = GetNextWindow(hwnd, GW_HWNDNEXT);
    }
}

int SecurityWarning(LPSECURITYPAGE pSec)
{
    TCHAR szWarning[64];

    TCHAR szBuf[512];
    TCHAR szMessage[512];
    TCHAR szLevel[64];

    // Load "Warning!"
    MLLoadShellLangString(IDS_WARNING, szWarning, ARRAYSIZE(szWarning));

    // Load "It is not recommended...."
    MLLoadShellLangString(IDS_SECURITY_WARNING, szBuf, ARRAYSIZE(szBuf));

    // Load level: "High, Medium, Medium Low, Low"
    if (pSec->pszs->dwMinSecLevel == URLTEMPLATE_HIGH)
        MLLoadShellLangString(IDS_TEMPLATE_NAME_HI, szLevel, ARRAYSIZE(szLevel));
    else if (pSec->pszs->dwMinSecLevel == URLTEMPLATE_MEDIUM)
        MLLoadShellLangString(IDS_TEMPLATE_NAME_MED, szLevel, ARRAYSIZE(szLevel));
    else if (pSec->pszs->dwMinSecLevel == URLTEMPLATE_MEDLOW)
        MLLoadShellLangString(IDS_TEMPLATE_NAME_MEDLOW, szLevel, ARRAYSIZE(szLevel));
    else
        MLLoadShellLangString(IDS_TEMPLATE_NAME_LOW, szLevel, ARRAYSIZE(szLevel));

    wnsprintf(szMessage, ARRAYSIZE(szMessage), szBuf, szLevel);

    return MessageBox(pSec->hDlg,szMessage,szWarning, MB_ICONWARNING | MB_YESNO | MB_DEFBUTTON2);
}

int RegWriteWarning(HWND hParent)
{
    TCHAR szWarning[64];
    TCHAR szWriteWarning[128];

    // load "Warning!"
    MLLoadShellLangString(IDS_WARNING, szWarning, ARRAYSIZE(szWarning));
    // Load "You are about to write..."
    MLLoadShellLangString(IDS_WRITE_WARNING, szWriteWarning, ARRAYSIZE(szWriteWarning));

    return MessageBox(hParent,szWriteWarning, szWarning, MB_ICONWARNING | MB_YESNO | MB_DEFBUTTON2);
}


BOOL SecurityEnableControls(LPSECURITYPAGE pSec, BOOL fSetFocus)
// Duties:
// Make the controls (slider, en/disabled buttons) match the data for the current zone
// Make the views (Level description text) match the data for the current zone
// Set focus (to slider, if enabled, else custom settings button, if enabled, else 
//     listbox) if fSetFocus is TRUE
// Note: the zone descriptions are not set here; those are handled by the code responsible
//       for changing zones
{
    int iLevel = -1;


    if (pSec && pSec->pszs)
    {
        HWND hwndSlider = GetDlgItem(pSec->hDlg, IDC_SLIDER);
        
        iLevel = SecLevelToSliderPos(pSec->pszs->dwSecLevel);
        ASSERT(iLevel > -2);

        // Set the level of the slider to the setting for the current zone
        // Show or hide the slider for preset levels/custom
        // Set the level description text
        if(iLevel >= 0)
        {
            SendMessage(hwndSlider, TBM_SETPOS, (WPARAM) (BOOL) TRUE, (LPARAM) (LONG) iLevel);
            // Make sure the slider is visible
            ShowWindow(hwndSlider, SW_SHOW);
            ShowWindow(GetDlgItem(pSec->hDlg, IDC_STATIC_SLIDERMOVETEXT), SW_SHOW);
            SetDlgItemText(pSec->hDlg, IDC_LEVEL_DESCRIPTION, LEVEL_DESCRIPTION[iLevel]);         
            SetDlgItemText(pSec->hDlg, IDC_LEVEL_NAME, LEVEL_NAME[iLevel]);
        }
        else
        {
            // Hide the slider for custom
            ShowWindow(hwndSlider, SW_HIDE);
            ShowWindow(GetDlgItem(pSec->hDlg, IDC_STATIC_SLIDERMOVETEXT), SW_HIDE);
            SetDlgItemText(pSec->hDlg, IDC_LEVEL_DESCRIPTION, CUSTOM_DESCRIPTION);
            SetDlgItemText(pSec->hDlg, IDC_LEVEL_NAME, CUSTOM_NAME);
        }

        // If the zone is empty, show the "zone is empty" string
        // Default is to not show the sting (if something goes wrong)
        // Empty zone not possible for internet, intranet, or local zones
        if((pSec->pszs->dwZoneIndex != URLZONE_INTRANET && 
            pSec->pszs->dwZoneIndex != URLZONE_INTERNET) &&
            pSec->pszs->dwZoneIndex != URLZONE_LOCAL_MACHINE &&
            (pSec->pInternetSecurityManager != NULL))
        {
            IEnumString * piesZones = NULL;
            LPOLESTR ppszDummy[1];
            pSec->pInternetSecurityManager->GetZoneMappings(pSec->pszs->dwZoneIndex, &piesZones, 0);

            // If enumerator can not get 1 item, zone is empty (not valid for internet and intranet)
            if(piesZones && (piesZones->Next(1, ppszDummy, NULL) == S_FALSE))
            {
                ShowWindow(GetDlgItem(pSec->hDlg, IDC_STATIC_EMPTY), SW_SHOW);
            }
            else
            {
                ShowWindow(GetDlgItem(pSec->hDlg, IDC_STATIC_EMPTY), SW_HIDE);
            }
            if(piesZones)
                piesZones->Release();
        }
        else
        {
            ShowWindow(GetDlgItem(pSec->hDlg, IDC_STATIC_EMPTY), SW_HIDE);
        }

        // If we were told to set focus then move focus to the slider.
        if (fSetFocus)
        {
            if(!pSec->fNoEdit)
            {
               if(iLevel >= 0)
                    SetFocus(hwndSlider);
               else if(pSec->pszs->dwFlags & ZAFLAGS_CUSTOM_EDIT)
                    SetFocus(GetDlgItem(pSec->hDlg, IDC_BUTTON_SETTINGS));
               else
                 SetFocus(GetDlgItem(pSec->hDlg, IDC_LIST_ZONE));
            }
            else // No focus is allowed, set focus to the list box
            {
                SetFocus(GetDlgItem(pSec->hDlg, IDC_LIST_ZONE));
            }

        }

        BOOL fEdit = !(pSec->fNoEdit || (IEHardened() && !IsNTAdmin(0, NULL)));
        EnableWindow(hwndSlider, (iLevel >= 0) && fEdit);
        EnableWindow(GetDlgItem(pSec->hDlg, IDC_ZONE_RESET), 
                     fEdit && (pSec->pszs->dwSecLevel != pSec->pszs->dwRecSecLevel));
        EnableWindow(GetDlgItem(pSec->hDlg, IDC_BUTTON_SETTINGS), 
                     (pSec->pszs->dwFlags & ZAFLAGS_CUSTOM_EDIT) && fEdit);
        EnableWindow(GetDlgItem(pSec->hDlg, IDC_BUTTON_ADD_SITES), 
                     (pSec->pszs->dwFlags & ZAFLAGS_ADD_SITES) && !pSec->fDisableAddSites);

        return TRUE;
    }

    return FALSE;
}

void SecuritySetLevel(DWORD dwLevel, LPSECURITYPAGE pSec)
{
    // All calls to this function are requests to change the security
    // level for the current zone
    // dwLevel = requested level template (URLTEMPLATE_???)
    int iPos = SecLevelToSliderPos(dwLevel);
    ASSERT(iPos != -2);
    BOOL bCanceled = FALSE;

    // Do nothing if the requested level is equal to the current level 
    if(dwLevel != pSec->pszs->dwSecLevel)
    {
        // Pop up warning box if under recommended min level and lowering security (custom N/A)
        if((pSec->pszs->dwMinSecLevel > dwLevel) && (pSec->pszs->dwSecLevel > dwLevel)
            && (dwLevel != URLTEMPLATE_CUSTOM))
        {
            if(SecurityWarning(pSec) == IDNO)
            {
                bCanceled = TRUE;
            }
        }                
        if(! bCanceled)
        {
            // Set the level
            pSec->pszs->dwPrevSecLevel = pSec->pszs->dwSecLevel;
            pSec->pszs->dwSecLevel = dwLevel;
            ENABLEAPPLY(pSec->hDlg);

            //Tell apply and ok that settings have been changed
            pSec->fChanged = TRUE;
        }
        // Sync the controls to the new level (or back to the old if cancelled)
        SecurityEnableControls(pSec, TRUE);
    }
    // Record that the change request has been handled
    pSec->fPendingChange = FALSE;
}


//
// SecurityDlgApplyNow()
//
// Retrieves the user's choices in dlg ctls,
//    and saves them through SecurityManager interfaces
// If bSaveAll is true, the data for all zones is saved,
// if false, only the current
// Return value is whether the changes were okayed 
//
BOOL SecurityDlgApplyNow(LPSECURITYPAGE pSec, BOOL bSaveAll)
{
    if (pSec->fChanged)
    {
        for (int iIndex = (int)SendMessage(pSec->hwndZones, LVM_GETITEMCOUNT, 0, 0) - 1;
             iIndex >= 0; iIndex--)
        {
            if(!((bSaveAll) || (iIndex == pSec->iZoneSel)))
                continue;
            LV_ITEM lvItem = {0};
            ZONEATTRIBUTES za = {0};
            LPSECURITYZONESETTINGS pszs;
            
            // get the item settings
            lvItem.mask  = LVIF_PARAM;
            lvItem.iItem = iIndex;
            lvItem.iSubItem = 0;
            if(SendMessage(pSec->hwndZones, LVM_GETITEM, (WPARAM)0, (LPARAM)&lvItem))
            {
                pszs = (LPSECURITYZONESETTINGS)lvItem.lParam;

                za.cbSize = sizeof(ZONEATTRIBUTES);
                pSec->pInternetZoneManager->GetZoneAttributes(pszs->dwZoneIndex, &za);
                za.dwTemplateCurrentLevel = pszs->dwSecLevel;
                pSec->pInternetZoneManager->SetZoneAttributes(pszs->dwZoneIndex, &za);
                // Custom settings are saved on exit from the Custom Settings window
            }
        }
        UpdateAllWindows();
        SecurityChanged();
        if (bSaveAll)
        {
            // if bSaveAll is false, that means we're saving the info for one zone, but not
            // the others. This happens when you have custom settings for a particular zone
            // However, other zones may have been changed to only one of the standard settings
            // We need to ensure that those settings also get saved when the user clicks OK/Apply.
            pSec->fChanged = FALSE;
        }
    }
    return TRUE;
}


//
// SecurityOnCommand()
//
// Handles Security Dialog's window messages
//
// History:
//
// 6/17/96  t-gpease   created
// 5/14/97  t-ashlm    ui changes
//
void SecurityOnCommand(LPSECURITYPAGE pSec, UINT id, UINT nCmd)
{

    switch (id)
    {
        case IDC_BUTTON_ADD_SITES:
        {
            if (pSec->pszs->dwZoneIndex == URLZONE_INTRANET && !IEHardened())
            {
                DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_SECURITY_INTRANET), pSec->hDlg,
                               SecurityAddSitesIntranetDlgProc, (LPARAM)pSec);
            }
            else
            {
                DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_SECURITY_ADD_SITES), pSec->hDlg,
                               SecurityAddSitesDlgProc, (LPARAM)pSec);
            }
                               
            // Resynch controls (in case the "zone is empty" message needs to be updated)
            SecurityEnableControls(pSec, FALSE);
        }   
        break;

        case IDC_BUTTON_SETTINGS:
        {
            // Note: messages to change the level from preset to custom as a result of this call
            //       are sent by the CustomSettings dialog
            DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_SECURITY_CUSTOM_SETTINGS), pSec->hDlg,
                           SecurityCustomSettingsDlgProc, (LPARAM)pSec);
            break;
        }
        case IDC_ZONE_RESET:
            if(!pSec->fPendingChange && pSec->pszs->dwSecLevel != pSec->pszs->dwRecSecLevel)
            {
                pSec->fPendingChange = TRUE;
                PostMessage(pSec->hDlg, WM_APP, (WPARAM) 0, (LPARAM) pSec->pszs->dwRecSecLevel);
            }
            break;
            
        case IDOK:
            SecurityDlgApplyNow(pSec, TRUE);
            EndDialog(pSec->hDlg, IDOK);
            break;
            
        case IDCANCEL:
            EndDialog(pSec->hDlg, IDCANCEL);
            break;
            
        case IDC_SLIDER:
            {
                // Get the current slider position
                // Sundown: forced typecast to int, slider positions are restricted
                int iPos = (int) SendDlgItemMessage(pSec->hDlg, IDC_SLIDER, TBM_GETPOS, (WPARAM) 0, (LPARAM) 0);
                if(nCmd == TB_THUMBTRACK)
                {
                    // on Mouse Move, change the level description only
                    SetDlgItemText(pSec->hDlg, IDC_LEVEL_DESCRIPTION, LEVEL_DESCRIPTION[iPos]);
                    SetDlgItemText(pSec->hDlg, IDC_LEVEL_NAME, LEVEL_NAME[iPos]);
                }
                else
                {
                    // Request that the current zone's security level be set to the corresponding level
                    DWORD_PTR dwLevel = SliderPosToSecLevel(iPos);
                    if(! pSec->fPendingChange)
                    {
                        pSec->fPendingChange = TRUE;
                        PostMessage(pSec->hDlg, WM_APP, (WPARAM) 0, (LPARAM) dwLevel);
                    }
                }
            }
            break;
            
        case IDC_LIST_ZONE:
        {
            // Sundown: coercion to int-- selection is range-restricted
            int iNewSelection = (int) SendMessage(pSec->hwndZones, LVM_GETNEXTITEM, (WPARAM)-1, 
                                                  MAKELPARAM(LVNI_SELECTED, 0));

            if ((iNewSelection != pSec->iZoneSel) && (iNewSelection != -1))
            {
                LV_ITEM lvItem;

                lvItem.iItem = iNewSelection;
                lvItem.iSubItem = 0;
                lvItem.mask  = LVIF_PARAM;                                            
                SendMessage(pSec->hwndZones, LVM_GETITEM, (WPARAM)0, (LPARAM)&lvItem);
                pSec->pszs = (LPSECURITYZONESETTINGS)lvItem.lParam;
                pSec->iZoneSel = iNewSelection;

                WCHAR wszBuffer[ MAX_PATH*2];
                MLLoadString( IDS_ZONEDESC_LOCAL + pSec->pszs->dwZoneIndex, wszBuffer, ARRAYSIZE(wszBuffer));
                SetDlgItemText(pSec->hDlg, IDC_ZONE_DESCRIPTION, wszBuffer);
                MLLoadString( IDS_ZONENAME_LOCAL + pSec->pszs->dwZoneIndex, wszBuffer, ARRAYSIZE(wszBuffer));
                SetDlgItemText(pSec->hDlg, IDC_ZONELABEL, wszBuffer);
                SendDlgItemMessage(pSec->hDlg, IDC_ZONE_ICON, STM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)pSec->pszs->hicon);
                SecurityEnableControls(pSec, FALSE);
            }    
            break;
        }
    }   

} // SecurityOnCommand()


//
// SecurityDlgProc()
//
// Handles Security Dialog's window messages
//
// History:
//
// 6/17/96  t-gpease   created
// 5/14/97  t-ashlm    ui changes
//
INT_PTR CALLBACK SecurityDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LPSECURITYPAGE pSec;

    if (uMsg == WM_INITDIALOG)
    {
        // A hack forced by PropertyPage:
        // PropertyPage creates this dialog in mainwnd.cpp when the dialog is entered from
        // the desktop e's properties, the browser's menu view-internetoptions-security, or
        // right clicking on the browser's zone icon.
        // In the property page case, lParam (our only route to get initialization information
        // in) is a pointer to a PROPERTYSHEETHEADER, more or less, and of entirely no use to us.
        // However, when called from our exported function LaunchSecurityDialogEx, using
        // CreateDialogParamWrapW, we want to pass useful information in.  The only way to make sure 
        // we our dealing with useful information is to make the passed in pointer be to a 
        // structure we know and love, and hence could not possibly be pointed to by PropertyPage.  
        // We use a ThreadLocalStorage object, as our information reference
        SECURITYINITFLAGS * psif = NULL;
        if(g_dwtlsSecInitFlags != (DWORD) -1)
            psif = (SECURITYINITFLAGS *) TlsGetValue(g_dwtlsSecInitFlags);
        if((SECURITYINITFLAGS *) lParam != psif)
            psif = NULL; 
        return SecurityDlgInit(hDlg, psif);
    }

    pSec = (LPSECURITYPAGE)GetWindowLongPtr(hDlg, DWLP_USER);
    if (!pSec)
        return FALSE;
    
    switch (uMsg)
    {
        case WM_COMMAND:
            SecurityOnCommand(pSec, LOWORD(wParam), HIWORD(wParam));
            return TRUE;

        case WM_NOTIFY:
        {
            NMHDR *lpnm = (NMHDR *) lParam;

            ASSERT(lpnm);

            // List Box Messages
            if(lpnm->idFrom == IDC_LIST_ZONE)
            {
                NM_LISTVIEW * lplvnm = (NM_LISTVIEW *) lParam;
                if(lplvnm->hdr.code == LVN_ITEMCHANGED)
                {
                    // If an item's state has changed, and it is now selected
                    if(((lplvnm->uChanged & LVIF_STATE) != 0) && ((lplvnm->uNewState & LVIS_SELECTED) != 0))
                    {
                        SecurityOnCommand(pSec, IDC_LIST_ZONE, LVN_ITEMCHANGED);
                    }                   
                }
            }
            else
            {
                switch (lpnm->code)
                {
                    case PSN_QUERYCANCEL:
                    case PSN_KILLACTIVE:
                    case PSN_RESET:
                        SetWindowLongPtr(pSec->hDlg, DWLP_MSGRESULT, FALSE);
                        return TRUE;

                    case PSN_APPLY:
                        // Hitting the apply button runs this code
                        SecurityDlgApplyNow(pSec, TRUE);
                        break;
                }
            }
        }
        break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_APP:
            // A message needs to be posted, because the set tools sometimes send two messages
            // hence we need delayed action and a pending change boolean
            // lParam is the level to set for this message
            // wParam is not used
            SecuritySetLevel((DWORD) lParam, pSec);
            break;
        case WM_VSCROLL:
            // Slider Messages
            SecurityOnCommand(pSec, IDC_SLIDER, LOWORD(wParam));
            return TRUE;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
            if(! pSec)
                break;

            SecurityFreeGlobals(pSec);            
            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
            break;
    }
    return FALSE;
}

// Subclassed window proc for the slider. This is used to take over the
// accessibility wrapper for the class so we can return the right zone
// string ( i.e. High, Medium, Low, etc). Just trap WM_GETOBJECT and pass
// in our override of the accessibility wrapper. 

LRESULT CALLBACK SliderSubWndProc (HWND hwndSlider, UINT uMsg, WPARAM wParam, LPARAM lParam, WPARAM uID, ULONG_PTR dwRefData)
{
    ASSERT(uID == 0);
    ASSERT(dwRefData == 0);

    switch (uMsg)
    {
        case WM_GETOBJECT:
            if ( lParam == OBJID_CLIENT )
            {       
                // At this point we will try to load oleacc and get the functions
                // we need. 
                if (!g_fAttemptedOleAccLoad)
                {
                    g_fAttemptedOleAccLoad = TRUE;

                    ASSERT(s_pfnCreateStdAccessibleProxy == NULL);
                    ASSERT(s_pfnLresultFromObject == NULL);

                    g_hOleAcc = LoadLibrary(TEXT("OLEACC"));
                    if (g_hOleAcc != NULL)
                    {
        #ifdef UNICODE
                        s_pfnCreateStdAccessibleProxy = (PFNCREATESTDACCESSIBLEPROXY)
                                                    GetProcAddress(g_hOleAcc, "CreateStdAccessibleProxyW");
        #else
                        s_pfnCreateStdAccessibleProxy = (PFNCREATESTDACCESSIBLEPROXY)
                                                    GetProcAddress(g_hOleAcc, "CreateStdAccessibleProxyA");
        #endif
                        s_pfnLresultFromObject = (PFNLRESULTFROMOBJECT)
                                                    GetProcAddress(g_hOleAcc, "LresultFromObject");
                    }
                    if (s_pfnLresultFromObject == NULL || s_pfnCreateStdAccessibleProxy == NULL)
                    {
                        // No point holding on to Oleacc since we can't use it.
                        FreeLibrary(g_hOleAcc);
                        g_hOleAcc = NULL;
                        s_pfnLresultFromObject = NULL;
                        s_pfnCreateStdAccessibleProxy = NULL;
                    }
                }

                
                if (g_hOleAcc && s_pfnCreateStdAccessibleProxy && s_pfnLresultFromObject)
                {
                    IAccessible *pAcc = NULL;
                    HRESULT hr;
                
                    // Create default slider proxy.
                    hr = s_pfnCreateStdAccessibleProxy(
                            hwndSlider,
                            TEXT("msctls_trackbar32"),
                            OBJID_CLIENT,
                            IID_IAccessible,
                            (void **)&pAcc
                            );


                    if (SUCCEEDED(hr) && pAcc)
                    {
                        // now wrap it up in our customized wrapper...
                        IAccessible * pWrapAcc = new CSecurityAccessibleWrapper( hwndSlider, pAcc );
                        // Release our ref to proxy (wrapper has its own addref'd ptr)...
                        pAcc->Release();
                    
                        if (pWrapAcc != NULL)
                        {

                            // ...and return the wrapper via LresultFromObject...
                            LRESULT lr = s_pfnLresultFromObject( IID_IAccessible, wParam, pWrapAcc );
                            // Release our interface pointer - OLEACC has its own addref to the object
                            pWrapAcc->Release();

                            // Return the lresult, which 'contains' a reference to our wrapper object.
                            return lr;
                            // All done!
                        }
                    // If it didn't work, fall through to default behavior instead. 
                    }
                }
            }
            break;

        case WM_DESTROY:
            RemoveWindowSubclass(hwndSlider, SliderSubWndProc, uID);
            break;    

    } /* end switch */

    return DefSubclassProc(hwndSlider, uMsg, wParam, lParam);
}

                        
// In Urlmon.dll                          
HRESULT __stdcall GetAddSitesFileUrl(LPWSTR /* [in, out] */ pszUrl);

HRESULT _GetAddSitesDisplayUrl(LPCWSTR pszUrl, LPWSTR pszUrlDisplay, DWORD cchUrlDisplay)
{
    HRESULT hr;

    LPWSTR pszSecUrl;
    hr = CoInternetGetSecurityUrl(pszUrl, &pszSecUrl, PSU_DEFAULT, 0);
    if (SUCCEEDED(hr))
    {
        LPCWSTR pszColon = StrChr(pszSecUrl, L':');
        //Special case about Urls so we don't munge them. 
        if (pszColon && (pszColon - pszSecUrl != 5 || StrCmpNI(pszSecUrl, L"about", 5) != 0))
        {
            DWORD bufferUsed = min(cchUrlDisplay, (DWORD)(pszColon - pszSecUrl) + 2);
            StrCpyN(pszUrlDisplay, pszSecUrl, bufferUsed);

            //Don't add // if the security url already has it
            if (StrCmpNI(pszColon + 1, L"//", 2) != 0)
            {
                StrCatBuff(pszUrlDisplay, L"//", cchUrlDisplay - bufferUsed);
                StrCatBuff(pszUrlDisplay, pszColon + 1, cchUrlDisplay - bufferUsed - 2);
            }
            else
            {
                StrCatBuff(pszUrlDisplay, pszColon + 1, cchUrlDisplay - bufferUsed);
            }
        }
        else
        {
            StrCpyN(pszUrlDisplay, pszSecUrl, cchUrlDisplay);
        }
        CoTaskMemFree(pszSecUrl);
    }
    else
    {
        StrCpyN(pszUrlDisplay, pszUrl, cchUrlDisplay);
        hr = S_OK;
    }

    if (SUCCEEDED (hr))
        // Transform file:// URLs to a file://UNC format if necessary:
        hr =  GetAddSitesFileUrl(pszUrlDisplay);
    
    return hr;
}

BOOL __cdecl _FormatMessage(LPCWSTR szTemplate, LPWSTR szBuf, UINT cchBuf, ...)
{
    BOOL fRet;
    va_list ArgList;
    va_start(ArgList, cchBuf);

    fRet = FormatMessage(FORMAT_MESSAGE_FROM_STRING, szTemplate, 0, 0, szBuf, cchBuf, &ArgList);

    va_end(ArgList);
    return fRet;
}


HRESULT _AddSite(LPADDSITESINFO pasi)
{
    HRESULT hr = S_OK;
    LPWSTR psz;

    SendMessage(pasi->hwndAdd, WM_GETTEXT, MAX_ZONE_PATH, (LPARAM)pasi->szWebSite);
#ifndef UNICODE
    WCHAR wszMapping[MAX_ZONE_PATH];
    MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, pasi->szWebSite, sizeof(pasi->szWebSite),  wszMapping, ARRAYSIZE(wszMapping));
    psz = wszMapping;
#else
    psz = pasi->szWebSite;
#endif

    if (*psz)
    {


        pasi->fRSVOld = pasi->fRequireServerVerification;
        pasi->fRequireServerVerification = IsDlgButtonChecked(pasi->hDlg, IDC_CHECK_REQUIRE_SERVER_VERIFICATION);                 

        // if the state of RequireServerVer has changed, then do a SetZoneAttr so we'll get the correct error codes
        if (pasi->fRSVOld != pasi->fRequireServerVerification)
        {
            ZONEATTRIBUTES za;
            za.cbSize = sizeof(ZONEATTRIBUTES);
            pasi->pSec->pInternetZoneManager->GetZoneAttributes(pasi->pSec->pszs->dwZoneIndex, &za);
            if (pasi->fRequireServerVerification)
                za.dwFlags |= ZAFLAGS_REQUIRE_VERIFICATION;
            else
                za.dwFlags &= ~ZAFLAGS_REQUIRE_VERIFICATION;
            
            pasi->pSec->pInternetZoneManager->SetZoneAttributes(pasi->pSec->pszs->dwZoneIndex, &za);

        }
        
        hr = pasi->pSec->pInternetSecurityManager->SetZoneMapping(pasi->pSec->pszs->dwZoneIndex,
            psz, SZM_CREATE);

        if (FAILED(hr))
        {
            UINT id = IDS_MAPPINGFAIL;
        
            if (hr == URL_E_INVALID_SYNTAX)
            {
                id = IDS_INVALIDURL;
            }
            else if (hr == E_INVALIDARG)
            {
                id = IDS_INVALIDWILDCARD;
            }
            else if (hr == E_ACCESSDENIED)
            {
                id = IDS_HTTPSREQ;
            }
            else if (hr == HRESULT_FROM_WIN32(ERROR_FILE_EXISTS))
            {
                id = IDS_SITEEXISTS;
            }

            DWORD dwOldZone;
            if (id == IDS_SITEEXISTS && SUCCEEDED(pasi->pSec->pInternetSecurityManager->MapUrlToZone(psz, &dwOldZone, 0)))
            {
                if (dwOldZone == pasi->pSec->pszs->dwZoneIndex)
                {
                    // Nothing to do except inform the user

                    SiteAlreadyInZoneMessage(pasi->hDlg, dwOldZone);
                }
                else if (dwOldZone == URLZONE_UNTRUSTED)
                {
                    // Do not allow moving a site from the restricted zone to any other zone.
                    WCHAR szMessage[200];
                    WCHAR szZone[100];
                    if (MLLoadString(IDS_CANNOT_MOVE_FROM_RESTRICTED, szMessage, ARRAYSIZE(szMessage)) &&
                        MLLoadString(IDS_ZONENAME_LOCAL + URLZONE_UNTRUSTED, szZone, ARRAYSIZE(szZone)))
                    {
                        MLShellMessageBox(pasi->hDlg, szMessage, szZone, MB_ICONINFORMATION | MB_OK);
                    }
                }
                else
                {
                    // The site exists in another zone

                    WCHAR szNewZone[100];
                    MLLoadString(IDS_ZONENAME_LOCAL + pasi->pSec->pszs->dwZoneIndex, szNewZone, ARRAYSIZE(szNewZone));
                    WCHAR szOldZone[100];
                    MLLoadString(IDS_ZONENAME_LOCAL + dwOldZone, szOldZone, ARRAYSIZE(szOldZone));
                    WCHAR szFormat[200];
                    MLLoadString(IDS_ADDSITEREPLACE, szFormat, ARRAYSIZE(szFormat));
                    WCHAR szText[400];
                    _FormatMessage(szFormat, szText, ARRAYSIZE(szText), szOldZone, szNewZone);
                    if (IDYES == MLShellMessageBox(pasi->hDlg, szText, NULL, MB_ICONQUESTION | MB_YESNO))
                    {
                        pasi->pSec->pInternetSecurityManager->SetZoneMapping(dwOldZone, psz, SZM_DELETE);
                        hr = _AddSite(pasi);
                    }
                }
            }
            else
            {
                MLShellMessageBox(pasi->hDlg, MAKEINTRESOURCEW(id), NULL, MB_ICONSTOP|MB_OK);
                Edit_SetSel(pasi->hwndAdd, 0, -1);
            }
        }
        else
        {
            WCHAR szUrl[MAX_ZONE_PATH];
            _GetAddSitesDisplayUrl(pasi->szWebSite, szUrl, ARRAYSIZE(szUrl));
            SendMessage(pasi->hwndWebSites, LB_ADDSTRING, (WPARAM)0, (LPARAM)szUrl);
            SendMessage(pasi->hwndAdd, WM_SETTEXT, (WPARAM)0, (LPARAM)NULL);
            SetFocus(pasi->hwndAdd);
        }
    }
    return hr;
}

INT_PTR CALLBACK SecurityAddSitesDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    LPADDSITESINFO pasi;

    if (uMsg == WM_INITDIALOG)
    {
        pasi = (LPADDSITESINFO)LocalAlloc(LPTR, sizeof(*pasi));
        if (!pasi)
        {
            EndDialog(hDlg, IDCANCEL);
            return FALSE;
        }

        // tell dialog where to get info
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pasi);

        // save the handle to the page
        pasi->hDlg         = hDlg;
        pasi->pSec         = (LPSECURITYPAGE)lParam;
        pasi->hwndWebSites = GetDlgItem(hDlg, IDC_LIST_WEBSITES);
        pasi->hwndAdd      = GetDlgItem(hDlg, IDC_EDIT_ADD_SITE);

        // cross-lang platform support
        SHSetDefaultDialogFont(hDlg, IDC_EDIT_ADD_SITE);

        // limit the text so it will fit
        SendMessage(pasi->hwndAdd, EM_SETLIMITTEXT, (WPARAM)sizeof(pasi->szWebSite), (LPARAM)0);

        pasi->fRequireServerVerification = pasi->pSec->pszs->dwFlags & ZAFLAGS_REQUIRE_VERIFICATION;

        CheckDlgButton(hDlg, IDC_CHECK_REQUIRE_SERVER_VERIFICATION, pasi->fRequireServerVerification);
        
        // hide the checkbox if it doesn't support server verification
        if (!(pasi->pSec->pszs->dwFlags & ZAFLAGS_SUPPORTS_VERIFICATION))
            ShowWindow(GetDlgItem(hDlg, IDC_CHECK_REQUIRE_SERVER_VERIFICATION), SW_HIDE);

        SendMessage(hDlg, WM_SETTEXT, (WPARAM)0, (LPARAM)pasi->pSec->pszs->szDisplayName);
        SetDlgItemText(hDlg, IDC_ADDSITES_GROUPBOX,(LPTSTR)pasi->pSec->pszs->szDisplayName);
        SendDlgItemMessage(hDlg, IDC_ZONE_ICON, STM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)pasi->pSec->pszs->hicon);
        EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_REMOVE), FALSE);
        
        if (pasi->pSec->pInternetSecurityManager || SUCCEEDED(CoInternetCreateSecurityManager(NULL, &(pasi->pSec->pInternetSecurityManager), 0)))
        {
            IEnumString *pEnum;

            if (SUCCEEDED(pasi->pSec->pInternetSecurityManager->GetZoneMappings(pasi->pSec->pszs->dwZoneIndex, &pEnum, 0)))
            {
                LPOLESTR pszMapping;
#ifndef UNICODE
                CHAR szMapping[MAX_URL_STRING];
#endif
                LPTSTR psz;

                while (pEnum->Next(1, &pszMapping, NULL) == S_OK)
                {
#ifndef UNICODE
                    WideCharToMultiByte(CP_ACP, 0, pszMapping, -1, szMapping, ARRAYSIZE(szMapping), NULL, NULL);
                    psz = szMapping;
#else
                    psz = pszMapping;
#endif // UNICODE                       
                    SendMessage(pasi->hwndWebSites, LB_INSERTSTRING, (WPARAM)-1, (LPARAM)psz);
                    CoTaskMemFree(pszMapping);
                }
                pEnum->Release();
            }
        }

        BOOL fUseHKLM = FALSE;
        DWORD cb = SIZEOF(fUseHKLM);
    
        SHGetValue( HKEY_LOCAL_MACHINE,
                    REGSTR_PATH_SECURITY_LOCKOUT,
                    REGSTR_VAL_HKLM_ONLY,
                    NULL,
                    &fUseHKLM,
                    &cb);
        
        if (pasi->pSec->fNoAddSites || pasi->pSec->fNoZoneMapEdit || (fUseHKLM && !IsNTAdmin(0, NULL)))
        {
            EnableDlgItem(hDlg, IDC_EDIT_ADD_SITE, FALSE);
            EnableDlgItem(hDlg, IDC_BUTTON_REMOVE, FALSE);            
        }
        else if (pasi->pSec->szPageUrl[0])
        {
            // Security manager should have been created above
            
            if (pasi->pSec->pInternetSecurityManager)
            {
                DWORD dwZone;                
                if (SUCCEEDED(pasi->pSec->pInternetSecurityManager->MapUrlToZone(pasi->pSec->szPageUrl, &dwZone, 0)))
                {
                    // If a site is already restricted, we don't want to auto-suggest.
                    // If a site is already trusted, we can't add it to either list anyway.
                    // So we only need to check for Intranet and Internet.
                    
                    if ((dwZone == URLZONE_INTERNET) ||
                        (pasi->pSec->pszs->dwZoneIndex == URLZONE_INTRANET && dwZone == URLZONE_TRUSTED) ||
                        (pasi->pSec->pszs->dwZoneIndex == URLZONE_TRUSTED && dwZone == URLZONE_INTRANET))
                    {
                        WCHAR szUrl[MAX_ZONE_PATH];
                        if (SUCCEEDED(_GetAddSitesDisplayUrl(pasi->pSec->szPageUrl, szUrl, ARRAYSIZE(szUrl))))
                        {
                            SetWindowText(pasi->hwndAdd, szUrl);
                            SetFocus(GetDlgItem(hDlg, IDC_BUTTON_ADD));
                        }
                    }
                }
            }            
        }

        if (pasi->pSec->fNoZoneMapEdit)
        {
            EnableDlgItem(hDlg, IDC_CHECK_REQUIRE_SERVER_VERIFICATION, FALSE);
            EnableDlgItem(hDlg, IDS_STATIC_ADDSITE, FALSE);            
        }

        SHAutoComplete(GetDlgItem(hDlg, IDC_EDIT_ADD_SITE), SHACF_DEFAULT);
    }
    
    else
        pasi = (LPADDSITESINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    if (!pasi)
        return FALSE;
    
    switch (uMsg)
    {
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDCANCEL: //Close
                {
                    ZONEATTRIBUTES za;

                    pasi->fRequireServerVerification = IsDlgButtonChecked(hDlg, IDC_CHECK_REQUIRE_SERVER_VERIFICATION);                 

                    if (pasi->fRequireServerVerification)
                        pasi->pSec->pszs->dwFlags |= ZAFLAGS_REQUIRE_VERIFICATION;
                    else
                        pasi->pSec->pszs->dwFlags &= ~ZAFLAGS_REQUIRE_VERIFICATION;

                    za.cbSize = sizeof(ZONEATTRIBUTES);
                    pasi->pSec->pInternetZoneManager->GetZoneAttributes(pasi->pSec->pszs->dwZoneIndex, &za);
                    za.dwFlags = pasi->pSec->pszs->dwFlags;
                    pasi->pSec->pInternetZoneManager->SetZoneAttributes(pasi->pSec->pszs->dwZoneIndex, &za);
                    SecurityChanged();
                    EndDialog(hDlg, IDOK);
                    break;
                }
                
                case IDC_LIST_WEBSITES:
                    switch (HIWORD(wParam))
                    {
                        case LBN_SELCHANGE:
                        case LBN_SELCANCEL:
                            if (!pasi->pSec->fNoAddSites && !pasi->pSec->fNoZoneMapEdit)
                                EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_REMOVE), SendDlgItemMessage(hDlg, IDC_LIST_WEBSITES, LB_GETCURSEL, 0, 0) != -1);
                            break;
                    }
                    break;
                            
                case IDC_EDIT_ADD_SITE:
                    switch(HIWORD(wParam))
                    {
                        case EN_CHANGE:
                            BOOL fEnable = GetWindowTextLength(GetDlgItem(hDlg, IDC_EDIT_ADD_SITE)) ? TRUE:FALSE;
                            EnableWindow(GetDlgItem(hDlg,IDC_BUTTON_ADD), fEnable);
                            SendMessage(hDlg, DM_SETDEFID, fEnable ? IDC_BUTTON_ADD : IDOK, 0);
                            break;
                    }   
                    break;

                case IDC_BUTTON_ADD:
                    _AddSite(pasi);
                    break;

                case IDC_BUTTON_REMOVE:
                {
                    TCHAR szMapping[MAX_ZONE_PATH];
                    LPWSTR psz;
                    
                            
                    INT_PTR iSel = SendMessage(pasi->hwndWebSites, LB_GETCURSEL, 0, 0);
                    if (iSel != -1)
                    {
                        SendMessage(pasi->hwndWebSites, LB_GETTEXT, (WPARAM)iSel, (LPARAM)szMapping);
#ifndef UNICODE
                        WCHAR wszMapping[MAX_ZONE_PATH];
                        MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, szMapping, sizeof(szMapping),  wszMapping, ARRAYSIZE(wszMapping));
                        psz = wszMapping;
#else
                        psz = szMapping;
#endif
                        SendMessage(pasi->hwndWebSites, LB_DELETESTRING, iSel , 0);
                        SendMessage(pasi->hwndWebSites, LB_SETCURSEL, iSel-1, 0);
                        if (!pasi->pSec->fNoAddSites && !pasi->pSec->fNoZoneMapEdit)
                            EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_REMOVE), SendDlgItemMessage(hDlg, IDC_LIST_WEBSITES, LB_GETCURSEL, 0, 0) != -1);

                        pasi->pSec->pInternetSecurityManager->SetZoneMapping(pasi->pSec->pszs->dwZoneIndex,
                            psz, SZM_DELETE);
                    }

                    break;
                }
                default:
                    return FALSE;
            }
            return TRUE;                
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
            SHRemoveDefaultDialogFont(hDlg);
            if (pasi)
            {
                LocalFree(pasi);
                SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
            }
            break;
    }
    return FALSE;
}

INT_PTR CALLBACK SecurityAddSitesIntranetDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    LPADDSITESINTRANETINFO pasii;

    if (uMsg == WM_INITDIALOG)
    {
        pasii = (LPADDSITESINTRANETINFO)LocalAlloc(LPTR, sizeof(*pasii));
        if (!pasii)
        {
            EndDialog(hDlg, IDCANCEL);
            return FALSE;
        }

        // tell dialog where to get info
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pasii);

        // save the handle to the page
        pasii->hDlg = hDlg;
        pasii->pSec = (LPSECURITYPAGE)lParam;

        SendMessage(hDlg, WM_SETTEXT, (WPARAM)0, (LPARAM)pasii->pSec->pszs->szDisplayName);
        CheckDlgButton(hDlg, IDC_CHECK_USEINTRANET, pasii->pSec->pszs->dwFlags & ZAFLAGS_INCLUDE_INTRANET_SITES);
        CheckDlgButton(hDlg, IDC_CHECK_PROXY, pasii->pSec->pszs->dwFlags & ZAFLAGS_INCLUDE_PROXY_OVERRIDE);
        CheckDlgButton(hDlg, IDC_CHECK_UNC, pasii->pSec->pszs->dwFlags & ZAFLAGS_UNC_AS_INTRANET);
        SendDlgItemMessage(hDlg, IDC_ZONE_ICON, STM_SETIMAGE, (WPARAM)IMAGE_ICON, (LPARAM)pasii->pSec->pszs->hicon);

        BOOL fHarden = IEHardened();
        if (pasii->pSec->fNoAddSites || pasii->pSec->fNoZoneMapEdit || fHarden)
        {
            EnableDlgItem(hDlg, IDC_CHECK_USEINTRANET, FALSE);
            EnableDlgItem(hDlg, IDC_CHECK_PROXY, FALSE);
        }

        if (pasii->pSec->fNoZoneMapEdit || fHarden)
        {
            EnableDlgItem(hDlg, IDC_CHECK_UNC, FALSE);
        }
        return TRUE;
    }

    else
         pasii = (LPADDSITESINTRANETINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    if (!pasii)
        return FALSE;
    
    switch (uMsg) {
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                {
                    ZONEATTRIBUTES za;

                    pasii->fUseIntranet       = IsDlgButtonChecked(hDlg, IDC_CHECK_USEINTRANET);
                    pasii->fUseProxyExclusion = IsDlgButtonChecked(hDlg, IDC_CHECK_PROXY);
                    pasii->fUseUNC            = IsDlgButtonChecked(hDlg, IDC_CHECK_UNC);
                    
                    if (pasii->fUseIntranet)
                        pasii->pSec->pszs->dwFlags |= ZAFLAGS_INCLUDE_INTRANET_SITES;
                    else
                        pasii->pSec->pszs->dwFlags &= ~ZAFLAGS_INCLUDE_INTRANET_SITES;

                    if (pasii->fUseProxyExclusion)
                        pasii->pSec->pszs->dwFlags |= ZAFLAGS_INCLUDE_PROXY_OVERRIDE;
                    else
                        pasii->pSec->pszs->dwFlags &= ~ZAFLAGS_INCLUDE_PROXY_OVERRIDE;

                    if (pasii->fUseUNC)
                        pasii->pSec->pszs->dwFlags |= ZAFLAGS_UNC_AS_INTRANET;
                    else
                        pasii->pSec->pszs->dwFlags &= ~ZAFLAGS_UNC_AS_INTRANET;
                    
                    za.cbSize = sizeof(ZONEATTRIBUTES);
                    pasii->pSec->pInternetZoneManager->GetZoneAttributes(pasii->pSec->pszs->dwZoneIndex, &za);
                    za.dwFlags = pasii->pSec->pszs->dwFlags;
                    pasii->pSec->pInternetZoneManager->SetZoneAttributes(pasii->pSec->pszs->dwZoneIndex, &za);
                    SecurityChanged();
                    EndDialog(hDlg, IDOK);
                    break;
                }
                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    break;

                case IDC_INTRANET_ADVANCED:
                    DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_SECURITY_ADD_SITES), hDlg,
                                   SecurityAddSitesDlgProc, (LPARAM)pasii->pSec);
                    break;

                default:
                    return FALSE;
            }
            return TRUE;                
            break;

        case WM_HELP:           // F1
            ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                        HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_CONTEXTMENU:        // right mouse click
            ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                        HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            break;

        case WM_DESTROY:
            if (pasii)
            {
                LocalFree(pasii);
                SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
            }
            break;
    }
    return FALSE;
}

VOID ShowJavaZonePermissionsDialog (HWND hdlg, LPCUSTOMSETTINGSINFO pcsi)
{
    HRESULT           hr;
    IJavaZonePermissionEditor *zoneeditor;

    hr = CoCreateInstance(
            CLSID_JavaRuntimeConfiguration,
            NULL,
            CLSCTX_INPROC_SERVER | CLSCTX_INPROC_HANDLER | CLSCTX_LOCAL_SERVER,
            IID_IJavaZonePermissionEditor,
            (PVOID*)&zoneeditor
            );

    if (SUCCEEDED(hr))
    {
        hr = zoneeditor->ShowUI(
                hdlg,
                0,
                0,
                pcsi->fUseHKLM ? URLZONEREG_HKLM : URLZONEREG_DEFAULT,
                pcsi->pSec->pszs->dwZoneIndex,
                pcsi->dwJavaPolicy | URLACTION_JAVA_PERMISSIONS,
                pcsi->pSec->pInternetZoneManager
                );

        zoneeditor->Release();
    }
}



void ShowCustom(LPCUSTOMSETTINGSINFO pcsi, HTREEITEM hti)
{
    TV_ITEM        tvi;
    tvi.hItem = hti;
    tvi.mask = TVIF_HANDLE | TVIF_PARAM | TVIF_IMAGE;

    TreeView_GetItem( pcsi->hwndTree, &tvi );

        // If it's not selected don't bother.
    if (tvi.iImage != IDRADIOON)
        return;

    TCHAR szValName[64];
    DWORD cb = SIZEOF(szValName);
    DWORD dwChecked;

    if (SHRegQueryUSValue((HUSKEY)tvi.lParam,
                        TEXT("ValueName"),
                        NULL,
                        (LPBYTE)szValName,
                        &cb,
                        pcsi->fUseHKLM,
                        NULL,
                        0) == ERROR_SUCCESS)
    {
        if (!(StrCmp(szValName, TEXT("1C00"))))
        {
            cb = SIZEOF(dwChecked);
            if (SHRegQueryUSValue((HUSKEY)tvi.lParam,
                                TEXT("CheckedValue"),
                                NULL,
                                (LPBYTE)&dwChecked,
                                &cb,
                                pcsi->fUseHKLM,
                                NULL,
                                0) == ERROR_SUCCESS)
            {
#ifndef UNIX
                HWND hCtl = GetDlgItem(pcsi->hDlg, IDC_JAVACUSTOM);
                ShowWindow(hCtl,
                           (dwChecked == URLPOLICY_JAVA_CUSTOM) && (tvi.iImage == IDRADIOON) ? SW_SHOWNA : SW_HIDE);
                EnableWindow(hCtl, dwChecked==URLPOLICY_JAVA_CUSTOM ? TRUE : FALSE);
                pcsi->dwJavaPolicy = dwChecked;
#endif
            }
        }
    }
}

void _FindCustomRecursive(
    LPCUSTOMSETTINGSINFO pcsi,
    HTREEITEM htvi
)
{
    HTREEITEM hctvi;    // child
    
    // step through the children
    hctvi = TreeView_GetChild( pcsi->hwndTree, htvi );
    while ( hctvi )
    {
        _FindCustomRecursive(pcsi,hctvi);
        hctvi = TreeView_GetNextSibling( pcsi->hwndTree, hctvi );
    }

    ShowCustom(pcsi, htvi);
}

void _FindCustom(
    LPCUSTOMSETTINGSINFO pcsi
    )
{
    HTREEITEM hti = TreeView_GetRoot( pcsi->hwndTree );
    
    // and walk the list of other roots
    while (hti)
    {
        // recurse through its children
        _FindCustomRecursive(pcsi, hti);

        // get the next root
        hti = TreeView_GetNextSibling(pcsi->hwndTree, hti );
    }
}

BOOL SecurityCustomSettingsInitDialog(HWND hDlg, LPARAM lParam)
{
    LPCUSTOMSETTINGSINFO pcsi = (LPCUSTOMSETTINGSINFO)LocalAlloc(LPTR, sizeof(*pcsi));
    HRESULT hr;
    
    if (!pcsi)
    {
        EndDialog(hDlg, IDCANCEL);
        return FALSE;
    }
    
    // tell dialog where to get info
    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pcsi);

    // save the handle to the page
    pcsi->hDlg = hDlg;
    pcsi->pSec = (LPSECURITYPAGE)lParam;

    // save dialog handle
    pcsi->hwndTree = GetDlgItem(pcsi->hDlg, IDC_TREE_SECURITY_SETTINGS);

    CoInitialize(0);
    hr = CoCreateInstance(CLSID_CRegTreeOptions, NULL, CLSCTX_INPROC_SERVER,
                          IID_IRegTreeOptions, (LPVOID *)&(pcsi->pTO));


    DWORD cb = SIZEOF(pcsi->fUseHKLM);
    
    SHGetValue(HKEY_LOCAL_MACHINE,
               REGSTR_PATH_SECURITY_LOCKOUT,
               REGSTR_VAL_HKLM_ONLY,
               NULL,
               &(pcsi->fUseHKLM),
               &cb);

    // if this fails, we'll just use the default of fUseHKLM == 0
               
    if (SUCCEEDED(hr))
    {
        CHAR szZone[32];

        wnsprintfA(szZone, ARRAYSIZE(szZone), "%ld", pcsi->pSec->pszs->dwZoneIndex);

        // use the SOHKLM tree when fUseHKLM==TRUE for IEAK
        hr = pcsi->pTO->InitTree(pcsi->hwndTree, HKEY_LOCAL_MACHINE,
                                 pcsi->fUseHKLM ?
                                 "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\SOIEAK" :
                                 "SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\SO",
                                 szZone);
    }
    
    // find the first root and make sure that it is visible
    TreeView_EnsureVisible( pcsi->hwndTree, TreeView_GetRoot( pcsi->hwndTree ) );

    pcsi->hwndCombo = GetDlgItem(hDlg, IDC_COMBO_RESETLEVEL);
    
    SendMessage(pcsi->hwndCombo, CB_INSERTSTRING, (WPARAM)0, (LPARAM)LEVEL_NAME[3]);
    SendMessage(pcsi->hwndCombo, CB_INSERTSTRING, (WPARAM)0, (LPARAM)LEVEL_NAME[2]);
    SendMessage(pcsi->hwndCombo, CB_INSERTSTRING, (WPARAM)0, (LPARAM)LEVEL_NAME[1]);
    SendMessage(pcsi->hwndCombo, CB_INSERTSTRING, (WPARAM)0, (LPARAM)LEVEL_NAME[0]);
    
    switch (pcsi->pSec->pszs->dwRecSecLevel)
    {
        case URLTEMPLATE_LOW:
            pcsi->iLevelSel = 3;
            break;
        case URLTEMPLATE_MEDLOW:
            pcsi->iLevelSel = 2;
            break;
        case URLTEMPLATE_MEDIUM:
            pcsi->iLevelSel = 1;
            break;
        case URLTEMPLATE_HIGH:
            pcsi->iLevelSel = 0;
            break;
        default:
            pcsi->iLevelSel = 0;
            break;
    }

    _FindCustom(pcsi);
    
    SendMessage(pcsi->hwndCombo, CB_SETCURSEL, (WPARAM)pcsi->iLevelSel, (LPARAM)0);

    if (pcsi->pSec->fNoEdit)
    {
        EnableDlgItem(hDlg, IDC_COMBO_RESETLEVEL, FALSE);
        EnableDlgItem(hDlg, IDC_BUTTON_APPLY, FALSE);
    }
    pcsi->fChanged = FALSE;
    return TRUE;
}

INT_PTR CALLBACK SecurityCustomSettingsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam,LPARAM lParam)
{
    LPCUSTOMSETTINGSINFO pcsi;

    if (uMsg == WM_INITDIALOG)
        return SecurityCustomSettingsInitDialog(hDlg, lParam);
    else
        pcsi = (LPCUSTOMSETTINGSINFO)GetWindowLongPtr(hDlg, DWLP_USER);
    
    if (!pcsi)
        return FALSE;
                
    switch (uMsg) {

        case WM_NOTIFY:
        {
            LPNMHDR psn = (LPNMHDR)lParam;
            switch( psn->code )
            {
                case TVN_KEYDOWN:
                {
                    TV_KEYDOWN *pnm = (TV_KEYDOWN*)psn;
                    if (pnm->wVKey == VK_SPACE) {
                        if (!pcsi->pSec->fNoEdit)
                        {
                            HTREEITEM hti = (HTREEITEM)SendMessage(pcsi->hwndTree, TVM_GETNEXTITEM, TVGN_CARET, NULL);
                            pcsi->pTO->ToggleItem(hti);
                            ShowCustom(pcsi, hti);
                            pcsi->fChanged = TRUE;
                            EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_APPLY),TRUE);
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE); // eat the key
                            return TRUE;
                         }
                    }
                    break;
                }
            
                case NM_CLICK:
                case NM_DBLCLK:
                {   // is this click in our tree?
                    if ( psn->idFrom == IDC_TREE_SECURITY_SETTINGS )
                    {   // yes...
                        TV_HITTESTINFO ht;
                        HTREEITEM hti;

                        if (!pcsi->pSec->fNoEdit)
                        {
                            GetCursorPos( &ht.pt );                         // get where we were hit
                            ScreenToClient( pcsi->hwndTree, &ht.pt );       // translate it to our window

                            // retrieve the item hit
                            hti = TreeView_HitTest( pcsi->hwndTree, &ht);

                            pcsi->pTO->ToggleItem(hti);
                            pcsi->fChanged = TRUE;
                            ShowCustom(pcsi, hti);
                            EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_APPLY),TRUE);
                         }
                    }   
                }
                break;
            }
        }
        break;
        
        case WM_COMMAND:
            switch (LOWORD(wParam))
            {
                case IDOK:
                    if(pcsi->pSec->fPendingChange)
                        break;
                    
                    if(pcsi->fChanged && RegWriteWarning(pcsi->pSec->hDlg) == IDNO)
                        break;
                    // we use send message instead of post because there is no chance of this button
                    // receiving multiple signals at one click, and we need the change level message to be
                    // processed before the apply message below
                    pcsi->pSec->fPendingChange = TRUE;
                    SendMessage(pcsi->pSec->hDlg, WM_APP, (WPARAM) 0, (LPARAM) URLTEMPLATE_CUSTOM);
                    if(pcsi->fChanged)
                    {
                        pcsi->pTO->WalkTree( WALK_TREE_SAVE );
                    }
                    // Saves custom to registry and Handles updateallwindows 
                    // and securitychanged calls

                    // APPCOMPAT: Force a call to SetZoneAttributes when anything in custom changes.
                    // This forces the security manager to flush any caches it has for that zone. 
                    pcsi->pSec->fChanged = TRUE;

                    SecurityDlgApplyNow(pcsi->pSec, FALSE);
                    EndDialog(hDlg, IDOK);
                    break;

                case IDCANCEL:
                    EndDialog(hDlg, IDCANCEL);
                    break;

                case IDC_COMBO_RESETLEVEL:
                    switch (HIWORD(wParam))
                    {
                        case CBN_SELCHANGE:
                        {
                            // Sundown: coercion to integer since cursor selection is 32b
                            int iNewSelection = (int) SendMessage(pcsi->hwndCombo, CB_GETCURSEL, (WPARAM)0, (LPARAM)0);

                            if (iNewSelection != pcsi->iLevelSel)
                            {
                                pcsi->iLevelSel = iNewSelection;
                                EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_APPLY),TRUE);
                            }
                            break;
                        }
                    }
                    break;

                case IDC_JAVACUSTOM:
                    ShowJavaZonePermissionsDialog(hDlg, pcsi);
                    break;
                    
                case IDC_BUTTON_APPLY:
                {
                    TCHAR szLevel[64];
                    ZONEATTRIBUTES za;
                    
                    if(pcsi->pSec->fPendingChange == TRUE)
                        break;
                    if(RegWriteWarning(hDlg) == IDNO)
                    {
                        break;
                    }
                    pcsi->pSec->fPendingChange = TRUE;

                    SendMessage(pcsi->hwndCombo, WM_GETTEXT, (WPARAM)ARRAYSIZE(szLevel), (LPARAM)szLevel);

                    za.cbSize = sizeof(ZONEATTRIBUTES);
                        
                    pcsi->pSec->pInternetZoneManager->GetZoneAttributes(pcsi->pSec->pszs->dwZoneIndex, &za);
                                
                    if (!StrCmp(szLevel, LEVEL_NAME[3])) 
                        za.dwTemplateCurrentLevel = URLTEMPLATE_LOW;
                    else if (!StrCmp(szLevel, LEVEL_NAME[2]))
                        za.dwTemplateCurrentLevel = URLTEMPLATE_MEDLOW;
                    else if (!StrCmp(szLevel, LEVEL_NAME[1]))
                        za.dwTemplateCurrentLevel = URLTEMPLATE_MEDIUM;
                    else if (!StrCmp(szLevel, LEVEL_NAME[0]))
                        za.dwTemplateCurrentLevel = URLTEMPLATE_HIGH;
                    else
                        za.dwTemplateCurrentLevel = URLTEMPLATE_CUSTOM;

                    pcsi->pSec->pInternetZoneManager->SetZoneAttributes(pcsi->pSec->pszs->dwZoneIndex, &za);

                    pcsi->pTO->WalkTree(WALK_TREE_REFRESH);

                    // find the first root and make sure that it is visible
                    TreeView_EnsureVisible( pcsi->hwndTree, TreeView_GetRoot( pcsi->hwndTree ) );
                    EnableWindow(GetDlgItem(hDlg, IDC_BUTTON_APPLY), FALSE);
                    SendMessage(hDlg, DM_SETDEFID, IDOK, 0);
                    SetFocus(GetDlgItem(hDlg, IDOK));   // since we grayout the reset button, might have keyboard
                                                        // focus, so we should set focus somewhere else
                    _FindCustom(pcsi);

                    // BUG #57358. We tell the Zone Manager to change to [High/Med/Low] level because we want
                    //             the policy values for those, but we don't want it to change the level from
                    //             custom.  So, after it changes the setting from Custom, we change it back.
                    // Save the level as custom

                    // we use send message instead of post because there is no chance of this button
                    // receiving multiple signals at one click, and we need the change level message to be
                    // processed before the apply message below
                    SendMessage(pcsi->pSec->hDlg, WM_APP, (WPARAM) 0, (LPARAM) URLTEMPLATE_CUSTOM);

                    // Saves custom to registry and Handles updateallwindows 
                    // and securitychanged calls

                    // APPCOMPAT: Force a call to SetZoneAttributes when anything in custom changes.
                    // This forces the security manager to flush any caches it has for that zone. 
                    pcsi->pSec->fChanged = TRUE;

                    SecurityDlgApplyNow(pcsi->pSec, TRUE);

                    pcsi->fChanged = FALSE;
                    break;
                }
                    

                default:
                    return FALSE;
            }
            return TRUE;                
            break;

        case WM_HELP:           // F1
        {
            LPHELPINFO lphelpinfo;
            lphelpinfo = (LPHELPINFO)lParam;

            TV_HITTESTINFO ht;
            HTREEITEM hItem;

            // If this help is invoked through the F1 key.
            if (GetAsyncKeyState(VK_F1) < 0)
            {
                // Yes we need to give help for the currently selected item.
                hItem = TreeView_GetSelection(pcsi->hwndTree);
            }
            else
            {
                // Else we need to give help for the item at current cursor position
                ht.pt =((LPHELPINFO)lParam)->MousePos;
                ScreenToClient(pcsi->hwndTree, &ht.pt); // Translate it to our window
                hItem = TreeView_HitTest(pcsi->hwndTree, &ht);
            }

                        
            if (FAILED(pcsi->pTO->ShowHelp(hItem , HELP_WM_HELP)))
            {
                ResWinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle, IDS_HELPFILE,
                            HELP_WM_HELP, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            }
            break; 

        }
        case WM_CONTEXTMENU:        // right mouse click
        {
            TV_HITTESTINFO ht;

            GetCursorPos( &ht.pt );                         // get where we were hit
            ScreenToClient( pcsi->hwndTree, &ht.pt );       // translate it to our window

            // retrieve the item hit
            if (FAILED(pcsi->pTO->ShowHelp(TreeView_HitTest( pcsi->hwndTree, &ht),HELP_CONTEXTMENU)))
            {           
                ResWinHelp( (HWND) wParam, IDS_HELPFILE,
                            HELP_CONTEXTMENU, (DWORD_PTR)(LPSTR)mapIDCsToIDHs);
            }
            break; 
        }
        case WM_DESTROY:
            if (pcsi)
            {
                if (pcsi->pTO)
                {
                    pcsi->pTO->WalkTree( WALK_TREE_DELETE );
                    pcsi->pTO->Release();
                    pcsi->pTO=NULL;
                }
                
                LocalFree(pcsi);
                SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)NULL);
                CoUninitialize();
            }
            break;
    }
    return FALSE;
}

#ifdef UNIX
extern "C" 
#endif
BOOL LaunchSecurityDialogEx(HWND hDlg, DWORD dwZone, DWORD dwFlags)
{
    INITCOMMONCONTROLSEX icex;
    SECURITYINITFLAGS * psif = NULL;

    icex.dwSize = sizeof(INITCOMMONCONTROLSEX);
    icex.dwICC  = ICC_USEREX_CLASSES|ICC_NATIVEFNTCTL_CLASS;
    InitCommonControlsEx(&icex);

    if(g_dwtlsSecInitFlags != (DWORD) -1)
        psif = (SECURITYINITFLAGS *) TlsGetValue(g_dwtlsSecInitFlags);
    if(psif)
    {
        psif->fForceUI = dwFlags & LSDFLAG_FORCEUI;
        psif->fDisableAddSites = dwFlags & LSDFLAG_NOADDSITES;
        psif->dwZone = dwZone;
    }

    // passing in a NULL psif is okay
    DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_SECSTANDALONE), hDlg,
                           SecurityDlgProc, (LPARAM) psif);
    
    return TRUE;
}

// backwards compatability
#ifdef UNIX
extern "C"
#endif
void LaunchSecurityDialog(HWND hDlg, DWORD dwZone)
{
    LaunchSecurityDialogEx(hDlg, dwZone, LSDFLAG_DEFAULT);
}

#ifdef UNIX
extern "C" 
#endif
void LaunchSiteCertDialog(HWND hDlg)
{
    CRYPTUI_CERT_MGR_STRUCT ccm = {0};
    ccm.dwSize = sizeof(ccm);
    ccm.hwndParent = hDlg;
    CryptUIDlgCertMgr(&ccm);
}

BOOL SiteAlreadyInZone(LPCWSTR pszUrl, DWORD dwZone, SECURITYPAGE* pSec)
{
    BOOL fRet = FALSE;

    if (pSec->pInternetSecurityManager || SUCCEEDED(CoInternetCreateSecurityManager(NULL, &(pSec->pInternetSecurityManager), 0)))
    {
        DWORD dwMappedZone;
        if (SUCCEEDED(pSec->pInternetSecurityManager->MapUrlToZone(pszUrl, &dwMappedZone, 0)))
        {
            fRet = (dwZone == dwMappedZone);
        }
    }

    return fRet;
}

void SiteAlreadyInZoneMessage(HWND hwnd, DWORD dwZone)
{
    WCHAR szFormat[200];
    WCHAR szZone[100];
    if (MLLoadString(IDS_SITEALREADYINZONE, szFormat, ARRAYSIZE(szFormat)) &&
        MLLoadString(IDS_ZONENAME_LOCAL + dwZone, szZone, ARRAYSIZE(szZone)))
    {
        WCHAR szText[300];
        wnsprintf(szText, ARRAYSIZE(szText), szFormat, szZone);
        MLShellMessageBox(hwnd, szText, szZone, MB_ICONINFORMATION | MB_OK);
    }
}


BOOL ShowAddSitesDialog(HWND hwnd, DWORD dwZone, LPCWSTR pszUrl)
{
    BOOL fRet = FALSE;

    SECURITYPAGE* pSec = NULL;
    if (SecurityInitGlobals(&pSec, NULL, NULL))
    {
        DWORD dwEnum;
        if (SUCCEEDED(pSec->pInternetZoneManager->CreateZoneEnumerator(&dwEnum, &(pSec->dwZoneCount), 0)))
        {
            if (S_OK == (SecurityInitZone(dwZone, pSec, dwEnum, NULL, NULL)))
            {
                if (!SiteAlreadyInZone(pszUrl, dwZone, pSec))
                {
                    StrCpyN(pSec->szPageUrl, pszUrl, ARRAYSIZE(pSec->szPageUrl));
                    DialogBoxParam(MLGetHinst(), MAKEINTRESOURCE(IDD_SECURITY_ADD_SITES), hwnd, SecurityAddSitesDlgProc, (LPARAM)pSec);
                    fRet = TRUE;
                    FreePszs(pSec->pszs);
                }
                else
                {
                    SiteAlreadyInZoneMessage(hwnd, dwZone);
                }
            }
            pSec->pInternetZoneManager->DestroyZoneEnumerator(dwEnum);
        }
        SecurityFreeGlobals(pSec);
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\unixstuff.h ===
#ifndef _UNIXSTUFF_H_
#define _UNIXSTUFF_H_

#include "cachecpl.h"

#define FONT_UPDATE_TICK 150

UINT  RegPopulateEditText(HWND hwndCB, HKEY hkeyProtocol);
BOOL  LocalFileCheck(LPCTSTR aszFileName);
BOOL  FoundProgram(HWND hwndDlg, int nIDDlgItem);
void  FontUpdateFeedBack(int nTick, void *pvParam);
VOID  DrawXFontButton(HWND hDlg, LPDRAWITEMSTRUCT lpdis);

BOOL  IsCacheReadOnly();

BOOL CALLBACK FontUpdDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

#endif // _UNIXSTUFF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\regutil.cpp ===
//////////////////////////////////////////////////////////////////////
//                      Microsoft Internet Explorer                 //
//                Copyright(c) Microsoft Corp., 1995-1996           //
//////////////////////////////////////////////////////////////////////
//
// REGUTIL.C - registry functions common between MSHTML and INETCPL.
//

// HISTORY:
//
// 8/7/96   t-gpease    created.
//

#include "inetcplp.h"

//
// Definintions
//

#define SMALLBUFFER 64

//
// Procedures
//
const TCHAR g_cszYes[] = TEXT("yes");
const TCHAR g_cszNo[]  = TEXT("no");


// Conveters and int into a string... ONLY BYTE VALUES!!
TCHAR *MyIntToStr(TCHAR *pBuf, BYTE iVal)
{
    int i, t;

    ASSERT(iVal < 1000);

    i=0;
    if (t = iVal/100)
    {
        pBuf[i] = L'0' + t;
        i++;
    }

    if ((t = (iVal % 100) / 10) || (i!=0))
    {
        pBuf[i] = L'0' + t;
        i++;
    }

    pBuf[i] = L'0' + iVal % 10;
    i++;

    pBuf[i] = L'\0';

    return pBuf;
}

// Read the registry for a string (REG_SZ) of comma separated RGB values
COLORREF RegGetColorRefString( HUSKEY huskey, LPTSTR RegValue, COLORREF Value)
{
    TCHAR SmallBuf[SMALLBUFFER];
    TCHAR *pBuf;
    DWORD cb;
	int iRed, iGreen, iBlue;

    cb = ARRAYSIZE(SmallBuf);
    if (SHRegQueryUSValue(huskey,
                          RegValue,
                          NULL,
                          (LPBYTE)&SmallBuf,
                          &cb,
                          FALSE,
                          NULL,
                          NULL) == ERROR_SUCCESS)
    {
        iRed = StrToInt(SmallBuf);
        pBuf = SmallBuf;

        // find the next comma
        while(pBuf && *pBuf && *pBuf!=L',')
            pBuf++;
        
        // if valid and not NULL...
        if (pBuf && *pBuf)
            pBuf++;         // increment

        iGreen = StrToInt(pBuf);

        // find the next comma
        while(pBuf && *pBuf && *pBuf!=L',')
            pBuf++;

        // if valid and not NULL...
        if (pBuf && *pBuf)
            pBuf++;         // increment

        iBlue = StrToInt(pBuf);

        // make sure all values are valid
		iRed    %= 256;
		iGreen  %= 256;
		iBlue   %= 256;

	    Value = RGB(iRed, iGreen, iBlue);
    }

    return Value;
}

// Writes the registry for a string (REG_SZ) of comma separated RGB values
COLORREF RegSetColorRefString( HUSKEY huskey, LPTSTR RegValue, COLORREF Value)
{
    TCHAR SmallBuf[SMALLBUFFER];
    TCHAR DigitBuf[4];  // that all we need for '255\0'
    int iRed, iGreen, iBlue;

    iRed   = GetRValue(Value);
    iGreen = GetGValue(Value);
    iBlue  = GetBValue(Value);

    ASSERT(ARRAYSIZE(SmallBuf) >= 3 + 3 + 3 + 2 + 1) // "255,255,255"

    MyIntToStr(SmallBuf, (BYTE)iRed);
    StrCat(SmallBuf, TEXT(","));
    StrCat(SmallBuf, MyIntToStr(DigitBuf, (BYTE)iGreen));
    StrCat(SmallBuf, TEXT(","));
    StrCat(SmallBuf, MyIntToStr(DigitBuf, (BYTE)iBlue));

    SHRegWriteUSValue(huskey,
                      RegValue,
                      REG_SZ,
                      (LPVOID)&SmallBuf,
                      (lstrlen(SmallBuf)+1) * sizeof(TCHAR),
                      SHREGSET_DEFAULT);

    //
    // FEATURE: Should we do something if this fails?
    //

    return Value;
}


// Read the registry for a string (REG_SZ = "yes" | "no") and return a BOOL value
BOOL RegGetBooleanString(HUSKEY huskey, LPTSTR pszRegValue, BOOL bValue)
{
    TCHAR   szBuf[SMALLBUFFER];
    LPCTSTR  pszDefault;
    DWORD   cb;
    DWORD   cbDef;

    // get the default setting
    if (bValue)
        pszDefault = g_cszYes;
    else
        pszDefault = g_cszNo;
    
    cb = ARRAYSIZE(szBuf);
    cbDef = (lstrlen(pszDefault)+1)*sizeof(TCHAR); // +1 for null term
    if (SHRegQueryUSValue(huskey,
                          pszRegValue,
                          NULL,
                          (LPVOID)&szBuf,
                          &cb,
                          FALSE,
                          (LPVOID)pszDefault,
                          cbDef) == ERROR_SUCCESS)
    {
        if (!StrCmpI(szBuf, g_cszYes))
            bValue = TRUE;
        else if (!StrCmpI(szBuf, g_cszNo))
            bValue = FALSE;

        // else fall thru and return the Default that was passed in
    }

    return bValue;
}

// Write the registry for a string (REG_SZ) TRUE = "yes", FALSE = "no"
BOOL RegSetBooleanString(HUSKEY huskey, LPTSTR pszRegValue, BOOL bValue)
{
    TCHAR szBuf[SMALLBUFFER];

    if (bValue)
        StrCpyN(szBuf, g_cszYes, ARRAYSIZE(szBuf));
    else
        StrCpyN(szBuf, g_cszNo, ARRAYSIZE(szBuf));

    SHRegWriteUSValue(huskey,
                      pszRegValue,
                      REG_SZ,
                      (LPVOID)&szBuf, 
                      (lstrlen(szBuf)+1) * sizeof(TCHAR),
                      SHREGSET_DEFAULT);

    //
    // FEATURE: Should we try to do something if this fails?
    //

    return bValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\shalias.cpp ===
/****************************************************************************
 *
 *  Microsoft Confidential
 *  Copyright (c) Microsoft Corporation 1994
 *  All rights reserved
 *
 ***************************************************************************/

#ifdef UNIX_FEATURE_ALIAS

#undef UNICODE

#include "inetcplp.h"
#include "shalias.h"

#include "mluisupp.h"

static TCHAR g_szAliasKey[]     = TEXT("Software\\Microsoft\\Internet Explorer\\Unix\\Alias");

// Member function definitions for CAlias
CAlias::CAlias( TCHAR * name )
{
    m_alias = (TCHAR *) LocalAlloc( LPTR, (lstrlen(name) + 1)*sizeof(TCHAR) );
    StrCpy( m_alias, name );
    m_szurl = NULL;
    m_fDirty= TRUE;
}

CAlias::~CAlias()
{
    if( m_alias ) LocalFree( m_alias );
    if( m_szurl ) LocalFree( m_szurl );
}

CAlias::Load()
{
    if(m_alias)
    {
        HKEY hKey;

        TCHAR aliasKey[MAX_PATH], buffer[MAX_PATH];
        StrCpy( aliasKey, g_szAliasKey);
        StrCat( aliasKey, TEXT("\\"));
        StrCat( aliasKey, m_alias );
         
           HRESULT lResult = RegOpenKeyExA(
                  HKEY_CURRENT_USER,
                  aliasKey,
                  0,
                  KEY_QUERY_VALUE | KEY_READ,
                  &hKey);
        if( lResult == ERROR_SUCCESS )
        {
            DWORD dwLen = MAX_PATH;
            if (RegQueryValue( hKey, NULL, buffer,  (long *)&dwLen ) 
                  == ERROR_SUCCESS )
            {
                 m_szurl = (TCHAR *)LocalAlloc( LPTR, (dwLen+1)*sizeof(TCHAR));
                 StrCpy(m_szurl, buffer);
            }
                
            RegCloseKey( hKey );
        }
        else
            return FALSE;
       
    }

    return TRUE;
}

CAlias::Save()
{
    HRESULT lResult;
    HKEY    hKey;
    TCHAR aliasKey[MAX_PATH], buffer[MAX_PATH];
    StrCpy( aliasKey, g_szAliasKey);
    StrCat( aliasKey, TEXT("\\"));
    StrCat( aliasKey, m_alias );
         
    lResult = RegOpenKeyEx(
        HKEY_CURRENT_USER,
        aliasKey,
        0,
        KEY_QUERY_VALUE| KEY_WRITE,
        &hKey);

    if( lResult != ERROR_SUCCESS )
    {
        lResult = RegCreateKey(
                      HKEY_CURRENT_USER,
                      aliasKey,
                      &hKey);      
    }

    if( lResult == ERROR_SUCCESS )
    {
        DWORD dwType = REG_SZ;
        DWORD dwLen  = (lstrlen(m_szurl)+1)*sizeof(TCHAR);

        RegSetValue( hKey, NULL, dwType, m_szurl, dwLen );
        RegCloseKey( hKey);
    }
    else 
        return FALSE;
               
    m_fDirty = FALSE;
    return TRUE;
}


CAlias::Delete()
{
    TCHAR aliasKey[MAX_PATH], buffer[MAX_PATH];
    StrCpy( aliasKey, g_szAliasKey);
    StrCat( aliasKey, TEXT("\\"));
    StrCat( aliasKey, m_alias );
    RegDeleteKey( HKEY_CURRENT_USER, aliasKey ); 
    return TRUE;
}

#ifdef DEBUG
CAlias::Print()
{
    if( m_alias ) printf( m_alias );
    printf(",");
    if( m_szurl ) printf( m_szurl );
    printf("\n");
    return TRUE;
}
#endif

STDAPI_(BOOL) FreeAliases( HDPA aliasListIn )
{
    if(aliasListIn)
    {
        int aliasCount = DPA_GetPtrCount( aliasListIn );

        for(int i=0; i<aliasCount; i++ )
        {
           CAlias * ptr = (CAlias *)DPA_FastGetPtr( aliasListIn, i );
          if(ptr) delete ptr;
        }
        return TRUE;
    }

    return FALSE;
}

STDAPI_(BOOL) AddAliasToList( HDPA aliasListIn, LPTSTR aliasIn, LPTSTR szurl, HWND hwnd )
{
    int index;
    CAlias * ptr;
    TCHAR alias[ MAX_ALIAS_LENGTH + 1 ];
    TCHAR achTemp[MAX_ALIAS_LENGTH], achTemp2[MAX_ALIAS_LENGTH];

    if (aliasListIn && aliasIn && lstrlen(aliasIn)<MAX_ALIAS_LENGTH)
    {
        StrCpy( alias, aliasIn );
        EatSpaces( alias );
        if((index = FindAliasIndex( aliasListIn, alias )) != -1)
        {
            if( !hwnd ) 
                return FALSE;

            MLLoadShellLangString(IDS_ERROR_ALIAS_ALREADY_EXISTS,
                achTemp, sizeof(achTemp));
            MLLoadShellLangString(IDS_TITLE_ALIASADD,
                achTemp2, sizeof(achTemp2));

            if(hwnd && MessageBox(hwnd, achTemp, achTemp2 , MB_YESNO|MB_ICONQUESTION) != IDYES)
                 return FALSE;

            ptr = (CAlias *)DPA_FastGetPtr( aliasListIn, index );
            SetAliasInfo( ptr, NULL, szurl );
            return TRUE;
        }
        else
        {
            ptr = new CAlias( alias );
            SetAliasInfo( ptr, NULL, szurl );
            DPA_InsertPtr(aliasListIn, 0x7FFF, (LPVOID)ptr);
            return TRUE;
        }
    }

    return FALSE;
}

STDAPI_(BOOL) SaveAliases( HDPA aliasListIn )
{
    // Save the currently changed aliases
    if( aliasListIn )
    {
        int count = DPA_GetPtrCount( aliasListIn );

        for(int i=0;i<count;i++)
        {
            CAlias * pAlias = (CAlias *)DPA_FastGetPtr( aliasListIn, i );
            if(pAlias && pAlias->m_fDirty)
            {
                pAlias->Save();
            }
        }

        return TRUE;
    }

    return FALSE;
}

STDAPI_(BOOL) LoadAliases( HDPA aliasListIn )
{
    HKEY hKey, hKeyAlias;
    int index = 0;
    DWORD dwLen  = MAX_PATH;

    if(aliasListIn) 
        FreeAliases( aliasListIn );

    TCHAR * buffer = (TCHAR *)LocalAlloc( LPTR, (MAX_PATH+1)*sizeof(TCHAR) );

    LONG lResult = RegOpenKeyExA(
                HKEY_CURRENT_USER,
                g_szAliasKey,
                0,
                KEY_QUERY_VALUE | KEY_READ,
                &hKeyAlias);
    
    if( lResult == ERROR_SUCCESS )
    {
        while( buffer )
        {
            dwLen  = MAXPATH; 
            if( RegEnumKeyEx( hKeyAlias, index, buffer, &dwLen,
                              NULL, NULL, NULL, NULL )
                == ERROR_NO_MORE_ITEMS ) break;
            {
                CAlias * ptr = new CAlias( buffer );

                if(ptr->Load())
                {
                   DPA_InsertPtr(aliasListIn, 0x7FFF, (LPVOID)ptr);
                   ptr->m_fDirty = FALSE;
                }
                else
                   delete ptr;

                index++;
            }
        }

        if(buffer) LocalFree( buffer );
        RegCloseKey( hKeyAlias );
    }

    return TRUE;
}


#ifdef DEBUG
STDAPI_(BOOL) PrintAliases( HDPA aliasListIn )
{
    printf("Listing Aliases:\n");

    if( !aliasListIn ) return FALSE;

    int aliasCount = DPA_GetPtrCount( aliasListIn );
    for(int i=0; i<aliasCount; i++ )
    {
       CAlias * ptr = (CAlias *)DPA_FastGetPtr( aliasListIn, i );
       ptr->Print();
    }

    return TRUE;
}
#endif

STDAPI_(INT) FindAliasIndex(HDPA aliasListIn , LPTSTR alias)
{
    if( ! aliasListIn ) return -1;

    int aliasCount = DPA_GetPtrCount( aliasListIn );
    for(int i = 0; i< aliasCount;i++ )
    {
        CAlias * ptr = (CAlias *)DPA_FastGetPtr( aliasListIn, i );
        if( !StrCmpI(alias, ptr->m_alias) )
            return i;
    }

    return -1;
}

STDAPI_(BOOL) FindAliasByURL(HDPA aliasListIn , LPTSTR szurl, LPTSTR aliasIn, INT cchAlias)
{
    if( ! aliasListIn ) return FALSE;

    int aliasCount = DPA_GetPtrCount( aliasListIn );
    for(int i = 0; i< aliasCount;i++ )
    {
        CAlias * ptr = (CAlias *)DPA_FastGetPtr( aliasListIn, i );
        if( !StrCmp(szurl, ptr->m_szurl) )
        {
            StrCpy( aliasIn, ptr->m_alias );
            return TRUE;
        }
    }

    return FALSE;
}

STDAPI_(BOOL) GetURLForAlias(HDPA aliasListIn, LPTSTR alias, LPTSTR szUrl, int cchUrl )
{
    int index = -1;

    if(!aliasListIn || !alias || !szUrl || cchUrl <= 0 ) return FALSE;
    
    // ENTERCRITICAL;

    if( (index = FindAliasIndex(aliasListIn, alias) ) != -1 )
    {
         CAlias * ptr = (CAlias *)DPA_FastGetPtr( aliasListIn, index );
         StrCpy( szUrl, ptr->m_szurl );
    }

Done:
    // LEAVECRITICAL;
    return (index != -1);  
}


STDAPI_(LPCTSTR) GetAliasName( CAlias * ptr )
{
    if( ptr )
        return ptr->m_alias;
    return NULL;
}

STDAPI_(LPCTSTR) GetAliasUrl( CAlias * ptr )
{
    if( ptr )
        return ptr->m_szurl;
    return NULL;
}

STDAPI_(LPVOID) CreateAlias( LPTSTR str )
{
    return new CAlias(str);
}

STDAPI_(VOID) DestroyAlias( CAlias * ptr )
{
    if( ptr ) delete ptr;
}

STDAPI_(BOOL) SetAliasInfo( CAlias * ptr, TCHAR * alias, TCHAR * url )
{
    if( ptr )
    {
        if(alias)
        {
           if( ptr->m_alias ) LocalFree( ptr->m_alias );
           ptr->m_alias = DuplicateString( alias );
           ptr->m_fDirty= TRUE;
        }
        if(url)
        {
           if( ptr->m_szurl ) LocalFree( ptr->m_szurl );
           ptr->m_szurl = DuplicateString( url );
           ptr->m_fDirty= TRUE;
        }
    } 
}



#ifdef UNICODE
STDAPI_(BOOL) FindAliasByURLA(HDPA aliasListIn , LPTSTR szurl, LPTSTR aliasIn, INT cchAlias)
{
    WCHAR szwurl[MAX_URL_STRING];
    WCHAR aliasw[MAX_ALIAS_LENGTH];

    if( !szurl || !aliasIn || !aliasListIn ) 
        return FALSE;

    SHAnsiToUnicode( aliasIn, alias
}

STDAPI_(BOOL) AddAliasToListA( HDPA aliasListIn, LPTSTR aliasIn, LPTSTR szurl, HWND hwnd )
{
    return FALSE;
}


#else

TCHAR *DuplicateString( TCHAR *orig )
{
    TCHAR * newStr;
    if( !orig ) return NULL;

    newStr  = (TCHAR *)LocalAlloc( LPTR, (lstrlen(orig) + 1)*sizeof(TCHAR));
    if(newStr) StrCpy( newStr, orig );

    return newStr;
}

TCHAR *EatSpaces( TCHAR * str )
{
    if( !str ) return NULL;

    TCHAR *ptr = str, *tmpStr = DuplicateString( str );
    TCHAR *tmpPtr = tmpStr;

    while( *tmpStr )
    {
        if(*tmpStr == TEXT(' ')  || *tmpStr == TEXT('\t') || 
           *tmpStr == TEXT('\n') || *tmpStr == TEXT('\r') || 
            // Remove special characters.
            (int)(*tmpStr) >= 127)
            tmpStr++; 
        else
            *ptr++ = *tmpStr++;
    }

    *ptr = TEXT('\0');

    LocalFree( tmpPtr );

    return str;
}

#endif /* UNICODE */

#endif /* UNIX_FEATURE_ALIAS */
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\util.cpp ===
//*                  Microsoft Windows                               **
//*            Copyright(c) Microsoft Corp., 1994                    **
//*********************************************************************

//
//  UTIL.C - common utility functions
//

//  HISTORY:
//  
//  12/21/94    jeremys     Created.
//

#include "inetcplp.h"
#include <advpub.h>         // For REGINSTALL
#include <mluisupp.h>
#include "brutil.h"
#include <mlang.h>
#include <inetreg.h>

// function prototypes
VOID _cdecl FormatErrorMessage(TCHAR * pszMsg,DWORD cbMsg,TCHAR * pszFmt,va_list ArgList);
extern VOID GetRNAErrorText(UINT uErr,CHAR * pszErrText,DWORD cbErrText);
extern VOID GetMAPIErrorText(UINT uErr,CHAR * pszErrText,DWORD cbErrText);

/*******************************************************************

    NAME:       MsgBox

    SYNOPSIS:   Displays a message box with the specified string ID

********************************************************************/
int MsgBox(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons)
{
    TCHAR szMsgBuf[MAX_RES_LEN+1];
    TCHAR szSmallBuf[SMALL_BUF_LEN+1];

    MLLoadShellLangString(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));
    MLLoadShellLangString(nMsgID,szMsgBuf,sizeof(szMsgBuf));

    MessageBeep(uIcon);
    return (MessageBox(hWnd,szMsgBuf,szSmallBuf,uIcon | uButtons));

}

/*******************************************************************

    NAME:       MsgBoxSz

    SYNOPSIS:   Displays a message box with the specified text

********************************************************************/
int MsgBoxSz(HWND hWnd,LPTSTR szText,UINT uIcon,UINT uButtons)
{
    TCHAR szSmallBuf[SMALL_BUF_LEN+1];
    MLLoadShellLangString(IDS_APPNAME,szSmallBuf,sizeof(szSmallBuf));

    MessageBeep(uIcon);
    return (MessageBox(hWnd,szText,szSmallBuf,uIcon | uButtons));
}

/*******************************************************************

    NAME:       MsgBoxParam

    SYNOPSIS:   Displays a message box with the specified string ID

    NOTES:      extra parameters are string pointers inserted into nMsgID.

********************************************************************/
int _cdecl MsgBoxParam(HWND hWnd,UINT nMsgID,UINT uIcon,UINT uButtons,...)
{

        va_list nextArg;

    BUFFER Msg(3*MAX_RES_LEN+1);    // nice n' big for room for inserts
    BUFFER MsgFmt(MAX_RES_LEN+1);

    if (!Msg || !MsgFmt) {
        return MsgBox(hWnd,IDS_ERROutOfMemory,MB_ICONSTOP,MB_OK);
    }

        MLLoadShellLangString(nMsgID,MsgFmt.QueryPtr(),MsgFmt.QuerySize());

        va_start(nextArg, uButtons);

    FormatErrorMessage(Msg.QueryPtr(),Msg.QuerySize(),
        MsgFmt.QueryPtr(),nextArg);
        va_end(nextArg);
    return MsgBoxSz(hWnd,Msg.QueryPtr(),uIcon,uButtons);
}

BOOL EnableDlgItem(HWND hDlg,UINT uID,BOOL fEnable)
{
    return EnableWindow(GetDlgItem(hDlg,uID),fEnable);
}


/*******************************************************************

    NAME:       LoadSz

    SYNOPSIS:   Loads specified string resource into buffer

    EXIT:       returns a pointer to the passed-in buffer

    NOTES:      If this function fails (most likely due to low
                memory), the returned buffer will have a leading NULL
                so it is generally safe to use this without checking for
                failure.

********************************************************************/
LPTSTR LoadSz(UINT idString,LPTSTR lpszBuf,UINT cbBuf)
{
    ASSERT(lpszBuf);

    // Clear the buffer and load the string
    if ( lpszBuf )
    {
        *lpszBuf = '\0';
        MLLoadString( idString, lpszBuf, cbBuf );
    }
    return lpszBuf;
}

/*******************************************************************

    NAME:       FormatErrorMessage

    SYNOPSIS:   Builds an error message by calling FormatMessage

    NOTES:      Worker function for DisplayErrorMessage

********************************************************************/
VOID _cdecl FormatErrorMessage(TCHAR * pszMsg,DWORD cbMsg,TCHAR * pszFmt,va_list ArgList)
{
    ASSERT(pszMsg);
    ASSERT(pszFmt);

    // build the message into the pszMsg buffer
    DWORD dwCount = FormatMessage(FORMAT_MESSAGE_FROM_STRING,
        pszFmt,0,0,pszMsg,cbMsg,&ArgList);
    ASSERT(dwCount > 0);
}


/*----------------------------------------------------------
Purpose: Calls the ADVPACK entry-point which executes an inf
         file section.

*/
HRESULT CallRegInstall(LPSTR szSection)
{
    HRESULT hr = E_FAIL;

    STRENTRY seReg[] = {
#ifdef WINNT
        { "CHANNELBARINIT", "no" }, // channel bar off by default on NT
#else
        { "CHANNELBARINIT", "yes" } // channel bar on by default on Win95/98
#endif
    };
    STRTABLE stReg = { ARRAYSIZE(seReg), seReg };

    RegInstall(ghInstance, szSection, &stReg);

    return hr;
}

//
// Code page to Script mapping table
// Can't load MLang during setup, so, we port this table from MLANG
//
typedef struct tagCPTOSCRIPT{
	UINT        uiCodePage;
	SCRIPT_ID   sid;
} CPTOSCRIPT;

const CPTOSCRIPT CpToScript [] = 
{
    {1252,  sidAsciiLatin},
    {1250,  sidAsciiLatin},
    {1254,  sidAsciiLatin},
    {1257,  sidAsciiLatin},
    {1258,  sidAsciiLatin},
    {1251,  sidCyrillic  },
    {1253,  sidGreek     },
    {1255,  sidHebrew    },
    {1256,  sidArabic    },
    {874,   sidThai      },
    {932,   sidKana      },
    {936,   sidHan       },
    {949,   sidHangul    },
    {950,   sidBopomofo  },
    {50000, sidUserDefined},
};


/*******************************************************************

    NAME:       MigrateIEFontSetting

    SYNOPSIS:   Port IE4 font setting data to IE5 script settings

    NOTES:      

********************************************************************/

VOID MigrateIEFontSetting(void)
{
    HKEY    hKeyInternational;
    HKEY    hKeyScripts;

    // Open IE international setting registry key
    if (ERROR_SUCCESS ==
        RegOpenKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_INTERNATIONAL, NULL, KEY_READ, &hKeyInternational))
    {
        DWORD dwIndex = 0;
        DWORD dwCreate = 0;
        TCHAR szCodePage[1024] = {0};

        // Open/Create scripts key
        if (ERROR_SUCCESS == RegCreateKeyEx(hKeyInternational, REGSTR_VAL_FONT_SCRIPTS, 0, NULL, 
                                            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, 
                                            NULL, &hKeyScripts, &dwCreate))
        {
            // If scripts already exists, we're upgrading from IE5, no data porting needed
            if (dwCreate == REG_CREATED_NEW_KEY)
            {
                DWORD dwSize = ARRAYSIZE(szCodePage);
                TCHAR szFont[LF_FACESIZE];

    	        while (ERROR_SUCCESS == RegEnumKeyEx(hKeyInternational, dwIndex, szCodePage, 
                                                     &dwSize, NULL, NULL, NULL, NULL))
    	        {
                    UINT uiCP = StrToInt(szCodePage);

                    for (int i=0; i<ARRAYSIZE(CpToScript); i++)
                    {
                        if (uiCP == CpToScript[i].uiCodePage)
                        {
                            HKEY hKeyCodePage;

                            if ( ERROR_SUCCESS == RegOpenKeyEx(hKeyInternational, szCodePage, 
                                                               NULL, KEY_READ, &hKeyCodePage))
                            {
                                HKEY    hKeyScript;
                                CHAR    szScript[1024];
                                    
                                wsprintfA(szScript, "%d", CpToScript[i].sid);

                                // Port code page font data to script font data
                                // If CP == 1252, we always need to use it to update Latin CP font info
                                if ((ERROR_SUCCESS == RegCreateKeyExA(hKeyScripts, szScript, 0, NULL, 
                                            REG_OPTION_NON_VOLATILE, KEY_ALL_ACCESS, 
                                            NULL, &hKeyScript, &dwCreate)) &&
                                    ((dwCreate == REG_CREATED_NEW_KEY) || (uiCP == 1252)))
                                {
                                    DWORD cb = sizeof(szFont);

                                    if (ERROR_SUCCESS == RegQueryValueEx(hKeyCodePage, 
                                                            REGSTR_VAL_FIXED_FONT, NULL, NULL,
                                                            (LPBYTE)szFont, &cb))
                                    {
                                        RegSetValueEx(hKeyScript, REGSTR_VAL_FIXED_FONT, 0, 
                                            REG_SZ, (LPBYTE)szFont, cb);
                                    }

                                    cb = sizeof(szFont);
                                    if (ERROR_SUCCESS == RegQueryValueEx(hKeyCodePage, 
                                                            REGSTR_VAL_PROP_FONT, NULL, NULL,
                                                            (LPBYTE)szFont, &cb))
                                    {
                                        RegSetValueEx(hKeyScript, REGSTR_VAL_PROP_FONT, 0, 
                                            REG_SZ, (LPBYTE)szFont, cb);
                                    }
                                    RegCloseKey(hKeyScript);
                                }                                
                                RegCloseKey(hKeyCodePage);
                            }
                        }                    
                    }
                    dwIndex++;
                    dwSize = ARRAYSIZE(szCodePage);
                }
            }
            RegCloseKey(hKeyScripts);
        }
        RegCloseKey(hKeyInternational);
    }        
}

#define TSZUNATTENDEDINTRANET TSZWININETPATH TEXT("\\Unattend\\LocalIntranetSites")
#define TSZUNATTENDEDTRUSTED  TSZWININETPATH TEXT("\\Unattend\\TrustedSites")

//Copy trusted/Intranet sites list from HKLM into ZoneMap
void CopySitesList(DWORD dwZone, TCHAR *szSubKey)
{
    HRESULT hr;
    HKEY hKey = NULL;
    IInternetSecurityManager* pInternetSecurityManager = NULL;
    TCHAR szValueName[32];
    TCHAR szUrl[128];
    DWORD cValueName, cbUrl;
    
    if (FAILED(CoInternetCreateSecurityManager(NULL, &pInternetSecurityManager,0)))
    {
        goto Cleanup;  // no zone manager?
    }

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, szSubKey, 0, KEY_QUERY_VALUE, &hKey))
    {
        for (DWORD i=0; ; i++)
        {
            cValueName = sizeof(szValueName)/sizeof(szValueName[0]);
            cbUrl = sizeof(szUrl);
            hr = RegEnumValue(hKey, i, szValueName, &cValueName, NULL, NULL, (LPBYTE)szUrl, &cbUrl);

            if (hr == ERROR_NO_MORE_ITEMS)
            {
                break;
            }
            else if (hr == ERROR_SUCCESS)
            {
                pInternetSecurityManager->SetZoneMapping(dwZone, szUrl, SZM_CREATE);
            }
        }

        RegCloseKey(hKey);
    }

Cleanup:

    if (pInternetSecurityManager)
        pInternetSecurityManager->Release();

    return;

}

#if 0
//Remove sites list from ZoneMap;
void ClearSitesList(DWORD dwZone)
{
    IInternetSecurityManager* pInternetSecurityManager = NULL;
    IEnumString *pEnumString = NULL;
    LPOLESTR pOleStr;
    
    if (FAILED(CoInternetCreateSecurityManager(NULL, &pInternetSecurityManager,0)))
    {
        goto Cleanup;  // no zone manager?
    }

    if (S_OK != pInternetSecurityManager->GetZoneMappings(dwZone, &pEnumString, 0))
    {
        goto Cleanup;
    }
    
    while (S_OK == pEnumString->Next(1, &pOleStr, NULL))
    {
        pInternetSecurityManager->SetZoneMapping(dwZone, pOleStr, SZM_DELETE);
    }

Cleanup:

    if (pInternetSecurityManager)
        pInternetSecurityManager->Release();

    if (pEnumString)
        pEnumString->Release();

    return;
}
#endif

/*----------------------------------------------------------
Purpose: Install/uninstall user settings

*/
STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
#ifdef DEBUG
    if (IsFlagSet(g_dwBreakFlags, BF_ONAPIENTER))
    {
        TraceMsg(TF_ALWAYS, "Stopping in DllInstall");
        DEBUG_BREAK;
    }
#endif

    if (bInstall)
    {
        if (pszCmdLine)
        {
            if(!StrCmpIW(pszCmdLine, L"HKCUHard"))
            {
                CallRegInstall("RegDll.HKCUHard");
                CopySitesList(URLZONE_TRUSTED, TSZUNATTENDEDTRUSTED);
                CopySitesList(URLZONE_INTRANET, TSZUNATTENDEDINTRANET);
                return S_OK;
            }

            if(!StrCmpIW(pszCmdLine, L"HKCUSoft"))
            {
                CallRegInstall("RegDll.HKCUSoft");
                return S_OK;
            }

            if(!StrCmpIW(pszCmdLine, L"HKLMHard"))
            {
                CallRegInstall("RegDll.HKLMHard"); 
                return S_OK;
            }

            if(!StrCmpIW(pszCmdLine, L"HKLMSoft"))
            {
                CallRegInstall("RegDll.HKLMSoft");
                return S_OK;
            }
        }

        //
        // We use to delete the whole key here - that doesn't work anymore
        // because other people write to this key and we don't want 
        // to crush them. If you need to explicity delete a value
        // add it to ao_2 value
        // CallRegInstall("UnregDll");
        CallRegInstall("RegDll");
        
        // If we also have the integrated shell installed, throw in the options
        // related to the Integrated Shell.
        if (WhichPlatform() == PLATFORM_INTEGRATED)
            CallRegInstall("RegDll.IntegratedShell");

        // NT5's new shell has special reg key settings
        if (GetUIVersion() >= 5)
            CallRegInstall("RegDll.NT5");

        // Run Whistler-specific settings.
        if (IsOS(OS_WHISTLERORGREATER))
        {
            CallRegInstall("RegDll.Whistler");
        }

        // Port IE4 code page font setting
        MigrateIEFontSetting();
    }
    else
    {
        CallRegInstall("UnregDll");
    }

    return S_OK;
}


#define REGSTR_CCS_CONTROL_WINDOWS  REGSTR_PATH_CURRENT_CONTROL_SET TEXT("\\WINDOWS")
#define CSDVERSION      TEXT("CSDVersion")

BOOL IsNTSPx(BOOL fEqualOrGreater, UINT uMajorVer, UINT uSPVer)
{
    HKEY    hKey;
    DWORD   dwSPVersion;
    DWORD   dwSize;
    BOOL    fResult = FALSE;
    OSVERSIONINFO VerInfo;

    VerInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);

    GetVersionEx(&VerInfo);

    // make sure we're on NT4 or greater (or specifically NT4, if required)
    if (VER_PLATFORM_WIN32_NT != VerInfo.dwPlatformId ||
        (!fEqualOrGreater && VerInfo.dwMajorVersion != uMajorVer) ||
        (fEqualOrGreater && VerInfo.dwMajorVersion < uMajorVer))
        return FALSE;

    if (fEqualOrGreater && VerInfo.dwMajorVersion > uMajorVer)
        return TRUE;

    // check for installed SP
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, REGSTR_CCS_CONTROL_WINDOWS, 0, KEY_QUERY_VALUE, &hKey) == ERROR_SUCCESS)
    {
        dwSize = sizeof(dwSPVersion);
        if (RegQueryValueEx(hKey, CSDVERSION, NULL, NULL, (unsigned char*)&dwSPVersion, &dwSize) == ERROR_SUCCESS)
        {
            dwSPVersion = dwSPVersion >> 8;
        }
        RegCloseKey(hKey);

        if (fEqualOrGreater)
            fResult = (dwSPVersion >= uSPVer ? TRUE : FALSE);
        else
            fResult = (dwSPVersion == uSPVer ? TRUE : FALSE);
    }

    return fResult;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by inetcpld.rc
//
#define IDD_GENERAL                     100
#define IDD_SECURITY_ADD_SITES          101
#define IDD_COLORS                      102
#define IDD_SECURITY_INTRANET           103
#define IDC_GENERAL_APPEARANCE_UNDERLINE_LINKS_CHECKBOX 104
#define IDC_GENERAL_APPEARANCE_GROUPBOX 105
#define IDC_GENERAL_MULTIMEDIA_PICTURES_CHECKBOX 106
#define IDC_GENERAL_APPEARANCE_USE_CUSTOM_COLORS_CHECKBOX 107
#define IDC_GENERAL_APPEARANCE_COLOR_TEXT 108
#define IDC_GENERAL_APPEARANCE_COLOR_BACKGROUND 109
#define IDC_GENERAL_APPEARANCE_COLOR_LINKS 110
#define IDC_GENERAL_APPEARANCE_COLOR_VISITED_LINKS 111
#define IDC_GENERAL_APPEARANCE_COLOR_HOVER 112
#define IDC_GENERAL_MULTIMEDIA_VIDEOS_CHECKBOX 113
#define IDC_GENERAL_SHOW_TEXT_ON_TOOLBAR 114
#define IDC_GENERAL_MULTIMEDIA_GROUPBOX 115
#define IDC_GENERAL_SHOW_BACKGROUNG_BITMAPS_CHECKBOX 116
#define IDC_GENERAL_SHOW_GROUPBOX       117
#define IDD_SECURITY_CUSTOM_SETTINGS    118
#define IDD_CONNECTION                  200
#define IDC_CONNECTION_DIALING_GROUPBOX 201
#define IDC_CONNECTION_PROXY_GROUPBOX   202
#define IDC_CONNECTION_PROXY_SETTINGS_BTN 203
#define IDC_CHOOSE_CONNECTOID           205
#define IDC_ENABLE_AUTODISCONNECT       206
#define IDC_IDLE_SPIN                   207
#define IDC_IDLE_TIMEOUT                208
#define IDC_ADD                         209
#define IDC_PROPERTIES                  210
#define IDC_INTERVAL                    211
#define IDC_TX_CHOOSE_CONNECTOID        212
#define IDC_GRP_SETTINGS2               213
#define IDC_TX_AUTODISCONNECT           214
#define IDC_CONNECT                     215
#define IDC_CONNECT_SPIN                216
#define IDC_INTERVAL_SPIN               217
#define IDC_PROXY_EXCEPTIONS_GROUPBOX   218
#define IDC_CONNECTION_AUTOCONFIG       219
#define IDD_PROGRAMS                    300
#ifndef UNIX
#define IDC_PROGRAMS_MAIL_COMBO         301
#define IDC_PROGRAMS_NEWS_COMBO         302
#define IDC_PROGRAMS_CALL_COMBO         313
#else
#define IDC_EDIT_PROGRAMS_MAIL          301
#define IDC_EDIT_PROGRAMS_NEWS          302
#define IDC_EDIT_PROGRAMS_VSOURCE       313
#endif
#define IDC_CHECK_ASSOCIATIONS_CHECKBOX 303
#define IDC_PROGRAMS_CALENDAR_COMBO     304
#define IDC_PROGRAMS_MAILANDNEWS_GROUPBOX 305
#define IDC_PROGRAMS_CONTACT_COMBO      306
#define IDC_PROGRAMS_WALLET_GROUPBOX    307
#define IDC_PROGRAMS_WALLET_PAYBUTTON   308
#define IDC_PROGRAMS_WALLET_ADDRBUTTON  309
#define IDC_PROGRAMS_IE_IS_FTPCLIENT    310
#define IDC_INTERNET_CALLS_GROUPBOX     311
#define IDC_PROGRAMS_MAIL_COMBO3        312
#ifdef UNIX
#define IDC_OE_MAIL                     320
#define IDC_MAIL_FIND                   314
#define IDC_MAIL_EDIT                   315
#define IDC_OE_NEWS                     321
#define IDC_NEWS_FIND                   316
#define IDC_NEWS_EDIT                   317
#define IDC_VSOURCE_FIND                318
#define IDC_VSOURCE_EDIT                319
#endif
#define IDC_PROGRAMS_WALLET_SETTINGS    320
#define IDC_AUTOSUGGEST_SETTINGS        321
#define IDD_PLACES                      400
#define IDC_PLACES_CUSTOMIZE_GROUPBOX   401
#define IDC_PLACES_CURRENT              402
#define IDC_USEBLANK                    404
#define IDC_PLACES_NAME                 405
#define IDC_PLACES_ADDRESS              406
#define IDC_PLACES_HISTORY_DAYS         407
#define IDC_PLACES_HISTORY_SPIN         408
#define IDC_PLACES_HISTORY_EMPTY        409
#define IDC_PLACES_HISTORY_GROUPBOX     410
#define IDC_PLACES_VIEW_HISTORY_BUTTON  411
#define IDD_SECURITY                    500
#define IDC_SECURITY_JAVA_CHECKBOX      501
#define IDC_SECURITY_ACTIVEX_SCRIPTING_CHECKBOX 503
#define IDC_SECURITY_ACTIVEX_CONTROLS_CHECKBOX 504
#define IDC_SECURITY_CODE_DOWNLOAD_BUTTON 505
#define IDC_SECURITY_SITES_BUTTON       511
//#define IDC_SECURITY_PERSONAL_BUTTON    512
#define IDC_SECURITY_WARNINGS_BUTTON    514
#define IDC_SECURITY_PUBLISHERS_BUTTON  515
#define IDC_SECURITY_ACTIVE_CONTENT_GROUPBOX 516
#define IDC_SECURITY_ACTIVE_CONTENT_GROUPBOX2 517
#define IDC_SECURITY_CLEAR_SSL_CACHE_BUTTON 518
#define IDD_ADVANCED                    600
#define IDC_RATINGS_TURN_ON             601
#define IDC_ADVANCED_MOVE_CACHE_LOCATION 605
#define IDC_ADVANCED_CACHE_MB           606
#define IDC_ADVANCED_RATINGS_GROUPBOX   607
#define IDC_ADVANCED_CACHE_LOCATION     608
#define IDC_ADVANCED_CACHE_BROWSE       609
#define IDC_ADVANCED_CACHE_PERCENT      610
#define IDC_ADVANCED_CACHE_TEXT_PERCENT 611
#define IDC_ADVANCED_CACHE_EMPTY        612
#define IDC_ADVANCED_CACHE_ONCEPERSESS  613
#define IDC_ADVANCED_CACHE_NEVER        614
#define IDC_ADVANCED_CACHE_AUTOMATIC    615
#define IDC_ADVANCED_CACHE_FILES_BUTTON 616
#define IDC_ADVANCED_CACHE_ALWAYS       618
#define IDC_ADVANCED_RATINGS_BUTTON     619
#define IDC_ADVANCED_TEMP_FILES_GROUPBOX 620
#define IDC_RATINGS_TEXT                621
#define IDC_RATINGS_ICON                622
#define IDC_CONNECTION_AUTO_CONFIG_BUTTON 623
#define IDC_CACHE_DELETE_FILES          624
#define IDC_ADVANCED_CACHE_STATUS       625
#define IDC_ADVANCED_CACHE_SIZE_SPIN    626
#define IDC_CACHE_DELETE_COOKIES        627
#define IDD_TEMP_FILES                  700
#define IDC_TEMPORARY_INTERNET_FILES_SETTINGS_GROUPBOX 701
#define IDD_AUTOSUGGEST_SETTINGS        750
#define IDD_WALLET_SETTINGS             751
#define IDC_AUTOSUGGEST_ENABLEADDR      756
#define IDC_AUTOSUGGEST_ENABLEFORM      757
#define IDC_AUTOSUGGEST_CLEARFORM       758
#define IDC_AUTOSUGGEST_SAVEPASSWORDS   759
#define IDC_AUTOSUGGEST_CLEARPASSWORDS  760
#define IDC_AUTOSUGGEST_PROMPTPASSWORDS 761
#define IDC_AUTOSUGGEST_CLEAR_TEXT      762
#define IDC_AUTOSUGGEST_FOR_GROUP       763
#define IDC_AUTOSUGGEST_HISTORY_GROUP   764
#define IDC_AUTOSUGGEST_STATIC_TEXT     765
#define IDD_SAFETY                      800
#define IDC_SAFETY_GROUPLABEL           801
#define IDC_SAFETY_LEVEL_HIGH           802
#define IDC_SAFETY_LEVEL_MEDIUM         803
#define IDC_SAFETY_LEVEL_LOW            804
#define IDD_FONTS                       1000
#define IDC_FONTS_SCRIPTS_GROUPBOX      1001
#define IDC_FONTS_CHAR_SET_COMBO        1002
#define IDC_BUTTON_REMOVE               1003
#define IDC_FONTS_PROP_FONT_LIST        1005
#define IDC_FONTS_FIXED_FONT_LIST       1007
#define IDC_CHECK_PROXY                 1008
#define IDC_EDIT_ADD_SITE               1010
#define IDC_CHECK_USEINTRANET           1011
#define IDC_CHECK_USE_MY_STYLESHEET     1012
#define IDC_COMBO_ZONE                  1013
#define IDC_RADIO_HIGH                  1014
#define IDC_RADIO_MEDIUM                1015
#define IDC_RADIO_LOW                   1016
#define IDC_RADIO_CUSTOM                1017
#define IDC_BUTTON_SETTINGS             1018
#define IDC_BUTTON_ADD_SITES            1019
#define IDC_BUTTON_APPLY                1020
#define IDC_COMBO_RESETLEVEL            1022
#define IDC_CHECK_REQUIRE_SERVER_VERIFICATION 1023
#define IDC_TREE_SECURITY_SETTINGS      1024
#define IDC_GROUP_CURRENT_SETTINGS      1025
#define IDC_LIST_WEBSITES               1026
#define IDC_CHECK_SOFTWARE_PUBLISHING   1027
#define IDC_BUTTON_ADD                  1028
#define IDC_LEVEL_GROUPBOX              1029
#define IDC_STATIC_SLIDERMOVETEXT       1030
#define IDC_SEC_STATIC_CURRENT_LEVEL    1031
#define IDD_PROXY_SETTINGS              1100
#define IDC_ENABLE_SECURITYCHECK        1101
#define IDC_PROXY_ENABLE                1102
#define IDC_PROXY_HTTP_ADDRESS          1103
#define IDC_PROXY_OVERRIDE              1104
#define IDC_PROXY_SECURITY_ADDRESS      1105
#define IDC_PROXY_FTP_ADDRESS           1106
#define IDC_PROXY_GOPHER_ADDRESS        1107
#define IDC_PROXY_HTTP_PORT             1108
#define IDC_PROXY_SECURITY_PORT         1109
#define IDC_PROXY_FTP_PORT              1110
#define IDC_PROXY_GOPHER_PORT           1111
#define IDC_PROXY_SOCKS_ADDRESS         1112
#define IDC_PROXY_SOCKS_PORT            1113
#define IDC_PROXY_HTTP_CAPTION          1114
#define IDC_PROXY_SECURITY_CAPTION      1115
#define IDC_PROXY_FTP_CAPTION           1116
#define IDC_PROXY_GOPHER_CAPTION        1117
#define IDC_PROXY_USE_SAME_SERVER       1118
#define IDC_PROXY_OMIT_LOCAL_ADDRESSES  1119
#define IDC_PROXY_SOCKS_CAPTION         1120
#define IDD_AUTOCNFG_SETTINGS           1140
#define IDC_CONFIGJS_ADDR               1141
#define IDC_CONFIGTIMER                 1142
#define IDC_CONFIGOPTIMIZE              1143
#define IDD_SITECERTS                   1200
#define IDC_CERTLIST                    1201
#define IDC_VIEWCERT                    1202
#define IDC_DELETECERT                  1203
#define IDC_INTL                        1300
#define IDI_HOME                        1301
#define IDI_TOOLBAR                     1302
#define IDI_HISTORY                     1303
#define IDI_FONTS                       1304
#define IDI_CRYPTOGRAPHY                1305
#define IDI_RATINGS                     1306
#define IDI_PRIVACY                     1307
#define IDI_MAILANDNEWS                 1308
#define IDI_VIEWERS                     1309
#define IDI_CERTIFICATES                1310
#define IDI_OTHER                       1311
#define IDI_MULTIMEDIA                  1312
#define IDI_ZONE_INTERNET               1313
#define IDI_DIALUP                      1314
#define IDI_PROXY                       1315
#define IDI_SAFETY                      1317
#define IDI_APPEARANCE                  1318
#define IDI_CACHE                       1319
#define IDI_SAFECONTENT                 1320
#define IDI_ACTIVECONTENT               1321
#define IDI_WALLET                      1322
#define IDI_USERS                       1323
#define IDI_ICON1_PLACEHOLDER           1324
#define IDI_PROGRAMS                    1325
#define IDC_GENERAL_APPEARANCE_COLOR_TEXT_LABEL 1400
#define IDC_GENERAL_APPEARANCE_COLOR_BACKGROUND_LABEL 1401
#define IDC_ACCEPTENABLE                1405
#define IDC_ACCEPTDISABLE               1406
#define IDC_NOTACCEPT                   1407
#define IDC_TYPE_TEXT                   1408
#define IDC_ADDR_TEXT                   1409
#define IDC_PORT_TEXT                   1410
#define IDC_EXCEPT_TEXT                 1411
#define IDC_PROXY_ICON1                 1412
#define IDC_PROXY_ICON2                 1413
#define IDC_EXCEPT2_TEXT                1414
#define IDC_GENERAL_LINKS_GROUPBOX      1415
#define IDD_CRYPT                       1416
#define IDC_ALLOW_SSL2                  1417
#define IDC_ALLOW_SSL3                  1418
//#define IDC_ALLOW_PCT                   1419
#define IDC_DONT_WRITE_SSL_PAGES_TO_CACHE 1420
#define IDC_GROUP_PRINT                 1425
#define IDC_PRINT_BACKGROUND            1426
#define IDC_PRINT_BCKGRND_IMGS          1427
#define IDC_PRINT_SHORTCUT              1428
#define IDC_PRINT_TABLEHDFT             1429
#define IDC_PRINT_RECURSIVE             1432
#define IDC_FONTS_PROP_SAMPLE           1435
#define IDC_FONTS_FIXED_SAMPLE          1436
#define IDC_ADVANCEDTREE                1439
#define IDC_LANGUAGE                    1440
#define IDC_LANG_ACCEPT_LIST            1441
#define IDC_LANG_MOVE_UP_BUTTON         1442
#define IDC_LANG_MOVE_DOWN_BUTTON       1443
#define IDC_LANG_ADD_BUTTON             1444
#define IDC_LANG_REMOVE_BUTTON          1445
#define IDC_LANG_AVAILABLE_LIST         1446
#define IDC_LANG_USER_DEFINED_EDIT      1447
#define IDC_USE_IE40_SEARCH             1448
#define IDC_DELETE_SUB                  1449
#define IDC_PROXY_EXCEPTIONS            1450
#define IDC_PROXY_AUTO_URL              1451
#define IDC_PROXY_AUTO_RELOAD           1452
#define IDC_CONNECTION_WIZARD           1453
#define IDC_GRP_DIALUPSETTINGS          1454
#define IDC_GRP_LANSETTINGS             1455
#define IDC_OFFLINE                     1456
#define IDC_MODEM_SETTINGS              1457
#define IDC_NO_PROXY                    1458
#define IDC_PROXY_ADDR                  1460
#define IDC_PROXY_PORT                  1461
#define IDC_UNATTENDED                  1463
#define IDC_USER                        1464
#define IDC_PASSWORD                    1465
#define IDC_DOMAIN                      1466
#define IDC_FILENAME                    1466
#define IDC_PASSWORD2                   1467
#define IDC_ADDRESS_TEXT                1471
#define IDC_TX_USER                     1473
#define IDC_TX_PASSWORD                 1474
#define IDC_TX_DOMAIN                   1475
#define IDC_TX_CONNECT                  1476
#define IDC_TX2_CONNECT                 1477
#define IDC_TX_INTERVAL                 1478
#define IDC_TX2_INTERVAL                1479
//#define IDC_AUTOPROXY                   1481
#define IDC_COLORS                      1483
#define IDC_USEDEFAULT                  1485
#define IDC_USECURRENT                  1486
#define IDC_START_ADDRESS               1487
#define IDC_HISTORY_VIEW                1488
#define IDC_HISTORY_CLEAR               1489
#define IDC_CACHE_SETTINGS              1490
#define IDC_CACHE_VIEW_FILES            1491
#define IDC_HISTORY_DAYS                1492
#define IDC_HISTORY_SPIN                1493
#define IDC_FONTS                       1494
#define IDC_LANGUAGES                   1495
#define IDC_ACCESSIBILITY               1496
#define IDC_GROUP_FORMATTING            1497
#define IDC_CHECK_COLOR                 1498
#define IDC_CHECK_FONT_STYLE            1499
#define IDC_CHECK_FONT_SIZE             1500
#define IDC_AUTO_CONFIG_URL             1501
#define IDC_AUTO_REFRESH                1502
#define IDC_CUSTOM_TEXT                 1505
#define IDC_CHECK_NETWORK_CLIENT        1506
#define IDC_CHECK_NETWORK_SERVER        1507
#define IDC_CHECK_SECURE_EMAIL          1508
#define IDC_COMBO_SERVICE               1510
#define IDC_ADVANCED_STATIC             1512
#define IDC_ZONE_GROUPBOX               1513
#define IDC_DEFAULT_SETTINGS_GROUPBOX   1514
#define IDC_CONTACT_LIST_GROUPBOX       1515
#define IDC_ZONE_DESCRIPTION            1516
#define IDC_ADDSITES_GROUPBOX           1517
#define IDC_ZONE_ICON                   1518
#define IDC_UNDERLINE_LINKS_COMBO       1522
#define IDC_GENERAL_APPEARANCE_USE_HOVER_COLOR_CHECKBOX 1524
#define IDC_STYLESHEET_BROWSE           1525
#define IDC_RESTORE_DEFAULT             1526
#define IDC_GROUP_STYLESHEET            1528
#define IDC_EDIT_STYLESHEET             1529
#define IDC_EDIT_PROFILE                1530
#define IDC_ZONE_RESET                  1531
#define IDC_INTRANET_ADVANCED           1532
#define IDC_ADVANCED_DOWNLOADED_CONTROLS 1533
#define IDC_JAVACUSTOM                  1534
#define IDC_CERT_BROWSE                 1535
#define IDC_USE_EXISTING                1536
#define IDC_USE_FILE                    1537
#define IDC_CHECK_UNC                   1540
#define IDC_CHECK_ENABLE_CERT           1541
#define IDC_RESET_SHARING               1542
#define IDC_AUTOCONFIG                  1544
#define IDC_AUTOCONFIG_TX               1545
#define IDC_USE_LAN                     1546
#define IDC_INTRANET                    1546
#define IDC_INTERNET                    1547
#define IDC_AUTOCNFG_ADVANCED           1548
#define IDC_DIALUP_REMOVE               1549
#define IDC_DIALUP_COMBO                1550
#define IDC_DIALUP_ADD                  1552
#define IDC_DIALUP_PROP                 1553
#define IDC_AUTODIAL                    1554
#define IDC_PROXY_ADVANCED              1555
#define IDC_EXIT_DISCONNECT             1556
#define IDC_TX_LOGON                    1557
#define IDC_CONN_LIST                   1559
#define IDC_RAS_SETTINGS                1560
#define IDC_GRP_DIAL                    1561
#define IDC_GRP_NET                     1562
#define IDC_TX_TIMES                    1563
#define IDC_TX_SECONDS                  1564
#define IDC_NO_AUTOCONFIG               1565
#define IDC_LIST_ZONE                   1566
#define IDC_SLIDER                      1567
#define IDC_LEVEL_DESCRIPTION           1568
#define IDC_NOPROXY                     1568
#define IDC_CONFIGSCRIPT                1569
#define IDC_MANUAL                      1570
#define IDC_CONFIG_ADDR                 1571
#define IDC_CONFIGADDR_TX               1572
#define IDC_AUTODISCOVER                1573
#define IDC_ENABLE_SECURITY             1574
#define IDC_STATIC_EMPTY                1575
#define IDC_ZONELABEL                   1576
#define IDC_LEVEL_NAME                  1578
#define IDC_LAN_SETTINGS                1580
#define IDS_DEFAULT_TEXT                1581
#define IDC_SET_DEFAULT                 1582
#define IDC_DIAL_DEF_ISP                1583
#define IDC_DIAL_ADVANCED               1584
#define IDC_DIAL_DEF_TXT                1585
#define IDC_GRP_PROXY                   1586
#define IDC_TX_PROPS                    1587
#define IDC_CON_SHARING                 1588
#define IDC_LANG_UI_PREF                1600
#define IDC_COMBO_UILANG                1601
#define IDC_LANG_CURSEL                 1602
#define IDC_LANG_DESCCURSEL             1603
#define IDC_LANG_ADDSPK                 1604
#define IDC_PROGRAMS_HTMLEDITOR_COMBO   1610
#define IDC_GRP_AUTO                    1611
#define IDC_DONT_USE_CONNECTION         1612
#define IDC_FONTS_PROP_FONT_COMBO       1613
#define IDC_FONTS_FIXED_FONT_COMBO      1614
#define IDC_FONTS_DEFAULT_LANG_TEXT     1615
#define IDC_FONTS_CODE_PAGES_LIST       1616
#define IDC_FONTS_SIZE_FONT_COMBO       1617
#define IDC_FONTS_MIME_FONT_COMBO       1618
#define IDC_FONTS_SETDEFAULT_BUTTON     1619
#define IDD_FONTS_IE4                   1620
#define IDC_DIALUP_NEVER                1621
#define IDC_DIALUP_ON_NONET             1622
#define IDC_DIALUP                      1623
#define IDC_ADVANCED_CACHE_PERCENT_ACC  1624
#define IDC_ERROR_USING_SYSTEM_DIR      4300
#define IDS_SELECT_CACHE                4301
// #define IDS_ERROR_SYSTEM_DIRECTORY      4302
#define IDS_REBOOTING_WARNING           4303
#define IDS_ERROR_REGISTRY_TITLE        4304
#define IDS_ERROR_WARNING_TITLE         4305
// #define IDS_ERROR_MUST_BE_ADMIN         4306
// #define IDS_ERROR_ADMIN_TITLE           4307
#define IDS_REBOOTING_TITLE             4308
// #define IDS_ERROR_REG_MISSING_SYSTEM_DIR 4309
#define IDS_ERROR_INVALID_PATH_MSG      4310
#define IDS_ERROR_INVALID_PATH_TITLE    4311
#define IDS_INTERNET                    4312
#define IDS_DESCRIPTION                 4313
#define IDS_APPNAME                     4314
#define IDS_RNADLL_FILENAME             4316
#define IDS_HELPFILE                    4317
#define IDS_RATINGS_TURN_OFF            4318
#define IDS_RATINGS_TURN_ON             4319
#define IDS_ERROutOfMemory              4320
// #define IDS_ConnectoidNotFound          4321
#define IDS_ConnectoidNotSpecified      4322
#define IDS_USERS                       4323
#define IDS_USERS_DESCRIPTION           4324
#define IDS_ERROR_INVALID_PATH          4325
// #define IDS_ClearCache                  4423
#define IDS_ClearHistory                4424
// #define IDS_SELECTHISTORYFOLDER         4425
#define IDD_NEWSITECERT                 4426
#define IDS_FILETYPES                   4427
#define IDS_FTDLL_FILENAME              4428
// #define IDS_RESTART_EXPLORER            4429
#define IDI_LINKS                       4432
#define IDD_PRINT                       4434
#define IDI_SECURITY                    4440
#define IDI_JAVA                        4441
#define IDI_WARNINGS                    4442
#define IDI_HTMLDOC                     4443
#define IDB_RADIOON                     4445
#define IDI_PRINTER                     4447
#define IDD_LANG                        4448
#define IDD_LANG_ADD                    4449
#define IDD_LANG_CHANGE                 4450
#define IDD_CACHE_EMPTY                 4451
#define IDD_DIALUP                      4452
#define IDD_CONTENT                     4454
#define IDS_DELETE_CERT                 4455
#define IDD_DIALUP_ADVANCED             4456
#define IDD_ACCESSIBILITY               4457
#define IDI_INTERNETCALL                4459
#define IDI_CONGEN                      4460
#define IDI_AUTOCFG                     4461
#define IDS_FONT_SIZE_SMALLEST          4474
#define IDB_BUTTONS                     4474
#define IDS_FONT_SIZE_SMALL             4475
#define IDS_FONT_SIZE_MEDIUM            4476
#define IDS_FONT_SIZE_LARGE             4477
#define IDS_FONT_SIZE_LARGEST           4478
#define IDI_ZONE                        4478
#define IDI_TRUSTED                     4480
#define IDI_UNTRUSTED                   4481
#define IDI_BROWSE                      4482
#define IDI_SEARCH                      4483
#define IDI_SCRIPT                      4485
#define IDI_DOWNLOAD                    4486
#define IDI_INTERNET                    4487
#define IDD_SECSTANDALONE               4488
#define IDI_MESSAGING                   4490
#define IDI_PERSINFO                    4491
#define IDD_PFX_EXPORT                  4493
#define IDD_PFX_IMPORT                  4495
#define IDI_YELLOW                      4496
#define IDI_ACCESS                      4497
#ifdef UNIX
#define IDI_OE                          4498
#define IDI_FONT                        4499
#endif
#define IDS_CLEAR_FORMSUGGEST           4500
#define IDS_CLEAR_FORMPASSWORDS         4501
#define IDS_USER_DEFINED_ERR            4602
#define IDS_LCID_ENG                    4603
#define IDS_USER_DEFINED                4604
#define IDS_MISSING_DLL                 4605
#define IDS_REOPEN_INETCPL              4606
#define IDS_INVALID_PROXY               4607
#define IDS_INVALID_PROXY_TITLE         4608
#define IDS_ICW_NAME                    4609
#define IDI_IMAGE                       4609
#define IDS_NONE                        4610
#define IDS_SIZE_FORMAT                 4612
// #define IDS_NO_AUTOPROXY                4613
#define IDS_SECURITY_WARNING            4614
#define IDS_WARNING                     4615
#define IDS_SECURITY_MINLEVEL           4616
#define IDS_SECURITY_HIGH               4617
#define IDS_SECURITY_MEDIUM             4618
#define IDS_SECURITY_LOW                4619
#define IDS_CERT_NETWORK_CLIENT         4620
#define IDS_CERT_NETWORK_SERVER         4621
#define IDS_CERT_SECURE_EMAIL           4622
#define IDS_CERT_SOFTWARE_PUBLISHING    4623
#define IDS_INVALIDURL                  4624
#define IDS_SECURITY                    4625
#define IDC_ISSUERS_GROUPBOX            4626
// #define IDS_ALWAYS                      4626
#define IDC_INTRANET_GROUPBOX           4627
// #define IDS_NEVER                       4627
// #define IDS_HOVER                       4628
#define IDS_HTTPSREQ                    4629
#define IDS_MAPPINGFAIL                 4630
#define IDS_STYLESHEET_EXT              4631
#define IDS_STYLESHEET_FILTER           4632
#define IDS_FILENOTFOUND                4633
#define IDS_ERROR                       4634
#define IDS_INTERNETOPTIONS             4635
#define IDS_PFX_EXT                     4636
#define IDS_PFX_FILTER                  4637
#define IDS_SITEEXISTS                  4638
#define IDS_INVALIDWILDCARD             4639
#define IDS_CERT_EXPORTOKTEXT           4640
#define IDS_CERT_EXPORTOKTITLE          4641
#define IDS_REVOKEPERMISSIONS           4642
#define IDS_CERT_FILE_INVALID           4643
#define IDC_ENABLE_AUTODIAL             4644
#define IDS_PASSWORDS_NOMATCH           4644
#define IDC_LAN                         4645
//#define IDS_TEMPMOVE                    4645
#define IDS_LAN                         4646
#define IDS_SETTINGS                    4648
#define IDS_LAN_SETTINGS                4649
#define IDS_LAN_SETTINGSPROXY         4650
#define IDI_PHONE                       4651
#define IDI_LAN                         4652
#define IDS_DELETECONNECTOID            4653
//#define IDS_CERT_MANAGER                4654
#define IDS_INVALID_REDIAL_ATTEMPTS     4655
#define IDS_INVALID_REDIAL_WAIT         4656
#define IDS_INVALID_AUTODISCONNECT_TIME 4657
#define IDS_STATIC_ADDSITE              4658
#define IDS_ERROR_MOVE_MSG              4659
#define IDS_ERROR_MOVE_TITLE            4660
#define IDS_ERROR_ARCHITECTURE          4661
#define IDS_ERROR_WRONG_PLACE           4662
//#define IDS_WARNING_USING_SYSTEM_DIR    4663
//#define IDS_ERROR_READONLY              4664
#define IDS_ERROR_STRANGENESS           4665
#define IDS_STATUS_FOLDER_CURRENT       4666
#define IDS_STATUS_FOLDER_NEW           4667
#define IDS_WRITE_WARNING               4668
#define IDS_TEMPLATE_DESC_HI            4669
#define IDS_TEMPLATE_DESC_MED           4670
#define IDS_TEMPLATE_DESC_MEDLOW        4671
#define IDS_TEMPLATE_DESC_LOW           4672
#define IDS_TEMPLATE_DESC_CUSTOM        4673
#define IDS_TEMPLATE_NAME_HI            4674
#define IDS_TEMPLATE_NAME_MED           4675
#define IDS_TEMPLATE_NAME_MEDLOW        4676
#define IDS_TEMPLATE_NAME_LOW           4677
#define IDS_TEMPLATE_NAME_CUSTOM        4678
#define IDS_ERROR_CANT_MOVE_TIF         4679
#define IDS_ERROR_CANT_CONNECT          4680
#define IDS_BRAND_NAME                  4681
#define IDS_RESTRICTED_MESSAGE          4682
#define IDS_RESTRICTED_TITLE            4683
#define IDS_TEMPLATE_NAME_UNDEFINED     4684
#define IDS_COOKIES_WARNING             4685
#define IDS_CLEAR_SSL_CACHE_TEXT        4686
#define IDS_CLEAR_SSL_CACHE_TITLE       4687
//  !!! do not change the order or distribution of IDS_ZONE* resources!
#define IDS_ZONENAME_LOCAL              4688
#define IDS_ZONENAME_INTRANET           4689
#define IDS_ZONENAME_TRUSTED            4690
#define IDS_ZONENAME_INTERNET           4691
#define IDS_ZONENAME_UNTRUSTED          4692
#define IDS_ZONEDESC_LOCAL              4693
#define IDS_ZONEDESC_INTRANET           4694
#define IDS_ZONEDESC_TRUSTED            4695
#define IDS_ZONEDESC_INTERNET           4696
#define IDS_ZONEDESC_UNTRUSTED          4697
//  !!! do not change the order or distribution of IDS_ZONE* resources!


#define IDS_LANG_EN                     4700
#define IDS_LANG_DE                     4701
#define IDS_LANG_JA                     4702
#define IDS_LANG_KO                     4703
#define IDS_LANG_TW                     4704
#define IDS_LANG_CN                     4705
#define IDS_LANG_FR                     4706
#define IDS_LANG_ES                     4707
#define IDS_LANG_BR                     4708
#define IDS_LANG_IT                     4709
#define IDS_LANG_NL                     4710
#define IDS_LANG_SV                     4711
#define IDS_LANG_DA                     4712
#define IDS_LANG_FI                     4713
#define IDS_LANG_HU                     4714
#define IDS_LANG_NO                     4715
#define IDS_LANG_EL                     4716
#define IDS_LANG_PL                     4717
#define IDS_LANG_RU                     4718
#define IDS_LANG_CZ                     4719
#define IDS_LANG_PT                     4720
#define IDS_LANG_TR                     4721
#define IDS_LANG_SK                     4722
#define IDS_LANG_SL                     4723
#define IDS_LANG_AR                     4724
#define IDS_LANG_HE                     4725
#define IDS_LANG_FUTUREUSE              4726
//#define IDS_NO_FONT                     4727
#define IDS_THE_INTERNET                4728
#define IDS_INTERNET_LOC                4729
#define IDC_STATIC_STYLESHEET           4730
#define IDC_UNUSED                      -1
#define IDC_STATIC                      -1
#define BETA1_FLAGS                     65535

//////////////////////////////////////////////
// strings which are referenced by id from  //
// the advanced options registry stuff      //
//////////////////////////////////////////////

#define IDS_ALTTEXT_TEXT                4731
#define IDS_MOVSYSCARET_TEXT            4732
#define IDS_BROWSE_PROCESS_TEXT         4733
#define IDS_FRIEND_URL_TEXT             4734
#define IDS_SMOOTH_SCROLL_TEXT          4735
#define IDS_ENABLE_SUB                  4736
#define IDS_ENABLE_FTPFOLDERS           4737
#define IDS_SM_IMAGE_DITH_TEXT          4738
#define IDS_PL_SOUNDS_TEXT              4739
#define IDS_PL_VID_TEXT                 4740
#define IDS_PL_ANI_TEXT                 4741
#define IDS_SH_PIC_TEXT                 4742
#define IDS_ENABLE_FTP_PASV             4743
#define IDS_MM_TEXT                     4744
#define IDS_BR_TEXT                     4745
#define IDS_ACC_TEXT                    4746
#define IDS_SEC_TEXT                    4747
#define IDS_IEONDESKTOP_TEXT            4748
#define IDS_CACHE_SEC_TEXT              4749
#define IDS_CACHE_FLUSH_TEXT            4750
//#define IDS_PCT1_TEXT                   4751
#define IDS_SSL2_TEXT                   4752
#define IDS_SSL3_TEXT                   4753
#define IDS_TLS1_TEXT                   4754
//#define IDS_FORTEZZA_TEXT               4755
#define IDS_P3_TEXT                     4756
#define IDS_ZONE_CROS_TEXT              4757
#define IDS_SUBMIT_REDIR_TEXT           4758
#define IDS_WARN_INV_CERT_TEXT          4759
#define IDS_SSL_REVOCATION_TEXT         4760
#define IDS_CERT_REV_TEXT               4761
#define IDS_SIG_CHECK_TEXT              4762
#define IDS_PRINT_TEXT                  4769
#define IDS_PR_BACK_TEXT                4770
#define IDS_SEARCH_TEXT                 4771
//#define IDS_AUTOSCAN_TEXT               4772
//#define IDS_URL_FAILS_TEXT              4773
#define IDS_ACTIVEX_TEXT                4774
#define IDS_RUN_ACTIVEX_TEXT            4775
#define IDS_DNLD_SIGN_ACTIVEX_TEXT      4776
#define IDS_DNLD_USIGN_ACTIVEX_TEXT     4777
#define IDS_JAVA_TEXT                   4778
#define IDS_JAVA_PER_TEXT               4779
#define IDS_SCRIPT_TEXT                 4782
#define IDS_SCRIPT_ACTIVEX_TEXT         4783
#define IDS_SCRIPT_SAFE_ACTIVEX_TEXT    4784
#define IDS_CROSS_DOMAIN_DATA_TEXT      4785
#define IDS_ACT_SCR_TEXT                4786
#define IDS_SCR_JAVA_TEXT               4787
#define IDS_AUTH_TEXT                   4788
#define IDS_LOGIN_TEXT                  4790
#define IDS_DNLD_TEXT                   4791
#define IDS_FILE_DNLD_TEXT              4792
#define IDS_FONT_DNLD_TEXT              4793
#define IDS_MISC_TEXT                   4794
#define IDS_DT_TEXT                     4795
#define IDS_DD_TEXT                     4796
#define IDS_SUB_FORM_TEXT               4797
#define IDS_LAUNCH_TEXT                 4798
#define IDS_ALWAYS_TEXT                 4799
#define IDS_AL_SEARCH_TEXT              4800
#define IDS_AL_ASK_TEXT                 4801
#define IDS_NEV_SEARCH_TEXT             4802
#define IDS_ENABLE_TEXT                 4803
#define IDS_PROMPT_TEXT                 4804
#define IDS_DISABLE_TEXT                4805
#define IDS_APPROVED_TEXT               4806
#define IDS_ANON_LOG_TEXT               4807
#define IDS_LOG_PROMPT_TEXT             4808
#define IDS_AUTO_LOG_TEXT               4809
#define IDS_COND_PROMPT_TEXT            4810
#define IDS_LOW_PER_TEXT                4814
#define IDS_MED_PER_TEXT                4815
#define IDS_HIGH_PER_TEXT               4816
#define IDS_CUS_PER_TEXT                4817
#define IDS_DIS_JAVA_TEXT               4818
#define IDS_HTTP_TEXT                   4822
#define IDS_HTTP11_TEXT                 4823
#define IDS_PXY_TEXT                    4824
#define IDS_ULINKS_ALWAYS_TEXT          4825
#define IDS_ULINKS_NEVER_TEXT           4826
#define IDS_ULINKS_HOVER_TEXT           4827
#define IDS_ULINKS_TEXT                 4828
#define IDS_PAGETRANS_TEXT              4829
#define IDS_SOFTDIST_TEXT               4830
#define IDS_SCRDBG_TEXT                 4831
#define IDS_SCRCACHE_TEXT               4832
#define IDS_FE_TEXT                     4833
#define IDS_CHANNELBAR_TEXT             4834
#define IDS_NOTIFYDOWNCOMPLETE_TEXT     4835
#define IDS_IOD_TEXT                    4836
#define IDS_IEUPDATECHECK_TEXT          4837
#define IDS_NSCSINGLEEXPAND_TEXT        4838
#define IDS_UTF8_TEXT                   4839
#define IDS_GOBUTTON_TEXT               4840
#define IDS_AUTOAPPEND_TEXT             4841
#define IDS_AUTOAPPEND_IE4_TEXT         4842
#define IDS_SH_PLACEHOLDERS_TEXT        4843
#define IDS_AUTOSEARCH_TEXT             4844
#define IDS_DISPLAY_AND_GO_TEXT         4845
#define IDS_JUST_GO_TEXT                4846
#define IDS_JUST_DISPLAY_TEXT           4847
#define IDS_NO_SEARCH_TEXT              4848
#define IDC_RESETWEBSETTINGS            4849
#define IDC_RESETWEBSETTINGS_TEXT       4850
#define IDS_LANG_CURRENTUSE             4851
#define IDS_AUTOAPPEND_NT5_TEXT         4852
#define IDS_USERDATA_TEXT               4853
#define IDS_SCRIPTPASTE_TEXT            4854
#define IDS_SUBFRAME_NAVIGATE           4855
#define IDS_FAVINTELLIMENUS             4856
#define IDS_LOGOFF_WARNING              4857
#define IDS_LOGOFF_TITLE                4858
#define IDD_LANG_WARNING                4859
#define IDD_LANG_INFO                   4860
#define IDS_REUSEWINDOWSTEXT            4861
#define IDS_CLIENT_CERT_PROMPT          4862
#define IDS_NEGOTIATE_TEXT              4863
#define IDS_SHELLEXEC_TEXT              4864
#define IDS_EN_MYPICS_TEXT              4865
#define IDS_FORCE_OFFSCREEN_TEXT        4866
#define IDD_CACHE_COOKIES_EMPTY         4869
#define IDS_METAREFRESH_TEXT            4870
#define IDS_AUTOIMAGERESIZE_TEXT        4871
#define IDS_MIXED_CONTENT_TEXT          4872
#define IDS_USE_THEMES_TEXT             4873
#define IDS_USE_BHO_TEXT                4874
#define IDS_WEBJIT_TEXT                 4875
#define IDS_NO_MB_ONLINE_TEXT           4876
#define IDS_SITEALREADYINZONE           4877
#define IDS_ADDSITEREPLACE              4878
#define IDS_WEBOC_SCRIPTABLE            4879
#define IDS_TRUSTDLG_TEXT               4880



// IDS range 5000 - 5299 is for script sample strings
// IDS_FONT_SAMPLE_SCRIPT = IDS_FONT_SAMPLE_DEFAULT + SidScript
//
#define IDS_FONT_SAMPLE_DEFAULT         5000
#define IDS_FONT_SAMPLE_MERGE           5001
#define IDS_FONT_SAMPLE_ASCIISYM        5002
#define IDS_FONT_SAMPLE_ASCIILATIN      5003
#define IDS_FONT_SAMPLE_LATIN           5004
#define IDS_FONT_SAMPLE_GREEK           5005
#define IDS_FONT_SAMPLE_CYRILLIC        5006
#define IDS_FONT_SAMPLE_ARMENIAN        5007
#define IDS_FONT_SAMPLE_HEBREW          5008
#define IDS_FONT_SAMPLE_ARABIC          5009
#define IDS_FONT_SAMPLE_DEVANAGARI      5010
#define IDS_FONT_SAMPLE_BENGALI         5011
#define IDS_FONT_SAMPLE_GURMUKHI        5012
#define IDS_FONT_SAMPLE_GUJARATI        5013
#define IDS_FONT_SAMPLE_ORIYA           5014
#define IDS_FONT_SAMPLE_TAMIL           5015
#define IDS_FONT_SAMPLE_TELUGU          5016
#define IDS_FONT_SAMPLE_KANNADA         5017
#define IDS_FONT_SAMPLE_MALAYALAM       5018
#define IDS_FONT_SAMPLE_THAI            5019
#define IDS_FONT_SAMPLE_LAO             5020
#define IDS_FONT_SAMPLE_TIBETAN         5021
#define IDS_FONT_SAMPLE_GEORGIAN        5022
#define IDS_FONT_SAMPLE_HANGUL          5023
#define IDS_FONT_SAMPLE_KANA            5024
#define IDS_FONT_SAMPLE_BOPOMOFO        5025
#define IDS_FONT_SAMPLE_HAN             5026
#define IDS_FONT_SAMPLE_ETHIOPIC        5027
#define IDS_FONT_SAMPLE_CANSYLLABIC     5028
#define IDS_FONT_SAMPLE_CHEROKEE        5029
#define IDS_FONT_SAMPLE_YI              5030
#define IDS_FONT_SAMPLE_BRAILLE         5031
#define IDS_FONT_SAMPLE_RUNIC           5032
#define IDS_FONT_SAMPLE_OGHAM           5033
#define IDS_FONT_SAMPLE_SINHALA         5034
#define IDS_FONT_SAMPLE_SYRIAC          5035
#define IDS_FONT_SAMPLE_BURMESE         5036
#define IDS_FONT_SAMPLE_KHMER           5037
#define IDS_FONT_SAMPLE_THAANA          5038
#define IDS_FONT_SAMPLE_MONGOLIAN       5039
#define IDS_FONT_SAMPLE_USERDEFINED     5040
// 5041 - 5299 is reserved for new language scripts
#define IDS_FONT_SAMPLE_MAX             5299

#define IDD_PRIVACY                     5300
#define IDC_PRIVACY_IMPORT              5301
#define IDI_PRIV                        5302
#define IDI_PRIV_IMPORT                 5303
#define IDS_PRIVACY_LEVEL_NO_COOKIE     5304
#define IDS_PRIVACY_LEVEL0              5305
#define IDS_PRIVACY_LEVEL1              5306
#define IDS_PRIVACY_LEVEL2              5307
#define IDS_PRIVACY_LEVEL3              5308
#define IDS_PRIVACY_LEVEL4              5309
#define IDS_PRIVACY_LEVEL5              5310
#define IDS_PRIVACY_DESC_NO_COOKIE      5311
#define IDS_PRIVACY_DESC0               5312
#define IDS_PRIVACY_DESC1               5313
#define IDS_PRIVACY_DESC2               5314
#define IDS_PRIVACY_DESC3               5315
#define IDS_PRIVACY_DESC4               5316
#define IDS_PRIVACY_DESC5               5317
#define IDC_PRIVACY_DEFAULT             5318
#define IDC_PRIVACY_ADVANCED            5319

#define IDD_PRIVACY_ADVANCED            5320
#define IDC_USE_ADVANCED                5321
#define IDC_FIRST_ACCEPT                5322
#define IDC_FIRST_DENY                  5323
#define IDC_FIRST_PROMPT                5324
#define IDC_THIRD_ACCEPT                5325
#define IDC_THIRD_DENY                  5326
#define IDC_THIRD_PROMPT                5327
#define IDC_SESSION_OVERRIDE            5328
#define IDC_PRIVACY_EDIT                5329
#define IDC_PRIVACY_CLEAR               5330
#define IDC_TX_FIRST                    5331
#define IDC_TX_THIRD                    5332
#define IDC_LEVEL                       5333
#define IDC_LEVEL_SLIDER                5334
#define IDC_PRIVACY_ICON                5335

#define IDD_PRIVACY_PERSITE             5371
//#define IDC_PRIVACYPS_SITEACCEPT        5372
//#define IDC_PRIVACYPS_SITEREJECT        5373
#define IDC_PRIVACYPS_SITETOSET         5374
#define IDC_PRIVACYPS_ACCEPTBTN         5375
#define IDC_PRIVACYPS_REJECTBTN         5376
#define IDC_PRIVACYPS_REMOVEBTN         5377
#define IDC_PRIVACYPS_LISTBOX           5378
#define IDC_PRIVACYPS_REMOVEALLBTN      5379
#define IDS_PRIVACYPS_ERRORTTL          5380
#define IDS_PRIVACYPS_ERRORTXT          5381
#define IDR_PERSITE_CONTEXT_MENU        5382
#define IDM_PRIVACYPS_CTXM_ACCEPT       5383
#define IDM_PRIVACYPS_CTXM_REJECT       5384
#define IDM_PRIVACYPS_CTXM_DELETE       5385
#define IDS_PRIVACYPS_COLSITE           5386
#define IDS_PRIVACYPS_COLSET            5387
#define IDS_PRIVACYPS_ACCEPT            5388
#define IDS_PRIVACYPS_REJECT            5389
#define IDI_PRIVACY_XP                  5390


#define IDS_PRIVACYIMPORT_TITLE                     5351
#define IDS_PRIVACYIMPORT_SUCCESS                   5352
#define IDS_PRIVACYIMPORT_FAILURE                   5355
#define IDS_PRIVACYIMPORT_FILEEXPR                  5356

#define IDS_PRIVACY_SLIDERCOMMANDSLIDE  5360
#define IDS_PRIVACY_SLIDERCOMMANDDEF    5361
#define IDC_PRIVACY_SLIDERCOMMAND       5362
                                           
#define IDS_CANNOT_MOVE_FROM_RESTRICTED     5363

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NO_MFC                     1
#define _APS_NEXT_RESOURCE_VALUE        4500
#define _APS_NEXT_COMMAND_VALUE         40001
#define _APS_NEXT_CONTROL_VALUE         1567
#define _APS_NEXT_SYMED_VALUE           5000
#endif
#endif

// Following IDs are used by UNIX only
//
#ifdef UNIX

#define IDD_ASSOCIATIONS                0x4000
#define IDC_DOC_LIST                    0x4001
#define IDC_DOC_TYPE                    0x4002
#define IDC_DOC_EXTS                    0x4003
#define IDC_DOC_MIME                    0x4004
#define IDC_DOC_CMND                    0x4005
#define IDC_DOC_DESC                    0x4006
#define IDC_ASSOC_ADD                   0x4007
#define IDC_ASSOC_DEL                   0x4008
#define IDC_ASSOC_UPD                   0x4009
#define IDC_ASSOC_EDIT                  0x4010
#define IDC_BROWSE                      0x4011
#define IDS_ERROR_EXTS_ALREADY_EXISTS   0x4020
#define IDS_ERROR_DESC_ALREADY_EXISTS   0x4021
#define IDS_ERROR_NOT_AN_EXT            0x4022
#define IDS_ERROR_MISSING_EXTS          0x4023
#define IDS_ERROR_MISSING_DESC          0x4024
#define IDS_ERROR_MISSING_CMND          0x4025
#define IDS_ERROR_INVALID_MIME          0x4026
#define IDS_ERROR_ALIAS_ALREADY_EXISTS  0x4027
#define IDS_TITLE_ALIASEDIT             0x4028
#define IDS_TITLE_ALIASADD              0x4029

#define IDC_ALIAS_LIST                  0x4030
#define IDC_ALIAS_ADD                   0x4031
#define IDC_ALIAS_EDIT                  0x4032
#define IDC_ALIAS_DEL                   0x4033
#define IDD_ALIASDLG                    0x4034
#define IDS_FIRSTCOLUMN                 0x4050

#define IDD_ALIAS_EDIT                  0x4060
#define IDC_URL_EDIT                    0x4062

#define IDC_FONTS_PROP_GROUPBOX         0x4070
#define IDC_FONTS_FIXED_GROUPBOX        0x4071
#define IDC_FONTS_UPDATE_GROUPBOX       0x4072
#define IDC_FONTS_UPDATE_BUTTON         0x4073
#define IDC_FONTS_UPDATE_TEXT           0x4074

#define IDS_READONLY_CACHE_TEXT         0x4081
#define IDC_READONLY_CACHE_WARNING      0x4082
#define IDC_TEMP_INTERNET_TEXT          0x4083

#define IDD_ENTER_ASSOC                 0x4090

#define IDD_FONTUPD_PROG                0x40A0
#define IDC_FONTUPD_PROG                0x40A1
#define IDC_FONTUPD_CANCEL              0x40A2
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\unixstuff.cpp ===
#ifdef unix

#include <tchar.h>
#include "inetcplp.h"
#include <shsemip.h>
#include <mluisupp.h>

#include <mainwin.h>  // _MAX_FNAME
#include <unistd.h>

#define UNIX_EDITOR_ENV TEXT("EDITOR")
#define UNIX_EDITOR_REG TEXT("command")

//
// Private Functions and Structures
//
BOOL ProgramsDlgInit( HWND hDlg);

typedef struct {
    HWND hDlg;          // dialog windows handle
    HWND hwndMail;      // Mail dropdown
    HWND hwndNews;      // News dropdown
    HWND hwndCalendar;  // Calendar dropdown
    HWND hwndContact;   // Contact dropdown
    HWND hwndCall;      // Internet call dropdown

    BOOL bAssociationCheck;     // Is IE the default browser?

    int  iMail;
    int  iNews;
    int  iCalendar;
    int  iContact;
    int  iCall; 
    BOOL fChanged;
} PROGRAMSPAGE, *LPPROGRAMSPAGE;

#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))

#ifdef WALLET    
typedef int (*PFN_DISPLAYWALLETPAYDIALOG_PROC)(HWND, HINSTANCE, LPTSTR, int);
typedef int (*PFN_DISPLAYWALLETADDRDIALOG_PROC)(HWND, HINSTANCE, LPTSTR, int);
#endif

void FindEditClient(LPTSTR szProtocol, HWND hwndDlg, int nIDDlgItem, LPTSTR szPath)
{
    TCHAR    szCurrent[MAX_PATH];
    TCHAR    szMsg[MAX_PATH];
    HKEY    hkey;
    DWORD   dw;
    HWND    hwnd;

    // get the name of the new client
    if (hwnd = GetDlgItem(hwndDlg, nIDDlgItem))
    {
        Edit_GetText(hwnd, szCurrent, MAX_PATH);
        if (RegCreateKeyEx(HKEY_CURRENT_USER, szPath,
            0, NULL, 0, KEY_READ|KEY_WRITE, NULL, &hkey, &dw) == ERROR_SUCCESS)
        {        
            DWORD   cb;
    
            cb = (lstrlen(szCurrent)+1)*sizeof(TCHAR);
            RegSetValueEx(hkey, REGSTR_PATH_CURRENT, NULL, REG_SZ, (LPBYTE)szCurrent, cb);
            // close the keys
            RegCloseKey(hkey);        
        
        }   // if RegCreateKeyEx()
    }
}   // FindEditClient()

BOOL  FoundProgram(HWND hwndDlg, int nIDDlgItem)
{
    TCHAR   szCurrent[MAX_PATH];
    CHAR    szCurrentA[MAX_PATH]; 
    TCHAR   szMsg[MAX_PATH];
    HWND    hwnd;
    DWORD   dwCurChar;
	BOOL    bPath = FALSE;

    // get the name of the new client
    if (hwnd = GetDlgItem(hwndDlg, nIDDlgItem))
    {
        if (!IsWindowEnabled(hwnd))
            return TRUE;
        Edit_GetText(hwnd, szCurrent, MAX_PATH);
        for (dwCurChar = 0; dwCurChar < lstrlen(szCurrent); dwCurChar++)
        {
            if (szCurrent[dwCurChar] == TEXT('/'))
            {
                bPath = TRUE;
                break;
            }
        }
        if (!bPath)  // if it's file name with no path we assume it's in the user's PATH
            return TRUE;
#ifdef UNICODE
	WideCharToMultiByte(CP_ACP, 0, szCurrent, -1, szCurrentA, MAX_PATH, NULL, NULL);
        if (access(szCurrentA, X_OK) == 0)
#else
        if (access(szCurrent, X_OK) == 0)
#endif
            return TRUE;
    }

    return FALSE;
}   // FoundProgram()


HRESULT ViewScript(TCHAR *lpszPath)
{
    HRESULT         hr = S_OK;

    TCHAR           tszPath[MAX_PATH];
    TCHAR           tszCommand[INTERNET_MAX_URL_LENGTH];
    TCHAR           tszExpandedCommand[INTERNET_MAX_URL_LENGTH];
    UINT            nCommandSize;
    int             i;
    HKEY    hkey;
    DWORD   dw;
    TCHAR *pchPos;
    BOOL bMailed;
    STARTUPINFO stInfo;

    _tcscpy(tszPath, lpszPath);

    hr = RegCreateKeyEx(HKEY_CURRENT_USER, REGSTR_PATH_VSOURCECLIENTS, 0, NULL, 0, KEY_READ, NULL, &hkey, &dw);
    if (hr != ERROR_SUCCESS)
        goto Cleanup;
    dw = INTERNET_MAX_URL_LENGTH;
    hr = RegQueryValueEx(hkey, REGSTR_PATH_CURRENT, NULL, NULL, (LPBYTE)tszCommand, &dw);
    if (hr != ERROR_SUCCESS)
    {
        RegCloseKey(hkey);
        goto Cleanup;
    }

    dw = ExpandEnvironmentStrings(tszCommand, tszExpandedCommand, INTERNET_MAX_URL_LENGTH);
    if (!dw)
     {
        _tcscpy(tszExpandedCommand, tszCommand);
     }
    _tcscat(tszCommand, tszExpandedCommand);
    for (i = _tcslen(tszCommand); i > 0; i--)
	if (tszCommand[i] == TEXT('/'))
	{
	    tszCommand[i] = TEXT('\0');
	    break;
	}
    _tcscat(tszCommand, TEXT(" "));
    _tcscat(tszCommand, tszPath);

    memset(&stInfo, 0, sizeof(stInfo));
    stInfo.cb = sizeof(stInfo);
    stInfo.wShowWindow= SW_SHOWNORMAL;
    bMailed = CreateProcess(tszExpandedCommand, tszCommand, NULL, NULL, TRUE, CREATE_NEW_CONSOLE, NULL, NULL, &stInfo, NULL);
 
Cleanup:

    return hr;
}

BOOL EditScript(HKEY hkeyProtocol)
{
    HKEY hKey;
    TCHAR tszCurrent[MAX_PATH];
    TCHAR tszScript[MAX_PATH];
    DWORD dw;

    dw = MAX_PATH;
    if (RegQueryValueEx(hkeyProtocol, REGSTR_PATH_CURRENT, NULL, NULL, (LPBYTE)tszCurrent, &dw)
        != ERROR_SUCCESS)
    {
        return FALSE;
    }    
    ExpandEnvironmentStrings(tszCurrent, tszScript, INTERNET_MAX_URL_LENGTH);

    return ViewScript(tszScript);
}

BOOL FindScript(HWND hwndLabel, HKEY hkeyProtocol)
{
    TCHAR tszCurrent[2*MAX_PATH + 1 ];
    TCHAR tszScript[2*MAX_PATH + 1];
    TCHAR tszFilter[5];
    DWORD dw;
    OPENFILENAME ofn;

    dw = MAX_PATH;
    if (RegQueryValueEx(hkeyProtocol, REGSTR_PATH_CURRENT, NULL, NULL, (LPBYTE)tszCurrent, &dw)
        != ERROR_SUCCESS)
    {
        return FALSE;
    }    

    tszCurrent[MAX_PATH] = TEXT('\0');

    ExpandEnvironmentStrings(tszCurrent, tszScript, INTERNET_MAX_URL_LENGTH);
    _tcscpy(tszCurrent, tszScript);

    BOOL bDirFound = FALSE;
    int  i;
    for (i = _tcslen(tszCurrent) - 1; i>=0; i--)
        if (tszCurrent[i] == TEXT('/') )
	{
	    tszCurrent[i] = TEXT('\0');
        bDirFound = TRUE;
	    break;
	}

    if( !bDirFound )
        tszCurrent[0] = TEXT('\0');
    else
        _tcscpy( tszScript, tszCurrent+i+1 );

    tszScript[ _MAX_FNAME - 1 ] = TEXT('\0');

    memset((void*)&tszFilter, 0, 5 * sizeof(TCHAR));
    tszFilter[0] = TEXT('*');
    tszFilter[2] = TEXT('*');

    memset((void*)&ofn, 0, sizeof(ofn));
    ofn.lpstrFilter = tszFilter;
    ofn.lStructSize = sizeof(ofn);
    ofn.hwndOwner = hwndLabel;
    ofn.lpstrFile = tszScript;
    ofn.nMaxFile = MAX_PATH;
    ofn.lpstrInitialDir = tszCurrent;
    ofn.Flags = OFN_HIDEREADONLY;

    if (GetOpenFileName(&ofn))
    {
        SendMessage(hwndLabel, EM_SETSEL, 0, -1);
        SendMessage(hwndLabel, EM_REPLACESEL, 0, (LPARAM)tszScript);
    }    

    return TRUE;
}
#endif


// Function used to determine if the given file exists in the directory
// that the current process is running from
BOOL LocalFileCheck(LPCTSTR aszFileName)
{
    // Determinate the base path of the current process binary
    TCHAR szPath[MAX_PATH];
    GetModuleFileName(NULL, szPath, sizeof(szPath)/sizeof(szPath[0]));

    // Find the final element separator if there is one
#ifdef UNICODE
    LPTSTR szPathName = _tcsrchr(szPath, FILENAME_SEPARATOR_W);
#else
    LPTSTR szPathName = _tcsrchr(szPath, FILENAME_SEPARATOR);
#endif
    DWORD dwPathLength;
    if (szPathName)
    {
        szPathName[1] = TEXT('\0');

        dwPathLength = szPathName-szPath+1;
    }
    else
    {
	dwPathLength = _tcslen(szPath)+1;

#ifdef UNICODE
        _tcsncat(szPath, FILENAME_SEPARATOR_STR_W, sizeof(szPath)/
#else
        _tcsncat(szPath, FILENAME_SEPARATOR_STR, sizeof(szPath)/
#endif
            sizeof(szPath[0])-dwPathLength);
    }

    // Append the target file name to the base path (make sure
    // the new string can't overflow the buffer)
    _tcsncat(szPath, aszFileName, sizeof(szPath)/sizeof(szPath[0])-
        dwPathLength-1);

    // Look for the given file without trying to open it
    WIN32_FIND_DATA findData;
    HANDLE hFind = FindFirstFile(szPath, &findData);
    if (hFind == INVALID_HANDLE_VALUE)
    {
        return TRUE;
    }
    else
    {
        FindClose(hFind);

        return(FALSE);
    }
}

UINT RegPopulateEditText(HWND hwndCB, HKEY hkeyProtocol)
{
    TCHAR           szCurrent           [MAX_PATH];
    TCHAR           szExpanded          [MAX_PATH];
    FILETIME        ftLastWriteTime;

    DWORD   cb;

    cb = sizeof(szCurrent);
    if (RegQueryValueEx(hkeyProtocol, REGSTR_PATH_CURRENT, NULL, NULL, (LPBYTE)szCurrent, &cb)
        != ERROR_SUCCESS)
    {
        szCurrent[0]=TEXT('\0');
    }

    ExpandEnvironmentStrings(szCurrent, szExpanded, MAX_PATH);
    SendMessage(hwndCB, EM_REPLACESEL, (WPARAM) 0, (LPARAM) szExpanded);

    return 0;
}   // RegPopulateEditText()

static const CHAR szCacheLockStatus[] = "unixGetWininetCacheLockStatus";
static const TCHAR szCacheLockStatusDll[] = TEXT("WININET.DLL");
typedef void (WINAPI *LPCACHELOCKSTATUS)(BOOL *pBoolReadOnly, TCHAR **ppszLockingHost);

BOOL IsCacheReadOnly()
{
     HINSTANCE hCacheLockStatusDll = NULL;
     LPCACHELOCKSTATUS fnCacheLockStatus;
     BOOL bReadOnlyCacheLockStatus;

     hCacheLockStatusDll = LoadLibrary(szCacheLockStatusDll); 
     if (hCacheLockStatusDll)
     {
        fnCacheLockStatus = (LPCACHELOCKSTATUS)GetProcAddress(hCacheLockStatusDll, szCacheLockStatus); 
        FreeLibrary(hCacheLockStatusDll);
     }

     if (fnCacheLockStatus)
        fnCacheLockStatus(&bReadOnlyCacheLockStatus, NULL);

     return bReadOnlyCacheLockStatus;
}

BOOL CALLBACK FontUpdDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HWND hProg = GetDlgItem(hDlg, IDC_FONTUPD_PROG);
    UINT nTimer = 1;

    switch (uMsg)
    {
       case WM_INITDIALOG:
	    HCURSOR hOldCursor = NULL;
	    HCURSOR hNewCursor = NULL;

	    hNewCursor = LoadCursor(NULL, IDC_WAIT);
	    if (hNewCursor) 
	        hOldCursor = SetCursor(hNewCursor);
	    SendMessage(hProg, PBM_SETRANGE, 0, MAKELPARAM(0, FONT_UPDATE_TICK));
	    SendMessage(hProg, PBM_SETSTEP, 1, 0);
	    SetTimer(hDlg, nTimer, 600, NULL);
	    break;
       case WM_TIMER:
	    KillTimer(hDlg, nTimer);
	    MwFontCacheUpdate(TRUE, FontUpdateFeedBack, FONT_UPDATE_TICK, (void*)hDlg);
	    break;
       case WM_CLOSE:
            EndDialog(hDlg, 0);
       case PBM_SETRANGE:
	    SendMessage(hProg, PBM_SETRANGE, wParam, lParam);
            break;
        case PBM_SETSTEP:
	    SendMessage(hProg, PBM_SETSTEP, wParam, lParam);
            break;
        case PBM_STEPIT:
	    SendMessage(hProg, PBM_STEPIT, wParam, lParam);
            break;
        default:
            return FALSE;
    }
    return TRUE;
}


void  FontUpdateFeedBack(int nTick, void *pvParam) 
{
    HWND hDlg = (HWND)pvParam;
    MSG msg;
    int iMsg = 0;

    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) && iMsg++ < 20)
    {
	TranslateMessage(&msg);
	DispatchMessage(&msg);
    } 
    if (hDlg)
        SendMessage(hDlg, PBM_STEPIT, 0, 0);    
    if (nTick == FONT_UPDATE_TICK - 1)
        SendMessage(hDlg, WM_CLOSE, 0, 0);        
}


VOID DrawXFontButton(HWND hDlg, LPDRAWITEMSTRUCT lpdis)
{
    SIZE thin   = { GetSystemMetrics(SM_CXBORDER), GetSystemMetrics(SM_CYBORDER) };
    RECT rc     = lpdis->rcItem;
    HDC hdc     = lpdis->hDC;
    BOOL bFocus = ((lpdis->itemState & ODS_FOCUS) && !(lpdis->itemState & ODS_DISABLED));

    if (!thin.cx) thin.cx = 1;
    if (!thin.cy) thin.cy = 1;

    FillRect(hdc, &rc, GetSysColorBrush(COLOR_3DFACE));

    //Draw Icon
    HICON hXFIcon;
    if (hXFIcon = LoadIcon(ghInstance, MAKEINTRESOURCE(IDI_FONT)))
    {
        DrawIcon(hdc, (rc.right + rc.left) / 2 - 8, (rc.top + rc.bottom / 2) / 2 - 8, hXFIcon);
    }

    // Draw any caption
    TCHAR szCaption[80];
    int cyText = (rc.bottom + rc.top)/2;

    if (GetWindowText(lpdis->hwndItem, szCaption, ARRAYSIZE(szCaption)))
    {
        COLORREF crText;

        RECT rcText = rc;
        rcText.top = cyText;

        int nOldMode = SetBkMode(hdc, TRANSPARENT);

        if (lpdis->itemState & ODS_DISABLED)
        {
            // Draw disabled text using the embossed look
            crText = SetTextColor(hdc, GetSysColor(COLOR_BTNHIGHLIGHT));
            RECT rcOffset = rcText;
            OffsetRect(&rcOffset, 1, 1);
            DrawText(hdc, szCaption, -1, &rcOffset, DT_VCENTER|DT_SINGLELINE);
            SetTextColor(hdc, GetSysColor(COLOR_BTNSHADOW));
        }
        else
        {
            crText = SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));
        }
        DrawText(hdc, szCaption, -1, &rcText, DT_VCENTER|DT_CENTER|DT_SINGLELINE);
        SetTextColor(hdc, crText);
        SetBkMode(hdc, nOldMode);
    }

    // Draw the button portion
    if (lpdis->itemState & ODS_SELECTED)
    {
        DrawEdge(hdc, &rc, EDGE_SUNKEN, BF_RECT | BF_ADJUST);
        OffsetRect(&rc, 1, 1);
    }
    else
    {
        DrawEdge(hdc, &rc, EDGE_RAISED, BF_RECT | BF_ADJUST);
    }

    if (bFocus)
    {
        InflateRect(&rc, -thin.cx, -thin.cy);
        DrawFocusRect(hdc, &rc);
        InflateRect(&rc, thin.cx, thin.cy);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\dll\makefile.inc ===
..\inetcpl.rc : ..\inetcpld.rc $(SELFREGNAME)

!include $(CCSHELL_DIR)\makefile.inc
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\main\applet.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    applet.h

Abstract:

    This module contains the main header information for this project.

Revision History:

--*/



#ifndef _APPLETS_H
#define _APPLETS_H



//
//  The prototype for an applet function is:
//    int Applet(HINSTANCE instance, HWND parent, LPCTSTR cmdline);
//
//  instance - The instance handle of the control panel containing the applet.
//
//  parent   - Contains the handle of a parent window for the applet (if any).
//
//  cmdline  - Points to the command line for the applet (if available).
//             If the applet was launched without a command line,
//             'cmdline' contains NULL.
//

typedef int (*PFNAPPLET)(HINSTANCE, HWND, LPCTSTR);


//
//  The return value specifies any further action that must be taken:
//      APPLET_RESTART -- Windows must be restarted
//      APPLET_REBOOT  -- the machine must be rebooted
//      all other values are ignored
//

#define APPLET_RESTART            0x8
#define APPLET_REBOOT             (APPLET_RESTART | 0x4)


//
//  The prototype for an applet query functions is:
//      LRESULT AppletQuery(UINT Message);
//

typedef LRESULT (*PFNAPPLETQUERY)(HWND, UINT);

#define APPLET_QUERY_EXISTS       0   //  BOOL result
#define APPLET_QUERY_GETICON      1   //  HICON result



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\inetcpl\webjitres.h ===
/*
 *
 *  IMPORTANT IMPORTANT IMPORTANT
 *
 */
//inetcore\urlmon\download\webjitres.h and shell\cpls\inetcpl\webjitres.h need to be IDENTICAL.

#ifndef IDC_STATIC
#define IDC_STATIC                      -1
#endif
#define IDC_PROGRESS1                   20000
#define IDC_CHECK1                      20001
#define IDC_TEXT                        20002
#define IDB_BITMAP1                     20003
#define IDC_ICON1                       20004
#define IDC_REMAINING_SIZE              20005
#define IDC_REMAINING_TIME              20006

#define IDS_DOWNLOAD_MSG                20201
#define IDS_ERROROCCURED                20202
#define IDS_JAVAVMJIT                   20203
#define IDS_MEDIAPLAYER                 20204

#define IDS_MISSINGCOMPONENTNAME        20301
#define IDS_REINSTALL                   20302
#define IDS_DIALOGERROR                 20303
#define IDS_DIALOGERROR2                20304
#define IDS_WARNINGINSTALLING           20305
#define IDS_ALTWARNINGDOWNLOAD          20306
#define IDS_ALTLANGUAGEDOWNLOAD         20307
#define IDS_DLFAIL                      20308
#define IDS_INSTALLFAIL                 20309
#define IDS_SERVERERROR                 20310
#define IDS_UNKNOWNERROR                20311
#define IDS_PRODUCTUPDATES              20312
#define IDS_NOTCONNECTED                20313
#define IDS_CERTREFUSE                  20314
#define IDS_IBUSY                       20315
#define IDS_SECURITYHIGH                20316
#define IDS_SECURITYHIGH1               20317
#define IDS_SECURITYHIGH2               20318
#define IDS_SECURITYHIGH3               20319
#define IDS_OFFLINEALERT                20320
#define IDS_OFFLINEALERT2               20321
#define IDS_ADMINRIGHTS                 20322
#define IDS_PLATFORMNOT                 20323
#define IDS_INTERNAL                    20324
#define IDS_SETUP                       20325
#define IDS_PROCESS                     20326
#define IDS_KILOBYTES_TEXT              20327
#define IDS_MEGABYTE_TEXT               20328
#define IDS_MINUTES_TEXT                20329
#define IDS_LessThanAMinute_TEXT        20330
#define IDS_hr1_TEXT                    20331
#define IDS_hrs_TEXT                    20332
#define IDS_SIZE                        20333
#define IDS_TIME                        20334
#define IDS_DOWNLOADING                 20335
#define IDS_INSTALLING                  20336
#define IDS_CHECKTRUST                  20337
#define IDS_ERRORTITLE                  20338
#define IDS_WEBJITHELPFILE              20339

#define IDD_WEBJIT                      20440

#define IDDOWNLOAD                      20441
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\main\keybdspd.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    keybdspd.c

Abstract:

    This module contains the main routines for the Keyboard applet's
    Speed property page.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "rc.h"
#include "util.h"
#include <regstr.h>
#include <help.h>




//
//  Constant Declarations.
//

#define KSPEED_MIN      0
#define KSPEED_MAX      31
#define KSPEED_RANGE    (KSPEED_MAX - KSPEED_MIN + 1)

//
//  For keyboard delay control.
//
#define KDELAY_MIN      0
#define KDELAY_MAX      3
#define KDELAY_RANGE    (KDELAY_MAX - KDELAY_MIN + 1)

//
//  For control of the cursor blink rate.
//
//  timer ID
#define BLINK           1000
//  Note that 1300 is converted to -1, which means "off". The max value
//  that we set is actually 1200.
#define CURSORMIN       200
#define CURSORMAX       1300
#define CURSORRANGE     (CURSORMAX - CURSORMIN)

static ARROWVSCROLL avsDelay =  { -1,
                                  1,
                                  -KDELAY_RANGE / 4,
                                  KDELAY_RANGE / 4,
                                  KDELAY_MAX,
                                  KDELAY_MIN
                                };
static ARROWVSCROLL avsSpeed  = { -1,
                                  1,
                                  -KSPEED_RANGE / 4,
                                  KSPEED_RANGE / 4,
                                  KSPEED_MAX,
                                  KSPEED_MIN
                                };
static ARROWVSCROLL avsCursor = { -1,                   // lineup
                                  1,                    // linedown
                                  -CURSORRANGE / 400,   // pageup
                                  CURSORRANGE / 400,    // pagedown
                                  CURSORRANGE / 100,    // top
                                  0,                    // bottom
                                  0,                    // thumbpos
                                  0                     // thumbtrack
                                };




//
//  Context Help Ids.
//

static DWORD aKbdHelpIds[] =
{
    KDELAY_GROUP,        IDH_COMM_GROUPBOX,
    KBLINK_GROUP,        IDH_COMM_GROUPBOX,
    KDELAY_SCROLL,       IDH_DLGKEY_REPDEL,
    KSPEED_SCROLL,       IDH_DLGKEY_REPSPEED,
    KREPEAT_EDIT,        IDH_DLGKEY_REPTEST,
    KBLINK_EDIT,         IDH_DLGKEY_CURSOR_GRAPHIC,
    KCURSOR_BLINK,       IDH_DLGKEY_CURSOR_GRAPHIC,
    KCURSOR_SCROLL,      IDH_DLGKEY_CURSBLNK,

    0, 0
};



//
//  Global Variables.
//

//
//  FEATURE - these should be moved into the KeyboardSpdStr structure
//
static UINT uOriginalDelay, uOriginalSpeed;
static UINT uBlinkTime;
static UINT uNewBlinkTime;
static BOOL bKbNeedsReset = FALSE;
static HWND hwndCursorScroll;
static HWND hwndCursorBlink;
static BOOL fBlink = TRUE;



//
//  Typedef Declarations.
//

typedef struct tag_KeyboardSpdStr
{
    HWND hDlg;        // HWND hKeyboardSpdDlg;

} KEYBOARDSPDSTR, *PKEYBOARDSPDSTR;


//
// Helper functions to handle the caret "off" setting
//
void _SetCaretBlinkTime(UINT uInterval)
{
    if (uInterval != uNewBlinkTime)
    {
        uNewBlinkTime = uInterval;

        if (CURSORMAX == uInterval)
            uInterval = (UINT)-1;   // blink is "off"

        SetCaretBlinkTime(uInterval);
    }
}

void _SetTimer(HWND hDlg, UINT uInterval)
{
    if (uInterval < CURSORMAX)
    {
        SetTimer(hDlg, BLINK, uInterval, NULL);
    }
    else
    {
        // Caret blink is "off".
        // Kill the timer and show our pseudo-caret.
        KillTimer(hDlg, BLINK);
        fBlink = TRUE;
        ShowWindow(hwndCursorBlink, SW_SHOW);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  KeyboardSpeedSupported
//
////////////////////////////////////////////////////////////////////////////

BOOL KeyboardSpeedSupported()
{
#ifdef WINNT
    //
    // FEATURE  For Windows NT we assume that all keyboards can
    //         handle the SetSpeed - we might be able to do a
    //         better check in the future if KEYBOARD.DLL is available.
    //
    return (TRUE);
#else
    HANDLE hKeyboardModule = LoadLibrary16(TEXT("KEYBOARD"));
    BOOL bCanDorkWithTheSpeed = FALSE;

    if (hKeyboardModule)
    {
        if (GetProcAddress16(hKeyboardModule, TEXT("SetSpeed")))
        {
            bCanDorkWithTheSpeed = TRUE;
        }

        FreeLibrary16(hKeyboardModule);
    }

    return (bCanDorkWithTheSpeed);
#endif
}


////////////////////////////////////////////////////////////////////////////
//
//  SetDelayAndSpeed
//
////////////////////////////////////////////////////////////////////////////

void SetDelayAndSpeed(
    HWND hDlg,
    int nDelay,
    int nSpeed,
    UINT uFlags)
{
    if (nDelay < 0)
    {
        nDelay = (int)SendDlgItemMessage( hDlg,
                                          KDELAY_SCROLL,
                                          TBM_GETPOS,
                                          0,
                                          0L );
    }

    if (nSpeed < 0)
    {
        nSpeed = (int)SendDlgItemMessage( hDlg,
                                          KSPEED_SCROLL,
                                          TBM_GETPOS,
                                          0,
                                          0L );
    }

    //
    //  Only send the WININICHANGE once.
    //
    SystemParametersInfo( SPI_SETKEYBOARDSPEED,
                          nSpeed,
                          0,
                          uFlags & ~SPIF_SENDWININICHANGE );
    SystemParametersInfo( SPI_SETKEYBOARDDELAY,
                          KDELAY_MAX - nDelay + KDELAY_MIN,
                          0L,
                          uFlags );
}


////////////////////////////////////////////////////////////////////////////
//
//  DestroyKeyboardSpdDlg
//
////////////////////////////////////////////////////////////////////////////

void DestroyKeyboardSpdDlg(
    PKEYBOARDSPDSTR pKstr)
{
    HWND hDlg;

    if (pKstr)
    {
        hDlg = pKstr->hDlg;

        LocalFree((HGLOBAL)pKstr);

        SetWindowLongPtr(hDlg, DWLP_USER, 0);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetSpeedGlobals
//
//  Get Repeat Speed, Delay, and Blink Time.
//
////////////////////////////////////////////////////////////////////////////

VOID GetSpeedGlobals()
{
    SystemParametersInfo(SPI_GETKEYBOARDSPEED, 0, &uOriginalSpeed, FALSE);
    SystemParametersInfo(SPI_GETKEYBOARDDELAY, 0, &uOriginalDelay, FALSE);

    uOriginalDelay = KDELAY_MAX - uOriginalDelay + KDELAY_MIN;

    // -1 means "off"
    uBlinkTime = GetCaretBlinkTime();
    if ((UINT)-1 == uBlinkTime || uBlinkTime > CURSORMAX)
        uBlinkTime = CURSORMAX;
    uNewBlinkTime = uBlinkTime;
}


////////////////////////////////////////////////////////////////////////////
//
//  InitKeyboardSpdDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL InitKeyboardSpdDlg(
    HWND hDlg)
{
    HourGlass(TRUE);

    if (!KeyboardSpeedSupported())
    {
        MyMessageBox( hDlg,
                      IDS_KEYBD_NOSETSPEED,
                      IDS_KEYBD_TITLE,
                      MB_OK | MB_ICONINFORMATION );

        HourGlass(FALSE);
        return (FALSE);
    }

    //
    //  Get Repeat Speed, Delay, and Blink Time.
    //
    GetSpeedGlobals();

    TrackInit(GetDlgItem(hDlg, KSPEED_SCROLL), uOriginalSpeed, &avsSpeed);
    TrackInit(GetDlgItem(hDlg, KDELAY_SCROLL), uOriginalDelay, &avsDelay);
    TrackInit(GetDlgItem(hDlg, KCURSOR_SCROLL), (CURSORMAX - uBlinkTime) / 100, &avsCursor );

    hwndCursorScroll = GetDlgItem(hDlg, KCURSOR_SCROLL);
    hwndCursorBlink = GetDlgItem(hDlg, KCURSOR_BLINK);

    _SetTimer(hDlg, uBlinkTime);

    HourGlass(FALSE);
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  KeyboardSpdDlg
//
////////////////////////////////////////////////////////////////////////////

static const TCHAR c_szUserDesktopKey[] = REGSTR_PATH_DESKTOP;
static const TCHAR c_szCursorBlink[] = TEXT("CursorBlinkRate");

INT_PTR CALLBACK KeyboardSpdDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PKEYBOARDSPDSTR pKstr = (PKEYBOARDSPDSTR)GetWindowLongPtr(hDlg, DWLP_USER);
    
    switch (message)
    {
        case ( WM_INITDIALOG ) :
        {
            bKbNeedsReset = FALSE;
            return (InitKeyboardSpdDlg(hDlg));
            break;
        }
        case ( WM_DESTROY ) :
        {
            DestroyKeyboardSpdDlg(pKstr);
            break;
        }
        case ( WM_HSCROLL ) :
        {
            if ((HWND)lParam == hwndCursorScroll)
            {
                int nCurrent = (int)SendMessage( (HWND)lParam,
                                                 TBM_GETPOS,
                                                 0,
                                                 0L );

                _SetCaretBlinkTime(CURSORMAX - (nCurrent * 100));
                _SetTimer(hDlg, uNewBlinkTime);
            }
            else
            {
                SetDelayAndSpeed(hDlg, -1, -1, 0);
                bKbNeedsReset = TRUE;
            }

            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
            break;
        }
        case ( WM_TIMER ) :
        {
            if (wParam == BLINK)
            {
                fBlink = !fBlink;
                ShowWindow(hwndCursorBlink, fBlink ? SW_SHOW : SW_HIDE);
            }
            break;
        }
        case ( WM_WININICHANGE ) :
        case ( WM_SYSCOLORCHANGE ) :
        case ( WM_DISPLAYCHANGE ) :
        {
            SHPropagateMessage(hDlg, message, wParam, lParam, TRUE);
            break;
        }

        case ( WM_HELP ) :             // F1
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     NULL,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aKbdHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     NULL,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aKbdHelpIds );
            break;
        }
        case ( WM_NOTIFY ) :
        {
            switch (((NMHDR *)lParam)->code)
            {
                case ( PSN_APPLY ) :
                {
                    HKEY hk;

                    HourGlass(TRUE);

                    if (RegCreateKeyEx(HKEY_CURRENT_USER, c_szUserDesktopKey, 0, NULL, 0, KEY_SET_VALUE, NULL, &hk, NULL) == ERROR_SUCCESS)
                    {
                        TCHAR buf[16];

                        if (CURSORMAX == uNewBlinkTime)
                        {
                            StringCchCopy(buf, ARRAYSIZE(buf), TEXT("-1"));
                        }
                        else
                        {
                            StringCchPrintf(buf, ARRAYSIZE(buf), TEXT("%d"), uNewBlinkTime);
                        }
                        RegSetValueEx(hk, c_szCursorBlink, 0, REG_SZ, (LPBYTE)buf, (DWORD)(lstrlen(buf) + 1) * sizeof(TCHAR));

                        RegCloseKey(hk);
                    }

                    SetDelayAndSpeed( hDlg,
                                      -1,
                                      -1,
                                      SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE);
                    GetSpeedGlobals();
                    HourGlass(FALSE);

                    break;
                }
                case ( PSN_RESET ) :
                {
                    _SetCaretBlinkTime(uBlinkTime);

                    if (bKbNeedsReset)
                    {
                        //
                        //  Restore the original keyboard speed.
                        //
                        SetDelayAndSpeed( hDlg,
                                          uOriginalDelay,
                                          uOriginalSpeed,
                                          0 );
                    }
                    break;
                }
            }
            break;
        }
        default :
        {
            return FALSE;
        }
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\main\drvaplet.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    drvaplet.h

Abstract:

    This module contains the header information for the driver routines
    for the project.

Revision History:

--*/



#ifndef _DRVAPLET_H
#define _DRVAPLET_H


//
//  HDAP: handle to a driver applet.
//

DECLARE_HANDLE(HDAP);


//
//  GetDriverModule: gets the module.
//
HMODULE GetDriverModule(LPCTSTR name);

//
// ReleaseDriverModule:  releases the module.
//
void ReleaseDriverModule(HMODULE module);

//
//  OpenDriverApplet: opens a handle to the named driver applet.
//
HDAP OpenDriverApplet(LPCTSTR);


//
//  CloseDriverApplet: closes a handle to a driver applet.
//
void CloseDriverApplet(HDAP);


//
//  GetDriverAppletIcon: get's a driver applet's icon (if any).
//
HICON GetDriverAppletIcon(HDAP);


//
//  CallDriverApplet: sends a message to the driver applet (CplApplet syntax).
//
LRESULT CallDriverApplet(HDAP, HWND, UINT, LPARAM, LPARAM);


//
//  RunDriverApplet: runs the driver applet.
//
#define RunDriverApplet(h, w)  CallDriverApplet(h, w, CPL_DBLCLK, 0L, 0L)


//
//  "CplApplet"
//
extern const TCHAR *c_szCplApplet;



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\main\drvaplet.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    drvaplet.c

Abstract:

    This module contains the driver routines for the project.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "drvaplet.h"




//
//  Defines for Win16 builds.
//

#ifndef WIN32
#define LoadLibrary16       LoadLibrary
#define FreeLibrary16       FreeLibrary
#define GetProcAddress16    GetProcAddress
#endif




//
//  Global Variables.
//

//
//  CplApplet.
//
const TCHAR *c_szCplApplet  = TEXT("CPlApplet");
const char  *c_szCplAppletA = "CPlApplet";




//
//  Typedef Declarations.
//

//
//  DRIVER_APPLET_INFO: the info we keep around about a driver applet.
//
typedef struct
{
    HMODULE     module;
    APPLET_PROC applet;
    HICON       icon;

} DRIVER_APPLET_INFO, *PDAI;




//
//  GetDriverModule: gets the module.
//
////////////////////////////////////////////////////////////////////////////
//
//  GetDriverModule
//
//  Gets the module.
//
////////////////////////////////////////////////////////////////////////////

HMODULE GetDriverModule(
    LPCTSTR name)
{
#ifdef WIN32

#ifdef WINNT
    return (LoadLibrary(name));
#else
    return (LoadLibrary16(name));
#endif

#else
    return (GetModuleHandle(name));
#endif
}


////////////////////////////////////////////////////////////////////////////
//
//  ReleaseDriverModule
//
////////////////////////////////////////////////////////////////////////////

void ReleaseDriverModule(
    HMODULE module)
{
#ifdef WIN32

#ifdef WINNT
    FreeLibrary(module);
#else
    FreeLibrary16(module);
#endif

#else
    //
    // do nothing (got it with GetModuleHandle)
    //
#endif
}


////////////////////////////////////////////////////////////////////////////
//
//  OpenDriverApplet
//
//  Opens a handle to the named driver applet.
//
////////////////////////////////////////////////////////////////////////////

HDAP OpenDriverApplet(
    LPCTSTR name)
{
    PDAI driver = (PDAI)LocalAlloc(LPTR, sizeof(DRIVER_APPLET_INFO));

    if (driver)
    {
        if ((driver->module = GetDriverModule(name)) != NULL)
        {
            if ((driver->applet = (APPLET_PROC)
#ifdef WINNT
                GetProcAddress(driver->module, c_szCplAppletA)) != NULL)
#else
                GetProcAddress16(driver->module, c_szCplApplet)) != NULL)
#endif
            {
                union
                {
                    NEWCPLINFO newform;
                    CPLINFO oldform;
                } info = { 0 };

                CallDriverApplet( (HDAP) driver,
                                  NULL,
                                  CPL_NEWINQUIRE,
                                  0,
                                  (LPARAM)&info.newform );

                if (info.newform.dwSize == sizeof(info.newform))
                {
                    driver->icon = info.newform.hIcon;
                    return ((HDAP)driver);
                }

//
//  NOTE: If the driver doesn't handle CPL_NEWIQUIRE, we must use CPL_INQUIRE
//  and LoadIcon the icon ourselves.  Win32 doesn't provide a LoadIcon16, so
//  in Win32 the 16 bit side of the thunk for CPL_NEWINQUIRE does this.  In
//  Win16, we do it right here.
//

#ifndef WIN32
                info.oldform.idIcon = 0;

                CallDriverApplet( (HDAP)driver,
                                  NULL,
                                  CPL_INQUIRE,
                                  0,
                                  (LPARAM)&info.oldform );

                if (info.oldform.idIcon)
                {
                    driver->icon =
                        LoadIcon( driver->module,
                                  MAKEINTRESOURCE(info.oldform.idIcon) );

                    return ((HDAP)driver);
                }
#endif
            }

            ReleaseDriverModule(driver->module);
        }

        LocalFree(driver);
    }

    return ((HDAP)0);
}


////////////////////////////////////////////////////////////////////////////
//
//  CloseDriverApplet
//
//  Closes a handle to a driver applet.
//
////////////////////////////////////////////////////////////////////////////

void CloseDriverApplet(
    HDAP HDAP)
{
#define driver ((PDAI)HDAP)

    if (driver)
    {
        if (driver->icon)
        {
            DestroyIcon(driver->icon);
        }
        ReleaseDriverModule(driver->module);
        LocalFree(driver);
    }

#undef driver
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDriverAppletIcon
//
//  Gets a driver applet's icon (if any).
//
////////////////////////////////////////////////////////////////////////////

HICON GetDriverAppletIcon(
    HDAP HDAP)
{
#define driver ((PDAI)HDAP)

    //
    //  Must return a copy for the current process/task to own.
    //
    return ((driver && driver->icon) ? CopyIcon(driver->icon) : NULL);

#undef driver
}


////////////////////////////////////////////////////////////////////////////
//
//  CallDriverApplet
//
//  Calls the driver applet (same syntax as CplApplet).
//
////////////////////////////////////////////////////////////////////////////

LRESULT CallDriverApplet(
    HDAP HDAP,
    HWND wnd,
    UINT msg,
    LPARAM p1,
    LPARAM p2)
{
#define driver ((PDAI)HDAP)

    if (driver)
    {
#ifdef WIN32
        return ( CallCPLEntry16( driver->module,
                                 (FARPROC16)driver->applet,
                                 wnd,
                                 msg,
                                 p1,
                                 p2 ) );
#else
        return (driver->applet(wnd, msg, p1, p2));
#endif
    }

    return (0L);

#undef driver
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\main\main.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    main.h

Abstract:

    This module contains the header information for the main routines of the
    Control Panel interface of the 32bit MAIN.CPL.

Revision History:

--*/



#ifndef _MAIN_H
#define _MAIN_H

#define USECOMM
#define OEMRESOURCE
#define STRICT

#ifdef WIN32
#define INC_OLE2
#define CONST_VTABLE
#endif



//
//  Include Files.
//

#include <windows.h>
#include <windowsx.h>
#include <dlgs.h>
#include <cpl.h>
#include <shlobj.h>
#include <shlwapi.h>
#include <shellapi.h>
#include <shlobjp.h>
#include <commctrl.h>
#include <shfusion.h>
#include <strsafe.h>

#ifndef RC_INVOKED
#include <prsht.h>
#include <debug.h>  // for ASSERT
#endif




//
//  Constant Declarations.
//

#define PATHMAX MAX_PATH
#define HELP_FILE TEXT("mouse.hlp")  // Help file for the mouse control panel


#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))


//
//  Typedef Declarations.
//

#ifndef NOARROWS
typedef struct
{
    short lineup;             // lineup/down, pageup/down are relative
    short linedown;           // changes.  top/bottom and the thumb
    short pageup;             // elements are absolute locations, with
    short pagedown;           // top & bottom used as limits.
    short top;
    short bottom;
    short thumbpos;
    short thumbtrack;
    BYTE  flags;              // flags set on return
} ARROWVSCROLL, NEAR *PARROWVSCROLL, FAR *LPARROWVSCROLL;

#define UNKNOWNCOMMAND 1
#define OVERFLOW       2
#define UNDERFLOW      4

#endif


#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\main\keybd.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    keybd.c

Abstract:

    This module contains the main routines for the Keyboard applet.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "rc.h"
#include "applet.h"
#include <regstr.h>
#include <cplext.h>
#include "util.h"
#include <intlid.h>




//
//  Constant Declarations.
//

#define MAX_PAGES 32              // limit on number of pages

const HWPAGEINFO c_hpiKeybd = {
    // Keyboard device class
    { 0x4d36e96bL, 0xe325, 0x11ce, { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } },

    // Keyboard troubleshooter command line
    IDS_KEYBD_TSHOOT,
};





//
//  Global Variables.
//

//
//  Location of prop sheet hooks in the registry.
//
static const TCHAR sc_szRegKeybd[] = REGSTR_PATH_CONTROLSFOLDER TEXT("\\Keyboard");




//
//  Function Prototypes.
//

INT_PTR CALLBACK
KeyboardSpdDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);





////////////////////////////////////////////////////////////////////////////
//
//  _AddKeybdPropSheetPage
//
//  Adds a property sheet page.
//
////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK _AddKeybdPropSheetPage(
    HPROPSHEETPAGE hpage,
    LPARAM lParam)
{
    PROPSHEETHEADER *ppsh = (PROPSHEETHEADER *)lParam;

    if (hpage && ppsh->nPages < MAX_PAGES)
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return (TRUE);
    }
    return (FALSE);
}



////////////////////////////////////////////////////////////////////////////
//
//  KeybdApplet
//
////////////////////////////////////////////////////////////////////////////

int KeybdApplet(
    HINSTANCE instance,
    HWND parent,
    LPCTSTR cmdline)
{
    HPROPSHEETPAGE rPages[MAX_PAGES];
    PROPSHEETPAGE psp;
    PROPSHEETHEADER psh;
    HPSXA hpsxa;
    int Result;

    //
    //  Make the initial page.
    //
    psh.dwSize     = sizeof(psh);
    psh.dwFlags    = PSH_PROPTITLE;
    psh.hwndParent = parent;
    psh.hInstance  = instance;
    psh.pszCaption = MAKEINTRESOURCE(IDS_KEYBD_TITLE);
    psh.nPages     = 0;

    if (cmdline)
    {
        psh.nStartPage = lstrlen(cmdline) ? StrToLong(cmdline) : 0;
    }
    else
    {
        psh.nStartPage = 0;
    }
    psh.phpage = rPages;

    //
    //  Load any installed extensions.
    //
    hpsxa = SHCreatePropSheetExtArray(HKEY_LOCAL_MACHINE, sc_szRegKeybd, 8);

    //
    //  Add the Speed page.
    //
    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = instance;
    psp.pszTemplate = MAKEINTRESOURCE(DLG_KEYBD_SPEED);
    psp.pfnDlgProc  = KeyboardSpdDlg;
    psp.lParam      = 0;

    _AddKeybdPropSheetPage(CreatePropertySheetPage(&psp), (LPARAM)&psh);

    //
    //  Add the Hardware page (not replaceable).
    //
    _AddKeybdPropSheetPage(CreateHardwarePage(&c_hpiKeybd), (LPARAM)&psh);

    //
    //  Add any extra pages that the extensions want in there.
    //
    if (hpsxa)
    {
        UINT cutoff = psh.nPages;
        UINT added = SHAddFromPropSheetExtArray( hpsxa,
                                                 _AddKeybdPropSheetPage,
                                                 (LPARAM)&psh );

        if (psh.nStartPage >= cutoff)
        {
            psh.nStartPage += added;
        }
    }

    //
    //  Invoke the Property Sheets.
    //
    switch (PropertySheet(&psh))
    {
        case ( ID_PSRESTARTWINDOWS ) :
        {
            Result = APPLET_RESTART;
            break;
        }
        case ( ID_PSREBOOTSYSTEM ) :
        {
            Result = APPLET_REBOOT;
            break;
        }
        default :
        {
            Result = 0;
            break;
        }
    }

    //
    //  Free any loaded extensions.
    //
    if (hpsxa)
    {
        SHDestroyPropSheetExtArray(hpsxa);
    }

    return (Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\main\main.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    main.c

Abstract:

    This module contains the main routines for the Control Panel
    interface of the 32bit MAIN.CPL.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "rc.h"
#include "applet.h"
#include "mousectl.h"
#include "drvaplet.h"


#define SZ_DEBUGINI     "maincpl.ini"
#define SZ_MODULE       "main"
#define SZ_DEBUGSECTION "debug"

#define DECLARE_DEBUG
#include <ccstock.h>
#include <debug.h>


//
//  Global Variables.
//

#ifdef WINNT

HINSTANCE g_hInst = NULL;

#else

#pragma data_seg(".idata")
HINSTANCE g_hInst = NULL;
#pragma data_seg()

#endif




//
//  Externally Defined Applets.
//

int MouseApplet(HINSTANCE, HWND, LPCTSTR);  // mouse.c
int KeybdApplet(HINSTANCE, HWND, LPCTSTR);  // keybd.c

BOOL RegisterPointerStuff(HINSTANCE);       // from mouseptr.c




//
//  Typedef Declarations.
//
typedef struct
{
    int            idIcon;
    int            idTitle;
    int            idExplanation;
    PFNAPPLETQUERY pfnAppletQuery;
    PFNAPPLET      pfnApplet;
    LPCTSTR        szDriver;
} APPLET;

APPLET Applets[] =
{
    { IDI_MOUSE,       IDS_MOUSE_TITLE,  IDS_MOUSE_EXPLAIN,  NULL,  MouseApplet,  TEXT("MOUSE") },
    { IDI_KEYBD,       IDS_KEYBD_TITLE,  IDS_KEYBD_EXPLAIN,  NULL,  KeybdApplet,  NULL    },
};

#define NUM_APPLETS (sizeof(Applets) / sizeof(Applets[0]))

int cApplets = NUM_APPLETS;





////////////////////////////////////////////////////////////////////////////
//
//  LibMain
//
////////////////////////////////////////////////////////////////////////////

BOOL APIENTRY LibMain(
    HINSTANCE hDll,
    DWORD dwReason,
    LPVOID lpReserved)
{
    switch (dwReason)
    {
        case ( DLL_PROCESS_ATTACH ) :
        {
            g_hInst = hDll;
            DisableThreadLibraryCalls(hDll);
            SHFusionInitializeFromModuleID(hDll, 124);
            break;
        }
        case ( DLL_PROCESS_DETACH ) :
        {
            SHFusionUninitialize();
            break;
        }
        case ( DLL_THREAD_ATTACH ) :
        case ( DLL_THREAD_DETACH ) :
        {
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CplInit
//
//  Called when a CPL consumer initializes a CPL.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CplInit(
    HWND hParent)
{
    int i;

    InitCommonControls();

    RegisterPointerStuff(g_hInst);

    RegisterMouseControlStuff(g_hInst);

    for (i = 0; i < cApplets; i++)
    {
        if ((Applets[i].pfnAppletQuery != NULL) &&
            ((*Applets[i].pfnAppletQuery)(hParent, APPLET_QUERY_EXISTS) == FALSE))
        {
            cApplets--;

            if (i != cApplets)
            {
                Applets[i] = Applets[cApplets];
            }

            i--;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CplExit
//
//  Called when a CPL consumer is done with a CPL.
//
////////////////////////////////////////////////////////////////////////////

void CplExit(void)
{
}


////////////////////////////////////////////////////////////////////////////
//
//  CplInquire
//
//  Called when a CPL consumer wants info about an applet.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CplInquire(
    LPCPLINFO info,
    int iApplet)
{
    APPLET *applet = Applets + iApplet;
    HMODULE hDriverApplet = NULL;

    info->idIcon = applet->idIcon;

    if (applet->szDriver) {

        if (hDriverApplet = GetDriverModule(applet->szDriver)) {

            info->idIcon = CPL_DYNAMIC_RES;
            ReleaseDriverModule(hDriverApplet);

        } // if (hDriverApplet = ...

    } // if (applet->szDriver)

    info->idName = applet->idTitle;
    info->idInfo = applet->idExplanation;
    info->lData  = 0L;

    return (1L);
}


////////////////////////////////////////////////////////////////////////////
//
//  CplNewInquire
//
//  Called when a CPL consumer wants info about an applet.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CplNewInquire(
    HWND parent,
    LPNEWCPLINFO info,
    int iApplet)
{
    APPLET *applet = Applets + iApplet;
    HDAP hdap;

    info->dwSize = sizeof(NEWCPLINFO);
    info->hIcon = NULL;

    //
    //  See if the applet is associated with a driver which can provide us
    //  an icon.
    //
    if ((applet->szDriver) &&
        ((hdap = OpenDriverApplet(applet->szDriver)) != NULL))
    {
        info->hIcon = GetDriverAppletIcon(hdap);
        CloseDriverApplet(hdap);
    }

    if ((!info->hIcon) && (applet->pfnAppletQuery != NULL))
    {
        info->hIcon = (HICON)(*(applet->pfnAppletQuery))( parent,
                                                          APPLET_QUERY_GETICON );
    }

    if (!info->hIcon)
    {
        info->hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(applet->idIcon));
    }

    LoadString(g_hInst, applet->idTitle, info->szName, ARRAYSIZE(info->szName));
    LoadString(g_hInst, applet->idExplanation, info->szInfo, ARRAYSIZE(info->szInfo));

    info->lData = 0L;
    *info->szHelpFile = 0;
    info->dwHelpContext = 0UL;

    return (1L);
}


////////////////////////////////////////////////////////////////////////////
//
//  CplInvoke
//
//  Called to invoke an applet.  It checks the applet's return value to see
//  if we need to restart.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CplInvoke(
    HWND parent,
    int iApplet,
    LPCTSTR cmdline)
{
    DWORD exitparam = 0UL;
    DWORD dwExitReason = SHTDN_REASON_FLAG_PLANNED |
                         SHTDN_REASON_MAJOR_OPERATINGSYSTEM |
                         SHTDN_REASON_MINOR_RECONFIG;

    switch (Applets[iApplet].pfnApplet(g_hInst, parent, cmdline))
    {
        case ( APPLET_RESTART ) :
        {
            exitparam = EW_RESTARTWINDOWS;
            break;
        }
        case ( APPLET_REBOOT ) :
        {
            exitparam = EW_REBOOTSYSTEM;
            break;
        }
        default :
        {
            return (1L);
        }
    }

    RestartDialogEx(parent, NULL, exitparam, dwExitReason);
    return (1L);
}


////////////////////////////////////////////////////////////////////////////
//
//  CplApplet
//
//  A CPL consumer calls this to request stuff from us.
//
////////////////////////////////////////////////////////////////////////////

LRESULT APIENTRY CPlApplet(
    HWND parent,
    UINT msg,
    LPARAM lparam1,
    LPARAM lparam2)
{
    switch (msg)
    {
        case ( CPL_INIT ) :
        {
            return (CplInit(parent));
        }
        case ( CPL_EXIT ) :
        {
            CplExit();
            break;
        }
        case ( CPL_GETCOUNT ) :
        {
            return (cApplets);
        }
        case ( CPL_INQUIRE ) :
        {
            return (CplInquire((LPCPLINFO)lparam2, (int)lparam1));
        }
        case ( CPL_NEWINQUIRE ) :
        {
            return (CplNewInquire(parent, (LPNEWCPLINFO)lparam2, (int)lparam1));
        }
        case ( CPL_DBLCLK ) :
        {
            lparam2 = 0L;

            // fall through...
        }
        case ( CPL_STARTWPARMS ) :
        {
            return (CplInvoke(parent, (int)lparam1, (LPTSTR)lparam2));
        }
    }

    return (0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\main\mouse.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mouse.c

Abstract:

    This module contains the main routines for the Mouse applet.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "rc.h"
#include "applet.h"
#include <regstr.h>
#include <cplext.h>
#include "util.h"



//
//  Constant Declarations.
//

#define MAX_PAGES 32


const HWPAGEINFO c_hpiMouse = {
    // Mouse device class
    { 0x4d36e96fL, 0xe325, 0x11ce, { 0xbf, 0xc1, 0x08, 0x00, 0x2b, 0xe1, 0x03, 0x18 } },

    // Mouse troubleshooter command line
    IDS_MOUSE_TSHOOT,
};


//
//  Global Variables.
//

//
//  Location of prop sheet hooks in the registry.
//
static const TCHAR sc_szRegMouse[] = REGSTR_PATH_CONTROLSFOLDER TEXT("\\Mouse");




//
//  Function Prototypes.
//

INT_PTR CALLBACK
MouseButDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
MousePtrDlg(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam);

INT_PTR CALLBACK
MouseMovDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

/*
INT_PTR CALLBACK
MouseActivitiesDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);
*/

INT_PTR CALLBACK
MouseWheelDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);


static int
GetClInt( const TCHAR *p );


////////////////////////////////////////////////////////////////////////////
//
//  _AddMousePropSheetPage
//
//  Adds a property sheet page.
//
////////////////////////////////////////////////////////////////////////////

BOOL CALLBACK _AddMousePropSheetPage(
    HPROPSHEETPAGE hpage,
    LPARAM lParam)
{
    PROPSHEETHEADER *ppsh = (PROPSHEETHEADER *)lParam;

    if (hpage && (ppsh->nPages < MAX_PAGES))
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return (TRUE);
    }
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseApplet
//
////////////////////////////////////////////////////////////////////////////

int MouseApplet(
    HINSTANCE instance,
    HWND parent,
    LPCTSTR cmdline)
{
    HPROPSHEETPAGE rPages[MAX_PAGES];
    PROPSHEETPAGE psp;
    PROPSHEETHEADER psh;
    HPSXA hpsxa;
    int Result;

    //
    //  Make the initial page.
    //
    psh.dwSize     = sizeof(psh);
    psh.dwFlags    = PSH_PROPTITLE;
    psh.hwndParent = parent;
    psh.hInstance  = instance;
    psh.pszCaption = MAKEINTRESOURCE(IDS_MOUSE_TITLE);
    psh.nPages     = 0;
    psh.nStartPage = ( ( cmdline && *cmdline )? GetClInt( cmdline ) : 0 );
    psh.phpage     = rPages;

    //
    //  Load any installed extensions.
    //
    hpsxa = SHCreatePropSheetExtArray(HKEY_LOCAL_MACHINE, sc_szRegMouse, 8);

    //
    //  Add the Buttons page, giving the extensions a chance to replace it.
    //
    if (!hpsxa ||
        !SHReplaceFromPropSheetExtArray( hpsxa,
                                         CPLPAGE_MOUSE_BUTTONS,
                                         _AddMousePropSheetPage,
                                         (LPARAM)&psh ))
    {
        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_DEFAULT;
        psp.hInstance   = instance;
        psp.pszTemplate = MAKEINTRESOURCE(DLG_MOUSE_BUTTONS);
        psp.pfnDlgProc  = MouseButDlg;
        psp.lParam      = 0;

        _AddMousePropSheetPage(CreatePropertySheetPage(&psp), (LPARAM)&psh);
    }


    //
    //  Add the Pointers page (not replaceable).
    //
    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = instance;
    psp.pszTemplate = MAKEINTRESOURCE(DLG_MOUSE_POINTER);
    psp.pfnDlgProc  = MousePtrDlg;
    psp.lParam      = 0;

    _AddMousePropSheetPage(CreatePropertySheetPage(&psp), (LPARAM)&psh);

    //
    //  Add the Motion page, giving the extensions a chance to replace it.
    //
    if (!hpsxa ||
        !SHReplaceFromPropSheetExtArray( hpsxa,
                                         CPLPAGE_MOUSE_PTRMOTION,
                                         _AddMousePropSheetPage,
                                         (LPARAM)&psh ))
    {
        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_DEFAULT;
        psp.hInstance   = instance;
        psp.pszTemplate = MAKEINTRESOURCE(DLG_MOUSE_MOTION);
        psp.pfnDlgProc  = MouseMovDlg;
        psp.lParam      = 0;

        _AddMousePropSheetPage(CreatePropertySheetPage(&psp), (LPARAM)&psh);
    }

/*
/*  Not added due to lack of time.  ewatson (05/05/2000)
    //
    //  Add the Activities page, giving the extensions a chance to replace it.
    //
    if (!hpsxa ||
        !SHReplaceFromPropSheetExtArray( hpsxa,
                                         CPLPAGE_MOUSE_ACTIVITIES,
                                         _AddMousePropSheetPage,
                                         (LPARAM)&psh ))
    {
        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_DEFAULT;
        psp.hInstance   = instance;
        psp.pszTemplate = MAKEINTRESOURCE(DLG_MOUSE_ACTIVITIES);
        psp.pfnDlgProc  = MouseActivitiesDlg;
        psp.lParam      = 0;

        _AddMousePropSheetPage(CreatePropertySheetPage(&psp), (LPARAM)&psh);
    }
*/

    //
    //  Add the Wheel page (if mouse with wheel is present)
    //  This page is replace-able.
    //
    if (!hpsxa ||
        !SHReplaceFromPropSheetExtArray( hpsxa,
                                         CPLPAGE_MOUSE_WHEEL,
                                         _AddMousePropSheetPage,
                                         (LPARAM)&psh ))
    {
      //
      //If a Wheel mouse is present on the system, then display the Wheel property sheet page
      //
      if  (GetSystemMetrics(SM_MOUSEWHEELPRESENT))
        {
        psp.dwSize      = sizeof(psp);
        psp.dwFlags     = PSP_DEFAULT;
        psp.hInstance   = instance;
        psp.pszTemplate = MAKEINTRESOURCE(DLG_MOUSE_WHEEL);
        psp.pfnDlgProc  = MouseWheelDlg;
        psp.lParam      = 0;

        _AddMousePropSheetPage(CreatePropertySheetPage(&psp), (LPARAM)&psh);
        }
    }


    _AddMousePropSheetPage(CreateHardwarePage(&c_hpiMouse), (LPARAM)&psh);
     



    //
    //  Add any extra pages that the extensions want in there.
    //
    if (hpsxa)
    {
        UINT cutoff = psh.nPages;
        UINT added = SHAddFromPropSheetExtArray( hpsxa,
                                                 _AddMousePropSheetPage,
                                                 (LPARAM)&psh );

        if (psh.nStartPage >= cutoff)
        {
            psh.nStartPage += added;
        }
    }

    //
    //  Invoke the Property Sheets.
    //
    switch (PropertySheet(&psh))
    {
        case ( ID_PSRESTARTWINDOWS ) :
        {
            Result = APPLET_RESTART;
            break;
        }
        case ( ID_PSREBOOTSYSTEM ) :
        {
            Result = APPLET_REBOOT;
            break;
        }
        default :
        {
            Result = 0;
            break;
        }
    }

    //
    //  Free any loaded extensions.
    //
    if (hpsxa)
    {
        SHDestroyPropSheetExtArray(hpsxa);
    }

    return (Result);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetClInt  to determine command line argument.
//
////////////////////////////////////////////////////////////////////////////
static int
GetClInt( const TCHAR *p )
{
    BOOL neg = FALSE;
    int v = 0;

    while( *p == TEXT(' ') )
        p++;                        // skip spaces

    if( *p == TEXT('-') )                 // is it negative?
    {
        neg = TRUE;                     // yes, remember that
        p++;                            // skip '-' char
    }

    // parse the absolute portion
    while( ( *p >= TEXT('0') ) && ( *p <= TEXT('9') ) )     // digits only
        v = v * 10 + *p++ - TEXT('0');    // accumulate the value

    return ( neg? -v : v );         // return the result
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\main\mousectl.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mousectl.h

Abstract:

    This module contains the header information for the Mouse control.

Revision History:

--*/



#ifndef _MOUSECTL_H
#define _MOUSECTL_H



#define MOUSECTL_CLASSNAME  TEXT("PropertyMouseButtonControl")


BOOL
RegisterMouseControlStuff(
    HINSTANCE instance);

void
MouseControlSetSwap(
    HWND window,
    BOOL swap);



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\main\mousebut.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mousebut.c

Abstract:

    This module contains the routines for the Mouse Buttons Property Sheet
    page.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "util.h"
#include "rc.h"
#include "mousectl.h"
#include <regstr.h>
#include <winerror.h>        // needed for ERROR_SUCCESS value
#include "mousehlp.h"



//
//  Constant Declarations.
//
const TCHAR szYes[]          = TEXT("yes");
const TCHAR szNo[]           = TEXT("no");
const TCHAR szDblClkSpeed[]  = TEXT("DoubleClickSpeed");
const TCHAR szRegStr_Mouse[] = REGSTR_PATH_MOUSE;

#define SAFE_DESTROYICON(hicon)   if (hicon) { DestroyIcon(hicon); hicon=NULL; }


//
//  SwapMouseButtons takes:
//      TRUE to make it a right mouse
//      FALSE to make it a left mouse
//
#define RIGHT       TRUE
#define LEFT        FALSE


//Identifiers used for setting DoubleClick speed
#define DBLCLICK_MIN    200      // milliseconds
#define DBLCLICK_MAX    900
#define DBLCLICK_DEFAULT_TIME 500 

#define DBLCLICK_TIME_SLIDER_MIN  0   
#define DBLCLICK_TIME_SLIDER_MAX  10   


#define DBLCLICK_RANGE  (DBLCLICK_MAX - DBLCLICK_MIN)
#define DBLCLICK_SLIDER_RANGE ( CLICKLOCK_TIME_SLIDER_MAX - CLICKLOCK_TIME_SLIDER_MIN)


#define DBLCLICK_TICKMULT  (DBLCLICK_RANGE / DBLCLICK_SLIDER_RANGE)

#define DBLCLICK_TICKS_TO_TIME(ticks)  (SHORT) (((DBLCLICK_TIME_SLIDER_MAX - ticks) * DBLCLICK_TICKMULT) + DBLCLICK_MIN)
#define DBLCLICK_TIME_TO_TICKS(time)   (SHORT) (DBLCLICK_TIME_SLIDER_MAX - ((time - DBLCLICK_MIN) / DBLCLICK_TICKMULT))




#define CLICKLOCK_TIME_SLIDER_MIN  1    //Minimum ClickLock Time setting for slider control
#define CLICKLOCK_TIME_SLIDER_MAX  11   //Maximum ClickLock Time setting for slider control
#define CLICKLOCK_TIME_FACTOR      200  //Multiplier for translating clicklock time slider units to milliseconds
#define TICKS_PER_CLICK       1

//Size assumed as the default size for icons, used for scaling the icons
#define		ICON_SIZEX								32									
#define		ICON_SIZEY								32
//The font size used for scaling
#define		SMALLFONTSIZE					96										
#define CLAPPER_CLASS   TEXT("Clapper")

//
//  Typedef Declarations.
//

typedef struct tag_MouseGenStr
{
    BOOL bSwap;
    BOOL bOrigSwap;

    short ClickSpeed;
    short OrigDblClkSpeed;

    HWND hWndDblClkScroll;
    HWND hDlg;                    

    HWND hWndDblClk_TestArea;

    RECT DblClkRect;
    
    HICON hIconDblClick[2];

#ifdef SHELL_SINGLE_CLICK
    BOOL bShellSingleClick,
         bOrigShellSingleClick ;

    HICON hIconSglClick,
          hIconDblClick ;
#endif //SHELL_SINGLE_CLICK

    BOOL bClickLock;
    BOOL bOrigClickLock;

    DWORD dwClickLockTime;
    DWORD dwOrigClickLockTime;

} MOUSEBUTSTR, *PMOUSEBUTSTR, *LPMOUSEBUTSTR;

//
//  Context Help Ids.
//

const DWORD aMouseButHelpIds[] =
{
    IDC_GROUPBOX_1,             IDH_COMM_GROUPBOX,
    IDBTN_BUTTONSWAP,           IDH_MOUSE_SWITCH,
    MOUSE_MOUSEBMP,             IDH_MOUSE_SWITCH_PIC,
    IDC_GROUPBOX_2,             IDH_COMM_GROUPBOX,
    
    IDC_GROUPBOX_4,             IDH_COMM_GROUPBOX,
    MOUSE_CLICKSCROLL,          IDH_MOUSE_DOUBLECLICK,
    IDC_DBLCLICK_TEXT,          IDH_COMM_GROUPBOX,
    IDC_TEST_DOUBLE_CLICK,      IDH_MOUSE_DCLICK_TEST_BOX,
    MOUSE_DBLCLK_TEST_AREA,     IDH_MOUSE_DCLICK_TEST_BOX,
    
    IDC_GROUPBOX_6,             IDH_COMM_GROUPBOX,
    IDCK_CLICKLOCK,             IDH_MOUSE_CLKLCK_CHKBOX,
    IDBTN_CLICKLOCK_SETTINGS,   IDH_MOUSE_CLKLCK_SETTINGS_BTN,
    IDC_CLICKLOCK_TEXT,         IDH_COMM_GROUPBOX,
    
    IDC_CLICKLOCK_SETTINGS_TXT,         IDH_COMM_GROUPBOX,
    IDT_CLICKLOCK_TIME_SETTINGS,        IDH_MOUSE_CLKLCK_DIALOG,
    IDC_CLICKLOCK_SETTINGS_LEFT_TXT,    IDH_MOUSE_CLKLCK_DIALOG,
    IDC_CLICKLOCK_SETTINGS_RIGHT_TXT,   IDH_MOUSE_CLKLCK_DIALOG,

#ifdef SHELL_SINGLE_CLICK    
    MOUSE_SGLCLICK,             IDH_MOUSE_SGLCLICK,
    MOUSE_DBLCLICK,             IDH_MOUSE_DBLCLICK,
#endif // SHELL_SINGLE_CLICK

    0,0 
};


//
//  helper function prototypes
//
void ShellClick_UpdateUI( HWND hDlg, PMOUSEBUTSTR pMstr) ;
void ShellClick_Refresh( PMOUSEBUTSTR pMstr ) ;


//
//  Debug Info.
//

#ifdef DEBUG

#define REG_INTEGER  1000

int fTraceRegAccess = 0;

void RegDetails(
    int     iWrite,
    HKEY    hk,
    LPCTSTR lpszSubKey,
    LPCTSTR lpszValueName,
    DWORD   dwType,
    LPTSTR  lpszString,
    int     iValue)
{
    TCHAR Buff[256];
    TCHAR *lpszReadWrite[] = { TEXT("DESK.CPL:Read"), TEXT("DESK.CPL:Write") };

    if (!fTraceRegAccess)
    {
        return;
    }

    switch (dwType)
    {
        case ( REG_SZ ) :
        {
            StringCchPrintf(Buff,
                        ARRAYSIZE(Buff),
                        TEXT("%s String:hk=%#08lx, %s:%s=%s\n\r"),
                        lpszReadWrite[iWrite],
                        hk,
                        lpszSubKey,
                        lpszValueName,
                        lpszString );
            break;
        }
        case ( REG_INTEGER ) :
        {
            StringCchPrintf(Buff,
                        ARRAYSIZE(Buff),
                        TEXT("%s int:hk=%#08lx, %s:%s=%d\n\r"),
                        lpszReadWrite[iWrite],
                        hk,
                        lpszSubKey,
                        lpszValueName,
                        iValue );
            break;
        }
        case ( REG_BINARY ) :
        {
            StringCchPrintf(Buff,
                        ARRAYSIZE(Buff),
                        TEXT("%s Binary:hk=%#08lx, %s:%s=%#0lx;DataSize:%d\r\n"),
                        lpszReadWrite[iWrite],
                        hk,
                        lpszSubKey,
                        lpszValueName,
                        lpszString,
                        iValue );
            break;
        }
    }
    OutputDebugString(Buff);
}

#endif  // DEBUG





////////////////////////////////////////////////////////////////////////////
//
//  GetIntFromSubKey
//
//  hKey is the handle to the subkey (already pointing to the proper
//  location.
//
////////////////////////////////////////////////////////////////////////////

int GetIntFromSubkey(
    HKEY hKey,
    LPCTSTR lpszValueName,
    int iDefault)
{
    TCHAR szValue[20];
    DWORD dwSizeofValueBuff = sizeof(szValue);
    DWORD dwType;
    int iRetValue = iDefault;

    if ((RegQueryValueEx( hKey,
                          (LPTSTR)lpszValueName,
                          NULL,
                          &dwType,
                          (LPBYTE)szValue,
                          &dwSizeofValueBuff ) == ERROR_SUCCESS) &&
        (dwSizeofValueBuff))
    {
        //
        //  BOGUS: This handles only the string type entries now!
        //
        if (dwType == REG_SZ)
        {
            iRetValue = (int)StrToLong(szValue);
        }
#ifdef DEBUG
        else
        {
            OutputDebugString(TEXT("String type expected from Registry\n\r"));
        }
#endif
    }

#ifdef DEBUG
    RegDetails(0, hKey, TEXT(""), lpszValueName, REG_INTEGER, NULL, iRetValue);
#endif

    return (iRetValue);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetIntFromReg
//
//  Opens the given subkey and gets the int value.
//
////////////////////////////////////////////////////////////////////////////

int GetIntFromReg(
    HKEY hKey,
    LPCTSTR lpszSubkey,
    LPCTSTR lpszNameValue,
    int iDefault)
{
    HKEY hk;
    int iRetValue = iDefault;

    //
    //  See if the key is present.
    //
    if (RegOpenKeyEx(hKey, lpszSubkey, 0, KEY_READ, &hk) == ERROR_SUCCESS)
    {
        iRetValue = GetIntFromSubkey(hk, lpszNameValue, iDefault);
        RegCloseKey(hk);
    }

    return (iRetValue);
}

////////////////////////////////////////////////////////////////////////////
//
//  CenterDlgOverParent
//
////////////////////////////////////////////////////////////////////////////
void WINAPI CenterDlgOverParent (HWND hWnd)
{
    HWND hwndOwner; 
    RECT rc, rcDlg, rcOwner; 
  
    if ((hwndOwner = GetParent(hWnd)) == NULL) 
    {      
         return;
    }

    GetWindowRect(hwndOwner, &rcOwner); 
    GetWindowRect(hWnd, &rcDlg); 
    CopyRect(&rc, &rcOwner); 
 
    // Offset the owner and dialog box rectangles so that 
    // right and bottom values represent the width and 
    // height, and then offset the owner again to discard 
    // space taken up by the dialog box. 
 
    OffsetRect(&rcDlg, -rcDlg.left, -rcDlg.top); 
    OffsetRect(&rc, -rc.left, -rc.top); 
    OffsetRect(&rc, -rcDlg.right, -rcDlg.bottom); 
 
    //The new position is the sum of half the remaining 
    //space and the owner's original position. 
    SetWindowPos(hWnd, 
                 HWND_TOP, 
                 rcOwner.left + (rc.right / 2), 
                 rcOwner.top + (rc.bottom / 2), 
                 0, 0,          // ignores size arguments 
                 SWP_NOSIZE);

	  // now let's verify left side is not off screen
		GetWindowRect( hWnd, &rc);

		if ((rc.left < 0) || (rc.top < 0))
		{
			if (rc.left < 0)
				rc.left = 0;
			if (rc.top < 0)
				rc.top = 0;

		    SetWindowPos(hWnd, 
		           HWND_TOP, 
		           rc.left, 
		           rc.top,
		           0, 0,          // ignores size arguments 
		           SWP_NOSIZE);

						
		}	
}



////////////////////////////////////////////////////////////////////////////
//
//  ShowButtonState
//
//  Swaps the menu and selection bitmaps.
//
////////////////////////////////////////////////////////////////////////////

void ShowButtonState(
    PMOUSEBUTSTR pMstr)
{
    HWND hDlg;

    Assert(pMstr);

    hDlg = pMstr->hDlg;

    MouseControlSetSwap(GetDlgItem(hDlg, MOUSE_MOUSEBMP), pMstr->bSwap);

    CheckDlgButton(hDlg,IDBTN_BUTTONSWAP, pMstr->bSwap);

#ifdef SHELL_SINGLE_CLICK
//This was removed
    CheckDlgButton(hDlg, MOUSE_SGLCLICK, pMstr->bShellSingleClick);
    CheckDlgButton(hDlg, MOUSE_DBLCLICK, !pMstr->bShellSingleClick);
#endif  //SHELL_SINGLE_CLICK
}


////////////////////////////////////////////////////////////////////////////
//
//  DestroyMouseButDlg
//
////////////////////////////////////////////////////////////////////////////

void DestroyMouseButDlg(
    PMOUSEBUTSTR pMstr)
{
    if (pMstr)
    {
#ifdef SHELL_SINGLE_CLICK
        SAFE_DESTROYICON( pMstr->hIconSglClick ) ;
        SAFE_DESTROYICON( pMstr->hIconDblClick ) ;
#endif 

        SAFE_DESTROYICON( pMstr->hIconDblClick[0]); 
        SAFE_DESTROYICON( pMstr->hIconDblClick[1]);


        SetWindowLongPtr(pMstr->hDlg, DWLP_USER, 0);
        LocalFree((HGLOBAL)pMstr);
    }
}




////////////////////////////////////////////////////////////////////////////
//
//  ClickLockSettingsDlg
//
////////////////////////////////////////////////////////////////////////////
INT_PTR CALLBACK ClickLockSettingsDlg (
   HWND   hDlg,                        // dialog window handle
   UINT   msg,                         // message identifier
   WPARAM wParam,                      // primary parameter
   LPARAM lParam)                      // secondary parameter
{
static DWORD* pdwClickLockTime;
static HICON hIcon = 0;

   switch (msg)
   {
   case WM_INITDIALOG:
     {
      
      WPARAM wSliderSetting;      //ClickLock time in terms of slider units

       HourGlass (TRUE);

       Assert(lParam);
      pdwClickLockTime = (DWORD*) lParam;   //Save Original value for return


      //Convert into slider units from milliseconds. Note that the slider
      //values get larger as the ClickLock time gets larger.
      wSliderSetting = (*pdwClickLockTime) / CLICKLOCK_TIME_FACTOR;

      //Make sure setting is within valid range for ClickLock slider
      wSliderSetting = max(wSliderSetting, CLICKLOCK_TIME_SLIDER_MIN);
      wSliderSetting = min(wSliderSetting, CLICKLOCK_TIME_SLIDER_MAX);

      SendDlgItemMessage (hDlg, IDT_CLICKLOCK_TIME_SETTINGS, TBM_SETRANGE,
        TRUE, MAKELONG(CLICKLOCK_TIME_SLIDER_MIN, CLICKLOCK_TIME_SLIDER_MAX));
      SendDlgItemMessage (hDlg, IDT_CLICKLOCK_TIME_SETTINGS, TBM_SETPAGESIZE,
                         0, TICKS_PER_CLICK); // click movement
      SendDlgItemMessage (hDlg, IDT_CLICKLOCK_TIME_SETTINGS, TBM_SETPOS,
                         TRUE, (LPARAM)(LONG)wSliderSetting);

      //icon for the dialog
      //  (saved in a static variable, and released on WM_DESTROY)
      hIcon = LoadIcon((HINSTANCE)GetWindowLongPtr( hDlg, GWLP_HINSTANCE ),
                                  MAKEINTRESOURCE(ICON_CLICKLOCK));
      SendMessage( GetDlgItem (hDlg, MOUSE_CLICKICON), 
                   STM_SETICON, (WPARAM)hIcon, 0L );

         
      CenterDlgOverParent(hDlg);    //Center dialog here so it doesn't jump around on screen
      HourGlass(FALSE);
      return(TRUE);
     }

   case WM_HSCROLL:
     {
      if (LOWORD(wParam) == TB_ENDTRACK)
        { 
        DWORD dwClTime;
        int  wSliderSetting = (int) SendMessage (GetDlgItem (hDlg, IDT_CLICKLOCK_TIME_SETTINGS),
                                                      TBM_GETPOS, 0, 0L);

        dwClTime = wSliderSetting * CLICKLOCK_TIME_FACTOR;

        SystemParametersInfo(SPI_SETMOUSECLICKLOCKTIME, 
                              0,
                              (PVOID) (LOWORD(dwClTime)), 
                              0);
        }
     }
     break;


   case WM_HELP:    //F1
      {
            WinHelp( ((LPHELPINFO)lParam)->hItemHandle,
                     HELP_FILE,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aMouseButHelpIds );
      }
      break;

   case WM_CONTEXTMENU:                // Display simple "What's This?" menu
      {  
            WinHelp( (HWND) wParam,
                     HELP_FILE,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aMouseButHelpIds );
      }
      break;

   case WM_DESTROY:
      SAFE_DESTROYICON(hIcon);
      break;


   case WM_COMMAND:
      switch(LOWORD(wParam))
      {
 
      case IDOK:                       // Flag to save setting
        {
          DWORD dwClickLockTime;
          int  wSliderSetting = (int) SendMessage (GetDlgItem (hDlg, IDT_CLICKLOCK_TIME_SETTINGS),
                                                      TBM_GETPOS, 0, 0L);

          //verify range
          wSliderSetting = max(wSliderSetting, CLICKLOCK_TIME_SLIDER_MIN);
          wSliderSetting = min(wSliderSetting, CLICKLOCK_TIME_SLIDER_MAX);
        
          // Convert to milliseconds from slider units.
          dwClickLockTime = wSliderSetting * CLICKLOCK_TIME_FACTOR;

          *pdwClickLockTime = dwClickLockTime;

          EndDialog(hDlg, IDOK); 
          break;  
        }
        
      case IDCANCEL:                   // revert to previous setting         
         EndDialog(hDlg, IDCANCEL);
         break;

      default:
         return(FALSE);
      }
      return (TRUE);
      
   default:
     return(FALSE);    
   }
   return (TRUE);                   
}


////////////////////////////////////////////////////////////////////////////
//
//  InitMouseButDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL InitMouseButDlg(
    HWND hDlg)
{
    SHELLSTATE   shellstate = {0} ;
    PMOUSEBUTSTR pMstr = NULL;
    HINSTANCE    hInstDlg = (HINSTANCE)GetWindowLongPtr( hDlg, GWLP_HINSTANCE ) ;
    HWND hwndClickLockSettingsButton = GetDlgItem(hDlg, IDBTN_CLICKLOCK_SETTINGS);
    DWORD dwClickLockSetting = 0;

    HWND hwndDoubleClickTestArea = NULL;

    pMstr = (PMOUSEBUTSTR)LocalAlloc(LPTR , sizeof(MOUSEBUTSTR));

    if (pMstr == NULL)
    {
        return (TRUE);
    }

    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pMstr);

    pMstr->hDlg = hDlg;
   
    //
    //Set up the double click test area 
    //
    pMstr->hWndDblClk_TestArea = GetDlgItem(hDlg, MOUSE_DBLCLK_TEST_AREA);
    GetWindowRect(pMstr->hWndDblClk_TestArea, &pMstr->DblClkRect);  
    MapWindowPoints(NULL, hDlg, (LPPOINT) &pMstr->DblClkRect, 2);                 

    pMstr->hIconDblClick[0] = LoadIcon(hInstDlg, MAKEINTRESOURCE(ICON_FOLDER_CLOSED));
    pMstr->hIconDblClick[1] = LoadIcon(hInstDlg, MAKEINTRESOURCE(ICON_FOLDER_OPEN));
 
    SendMessage(pMstr->hWndDblClk_TestArea, STM_SETICON, (WPARAM)pMstr->hIconDblClick[0], 0L);

    //
    //  Set (and get), then restore the state of the mouse buttons.
    //
    (pMstr->bOrigSwap) = (pMstr->bSwap) = SwapMouseButton(TRUE);

    SwapMouseButton(pMstr->bOrigSwap);
    
#ifdef SHELL_SINGLE_CLICK
    //
    //  Get shell single-click behavior:
    //
    SHGetSetSettings( &shellstate, SSF_DOUBLECLICKINWEBVIEW | SSF_WIN95CLASSIC, FALSE /*get*/ ) ;
    pMstr->bShellSingleClick =
    pMstr->bOrigShellSingleClick =  shellstate.fWin95Classic ? FALSE :
                                    shellstate.fDoubleClickInWebView ? FALSE :
                                    TRUE ;
    pMstr->hIconSglClick = LoadIcon( hInstDlg, MAKEINTRESOURCE( IDI_SGLCLICK ) ) ;
    pMstr->hIconDblClick = LoadIcon( hInstDlg, MAKEINTRESOURCE( IDI_DBLCLICK ) ) ;
    ShellClick_UpdateUI( hDlg, pMstr ) ;
#endif //SHELL_SINGLE_CLICK

    //
    //  Initialize check/radio button state
    //
    ShowButtonState(pMstr);

    pMstr->OrigDblClkSpeed =
    pMstr->ClickSpeed = (SHORT) GetIntFromReg( HKEY_CURRENT_USER,
                                       szRegStr_Mouse,
                                       szDblClkSpeed,
                                       DBLCLICK_DEFAULT_TIME );

    pMstr->hWndDblClkScroll = GetDlgItem(hDlg, MOUSE_CLICKSCROLL);

    SendMessage( pMstr->hWndDblClkScroll,
                 TBM_SETRANGE,
                 0,
                 MAKELONG(DBLCLICK_TIME_SLIDER_MIN, DBLCLICK_TIME_SLIDER_MAX) );
   
    SendMessage( pMstr->hWndDblClkScroll,
                 TBM_SETPOS,
                 TRUE,
                 (LONG) (DBLCLICK_TIME_TO_TICKS(pMstr->ClickSpeed)) );
   


    SetDoubleClickTime(pMstr->ClickSpeed);


    //
    //Get clicklock settings and set the checkbox
    //
    SystemParametersInfo(SPI_GETMOUSECLICKLOCK, 0, (PVOID)&dwClickLockSetting, 0);
    pMstr->bOrigClickLock = pMstr->bClickLock  = (dwClickLockSetting) ? TRUE : FALSE;
    
    if ( pMstr->bClickLock )
      {
       CheckDlgButton (hDlg, IDCK_CLICKLOCK, BST_CHECKED);  
       EnableWindow(hwndClickLockSettingsButton, TRUE);       
      }
    else
      {
       CheckDlgButton (hDlg, IDCK_CLICKLOCK, BST_UNCHECKED);  
       EnableWindow(hwndClickLockSettingsButton, FALSE);             
      }

    // click lock speed    
    {
    DWORD dwClTime = 0;
    SystemParametersInfo(SPI_GETMOUSECLICKLOCKTIME, 0, (PVOID)&dwClTime, 0);

    dwClTime = max(dwClTime, CLICKLOCK_TIME_SLIDER_MIN * CLICKLOCK_TIME_FACTOR);
    dwClTime = min(dwClTime, CLICKLOCK_TIME_SLIDER_MAX * CLICKLOCK_TIME_FACTOR);

    pMstr->dwOrigClickLockTime = pMstr->dwClickLockTime  = dwClTime;
    }
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseButDlg
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK MouseButDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{

    static int iTestIcon = 0;   //index into hIconDblClick array

    PMOUSEBUTSTR pMstr = (PMOUSEBUTSTR)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (message)
    {
        case ( WM_INITDIALOG ) :
        {
            iTestIcon = 0;
            return (InitMouseButDlg(hDlg));
        }
        case ( WM_DESTROY ) :
        {
            DestroyMouseButDlg(pMstr);
            break;
        }
        case ( WM_HSCROLL ) :
        {
            if ((HWND)lParam == pMstr->hWndDblClkScroll)
            {
                short temp = DBLCLICK_TICKS_TO_TIME((short)SendMessage( (HWND)lParam,
                                                 TBM_GETPOS,
                                                 0,
                                                 0L ));

                if (temp != pMstr->ClickSpeed)
                {
                    pMstr->ClickSpeed = temp;

                    SetDoubleClickTime(pMstr->ClickSpeed);

                    SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                }
            }
            break;
        }
        case ( WM_RBUTTONDBLCLK ) :
        case ( WM_LBUTTONDBLCLK ) :
        {
            POINT point = { (int)MAKEPOINTS(lParam).x,
                            (int)MAKEPOINTS(lParam).y };

            if (PtInRect(&pMstr->DblClkRect, point))
            {
            iTestIcon ^= 1;
            SendMessage(pMstr->hWndDblClk_TestArea, STM_SETICON, 
                         (WPARAM)pMstr->hIconDblClick[iTestIcon], 0L);
            }
            break;
        }

        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( IDCK_CLICKLOCK ) :
                {
                 HWND hwndClickLockSettingsButton = GetDlgItem(hDlg, IDBTN_CLICKLOCK_SETTINGS);

                 SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                  
                 pMstr->bClickLock = !(pMstr->bClickLock);
                  
                 // update control(s) appearance
                 CheckDlgButton (hDlg, IDCK_CLICKLOCK,      ( pMstr->bClickLock ) ? BST_CHECKED : BST_UNCHECKED);
                 EnableWindow(hwndClickLockSettingsButton,  ( pMstr->bClickLock ) ? TRUE        : FALSE);       

                 SystemParametersInfo(SPI_SETMOUSECLICKLOCK,     
                                      0,
                                      IntToPtr(pMstr->bClickLock),     
                                      0);

                 break;
                }

                case ( IDBTN_CLICKLOCK_SETTINGS ) :
                {
                  LPARAM lRet;
                  UINT code = HIWORD(wParam);
                  
                  DWORD dwTempClickLockTime =  pMstr->dwClickLockTime;
                  
                  if (code == BN_CLICKED)
                    {                 
                    lRet = DialogBoxParam ((HINSTANCE)GetWindowLongPtr( hDlg, GWLP_HINSTANCE ),
                                            MAKEINTRESOURCE(IDD_CLICKLOCK_SETTINGS_DLG ),
                                            GetParent (hDlg),
                                            ClickLockSettingsDlg, 
                                            (LPARAM) &dwTempClickLockTime);
                    if (lRet == IDOK &&
                        pMstr->dwClickLockTime != dwTempClickLockTime)
                      {
                      pMstr->dwClickLockTime = dwTempClickLockTime;
                      SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                      }
                    else if (lRet == IDCANCEL)
                      {
                      //set back
                      DWORD dwClTime = pMstr->dwClickLockTime;
                      SystemParametersInfo(SPI_SETMOUSECLICKLOCKTIME, 
                                            0,
                                            IntToPtr(LOWORD(dwClTime)), 
                                            0);
                      }
                                      
                    }

                  break;
                }


                case ( IDBTN_BUTTONSWAP) :
                {                   
                    pMstr->bSwap = !pMstr->bSwap;                     
                    SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                    SystemParametersInfo( SPI_SETMOUSEBUTTONSWAP,
                          pMstr->bSwap,
                          NULL,
                          0);
                    ShowButtonState(pMstr);                   
                }



#ifdef SHELL_SINGLE_CLICK
                case ( MOUSE_SGLCLICK ) :
                case ( MOUSE_DBLCLICK ) :
                {
                    if( pMstr->bShellSingleClick != (MOUSE_SGLCLICK == LOWORD(wParam)) )
                    {
                        pMstr->bShellSingleClick = (MOUSE_SGLCLICK == LOWORD(wParam)) ;
                        ShellClick_UpdateUI( hDlg, pMstr ) ;
                        SendMessage( GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L ) ;
                    }
                    break ;
                }
#endif // SHELL_SINGLE_CLICK


            }
            break;
        }
        case ( WM_NOTIFY ) :
        {
            switch (((NMHDR *)lParam)->code)
            {
                case ( PSN_APPLY ) :
                {
                    HourGlass(TRUE);


                    //
                    // Apply Button Swap setting.
                    //
                    if (pMstr->bSwap != pMstr->bOrigSwap)
                    {
                        SystemParametersInfo( SPI_SETMOUSEBUTTONSWAP,
                                              pMstr->bSwap,
                                              NULL,
                                              SPIF_UPDATEINIFILE |
                                                SPIF_SENDWININICHANGE );
                        pMstr->bOrigSwap = pMstr->bSwap;
                    }
          
                    // 
                    // Apply DoubleClickTime setting.
                    //
                    if (pMstr->ClickSpeed != pMstr->OrigDblClkSpeed)
                    {
                        SystemParametersInfo( SPI_SETDOUBLECLICKTIME,
                                              pMstr->ClickSpeed,
                                              NULL,
                                              SPIF_UPDATEINIFILE |
                                                SPIF_SENDWININICHANGE );
                        pMstr->OrigDblClkSpeed = pMstr->ClickSpeed;
                    }


                    // 
                    // Apply ClickLock setting.
                    //
                    if (pMstr->bClickLock != pMstr->bOrigClickLock)
                    {
                        SystemParametersInfo(SPI_SETMOUSECLICKLOCK,     
                                              0,
                                              IntToPtr(pMstr->bClickLock),     
                                              SPIF_UPDATEINIFILE | 
                                                SPIF_SENDWININICHANGE);   
                        pMstr->bOrigClickLock = pMstr->bClickLock;
                    }

                    // 
                    // Apply ClickLockTime setting.
                    //                    
                    if (pMstr->dwClickLockTime != pMstr->dwOrigClickLockTime)
                    {    
                        SystemParametersInfo(SPI_SETMOUSECLICKLOCKTIME, 
                                              0,
                                              (PVOID) (LOWORD(pMstr->dwClickLockTime)), 
                                              SPIF_UPDATEINIFILE |
                                                SPIF_SENDWININICHANGE );

                        pMstr->dwOrigClickLockTime = pMstr->dwClickLockTime;
                    }



#ifdef SHELL_SINGLE_CLICK
                    if( pMstr->bOrigShellSingleClick != pMstr->bShellSingleClick )
                    {
                        SHELLSTATE shellstate = {0} ;
                        ULONG      dwFlags = SSF_DOUBLECLICKINWEBVIEW ;

                        shellstate.fWin95Classic =
                        shellstate.fDoubleClickInWebView = !pMstr->bShellSingleClick ;

                        // update the WIN95CLASSIC member only if we've chosen single-click.
                        if( pMstr->bShellSingleClick )
                            dwFlags |= SSF_WIN95CLASSIC ;

                        SHGetSetSettings( &shellstate, dwFlags, TRUE ) ;
                        ShellClick_Refresh( pMstr ) ;

                        pMstr->bOrigShellSingleClick = pMstr->bShellSingleClick ;
                    }
#endif //SHELL_SINGLE_CLICK

                    HourGlass(FALSE);
                    break;
                }
                case ( PSN_RESET ) :
                {
                  //
                  // Reset Button Swap setting.
                  //
                  if (pMstr->bSwap != pMstr->bOrigSwap)
                  {
                      SystemParametersInfo( SPI_SETMOUSEBUTTONSWAP,
                                            pMstr->bOrigSwap,
                                            NULL,
                                            0);
                  }
        
                  // 
                  // Reset DoubleClickTime setting.
                  //
                  if (pMstr->ClickSpeed != pMstr->OrigDblClkSpeed)
                  {
                      SystemParametersInfo( SPI_SETDOUBLECLICKTIME,
                                            pMstr->OrigDblClkSpeed,
                                            NULL,
                                            0);
                  }


                  // 
                  // Reset ClickLock setting.
                  //
                  if (pMstr->bClickLock != pMstr->bOrigClickLock)
                  {
                      SystemParametersInfo(SPI_SETMOUSECLICKLOCK,     
                                            0,
                                            IntToPtr(pMstr->bOrigClickLock),     
                                            0);
                  }

                  // 
                  // Reset ClickLockTime setting.
                  //                    
                  if (pMstr->dwClickLockTime != pMstr->dwOrigClickLockTime)
                  {    
                      SystemParametersInfo(SPI_SETMOUSECLICKLOCKTIME, 
                                            0,
                                            (PVOID) (LOWORD(pMstr->dwOrigClickLockTime)), 
                                            0);
                  }



#ifdef SHELL_SINGLE_CLICK
                  if( pMstr->bOrigShellSingleClick != pMstr->bShellSingleClick )
                  {
                      SHELLSTATE shellstate = {0} ;
                      ULONG      dwFlags = SSF_DOUBLECLICKINWEBVIEW ;

                      shellstate.fWin95Classic =
                      shellstate.fDoubleClickInWebView = !pMstr->bOrigShellSingleClick ;

                      // update the WIN95CLASSIC member only if we've chosen single-click.
                      if( pMstr->bShellSingleClick )
                          dwFlags |= SSF_WIN95CLASSIC ;

                      SHGetSetSettings( &shellstate, dwFlags, TRUE ) ;
                      ShellClick_Refresh( pMstr ) ;

                      pMstr->bShellSingleClick  = pMstr->bOrigShellSingleClick ;
                  }
#endif //SHELL_SINGLE_CLICK

                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_HELP ) :             // F1
        {
            WinHelp( ((LPHELPINFO)lParam)->hItemHandle,
                     HELP_FILE,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aMouseButHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND) wParam,
                     HELP_FILE,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aMouseButHelpIds );
            break;
        }

        case ( WM_DISPLAYCHANGE ) :
        case ( WM_WININICHANGE ) :
        case ( WM_SYSCOLORCHANGE ) :
        {
            SHPropagateMessage(hDlg, message, wParam, lParam, TRUE);
            return TRUE;
        }

        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


#ifdef SHELL_SINGLE_CLICK
////////////////////////////////////////////////////////////////////////////
//
//  ShellClick_UpdateUI
//
//  Assigns the appropriate icon for shell single/double click
//
////////////////////////////////////////////////////////////////////////////
void ShellClick_UpdateUI(
    HWND hDlg,
    PMOUSEBUTSTR pMstr)
{
    HICON hicon = pMstr->bShellSingleClick ? pMstr->hIconSglClick :
                                             pMstr->hIconDblClick ;

    SendMessage( GetDlgItem( hDlg, MOUSE_CLICKICON ), STM_SETICON,
                 (WPARAM)hicon, 0L ) ;
}
#endif //SHELL_SINGLE_CLICK

////////////////////////////////////////////////////////////////////////////
//
//  IsShellWindow
//
//  Determines whether the specified window is a shell folder window.
//
////////////////////////////////////////////////////////////////////////////
#define c_szExploreClass TEXT("ExploreWClass")
#define c_szIExploreClass TEXT("IEFrame")
#ifdef IE3CLASSNAME
#define c_szCabinetClass TEXT("IEFrame")
#else
#define c_szCabinetClass TEXT("CabinetWClass")
#endif

BOOL IsShellWindow( HWND hwnd )
{
    TCHAR szClass[32];

    GetClassName(hwnd, szClass, ARRAYSIZE(szClass));
    return (lstrcmp(szClass, c_szCabinetClass) == 0) ||
           (lstrcmp(szClass, c_szExploreClass) == 0) ||
           (lstrcmp(szClass, c_szIExploreClass) == 0) ;
}

//The following value is taken from shdocvw\rcids.h
#ifndef FCIDM_REFRESH
#define FCIDM_REFRESH  0xA220
#endif // FCIDM_REFRESH

////////////////////////////////////////////////////////////////////////////
//
//  ShellClick_RefreshEnumProc
//
//  EnumWindow callback for shell refresh.
//
////////////////////////////////////////////////////////////////////////////
BOOL CALLBACK ShellClick_RefreshEnumProc( HWND hwnd, LPARAM lParam )
{
    if( IsShellWindow(hwnd) )
        PostMessage(hwnd, WM_COMMAND, FCIDM_REFRESH, 0L);

    return(TRUE);
}

////////////////////////////////////////////////////////////////////////////
//
//  ShellClick_Refresh
//
//  Re-renders the contents of all shell folder windows.
//
////////////////////////////////////////////////////////////////////////////
void ShellClick_Refresh( PMOUSEBUTSTR pMstr )
{
    HWND hwndDesktop = FindWindowEx(NULL, NULL, TEXT(STR_DESKTOPCLASS), NULL);

    if( NULL != hwndDesktop )
       PostMessage( hwndDesktop, WM_COMMAND, FCIDM_REFRESH, 0L );

    EnumWindows( ShellClick_RefreshEnumProc, 0L ) ;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\main\mousectl.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mousectl.c

Abstract:

    This module contains the routines for the Mouse control.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "mousectl.h"
#include "rc.h"



//
//  Constant Declarations.
//

#define MOUSECTL_BITMAP_NAME          MAKEINTRESOURCE(IDB_MOUSE)

#define MOUSECTL_DATA                 0

//
//  These are indices into the VGA palette!
//
#define MOUSECTL_BKGND_INDEX          14    // light cyan
#define MOUSECTL_LBUTTON_INDEX        13    // light magenta
#define MOUSECTL_RBUTTON_INDEX        11    // light yellow
#define MOUSECTL_LBUTTON_ALTERNATE    5     // magenta
#define MOUSECTL_RBUTTON_ALTERNATE    3     // yellow

#define MOUSECTL_NORMAL_COLOR         RGB(255, 255, 255)

#define HALFRGB(c)  RGB(GetRValue(c) / 2, GetGValue(c) / 2, GetBValue(c) / 2)




//
//  Typedef Declarations.
//

typedef struct tagMOUSECTLDATA
{
    HWND     window;         // window handle for this control
    BOOL     swapped;        // are the buttons swapped?

    HBITMAP  image;          // DIB section image of mouse
    HDC      imagedc;        // DC where image lives
    HBITMAP  olddcimage;     // previous inhabitant of imagedc

    POINT    offset;         // offset of bitmap in control
    SIZE     size;           // size of bitmap

} MOUSECTLDATA, *PMOUSECTLDATA;




//
//  Forward Declarations.
//

LRESULT CALLBACK
MouseControlWndProc(
    HWND window,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

void
MouseControlShowSwap(
    PMOUSECTLDATA ctldata);





////////////////////////////////////////////////////////////////////////////
//
//  SetMouseControlData
//
////////////////////////////////////////////////////////////////////////////

__inline void SetMouseControlData(
    HWND window,
    PMOUSECTLDATA ctldata)
{
    SetWindowLongPtr(window, MOUSECTL_DATA, (LONG_PTR)ctldata);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMouseControlData
//
////////////////////////////////////////////////////////////////////////////

__inline PMOUSECTLDATA GetMouseControlData(
    HWND window)
{
    return ((PMOUSECTLDATA)GetWindowLongPtr(window, MOUSECTL_DATA));
}


////////////////////////////////////////////////////////////////////////////
//
//  RegisterMouseControlStuff
//
////////////////////////////////////////////////////////////////////////////

BOOL RegisterMouseControlStuff(
    HINSTANCE instance)
{
    WNDCLASS wc;

    wc.style         = 0;
    wc.lpfnWndProc   = MouseControlWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PMOUSECTLDATA);
    wc.hInstance     = instance;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1);
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = MOUSECTL_CLASSNAME;

    return (RegisterClass(&wc));
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateMouseControlData
//
////////////////////////////////////////////////////////////////////////////

PMOUSECTLDATA CreateMouseControlData(
    HWND window)
{
    PMOUSECTLDATA ctldata = (PMOUSECTLDATA)LocalAlloc(LPTR, sizeof(MOUSECTLDATA));

    if (ctldata)
    {
        ctldata->window = window;
        SetMouseControlData(window, ctldata);
    }

    return (ctldata);
}


////////////////////////////////////////////////////////////////////////////
//
//  DestroyMouseControlData
//
////////////////////////////////////////////////////////////////////////////

void DestroyMouseControlData(
    PMOUSECTLDATA ctldata)
{
    if (ctldata)
    {
        SetMouseControlData(ctldata->window, 0);

        LocalFree(ctldata);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlNCCreate
//
////////////////////////////////////////////////////////////////////////////

BOOL MouseControlNCCreate(
    PMOUSECTLDATA ctldata,
    LPCREATESTRUCT cs)
{
    if (!ctldata)
    {
        return (FALSE);
    }

    ctldata->image = LoadImage( cs->hInstance,
                                MOUSECTL_BITMAP_NAME,
                                IMAGE_BITMAP,
                                0,
                                0,
                                LR_CREATEDIBSECTION );

    if (ctldata->image)
    {
        ctldata->imagedc = CreateCompatibleDC(NULL);

        if (ctldata->imagedc)
        {
            BITMAP bm;

            ctldata->olddcimage =
                SelectBitmap(ctldata->imagedc, ctldata->image);

            ctldata->offset.x = ctldata->offset.y = 0;

            if (GetObject(ctldata->image, sizeof(BITMAP), &bm))
            {
                ctldata->size.cx  = bm.bmWidth;
                ctldata->size.cy  = bm.bmHeight;
                ctldata->offset.x = (cs->cx - ctldata->size.cx) / 2;
                ctldata->offset.y = (cs->cy - ctldata->size.cy) / 2;

                ctldata->swapped = FALSE;
                MouseControlShowSwap(ctldata);
                return (TRUE);
            }

            SelectBitmap(ctldata->imagedc, ctldata->olddcimage);
            ctldata->olddcimage = NULL;
        }

        DeleteBitmap(ctldata->image);
        ctldata->image = NULL;
    }

    ctldata->olddcimage = NULL;
    ctldata->imagedc    = NULL;

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlNCDestroy
//
////////////////////////////////////////////////////////////////////////////

void MouseControlNCDestroy(
    PMOUSECTLDATA ctldata)
{
    if (ctldata)
    {
        if (ctldata->olddcimage)
        {
            SelectBitmap(ctldata->imagedc, ctldata->olddcimage);
            ctldata->olddcimage = NULL;
        }

        if (ctldata->imagedc)
        {
            DeleteDC(ctldata->imagedc);
            ctldata->imagedc = NULL;
        }

        if (ctldata->image)
        {
            DeleteBitmap(ctldata->image);
            ctldata->image = NULL;
        }

        DestroyMouseControlData(ctldata);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlPaint
//
////////////////////////////////////////////////////////////////////////////

void MouseControlPaint(
    PMOUSECTLDATA ctldata)
{
    PAINTSTRUCT ps;
    HDC dc = BeginPaint(ctldata->window, &ps);

    BitBlt( dc,
            ctldata->offset.x,
            ctldata->offset.y,
            ctldata->size.cx,
            ctldata->size.cy,
            ctldata->imagedc,
            0,
            0,
            SRCCOPY|NOMIRRORBITMAP);

    EndPaint(ctldata->window, &ps);
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlSetColor
//
////////////////////////////////////////////////////////////////////////////

__inline void MouseControlSetColor(
    PMOUSECTLDATA ctldata,
    UINT index,
    COLORREF color)
{
    RGBQUAD rgbq = { GetBValue(color), GetGValue(color), GetRValue(color), 0 };

    SetDIBColorTable(ctldata->imagedc, index, 1, &rgbq);
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlShowSwap
//
////////////////////////////////////////////////////////////////////////////

void MouseControlShowSwap(
    PMOUSECTLDATA ctldata)
{
    MouseControlSetColor( ctldata,
                          MOUSECTL_BKGND_INDEX,
                          GetSysColor(COLOR_BTNFACE) );

    MouseControlSetColor( ctldata,
                          ctldata->swapped
                            ? MOUSECTL_RBUTTON_INDEX
                            : MOUSECTL_LBUTTON_INDEX,
                          GetSysColor(COLOR_HIGHLIGHT) );

    MouseControlSetColor( ctldata,
                          ctldata->swapped
                            ? MOUSECTL_RBUTTON_ALTERNATE
                            : MOUSECTL_LBUTTON_ALTERNATE,
                          HALFRGB(GetSysColor(COLOR_HIGHLIGHT)) );

    MouseControlSetColor( ctldata,
                          ctldata->swapped
                            ? MOUSECTL_LBUTTON_INDEX
                            : MOUSECTL_RBUTTON_INDEX,
                          MOUSECTL_NORMAL_COLOR );

    MouseControlSetColor( ctldata,
                          ctldata->swapped
                            ? MOUSECTL_LBUTTON_ALTERNATE
                            : MOUSECTL_RBUTTON_ALTERNATE,
                          HALFRGB(MOUSECTL_NORMAL_COLOR) );

    InvalidateRect(ctldata->window, NULL, FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlSetSwap
//
////////////////////////////////////////////////////////////////////////////

void MouseControlSetSwap(
    HWND window,
    BOOL swap)
{
    PMOUSECTLDATA ctldata = GetMouseControlData(window);

    if (ctldata->swapped != swap)
    {
        ctldata->swapped = swap;
        MouseControlShowSwap(ctldata);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MouseControlWndProc
//
////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK MouseControlWndProc(
    HWND window,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PMOUSECTLDATA ctldata = (message == WM_NCCREATE)
                              ? CreateMouseControlData(window)
                              : GetMouseControlData(window);

    switch (message)
    {
        HANDLE_MSG(ctldata, WM_NCCREATE,  MouseControlNCCreate );
        HANDLE_MSG(ctldata, WM_NCDESTROY, MouseControlNCDestroy);
        HANDLE_MSG(ctldata, WM_PAINT,     MouseControlPaint    );
    }

    return (DefWindowProc(window, message, wParam, lParam));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\main\mousehlp.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:
    mousehlp.h
Abstract:
    This module contains the header information for the Mouse help.

Revision History:
--*/

//  ID values for Mouse property sheet.

#define IDH_COMM_GROUPBOX               28548

// Buttons tab
#define IDH_MOUSE_SWITCH	 	        3000	// Switch primary and secondary buttons check box
#define IDH_MOUSE_SWITCH_PIC  		    3001	// Button configuration picture
#define IDH_MOUSE_DOUBLECLICK	 	    3002	// Double-click text and slider
#define IDH_MOUSE_DCLICK_TEST_BOX  	    3003	// Double-click speed test area
#define IDH_MOUSE_CLKLCK_CHKBOX		    3004	// ClickLock check box and text
#define IDH_MOUSE_CLKLCK_SETTINGS_BTN	3005	// ClickLock Settings button
#define IDH_MOUSE_CLKLCK_DIALOG		    3006	// Settings dialog (entire dialog)

// Pointers tab
#define IDH_MOUSE_POINT_SCHEME      	3010	// Scheme list box
#define IDH_MOUSE_POINT_DEL     	    3011	// Scheme Delete button
#define IDH_MOUSE_POINT_SAVEAS     	    3012	// Scheme Save As button
#define IDH_MOUSE_POINT_PREVIEW      	3013	// Scheme Preview box
#define IDH_MOUSE_POINT_BROWSE      	3014	// Browse button
#define IDH_MOUSE_POINT_LIST      	    3015	// Customize list box
#define IDH_MOUSE_POINT_DEFAULT      	3016	// Use Default button
#define IDH_MOUSE_NEW_SCHEME_NAME      	3017	// Save As dialog box
#define IDH_MOUSE_CURSORSHADOW      	3030	// Mouse Shadow check box
#define IDH_MOUSE_ENHANCED_MOTION       3031    // Enhanced motion checkbox

// Pointer Options tab
#define IDH_MOUSE_POINTERSPEED	 	    3020	// Text and slider
#define IDH_MOUSE_ADVANCED_BTN	 	    3021	// Advanced button
#define IDH_MOUSE_ACCELERATION_DLG	    3022	// Entire Advanced Settings dialog box
#define IDH_MOUSE_SNAPTO		        3023	// Text and check box
#define IDH_MOUSE_POINTER_TRAILS	    3024	// Includes slider
#define IDH_MOUSE_VANISH		        3025	// Hide pointer check box and text
#define IDH_MOUSE_SONAR			        3026	// Show location check box and text

// Wheel tab
#define IDH_MOUSE_WHEEL_SCROLLING	    3028	// Includes entire control
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\main\mouseptr.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mouseptr.c

Abstract:

    This module contains the routines for the Mouse Pointer Property Sheet
    page.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "rc.h"
#include "mousehlp.h"
#include <regstr.h>

//
// From shell\inc\shsemip.h
//
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))



//
//  Constant Declarations.
//

#define gcxAvgChar              8

#define MAX_SCHEME_NAME_LEN     64
#define MAX_SCHEME_SUFFIX       32      // length of " (system scheme)" - update if more space is needed
#define OVERWRITE_TITLE         32      // length of title for the confirm overwrite dialog
#define OVERWRITE_MSG           200     // length of the message for the overwrite dialog

#define PM_NEWCURSOR            (WM_USER + 1)
#define PM_PAUSEANIMATION       (WM_USER + 2)
#define PM_UNPAUSEANIMATION     (WM_USER + 3)

#define ID_PREVIEWTIMER         1

#define CCH_ANISTRING           80

#define CIF_FILE        0x0001
#define CIF_MODIFIED    0x0002
#define CIF_SHARED      0x0004

#define IDT_BROWSE 1




//
//  Typedef Declarations.
//

typedef struct _CURSOR_INFO
{
    DWORD    fl;
    HCURSOR  hcur;
    int      ccur;
    int      icur;
    TCHAR    szFile[MAX_PATH];
} CURSOR_INFO, *PCURSOR_INFO;

#pragma pack(2)
typedef struct tagNEWHEADER
{
    WORD reserved;
    WORD rt;
    WORD cResources;
} NEWHEADER, *LPNEWHEADER;
#pragma pack()

typedef struct
{
    UINT   idVisName;
    int    idResource;
    int    idDefResource;
    LPTSTR pszIniName;
    TCHAR  szVisName[MAX_PATH];
} CURSORDESC, *PCURSORDESC;

//
// Structure that contains data used within a preview window.  This
// data is unique for each preview window, and is used to optimize
// the painting.
//
typedef struct
{
    HDC          hdcMem;
    HBITMAP      hbmMem;
    HBITMAP      hbmOld;
    PCURSOR_INFO pcuri;
} PREVIEWDATA, *PPREVIEWDATA;


typedef struct _MOUSEPTRBR
{
    HWND        hDlg;
    CURSOR_INFO curi;
} MOUSEPTRBR, *PMOUSEPTRBR;




//
//  Global Variables.
//

extern HINSTANCE g_hInst;    // from main.c
int gcxCursor, gcyCursor;
HWND ghwndDlg, ghwndFile, ghwndFileH, ghwndTitle, ghwndTitleH;
HWND ghwndCreator, ghwndCreatorH, ghwndCursors, ghwndPreview, ghwndSchemeCB;
HBRUSH ghbrHighlight, ghbrHighlightText, ghbrWindow, ghbrButton;

UINT guTextHeight = 0;
UINT guTextGap = 0;

COLORREF gcrHighlightText;

TCHAR gszFileName2[MAX_PATH];

UINT wBrowseHelpMessage;

LPTSTR gszFileNotFound = NULL;
LPTSTR gszBrowse = NULL;
LPTSTR gszFilter = NULL;

TCHAR gszNoMem[256] = TEXT("No Memory");

HHOOK ghhkMsgFilter;         // hook handle for message filter function

static const TCHAR szRegStr_Setup[] = REGSTR_PATH_SETUP TEXT("\\Setup");
static const TCHAR szSharedDir[]    = TEXT("SharedDir");

BOOL gfCursorShadow = FALSE;

//
//  Make sure you add new cursors to the end of this array.
//  Otherwise the cursor schemes will not work
//
CURSORDESC gacd[] =
{
    { IDS_ARROW,       OCR_NORMAL,      OCR_ARROW_DEFAULT,       TEXT("Arrow"),       TEXT("") },
    { IDS_HELPCUR,     OCR_HELP,        OCR_HELP_DEFAULT,        TEXT("Help"),        TEXT("") },
    { IDS_APPSTARTING, OCR_APPSTARTING, OCR_APPSTARTING_DEFAULT, TEXT("AppStarting"), TEXT("") },
    { IDS_WAIT,        OCR_WAIT,        OCR_WAIT_DEFAULT,        TEXT("Wait"),        TEXT("") },
    { IDS_CROSS,       OCR_CROSS,       OCR_CROSS_DEFAULT,       TEXT("Crosshair"),   TEXT("") },
    { IDS_IBEAM,       OCR_IBEAM,       OCR_IBEAM_DEFAULT,       TEXT("IBeam"),       TEXT("") },
    { IDS_NWPEN,       OCR_NWPEN,       OCR_NWPEN_DEFAULT,       TEXT("NWPen"),       TEXT("") },
    { IDS_NO,          OCR_NO,          OCR_NO_DEFAULT,          TEXT("No"),          TEXT("") },
    { IDS_SIZENS,      OCR_SIZENS,      OCR_SIZENS_DEFAULT,      TEXT("SizeNS"),      TEXT("") },
    { IDS_SIZEWE,      OCR_SIZEWE,      OCR_SIZEWE_DEFAULT,      TEXT("SizeWE"),      TEXT("") },
    { IDS_SIZENWSE,    OCR_SIZENWSE,    OCR_SIZENWSE_DEFAULT,    TEXT("SizeNWSE"),    TEXT("") },
    { IDS_SIZENESW,    OCR_SIZENESW,    OCR_SIZENESW_DEFAULT,    TEXT("SizeNESW"),    TEXT("") },
    { IDS_SIZEALL,     OCR_SIZEALL,     OCR_SIZEALL_DEFAULT,     TEXT("SizeAll"),     TEXT("") },
    { IDS_UPARROW,     OCR_UP,          OCR_UPARROW_DEFAULT,     TEXT("UpArrow"),     TEXT("") },
    { IDS_HANDCUR,     OCR_HAND,        OCR_HAND_DEFAULT,        TEXT("Hand"),        TEXT("") },
};

#define CCURSORS   (sizeof(gacd) / sizeof(gacd[0]))

CURSOR_INFO acuri[CCURSORS];

//
//  Registry Keys.
//
const TCHAR szCursorSubdir[]  = TEXT("Cursors");
const TCHAR szCursorRegPath[] = REGSTR_PATH_CURSORS;

static const TCHAR c_szRegPathCursors[] = REGSTR_PATH_CURSORS;
static const TCHAR c_szSchemes[]        = TEXT("Schemes");

static const TCHAR c_szRegPathCursorSchemes[] = REGSTR_PATH_CURSORS TEXT( "\\Schemes" );

//
//  Strings used to read from the combo box must be larger than max length.
//
TCHAR gszSchemeName[MAX_SCHEME_SUFFIX + MAX_SCHEME_NAME_LEN + 1];    // used to store selected scheme name for saving
int iSchemeLocation;        // used to store scheme location (HKCU vs HKLM)

static const TCHAR c_szRegPathSystemSchemes[] = REGSTR_PATH_SETUP TEXT("\\Control Panel\\Cursors\\Schemes");
TCHAR szSystemScheme[MAX_SCHEME_SUFFIX];
TCHAR szNone[MAX_SCHEME_NAME_LEN + 1];
const TCHAR szSchemeSource[] = TEXT("Scheme Source");

TCHAR gszPreviousScheme[MAX_SCHEME_SUFFIX + MAX_SCHEME_NAME_LEN + 1];   // used to tell if a different scheme is selected

#define ID_NONE_SCHEME    0
#define ID_USER_SCHEME    1
#define ID_OS_SCHEME      2




//
//  Context Help Ids.
//

const static DWORD aMousePtrHelpIDs[] =
{
    IDC_GROUPBOX_1,    IDH_COMM_GROUPBOX,
    ID_SCHEMECOMBO,    IDH_MOUSE_POINT_SCHEME,
    ID_SAVESCHEME,     IDH_MOUSE_POINT_SAVEAS,
    ID_REMOVESCHEME,   IDH_MOUSE_POINT_DEL,
    ID_PREVIEW,        IDH_MOUSE_POINT_PREVIEW,
    ID_CURSORLIST,     IDH_MOUSE_POINT_LIST,
    ID_DEFAULT,        IDH_MOUSE_POINT_DEFAULT,
    ID_BROWSE,         IDH_MOUSE_POINT_BROWSE,
    ID_CURSORSHADOW,   IDH_MOUSE_CURSORSHADOW,

    0, 0
};

const static DWORD aMousePtrBrowseHelpIDs[] =
{
    IDC_GROUPBOX_1,    IDH_MOUSE_POINT_PREVIEW,
    ID_CURSORPREVIEW,  IDH_MOUSE_POINT_PREVIEW,

    0, 0
};

const static DWORD aHelpIDs[] =
{
    ID_SCHEMEFILENAME, IDH_MOUSE_NEW_SCHEME_NAME,

    0, 0
};




//
//  Forward Declarations.
//

void LoadCursorSet(HWND hwnd);

void CreateBrushes(void);

LPTSTR GetResourceString(HINSTANCE hmod,int id);

void DrawCursorListItem(DRAWITEMSTRUCT *pdis);

BOOL GetCursorFromFile(CURSOR_INFO *pcuri);

BOOL Browse(HWND hwndOwner);

void CleanUpEverything(void);

VOID UpdateCursorList(void);

VOID NextFrame(HWND hwnd);

void HourGlass(BOOL fOn);

BOOL TryToLoadCursor(
    HWND hwnd,
    int i,
    CURSOR_INFO *pcuri);

BOOL LoadScheme(void);

BOOL SaveScheme(void);

BOOL SaveSchemeAs(void);

void SaveCurSchemeName(void);

BOOL RemoveScheme(void);

BOOL InitSchemeComboBox(void);

BOOL SchemeUpdate(int i);

LPTSTR MakeFilename(LPTSTR sz);

INT_PTR CALLBACK SaveSchemeDlgProc(
    HWND  hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

void CurStripBlanks(LPTSTR pszString, int cchString);

int SystemOrUser(TCHAR *pszSchemeName);

BOOL UnExpandPath(LPTSTR pszPath, int cchPath);




////////////////////////////////////////////////////////////////////////////
//
//  RegisterPointerStuff
//
////////////////////////////////////////////////////////////////////////////

BOOL RegisterPointerStuff(
    HINSTANCE hi)
{
    gcxCursor = GetSystemMetrics(SM_CXCURSOR);
    gcyCursor = GetSystemMetrics(SM_CYCURSOR);

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitCursorsShadow
//
////////////////////////////////////////////////////////////////////////////

void InitCursorShadow(HWND hwnd)
{
    BOOL fPalette;
    HDC hdc;
    int nCommand;

    hdc = GetDC(NULL);
    fPalette = (GetDeviceCaps(hdc, NUMCOLORS) != -1);
    ReleaseDC(NULL, hdc);

    if (!fPalette) {
        nCommand = SW_SHOW;
    } else {
        nCommand = SW_HIDE;
    }
    ShowWindow(GetDlgItem(hwnd, ID_CURSORSHADOW), nCommand);

    if (nCommand == SW_SHOW) {
        SystemParametersInfo(SPI_GETCURSORSHADOW, 0, (PVOID)&gfCursorShadow, 0);
        CheckDlgButton(hwnd, ID_CURSORSHADOW, gfCursorShadow);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  InitCursorsDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL InitCursorsDlg(HWND hwnd)
{
    int i;
    ghwndDlg = hwnd;
    gszPreviousScheme[0] = TEXT('\0');

    //
    //  Register the help message from the File Open (Browse) dialog.
    //
    wBrowseHelpMessage = RegisterWindowMessage(HELPMSGSTRING);

    //
    //  Load Strings.
    //
    if (gszFileNotFound == NULL)
    {
        gszFileNotFound = GetResourceString(g_hInst, IDS_CUR_BADFILE);

        if (gszFileNotFound == NULL)
        {
            return (FALSE);
        }
    }

    if (gszBrowse == NULL)
    {
        gszBrowse = GetResourceString(g_hInst, IDS_CUR_BROWSE);

        if (gszBrowse == NULL)
        {
            return (FALSE);
        }
    }

#ifdef WINNT
    if (gszFilter == NULL)
    {
        gszFilter = GetResourceString(g_hInst, IDS_ANICUR_FILTER);

        if (!gszFilter)
        {
            return (FALSE);
        }
    }
#else
    if (gszFilter == NULL)
    {
        HDC  dc = GetDC(NULL);
        BOOL fAni = (GetDeviceCaps(dc, CAPS1) & C1_COLORCURSOR) != 0;

        ReleaseDC(NULL, dc);

        gszFilter = GetResourceString( g_hInst,
                                       fAni
                                         ? IDS_ANICUR_FILTER
                                         : IDS_CUR_FILTER );

        if (!gszFilter)
        {
            return (FALSE);
        }
    }
#endif

    //
    //  Load description strings from the resource file.
    //
    for (i = 0; i < CCURSORS; i++)
    {
        if ((!gacd[i].idVisName) ||
            (LoadString( g_hInst,
                         gacd[i].idVisName,
                         gacd[i].szVisName,
                         ARRAYSIZE(gacd[i].szVisName) ) <= 0))
        {
            //
            //  Show something.
            //
            StringCchCopy(gacd[i].szVisName, ARRAYSIZE(gacd[i].szVisName), gacd[i].pszIniName);
        }
    }

    //
    //  As an optimization, remember the window handles of the cursor
    //  information fields.
    //
    ghwndPreview  = GetDlgItem(hwnd, ID_PREVIEW);
    ghwndFile     = GetDlgItem(hwnd, ID_FILE);
    ghwndFileH    = GetDlgItem(hwnd, ID_FILEH);
    ghwndTitle    = GetDlgItem(hwnd, ID_TITLE);
    ghwndTitleH   = GetDlgItem(hwnd, ID_TITLEH);
    ghwndCreator  = GetDlgItem(hwnd, ID_CREATOR);
    ghwndCreatorH = GetDlgItem(hwnd, ID_CREATORH);
    ghwndCursors  = GetDlgItem(hwnd, ID_CURSORLIST);
    ghwndSchemeCB = GetDlgItem(hwnd, ID_SCHEMECOMBO);

    //
    //  Create some brushes we'll be using.
    //
    CreateBrushes();

    //
    //  Initialize the scheme combo box.
    //
    InitSchemeComboBox();

    //
    //  Pre-clear the cursor info array.
    //
    ZeroMemory(&acuri, sizeof(acuri));

    //
    //  Load the cursors.
    //
    LoadCursorSet(hwnd);

    //
    //  Force an update of the preview window and the cursor details.
    //
    UpdateCursorList();

    InitCursorShadow(hwnd);

    return (TRUE);
}



////////////////////////////////////////////////////////////////////////////
//
//  LoadCursorSet
//
////////////////////////////////////////////////////////////////////////////

void LoadCursorSet(
    HWND hwnd)
{
    CURSOR_INFO *pcuri;
    HKEY hkCursors;
    int i;

    if (RegOpenKeyEx(HKEY_CURRENT_USER, szCursorRegPath, 0, KEY_READ, &hkCursors) != ERROR_SUCCESS)
    {
        hkCursors = NULL;
    }

    for (pcuri = &acuri[0], i = 0; i < CCURSORS; i++, pcuri++)
    {
        if ( hkCursors )
        {
            DWORD dwType;
            DWORD dwCount = sizeof(pcuri->szFile);

            DWORD dwErr = RegQueryValueEx( hkCursors,
                              gacd[i].pszIniName,
                              NULL,
                              &dwType,
                              (LPBYTE)pcuri->szFile,
                              &dwCount );

            if (dwErr == ERROR_SUCCESS)
            {
                if (TryToLoadCursor(hwnd, i, pcuri))
                {
                    goto EverythingWorked;
                }
            }
        }

        // This is actually the failure case.  We load the default cursor.
        pcuri->hcur =
            (HCURSOR)LoadImage( NULL,
                                MAKEINTRESOURCE(gacd[i].idResource),
                                IMAGE_CURSOR,
                                0,
                                0,
                                LR_SHARED | LR_DEFAULTSIZE | LR_ENVSUBST );

        pcuri->fl |= CIF_SHARED;

EverythingWorked:

        SendMessage(ghwndCursors, LB_ADDSTRING, 0, (LPARAM)gacd[i].szVisName);
        SendMessage(ghwndCursors, LB_SETITEMDATA, i, i);
    }

    if (hkCursors)
    {
        RegCloseKey(hkCursors);
    }

    SendMessage(ghwndCursors, LB_SETCURSEL, 0, 0);
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateBrushes
//
//  Creates the brushes that are used to paint within the Cursors applet.
//
////////////////////////////////////////////////////////////////////////////

VOID CreateBrushes()
{
    ghbrHighlight     = GetSysColorBrush(COLOR_HIGHLIGHT);
    gcrHighlightText  = GetSysColor(COLOR_HIGHLIGHTTEXT);
    ghbrHighlightText = GetSysColorBrush(COLOR_HIGHLIGHTTEXT);
    ghbrWindow        = GetSysColorBrush(COLOR_WINDOW);
    ghbrButton        = GetSysColorBrush(COLOR_BTNFACE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetResourceString
//
//  Gets a string out of the resource file.
//
////////////////////////////////////////////////////////////////////////////

LPTSTR GetResourceString(
    HINSTANCE hmod,
    int id)
{
    TCHAR szBuffer[256];
    LPTSTR psz;
    int cch;

    if ((cch = LoadString(hmod, id, szBuffer, ARRAYSIZE(szBuffer))) == 0)
    {
        return (NULL);
    }

    psz = LocalAlloc(LPTR, (cch + 1) * sizeof(TCHAR));

    if (psz != NULL)
    {
        int i;

        for (i = 0; i <= cch; i++)
        {
            psz[i] = (szBuffer[i] == TEXT('\1')) ? TEXT('\0') : szBuffer[i];
        }
    }

    return (psz);
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeItemCursor
//
////////////////////////////////////////////////////////////////////////////

void FreeItemCursor(
    CURSOR_INFO *pcuri)
{
    if (pcuri->hcur)
    {
        if (!(pcuri->fl & CIF_SHARED))
        {
            DestroyCursor(pcuri->hcur);
        }
        pcuri->hcur = NULL;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MousePtrDlg
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK MousePtrDlg(
    HWND hwnd,
    UINT msg,
    WPARAM wParam,
    LPARAM lParam)
{
    CURSOR_INFO *pcuri;
    HKEY hkCursors;
    int i;

    switch (msg)
    {
        case ( WM_INITDIALOG ) :
        {
            return InitCursorsDlg(hwnd);
        }
        case ( WM_DISPLAYCHANGE ) :
        {
            InitCursorShadow(hwnd);
            SHPropagateMessage(hwnd, msg, wParam, lParam, TRUE);
            break;
        }
        case ( WM_MEASUREITEM ) :
        {
            ((MEASUREITEMSTRUCT *)lParam)->itemHeight = gcyCursor + 2;
            break;
        }
        case ( WM_DRAWITEM ) :
        {
            DrawCursorListItem((DRAWITEMSTRUCT *)lParam);
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( ID_SCHEMECOMBO ) :
                {
                    switch (HIWORD(wParam))
                    {
                        case ( CBN_SELCHANGE ) :
                        {
                            LoadScheme();
                            break;
                        }
                    }
                    break;
                }
                case ( ID_DEFAULT ) :
                {
                    //
                    //  Throw away any fancy new cursor and replace it with
                    //  the system's original.
                    //
                    i = (int)SendMessage(ghwndCursors, LB_GETCURSEL, 0, 0);

                    pcuri = &acuri[i];

                    if (!(pcuri->fl & CIF_FILE))
                    {
                        break;
                    }
                    pcuri->fl = CIF_MODIFIED;

                    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0L);

                    FreeItemCursor(pcuri);

                    pcuri->hcur =
                        (HCURSOR)LoadImage( NULL,
                                            MAKEINTRESOURCE(gacd[i].idDefResource),
                                            IMAGE_CURSOR,
                                            0,
                                            0,
                                            LR_DEFAULTSIZE | LR_ENVSUBST );

                    *pcuri->szFile = TEXT('\0');

                    EnableWindow(GetDlgItem(hwnd, ID_SAVESCHEME), TRUE);

                    UpdateCursorList();

                    break;
                }
                case ( ID_CURSORLIST ) :
                {
                    switch (HIWORD(wParam))
                    {
                        case ( LBN_SELCHANGE ) :
                        {
                            i = (int)SendMessage((HWND)lParam, LB_GETCURSEL, 0, 0);
                            pcuri = &acuri[i];

                            //
                            //  Show a preview (including animation) in the
                            //  preview window.
                            //
                            SendMessage( ghwndPreview,
                                         STM_SETICON,
                                         (WPARAM)pcuri->hcur,
                                         0L );

                            //
                            //  Enable the "Set Default" button if the cursor
                            //  is from a file.
                            //
                            EnableWindow( GetDlgItem(hwnd, ID_DEFAULT),
                                          (pcuri->fl & CIF_FILE ) ? TRUE : FALSE );
                            break;
                        }
                        case ( LBN_DBLCLK ) :
                        {
                            Browse(hwnd);
                            break;
                        }
                    }
                    break;
                }
                case ( ID_BROWSE ) :
                {
                    Browse(hwnd);
                    break;
                }
                case ( ID_SAVESCHEME ) :
                {
                    SaveSchemeAs();
                    break;
                }
                case ( ID_REMOVESCHEME ) :
                {
                    RemoveScheme();
                    break;
                }
                case ( ID_CURSORSHADOW ) :
                {
                    gfCursorShadow = IsDlgButtonChecked(hwnd, ID_CURSORSHADOW);
                    SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0L);
                    break;
                }
            }
            break;
        }
        case ( WM_NOTIFY ) :
        {
            switch(((NMHDR *)lParam)->code)
            {
                case ( PSN_APPLY ) :
                {
                    //
                    //  Change cursor to hour glass.
                    //
                    HourGlass(TRUE);

                    // Set cursor shadow
                    SystemParametersInfo( SPI_SETCURSORSHADOW,
                                          0,
                                          IntToPtr(gfCursorShadow),
                                          SPIF_UPDATEINIFILE);

                    //
                    //  Save the modified scheme, order of calls important.
                    //
                    SaveCurSchemeName();

                    //
                    //  Set the system cursors.
                    //
                    if (RegCreateKeyEx(HKEY_CURRENT_USER, szCursorRegPath, 0, NULL, 0, KEY_SET_VALUE, NULL, &hkCursors, NULL) == ERROR_SUCCESS)
                    {
                        for (pcuri = &acuri[0], i = 0; i < CCURSORS; i++, pcuri++)
                        {
                            if (pcuri->fl & CIF_MODIFIED)
                            {
                                LPCTSTR data;
                                UINT count;

                                // Always unexpand before we save a filename
                                UnExpandPath(pcuri->szFile, ARRAYSIZE(pcuri->szFile));

                                data = (pcuri->fl & CIF_FILE) ? pcuri->szFile : TEXT("");
                                count = (pcuri->fl & CIF_FILE) ? (lstrlen(pcuri->szFile) + 1) * sizeof(TCHAR) : sizeof(TCHAR);

                                RegSetValueEx(hkCursors, gacd[i].pszIniName, 0L, REG_EXPAND_SZ, (CONST LPBYTE)data, count);
                            }
                        }

                        RegCloseKey(hkCursors);

                        SystemParametersInfo( SPI_SETCURSORS,
                                              0,
                                              0,
                                              SPIF_SENDCHANGE );
                    }

                    HourGlass(FALSE);
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_SYSCOLORCHANGE ) :
        {
            gcrHighlightText = GetSysColor(COLOR_HIGHLIGHTTEXT);
            SHPropagateMessage(hwnd, msg, wParam, lParam, TRUE);
            break;
        }

        case ( WM_WININICHANGE ) :
        {
            SHPropagateMessage(hwnd, msg, wParam, lParam, TRUE);
            break;
        }

        case ( WM_DESTROY ) :
        {
            //
            //  Clean up global allocs.
            //
            CleanUpEverything();

            if (gszFileNotFound != NULL)
            {
                LocalFree(gszFileNotFound);
                gszFileNotFound = NULL;
            }

            if (gszBrowse != NULL)
            {
                LocalFree(gszBrowse);
                gszBrowse = NULL;
            }

            if (gszFilter != NULL)
            {
                LocalFree(gszFilter);
                gszFilter = NULL;
            }
            break;
        }
        case ( WM_HELP ) :
        {
            WinHelp( ((LPHELPINFO)lParam)->hItemHandle,
                     HELP_FILE,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aMousePtrHelpIDs );
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            WinHelp( (HWND)wParam,
                     HELP_FILE,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPVOID)aMousePtrHelpIDs );
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawCursorListItem
//
////////////////////////////////////////////////////////////////////////////

void DrawCursorListItem(
    DRAWITEMSTRUCT *pdis)
{
    CURSOR_INFO *pcuri;
    COLORREF clrOldText, clrOldBk;
    RECT rc;
    DWORD dwLayout;

    if (!guTextHeight || !guTextGap)
    {
        TEXTMETRIC tm;

        tm.tmHeight = 0;
        GetTextMetrics(pdis->hDC, &tm);

        if (tm.tmHeight < 0)
        {
            tm.tmHeight *= -1;
        }
        guTextHeight = (UINT)tm.tmHeight;
        guTextGap = (UINT)tm.tmAveCharWidth;
    }

    pcuri = &acuri[pdis->itemData];

    if (pdis->itemState & ODS_SELECTED)
    {
        clrOldText = SetTextColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHTTEXT));
        clrOldBk = SetBkColor(pdis->hDC, GetSysColor(COLOR_HIGHLIGHT));
    }
    else
    {
        clrOldText = SetTextColor(pdis->hDC, GetSysColor(COLOR_WINDOWTEXT));
        clrOldBk = SetBkColor(pdis->hDC, GetSysColor(COLOR_WINDOW));
    }

    ExtTextOut( pdis->hDC,
                pdis->rcItem.left + guTextGap,   // fudge factor
                (pdis->rcItem.top + pdis->rcItem.bottom - guTextHeight) / 2,
                ETO_OPAQUE,
                &pdis->rcItem,
                gacd[pdis->itemData].szVisName,
                lstrlen(gacd[pdis->itemData].szVisName),
                NULL );

    if (pcuri->hcur != NULL)
    {
        dwLayout = GetLayout(pdis->hDC);
        SetLayout(pdis->hDC, dwLayout | LAYOUT_BITMAPORIENTATIONPRESERVED);
        DrawIcon( pdis->hDC,
                  pdis->rcItem.right - (gcxCursor + guTextGap),
                  pdis->rcItem.top + 1, pcuri->hcur );
        SetLayout(pdis->hDC, dwLayout);
    }

    if (pdis->itemState & ODS_FOCUS)
    {
        CopyRect(&rc, &pdis->rcItem);
        InflateRect(&rc, -1, -1);
        DrawFocusRect(pdis->hDC, &rc);
    }

    SetTextColor(pdis->hDC, clrOldText);
    SetBkColor(pdis->hDC, clrOldBk);
}


////////////////////////////////////////////////////////////////////////////
//
//  TryToLoadCursor
//
////////////////////////////////////////////////////////////////////////////

BOOL TryToLoadCursor(
    HWND hwnd,
    int i,
    CURSOR_INFO *pcuri)
{
    BOOL fRet    = TRUE;
    BOOL bCustom = (*pcuri->szFile != 0);


    if (bCustom && !GetCursorFromFile(pcuri))
    {
        HWND hwndControl = GetParent(hwnd);
        LPTSTR pszText;
        LPTSTR pszFilename;
        int cchText;

        //
        //  MakeFilename returns the address of a global, so we don't
        //  need to free pszFilename.
        //
        pszFilename = MakeFilename(pcuri->szFile);

        cchText = lstrlen(gszFileNotFound) + lstrlen(gacd[i].szVisName) + lstrlen(pszFilename) + 1;

        pszText = LocalAlloc(LPTR, cchText * sizeof(TCHAR));

        if (pszText == NULL)
        {
            return (FALSE);
        }

        StringCchPrintf(pszText, cchText, gszFileNotFound, pszFilename, gacd[i].szVisName);

        MessageBeep(MB_ICONEXCLAMATION);

        MessageBox(hwndControl, pszText, NULL, MB_ICONEXCLAMATION | MB_OK);

        pcuri->fl = CIF_MODIFIED;

        SendMessage(GetParent(hwnd), PSM_CHANGED, (WPARAM)hwnd, 0L);

        bCustom = FALSE;

        LocalFree(pszText);
    }

    if (!bCustom)
    {
        FreeItemCursor(pcuri);

        pcuri->hcur =
            (HCURSOR)LoadImage( NULL,
                                MAKEINTRESOURCE(gacd[i].idDefResource),
                                IMAGE_CURSOR,
                                0,
                                0,
                                LR_DEFAULTSIZE | LR_ENVSUBST );

        *pcuri->szFile = TEXT('\0');

        EnableWindow(GetDlgItem(hwnd, ID_SAVESCHEME), TRUE);
        UpdateCursorList();
    }

    return (pcuri->hcur != NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetCursorFromFile
//
////////////////////////////////////////////////////////////////////////////

BOOL GetCursorFromFile(
    CURSOR_INFO *pcuri)
{
    pcuri->fl = 0;
    pcuri->hcur =
        (HCURSOR)LoadImage( NULL,
                            MakeFilename(pcuri->szFile),
                            IMAGE_CURSOR,
                            0,
                            0,
                            LR_LOADFROMFILE | LR_DEFAULTSIZE | LR_ENVSUBST );

    if (pcuri->hcur)
    {
        pcuri->fl |= CIF_FILE;
    }

    return (pcuri->hcur != NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  MousePtrBrowsePreview
//
////////////////////////////////////////////////////////////////////////////

void MousePtrBrowsePreview(
    HWND hDlg)
{
    PMOUSEPTRBR pPtrBr;
    HCURSOR hcurOld;

    pPtrBr = (PMOUSEPTRBR)GetWindowLongPtr(hDlg, DWLP_USER);

    hcurOld = pPtrBr->curi.hcur;

    CommDlg_OpenSave_GetFilePath( GetParent(hDlg),
                                  pPtrBr->curi.szFile,
                                  ARRAYSIZE(pPtrBr->curi.szFile) );

    if (!GetCursorFromFile(&pPtrBr->curi))
    {
        pPtrBr->curi.hcur = NULL;
    }

    SendDlgItemMessage( hDlg,
                        ID_CURSORPREVIEW,
                        STM_SETICON,
                        (WPARAM)pPtrBr->curi.hcur, 0L );

    if (hcurOld)
    {
        DestroyCursor(hcurOld);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MousePtrBrowseNotify
//
////////////////////////////////////////////////////////////////////////////

BOOL MousePtrBrowseNotify(
    HWND hDlg,
    LPOFNOTIFY pofn)
{
    switch (pofn->hdr.code)
    {
        case ( CDN_SELCHANGE ) :
        {
            //
            //  Don't show the cursor until the user stops moving around.
            //
            if (SetTimer(hDlg, IDT_BROWSE, 250, NULL))
            {
                //
                //  Don't destroy the old cursor.
                //
                SendDlgItemMessage( hDlg,
                                    ID_CURSORPREVIEW,
                                    STM_SETICON,
                                    0,
                                    0L );
            }
            else
            {
                MousePtrBrowsePreview(hDlg);
            }
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MousePtrBrowseDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK MousePtrBrowseDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            PMOUSEPTRBR pPtrBr = (PMOUSEPTRBR)((LPOPENFILENAME)lParam)->lCustData;

            if (pPtrBr)
            {
                pPtrBr->hDlg = hDlg;
            }

            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR) pPtrBr);
            break;
        }
        case ( WM_DESTROY ) :
        {
            KillTimer(hDlg, IDT_BROWSE);

            //
            //  Don't destroy the old cursor.
            //
            SendDlgItemMessage(hDlg, ID_CURSORPREVIEW, STM_SETICON, 0, 0L);
            break;
        }
        case ( WM_TIMER ) :
        {
            KillTimer(hDlg, IDT_BROWSE);

            MousePtrBrowsePreview(hDlg);
            break;
        }
        case ( WM_NOTIFY ) :
        {
            return (MousePtrBrowseNotify(hDlg, (LPOFNOTIFY) lParam));
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     HELP_FILE,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aMousePtrBrowseHelpIDs );
            break;
        }
        case ( WM_CONTEXTMENU ) :
        {
            WinHelp( (HWND)wParam,
                     HELP_FILE,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPVOID)aMousePtrBrowseHelpIDs );
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  Browse
//
//  Browse the file system for a new cursor for the selected item.
//
////////////////////////////////////////////////////////////////////////////

BOOL Browse(HWND hwndOwner)
{
    static TCHAR szCustomFilter[80] = TEXT("");
    static TCHAR szStartDir[MAX_PATH] = TEXT("");

    OPENFILENAME ofn;
    CURSOR_INFO curi;
    int i;
    BOOL fRet = FALSE;
    MOUSEPTRBR sPtrBr;

    if (!*szStartDir)
    {
        HKEY key = NULL;

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, szRegStr_Setup, 0, KEY_READ, &key) == ERROR_SUCCESS)
        {
            LONG len = ARRAYSIZE(szStartDir);

            if (RegQueryValueEx( key,
                                 szSharedDir,
                                 NULL,
                                 NULL,
                                 (LPBYTE)szStartDir,
                                 &len ) != ERROR_SUCCESS)
            {
                *szStartDir = TEXT('\0');
            }

            RegCloseKey(key);
        }

        if (!*szStartDir)
        {
            if (0 == GetWindowsDirectory(szStartDir, ARRAYSIZE(szStartDir)))
            {
                goto Error;
            }
        }

        PathAppend(szStartDir, szCursorSubdir);
    }

    curi.szFile[0] = TEXT('\0');

    sPtrBr.curi.szFile[0] = TEXT('\0');
    sPtrBr.curi.hcur      = NULL;

    ofn.lStructSize       = sizeof(ofn);
    ofn.hwndOwner         = hwndOwner;
    ofn.hInstance         = g_hInst;
    ofn.lpstrFilter       = gszFilter;
    ofn.lpstrCustomFilter = szCustomFilter;
    ofn.nMaxCustFilter    = ARRAYSIZE(szCustomFilter);
    ofn.nFilterIndex      = 1;
    ofn.lpstrFile         = curi.szFile;
    ofn.nMaxFile          = ARRAYSIZE(curi.szFile);
    ofn.lpstrFileTitle    = NULL;
    ofn.nMaxFileTitle     = 0;
    ofn.lpstrInitialDir   = szStartDir;
    ofn.lpstrTitle        = gszBrowse;
    ofn.Flags             = OFN_EXPLORER | OFN_ENABLETEMPLATE | OFN_ENABLEHOOK |
                            OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
    ofn.lpstrDefExt       = NULL;
    ofn.lpfnHook          = MousePtrBrowseDlgProc;
    ofn.lpTemplateName    = MAKEINTRESOURCE(DLG_MOUSE_POINTER_BROWSE);
    ofn.lCustData         = (LPARAM)(PMOUSEPTRBR)&sPtrBr;

    fRet = GetOpenFileName(&ofn);

    if (!fRet)
    {
        goto brErrExit;
    }
    // we got a valid value, save the current location
    GetCurrentDirectory(ARRAYSIZE(szStartDir), szStartDir);

    fRet = FALSE;

    //
    //  We have probably already gotten this cursor.
    //
    if (lstrcmpi(curi.szFile, sPtrBr.curi.szFile) == 0)
    {
        if (!sPtrBr.curi.hcur)
        {
            goto brErrExit;
        }

        curi = sPtrBr.curi;

        //
        //  Clear this so it will not get destroyed in the cleanup code.
        //
        sPtrBr.curi.hcur = NULL;
    }
    else
    {
        //
        //  The user must have typed in a name.
        //
        if (!GetCursorFromFile(&curi))
        {
            goto brErrExit;
        }
    }

    //
    //  Convert mapped drive letters to UNC.
    //
    if (curi.szFile[1] == TEXT(':'))
    {
        TCHAR szDrive[3];
        TCHAR szNet[MAX_PATH];
        int lenNet = ARRAYSIZE(szNet);

        StringCchCopy(szDrive, ARRAYSIZE(szDrive), curi.szFile);

        if ((WNetGetConnection(szDrive, szNet, &lenNet) == NO_ERROR) &&
            (szNet[0] == TEXT('\\')) &&
            (szNet[1] == TEXT('\\')))
        {
            StringCchCat(szNet, ARRAYSIZE(szNet), curi.szFile + 2);
            StringCchCopy(curi.szFile, ARRAYSIZE(curi.szFile), szNet);
        }
    }

    i = (int)SendMessage(ghwndCursors, LB_GETCURSEL, 0, 0);

    curi.fl |= CIF_MODIFIED;

    SendMessage(GetParent(ghwndDlg), PSM_CHANGED, (WPARAM)ghwndDlg, 0L);

    EnableWindow(GetDlgItem(ghwndDlg, ID_SAVESCHEME), TRUE);

    //
    //  Destroy the old cursor before we retain the new one.
    //
    FreeItemCursor(acuri + i);

    acuri[i] = curi;

    UpdateCursorList();

    fRet = TRUE;

brErrExit:
    if (sPtrBr.curi.hcur)
    {
        DestroyCursor(sPtrBr.curi.hcur);
    }

Error:
    return (fRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  CleanUpEverything
//
//  Destroy all the outstanding cursors.
//
////////////////////////////////////////////////////////////////////////////

void CleanUpEverything()
{
    CURSOR_INFO *pcuri;
    int i;

    for (pcuri = &acuri[0], i = 0; i < CCURSORS; i++, pcuri++)
    {
        FreeItemCursor(pcuri);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateCursorList
//
//  Force the Cursor ListBox to repaint and the cursor information below the
//  listbox to be refreshed as well.
//
////////////////////////////////////////////////////////////////////////////

VOID UpdateCursorList()
{
    int i = (int)SendMessage(ghwndCursors, LB_GETCURSEL, 0, 0);
    PCURSOR_INFO pcuri = ((i >= 0) ? &acuri[i] : NULL);
    HCURSOR hcur = pcuri ? pcuri->hcur : NULL;
    HWND hDefaultButton = GetDlgItem(ghwndDlg, ID_DEFAULT);
    BOOL fEnableDefaultButton = (pcuri && (pcuri->fl & CIF_FILE));

    InvalidateRect(ghwndCursors, NULL, FALSE);

    SendMessage(ghwndPreview, STM_SETICON, (WPARAM)hcur, 0L);

    if (!fEnableDefaultButton && (GetFocus() == hDefaultButton))
    {
        SendMessage(ghwndDlg, WM_NEXTDLGCTL, (WPARAM)ghwndCursors, TRUE);
    }

    EnableWindow(hDefaultButton, fEnableDefaultButton);
}


////////////////////////////////////////////////////////////////////////////
//
//  SaveSchemeAs
//
////////////////////////////////////////////////////////////////////////////

BOOL SaveSchemeAs()
{
    BOOL fSuccess = TRUE;

    //
    //  Dialog proc returns TRUE & sets gszSchemeName to filename entered
    //  on OK.
    //
    if (DialogBox( g_hInst,
                   MAKEINTRESOURCE(DLG_MOUSE_POINTER_SCHEMESAVE),
                   ghwndDlg,
                   SaveSchemeDlgProc ))
    {
        fSuccess = SaveScheme();

        if (fSuccess)
        {
            int index = (int)SendMessage( ghwndSchemeCB,
                                          CB_FINDSTRINGEXACT,
                                          (WPARAM)-1,
                                          (LPARAM)gszSchemeName );
            //
            //  If not found, add it.
            //
            if (index < 0)
            {
                index = (int)SendMessage( ghwndSchemeCB,
                                          CB_ADDSTRING,
                                          0,
                                          (LPARAM)gszSchemeName );
            }

            //
            //  Select the name.
            //
            SendMessage(ghwndSchemeCB, CB_SETCURSEL, (WPARAM) index, 0);

            //
            //  Since this is now a user saved scheme, activate the delete
            //  button.
            //
            EnableWindow(GetDlgItem(ghwndDlg, ID_REMOVESCHEME), TRUE);
        }
    }

    return (fSuccess);
}


////////////////////////////////////////////////////////////////////////////
//
//  SubstituteString
//
//  Replaces the string pszRemove with the string pszReplace in the
//  string pszInput and places the output in pszResult.  Only looks
//  at the begining of the input string.
//
////////////////////////////////////////////////////////////////////////////

BOOL SubstituteString(LPCTSTR pszInput, LPCTSTR pszRemove, LPCTSTR pszReplace, LPTSTR pszResult, UINT cchResult)
{
    UINT cchInput = lstrlen(pszInput);
    UINT cchRemove = lstrlen(pszRemove);
    
    if (cchRemove <= cchInput)
    {
        if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE,
                        pszRemove, cchRemove, pszInput, cchRemove) == CSTR_EQUAL)
        {
            int cchReplace = lstrlen(pszReplace);
            if ((cchInput - cchRemove) + cchReplace < cchResult)
            {
                StringCchCopy(pszResult, cchResult, pszReplace);
                StringCchCat(pszResult, cchResult, pszInput + cchRemove);
                return TRUE;
            }
        }
    }
    return FALSE;
}


BOOL UnExpandPath(LPTSTR pszPath, int cchPath)
{
    static TCHAR szUserProfile[MAX_PATH];
    static TCHAR szSystemRoot[MAX_PATH];
    static TCHAR szProgramFiles[MAX_PATH];
    static BOOL bInit = FALSE;
    TCHAR szUnexpandedFilename[MAX_PATH];

    if ( !bInit )
    {
        ExpandEnvironmentStrings( TEXT("%USERPROFILE%"),  szUserProfile,  ARRAYSIZE(szUserProfile)  );
        ExpandEnvironmentStrings( TEXT("%SYSTEMROOT%"),   szSystemRoot,   ARRAYSIZE(szSystemRoot)   );
        ExpandEnvironmentStrings( TEXT("%ProgramFiles%"), szProgramFiles, ARRAYSIZE(szProgramFiles) );
        bInit = TRUE;
    }

    if (!SubstituteString(pszPath, szUserProfile, TEXT("%USERPROFILE%"), szUnexpandedFilename, ARRAYSIZE(szUnexpandedFilename)))
    {
        if (!SubstituteString(pszPath, szSystemRoot, TEXT("%SYSTEMROOT%"), szUnexpandedFilename, ARRAYSIZE(szUnexpandedFilename)))
        {
            if (!SubstituteString(pszPath, szProgramFiles, TEXT("%ProgramFiles%"), szUnexpandedFilename, ARRAYSIZE(szUnexpandedFilename)))
            {
                return FALSE;
            }
        }
    }
    StringCchCopy(pszPath, cchPath, szUnexpandedFilename);
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  SaveScheme
//
////////////////////////////////////////////////////////////////////////////

BOOL SaveScheme()
{
    BOOL fSuccess = FALSE;

    if (*gszSchemeName)
    {
        const BUFFER_SIZE = CCURSORS * (MAX_PATH + 1) + 1;
        LPTSTR pszBuffer = (LPTSTR)LocalAlloc( LMEM_FIXED,
            BUFFER_SIZE * sizeof(TCHAR) );

        HKEY hk;
        int i;
        if (!pszBuffer)
        {
            return (FALSE);
        }

        pszBuffer[0] = TEXT('\0');


        for (i = 0; i < CCURSORS; i++)
        {
            if (i)
            {
                StringCchCat(pszBuffer, BUFFER_SIZE, TEXT(","));
            }

            // Replace path with evnironment variables.
            UnExpandPath(acuri[i].szFile, ARRAYSIZE(acuri[i].szFile));

            StringCchCat(pszBuffer, BUFFER_SIZE, acuri[i].szFile);
        }

        if (RegCreateKeyEx( HKEY_CURRENT_USER, c_szRegPathCursors, 0, NULL, 0, KEY_CREATE_SUB_KEY, NULL, &hk, NULL) == ERROR_SUCCESS)
        {
            HKEY hks;
            if (RegCreateKeyEx(hk, c_szSchemes, 0, NULL, 0, KEY_SET_VALUE | KEY_QUERY_VALUE, NULL, &hks, NULL) == ERROR_SUCCESS)
            {
                LPTSTR pszOldValue = (LPTSTR)LocalAlloc(LMEM_FIXED, 
                        BUFFER_SIZE * sizeof(TCHAR));
                if (NULL != pszOldValue)
                {
                    DWORD dwType;
                    DWORD dwSize = BUFFER_SIZE*sizeof(TCHAR);
                    BOOL bSave = FALSE;

                    int ret = RegQueryValueEx(hks, gszSchemeName, NULL, &dwType, (LPBYTE)pszOldValue, &dwSize);

                    //
                    //  If the key already exists, ask to confirm the overwrite.
                    //
                    if (ret == ERROR_SUCCESS && (dwType==REG_SZ || dwType==REG_EXPAND_SZ))
                    {
                        // only need to save if value is different from old value
                        if (lstrcmp(pszOldValue,pszBuffer)!=0)
                        {
                            TCHAR szTitle[OVERWRITE_TITLE];
                            TCHAR szMsg[OVERWRITE_MSG];
                            LoadString(g_hInst, IDS_OVERWRITE_TITLE, szTitle, OVERWRITE_TITLE);
                            LoadString(g_hInst, IDS_OVERWRITE_MSG, szMsg, OVERWRITE_MSG);

                            if (MessageBox( ghwndDlg,
                                szMsg,
                                szTitle,
                                MB_ICONQUESTION | MB_YESNO ) == IDYES)
                            {
                                //
                                //  Overwrite confirmed.  Safe to save.
                                //
                                bSave = TRUE;
                            }
                        }
                        else
                        {
                            // no need to save since the new value is the same as the old value.
                            fSuccess = TRUE;
                        }
                    }
                    else
                    {
                        //
                        //  The key doesn't exist, so it's safe to create it.
                        //
                        bSave = TRUE;
                    }

                    if (bSave)
                    {
                        if (RegSetValueEx(hks, gszSchemeName, 0, REG_EXPAND_SZ, (LPBYTE)pszBuffer, (lstrlen(pszBuffer) + 1) * sizeof(TCHAR)) == ERROR_SUCCESS)
                        {
                            fSuccess = TRUE;
                        }
                    }
                    LocalFree( pszOldValue );
                }

                RegCloseKey(hks);
            }
            RegCloseKey(hk);
        }
        LocalFree(pszBuffer);
    }
    return (fSuccess);
}

////////////////////////////////////////////////////////////////////////////
//
//  SaveCurSchemeName
//
////////////////////////////////////////////////////////////////////////////

void SaveCurSchemeName()
{
    HKEY hk;

    if (RegCreateKeyEx(HKEY_CURRENT_USER, c_szRegPathCursors, 0, NULL, 0, KEY_SET_VALUE, NULL, &hk, NULL) == ERROR_SUCCESS)
    {
        int index = (int)SendMessage(ghwndSchemeCB, CB_GETCURSEL, 0, 0L);

        SendMessage(ghwndSchemeCB, CB_GETLBTEXT, (WPARAM)index, (LPARAM)gszSchemeName);
        //
        //  Exclude the "none" pattern.
        //
        if (lstrcmpi(gszSchemeName, szNone) == 0)
        {
            *gszSchemeName = 0;
            iSchemeLocation = ID_NONE_SCHEME;
        }
        else
        {
            iSchemeLocation = SystemOrUser(gszSchemeName);
        }

        RegSetValue(hk, NULL, REG_SZ, gszSchemeName, (lstrlen(gszSchemeName) + 1) * sizeof(TCHAR) );

        RegSetValueEx(hk, szSchemeSource, 0, REG_DWORD, (unsigned char *)&iSchemeLocation, sizeof(iSchemeLocation));

        RegCloseKey(hk);

        if (iSchemeLocation == ID_USER_SCHEME)
        {
            SaveScheme();
        }
    }
}



////////////////////////////////////////////////////////////////////////////
//
//  LoadScheme
//
//  This is called whenever a selection is made from the schemes combo box.
//
////////////////////////////////////////////////////////////////////////////

BOOL LoadScheme()
{
    const BUFFER_SIZE = CCURSORS * (MAX_PATH + 1) + 1;
    TCHAR pszSchemeName[MAX_SCHEME_SUFFIX + MAX_SCHEME_NAME_LEN + 1];
    LPTSTR pszBuffer;
    BOOL fSuccess = FALSE;
    int index, ret;
    HKEY hk;

    //
    //  Allocate buffer for cursor paths.
    //
    pszBuffer = (LPTSTR)LocalAlloc(LMEM_FIXED, BUFFER_SIZE * sizeof(TCHAR));
    if (pszBuffer == NULL)
    {
        return (FALSE);
    }

    HourGlass(TRUE);

    *pszBuffer = *pszSchemeName = 0;

    index = (int)SendMessage(ghwndSchemeCB, CB_GETCURSEL, 0, 0L);

    //
    //  Get current scheme name.
    //
    SendMessage( ghwndSchemeCB,
                 CB_GETLBTEXT,
                 (WPARAM)index,
                 (LPARAM)pszSchemeName );

    // Get the text for the item at index, compare to the previous value to see
    // if it changed.  We can't simply compare the previous index because new items
    // get inserted into the list so the index can change and still be the same or
    // can be different when nothing has changed.
    if ( 0 == lstrcmp(gszPreviousScheme, pszSchemeName) )
    {
        LocalFree(pszBuffer);
        // nothing to do, we're loading the already selected scheme
        return FALSE;
    }

    // We're loading a different scheme, enable the apply button.
    SendMessage(GetParent(ghwndDlg), PSM_CHANGED, (WPARAM)ghwndDlg, 0L);
    StringCchCopy(gszPreviousScheme, ARRAYSIZE(gszPreviousScheme), pszSchemeName);

    //
    //  Exclude the "none" pattern.
    //
    if (lstrcmpi(pszSchemeName, szNone) != 0)
    {
        //
        //  If we have an os scheme, then search for the scheme in HKLM,
        //  otherwise look in HKCU.
        //
        if ((((ret = SystemOrUser(pszSchemeName)) == ID_OS_SCHEME)
               ? (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegPathSystemSchemes, 0, KEY_READ, &hk))
               : (RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegPathCursorSchemes, 0, KEY_READ, &hk)))
             == ERROR_SUCCESS)
        {
            DWORD len = BUFFER_SIZE * sizeof(TCHAR);

            if (RegQueryValueEx( hk,
                                 pszSchemeName, 0, NULL,
                                 (LPBYTE)pszBuffer,
                                 &len ) == ERROR_SUCCESS)
            {
                fSuccess = TRUE;       // can be reset to FALSE below
            }

            RegCloseKey(hk);
        }
    }
    else
    {
        //
        //  "none" pattern is a valid choice.
        //
        ret = ID_NONE_SCHEME;
        fSuccess = TRUE;
    }

    if (fSuccess)
    {
        LPTSTR pszNextFile, pszFile = pszBuffer;
        BOOL fEOL = FALSE;
        int i = 0;

        //
        // Remove an enclosing pair of double quotes from the list
        // of cusor file names associated with the scheme.
        //
        // Why?  On 3/29/00 someone changed the setup file accessor.inx 
        // placing double quotes around some of the cursor scheme reg values
        // in HKLM.  We'll fix the setup file but we should handle this
        // case for all those who have already installed using that
        // setup file.
        //
        if (TEXT('"') == *pszFile)
        {
            const LPTSTR pszLastChar = pszFile + lstrlen(pszFile) - 1;
            if (TEXT('"') == *pszLastChar && pszLastChar > pszFile)
            {
                //
                // Increment passed first dbl quote and truncate 
                // string before the last.
                //
                pszFile++;
                *pszLastChar = TEXT('\0');
            }
        }

        //
        //  Parse string of format TEXT("filename1, filename2, filename3...")
        //  into cursor info array.
        //
        do
        {
            while (*pszFile &&
                   (*pszFile == TEXT(' ')  ||
                    *pszFile == TEXT('\t') ||
                    *pszFile == TEXT('\n')))
            {
                pszFile++;
            }

            pszNextFile = pszFile;

            while (*pszNextFile != TEXT('\0'))
            {
                if (*pszNextFile == TEXT(','))
                {
                    break;
                }

                pszNextFile = CharNext(pszNextFile);
            }

            if (*pszNextFile == TEXT('\0'))
            {
                fEOL = TRUE;
            }
            else
            {
                *pszNextFile = TEXT('\0');
            }

            if (lstrcmp(pszFile, acuri[i].szFile))
            {
                //
                //  It's different than current, update.
                //
                StringCchCopy(acuri[i].szFile, ARRAYSIZE(acuri[i].szFile), pszFile);

                fSuccess &= SchemeUpdate(i);
            }

            pszFile = pszNextFile;

            if (!fEOL)
            {
                pszFile++;        // skip TEXT('\0') and move to next path
            }

            i++;

        } while (i < CCURSORS);
    }

    LocalFree(pszBuffer);

    UpdateCursorList();

    EnableWindow(GetDlgItem(ghwndDlg, ID_REMOVESCHEME), (ret == ID_USER_SCHEME));

    HourGlass(FALSE);

    return (fSuccess);
}


////////////////////////////////////////////////////////////////////////////
//
//  SchemeUpdate
//
//  Updates the cursor at index i in acuri.
//
////////////////////////////////////////////////////////////////////////////

BOOL SchemeUpdate(int i)
{
    BOOL fSuccess = TRUE;

    if (acuri[i].hcur)
    {
        FreeItemCursor(acuri + i);
    }

    //
    //  If TEXT("Set Default").
    //
    if (*(acuri[i].szFile) == TEXT('\0'))
    {
        acuri[i].hcur =
            (HCURSOR)LoadImage( NULL,
                                MAKEINTRESOURCE(gacd[i].idDefResource),
                                IMAGE_CURSOR,
                                0,
                                0,
                                LR_DEFAULTSIZE | LR_ENVSUBST );
        acuri[i].fl = 0;
    }
    else
    {
        fSuccess = TryToLoadCursor(ghwndDlg, i, &acuri[i]);
    }

    acuri[i].fl |= CIF_MODIFIED;

    return (fSuccess);
}


////////////////////////////////////////////////////////////////////////////
//
//  RemoveScheme
//
////////////////////////////////////////////////////////////////////////////

BOOL RemoveScheme()
{
    //
    //  Only user schemes can be removed, so this only needs to
    //  be MAX_SCHEME_NAME_LEN + 1 long.
    //
    TCHAR szSchemeName[MAX_SCHEME_NAME_LEN + 1];
    int index;
    HKEY hk;

    index = (int)SendMessage(ghwndSchemeCB, CB_GETCURSEL, 0, 0L);

    //
    //  Get current scheme name.
    //
    SendMessage( ghwndSchemeCB,
                 CB_GETLBTEXT,
                 (WPARAM)index,
                 (LPARAM)szSchemeName );

    //
    //  Exclude the "none" pattern from removal.
    //
    if (lstrcmpi(szSchemeName, szNone) == 0)
    {
        return (FALSE);
    }

    //
    //  HACK: assume deleting noname needs no confirmation -
    //  this is because the scheme won't save properly anyway.
    //
    if (*szSchemeName)
    {
        TCHAR RemoveMsg[MAX_PATH];
        TCHAR DialogMsg[MAX_PATH];

        LoadString(g_hInst, IDS_REMOVESCHEME, RemoveMsg, MAX_PATH);

        StringCchPrintf(DialogMsg, ARRAYSIZE(DialogMsg), RemoveMsg, (LPTSTR)szSchemeName);

        LoadString(g_hInst, IDS_NAME, RemoveMsg, MAX_PATH);

        if (MessageBox( ghwndDlg,
                        DialogMsg,
                        RemoveMsg,
                        MB_ICONQUESTION | MB_YESNO ) != IDYES)
        {
            return (TRUE);
        }
    }

    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegPathCursors, 0, KEY_WRITE, &hk) == ERROR_SUCCESS)
    {
        HKEY hks;

        if (RegOpenKeyEx(hk, c_szSchemes, 0, KEY_WRITE, &hks) == ERROR_SUCCESS)
        {
            RegDeleteValue(hks, szSchemeName);
            RegCloseKey(hks);
        }

        RegCloseKey(hk);
    }

    //
    //  Delete from list box.
    //
    index = (int)SendMessage( ghwndSchemeCB,
                              CB_FINDSTRINGEXACT,
                              (WPARAM)-1,
                              (LPARAM)szSchemeName );

    SendMessage(ghwndSchemeCB, CB_DELETESTRING, (WPARAM)index, 0);

    SendMessage(ghwndSchemeCB, CB_SETCURSEL, 0, 0);
    SendMessage(ghwndDlg, WM_NEXTDLGCTL, 1, 0L);

    EnableWindow(GetDlgItem(ghwndDlg, ID_REMOVESCHEME), FALSE);
    return TRUE;
}


////////////////////////////////////////////////////////////////////////////
//
//  InitSchemeComboBox
//
////////////////////////////////////////////////////////////////////////////

BOOL InitSchemeComboBox()
{
    TCHAR szSchemeName[MAX_SCHEME_NAME_LEN + 1];
    TCHAR szDefaultSchemeName[MAX_SCHEME_NAME_LEN + 1];
    TCHAR szLongName[MAX_SCHEME_SUFFIX + MAX_SCHEME_NAME_LEN + 1];
    int index;
    HKEY hk;
    DWORD len;

    LoadString(g_hInst, IDS_NONE, szNone, ARRAYSIZE(szNone));
    LoadString(g_hInst, IDS_SUFFIX, szSystemScheme, ARRAYSIZE(szSystemScheme));

    if (RegOpenKeyEx(HKEY_CURRENT_USER, c_szRegPathCursors, 0, KEY_READ, &hk) == ERROR_SUCCESS)
    {
        HKEY hks;

        //
        //  Enumerate the schemes.
        //
        if (RegOpenKeyEx(hk, c_szSchemes, 0, KEY_READ, &hks) == ERROR_SUCCESS)
        {
            DWORD i;

            for (i = 0; ;i++)
            {
                LONG ret;

                //
                //  Reset each pass.
                //
                len = ARRAYSIZE(szSchemeName);

                ret = RegEnumValue( hks,
                                    i,
                                    szSchemeName,
                                    &len,
                                    NULL,
                                    NULL,
                                    NULL,
                                    NULL );

                if (ret == ERROR_MORE_DATA)
                {
                    continue;
                }

                if (ret != ERROR_SUCCESS)
                {
                    break;
                }

                //
                //  HACK to keep "NONE" pure.
                //
                if (lstrcmpi(szSchemeName, szNone) != 0)
                {
                    SendMessage( ghwndSchemeCB,
                                 CB_ADDSTRING,
                                 0,
                                 (LPARAM)szSchemeName );
                }
            }

            //
            //  At this point, all of the user defined scheme names have been
            //  added to the combo box.
            //
            RegCloseKey(hks);
        }

        //
        //  Get name of current one.
        //
        //  Reset again.
        //
        len = sizeof(szDefaultSchemeName);

        RegQueryValue(hk, NULL, szDefaultSchemeName, &len);

        //
        //  Try to read the value of Scheme Source.  If this value doesn't
        //  exist, then we have a pre NT 5.0 implementation, so all schemes
        //  will be user schemes.
        //
        len = sizeof(iSchemeLocation);
        if (RegQueryValueEx( hk,
                             szSchemeSource,
                             NULL,
                             NULL,
                             (unsigned char *)&iSchemeLocation,
                             &len ) != ERROR_SUCCESS)
        {
            iSchemeLocation = ID_USER_SCHEME;
        }

        RegCloseKey(hk);
    }

    //
    //  Now add the system defined pointer schemes.
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szRegPathSystemSchemes, 0, KEY_READ, &hk) == ERROR_SUCCESS)
    {
        DWORD i;

        for (i = 0; ;i++)
        {
            LONG ret;

            //
            //  Reset each pass.
            //
            len = ARRAYSIZE(szSchemeName);

            ret = RegEnumValue( hk,
                                i,
                                szSchemeName,
                                &len,
                                NULL,
                                NULL,
                                NULL,
                                NULL );

            //
            //  If the Scheme name is longer than the allowed length, skip it.
            //
            if (ret == ERROR_MORE_DATA)
            {
                continue;
            }

            //
            //  If there's an error, then we're done.
            //
            if (ret != ERROR_SUCCESS)
            {
                break;
            }

            //
            //  When we add the system identifier to the string, it could be
            //  longer than MAX_SCHEME_NAME, however we only want to read
            //  max length from the registry.
            //
            StringCchCopy(szLongName, ARRAYSIZE(szLongName), szSchemeName);
            StringCchCat(szLongName, ARRAYSIZE(szLongName), szSystemScheme);
            SendMessage(ghwndSchemeCB, CB_ADDSTRING, 0, (LPARAM)szLongName);
        }

        RegCloseKey(hk);
    }

    //
    //  Add the "none" scheme.
    //
    SendMessage(ghwndSchemeCB, CB_INSERTSTRING, 0, (LPARAM)szNone);

    //
    //  Try to find current one in the combobox.
    //
    StringCchCopy(szLongName, ARRAYSIZE(szLongName), szDefaultSchemeName);
    if (iSchemeLocation == ID_OS_SCHEME)
    {
        StringCchCat(szLongName, ARRAYSIZE(szLongName), szSystemScheme);
    }
    index = (int)SendMessage( ghwndSchemeCB,
                              CB_FINDSTRINGEXACT,
                              0xFFFF,
                              (LPARAM)szLongName );

    //
    //  If found, select it.
    //
    if (index < 0)           // if we are on the None scheme
    {
        iSchemeLocation = ID_NONE_SCHEME;
        index = 0;
    }

    // We keep around a selection indicator so we know when selection has changed.
    // Initialize that value here.
    StringCchCopy(gszPreviousScheme, ARRAYSIZE(gszPreviousScheme), szLongName);

    SendMessage(ghwndSchemeCB, CB_SETCURSEL, (WPARAM)index, 0);

    EnableWindow( GetDlgItem(ghwndDlg, ID_REMOVESCHEME),
                  (iSchemeLocation == ID_USER_SCHEME) );

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SaveSchemeDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK SaveSchemeDlgProc(
    HWND  hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    TCHAR szSchemeName[MAX_SCHEME_SUFFIX + MAX_SCHEME_NAME_LEN + 1];

    switch (message)
    {
        case ( WM_INITDIALOG ) :
        {
            HourGlass(TRUE);

            GetWindowText(ghwndSchemeCB, szSchemeName, ARRAYSIZE(szSchemeName));

            //
            //  CANNOT SAVE "NONE" SCHEME.
            //
            if (lstrcmpi(szSchemeName, szNone) == 0)
            {
                *szSchemeName = 0;
            }

            iSchemeLocation = SystemOrUser(szSchemeName);

            SetDlgItemText(hWnd, ID_SCHEMEFILENAME,  szSchemeName);

            SendDlgItemMessage(hWnd, ID_SCHEMEFILENAME, EM_SETSEL, 0, 32767);

            SendDlgItemMessage( hWnd,
                                ID_SCHEMEFILENAME,
                                EM_LIMITTEXT,
                                MAX_SCHEME_NAME_LEN,
                                0L );

            EnableWindow(GetDlgItem(hWnd, IDOK), szSchemeName[0] != TEXT('\0'));

            HourGlass(FALSE);
            return (TRUE);
        }
        case ( WM_HELP ) :
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     HELP_FILE,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aHelpIDs );
            return (TRUE);
        }
        case ( WM_CONTEXTMENU ) :
        {
            WinHelp( (HWND)wParam,
                     HELP_FILE,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPVOID)aHelpIDs );
            return (TRUE);
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( ID_SCHEMEFILENAME ) :
                {
                    if (HIWORD(wParam) == EN_CHANGE)
                    {
                        //
                        //  CANNOT SAVE "NONE" SCHEME
                        //  cannot save a scheme ending with szSystemScheme
                        //
                        EnableWindow(
                            GetDlgItem(hWnd, IDOK),
                            ((GetDlgItemText( hWnd,
                                              ID_SCHEMEFILENAME,
                                              szSchemeName,
                                              ARRAYSIZE(szSchemeName) ) > 0) &&
                             (lstrcmpi(szSchemeName, szNone) != 0) &&
                             (SystemOrUser(szSchemeName) != ID_OS_SCHEME)) );
                    }
                    break;
                }
                case ( IDOK ) :
                {
                    GetDlgItemText( hWnd,
                                    ID_SCHEMEFILENAME,
                                    szSchemeName,
                                    MAX_SCHEME_NAME_LEN + 1 );

                    CurStripBlanks(szSchemeName, ARRAYSIZE(szSchemeName));

                    if (*szSchemeName == TEXT('\0'))
                    {
                        MessageBeep(0);
                        break;
                    }

                    StringCchCopy(gszSchemeName, ARRAYSIZE(gszSchemeName), szSchemeName);

                    // fall through...
                }
                case ( IDCANCEL ) :
                {
                    EndDialog(hWnd, LOWORD(wParam) == IDOK);
                    return (TRUE);
                }
            }
        }
    }

    //
    //  Didn't process a message.
    //
    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MakeFilename
//
//  Returns Filename with a default path in system directory if no path
//  is already specified.
//
////////////////////////////////////////////////////////////////////////////

LPTSTR MakeFilename(
    LPTSTR sz)
{
    TCHAR szTemp[MAX_PATH];

    ExpandEnvironmentStrings(sz, szTemp, MAX_PATH);

    if (szTemp[0] == TEXT('\\') || szTemp[1] == TEXT(':'))
    {
        StringCchCopy(gszFileName2, ARRAYSIZE(gszFileName2), szTemp);

        return (gszFileName2);
    }
    else
    {
        GetSystemDirectory(gszFileName2, ARRAYSIZE(gszFileName2));

        StringCchCat(gszFileName2, ARRAYSIZE(gszFileName2), TEXT("\\"));
        StringCchCat(gszFileName2, ARRAYSIZE(gszFileName2), szTemp);

        return (gszFileName2);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CurStripBlanks
//
//  Strips leading and trailing blanks from a string.
//  Alters the memory where the string sits.
//
////////////////////////////////////////////////////////////////////////////

void CurStripBlanks(LPTSTR pszString, int cchString)
{
    LPTSTR pszPosn;

    //
    //  Strip leading blanks.
    //
    pszPosn = pszString;

    while (*pszPosn == TEXT(' '))
    {
        pszPosn++;
    }

    if (pszPosn != pszString)
    {
        WCHAR szEdit[MAX_PATH];
        StringCchCopy(szEdit, ARRAYSIZE(szEdit), pszPosn);
        StringCchCopy(pszString, cchString, szEdit);
    }

    //
    //  Strip trailing blanks.
    //
    if ((pszPosn = pszString + lstrlen(pszString)) != pszString)
    {
       pszPosn = CharPrev(pszString, pszPosn);

       while (*pszPosn == TEXT(' '))
       {
           pszPosn = CharPrev(pszString, pszPosn);
       }

       pszPosn = CharNext(pszPosn);

       *pszPosn = TEXT('\0');
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  SystemOrUser
//
//  Attempts to determine if the scheme name selected from the combo
//  box ends with the string szSystemScheme and retuns ID_OS_SCHEME
//  if it does, ID_USER_SCHEME if it doesn't.
//
////////////////////////////////////////////////////////////////////////////

int SystemOrUser(TCHAR *pszSchemeName)
{
    TCHAR *pszSN;
    int lenSS, lenSN;
    int i;

    lenSS = lstrlen(szSystemScheme);
    lenSN = lstrlen(pszSchemeName);

    if (lenSN <= lenSS)
    {
        return (ID_USER_SCHEME);
    }

    pszSN = pszSchemeName + (lenSN - lenSS);

    //
    //  If these strings are different, it's a user scheme.
    //
    if (lstrcmpi(pszSN, szSystemScheme))
    {
        return (ID_USER_SCHEME);
    }

    //
    //  For system schemes, this function also removes the
    //  szSystemScheme string from the end.
    //
    *pszSN = TEXT('\0');

    return (ID_OS_SCHEME);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\main\mousemov.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mousemov.c

Abstract:

    This module contains the routines for the Mouse Pointer Property Sheet
    page.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "util.h"
#include "rc.h"
#include "mousehlp.h"


extern void WINAPI CenterDlgOverParent (HWND hWnd);

#define SAFE_DESTROYICON(hicon)   if (hicon) { DestroyIcon(hicon); hicon=NULL; }

//
//  Constant Declarations.
//


#define TRAILMIN   2
#define TRAILMAX   (TRAILMIN + 5)      // range of 8 settings
//
// Motion trackbar parameters.
//
const int MOTION_TB_MIN  =  0;
const int MOTION_TB_MAX  = 10;
const int MOTION_TB_STEP =  1;


//
//  Typedef Declarations.
//
typedef struct
{
    int Thresh1;
    int Thresh2;
    int Accel;
} GETMOUSE;

//
//  Dialog Data.
//
typedef struct tag_MouseGenStr
{
    int       nMotion;
    int       nOrigMotion;
    BOOL      fOrigEnhancedMotion;

    short     nTrailSize;
    short     nOrigTrailSize;

    HWND      hWndTrailScroll;

    BOOL      fOrigSnapTo;

    HWND      hWndSpeedScroll;
    HWND      hDlg;

    BOOL      fOrigVanish;

    BOOL      fOrigSonar;
} MOUSEPTRSTR, *PMOUSEPTRSTR, *LPMOUSEPTRSTR;




//
//  Context Help Ids.
//

const DWORD aMouseMoveHelpIds[] =
{
    IDC_GROUPBOX_1,                 IDH_COMM_GROUPBOX,
    MOUSE_SPEEDSCROLL,              IDH_MOUSE_POINTERSPEED,

    IDC_GROUPBOX_4,                 IDH_COMM_GROUPBOX,
    MOUSE_SNAPDEF,                  IDH_MOUSE_SNAPTO,
    MOUSE_PTRSNAPDEF,               IDH_MOUSE_SNAPTO,

    IDC_GROUPBOX_5,                 IDH_COMM_GROUPBOX,
    MOUSE_TRAILS,                   IDH_MOUSE_POINTER_TRAILS,
    MOUSE_TRAILSCROLLTXT1,          IDH_MOUSE_POINTER_TRAILS,
    MOUSE_TRAILSCROLLTXT2,          IDH_MOUSE_POINTER_TRAILS,
    MOUSE_TRAILSCROLL,              IDH_MOUSE_POINTER_TRAILS,
    MOUSE_VANISH,                   IDH_MOUSE_VANISH,
    MOUSE_SONAR,                    IDH_MOUSE_SONAR,
    MOUSE_ENHANCED_MOTION,          IDH_MOUSE_ENHANCED_MOTION,

    0,0
};


BOOL
_IsValidTrackbarMotionValue(
    int nMotionTrackbar
    )
{
    return (MOTION_TB_MIN <= nMotionTrackbar && MOTION_TB_MAX >= nMotionTrackbar);
}

//
// Sets the mouse acceleration settings.
// If the "Enhanced Motion" checkbox is checked we disable acceleration and
// let USER handle it based on the "motion" setting.
// If the checkbox is unchecked, we default to what was "low" acceleration
// in Windows 2000.  Therefore, it is critical that the MOUSE_ENHANCED_MOTION
// checkbox be in the proper configuration before calling this function.
//
DWORD
_SetPointerAcceleration(
    HWND hwndDlg,
    UINT fWinIni
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    GETMOUSE gm = { 0, 0, 0 };

    if (IsDlgButtonChecked(hwndDlg, MOUSE_ENHANCED_MOTION))
    {
        gm.Thresh1 =  6;
        gm.Thresh2 = 10;
        gm.Accel   =  1;
    }

    if (!SystemParametersInfo(SPI_SETMOUSE, 0, (PVOID)&gm, fWinIni))
    {
        dwResult = GetLastError();
        ASSERTMSG(0,
                  "SystemParametersInfo(SPI_SETMOUSE) failed with error %d",
                  dwResult);
    }
    return dwResult;
}



//
// Sets the mouse motion settings based on the current position of
// the motion trackbar and the configuration of the "enhanced motion"
// checkbox.
//
DWORD
_SetPointerMotion(
    HWND hwndDlg,
    int nMotionTrackbar, // Trackbar position [0 - 10]
    UINT fWinIni
    )
{
    DWORD dwResult = ERROR_SUCCESS;
    int nSpiSpeedValue;

    //
    // Calculations below depend on a trackbar max value of 10.
    // If the trackbar scaling changes, the expressions calculating
    // the system parameter below must also change.
    //
    ASSERT(0 == MOTION_TB_MIN);
    ASSERT(10 == MOTION_TB_MAX);
    ASSERT(_IsValidTrackbarMotionValue(nMotionTrackbar));

    if (0 == nMotionTrackbar)
    {
        //
        // SPI_SETMOUSESPEED doesn't accept 0 so we set a lower-bound
        // of 1.
        //
        nSpiSpeedValue = 1;
    } else {
        nSpiSpeedValue = nMotionTrackbar * 2;
    }

    //
    // Ensure pointer acceleration is correctly set before setting
    // the speed value.
    //
    dwResult = _SetPointerAcceleration(hwndDlg, fWinIni);
    if (ERROR_SUCCESS == dwResult)
    {
        if (!SystemParametersInfo(SPI_SETMOUSESPEED,
                                  0,
                                  IntToPtr(nSpiSpeedValue),
                                  fWinIni))
        {
            dwResult = GetLastError();
            ASSERTMSG(0,
                      "SystemParametersInfo(SPI_SETMOUSESPEED) failed with error %d",
                      dwResult);
        }
    }
    return dwResult;
}



//
// Retrieves the motion trackbar setting based on the values returned
// by SystemParametersInfo.
//
DWORD
_GetPointerMotion(
    HWND hwndDlg,
    int *pnMotionTrackbar,
    BOOL *pfEnhancedMotion
    )
{
    BOOL fEnhancedMotion = FALSE;
    int nSpiSpeedValue   = 0;
    int nMotionTrackbar  = 0;
    GETMOUSE gm;
    DWORD dwResult       = ERROR_SUCCESS;

    ASSERT(0 == MOTION_TB_MIN);
    ASSERT(10 == MOTION_TB_MAX);

    //
    // Read the speed setting from USER.
    //
    if (!SystemParametersInfo(SPI_GETMOUSESPEED,
                              0,
                              &nSpiSpeedValue,
                              FALSE) ||
        !SystemParametersInfo(SPI_GETMOUSE,
                              0,
                              &gm,
                              FALSE))
    {
        dwResult = GetLastError();
        ASSERTMSG(0,
                  "SystemParametersInfo failed with error %d",
                  dwResult);
    }
    else
    {
        //
        // USER is no longer exposing the old acceleration algorithm. Thus,
        // if acceleration is on, then "Enhanced Motion" is (since it's the
        // only acceleration algorithm supported).
        //
        if (gm.Accel)
        {
            //
            // Enhanced.
            //
            fEnhancedMotion = TRUE;
        }

        if (1 <= nSpiSpeedValue && 20 >= nSpiSpeedValue)
        {
            //
            // Classic.
            //
            nMotionTrackbar = nSpiSpeedValue / 2;
        }
        else
        {
            //
            // Invalid value.  Default to classic mid-point.
            //
            nMotionTrackbar = 5;
        }
    }

    ASSERT(_IsValidTrackbarMotionValue(nMotionTrackbar));
    if (NULL != pfEnhancedMotion)
    {
        *pfEnhancedMotion = fEnhancedMotion;
    }
    if (NULL != pnMotionTrackbar)
    {
        *pnMotionTrackbar = nMotionTrackbar;
    }

    return dwResult;
}



////////////////////////////////////////////////////////////////////////////
//
//  DestroyMousePtrDlg
//
////////////////////////////////////////////////////////////////////////////

void DestroyMousePtrDlg(
    PMOUSEPTRSTR pMstr)
{
    HWND hDlg;

    ASSERT( pMstr )

    if( pMstr )
    {
        hDlg = pMstr->hDlg;

        LocalFree( (HGLOBAL)pMstr );

        SetWindowLongPtr( hDlg, DWLP_USER, 0 );
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  EnableTrailScroll
//
////////////////////////////////////////////////////////////////////////////

void EnableTrailScroll(
    HWND hDlg,
    BOOL val)
{
    EnableWindow(GetDlgItem(hDlg, MOUSE_TRAILSCROLL), val);
    EnableWindow(GetDlgItem(hDlg, MOUSE_TRAILSCROLLTXT1), val);
    EnableWindow(GetDlgItem(hDlg, MOUSE_TRAILSCROLLTXT2), val);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitMousePtrDlg
//
////////////////////////////////////////////////////////////////////////////

BOOL InitMousePtrDlg(
    HWND hDlg)
{
    PMOUSEPTRSTR pMstr = NULL;

    BOOL fSnapTo         = FALSE;  //default
    BOOL fVanish         = FALSE;  //default
    BOOL fSonar          = FALSE;  //default
    BOOL fEnhancedMotion = FALSE;
    short nTrails        = 0;      //default

    pMstr = (PMOUSEPTRSTR)LocalAlloc(LPTR, sizeof(MOUSEPTRSTR));

    if (pMstr == NULL)
    {
        return (TRUE);
    }

    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pMstr);

    pMstr->hDlg = hDlg;

    //
    //  Mouse Trails
    //
    SystemParametersInfo(SPI_GETMOUSETRAILS, 0, &nTrails, 0);
    pMstr->nOrigTrailSize = pMstr->nTrailSize = nTrails;


    SendDlgItemMessage( hDlg,
                        MOUSE_TRAILSCROLL,
                        TBM_SETRANGE,
                        0,
                        MAKELONG(TRAILMIN, TRAILMAX) );

    CheckDlgButton(hDlg, MOUSE_TRAILS, (pMstr->nTrailSize > 1));

    if (pMstr->nTrailSize > 1)
      {
        SendDlgItemMessage( hDlg,
                            MOUSE_TRAILSCROLL,
                            TBM_SETPOS,
                            TRUE,
                            (LONG)pMstr->nTrailSize );
      }
    else
      {
        pMstr->nTrailSize = TRAILMAX;

        EnableTrailScroll(hDlg, FALSE);

        SendDlgItemMessage( hDlg,
                            MOUSE_TRAILSCROLL,
                            TBM_SETPOS,
                            TRUE,
                            (LONG)pMstr->nTrailSize );
      }

    //
    // Enable or disable the Snap To Default Checkbutton
    //
    SystemParametersInfo(SPI_GETSNAPTODEFBUTTON, 0, (PVOID)&fSnapTo, FALSE);
    pMstr->fOrigSnapTo = fSnapTo;
    CheckDlgButton(hDlg, MOUSE_SNAPDEF, fSnapTo);

    //
    //Enable or disable the Sonar Checkbutton
    //
    SystemParametersInfo(SPI_GETMOUSESONAR, 0, (PVOID)&fSonar, FALSE);
    pMstr->fOrigSonar = fSonar;
	CheckDlgButton(hDlg, MOUSE_SONAR, fSonar);

    //
    //Enable or disable the Vanish Checkbutton
    //
    SystemParametersInfo(SPI_GETMOUSEVANISH, 0, (PVOID)&fVanish, FALSE);
    pMstr->fOrigVanish = fVanish;
	CheckDlgButton(hDlg, MOUSE_VANISH, fVanish);

    //
    //  Mouse Speed
    //
    _GetPointerMotion(hDlg, &pMstr->nOrigMotion, &fEnhancedMotion);

    CheckDlgButton(hDlg, MOUSE_ENHANCED_MOTION, fEnhancedMotion);
    pMstr->nMotion = pMstr->nOrigMotion;
    pMstr->fOrigEnhancedMotion = fEnhancedMotion;

    pMstr->hWndTrailScroll = GetDlgItem(hDlg, MOUSE_TRAILSCROLL);

    pMstr->hWndSpeedScroll = GetDlgItem(hDlg, MOUSE_SPEEDSCROLL);

    SendDlgItemMessage( hDlg,
                        MOUSE_SPEEDSCROLL,
                        TBM_SETRANGE,
                        0,
                        MAKELONG(MOTION_TB_MIN, MOTION_TB_MAX) );

    SendDlgItemMessage( hDlg,
                        MOUSE_SPEEDSCROLL,
                        TBM_SETTICFREQ,
                        MOTION_TB_STEP,
                        0);

    SendDlgItemMessage( hDlg,
                        MOUSE_SPEEDSCROLL,
                        TBM_SETLINESIZE,
                        0,
                        MOTION_TB_STEP);

    SendDlgItemMessage( hDlg,
                        MOUSE_SPEEDSCROLL,
                        TBM_SETPOS,
                        TRUE,
                        (LONG)pMstr->nOrigMotion);
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  TrailScroll
//
////////////////////////////////////////////////////////////////////////////

void TrailScroll(
    WPARAM wParam,
    LPARAM lParam,
    PMOUSEPTRSTR pMstr)
{
    pMstr->nTrailSize = (short)SendMessage((HWND)lParam, TBM_GETPOS, 0, 0L);
    SystemParametersInfo(SPI_SETMOUSETRAILS, pMstr->nTrailSize, 0,0);
}


////////////////////////////////////////////////////////////////////////////
//
//  SpeedScroll
//
////////////////////////////////////////////////////////////////////////////

void SpeedScroll(
    WPARAM wParam,
    LPARAM lParam,
    PMOUSEPTRSTR pMstr)
{
    const HWND hwndTrackbar = (HWND)lParam;
    pMstr->nMotion = (int)SendMessage(hwndTrackbar, TBM_GETPOS, 0, 0L);
    //
    //  Update speed when they let go of the thumb.
    //
    if (LOWORD(wParam) == SB_ENDSCROLL)
    {
        const HWND hwndDlg = GetParent(hwndTrackbar);
        _SetPointerMotion(hwndDlg, pMstr->nMotion, SPIF_SENDCHANGE);
    }
}


//
// User checked or unchecked the "Enhanced pointer motion" checkbox.
//
void
_OnEnhancedMotionChecked(
    PMOUSEPTRSTR pMstr
    )
{
    const HWND hwndTrackbar = (HWND)pMstr->hWndSpeedScroll;
    const HWND hwndDlg      = GetParent(hwndTrackbar);

    pMstr->nMotion = (int)SendMessage(hwndTrackbar, TBM_GETPOS, 0, 0L);
    _SetPointerMotion(hwndDlg, pMstr->nMotion, SPIF_SENDCHANGE);
}




////////////////////////////////////////////////////////////////////////////
//
//  MouseMovDlg
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK MouseMovDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PMOUSEPTRSTR pMstr = NULL;
    BOOL bRet = FALSE;

    pMstr = (PMOUSEPTRSTR)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (message)
    {
        case ( WM_INITDIALOG ) :
        {
            bRet = InitMousePtrDlg(hDlg);
            break;
        }
        case ( WM_DESTROY ) :
        {
            DestroyMousePtrDlg(pMstr);
            break;
        }
        case ( WM_HSCROLL ) :
        {
            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);

            if ((HWND)lParam == pMstr->hWndSpeedScroll)
            {
                SpeedScroll(wParam, lParam, pMstr);
            }
            else if ((HWND)lParam == pMstr->hWndTrailScroll)
            {
                TrailScroll(wParam, lParam, pMstr);
            }

            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (LOWORD(wParam))
            {
                case ( MOUSE_TRAILS ) :
                {
                    if (IsDlgButtonChecked(hDlg, MOUSE_TRAILS))
                    {
                        EnableTrailScroll(hDlg, TRUE);

                        pMstr->nTrailSize =
                            (int)SendMessage( pMstr->hWndTrailScroll,
                                              TBM_GETPOS,
                                              0,
                                              0 );
                        SystemParametersInfo( SPI_SETMOUSETRAILS,
                                              pMstr->nTrailSize,
                                              0,
                                              0 );

                    }
                    else
                    {
                        EnableTrailScroll(hDlg, FALSE);
                        SystemParametersInfo(SPI_SETMOUSETRAILS, 0, 0, 0);
                    }
                    SendMessage( GetParent(hDlg),
                                 PSM_CHANGED,
                                 (WPARAM)hDlg,
                                 0L );
                    break;
                }

                case ( MOUSE_SNAPDEF ) :
                {
                    SystemParametersInfo( SPI_SETSNAPTODEFBUTTON,
                                          IsDlgButtonChecked(hDlg, MOUSE_SNAPDEF),
                                          0,
                                          FALSE );
                    SendMessage( GetParent(hDlg),
                                 PSM_CHANGED,
                                 (WPARAM)hDlg,
                                 0L );
                    break;
                }

                case ( MOUSE_SONAR ) :
                {
                    SystemParametersInfo( SPI_SETMOUSESONAR,
                                          0,
                                          IntToPtr( IsDlgButtonChecked(hDlg, MOUSE_SONAR) ),
                                          FALSE );
                    SendMessage( GetParent(hDlg),
                                 PSM_CHANGED,
                                 (WPARAM)hDlg,
                                 0L );
                    break;
                }

                case ( MOUSE_VANISH ) :
                {
                    SystemParametersInfo( SPI_SETMOUSEVANISH,
                                          0,
                                          IntToPtr( IsDlgButtonChecked(hDlg, MOUSE_VANISH) ),
                                          FALSE );
                    SendMessage( GetParent(hDlg),
                                 PSM_CHANGED,
                                 (WPARAM)hDlg,
                                 0L );
                    break;
                }

                case ( MOUSE_ENHANCED_MOTION ) :
                    _OnEnhancedMotionChecked(pMstr);
                    SendMessage( GetParent(hDlg),
                                 PSM_CHANGED,
                                 (WPARAM)hDlg,
                                 0L );
                    break;

            }
            break;
        }
        case ( WM_NOTIFY ) :
        {
            switch (((NMHDR *)lParam)->code)
            {
              case ( PSN_APPLY ) :
                {
                short nTrails = 0;
                BOOL fSnapTo = FALSE;
                BOOL fSonar = FALSE;
                BOOL fVanish = FALSE;

                //
                //  Change cursor to hour glass.
                //
                HourGlass(TRUE);

                //
                //  Apply Mouse trails setting.
                //
                nTrails = (IsDlgButtonChecked(hDlg, MOUSE_TRAILS)) ? pMstr->nTrailSize : 0;
                SystemParametersInfo( SPI_SETMOUSETRAILS,
                                      nTrails,
                                      0,
                                      SPIF_UPDATEINIFILE |
                                        SPIF_SENDCHANGE );
                pMstr->nOrigTrailSize = pMstr->nTrailSize = nTrails;


                //
                //  Apply Snap-To-Default setting.
                //
                fSnapTo = IsDlgButtonChecked(hDlg, MOUSE_SNAPDEF);

                if (fSnapTo != pMstr->fOrigSnapTo)
                  {
                  SystemParametersInfo( SPI_SETSNAPTODEFBUTTON,
                                        fSnapTo,
                                        0,
                                        SPIF_UPDATEINIFILE |
                                          SPIF_SENDCHANGE );
                  pMstr->fOrigSnapTo = fSnapTo;
                  }


                //
                //  Apply Sonar setting.
                //
                fSonar = IsDlgButtonChecked(hDlg, MOUSE_SONAR);
                if (fSonar != pMstr->fOrigSonar)
                  {
                  SystemParametersInfo( SPI_SETMOUSESONAR,
                                        0,
                                        IntToPtr(fSonar),
                                        SPIF_UPDATEINIFILE |
                                          SPIF_SENDCHANGE );
                  pMstr->fOrigSonar = fSonar;
                  }


                //
                //  Apply Vanish setting.
                //
                fVanish = IsDlgButtonChecked(hDlg, MOUSE_VANISH);

                if (fVanish != pMstr->fOrigVanish)
                  {
                  SystemParametersInfo( SPI_SETMOUSEVANISH,
                                        0,
                                        IntToPtr(fVanish),
                                        SPIF_UPDATEINIFILE |
                                          SPIF_SENDCHANGE );
                  pMstr->fOrigVanish = fVanish;
                  }

                //
                //  Apply Mouse Speed setting.
                //
                _SetPointerMotion(hDlg, pMstr->nMotion, SPIF_UPDATEINIFILE | SPIF_SENDCHANGE);
                pMstr->fOrigEnhancedMotion = IsDlgButtonChecked(hDlg, MOUSE_ENHANCED_MOTION);
                pMstr->nOrigMotion = pMstr->nMotion;

                HourGlass(FALSE);
                break;
                }
              case ( PSN_RESET ) :
                {
                //
                //  Restore the original Mouse Trails setting.
                //
                SystemParametersInfo( SPI_SETMOUSETRAILS,
                                      pMstr->nOrigTrailSize,
                                      0,
                                      0 );

                //
                //  Restore the original Snap-To-Default setting .
                //
                SystemParametersInfo( SPI_SETSNAPTODEFBUTTON,
                                      pMstr->fOrigSnapTo,
                                      0,
                                      0 );

                //
                //  Restore the original Sonar setting.
                //
                SystemParametersInfo( SPI_SETMOUSESONAR,
                                      0,
                                      IntToPtr(pMstr->fOrigSonar),
                                      0);

                //
                //  Restore the original Vanish setting.
                //
                SystemParametersInfo( SPI_SETMOUSEVANISH,
                                      0,
                                      IntToPtr(pMstr->fOrigVanish),
                                      0);

                //
                //  Restore the original Mouse Motion value.
                //
                CheckDlgButton(hDlg, MOUSE_ENHANCED_MOTION, pMstr->fOrigEnhancedMotion);
                _SetPointerMotion(hDlg, pMstr->nOrigMotion, FALSE);
                break;
                }
              default :
                {
                    return (FALSE);
                }
            }
            break;
        }
        case ( WM_HELP ) :             // F1
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     HELP_FILE,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aMouseMoveHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     HELP_FILE,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aMouseMoveHelpIds );
            break;
        }

        case ( WM_DISPLAYCHANGE ) :
        case ( WM_WININICHANGE ) :
        case ( WM_SYSCOLORCHANGE ) :
        {
            SHPropagateMessage(hDlg, message, wParam, lParam, TRUE);
            return TRUE;
        }

        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\main\mousewhl.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mousewhl.c

Abstract:

    This module contains the routines for the Mouse Wheel Property Sheet
    page.

Revision History:

--*/


//
//  Include Files.
//

#include "main.h"
#include "util.h"
#include "rc.h"
#include "mousehlp.h"


#ifndef ARRAYSIZE
#define ARRAYSIZE(x)   (sizeof(x)/sizeof((x)[0]))
#endif
//
//  Constant Declarations.
//
#define SCROLL_DEFAULT              3

#define MIN_SCROLL_LINES            1 
#define MAX_SCROLL_LINES            100

#define MAX_CHARS_FOR_SCROLL_LINES  3

#ifndef UINT_MAX
#define UINT_MAX                ((UINT)-1)
#endif




//
//  Typedef Declarations.
//


//
//  Dialog Data.
//
typedef struct tag_MouseGenStr
{

    UINT       nOrigScrollLines;    //If this is WHEEL_PAGESCROLL, then we scroll one Page at a time.
    HWND      hDlg;

} MOUSEWHLSTR, *PMOUSEWHLSTR, *LPMOUSEWHLSTR;




//
//  Context Help Ids.
//

const DWORD aMouseWheelHelpIds[] =
{
    IDC_GROUPBOX_1,                 IDH_COMM_GROUPBOX,
    IDRAD_SCROLL_LINES,             IDH_MOUSE_WHEEL_SCROLLING,
    IDRAD_SCROLL_PAGE,              IDH_MOUSE_WHEEL_SCROLLING,
    IDC_SPIN_SCROLL_LINES,          IDH_MOUSE_WHEEL_SCROLLING,
    IDT_SCROLL_FEATURE_TXT,         IDH_MOUSE_WHEEL_SCROLLING,
    IDE_BUDDY_SCROLL_LINES,         IDH_MOUSE_WHEEL_SCROLLING,
    0,0
};


////////////////////////////////////////////////////////////////////////////
//
//  EnableMouseWheelDlgControls
//
////////////////////////////////////////////////////////////////////////////
void EnableMouseWheelDlgControls(HWND hDlg, BOOL bEnable)
{
      static const UINT rgidCtl[] = {
          IDE_BUDDY_SCROLL_LINES,
          IDC_SPIN_SCROLL_LINES,
          };
 
      int i;
      for (i = 0; i < ARRAYSIZE(rgidCtl); i++)
      {
          HWND hwnd = GetDlgItem(hDlg, rgidCtl[i]);
          if (NULL != hwnd)
          {
              EnableWindow(hwnd, bEnable);
          }
      }
}
 

////////////////////////////////////////////////////////////////////////////
//
//  SetScrollWheelLines
//
////////////////////////////////////////////////////////////////////////////
void SetScrollWheelLines(HWND hDlg, BOOL bSaveSettings)
{
  UINT uNumLines = SCROLL_DEFAULT;  
  UINT uiSaveFlag = (bSaveSettings) ? SPIF_UPDATEINIFILE | SPIF_SENDWININICHANGE : FALSE;

  if (IsDlgButtonChecked(hDlg, IDRAD_SCROLL_LINES))
   {
    //Scrolling n Lines at a time

    BOOL fTranslated = FALSE;       // numeric conversion successful
    // Retrieve number of scroll-lines from edit control.
    uNumLines = GetDlgItemInt(hDlg, IDE_BUDDY_SCROLL_LINES,
                             &fTranslated, FALSE);
    if (!fTranslated)
      {
      uNumLines = SCROLL_DEFAULT;
      }
    }   
  else    
  {
  //Scrolling a page at a time
  uNumLines = WHEEL_PAGESCROLL;
  }

  SystemParametersInfo( SPI_SETWHEELSCROLLLINES,
                        uNumLines,
                        NULL,
                        uiSaveFlag);
}


////////////////////////////////////////////////////////////////////////////
//
//  DestroyMouseWheelDlg
//
////////////////////////////////////////////////////////////////////////////

void DestroyMouseWheelDlg(
    PMOUSEWHLSTR pMstr)
{
  HWND hDlg = NULL;
    
  if( pMstr )
    {
    hDlg = pMstr->hDlg;

    LocalFree( (HGLOBAL)pMstr );

    SetWindowLongPtr( hDlg, DWLP_USER, 0 );
    }
}



////////////////////////////////////////////////////////////////////////////
//
//  InitMouseWheelDlg
//
////////////////////////////////////////////////////////////////////////////

void InitMouseWheelDlg(
    HWND hDlg)
{
    PMOUSEWHLSTR pMstr = NULL;
    HWND hWndBuddy = NULL;
    UINT nScrollLines = SCROLL_DEFAULT;

    pMstr = (PMOUSEWHLSTR)LocalAlloc(LPTR, sizeof(MOUSEWHLSTR));

    if (pMstr == NULL)
    {
        return;
    }

    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pMstr);

    pMstr->hDlg = hDlg;

//////////////////////
    SystemParametersInfo(SPI_GETWHEELSCROLLLINES, 0, &nScrollLines, 0);
    
    if (nScrollLines < MIN_SCROLL_LINES) 
      {
      nScrollLines = SCROLL_DEFAULT;
      }
    
    pMstr->nOrigScrollLines = nScrollLines; 

    //Set the buddy window
    hWndBuddy = GetDlgItem (hDlg, IDE_BUDDY_SCROLL_LINES);
    
    SendDlgItemMessage (hDlg, IDC_SPIN_SCROLL_LINES, UDM_SETBUDDY,
                        (WPARAM)hWndBuddy, 0L);


    //Set the range.  The maximum range is UINT_MAX for the scroll-lines feature
    //but the up-down control can only accept a max value of UD_MAXVAL. Therefore,
    //the scroll-lines feature will only have a setting of UINT_MAX when user
    //explicitly specifies to scroll one page at a time.
    SendDlgItemMessage (hDlg, IDC_SPIN_SCROLL_LINES, UDM_SETRANGE, 0L,
                        MAKELONG(MAX_SCROLL_LINES, MIN_SCROLL_LINES));

    //Initialize appropriate scroll-line controls depending on value of
    //scroll-lines setting.
    if (nScrollLines > MAX_SCROLL_LINES)
      {
      EnableMouseWheelDlgControls(hDlg, FALSE);
      SetDlgItemInt (hDlg, IDE_BUDDY_SCROLL_LINES, SCROLL_DEFAULT, FALSE);
      CheckRadioButton (hDlg, IDRAD_SCROLL_LINES, IDRAD_SCROLL_PAGE, IDRAD_SCROLL_PAGE);
      }
    else
      {
      //Display current value in edit control
      SetDlgItemInt (hDlg, IDE_BUDDY_SCROLL_LINES, nScrollLines, FALSE);
     
      //Check scroll-lines or scroll-page button
      CheckRadioButton (hDlg, IDRAD_SCROLL_LINES, IDRAD_SCROLL_PAGE, IDRAD_SCROLL_LINES);                                                            
      }

    Edit_LimitText (GetDlgItem (hDlg, IDE_BUDDY_SCROLL_LINES),
                    MAX_CHARS_FOR_SCROLL_LINES);

}



////////////////////////////////////////////////////////////////////////////
//
//  MouseWheelDlg
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK MouseWheelDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PMOUSEWHLSTR pMstr = NULL;
    BOOL bRet = FALSE;

    pMstr = (PMOUSEWHLSTR)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (message)
    {
        case ( WM_INITDIALOG ) :
        {
            InitMouseWheelDlg(hDlg);
            break;
        }
        case ( WM_DESTROY ) :
        {
            DestroyMouseWheelDlg(pMstr);
            break;
        }

        case WM_VSCROLL:    
          {
            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
            break;
          }


          case ( WM_COMMAND ) :
            {
              switch (LOWORD(wParam))
              {
              case IDRAD_SCROLL_LINES:
              case IDRAD_SCROLL_PAGE :
                {
                UINT code = HIWORD(wParam);

                if (code == BN_CLICKED)
                  {
                  EnableMouseWheelDlgControls(hDlg, IsDlgButtonChecked(hDlg, IDRAD_SCROLL_LINES) );
                  // Set the property
                  SetScrollWheelLines(hDlg, FALSE);
              
                  SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                  }              
                break;
                }

              case IDE_BUDDY_SCROLL_LINES:
                {
                UINT code = HIWORD(wParam);
                if (code == EN_UPDATE)
                  {
                   BOOL fTranslated = FALSE;       // numeric conversion successful

                   // Retrieve number of scroll-lines from edit control.
                   UINT uNumLines = GetDlgItemInt(hDlg, IDE_BUDDY_SCROLL_LINES,
                                             &fTranslated, FALSE);
                   if (fTranslated)        // valid number converted from text
                   {
                      if (uNumLines >= MIN_SCROLL_LINES &&
                          uNumLines <= MAX_SCROLL_LINES)
                      {                                             // spin-control range
                         if (uNumLines != pMstr->nOrigScrollLines)  // different value
                         {
                         // Set the property
                         SetScrollWheelLines(hDlg, FALSE);
              
                         SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                        }
                      }
                      else                 // value out of range
                      {
                         fTranslated = FALSE; // discard value
                      }
                   }
                   if (!fTranslated &&  // invalid (non-numeric) data
                                        // or out of range numeric value
                        pMstr)          //and the Window has been initialized.
                   {                       
                      SetDlgItemInt (hDlg, IDE_BUDDY_SCROLL_LINES,
                                     pMstr->nOrigScrollLines, FALSE);  // unsigned
                    //MessageBeep (0xFFFFFFFF);  // chastise user
                   }
                  }
                
                }
                

              }//switch
             break;
            } //WM_COMMAND


          case ( WM_NOTIFY ) :
            {
            ASSERT (lParam);

            switch (((NMHDR *)lParam)->code)
              {
                case ( PSN_APPLY ) :
                {
                    SetScrollWheelLines(hDlg, TRUE);
                    break;
                }
                case ( PSN_RESET ) :
                {
                    //
                    //  Restore the original 
                    //
                    SystemParametersInfo( SPI_SETWHEELSCROLLLINES,
                                            pMstr->nOrigScrollLines,
                                            NULL,
                                            FALSE);                    
                    break;
                }
                default :
                {
                    return (FALSE);
                }
            
              }
            break;
            }

          case ( WM_HELP ) :             // F1
            {
              WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                       HELP_FILE,
                       HELP_WM_HELP,
                       (DWORD_PTR)(LPTSTR)aMouseWheelHelpIds );
              break;
            }

          case ( WM_CONTEXTMENU ) :      // right mouse click
            {
              WinHelp( (HWND)wParam,
                       HELP_FILE,
                       HELP_CONTEXTMENU,
                       (DWORD_PTR)(LPTSTR)aMouseWheelHelpIds );
              break;
            }

          case ( WM_DISPLAYCHANGE ) :
          case ( WM_WININICHANGE ) :
          case ( WM_SYSCOLORCHANGE ) :
            {
              SHPropagateMessage(hDlg, message, wParam, lParam, TRUE);
              return TRUE;
            }
            
        default :
          {
              return (FALSE);
          }
    }

    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\main\rc.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    rc.h

Abstract:

    This module contains the header information for the resources of
    this project.

Revision History:

--*/



#ifndef _RC_H
#define _RC_H

#define IDC_STATIC -1


//
//  Icons.
//

//
// These IDs determine the index of the icons in the cpl. They
// should not be changed as they are externally referenced,
// In particular IDI_ADM and IDI_FONT must maintain their indices (9 and 10)
// If you add/remove icons from main.cpl, make sure you don't break
// the icons for the fonts and admin folder.
//

#define IDI_MOUSE                      100
#define IDI_KEYBD                      200
#define IDI_PRINT                      300
#define IDI_FONTS                      400
#define IDI_ADM                        500

#define IDI_PTSPEED                    104

#define IDI_DELAY                      105
#define IDI_REPEAT                     106

#define IDI_SNAPDEF                    108

#define IDI_SGLCLICK                   109
#define IDI_DBLCLICK                   110

//
// IDI_PTTRAILS has been renumbered to have a higher index
// than IDI_ADM as earlier it was not getting installed on Winnt
// We used to install only IDI_SNAPDEF on Winnt and IDI_PTTRAILS
// on Millennium, hence the index of the Fonts and Admin icon used
// to be the same in both cases, now we are installing both IDI_SNAPDEF
// and IDI_PTTRAILS in Whistler we must bump one of these IDs 
// above ID_ADM so that we maintain their indices.
//

#define IDI_PTTRAILS                   600

#define IDI_PTVANISH                   601  
#define IDI_PTSONAR                    602  
#define IDI_WHEEL                      603  

#define ICON_FOLDER_CLOSED             605
#define ICON_FOLDER_OPEN               606

//
// Add any new Icon IDs here, ie, value greater than 606.
//
#define ICON_CLICKLOCK                 607

//
//  Bitmaps.
//

#define IDB_MOUSE                     100






//
//  Strings.
//

#define IDS_MOUSE_TITLE                100
#define IDS_MOUSE_EXPLAIN              101
#define IDS_KEYBD_TITLE                102
#define IDS_KEYBD_EXPLAIN              103
#define IDS_PRINT_TITLE                104
#define IDS_PRINT_EXPLAIN              105
#define IDS_FONTS_TITLE                106
#define IDS_FONTS_EXPLAIN              107
#define IDS_ADM_TITLE                  108
#define IDS_ADM_EXPLAIN                109

#define IDS_MOUSE_TSHOOT               110
#define IDS_KEYBD_TSHOOT               111

#define IDS_UNKNOWN                    198
#define IDS_KEYBD_NOSETSPEED           199

#define IDS_ANICUR_FILTER              200
#define IDS_NAME                       201
#define IDS_INFO                       202
#define IDS_CUR_NOMEM                  203
#define IDS_CUR_BADFILE                204
#define IDS_CUR_BROWSE                 205
#define IDS_CUR_FILTER                 206
#define IDS_ARROW                      207
#define IDS_WAIT                       208
#define IDS_APPSTARTING                209
#define IDS_NO                         210
#define IDS_IBEAM                      211
#define IDS_CROSS                      212
#define IDS_SIZENS                     213
#define IDS_SIZEWE                     214
#define IDS_SIZENWSE                   215
#define IDS_SIZENESW                   216
#define IDS_SIZEALL                    217
#define IDS_HELPCUR                    218
#define IDS_NWPEN                      219
#define IDS_UPARROW                    220
#define IDS_NONE                       221
#define IDS_SUFFIX                     222
#define IDS_OVERWRITE_TITLE            223
#define IDS_OVERWRITE_MSG              224
#define IDS_HANDCUR                    225

#define IDS_REMOVESCHEME               230
#define IDS_DEFAULTSCHEME              231

#define IDS_FIRSTSCHEME                1000
#define IDS_LASTSCHEME                 1017




//
//  Dialog Boxes.
//

#define DLG_MOUSE_POINTER_SCHEMESAVE   99
#define DLG_MOUSE_BUTTONS              100
#define DLG_MOUSE_POINTER              101
#define DLG_MOUSE_POINTER_BROWSE       102
#define DLG_MOUSE_MOTION               103
#define DLG_KEYBD_SPEED                104
#define DLG_KEYBD_POINTER              105
#define DLG_HARDWARE                   106
#define DLG_MOUSE_ACTIVITIES           107
#define DLG_MOUSE_WHEEL                108
#define DLG_POINTER_OPTIONS_ADVANCED   109
#define DLG_MOUSE_SET_ORIENTATION      110


//
//  Dialog Controls.
//

#define IDC_GROUPBOX_1                 94   // Use in place of IDC_STATIC for
#define IDC_GROUPBOX_2                 95   // controls with no context Help
#define IDC_GROUPBOX_3                 96
#define IDC_GROUPBOX_4                 97
#define IDC_GROUPBOX_5                 98
#define IDC_GROUPBOX_6                 99




//
//  Mouse Button Page.
//

#define MOUSE_SELECTBMP                102
#define IDBTN_BUTTONSWAP               101

#define MOUSE_MOUSEBMP                 103
#define MOUSE_MENUBMP                  104
#define MOUSE_CLICKSCROLL              105
#define MOUSE_DBLCLK_TEST_AREA         106
#define MOUSE_PTRCOLOR                 107
#define MOUSE_SIZESCROLL               108
#define MOUSE_CLICKICON                111
#define MOUSE_DBLCLICK                 112
#define MOUSE_SGLCLICK                 113
#define IDCK_CLICKLOCK                 114
#define IDBTN_CLICKLOCK_SETTINGS       115
#define IDD_CLICKLOCK_SETTINGS_DLG          116
#define IDC_CLICKLOCK_SETTINGS_TXT          117
#define IDC_CLICKLOCK_SETTINGS_LEFT_TXT     118
#define IDC_CLICKLOCK_SETTINGS_RIGHT_TXT    119
#define IDT_CLICKLOCK_TIME_SETTINGS         120
#define IDC_TEST_DOUBLE_CLICK          123
#define IDC_DBLCLICK_TEXT              124 
#define IDC_CLICKLOCK_TEXT             125

//
//  Mouse Pointer Page.
//

#define DLG_CURSORS                    100
#define ID_CURSORLIST                  101
#define ID_BROWSE                      102
#define ID_DEFAULT                     103
#define ID_TITLEH                      104
#define ID_CREATORH                    105
#define ID_FILEH                       106
#define ID_TITLE                       107
#define ID_CREATOR                     108
#define ID_FILE                        109
#define ID_PREVIEW                     110
#define ID_SAVESCHEME                  111
#define ID_REMOVESCHEME                112
#define ID_SCHEMECOMBO                 113
#define ID_CURSORSHADOW                114


#define ID_SCHEMEFILENAME              300

#define ID_CURSORPREVIEW               400




//
//  Mouse Motion Page.  (Now called Pointer Options)
//

#define MOUSE_SPEEDSCROLL              101
#define MOUSE_TRAILBMP                 102
#define MOUSE_TRAILS                   103
#define MOUSE_TRAILSCROLL              104
#define MOUSE_PTRTRAIL                 105
#define MOUSE_SPEEDBMP                 106
#define MOUSE_TRAILSCROLLTXT1          107
#define MOUSE_TRAILSCROLLTXT2          108
#define MOUSE_SNAPDEF                  109
#define MOUSE_PTRSNAPDEF               110
#define MOUSE_PTRVANISH                112
#define MOUSE_PTRSONAR                 113
#define MOUSE_VANISH                   114
#define MOUSE_SONAR                    115
#define MOUSE_ENHANCED_MOTION          116

/*
//
// Mouse Activities Page.
//
#define IDB_SET_ORIENTATION             101
#define IDB_DEFAULT_ORIENTATION         102
#define IDBMP_WHEEL                     103

//Orientation wizard Dialog 
#define IDBTN_BACK                      110
#define IDBTN_NEXT                      111
#define IDBTN_FINISH                    112
#define IDGB_BITMAP_AREA                113
#define IDC_ORIENT_AREA                 114
#define IDGB_3D_LINE                    115
#define IDC_ORIENT_WIZ_TXT              116
#define IDC_ORIENT_WIZ_TXT_2            117
*/

//
// Mouse Wheel Page
//
#define IDBMP_SCROLL                    101
#define IDT_SCROLL_FEATURE_TXT          102
#define IDRAD_SCROLL_LINES              103
#define IDRAD_SCROLL_PAGE               104
#define IDE_BUDDY_SCROLL_LINES          105
#define IDC_SPIN_SCROLL_LINES           106
#define IDT_SCROLL_LINES_PER_TICK_TXT   107


//
//  Keyboard Speed Page.
//

#define KDELAY_SCROLL                  100
#define KSPEED_SCROLL                  101
#define KREPEAT_EDIT                   102
#define KBLINK_EDIT                    103
#define KCURSOR_BLINK                  104
#define KCURSOR_SCROLL                 105
#define KDELAY_GROUP                   106
#define KBLINK_GROUP                   107




//
//  Keyboard Pointer Page.
//

#define KCHK_ON                        100
#define KNUM_BMP                       101
#define KBTN_NUMBER                    102
#define KBTN_ARROW                     103
#define KARROW_BMP                     104
#define KPSPEED_SCROLL                 105
#define KPACC_SCROLL                   106


//
//	Friend User Type
//
//	This is refered to in the registry for "anifile" types.

#define IDS_FRIENDUSERTYPE			   2000



#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\main\util.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    util.c

Abstract:

    This module contains the utility routines for this project.

Revision History:

--*/



//
//  Include Files.
//

#include "main.h"
#include "util.h"
#include "rc.h"

//
// From shell\inc\shsemip.h
//
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))


//
//  Global Variables.
//

extern HINSTANCE g_hInst;





////////////////////////////////////////////////////////////////////////////
//
//  HourGlass
//
////////////////////////////////////////////////////////////////////////////

void HourGlass(
    BOOL fOn)
{
   if (!GetSystemMetrics(SM_MOUSEPRESENT))
   {
      ShowCursor(fOn);
   }
   SetCursor(LoadCursor(NULL, (fOn ? IDC_WAIT : IDC_ARROW)));
}


////////////////////////////////////////////////////////////////////////////
//
//  MyMessageBox
//
////////////////////////////////////////////////////////////////////////////

int MyMessageBox(
    HWND hWnd,
    UINT uText,
    UINT uCaption,
    UINT uType,
    ...)
{
    TCHAR szText[4 * PATHMAX], szCaption[2 * PATHMAX];
    int result;
    va_list parg;

    va_start(parg, uType);

    LoadString(g_hInst, uText, szCaption, ARRAYSIZE(szCaption));

    StringCchVPrintf(szText, ARRAYSIZE(szText), szCaption, parg);

    LoadString(g_hInst, uCaption, szCaption, ARRAYSIZE(szCaption));

    result = MessageBox(hWnd, szText, szCaption, uType);

    va_end(parg);

    return (result);
}


////////////////////////////////////////////////////////////////////////////
//
//  TrackInit
//
////////////////////////////////////////////////////////////////////////////

void TrackInit(
    HWND hwndScroll,
    int nCurrent,
    PARROWVSCROLL pAVS)
{
    SendMessage(hwndScroll, TBM_SETRANGE, 0, MAKELONG(pAVS->bottom, pAVS->top));
    SendMessage(hwndScroll, TBM_SETPOS, TRUE, (LONG)nCurrent);
}


////////////////////////////////////////////////////////////////////////////
//
//  TrackMessage
//
////////////////////////////////////////////////////////////////////////////

int TrackMessage(
    WPARAM wParam,
    LPARAM lParam,
    PARROWVSCROLL pAVS)
{
    return ((int)SendMessage((HWND)lParam, TBM_GETPOS, 0, 0L));
}

////////////////////////////////////////////////////////////////////////////
//
//  HardwareDlg_OnInitDialog
//
//  Load the real hardware tab out of devmgr.dll.
//
//  DWLP_USER     - HWND of inner page
//
////////////////////////////////////////////////////////////////////////////

// There is no devmgr.h (go figure) so we must declare it ourselves.

EXTERN_C DECLSPEC_IMPORT HWND STDAPICALLTYPE
DeviceCreateHardwarePage(HWND hwndParent, const GUID *pguid);

void
HardwareDlg_OnInitDialog(HWND hdlg, LPARAM lp)
{
    PCHWPAGEINFO phpi = (PCHWPAGEINFO)((LPPROPSHEETPAGE)lp)->lParam;
    HWND hwndHW = DeviceCreateHardwarePage(hdlg, &phpi->guidClass);

    if (hwndHW) {
        TCHAR tszTshoot[MAX_PATH];
        SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR)hwndHW);
        if (LoadString(g_hInst, phpi->idsTshoot, tszTshoot, ARRAYSIZE(tszTshoot))) {
            SetWindowText(hwndHW, tszTshoot);
        }
    } else {
        DestroyWindow(hdlg); // catastrophic failure
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  HardwareDlg
//
//  The dialog procedure for generic hardware tabs.
//
//  GWLP_USERDATA - HINSTANCE of devmgr.dll
//  DWLP_USER     - HWND of inner page
//
//
////////////////////////////////////////////////////////////////////////////

typedef HWND (WINAPI *DEVICECREATEHARDWAREPAGE)
        (HWND hwndParent, const GUID *pguid);

INT_PTR CALLBACK HardwareDlg(HWND hdlg, UINT uMsg, WPARAM wp, LPARAM lp)
{
    switch (uMsg) {

    case WM_INITDIALOG:
        HardwareDlg_OnInitDialog(hdlg, lp);
        return TRUE;
    }
    return FALSE;
}

////////////////////////////////////////////////////////////////////////////
//
//  CreateHardwarePage
//
////////////////////////////////////////////////////////////////////////////

HPROPSHEETPAGE
CreateHardwarePage(PCHWPAGEINFO phpi)
{
    PROPSHEETPAGE psp;

    // No hardware tab if we are a remote TS session, since we would end
    // up showing the properties of the server, not the client, and that
    // would be too confusing.
    if (GetSystemMetrics(SM_REMOTESESSION))
        return NULL;

    // No hardware tab if it's been disabled via policy.
    if (SHRestricted(REST_NOHARDWARETAB))
        return NULL;

    psp.dwSize      = sizeof(psp);
    psp.dwFlags     = PSP_DEFAULT;
    psp.hInstance   = g_hInst;
    psp.pszTemplate = MAKEINTRESOURCE(DLG_HARDWARE);
    psp.pfnDlgProc  = HardwareDlg;
    psp.lParam      = (LPARAM)phpi;

    return CreatePropertySheetPage(&psp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\nusrmgr\commondialog.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       CommonDialog.h
//
//  Contents:   interface definition for ICommonDialog
//
//----------------------------------------------------------------------------
#ifndef _NUSRMGR_COMMONDIALOG_H_
#define _NUSRMGR_COMMONDIALOG_H_


class ATL_NO_VTABLE CCommonDialog :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<ICommonDialog, &IID_ICommonDialog, &LIBID_NUSRMGRLib>,
    public CComCoClass<CCommonDialog, &CLSID_CommonDialog>
{
public:
    CCommonDialog(void)
    : _hwndOwner(NULL), _dwFlags(0), _dwFilterIndex(0),
      _strFilter(NULL), _strFileName(NULL), _strInitialDir(NULL)
    {}
    ~CCommonDialog() {}

DECLARE_REGISTRY_RESOURCEID((UINT)0)

BEGIN_COM_MAP(CCommonDialog)
    COM_INTERFACE_ENTRY(ICommonDialog)
    COM_INTERFACE_ENTRY2(IDispatch, ICommonDialog)
END_COM_MAP()

    // *** ICommonDialog ***
    STDMETHODIMP get_Filter(BSTR* pbstrFilter);
    STDMETHODIMP put_Filter(BSTR bstrFilter);
    STDMETHODIMP get_FilterIndex(UINT* puiFilterIndex);
    STDMETHODIMP put_FilterIndex(UINT uiFilterIndex);
    STDMETHODIMP get_FileName(BSTR* pbstrFilter);
    STDMETHODIMP put_FileName(BSTR bstrFilter);
    STDMETHODIMP get_Flags(UINT* puiFlags);
    STDMETHODIMP put_Flags(UINT uiFlags);
    STDMETHODIMP put_Owner(VARIANT varOwner);
    STDMETHODIMP get_InitialDir(BSTR* pbstrInitialDir);
    STDMETHODIMP put_InitialDir(BSTR bstrInitialDir);

    STDMETHODIMP ShowOpen(VARIANT_BOOL *pbSuccess);

private:
    // private member variables
    HWND  _hwndOwner;
    DWORD _dwFlags;
    DWORD _dwFilterIndex;
    CComBSTR _strFilter;
    CComBSTR _strFileName;
    CComBSTR _strInitialDir;
};


#endif // _NUSRMGR_COMMONDIALOG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\main\util.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    util.h

Abstract:

    This module contains the header information for the utility routines
    for this project.

Revision History:

--*/



#ifndef _UTIL_H
#define _UTIL_H



void
HourGlass(
    BOOL fOn);

int
MyMessageBox(
    HWND hWnd,
    UINT uText,
    UINT uCaption,
    UINT uType,
    ...);

void
TrackInit(
    HWND hwndScroll,
    int nCurrent,
    PARROWVSCROLL pAVS);

int
TrackMessage(
    WPARAM wParam,
    LPARAM lParam,
    PARROWVSCROLL pAVS);

typedef struct HWPAGEINFO {
    GUID    guidClass;                  // Setup device class
    UINT    idsTshoot;                  // Troubleshooter string
} HWPAGEINFO, *PHWPAGEINFO;
typedef const HWPAGEINFO *PCHWPAGEINFO;

HPROPSHEETPAGE
CreateHardwarePage(PCHWPAGEINFO phpi);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\nusrmgr\makefile.inc ===
# This is the list of html and related files packaged in the resource
HTM_FILES = \
            $(O)\nusrmgr.hta        \
            $(O)\nusrmgr.css        \
            $(O)\classic.css        \
            $(O)\body.htc           \
            $(O)\popup.htc          \
            $(O)\selectable.htc     \
            $(O)\accountpage.htm    \
            $(O)\advpage.htm        \
            $(O)\changepage.htm     \
            $(O)\createpage.htm     \
            $(O)\createpage2.htm    \
            $(O)\deletepage.htm     \
            $(O)\deletepage2.htm    \
            $(O)\enableguest.htm    \
            $(O)\mainpage.htm       \
            $(O)\mainpage2.htm      \
            $(O)\namepage.htm       \
            $(O)\passport.htm       \
            $(O)\passwordpage.htm   \
            $(O)\passwordpage2.htm  \
            $(O)\picturepage.htm    \
            $(O)\pwchange_o.htm     \
            $(O)\pwcreate.htm       \
            $(O)\pwcreate_o.htm     \
            $(O)\removepassword.htm \
            $(O)\accountpage.js     \
            $(O)\acct_common.js     \
            $(O)\advpage.js         \
            $(O)\chg_common.js      \
            $(O)\createpage.js      \
            $(O)\createpage2.js     \
            $(O)\deletepage.js      \
            $(O)\deletepage2.js     \
            $(O)\localtext.js       \
            $(O)\mainpage.js        \
            $(O)\namepage.js        \
            $(O)\name_common.js     \
            $(O)\nusrmgr.js         \
            $(O)\passport.js        \
            $(O)\picturepage.js     \
            $(O)\popup.js           \
            $(O)\pw_common.js       \
            $(O)\removepassword.js  \

IMG_FILES = \
            res\camera.ico              \
            res\helpdoc.ico             \
            res\stfind_3.ico            \
            res\users.ico               \
            res\users32.ico             \
            res\guest_disabled.bmp      \
            res\users32.gif             \
            res\tbdef.bmp               \
            res\tbhot.bmp               \
            res\tbdefhi.bmp             \
            res\tbhothi.bmp


$(O)\selfreg_nusrmgr.inf : selfreg.inx
        $(C_PREPROCESSOR_NAME) $(C_PREPROCESSOR_FLAGS:-DNT =) $** > $*.cln
        $(CLEANINF) -inf $*.cln $@
        del $*.cln

nusrmgr.rc : $(HTM_FILES) $(IMG_FILES) $(MIDL_TLBDIR)\$(TARGETNAME).tlb $(O)\selfreg_nusrmgr.inf $(SXS_MANIFEST)

nusrmgr.cpp : commondialog.h passportmanager.h toolbar.h
commondialog.cpp : commondialog.h
passportmanager.cpp : passportmanager.h
toolbar.cpp : toolbar.h

# 
# Inference rules
#

.SUFFIXES:.js .htc .htm .hta .css

{html}.hta{$(O)}.hta:
    $(CLEANINF) $** $@

{html}.htm{$(O)}.htm:
    $(CLEANINF) $** $@

{html}.htc{$(O)}.htc:
    $(CLEANINF) $** $@

{html}.css{$(O)}.css:
    $(CLEANINF) $** $@

{html}.js{$(O)}.js:
    $(CLEANINF) $** $@
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\nusrmgr\commondialog.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 2000.
//
//  File:       CommonDialog.cpp
//
//  Contents:   implementation of CCommonDialog
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "commondialog.h"

HWND _VariantToHWND(const VARIANT& varOwner);   // passportmanager.cpp


//
// ICommonDialog Interface
//
STDMETHODIMP CCommonDialog::get_Filter(BSTR* pbstrFilter)
{
    if (!pbstrFilter)
        return E_POINTER;

    *pbstrFilter = _strFilter.Copy();
    return S_OK;
}


STDMETHODIMP CCommonDialog::put_Filter(BSTR bstrFilter)
{
    _strFilter = bstrFilter;
    return S_OK;
}


STDMETHODIMP CCommonDialog::get_FilterIndex(UINT *puiFilterIndex)
{
    if (!puiFilterIndex)
        return E_POINTER;

    *puiFilterIndex = _dwFilterIndex;
    return S_OK;
}


STDMETHODIMP CCommonDialog::put_FilterIndex(UINT uiFilterIndex)
{
    _dwFilterIndex = uiFilterIndex;
    return S_OK;
}


STDMETHODIMP CCommonDialog::get_FileName(BSTR* pbstrFileName)
{
    if (!pbstrFileName)
        return E_POINTER;

    *pbstrFileName = _strFileName.Copy();
    return S_OK;
}


STDMETHODIMP CCommonDialog::put_FileName(BSTR bstrFileName)
{
    _strFileName = bstrFileName;
    return S_OK;
}


STDMETHODIMP CCommonDialog::get_Flags(UINT *puiFlags)
{
    if (!puiFlags)
        return E_POINTER;

    *puiFlags = _dwFlags;
    return S_OK;
}


STDMETHODIMP CCommonDialog::put_Flags(UINT uiFlags)
{
    _dwFlags = uiFlags;
    return S_OK;
}


STDMETHODIMP CCommonDialog::put_Owner(VARIANT varOwner)
{
    HRESULT hr = E_INVALIDARG;

    _hwndOwner = _VariantToHWND(varOwner);
    if (_hwndOwner)
        hr = S_OK;

    return hr;
}

STDMETHODIMP CCommonDialog::get_InitialDir(BSTR* pbstrInitialDir)
{
    if (!pbstrInitialDir)
        return E_POINTER;

    *pbstrInitialDir = _strInitialDir.Copy();
    return S_OK;
}


STDMETHODIMP CCommonDialog::put_InitialDir(BSTR bstrInitialDir)
{
    _strInitialDir = bstrInitialDir;
    return S_OK;
}


STDMETHODIMP CCommonDialog::ShowOpen(VARIANT_BOOL *pbSuccess)
{
    OPENFILENAMEW ofn = { 0 };
    WCHAR szFileName[MAX_PATH];

    // Null characters can't be passed through script, so we separated
    // name filter string combinations with the '|' character.
    // The CommDlg32 api expects name/filter pairs to be separated by
    // a null character, and the entire string to be double
    // null terminated.

    // copy the filter string (plus one for double null at the end)
    CComBSTR strFilter(_strFilter.Length()+1, _strFilter);
    if (strFilter)
    {
        LPWSTR pch;
        int cch = lstrlenW(strFilter);
        for (pch = strFilter; cch > 0; ++pch, --cch)
        {
            if ( *pch == L'|' )
            {
                *pch = L'\0';
            }
        }
        // Double null terminate the string
        ++pch;
        *pch = L'\0';
    }

    // copy the initial file name, if any
    if (_strFileName)
    {
        lstrcpynW(szFileName, _strFileName, ARRAYSIZE(szFileName));
    }
    else
    {
        szFileName[0] = L'\0';
    }

    // set the struct members
    ofn.lStructSize       = SIZEOF(ofn);
    ofn.hwndOwner         = _hwndOwner;
    ofn.lpstrFilter       = strFilter;
    ofn.nFilterIndex      = _dwFilterIndex;
    ofn.lpstrFile         = szFileName;
    ofn.nMaxFile          = ARRAYSIZE(szFileName);
    ofn.lpstrInitialDir   = _strInitialDir;
    ofn.Flags             = _dwFlags;

    // make the call
    if (GetOpenFileNameW(&ofn))
    {
        _strFileName = szFileName;
        *pbSuccess = VARIANT_TRUE;
    }
    else
    {
        *pbSuccess = VARIANT_FALSE;
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\nusrmgr\debug.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//
//  Copyright (C) Microsoft Corporation, 2000
//
//  File:       debug.cpp
//
//--------------------------------------------------------------------------
#include "stdafx.h"

#define DECLARE_DEBUG
#define SZ_DEBUGINI     "nusrmgr.ini"
#define SZ_MODULE       "nusrmgr.cpl"
#define SZ_DEBUGSECTION ""
#include <debug.h>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\nusrmgr\stdafx.cpp ===
// stdafx.cpp : source file that includes just the standard includes
//  stdafx.pch will be the pre-compiled header
//  stdafx.obj will contain the pre-compiled type information

#include "stdafx.h"

#ifdef _ATL_STATIC_REGISTRY
#include <statreg.h>
#include <statreg.cpp>
#endif

#include <atlimpl.cpp>
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\nusrmgr\nusrmgr.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 2000.
//
//  File:       nusrmgr.cpp
//
//  Contents:   DllMain routines
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include <advpub.h> // for REGINSTALL
#define DECL_CRTFREE
#include <crtfree.h>
#include "resource.h"
#include "nusrmgr_i.c"
#include "commondialog.h"
#include "passportmanager.h"
#include "toolbar.h"


DWORD g_tlsAppCommandHook = -1;

CComModule _Module;

BEGIN_OBJECT_MAP(ObjectMap)
OBJECT_ENTRY(CLSID_CommonDialog, CCommonDialog)
OBJECT_ENTRY(CLSID_PassportManager, CPassportManager)
OBJECT_ENTRY(CLSID_Toolbar, CToolbar)
END_OBJECT_MAP()


//
// DllMain (attach/deatch) routine
//
STDAPI_(BOOL) DllMain(HINSTANCE hInstance, DWORD dwReason, LPVOID /*lpReserved*/)
{
    if (dwReason == DLL_PROCESS_ATTACH)
    {
        // Don't put it under #ifdef DEBUG
        CcshellGetDebugFlags();
        DisableThreadLibraryCalls(hInstance);
        g_tlsAppCommandHook = TlsAlloc();
        SHFusionInitializeFromModuleID(hInstance, 123);
        _Module.Init(ObjectMap, hInstance, &LIBID_NUSRMGRLib);
    }
    else if (dwReason == DLL_PROCESS_DETACH)
    {
        _Module.Term();
        SHFusionUninitialize();
        if (-1 != g_tlsAppCommandHook)
        {
            TlsFree(g_tlsAppCommandHook);
        }
    }
    return TRUE;
}


/////////////////////////////////////////////////////////////////////////////
// Used to determine whether the DLL can be unloaded by OLE

STDAPI DllCanUnloadNow()
{
    return (_Module.GetLockCount()==0) ? S_OK : S_FALSE;
}


/////////////////////////////////////////////////////////////////////////////
// Returns a class factory to create an object of the requested type

STDAPI DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv)
{
    return _Module.GetClassObject(rclsid, riid, ppv);
}


//
// Calls the ADVPACK entry-point which executes an inf
// file section.
//
HRESULT CallRegInstall(HINSTANCE hinstFTP, LPSTR szSection)
{
    UNREFERENCED_PARAMETER(hinstFTP);

    HRESULT hr = E_FAIL;
    HINSTANCE hinstAdvPack = LoadLibrary(TEXT("ADVPACK.DLL"));

    if (hinstAdvPack)
    {
        REGINSTALL pfnri = (REGINSTALL)GetProcAddress(hinstAdvPack, "RegInstall");

        if (pfnri)
        {
            char szThisDLL[MAX_PATH];

            // Get the location of this DLL from the HINSTANCE
            if (GetModuleFileNameA(_Module.GetModuleInstance(), szThisDLL, ARRAYSIZE(szThisDLL)))
            {
                STRENTRY seReg[] = {
                    {"THISDLL", szThisDLL },
                    { "25", "%SystemRoot%" },           // These two NT-specific entries
                    { "11", "%SystemRoot%\\system32" }, // must be at the end of the table
                };
                STRTABLE stReg = {ARRAYSIZE(seReg) - 2, seReg};

                hr = pfnri(_Module.GetResourceInstance(), szSection, &stReg);
            }
        }

        FreeLibrary(hinstAdvPack);
    }

    return hr;
}


HRESULT UnregisterTypeLibrary(const CLSID* piidLibrary)
{
    HRESULT hr = E_FAIL;
    TCHAR szGuid[GUIDSTR_MAX];
    HKEY hk;

    // convert the libid into a string.
    //
    SHStringFromGUID(*piidLibrary, szGuid, ARRAYSIZE(szGuid));

    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("TypeLib"), 0, MAXIMUM_ALLOWED, &hk) == ERROR_SUCCESS)
    {
        if (SHDeleteKey(hk, szGuid))
        {
            // success
            hr = S_OK;
        }
        RegCloseKey(hk);
    }
    else
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    
    return hr;
}


HRESULT RegisterTypeLibrary(const CLSID* piidLibrary)
{
    HRESULT hr = E_FAIL;
    ITypeLib* pTypeLib;
    WCHAR wszModuleName[MAX_PATH];

    // Load and register our type library.
    
    if (GetModuleFileNameW(_Module.GetModuleInstance(), wszModuleName, ARRAYSIZE(wszModuleName)))
    {
        hr = LoadTypeLib(wszModuleName, &pTypeLib);

        if (SUCCEEDED(hr))
        {
            // call the unregister type library in case we had some old junk in the registry
            UnregisterTypeLibrary(piidLibrary);

            hr = RegisterTypeLib(pTypeLib, wszModuleName, NULL);
            if (FAILED(hr))
            {
                TraceMsg(TF_WARNING, "RegisterTypeLibrary: RegisterTypeLib failed (%x)", hr);
            }
            pTypeLib->Release();
        }
        else
        {
            TraceMsg(TF_WARNING, "RegisterTypeLibrary: LoadTypeLib failed (%x) on", hr);
        }
    } 

    return hr;
}


STDAPI DllRegisterServer(void)
{
    HRESULT hr;

    hr = CallRegInstall(_Module.GetResourceInstance(), "UserAccountsInstall");
    ASSERT(SUCCEEDED(hr));

    hr = RegisterTypeLibrary(&LIBID_NUSRMGRLib);
    ASSERT(SUCCEEDED(hr));

    return hr;
}


STDAPI DllUnregisterServer(void)
{
    HRESULT hr;

    hr = CallRegInstall(_Module.GetResourceInstance(), "UserAccountsUninstall");
    ASSERT(SUCCEEDED(hr));

    hr = UnregisterTypeLibrary(&LIBID_NUSRMGRLib);
    ASSERT(SUCCEEDED(hr));

    return hr;
}


STDAPI DllInstall(BOOL bInstall, LPCWSTR pszCmdLine)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\nusrmgr\passportmanager.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 2000.
//
//  File:       PassportManager.cpp
//
//  Contents:   implementation of CPassportManager
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "passportmanager.h"
#include <wincrui.h>        // credui
#include <wininet.h>        // INTERNET_MAX_URL_LENGTH
#include <keymgr.h>         // KRShowKeyMgr


const TCHAR c_szWininetKey[]        = TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Internet Settings\\Passport");
const TCHAR c_szMemberServicesVal[] = TEXT("Properties");


void PassportForceNexusRepopulate()
{
    HMODULE hm = LoadLibrary(TEXT("wininet.dll"));
    if (hm)
    {
        typedef void (STDAPICALLTYPE *PFN_FORCENEXUSLOOKUP)(void);
        PFN_FORCENEXUSLOOKUP pfnForceNexusLookup = (PFN_FORCENEXUSLOOKUP)GetProcAddress(hm, "ForceNexusLookup");
        if (pfnForceNexusLookup)
        {
            pfnForceNexusLookup();
        }
        FreeLibrary(hm);
    }
}

HWND _VariantToHWND(const VARIANT& varOwner)
{
    HWND hwndResult = NULL;

    if (VT_BSTR == varOwner.vt && varOwner.bstrVal && *varOwner.bstrVal != TEXT('\0'))
    {
        hwndResult = FindWindow(NULL, varOwner.bstrVal);
    }

    return hwndResult;
}


//
// IPassportManager Interface
//
STDMETHODIMP CPassportManager::get_currentPassport(BSTR* pbstrPassport)
{
    if (!pbstrPassport)
        return E_POINTER;

    *pbstrPassport = NULL;

    LPWSTR pszCred = NULL;
    if (ERROR_SUCCESS == CredUIReadSSOCredW(NULL, &pszCred))
    {
        *pbstrPassport = SysAllocString(pszCred);
        LocalFree(pszCred);
    }

    return S_OK;
}


STDMETHODIMP CPassportManager::get_memberServicesURL(BSTR* pbstrURL)
{
    if (!pbstrURL)
        return E_POINTER;

    *pbstrURL = NULL;

    BSTR bstrURL = SysAllocStringLen(NULL, INTERNET_MAX_URL_LENGTH);

    if (!bstrURL)
        return E_OUTOFMEMORY;

    // This ensures that the correct reg values are populated.
    PassportForceNexusRepopulate();

    // Try HKEY_CURRENT_USER first
    DWORD cbData = SysStringByteLen(bstrURL);
    DWORD dwErr = SHGetValue(HKEY_CURRENT_USER, c_szWininetKey, c_szMemberServicesVal, NULL, bstrURL, &cbData);

    if (ERROR_SUCCESS != dwErr)
    {
        // Not under HKEY_CURRENT_USER, try HKEY_LOCAL_MACHINE instead
        cbData = SysStringByteLen(bstrURL);
        dwErr = SHGetValue(HKEY_LOCAL_MACHINE, c_szWininetKey, c_szMemberServicesVal, NULL, bstrURL, &cbData);
    }

    if (ERROR_SUCCESS != dwErr)
    {
        SysFreeString(bstrURL);
        bstrURL = NULL;
    }

    *pbstrURL = bstrURL;

    return S_OK;
}
    

STDMETHODIMP CPassportManager::showWizard(VARIANT varOwner, VARIANT_BOOL *pbRet)
{
    if (!pbRet)
        return E_POINTER;

    *pbRet = VARIANT_FALSE;

    IPassportWizard *pPW;
    if (SUCCEEDED(CoCreateInstance(CLSID_PassportWizard, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IPassportWizard, &pPW))))
    {
        pPW->SetOptions(PPW_LAUNCHEDBYUSER);
        if (S_OK == pPW->Show(_VariantToHWND(varOwner)))
        {
            *pbRet = VARIANT_TRUE;
        }
        pPW->Release();
    }

    return S_OK;
}
    

STDMETHODIMP CPassportManager::showKeyManager(VARIANT varOwner, VARIANT_BOOL *pbRet)
{
    if (!pbRet)
        return E_POINTER;

    // This returns void, so we claim to always succeed
    KRShowKeyMgr(_VariantToHWND(varOwner), NULL, NULL, 0);
    *pbRet = VARIANT_TRUE;

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\nusrmgr\cpl.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 2000.
//
//  File:       cpl.cpp
//
//  Contents:   Control Panel entry point (CPlApplet)
//
//----------------------------------------------------------------------------

#include "stdafx.h"

#include <regstr.h>     // REGSTR_PATH_POLICIES
#include <lm.h>         // NetGetJoinInformation
#include <cpl.h>
#include "resource.h"


const struct
{
    LPCTSTR pszApp;
    LPCTSTR pszCommand;
}
s_rgCommands[] =
{
    { TEXT("%SystemRoot%\\system32\\rundll32.exe"), TEXT("rundll32.exe \"%SystemRoot%\\system32\\netplwiz.dll\",UsersRunDll")   },
    { TEXT("%SystemRoot%\\system32\\mshta.exe"),    TEXT("mshta.exe \"res://%SystemRoot%\\system32\\nusrmgr.cpl/nusrmgr.hta\"") },
};

TCHAR const c_szPolicyKey[]         = REGSTR_PATH_POLICIES TEXT("\\Explorer");
TCHAR const c_szPolicyVal[]         = TEXT("UserPasswordsVer");


HRESULT StartUserManager(LPCTSTR pszParams)
{
    TCHAR szApp[MAX_PATH];
    TCHAR szCommand[MAX_PATH];
    int iCommandIndex;
    STARTUPINFO rgStartup = {0};
    PROCESS_INFORMATION rgProcess = {0};

    // Default is to use the old UI
    iCommandIndex = 0;

#ifndef _WIN64
    if (IsOS(OS_PERSONAL) || (IsOS(OS_PROFESSIONAL) && !IsOS(OS_DOMAINMEMBER)))
    {
        // Switch to the friendly UI.
        iCommandIndex = 1;
    }
#endif

    DWORD cch = ExpandEnvironmentStrings(s_rgCommands[iCommandIndex].pszApp, szApp, ARRAYSIZE(szApp));
    if (cch == 0 || cch > ARRAYSIZE(szApp))
    {
        return E_FAIL;
    }

    cch = ExpandEnvironmentStrings(s_rgCommands[iCommandIndex].pszCommand, szCommand, ARRAYSIZE(szCommand));
    if (cch == 0 || cch > ARRAYSIZE(szCommand))
    {
        return E_FAIL;
    }

    if (pszParams && *pszParams != TEXT('\0'))
    {
        // ExpandEnvironmentStrings counts the last '\0'
        // (we checked cch == 0 above)
        cch--;

        // Is there room for the params?
        if (cch + sizeof(' ') + lstrlen(pszParams) < ARRAYSIZE(szCommand))
        {
            szCommand[cch++] = TEXT(' ');
            lstrcpyn(&szCommand[cch], pszParams, ARRAYSIZE(szCommand)-cch);
        }
        // else launch without extra parameters
    }

    rgStartup.cb = sizeof(rgStartup);
    rgStartup.wShowWindow = SW_SHOWNORMAL;

    if (CreateProcess(szApp,
                      szCommand,
                      NULL,
                      NULL,
                      FALSE,
                      0,
                      NULL,
                      NULL,
                      &rgStartup,
                      &rgProcess))
    {
        WaitForInputIdle(rgProcess.hProcess, 10000);
        CloseHandle(rgProcess.hProcess);
        CloseHandle(rgProcess.hThread);
        return S_OK;
    }

    return E_FAIL;
}


LONG APIENTRY CPlApplet(HWND hwnd, UINT Msg, LPARAM lParam1, LPARAM lParam2)
{
    LPCPLINFO lpCplInfo;

    switch (Msg)
    {
    case CPL_INIT:
        return TRUE;

    case CPL_GETCOUNT:
        return 1;

    case CPL_INQUIRE:
        lpCplInfo = (LPCPLINFO)lParam2;
        lpCplInfo->idIcon = IDI_CPLICON;
        lpCplInfo->idName = IDS_NAME;
        lpCplInfo->idInfo = IDS_INFO;
        lpCplInfo->lData  = 0;
        break;

    case CPL_DBLCLK:
        StartUserManager(NULL);
        return TRUE;

    case CPL_STARTWPARMS:
        StartUserManager((LPCTSTR)lParam2);
        return TRUE;
    }

    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\nusrmgr\passportmanager.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1999.
//
//  File:       PassportManager.h
//
//  Contents:   interface definition for IPassportManager
//
//----------------------------------------------------------------------------
#ifndef _NUSRMGR_PASSPORTMANAGER_H_
#define _NUSRMGR_PASSPORTMANAGER_H_


class ATL_NO_VTABLE CPassportManager :
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IPassportManager, &IID_IPassportManager, &LIBID_NUSRMGRLib>,
    public CComCoClass<CPassportManager, &CLSID_PassportManager>
{
public:
    CPassportManager(void) {};
    ~CPassportManager() {};

DECLARE_REGISTRY_RESOURCEID((UINT)0)

BEGIN_COM_MAP(CPassportManager)
    COM_INTERFACE_ENTRY(IPassportManager)
    COM_INTERFACE_ENTRY2(IDispatch, IPassportManager)
END_COM_MAP()

    // *** IPassportManager ***
    STDMETHODIMP get_currentPassport(BSTR* pbstrPassport);
    STDMETHODIMP get_memberServicesURL(BSTR* pbstrURL);
    STDMETHODIMP showWizard(VARIANT varOwner, VARIANT_BOOL *pbRet);
    STDMETHODIMP showKeyManager(VARIANT varOwner, VARIANT_BOOL *pbRet);
};


#endif // _NUSRMGR_PASSPORTMANAGER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\nusrmgr\resource.h ===
//{{NO_DEPENDENCIES}}
// Microsoft Developer Studio generated include file.
// Used by TaskUI.rc
//
#define IDS_NAME                        101
#define IDS_INFO                        102
#define ID_BACK                         103
#define ID_FORWARD                      104
#define ID_HOME                         105
#define IDS_TOOLTIP_BACK                106
#define IDS_TOOLTIP_FORWARD             107
#define IDS_TOOLTIP_HOME                108
#define IDR_ACCEL                       109
#define IDI_CPLICON                     200
#define IDB_NAVBAR                      201
#define IDB_NAVBARHOT                   202
#define IDB_NAVBARHICOLOR               203
#define IDB_NAVBARHOTHICOLOR            204
#define IDI_CPUSRPICT                   205

// Next default values for new objects
//
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS
#define _APS_NEXT_RESOURCE_VALUE        206
#define _APS_NEXT_COMMAND_VALUE         32768
#define _APS_NEXT_CONTROL_VALUE         205
#define _APS_NEXT_SYMED_VALUE           110
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\nusrmgr\stdafx.h ===
// stdafx.h : include file for standard system include files,
//      or project specific include files that are used frequently,
//      but are changed infrequently

#if !defined(AFX_STDAFX_H__7705A854_5A8D_48E4_8E5D_E7209E726836__INCLUDED)
#define AFX_STDAFX_H__7705A854_5A8D_48E4_8E5D_E7209E726836__INCLUDED

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x0501
#endif
#define _ATL_APARTMENT_THREADED

#include <windows.h>
#include <ctype.h>

#define DISALLOW_Assert             // Force to use ASSERT instead of Assert
#define DISALLOW_DebugMsg           // Force to use TraceMsg instead of DebugMsg
#include <debug.h>

#include <ccstock.h>
#include <shlguid.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <commctrl.h>
#include <comctrlp.h>   // HDPA
#include <shlwapi.h>
#include <shlwapip.h>
#include <shfusion.h>

#include <nusrmgr.h>    // our IDL generated header file

extern DWORD g_tlsAppCommandHook;

#include <atlbase.h>
//You may derive a class from CComModule and use it if you want to override
//something, but do not change the name of _Module
extern CComModule _Module;
#include <atlcom.h>
#include <atlhost.h>
#include <atlwin.h>
#include <exdisp.h>
#include <atlctl.h>

//{{AFX_INSERT_LOCATION}}
// Microsoft Visual C++ will insert additional declarations immediately before the previous line.

#endif // !defined(AFX_STDAFX_H__7705A854_5A8D_48E4_8E5D_E7209E726836__INCLUDED)
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\poscpl\debug.c ===
/*
 *  DEBUG.C
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <cpl.h>

#include <setupapi.h>
#include <hidsdi.h>

#include "internal.h"
#include "res.h"
#include "debug.h"




#if DBG

    PWCHAR DbgHidStatusStr(DWORD hidStatus)
    {
        PWCHAR statusName = L"<Unknown>";

        switch (hidStatus){

            #define MAKE_CASE(stat) case stat: statusName = L#stat; break;

            MAKE_CASE(HIDP_STATUS_SUCCESS)
            MAKE_CASE(HIDP_STATUS_NULL)
            MAKE_CASE(HIDP_STATUS_INVALID_PREPARSED_DATA)
            MAKE_CASE(HIDP_STATUS_INVALID_REPORT_TYPE)
            MAKE_CASE(HIDP_STATUS_INVALID_REPORT_LENGTH)
            MAKE_CASE(HIDP_STATUS_USAGE_NOT_FOUND)
            MAKE_CASE(HIDP_STATUS_VALUE_OUT_OF_RANGE)
            MAKE_CASE(HIDP_STATUS_BAD_LOG_PHY_VALUES)
            MAKE_CASE(HIDP_STATUS_BUFFER_TOO_SMALL)
            MAKE_CASE(HIDP_STATUS_INTERNAL_ERROR)
            MAKE_CASE(HIDP_STATUS_I8042_TRANS_UNKNOWN)
            MAKE_CASE(HIDP_STATUS_INCOMPATIBLE_REPORT_ID)
            MAKE_CASE(HIDP_STATUS_NOT_VALUE_ARRAY)
            MAKE_CASE(HIDP_STATUS_IS_VALUE_ARRAY)
            MAKE_CASE(HIDP_STATUS_DATA_INDEX_NOT_FOUND)
            MAKE_CASE(HIDP_STATUS_DATA_INDEX_OUT_OF_RANGE)
            MAKE_CASE(HIDP_STATUS_BUTTON_NOT_PRESSED)
            MAKE_CASE(HIDP_STATUS_REPORT_DOES_NOT_EXIST)
            MAKE_CASE(HIDP_STATUS_NOT_IMPLEMENTED)
        }

        return statusName;
    }

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\poscpl\debug.h ===
/*
 *  DEBUG.H
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */



#if DBG
    PWCHAR DbgHidStatusStr(DWORD hidStatus);

    #define ASSERT(fact) { if (!(fact)) MessageBox(NULL, L#fact, L"POSCPL assertion failed", MB_OK); }
    #define DBGERR(msg, arg)  { \
                                WCHAR __s[200]={0}; \
                                WCHAR __narg[11]; \
                                WStrNCpy(__s, msg, 100); \
                                WStrNCpy(__s+wcslen(__s), L", ", 3); \
                                IntToWChar(__narg, arg); \
                                WStrNCpy(__s+wcslen(__s), __narg, 100); \
                                WStrNCpy(__s+wcslen(__s), L"=", 2); \
                                HexToWChar(__narg, arg); \
                                WStrNCpy(__s+wcslen(__s), __narg, 100); \
                                WStrNCpy(__s+wcslen(__s), L"h.", 3); \
                                MessageBox(NULL, __s, L"POSCPL error message", MB_OK); \
    }

    #define DBGHIDSTATUSSTR(hidStatus) DbgHidStatusStr(hidStatus)

#else
    #define ASSERT(fact)
    #define DBGERR(msg, arg)
    #define DBGHIDSTATUSSTR(hidStatus)
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\nusrmgr\toolbar.cpp ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 2001.
//
//  File:       Toolbar.cpp
//
//  Contents:   implementation of CToolbar
//
//----------------------------------------------------------------------------

#include "stdafx.h"
#include "Toolbar.h"


class CAppCommandHook
{
public:
    static void SetHook(HWND hWnd)
    {
        CAppCommandHook *pach = _GetInfo(TRUE);
        if (pach)
        {
            if (NULL != pach->_hHook)
            {
                UnhookWindowsHookEx(pach->_hHook);
                pach->_hHook = NULL;
                pach->_hWnd = NULL;
            }
            if (NULL != hWnd)
            {
                pach->_hWnd = hWnd;
                pach->_hHook = SetWindowsHookEx(WH_SHELL, _HookProc, NULL, GetCurrentThreadId());
            }
        }
    }

    static void Unhook(void)
    {
        CAppCommandHook *pach = _GetInfo(FALSE);
        if (-1 != g_tlsAppCommandHook)
        {
            TlsSetValue(g_tlsAppCommandHook, NULL);
        }
        delete pach;
    }

private:
    CAppCommandHook() : _hHook(NULL), _hWnd(NULL) {}
    ~CAppCommandHook()
    {
        if (NULL != _hHook)
            UnhookWindowsHookEx(_hHook);
    }

    static CAppCommandHook* _GetInfo(BOOL bAlloc)
    {
        CAppCommandHook *pach = NULL;
        if (-1 != g_tlsAppCommandHook)
        {
            pach = (CAppCommandHook*)TlsGetValue(g_tlsAppCommandHook);

            if (NULL == pach && bAlloc)
            {
                pach = new CAppCommandHook;
                if (NULL != pach)
                {
                    TlsSetValue(g_tlsAppCommandHook, pach);
                }
            }
        }
        return pach;
    }

    static LRESULT CALLBACK _HookProc(int nCode, WPARAM wParam, LPARAM lParam)
    {
        CAppCommandHook *pach = _GetInfo(FALSE);
        if (pach)
        {
            if (nCode == HSHELL_APPCOMMAND && NULL != pach->_hWnd)
            {
                if (::SendMessage(pach->_hWnd, WM_APPCOMMAND, wParam, lParam))
                    return 0;
            }
            if (NULL != pach->_hHook)
                return CallNextHookEx(pach->_hHook, nCode, wParam, lParam);
        }
        return 0;
    }

private:
    HHOOK _hHook;
    HWND  _hWnd;
};


/////////////////////////////////////////////////////////////////////////////
// CToolbar

LRESULT CToolbar::_OnCreate(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM /*lParam*/, BOOL& /*bHandled*/)
{
    m_hAccel = LoadAccelerators(_Module.GetResourceInstance(), MAKEINTRESOURCE(IDR_ACCEL));

    DWORD dwExStyle = TBSTYLE_EX_MIXEDBUTTONS;

    //
    // NTRAID#NTBUG9-300152-2001/02/02-jeffreys  Toolbar isn't mirrored
    //
    // The HTA frame window isn't getting the right layout style on mirrored
    // builds.  This style is normally inherited from parent to child, so
    // we shouldn't have to do anything here.
    //
    // However, I'm putting this in temporarily so the toolbar will be
    // mirrored for beta 2.  After beta 2, or whenever trident fixes the
    // HTA problem, this can be removed.
    //
    CComVariant varRTL;
    if (SUCCEEDED(GetAmbientProperty(DISPID_AMBIENT_RIGHTTOLEFT, varRTL))
        && varRTL.boolVal == VARIANT_TRUE)
    {
        dwExStyle |= WS_EX_NOINHERITLAYOUT | WS_EX_LAYOUTRTL;
    }

    RECT rc = {0,0,0,0};
    m_ctlToolbar.Create(m_hWnd,
                        &rc,
                        NULL,
                        WS_CHILD | WS_VISIBLE | CCS_NODIVIDER | CCS_TOP | CCS_NOPARENTALIGN | TBSTYLE_FLAT | TBSTYLE_LIST | TBSTYLE_TOOLTIPS,
                        dwExStyle);
    if (!m_ctlToolbar)
        return -1;

    m_ctlToolbar.SendMessage(TB_BUTTONSTRUCTSIZE, sizeof(TBBUTTON), 0);

    int idBmp = IDB_NAVBAR;
    if (SHGetCurColorRes() > 8)
        idBmp += (IDB_NAVBARHICOLOR - IDB_NAVBAR);

    m_himlNBDef = ImageList_LoadImageW(_Module.GetResourceInstance(),
                                       MAKEINTRESOURCE(idBmp),
                                       NAVBAR_CX,
                                       0,
                                       CLR_DEFAULT,
                                       IMAGE_BITMAP,
                                       LR_CREATEDIBSECTION);
    if (m_himlNBDef)
    {
        m_ctlToolbar.SendMessage(TB_SETIMAGELIST, 0, (LPARAM)m_himlNBDef);
    }

    m_himlNBHot = ImageList_LoadImageW(_Module.GetResourceInstance(),
                                       MAKEINTRESOURCE(idBmp+1),
                                       NAVBAR_CX,
                                       0,
                                       CLR_DEFAULT,
                                       IMAGE_BITMAP,
                                       LR_CREATEDIBSECTION);
    if (m_himlNBHot)
    {
        m_ctlToolbar.SendMessage(TB_SETHOTIMAGELIST, 0, (LPARAM)m_himlNBHot);
    }

    if (!m_himlNBDef && !m_himlNBHot)
    {
        // Must be serious low memory or other resource problems.
        // There's no point having a toolbar without any images.
        m_ctlToolbar.DestroyWindow();
        return -1;
    }

    TCHAR szBack[64];
    TCHAR szHome[64];
    TBBUTTON rgButtons[] =
    {
        {0, ID_BACK,    TBSTATE_ENABLED, BTNS_BUTTON | BTNS_AUTOSIZE | BTNS_SHOWTEXT, {0}, 0, (INT_PTR)szBack},
        {1, ID_FORWARD, TBSTATE_ENABLED, BTNS_BUTTON | BTNS_AUTOSIZE, {0}, 0, 0},
        {2, ID_HOME,    TBSTATE_ENABLED, BTNS_BUTTON | BTNS_AUTOSIZE | BTNS_SHOWTEXT, {0}, 0, (INT_PTR)szHome},
    };

    ::LoadStringW(_Module.GetResourceInstance(), ID_BACK, szBack, ARRAYSIZE(szBack));
    ::LoadStringW(_Module.GetResourceInstance(), ID_HOME, szHome, ARRAYSIZE(szHome));
    m_ctlToolbar.SendMessage(TB_ADDBUTTONSW, ARRAYSIZE(rgButtons), (LPARAM)rgButtons);

    // Update the position and extent stuff. Do this asynchronously since ATL
    // will call SetObjectRects shortly after we return from this method (with
    // the original rect).
    PostMessage(PWM_UPDATESIZE);

    // Set a hook to redirect WM_APPCOMMAND messages to our control window
    CAppCommandHook::SetHook(m_hWnd);

    return 0;
}

LRESULT CToolbar::_OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    CAppCommandHook::Unhook();
    return 0;
}

LRESULT CToolbar::_OnAppCommand(UINT /*uMsg*/, WPARAM /*wParam*/, LPARAM lParam, BOOL& bHandled)
{
    switch (GET_APPCOMMAND_LPARAM(lParam))
    {
    case APPCOMMAND_BROWSER_BACKWARD:
        Fire_OnButtonClick(0);
        break;

    case APPCOMMAND_BROWSER_FORWARD:
        Fire_OnButtonClick(1);
        break;

    case APPCOMMAND_BROWSER_HOME:
        Fire_OnButtonClick(2);
        break;

    default:
        bHandled = FALSE;
        break;
    }
    return 0;
}

LRESULT CToolbar::_UpdateSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
{
    if (m_ctlToolbar)
    {
        //
        // TB_AUTOSIZE causes m_ctlToolbar to set its preferred height, but it
        // doesn't adjust it's width or position because of the styles we use
        // (CCS_TOP | CCS_NOPARENTALIGN).
        //
        // The width will always be the same as m_rcPos because we keep them
        // in sync via SetObjectRects below.
        //
        // If the height is different after TB_AUTOSIZE, ask the container to
        // adjust our rect.
        //

        m_ctlToolbar.SendMessage(TB_AUTOSIZE, 0, 0);

        RECT rc;
        m_ctlToolbar.GetWindowRect(&rc);
        ::MapWindowPoints(NULL, GetParent(), (LPPOINT)&rc, 2);

        if ((rc.bottom - rc.top) != (m_rcPos.bottom - m_rcPos.top))
        {
            //
            // We only want to set the height (leave the width alone), but
            // OnPosRectChange sets both the height and the width. Moreover,
            // it sets the width to a fixed (pixel) width, nuking styles such
            // as "100%". We get around this by getting the current width
            // now and restoring it after calling OnPosRectChange.
            //
            CComPtr<IHTMLStyle> spStyle;
            CComVariant varWidth;
            CComQIPtr<IOleControlSite> spCtrlSite(m_spClientSite);
            if (spCtrlSite)
            {
                CComPtr<IDispatch> spDispatch;
                spCtrlSite->GetExtendedControl(&spDispatch);
                if (spDispatch)
                {
                    CComQIPtr<IHTMLElement> spElement(spDispatch);
                    if (spElement)
                    {
                        spElement->get_style(&spStyle);
                        if (spStyle)
                        {
                            spStyle->get_width(&varWidth);
                        }
                    }
                }
            }

            // Ask the container to give us a new rect
            m_spInPlaceSite->OnPosRectChange(&rc);

            // Restore the previous width style
            if (spStyle)
            {
                spStyle->setAttribute(L"width", varWidth, 0);
            }
        }
    }

    return 0;
}

HRESULT CToolbar::OnAmbientPropertyChange(DISPID dispid)
{
    switch (dispid)
    {
    case DISPID_UNKNOWN:
    case DISPID_AMBIENT_FONT:
        _ClearAmbientFont();
        _GetAmbientFont();
        m_ctlToolbar.SendMessage(WM_SETFONT, (WPARAM)m_hFont, FALSE);
        m_ctlToolbar.InvalidateRect(NULL);   // redraw
        break;
    }

    return S_OK;
}

void CToolbar::_ClearAmbientFont(void)
{
    if (m_pFont)
    {
        if (m_hFont)
            m_pFont->ReleaseHfont(m_hFont);
        m_pFont->Release();
        m_pFont = NULL;

    }
    m_hFont = NULL;
}

void CToolbar::_GetAmbientFont(void)
{
    if (!m_hFont)
    {
        // Try to get the ambient font from our container
        if (SUCCEEDED(GetAmbientFont(&m_pFont)))
        {
            if (SUCCEEDED(m_pFont->get_hFont(&m_hFont)))
            {
                // Yea, everybody is happy
                m_pFont->AddRefHfont(m_hFont);
            }
            else
            {
                // Darn, couldn't get the font from container
                _ClearAmbientFont();
            }
        }
    }
}

STDMETHODIMP CToolbar::get_enabled(VARIANT vIndex, VARIANT_BOOL *pVal)
{
    if (!pVal)
        return E_POINTER;

    *pVal = VARIANT_FALSE;

    if (FAILED(VariantChangeType(&vIndex, &vIndex, 0, VT_I4)))
        return E_INVALIDARG;

    LRESULT state = m_ctlToolbar.SendMessage(TB_GETSTATE, ID_BACK + vIndex.lVal, 0);
    if (-1 == state)
        return E_INVALIDARG;

    if (state & TBSTATE_ENABLED)
        *pVal = VARIANT_TRUE;

    return S_OK;
}

STDMETHODIMP CToolbar::put_enabled(VARIANT vIndex, VARIANT_BOOL newVal)
{
    if (FAILED(VariantChangeType(&vIndex, &vIndex, 0, VT_I4)))
        return E_INVALIDARG;

    m_ctlToolbar.SendMessage(TB_ENABLEBUTTON, ID_BACK + vIndex.lVal, MAKELONG((VARIANT_TRUE == newVal), 0));

    return S_OK;
}

void CToolbar::Fire_OnButtonClick(int buttonIndex)
{
    int nConnectionIndex;
    CComVariant* pvars = new CComVariant[1];
    int nConnections = m_vec.GetSize();

    for (nConnectionIndex = 0; nConnectionIndex < nConnections; nConnectionIndex++)
    {
        Lock();
        CComPtr<IUnknown> sp = m_vec.GetAt(nConnectionIndex);
        Unlock();
        IDispatch* pDispatch = reinterpret_cast<IDispatch*>(sp.p);
        if (pDispatch != NULL)
        {
            pvars[0] = buttonIndex;
            DISPPARAMS disp = { pvars, NULL, 1, 0 };
            pDispatch->Invoke(0x1, IID_NULL, LOCALE_USER_DEFAULT, DISPATCH_METHOD, &disp, NULL, NULL, NULL);
        }
    }
    delete[] pvars;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\nusrmgr\toolbar.h ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 2001.
//
//  File:       Toolbar.h
//
//  Contents:   declaration of CToolbar
//
//----------------------------------------------------------------------------

#ifndef _NUSRMGR_TOOLBAR_H_
#define _NUSRMGR_TOOLBAR_H_

#include "resource.h"       // main symbols
#include <atlctl.h>

#define NAVBAR_CX               24
#define PWM_UPDATESIZE          (WM_APP + 143)


/////////////////////////////////////////////////////////////////////////////
// CToolbar

class ATL_NO_VTABLE CToolbar : 
    public CComObjectRootEx<CComSingleThreadModel>,
    public IDispatchImpl<IToolbar, &IID_IToolbar, &LIBID_NUSRMGRLib>,
    public CComControl<CToolbar>,
    public IOleControlImpl<CToolbar>,
    public IOleObjectImpl<CToolbar>,
    public IOleInPlaceActiveObjectImpl<CToolbar>,
    public IViewObjectExImpl<CToolbar>,
    public IOleInPlaceObjectWindowlessImpl<CToolbar>,
    public IConnectionPointImpl<CToolbar, &DIID_DToolbarEvents>,
    //public IPropertyNotifySinkCP<CToolbar>,
    public IConnectionPointContainerImpl<CToolbar>,
    public IProvideClassInfo2Impl<&CLSID_Toolbar, &DIID_DToolbarEvents, &LIBID_NUSRMGRLib>,
    public CComCoClass<CToolbar, &CLSID_Toolbar>
{
public:
    CToolbar() :
        m_ctlToolbar(_T("ToolbarWindow32"), this, 1),
        m_hAccel(NULL), m_pFont(NULL), m_hFont(NULL),
        m_himlNBDef(NULL), m_himlNBHot(NULL)
    {
        m_bWindowOnly = TRUE;
        m_bRecomposeOnResize = TRUE;

        // This is an educated guess based on the usual height (the width
        // doesn't matter).
        m_sizeExtent.cx = 5000;
        m_sizeExtent.cy =  688; //  26px @ 96dpi
        m_sizeNatural.cx = -1;
        m_sizeNatural.cy = -1;
    }

    ~CToolbar()
    {
        _ClearAmbientFont();

        if (m_himlNBDef)
            ImageList_Destroy(m_himlNBDef);
        if (m_himlNBHot)
            ImageList_Destroy(m_himlNBHot);
    }

DECLARE_WND_CLASS_EX(_T("UserAccounts.Toolbar"), CS_DBLCLKS, -1)
DECLARE_REGISTRY_RESOURCEID((UINT)0)
DECLARE_NOT_AGGREGATABLE(CToolbar)
//DECLARE_PROTECT_FINAL_CONSTRUCT()

BEGIN_COM_MAP(CToolbar)
    COM_INTERFACE_ENTRY(IToolbar)
    COM_INTERFACE_ENTRY(IDispatch)
    COM_INTERFACE_ENTRY(IViewObjectEx)
    COM_INTERFACE_ENTRY(IViewObject2)
    COM_INTERFACE_ENTRY(IViewObject)
    COM_INTERFACE_ENTRY(IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceObject)
    COM_INTERFACE_ENTRY2(IOleWindow, IOleInPlaceObjectWindowless)
    COM_INTERFACE_ENTRY(IOleInPlaceActiveObject)
    COM_INTERFACE_ENTRY(IOleControl)
    COM_INTERFACE_ENTRY(IOleObject)
    COM_INTERFACE_ENTRY(IConnectionPointContainer)
    COM_INTERFACE_ENTRY(IProvideClassInfo2)
    COM_INTERFACE_ENTRY(IProvideClassInfo)
END_COM_MAP()

BEGIN_CONNECTION_POINT_MAP(CToolbar)
    CONNECTION_POINT_ENTRY(DIID_DToolbarEvents)
    //CONNECTION_POINT_ENTRY(IID_IPropertyNotifySink)
END_CONNECTION_POINT_MAP()

BEGIN_MSG_MAP(CToolbar)
    NOTIFY_CODE_HANDLER(TBN_GETINFOTIP, _OnGetInfoTip)
    MESSAGE_HANDLER(WM_SETFOCUS, OnSetFocus)
    COMMAND_RANGE_HANDLER(ID_BACK, ID_HOME, _OnButtonClick)
    MESSAGE_HANDLER(WM_APPCOMMAND, _OnAppCommand)
    MESSAGE_HANDLER(WM_CREATE, _OnCreate)
    MESSAGE_HANDLER(WM_DESTROY, _OnDestroy)
    MESSAGE_HANDLER(PWM_UPDATESIZE, _UpdateSize)
    CHAIN_MSG_MAP(CComControl<CToolbar>)
ALT_MSG_MAP(1)
    // Replace this with message map entries for superclassed ToolbarWindow32
END_MSG_MAP()
// Handler prototypes:
//  LRESULT MessageHandler(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
//  LRESULT CommandHandler(WORD wNotifyCode, WORD wID, HWND hWndCtl, BOOL& bHandled);
//  LRESULT NotifyHandler(int idCtrl, LPNMHDR pnmh, BOOL& bHandled);

    LRESULT _OnGetInfoTip(int /*idCtrl*/, LPNMHDR pnmh, BOOL& /*bHandled*/)
    {
        LPNMTBGETINFOTIP pgit = (LPNMTBGETINFOTIP)pnmh;
        ::LoadString(_Module.GetResourceInstance(),
                     pgit->iItem + (IDS_TOOLTIP_BACK - ID_BACK),
                     pgit->pszText,
                     pgit->cchTextMax);
        return 0;
    }

    LRESULT OnSetFocus(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled)
    {
        LRESULT lRes = CComControl<CToolbar>::OnSetFocus(uMsg, wParam, lParam, bHandled);
        if (m_bInPlaceActive)
        {
            DoVerbUIActivate(&m_rcPos,  NULL);
            if(!IsChild(::GetFocus()))
                m_ctlToolbar.SetFocus();
        }
        return lRes;
    }

    LRESULT _OnButtonClick(WORD, WORD wID, HWND, BOOL&)
    {
        Fire_OnButtonClick(wID - ID_BACK);
        return 0;
    }

    LRESULT _OnAppCommand(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT _OnCreate(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT _OnDestroy(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);
    LRESULT _UpdateSize(UINT uMsg, WPARAM wParam, LPARAM lParam, BOOL& bHandled);

// IOleInPlaceObject
    STDMETHOD(SetObjectRects)(LPCRECT prcPos, LPCRECT prcClip)
    {
        IOleInPlaceObjectWindowlessImpl<CToolbar>::SetObjectRects(prcPos, prcClip);
        m_ctlToolbar.SetWindowPos(NULL, 0, 0,
                                  prcPos->right - prcPos->left,
                                  prcPos->bottom - prcPos->top,
                                  SWP_NOZORDER | SWP_NOACTIVATE);
        return S_OK;
    }

// IViewObjectEx
    DECLARE_VIEW_STATUS(0)

// IOleControl
    STDMETHOD(GetControlInfo)(CONTROLINFO *pci)
    {
        if (!pci)
            return E_POINTER;
        pci->hAccel = m_hAccel;
        pci->cAccel = m_hAccel ? 3 : 0;
        pci->dwFlags = 0;
        return S_OK;
    }

    STDMETHOD(OnAmbientPropertyChange)(DISPID dispid);

    STDMETHOD(OnMnemonic)(MSG *pMsg)
    {
        WORD wID;
        if (m_hAccel && ::IsAccelerator(m_hAccel, 3, pMsg, &wID))
        {
            Fire_OnButtonClick(wID - ID_BACK);
            return S_OK;
        }
        return S_FALSE;
    }

// IOleInPlaceActiveObject
    STDMETHOD(TranslateAccelerator)(MSG *pMsg)
    {
        HRESULT hr = IOleInPlaceActiveObjectImpl<CToolbar>::TranslateAccelerator(pMsg);
        if (S_FALSE == hr)
        {
            hr = OnMnemonic(pMsg);
        }
        return hr;
    }

// IOleObject
    STDMETHOD(GetMiscStatus)(DWORD /*dwAspect*/, DWORD *pdwStatus)
    {
        if (!pdwStatus)
            return E_POINTER;
        *pdwStatus = OLEMISC_RECOMPOSEONRESIZE | OLEMISC_CANTLINKINSIDE | OLEMISC_INSIDEOUT | OLEMISC_ACTIVATEWHENVISIBLE | OLEMISC_SETCLIENTSITEFIRST;
        return S_OK;
    }

// IToolbar
    STDMETHOD(get_enabled)(/*[in]*/ VARIANT vIndex, /*[out, retval]*/ VARIANT_BOOL *pVal);
    STDMETHOD(put_enabled)(/*[in]*/ VARIANT vIndex, /*[in]*/ VARIANT_BOOL newVal);

// DToolbarEvents
    void Fire_OnButtonClick(int buttonIndex);

private:
    void _ClearAmbientFont(void);
    void _GetAmbientFont(void);

private:
    CContainedWindow m_ctlToolbar;
    HACCEL m_hAccel;
    IFont *m_pFont;
    HFONT m_hFont;
    HIMAGELIST m_himlNBDef;
    HIMAGELIST m_himlNBHot;
};

#endif //_NUSRMGR_TOOLBAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\poscpl\devices.c ===
/*
 *  DEVICES.C
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <cpl.h>

#include <setupapi.h>
#include <hidsdi.h>

#include "internal.h"
#include "res.h"
#include "debug.h"


ULONG numDeviceInstances = 0;
LIST_ENTRY allPOSDevicesList;



posDevice *NewPOSDevice(    DWORD dialogId,
                            HANDLE devHandle,
                            PWCHAR devPath,
                            PHIDP_PREPARSED_DATA pHidPreparsedData,
                            PHIDD_ATTRIBUTES pHidAttrib,
                            HIDP_CAPS *pHidCapabilities)
{
    posDevice *newPosDev;

    newPosDev = (posDevice *)GlobalAlloc(   GMEM_FIXED|GMEM_ZEROINIT, 
                                            sizeof(posDevice));
    if (newPosDev){

        newPosDev->sig = POSCPL_SIG;
        InitializeListHead(&newPosDev->listEntry);

        newPosDev->dialogId = dialogId;
        newPosDev->devHandle = devHandle;
        WStrNCpy(newPosDev->pathName, devPath, MAX_PATH);
        newPosDev->hidPreparsedData = pHidPreparsedData;
        newPosDev->hidAttrib = *pHidAttrib;
        newPosDev->hidCapabilities = *pHidCapabilities;

        /*
         *  Allocate components of the context
         */
        if (newPosDev->hidCapabilities.InputReportByteLength){
            newPosDev->readBuffer = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, 
                                                newPosDev->hidCapabilities.InputReportByteLength);
        }
        if (newPosDev->hidCapabilities.OutputReportByteLength){
            newPosDev->writeBuffer = GlobalAlloc(   GMEM_FIXED|GMEM_ZEROINIT, 
                                                    newPosDev->hidCapabilities.OutputReportByteLength);
        }
        #if USE_OVERLAPPED_IO
            newPosDev->overlappedReadEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
            newPosDev->overlappedWriteEvent = CreateEvent(NULL, TRUE, FALSE, NULL);
        #endif

        /*
         *  Check if we allocated everything successfully.
         */
        if (    
                (newPosDev->readBuffer || !newPosDev->hidCapabilities.InputReportByteLength) &&
                (newPosDev->writeBuffer || !newPosDev->hidCapabilities.OutputReportByteLength) &&
                #if USE_OVERLAPPED_IO
                    newPosDev->overlappedReadEvent  && 
                    newPosDev->overlappedWriteEvent &&
                #endif
                TRUE
            ){

            /*
             *  Created device context successfully.
             */


        }
        else {
            DBGERR(L"allocation error in NewPOSDevice()", 0);
            DestroyPOSDevice(newPosDev);
            newPosDev = NULL;
        }
    }

    ASSERT(newPosDev);
    return newPosDev;
}


VOID DestroyPOSDevice(posDevice *posDev)
{
    ASSERT(IsListEmpty(&posDev->listEntry));

    /*
     *  Note: this destroy function is called from a failed NewPOSDevice()
     *        call as well; so check every pointer before freeing.
     */
    if (posDev->readBuffer) GlobalFree(posDev->readBuffer);
    if (posDev->writeBuffer) GlobalFree(posDev->writeBuffer);
    if (posDev->hidPreparsedData) GlobalFree(posDev->hidPreparsedData);

    #if USE_OVERLAPPED_IO
        if (posDev->overlappedReadEvent) CloseHandle(posDev->overlappedReadEvent);
        if (posDev->overlappedWriteEvent) CloseHandle(posDev->overlappedWriteEvent);
    #endif

    GlobalFree(posDev);
}


VOID EnqueuePOSDevice(posDevice *posDev)
{
    ASSERT(IsListEmpty(&posDev->listEntry));
    InsertTailList(&allPOSDevicesList, &posDev->listEntry);
    numDeviceInstances++;
}


VOID DequeuePOSDevice(posDevice *posDev)
{
    ASSERT(!IsListEmpty(&allPOSDevicesList));
    ASSERT(!IsListEmpty(&posDev->listEntry));
    RemoveEntryList(&posDev->listEntry);
    InitializeListHead(&posDev->listEntry);
    numDeviceInstances--;
}


posDevice *GetDeviceByHDlg(HWND hDlg)
{
    posDevice *foundPosDev = NULL;
    LIST_ENTRY *listEntry;

    listEntry = &allPOSDevicesList;
    while ((listEntry = listEntry->Flink) != &allPOSDevicesList){        
        posDevice *thisPosDev;
    
        thisPosDev = CONTAINING_RECORD(listEntry, posDevice, listEntry);
        if (thisPosDev->hDlg == hDlg){
            foundPosDev = thisPosDev;
            break;
        }
    }

    return foundPosDev;
}


VOID OpenAllHIDPOSDevices()
{
    HDEVINFO hDevInfo;
    GUID hidGuid = {0};
    WCHAR devicePath[MAX_PATH];
    
    /*
     *  Call hid.dll to get the GUID for Human Input Devices.
     */
    HidD_GetHidGuid(&hidGuid);

    hDevInfo = SetupDiGetClassDevs( &hidGuid,
                                    NULL, 
                                    NULL,
                                    DIGCF_PRESENT | DIGCF_DEVICEINTERFACE);
    if (hDevInfo == INVALID_HANDLE_VALUE){
        DWORD err = GetLastError();
        DBGERR(L"SetupDiGetClassDevs failed", err);
    }
    else {
        int i;

        for (i = 0; TRUE; i++){
            SP_DEVICE_INTERFACE_DATA devInfoData = {0};
            BOOL ok;

            devInfoData.cbSize = sizeof(SP_DEVICE_INTERFACE_DATA);
            ok = SetupDiEnumDeviceInterfaces(   hDevInfo, 
                                                0, 
                                                &hidGuid,
                                                i,
                                                &devInfoData);
            if (ok){
                DWORD hwDetailLen = 0;

                /*
                 *  Call SetupDiGetDeviceInterfaceDetail with
                 *  a NULL PSP_DEVICE_INTERFACE_DETAIL_DATA pointer
                 *  just to get the length of the hardware details.
                 */
                ASSERT(devInfoData.cbSize == sizeof(SP_DEVICE_INTERFACE_DATA));
                ok = SetupDiGetDeviceInterfaceDetail(
                                        hDevInfo,
                                        &devInfoData,
                                        NULL,
                                        0,  
                                        &hwDetailLen,
                                        NULL);
                if (ok || (GetLastError() == ERROR_INSUFFICIENT_BUFFER)){
                    PSP_DEVICE_INTERFACE_DETAIL_DATA devDetails;

                    /*
                     *  Now make the real call to SetupDiGetDeviceInterfaceDetail.
                     */
                    ASSERT(hwDetailLen > sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA));
                    devDetails = GlobalAlloc(GMEM_FIXED|GMEM_ZEROINIT, hwDetailLen);
                    if (devDetails){
                        devDetails->cbSize = sizeof(SP_DEVICE_INTERFACE_DETAIL_DATA);
                        ok = SetupDiGetDeviceInterfaceDetail(
                                                hDevInfo,
                                                &devInfoData,
                                                devDetails,
                                                hwDetailLen,  
                                                &hwDetailLen,
                                                NULL);
                        if (ok){

                            /*
                             *  BUGBUG - FINISH
                             *  Right now, we only handle cash drawers.
                             *  And we only work with the APG cash drawers 
                             *  (with vendor-specific usages) for now.
                             */
                            // APG Cash Drawer wrote to say their VID is actually 1989
                            // WCHAR apgKbPathPrefix[] = L"\\\\?\\hid#vid_0f25&pid_0500";
							// Correct APG Cash Drawer VID (1989) to hexcode (07C5)
                            // WCHAR apgKbPathPrefix[] = L"\\\\?\\hid#vid_1989&pid_0500";
                            WCHAR apgKbPathPrefix[] = L"\\\\?\\hid#vid_07c5&pid_0500";

                            /*
                             *  If this is an APG keyboard, then the device path
                             *  (very long) will begin with apgKbPathPrefix.
                             */
                            if (RtlEqualMemory( devDetails->DevicePath,
                                                apgKbPathPrefix,
                                                sizeof(apgKbPathPrefix)-sizeof(WCHAR))){
                                HANDLE hDev;

                                // MessageBox(NULL, devDetails->DevicePath, L"DEBUG message - found APG kb", MB_OK);

                                hDev = CreateFile(  
                                            devDetails->DevicePath,
                                            GENERIC_READ | GENERIC_WRITE,
                                            FILE_SHARE_READ | FILE_SHARE_WRITE,  
                                            NULL,
                                            OPEN_EXISTING,                
                                            0,                 
                                            NULL);
                                if (hDev == INVALID_HANDLE_VALUE){
                                    DWORD err = GetLastError();
                                    DBGERR(L"CreateFile failed", err);
                                }
                                else {
                                    PHIDP_PREPARSED_DATA hidPreparsedData;

                                    // MessageBox(NULL, devDetails->DevicePath, L"DEBUG message - CreateFile succeeded", MB_OK);

                                    ok = HidD_GetPreparsedData(hDev, &hidPreparsedData);
                                    if (ok){
                                        HIDD_ATTRIBUTES hidAttrib;

                                        ok = HidD_GetAttributes(hDev, &hidAttrib);
                                        if (ok){
                                            HIDP_CAPS hidCapabilities;

                                            ok = HidP_GetCaps(hidPreparsedData, &hidCapabilities);
                                            if (ok){
                                                posDevice *posDev;
                                            
                                                posDev = NewPOSDevice(  IDD_POS_CASHDRAWER_DLG,
                                                                        hDev,
                                                                        devDetails->DevicePath,
                                                                        hidPreparsedData,
                                                                        &hidAttrib,
                                                                        &hidCapabilities);
                                                if (posDev){
                                                    EnqueuePOSDevice(posDev);
                                                }
                                                else {
                                                    ASSERT(posDev);
                                                }
                                            }
                                            else {
                                                DBGERR(L"HidP_GetCaps failed", 0);

                                            }
                                        }
                                        else {
                                            DWORD err = GetLastError();
                                            DBGERR(L"HidD_GetAttributes failed", err);
                                        }
                                    }
                                    else {
                                        DWORD err = GetLastError();
                                        DBGERR(L"HidD_GetPreparsedData failed", err);
                                    }
                                }
                            }
                        }
                        else {
                            DWORD err = GetLastError();
                            DBGERR(L"SetupDiGetDeviceInterfaceDetail(2) failed", err);
                        }

                        GlobalFree(devDetails);
                    }
                }
                else {
                    DWORD err = GetLastError();
                    DBGERR(L"SetupDiGetDeviceInterfaceDetail(1) failed", err);
                }
            }
            else {
                DWORD err = GetLastError();
                if (err != ERROR_NO_MORE_ITEMS){
                    DBGERR(L"SetupDiEnumDeviceInterfaces failed", err); 
                }
                break;
            }
        }

        SetupDiDestroyDeviceInfoList(hDevInfo);
    }

}


/*
 *  LaunchDeviceInstanceThread
 *
 *      Launch a thread for a device instance to read
 *      asynchronous events from the device.
 */
VOID LaunchDeviceInstanceThread(posDevice *posDev)
{
    DWORD threadId;

    posDev->hThread = CreateThread(NULL, 0, DeviceInstanceThread, posDev, 0, &threadId);
    if (posDev->hThread){

    }
    else {
        DWORD err = GetLastError();
        DBGERR(L"CreateThread failed", err);
    }

}


#if USE_OVERLAPPED_IO
    VOID CALLBACK OverlappedReadCompletionRoutine(  DWORD dwErrorCode,                
                                                    DWORD dwNumberOfBytesTransfered,  
                                                    LPOVERLAPPED lpOverlapped)
    {
        posDevice *posDev;
        
        /*
         *  We stashed our context in the hEvent field of the
         *  overlapped structure (this is allowed).
         */
        ASSERT(lpOverlapped);
        posDev = lpOverlapped->hEvent;
        ASSERT(posDev->sig == POSCPL_SIG);

        posDev->overlappedReadStatus = dwErrorCode;
        posDev->overlappedReadLen = dwNumberOfBytesTransfered;
        SetEvent(posDev->overlappedReadEvent);
    }
#endif


DWORD __stdcall DeviceInstanceThread(void *context)
{
    posDevice *posDev = (posDevice *)context;
    HANDLE hDevNew;

    ASSERT(posDev->sig == POSCPL_SIG);


    // BUGBUG - for some reason, reads and writes on the same handle
    //          interfere with one another
    hDevNew = CreateFile(  
                posDev->pathName,
                GENERIC_READ,
                FILE_SHARE_READ | FILE_SHARE_WRITE,  
                NULL,
                OPEN_EXISTING,                
                0,                 
                NULL);
    if (hDevNew == INVALID_HANDLE_VALUE){
        DWORD err = GetLastError();
        DBGERR(L"CreateFile failed", err);
    }
    else {

        /*
         *  Loop forever until main thread kills this thread.
         */
        while (TRUE){
            WCHAR drawerStateString[100];
            DWORD bytesRead = 0;
            BOOL ok;

            /*
             *  Load the default string for the drawer state
             */
            LoadString(g_hInst, IDS_DRAWERSTATE_UNKNOWN, drawerStateString, 100);

            ASSERT(posDev->hidCapabilities.InputReportByteLength > 0);
            ASSERT(posDev->readBuffer);

            #if USE_OVERLAPPED_IO
                /*
                 *  It's ok to stash our context in the hEvent field
                 *  of the overlapped structure.
                 */
                posDev->overlappedReadInfo.hEvent = (HANDLE)posDev;
                posDev->overlappedReadInfo.Offset = 0;
                posDev->overlappedReadInfo.OffsetHigh = 0;
                posDev->overlappedReadLen = 0;
                ResetEvent(posDev->overlappedReadEvent);
                ok = ReadFileEx(hDevNew,
                                posDev->readBuffer,
                                posDev->hidCapabilities.InputReportByteLength,
                                &posDev->overlappedReadInfo,
                                OverlappedReadCompletionRoutine);
                if (ok){
                    WaitForSingleObject(posDev->overlappedReadEvent, INFINITE);
                    ok = (posDev->overlappedReadStatus == NO_ERROR);
                    bytesRead = posDev->overlappedWriteLen;
                }
                else {
                    bytesRead = 0;
                }
            #else
                ok = ReadFile(  hDevNew,
                                posDev->readBuffer,
                                posDev->hidCapabilities.InputReportByteLength,
                                &bytesRead,
                                NULL);
            #endif


            if (ok){
                NTSTATUS ntStat;
                ULONG usageVal;

                ASSERT(bytesRead <= posDev->hidCapabilities.InputReportByteLength);

                ntStat = HidP_GetUsageValue(HidP_Input,
                                            USAGE_PAGE_CASH_DEVICE,
                                            0, // all collections
                                            USAGE_CASH_DRAWER_STATUS,
                                            &usageVal,
                                            posDev->hidPreparsedData,
                                            posDev->readBuffer,
                                            posDev->hidCapabilities.InputReportByteLength);
                if (ntStat == HIDP_STATUS_SUCCESS){
                    HWND hOpenButton;

                    /*
                     *  Get display string for new drawer state.
                     */
                    switch (usageVal){
                        case DRAWER_STATE_OPEN:
                            LoadString(g_hInst, IDS_DRAWERSTATE_OPEN, drawerStateString, 100);
                            break;
                        case DRAWER_STATE_CLOSED_READY:
                            LoadString(g_hInst, IDS_DRAWERSTATE_READY, drawerStateString, 100);
                            break;
                        case DRAWER_STATE_CLOSED_CHARGING:
                            LoadString(g_hInst, IDS_DRAWERSTATE_CHARGING, drawerStateString, 100);
                            break;
                        case DRAWER_STATE_LOCKED:
                            LoadString(g_hInst, IDS_DRAWERSTATE_LOCKED, drawerStateString, 100);
                            break;
                        default:
                            DBGERR(L"illegal usage", usageVal); 
                            break;
                    }

                    /*
                     *  Set 'Open' button based on the drawer state.
                     */
                    hOpenButton = GetDlgItem(posDev->hDlg, IDC_CASHDRAWER_OPEN);
                    if (hOpenButton){

                        LONG btnState = GetWindowLong(hOpenButton, GWL_STYLE);
                        switch (usageVal){
                            case DRAWER_STATE_OPEN:
                                btnState |= WS_DISABLED;
                                break;
                            default:
                                btnState &= ~WS_DISABLED;
                                break;
                        }
                        SetWindowLong(hOpenButton, GWL_STYLE, btnState);

                        /*
                         *  To make SetWindowLong take effect, you
                         *  sometimes have to call SetWindowPos.
                         */
                        SetWindowPos(hOpenButton, 0,
                                     0, 0, 0, 0,
                                     SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_HIDEWINDOW);
                        SetWindowPos(hOpenButton, 0,
                                     0, 0, 0, 0,
                                     SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER|SWP_SHOWWINDOW);
                    }
                    else {
                        DBGERR(L"GetDlgItem failed", 0);
                    }
                }
                else {
                    DBGERR(L"HidP_GetUsageValue failed", ntStat);
                    DBGERR(DBGHIDSTATUSSTR(ntStat), 0);
                }
            }
            else {
                DWORD err = GetLastError();
                DBGERR(L"ReadFile failed", err);
            }


            ASSERT(posDev->hDlg);
            ok = SetDlgItemText(posDev->hDlg, IDC_CASHDRAWER_STATETEXT, drawerStateString);
            if (ok){

            }
            else {
                DWORD err = GetLastError();
                DBGERR(L"SetDlgItemText failed", err);
            }
        }

        CloseHandle(hDevNew);
    }

    return NO_ERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\poscpl\cashdrwr.c ===
/*
 *  CASHDRWR.C
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <cpl.h>

#include <setupapi.h>
#include <hidsdi.h>

#include "internal.h"
#include "res.h"
#include "debug.h"



#if USE_OVERLAPPED_IO
    VOID CALLBACK OverlappedWriteCompletionRoutine( DWORD dwErrorCode,                
                                                    DWORD dwNumberOfBytesTransfered,  
                                                    LPOVERLAPPED lpOverlapped)
    {
        posDevice *posDev;
        
        /*
         *  We stashed our context in the hEvent field of the
         *  overlapped structure (this is allowed).
         */
        ASSERT(lpOverlapped);
        posDev = lpOverlapped->hEvent;
        ASSERT(posDev->sig == POSCPL_SIG);

        posDev->overlappedWriteStatus = dwErrorCode;
        posDev->overlappedWriteLen = dwNumberOfBytesTransfered;
        SetEvent(posDev->overlappedWriteEvent);
    }
#endif


BOOL SetCashDrawerState(posDevice *posDev, enum cashDrawerStates newState)
{
    NTSTATUS ntStat;
    BOOL result = FALSE;

    ASSERT(posDev->hidCapabilities.OutputReportByteLength <= 20);
    ntStat = HidP_SetUsageValue(HidP_Output,
                                USAGE_PAGE_CASH_DEVICE,
                                0, // all collections
                                USAGE_CASH_DRAWER_SET,
                                newState,
                                posDev->hidPreparsedData,
                                posDev->writeBuffer,
                                posDev->hidCapabilities.OutputReportByteLength);
    if (ntStat == HIDP_STATUS_SUCCESS){
        DWORD bytesWritten = 0;
        BOOL ok;

        ASSERT(posDev->hidCapabilities.OutputReportByteLength > 0);
        ASSERT(posDev->writeBuffer);

        #if USE_OVERLAPPED_IO
            /*
             *  It's ok to stash our context in the hEvent field
             *  of the overlapped structure.
             */
            posDev->overlappedWriteInfo.hEvent = (HANDLE)posDev;
            posDev->overlappedWriteInfo.Offset = 0;
            posDev->overlappedWriteInfo.OffsetHigh = 0;
            posDev->overlappedWriteLen = 0;
            ResetEvent(posDev->overlappedWriteEvent);
            ok = WriteFileEx(   posDev->devHandle,
                                posDev->writeBuffer,
                                posDev->hidCapabilities.OutputReportByteLength,
                                &posDev->overlappedWriteInfo,
                                OverlappedWriteCompletionRoutine);
            if (ok){
                WaitForSingleObject(posDev->overlappedWriteEvent, INFINITE);
                ok = (posDev->overlappedWriteStatus == NO_ERROR);
                bytesWritten = posDev->overlappedWriteLen;
            }
            else {
                bytesWritten = 0;
            }
        #else
            ok = WriteFile( posDev->devHandle,
                            posDev->writeBuffer,
                            posDev->hidCapabilities.OutputReportByteLength,
                            &bytesWritten,
                            NULL);
        #endif

        if (ok){
            ASSERT(bytesWritten <= posDev->hidCapabilities.OutputReportByteLength);
            result = TRUE;
        }
        else {
            DWORD err = GetLastError();
            DBGERR(L"WriteFile failed", err);
        }
    }
    else {
        DBGERR(L"HidP_SetUsageValue failed", ntStat);
        DBGERR(DBGHIDSTATUSSTR(ntStat), 0);
    }

    return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\poscpl\internal.h ===
/*
 *  INTERNAL.H
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */



#define USE_OVERLAPPED_IO   FALSE



typedef struct posDevice {
                            #define POSCPL_SIG 'CsoP'
                            DWORD sig;

                            LIST_ENTRY listEntry;

                            /*
                             *  Device type, identified by dialog
                             *  id for the device type
                             *  (e.g. IDD_POS_CASHDRAWER_DLG).
                             */
                            DWORD dialogId;

                            PHIDP_PREPARSED_DATA hidPreparsedData;
                            HIDD_ATTRIBUTES hidAttrib;
                            HIDP_CAPS hidCapabilities;

                            HWND hDlg;

                            HANDLE hThread;

                            PUCHAR readBuffer;
                            PUCHAR writeBuffer;

                            HANDLE devHandle;
                            WCHAR pathName[MAX_PATH];

                            #if USE_OVERLAPPED_IO
                                OVERLAPPED overlappedReadInfo;
                                NTSTATUS overlappedReadStatus;
                                DWORD overlappedReadLen;
                                HANDLE overlappedReadEvent;

                                OVERLAPPED overlappedWriteInfo;
                                NTSTATUS overlappedWriteStatus;
                                DWORD overlappedWriteLen;
                                HANDLE overlappedWriteEvent;
                            #endif
} posDevice;



/*
 *  These are non-standard vendor usage values and codes
 *  used by APG Cash Drawer.
 */
#define USAGE_PAGE_CASH_DEVICE          0x0F0
#define USAGE_CASH_DRAWER               0x0F1
#define USAGE_CASH_DRAWER_NUMBER        0x0F2
#define USAGE_CASH_DRAWER_SET           0x0F3
#define USAGE_CASH_DRAWER_STATUS        0x0F4
enum cashDrawerStates {
                        DRAWER_STATE_OPEN =             1,
                        DRAWER_STATE_CLOSED_READY =     2,
                        DRAWER_STATE_CLOSED_CHARGING =  3,
                        DRAWER_STATE_LOCKED =           4,
                      };





/*
 *  List macros -- not defined in winnt.h for some reason.
 */
#define InitializeListHead(ListHead) (\
    (ListHead)->Flink = (ListHead)->Blink = (ListHead))
#define IsListEmpty(ListHead) \
    ((ListHead)->Flink == (ListHead))
#define RemoveHeadList(ListHead) \
    (ListHead)->Flink;\
    {RemoveEntryList((ListHead)->Flink)}
#define RemoveTailList(ListHead) \
    (ListHead)->Blink;\
    {RemoveEntryList((ListHead)->Blink)}
#define RemoveEntryList(Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_Flink;\
    _EX_Flink = (Entry)->Flink;\
    _EX_Blink = (Entry)->Blink;\
    _EX_Blink->Flink = _EX_Flink;\
    _EX_Flink->Blink = _EX_Blink;\
    }
#define InsertTailList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Blink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Blink = _EX_ListHead->Blink;\
    (Entry)->Flink = _EX_ListHead;\
    (Entry)->Blink = _EX_Blink;\
    _EX_Blink->Flink = (Entry);\
    _EX_ListHead->Blink = (Entry);\
    }
#define InsertHeadList(ListHead,Entry) {\
    PLIST_ENTRY _EX_Flink;\
    PLIST_ENTRY _EX_ListHead;\
    _EX_ListHead = (ListHead);\
    _EX_Flink = _EX_ListHead->Flink;\
    (Entry)->Flink = _EX_Flink;\
    (Entry)->Blink = _EX_ListHead;\
    _EX_Flink->Blink = (Entry);\
    _EX_ListHead->Flink = (Entry);\
    }



/*
 *  Function prototypes
 */
VOID LaunchPOSDialog(HWND hwndCPl);
INT_PTR APIENTRY POSDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
INT_PTR APIENTRY NullPOSDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
posDevice *NewPOSDevice(DWORD dialogId, HANDLE devHandle, PWCHAR devPath, PHIDP_PREPARSED_DATA pHidPreparsedData, PHIDD_ATTRIBUTES pHidAttrib, HIDP_CAPS *pHidCapabilities);
VOID DestroyPOSDevice(posDevice *posDev);
VOID EnqueuePOSDevice(posDevice *posDev);
VOID DequeuePOSDevice(posDevice *posDev);
VOID OpenAllHIDPOSDevices();
VOID IntToWChar(WCHAR *buf, DWORD x);
VOID HexToWChar(WCHAR *buf, DWORD x);
ULONG WStrNCpy(WCHAR *dest, const WCHAR *src, ULONG maxWChars);
ULONG AsciiToWChar(WCHAR *dest, const char *src, ULONG maxChars);
posDevice *GetDeviceByHDlg(HWND hDlg);
VOID LaunchDeviceInstanceThread(posDevice *posDev);
DWORD __stdcall DeviceInstanceThread(void *context);
BOOL SetCashDrawerState(posDevice *posDev, enum cashDrawerStates newState);
#if USE_OVERLAPPED_IO
    VOID CALLBACK OverlappedReadCompletionRoutine(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped);
    VOID CALLBACK OverlappedWriteCompletionRoutine(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped);
#endif



/*
 *  Externs
 */
extern HANDLE g_hInst;
extern ULONG numDeviceInstances;
extern LIST_ENTRY allPOSDevicesList;
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\poscpl\msr.c ===
/*
 *  MSR.C
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <cpl.h>

#include <setupapi.h>
#include <hidsdi.h>

#include "internal.h"
#include "res.h"
#include "debug.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\poscpl\poscpl.c ===
/*
 *  POSCPL.C
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <cpl.h>

#include <setupapi.h>
#include <hidsdi.h>

#include "internal.h"
#include "res.h"
#include "debug.h"




HANDLE g_hInst = NULL;


BOOL WINAPI LibMain(HANDLE hDll, DWORD dwReason, LPVOID lpReserved)
{
    switch (dwReason){

        case DLL_PROCESS_ATTACH:
            g_hInst = hDll;
            DisableThreadLibraryCalls(hDll);
            InitializeListHead(&allPOSDevicesList);
            break;

        case DLL_PROCESS_DETACH:
        case DLL_THREAD_DETACH:
        case DLL_THREAD_ATTACH:
        default:
            break;
    }

    return TRUE;
}


LONG CPlApplet(HWND hwndCPl, UINT uMsg, LPARAM lParam1, LPARAM lParam2)
{
    LONG result = 0L;

	switch (uMsg){

		case CPL_INIT:
            result = 1;
			break;

        case CPL_GETCOUNT:
            result = 1;
			break;

		case CPL_INQUIRE:
            {
                LPCPLINFO pcplinfo = (LPCPLINFO)lParam2;
                switch (lParam1){
                    case 0:
                        pcplinfo->idIcon = IDI_POSCPL_ICON;
                        pcplinfo->idName = IDS_CAPTION;
                        pcplinfo->idInfo = IDS_DESCRIPTION;
                        break;
                    case 1:     // BUGBUG
                        pcplinfo->idIcon = IDI_POSCPL_ICON;
                        pcplinfo->idName = IDS_CAPTION;
                        pcplinfo->idInfo = IDS_DESCRIPTION;
                        break;
                    }
                pcplinfo->lData = 0L;
            }
            result = 1;
			break;

		case CPL_SELECT:
            result = 0;  // BUGBUG ?
			break;

		case CPL_DBLCLK:
            /*
             *  The CPL was selected by the user.
             *  Show our main dialog.
             */
            switch (lParam1){

                case 0:

                    OpenAllHIDPOSDevices();
                    
                    LaunchPOSDialog(hwndCPl);

                    break;
            }
			break;

		case CPL_STOP:
            result = 1;     // BUGBUG ?
			break;

		case CPL_EXIT:
            result = 1;
			break;

		case CPL_NEWINQUIRE:
            {
                LPNEWCPLINFO pnewcplinfo = (LPNEWCPLINFO)lParam2;
                switch (lParam1){
                    case 0:
                        pnewcplinfo->hIcon = LoadIcon(g_hInst, MAKEINTRESOURCE(IDI_POSCPL_ICON));
                        // BUGBUG LoadString(g_hInst, IDS_xxx, pnewcplinfo->szName, sizeof(pnewcplinfo->szName));
                        // BUGBUG LoadString(g_hInst, IDS_xxx, pnewcplinfo->szInfo, sizeof(pnewcplinfo->szInfo));
                        break;
                }
                pnewcplinfo->dwHelpContext = 0;
                pnewcplinfo->dwSize = sizeof(NEWCPLINFO);
                pnewcplinfo->lData = 0L;
                pnewcplinfo->szHelpFile[0] = 0;
            }
            result = 1;
			break;

        default:
            result = 0;
            break;
    }

    return result;
}


VOID LaunchPOSDialog(HWND hwndCPl)
{
    PROPSHEETPAGE *propSheetPages;
    ULONG numPropSheetPages;
    
    /*
     *  Make sure we allocate at least one propsheetpage,
     *  even if there are no devices.
     */
    numPropSheetPages = (numDeviceInstances == 0) ? 1 : numDeviceInstances;
    propSheetPages = GlobalAlloc(   GMEM_FIXED|GMEM_ZEROINIT,
                                    numPropSheetPages*sizeof(PROPSHEETPAGE));

    if (propSheetPages){
        PROPSHEETHEADER propSheetHeader = {0};

        if (numDeviceInstances == 0){
            /*
             *  If there are no POS devices, 
             *  then put up a single tab saying so.
             */
            propSheetPages[0].dwSize = sizeof(PROPSHEETPAGE);
            propSheetPages[0].dwFlags = PSP_DEFAULT;
            propSheetPages[0].hInstance = g_hInst;
            propSheetPages[0].pszTemplate = MAKEINTRESOURCE(IDD_NO_DEVICES_DLG);
            propSheetPages[0].pszIcon = NULL;   // PSP_USEICONID not set in dwFlags
            propSheetPages[0].pszTitle = MAKEINTRESOURCE("BUGBUG");  // PSP_USETITLE not set in dwFlags
            propSheetPages[0].pfnDlgProc = NullPOSDlgProc;
            propSheetPages[0].lParam = (LPARAM)NULL;
            propSheetPages[0].pfnCallback = NULL;
            propSheetPages[0].pcRefParent = NULL;
        }
        else {
            LIST_ENTRY *listEntry;
            ULONG i;

            /*
             *  Create the array of property sheet handles
             */
            i = 0;
            listEntry = &allPOSDevicesList;
            while ((listEntry = listEntry->Flink) != &allPOSDevicesList){        
                posDevice *posDev;
            
                posDev = CONTAINING_RECORD(listEntry, posDevice, listEntry);

                ASSERT(i < numDeviceInstances);
                propSheetPages[i].dwSize = sizeof(PROPSHEETPAGE);
                propSheetPages[i].dwFlags = PSP_DEFAULT;
                propSheetPages[i].hInstance = g_hInst;
                propSheetPages[i].pszTemplate = MAKEINTRESOURCE(posDev->dialogId);
                propSheetPages[i].pszIcon = NULL;   // PSP_USEICONID not set in dwFlags
                propSheetPages[i].pszTitle = MAKEINTRESOURCE("BUGBUG");  // PSP_USETITLE not set in dwFlags
                propSheetPages[i].pfnDlgProc = POSDlgProc;
                propSheetPages[i].lParam = (LPARAM)posDev;  // BUGBUG ? - context ?
                propSheetPages[i].pfnCallback = NULL;
                propSheetPages[i].pcRefParent = NULL;

                i++;
            }
        }

        /*
         *  Initialize the property sheet header
         */
        propSheetHeader.dwSize = sizeof(PROPSHEETHEADER);
        propSheetHeader.dwFlags = PSH_PROPTITLE | PSH_PROPSHEETPAGE;
        propSheetHeader.hwndParent = hwndCPl;
        propSheetHeader.hInstance = g_hInst;
        propSheetHeader.pszIcon = NULL;
        propSheetHeader.pszCaption = MAKEINTRESOURCE(IDS_DIALOG_TITLE);
        propSheetHeader.ppsp = propSheetPages;
        propSheetHeader.nPages = numPropSheetPages; 


        /*
         *  Launch the property sheet tabbed dialog
         */
        PropertySheet(&propSheetHeader);

        GlobalFree(propSheetPages);
    }
    else {
        ASSERT(propSheetPages);
    }
}


INT_PTR APIENTRY POSDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL result = TRUE;

    switch (uMsg){

        case WM_INITDIALOG:
            {
                /*
                 *  On the WM_INITDIALOG only, lParam points to
                 *  our propSheetPage, which contains our posDevice
                 *  context (in the 'lParam' field).  This is our
                 *  only chance to associate the posDevice context
                 *  with the actual dialog for future calls.
                 */
                PROPSHEETPAGE *propSheetPage = (PROPSHEETPAGE *)lParam;
                posDevice *posDev = (posDevice *)propSheetPage->lParam;

                ASSERT(posDev->sig == POSCPL_SIG);

                posDev->hDlg = hDlg;
                
                LaunchDeviceInstanceThread(posDev);
            }
            break;

        case WM_NOTIFY:
            switch (((NMHDR FAR*)lParam)->code){
                case PSN_APPLY:
                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    break;
                default:
                    result = FALSE;
                    break;
            }
            break;

        case WM_COMMAND:
            switch (LOWORD(wParam)){

                case IDC_SELECT_DEVICETYPE:
                    break;

                case IDC_CASHDRAWER_STATE:
                    break;

                case IDC_CASHDRAWER_STATETEXT:
                    break;

                case IDC_CASHDRAWER_OPEN:
                    {
                        posDevice *posDev;

                        posDev = GetDeviceByHDlg(hDlg);
                        if (posDev){
                            SetCashDrawerState(posDev, DRAWER_STATE_OPEN);
                        }
                        else {
                            DBGERR(L"GetDeviceByHDlg failed", 0);
                        }
                    }
                    break;

                case IDC_MSR_TEXT:
                    break;

                case IDC_STATIC1:
                case IDC_STATIC2:
                    break;

            }
            break;

        case WM_DESTROY:
            {
                LIST_ENTRY *listEntry = &allPOSDevicesList;
                while ((listEntry = listEntry->Flink) != &allPOSDevicesList){        
                    posDevice *posDev = CONTAINING_RECORD(listEntry, posDevice, listEntry);
                    if (posDev->hThread){

                        #if 0
                            // BUGBUG FINISH - kill the thread

                            WaitForSingleObject(posDev->hThread, INFINITE);
                            CloseHandle(posDev->hThread);
                        #endif
                    }
                }
            }
            break;

        case WM_HELP: 
            break;

        case WM_CONTEXTMENU:
            break;

        default:
            result = FALSE;
            break;
    }

    return (INT_PTR)result;
}


/*
 *  NullPOSDlgProc
 *
 *      This is the dialog proc when we have no POS devices to display.
 */
INT_PTR APIENTRY NullPOSDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL result = TRUE;

    switch (uMsg){

        case WM_NOTIFY:
            switch (((NMHDR FAR*)lParam)->code){
                case PSN_APPLY:
                    SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                    break;
                default:
                    result = FALSE;
                    break;
            }
            break;

        default:
            result = FALSE;
            break;
    }

    return (INT_PTR)result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\poscpl\resource.h ===
/*
 *  RESOURCE.H
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */


/*
 *  Icon identifiers
 */
#define	IDI_POSCPL_ICON			        1


/*
 *  String identifiers
 */
#define IDS_DIALOG_TITLE                101
#define IDS_CAPTION                     102
#define IDS_DESCRIPTION                 103
#define IDS_DRAWERSTATE_UNKNOWN         104
#define IDS_DRAWERSTATE_OPEN            105
#define IDS_DRAWERSTATE_READY           106
#define IDS_DRAWERSTATE_CHARGING        107
#define IDS_DRAWERSTATE_LOCKED          108


/*
 *  Prop sheet page identifiers (one for each POS device type)
 */
#define IDD_POS_CASHDRAWER_DLG          1   
#define IDD_POS_MSR_DLG                 2

#define IDD_DEVICETYPE_NONE             11
#define IDD_DEVICETYPE_CASHDRAWER       12   
#define IDD_DEVICETYPE_MSR              13

/*
 *  Dialog control identifiers
 */
#define IDC_SELECT_DEVICETYPE           51
#define IDC_CASHDRAWER_STATE            52
#define IDC_CASHDRAWER_STATETEXT        53
#define IDC_CASHDRAWER_OPEN             54
#define IDC_MSR_TEXT                    55
#define IDC_STATIC1                     56
#define IDC_STATIC2                     57
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\advanced.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    advanced.h

Abstract:

    Public declarations for the Advanced tab of the System Control Panel 
    Applet.

Author:

    Scott Hallock (scotthal) 15-Oct-1997

--*/
#ifndef _SYSDM_ADVANCED_H_
#define _SYSDM_ADVANCED_H_

INT_PTR
APIENTRY
AdvancedDlgProc(
    IN HWND hDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
);

void DoPerformancePS(HWND hDlg);

#endif // _SYSDM_ADVANCED_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\poscpl\res.h ===
/*
 *  RESOURCE.H
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */


/*
 *  Icon identifiers
 */
#define	IDI_POSCPL_ICON			        1


/*
 *  String identifiers
 */
#define IDS_DIALOG_TITLE                101
#define IDS_CAPTION                     102
#define IDS_DESCRIPTION                 103
#define IDS_DRAWERSTATE_UNKNOWN         104
#define IDS_DRAWERSTATE_OPEN            105
#define IDS_DRAWERSTATE_READY           106
#define IDS_DRAWERSTATE_CHARGING        107
#define IDS_DRAWERSTATE_LOCKED          108


/*
 *  Prop sheet page identifiers (one for each POS device type)
 */
#define IDD_NO_DEVICES_DLG              1
#define IDD_POS_CASHDRAWER_DLG          2
#define IDD_POS_MSR_DLG                 3

#define IDD_DEVICETYPE_NONE             11
#define IDD_DEVICETYPE_CASHDRAWER       12   
#define IDD_DEVICETYPE_MSR              13

/*
 *  Dialog control identifiers
 */
#define IDC_SELECT_DEVICETYPE           51
#define IDC_CASHDRAWER_STATE            52
#define IDC_CASHDRAWER_STATETEXT        53
#define IDC_CASHDRAWER_OPEN             54
#define IDC_MSR_TEXT                    55
#define IDC_STATIC1                     56
#define IDC_STATIC2                     57
#define IDC_NO_DEVICES_TEXT             58
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\poscpl\util.c ===
/*
 *  UTIL.C
 *
 *		Point-of-Sale Control Panel Applet
 *
 *      Author:  Ervin Peretz
 *
 *      (c) 2001 Microsoft Corporation 
 */

#include <windows.h>
#include <windowsx.h>
#include <commctrl.h>
#include <cpl.h>

#include <setupapi.h>
#include <hidsdi.h>

#include "internal.h"
#include "res.h"
#include "debug.h"



/*
 *  WStrNCpy
 *
 *      Like wcsncpy, but terminates the string if truncated.
 *      Also, tolerates NULL src string.
 */
ULONG WStrNCpy(WCHAR *dest, const WCHAR *src, ULONG maxWChars)
{
    ULONG wCharsWritten = 0;

    ASSERT(dest);

    if (src){
        while ((maxWChars-- > 1) && (*dest++ = *src++)){
            wCharsWritten++;
        }
        if (maxWChars == 1){
            *dest = L'\0';
            wCharsWritten++;
        }
    }
    else {
        *dest = L'\0';
        wCharsWritten++;
    }

    return wCharsWritten;
}


/*
 *  AsciiToWChar
 *
 *      Like mbstowcs, but terminates the string if truncated.
 *      Also, tolerates NULL ascii string.
 */
ULONG AsciiToWChar(WCHAR *dest, const char *src, ULONG maxChars)
{
    ULONG charsWritten = 0;

    if (src){
        while ((maxChars-- > 1) && (*dest++ = (WCHAR)*src++)){
            charsWritten++;
        }
        if (maxChars == 1){
            *dest = (WCHAR)NULL;
            charsWritten++;
        }
    }
    else {
        *dest = (WCHAR)NULL;
        charsWritten++;
    }

    return charsWritten;
}


VOID IntToWChar(WCHAR *buf, DWORD x)
{
	int i;
	WCHAR tmpbuf[11] = {0};

    if (x){
	    for (i = 10; x && (i >= 0); i--){
		    tmpbuf[i] = (WCHAR)(L'0' + (x % 10));
		    x /= 10;
	    }

	    WStrNCpy(buf, &tmpbuf[i+1], 11);
    }
    else {
        WStrNCpy(buf, L"0", 2);
    }
}


VOID HexToWChar(WCHAR *buf, DWORD x)
{
	int i;
	WCHAR tmpbuf[9] = {0};

    if (x){
	    for (i = 7; x && (i >= 0); i--){
            ULONG nibble = (x % 16);
            if (nibble < 10){
		        tmpbuf[i] = (WCHAR)(L'0' + nibble);
            }
            else {
                tmpbuf[i] = (WCHAR)(L'A' + nibble - 10);
            }
		    x /= 16;
	    }

	    WStrNCpy(buf, &tmpbuf[i+1], 9);
    }
    else {
        WStrNCpy(buf, L"0", 2);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\advanced.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    advanced.c

Abstract:

    Implements the Advanced tab of the System Control Panel Applet.

Author:

    Scott Hallock (scotthal) 15-Oct-1997

--*/
#include "sysdm.h"

//
// Help IDs
//
DWORD aAdvancedHelpIds[] = {
    IDC_ADV_PERF_TEXT,             (IDH_ADVANCED + 0),
    IDC_ADV_PERF_BTN,              (IDH_ADVANCED + 1),
    IDC_ADV_ENV_TEXT,              (IDH_ADVANCED + 2),
    IDC_ADV_ENV_BTN,               (IDH_ADVANCED + 3),
    IDC_ADV_RECOVERY_TEXT,         (IDH_ADVANCED + 4),
    IDC_ADV_RECOVERY_BTN,          (IDH_ADVANCED + 5),
    IDC_ADV_PROF_TEXT,             (IDH_ADVANCED + 6),
    IDC_ADV_PROF_BTN,              (IDH_ADVANCED + 7),
    IDC_ADV_PFR_BTN,               (IDH_PFR + 99),
    0, 0
};
//
// Private function prototypes
//
BOOL
AdvancedHandleCommand(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
);

BOOL
AdvancedHandleNotify(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
);


INT_PTR
APIENTRY
AdvancedDlgProc(
    IN HWND hDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles messages sent to the Advanced page

Arguments:

    hDlg -
        Window handle

    uMsg -
        Message being sent

    wParam -
        Message parameter

    lParam -
        Message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
{

    switch (uMsg) {
        case WM_COMMAND:
            return(AdvancedHandleCommand(hDlg, wParam, lParam));
            break;

        case WM_NOTIFY:
            return(AdvancedHandleNotify(hDlg, wParam, lParam));
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP, (DWORD_PTR) (LPSTR) aAdvancedHelpIds);
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) aAdvancedHelpIds);
            break;

        default:
            return(FALSE);
    } // switch

    return(TRUE);

}

static const PSPINFO c_pspPerf[] =
{
    { CreatePage,   IDD_VISUALEFFECTS,  VisualEffectsDlgProc    },
    { CreatePage,   IDD_ADVANCEDPERF,   PerformanceDlgProc      },
};

void DoPerformancePS(HWND hDlg)
{
    PROPSHEETHEADER psh;
    HPROPSHEETPAGE rPages[ARRAYSIZE(c_pspPerf)];
    int i;

    //
    // Property sheet stuff.
    //
    psh.dwSize = sizeof(psh);
    psh.dwFlags = PSH_DEFAULT;
    psh.hInstance = hInstance;
    psh.hwndParent = hDlg;
    psh.pszCaption = MAKEINTRESOURCE(IDS_PERFOPTIONS);
    psh.nPages = 0;
    psh.nStartPage = 0;
    psh.phpage = rPages;

    for (i = 0; i < ARRAYSIZE(c_pspPerf); i++)
    {
        rPages[psh.nPages] = c_pspPerf[i].pfnCreatePage(c_pspPerf[i].idd, c_pspPerf[i].pfnDlgProc);
        if (rPages[psh.nPages] != NULL)
        {
            psh.nPages++;
        }
    }

    //
    // Display the property sheet.
    //
    PropertySheet(&psh);
}

BOOL
AdvancedHandleCommand(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles WM_COMMAND messages sent to Advanced tab

Arguments:

    hDlg -
        Supplies window handle

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
{
    DWORD_PTR dwResult = 0;

    switch (LOWORD(wParam))
    {
        case IDC_ADV_PERF_BTN:
            DoPerformancePS(hDlg);        
            break;
    
        case IDC_ADV_PROF_BTN:
        {
            dwResult = DialogBox(
                hInstance,
                (LPTSTR) MAKEINTRESOURCE(IDD_USERPROFILE),
                hDlg,
                UserProfileDlgProc);
            break;
        }

        case IDC_ADV_ENV_BTN:
            dwResult = DialogBox(
                hInstance,
                (LPTSTR) MAKEINTRESOURCE(IDD_ENVVARS),
                hDlg,
                EnvVarsDlgProc
            );

            break;

        case IDC_ADV_RECOVERY_BTN:
            dwResult = DialogBox(
                hInstance,
                (LPTSTR) MAKEINTRESOURCE(IDD_STARTUP),
                hDlg,
                StartupDlgProc
            );

            break;

        case IDC_ADV_PFR_BTN:
        {
            INITCOMMONCONTROLSEX    icex;

            icex.dwSize = sizeof(icex);
            icex.dwICC  = ICC_LISTVIEW_CLASSES;

            if (InitCommonControlsEx(&icex) == FALSE)
                MessageBoxW(NULL, L"ICEX failed.", NULL, MB_OK);

            dwResult = DialogBox(hInstance, 
                                 MAKEINTRESOURCE(IsOS(OS_ANYSERVER) ? IDD_PFR_REPORTSRV : IDD_PFR_REPORT),
                                 hDlg, 
                                 PFRDlgProc);
            break;
        }

        default:
            return(FALSE);
    } // switch

    return(TRUE);

}


BOOL
AdvancedHandleNotify(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles WM_NOTIFY messages sent to Advanced tab

Arguments:

    hDlg -
        Supplies window handle

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
{
    LPNMHDR pnmh = (LPNMHDR) lParam;
    LPPSHNOTIFY psh = (LPPSHNOTIFY) lParam;

    switch (pnmh->code) {
        case PSN_APPLY:
            //
            // If the user is pressing "OK" and a reboot is required,
            // send the PSM_REBOOTSYSTEM message.
            //
            if ((psh->lParam) && g_fRebootRequired) {
                PropSheet_RebootSystem(GetParent(hDlg));
            } // if

            break;

        default:
            return(FALSE);

    } // switch

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\debug.c ===
//*************************************************************
//  File name:    DEBUG.C
//
//  Description:  Debug helper code for System control panel
//                applet
//
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1992-2000
//  All rights reserved
//
//*************************************************************
#include "sysdm.h"

// Define some things for debug.h
#define SZ_DEBUGINI         "ccshell.ini"
#define SZ_DEBUGSECTION     "SYSDM"
#define SZ_MODULE           "SYSDM"
#define DECLARE_DEBUG

#include <ccstock.h>
#include <debug.h>

#ifdef DBG_CODE

/*
 * Buffer used for OutputDebugString formatting (See DbgPrintf and DbgStopX)
 */
TCHAR g_szDbgOutBuffer[1024];

#define COMPILETIME_ASSERT(f) switch (0) case 0: case f:

//***************************************************************
//
// void DbgPrintf( LPTSTR szFmt, ... )
//
//  Formatted version of OutputDebugString
//
//  Parameters: Same as printf()
//
//  History:
//      18-Jan-1996 JonPa       Wrote it
//***************************************************************
void DbgPrintf( LPTSTR szFmt, ... ) {
    va_list marker;

    va_start( marker, szFmt );

    StringCchVPrintf( g_szDbgOutBuffer, ARRAYSIZE(g_szDbgOutBuffer), szFmt, marker); // truncation ok
    OutputDebugString( g_szDbgOutBuffer );

    va_end( marker );
}


//***************************************************************
//
// void DbgStopX(LPSTR mszFile, int iLine, LPTSTR szText )
//
//  Print a string (with location id) and then break
//
//  Parameters:
//      mszFile     ANSI filename (__FILE__)
//      iLine       line number   (__LINE__)
//      szText      Text string to send to debug port
//
//  History:
//      18-Jan-1996 JonPa       Wrote it
//***************************************************************
void DbgStopX(LPSTR mszFile, int iLine, LPTSTR szText )
{
    StringCchPrintf(g_szDbgOutBuffer, ARRAYSIZE(g_szDbgOutBuffer), TEXT("SYSDM.CPL (%hs %d) : %s\n"), mszFile, iLine, szText);  // truncation ok
    OutputDebugString(g_szDbgOutBuffer);

    DebugBreak();
}

#endif // DBG_CODE
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\edtenvar.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    edtenvar.c

Abstract:

    Implements the Edit Environment Variables dialog of the
    System Control Panel Applet

Author:

    Scott Hallock (scotthal) 11-Nov-1997

Revision History:

--*/
#include "sysdm.h"

//
// Global Variables
//
UINT g_VarType = INVALID_VAR_TYPE;
UINT g_EditType = INVALID_EDIT_TYPE;
TCHAR g_szVarName[BUFZ];
TCHAR g_szVarValue[BUFZ];

//
// Help IDs
//
DWORD aEditEnvVarsHelpIds[] = {
    IDC_ENVVAR_EDIT_NAME_LABEL,  (IDH_ENV_EDIT + 0),
    IDC_ENVVAR_EDIT_NAME,        (IDH_ENV_EDIT + 0),
    IDC_ENVVAR_EDIT_VALUE_LABEL, (IDH_ENV_EDIT + 1),
    IDC_ENVVAR_EDIT_VALUE,       (IDH_ENV_EDIT + 1),
    0, 0
};

//
// Function prototypes
//
BOOL
InitEnvVarsEdit(
    IN HWND hDlg
);

BOOL
EnvVarsEditHandleCommand(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
);

//
// Function implementation
//
INT_PTR
APIENTRY
EnvVarsEditDlg(
    IN HWND hDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles messages sent to the New.../Edit... dialog.

Arguments:

    hDlg -
        Supplies the window handle

    uMsg -
        Supplies the message being sent

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled.
    FALSE if message was unhandled.

--*/
{
    BOOL fInitializing = FALSE;

    switch (uMsg) {
        case WM_INITDIALOG: {
            BOOL fSuccess = FALSE;

            fInitializing = TRUE;

            fSuccess = InitEnvVarsEdit(hDlg);
            if (!fSuccess) {
                EndDialog(hDlg, EDIT_ERROR);
            } // if

            fInitializing = FALSE;
            break;
        } // case WM_INITDIALOG

        case WM_COMMAND:
            return EnvVarsEditHandleCommand(hDlg, wParam, lParam);
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP, (DWORD_PTR) (LPSTR) aEditEnvVarsHelpIds);
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) aEditEnvVarsHelpIds);
            break;

        default:
            return(FALSE);
            break;

    } // switch (uMsg)

    return(TRUE);
}

BOOL
InitEnvVarsEdit(
    IN HWND hDlg
)
/*++

Routine Description:

    Initializes the Edit Environment Variables dialog by placing initial
    values into the text editing controls if necessary.

Arguments:

    hDlg -
        Supplies window handle

Return Value:

    TRUE if successful
    FALSE if an error occurs

--*/
{
    TCHAR szCaption[EDIT_ENVVAR_CAPTION_LENGTH];
    LRESULT fRetVal = FALSE;
    INT  nResult = 0;

    ASSERT(INVALID_EDIT_TYPE != g_EditType);
    ASSERT(INVALID_VAR_TYPE != g_VarType);

    __try {

        fRetVal = SendMessage(
            GetDlgItem(hDlg, IDC_ENVVAR_EDIT_NAME),
            EM_LIMITTEXT,
            MAX_PATH - 1,
            0
        );
        fRetVal = SendMessage(
            GetDlgItem(hDlg, IDC_ENVVAR_EDIT_VALUE),
            EM_LIMITTEXT,
            MAX_VALUE_LEN - 1,
            0
        );

        switch (g_EditType) {
            //
            // If this is to be a New.. dialog, we only need to
            // load the proper capiton for the variable type
            //
            case NEW_VAR:

                switch (g_VarType) {
                    case SYSTEM_VAR:
                        nResult = LoadString(
                            hInstance,
                            IDS_NEW_SYSVAR_CAPTION,
                            szCaption,
                            EDIT_ENVVAR_CAPTION_LENGTH
                        );
                        break;

                    case USER_VAR:
                        nResult = LoadString(
                            hInstance,
                            IDS_NEW_USERVAR_CAPTION,
                            szCaption,
                            EDIT_ENVVAR_CAPTION_LENGTH
                        );
                        break;

                    default:
                        __leave;
                        break;
                } // switch (g_VarType)

                //
                // Set the focus to the "Name" field
                // SetFocus() doesn't want to work here
                //
                PostMessage(
                    hDlg, 
                    WM_NEXTDLGCTL,
                    (WPARAM) GetDlgItem(hDlg, IDC_ENVVAR_EDIT_NAME),
                    (LPARAM) TRUE
                );

                break;

            //
            // If this is to be an Edit.. dialog, then we need to load the
            // proper caption and fill in initial values for the edit
            // controls
            //
            case EDIT_VAR:

                switch (g_VarType) {
                    case SYSTEM_VAR:
                        nResult = LoadString(
                            hInstance,
                            IDS_EDIT_SYSVAR_CAPTION,
                            szCaption,
                            EDIT_ENVVAR_CAPTION_LENGTH
                        );
                        break;

                     case USER_VAR:
                        nResult = LoadString(
                            hInstance,
                            IDS_EDIT_USERVAR_CAPTION,
                            szCaption,
                            EDIT_ENVVAR_CAPTION_LENGTH
                        );
                        break;
    
                    default:
                         __leave;
                        break;
                } // switch (g_VarType)
        
                SetDlgItemText(
                    hDlg,
                    IDC_ENVVAR_EDIT_NAME,
                    g_szVarName
                );
                SetDlgItemText(
                    hDlg,
                    IDC_ENVVAR_EDIT_VALUE,
                    g_szVarValue
                );

                //
                // Set the focus to the "Value" field
                // SetFocus() doesn't want to work here
                //
                PostMessage(
                    hDlg, 
                    WM_NEXTDLGCTL,
                    (WPARAM) GetDlgItem(hDlg, IDC_ENVVAR_EDIT_VALUE),
                    (LPARAM) TRUE
                );
        
                break;
        } // switch (g_EditType)
        
        fRetVal = SendMessage(
            GetDlgItem(hDlg, IDC_ENVVAR_EDIT_NAME),
            EM_SETSEL,
            0,
            -1
        );
        fRetVal = SendMessage(
            GetDlgItem(hDlg, IDC_ENVVAR_EDIT_VALUE),
            EM_SETSEL,
            0,
            -1
        );

        fRetVal = SetWindowText(hDlg, szCaption);

    } // __try
    __finally {
        //
        // Nothing to clean up.  __try is only there for __leave on
        // failure capability.
        //
    } // __finally

    return fRetVal ? TRUE : FALSE;
}

BOOL
EnvVarsEditHandleCommand(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles WM_COMMAND messages sent to the Edit Environment Variables
    dialog

Arguments:

    hDlg -
        Supplies window handle

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
{
    switch (LOWORD(wParam)) {

        case IDOK:
            GetDlgItemText(
                hDlg,
                IDC_ENVVAR_EDIT_NAME,
                g_szVarName,
                BUFZ
            );
            GetDlgItemText(
                hDlg,
                IDC_ENVVAR_EDIT_VALUE,
                g_szVarValue,
                BUFZ
            );
            EndDialog(hDlg, EDIT_CHANGE);
            break;

        case IDCANCEL:
            EndDialog(hDlg, EDIT_NO_CHANGE);
            break;

        default:
            return(FALSE);
            break;

    } // switch (LOWORD(wParam))

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\crashdmp.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    crashdmp.c

Abstract:

    Implements the "Recovery" group on the Startup/Recovery
    dialog of the System Control Panel Applet

Notes:

    The virtual memory settings and the crash dump (core dump) settings
    are tightly-coupled.  Therefore, crashdmp.c and startup.h have some
    heavy dependencies on virtual.c and virtual.h (and vice versa).

Author:

    Byron Dazey 06-Jun-1992

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/

#include "sysdm.h"
#include <windowsx.h>

#define KBYTE (1024UI64)
#define MBYTE (1024UI64 * KBYTE)
#define GBYTE (1024UI64 * MBYTE)

//
// CrashDumpEnabled is not a boolean value anymore. It can take on one of the
// following types.
//

#define DUMP_TYPE_NONE              (0)
#define DUMP_TYPE_MINI              (1)
#define DUMP_TYPE_SUMMARY           (2)
#define DUMP_TYPE_FULL              (3)
#define DUMP_TYPE_MAX               (4)

#define REG_LOG_EVENT_VALUE_NAME    TEXT ("LogEvent")
#define REG_SEND_ALERT_VALUE_NAME   TEXT ("SendAlert")
#define REG_OVERWRITE_VALUE_NAME    TEXT ("Overwrite")
#define REG_AUTOREBOOT_VALUE_NAME   TEXT ("AutoReboot")
#define REG_DUMPFILE_VALUE_NAME     TEXT ("DumpFile")
#define REG_MINIDUMP_DIR_VALUE_NAME TEXT ("MinidumpDir")
#define REG_DUMP_TYPE_VALUE_NAME    TEXT ("CrashDumpEnabled")

#define BIG_MEMORY_MAX_BOOT_PF_MB   (2048)
#define CRASH_CONTROL_KEY           TEXT("System\\CurrentControlSet\\Control\\CrashControl")

//
// The crashdump code is hard-coded to generate only summary dumps for
// machines with more than 2 GB of physical memory. Do not change this
// constant unless unless you change the same code in ntos\io\dumpctl.c
//

#define LARGE_MEMORY_THRESHOLD      (2 * GBYTE)

typedef struct _SYSTEM_MEMORY_CONFIGURATION {
    BOOL    BigMemory;
    ULONG   PageSize;
    ULONG64 PhysicalMemorySize;
    ULONG64 BootPartitionPageFileSize;
    TCHAR   BootDrive;
} SYSTEM_MEMORY_CONFIGURATION;

VCREG_RET gvcCrashCtrl =  VCREG_ERROR;
HKEY ghkeyCrashCtrl = NULL;
int  gcrefCrashCtrl = 0;
BOOL gfCoreDumpChanged = FALSE;

TCHAR CrashDumpFile [MAX_PATH] = TEXT("%SystemRoot%\\MEMORY.DMP");
TCHAR MiniDumpDirectory [MAX_PATH] = TEXT("%SystemRoot%\\Minidump");
TCHAR DumpFileText [100];
TCHAR MiniDumpDirText [100];

SYSTEM_MEMORY_CONFIGURATION SystemMemoryConfiguration;

//
// Private function prototypes
//

DWORD
GetDumpSelection(
    HWND hDlg
    );

NTSTATUS
GetMemoryConfiguration(
    OUT SYSTEM_MEMORY_CONFIGURATION * MemoryConfig
    );

VOID
DisableCoreDumpControls(
    HWND hDlg
    );

static
BOOL
CoreDumpInit(
    IN HWND hDlg
    );

static
BOOL
CoreDumpUpdateRegistry(
    IN HWND hDlg,
    IN HKEY hKey
    );

int
CoreDumpHandleOk(
    IN BOOL fInitialized,
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
    );


VOID
SwapDumpSelection(
    HWND hDlg
    );
//
// Implementation
//

VCREG_RET
CoreDumpOpenKey(
    )
{
    if (gvcCrashCtrl == VCREG_ERROR) {
        gvcCrashCtrl = OpenRegKey( CRASH_CONTROL_KEY, &ghkeyCrashCtrl );
    }

    if (gvcCrashCtrl != VCREG_ERROR) {
        gcrefCrashCtrl++;
    }

    return gvcCrashCtrl;
}

void
CoreDumpCloseKey(
    )
{
    if (gcrefCrashCtrl > 0) {
        gcrefCrashCtrl--;
        if (gcrefCrashCtrl == 0) {
            CloseRegKey( ghkeyCrashCtrl );
            gvcCrashCtrl = VCREG_ERROR;
        }
    }
}




BOOL
StartAlerterService(
    IN SC_HANDLE hAlerter
    )
{
    BOOL fResult = FALSE;

    fResult = ChangeServiceConfig(
        hAlerter,
        SERVICE_NO_CHANGE,
        SERVICE_AUTO_START,
        SERVICE_NO_CHANGE,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL,
        NULL
    );

    fResult = StartService(hAlerter, 0, NULL);

    return(fResult);

}

BOOL
IsAlerterSvcStarted(
    HWND hDlg
    )
{
    SC_HANDLE schSCManager, schService = NULL;
    LPQUERY_SERVICE_CONFIG lpqscBuf;
    DWORD dwBytesNeeded;
    BOOL fRunning = FALSE;
    SERVICE_STATUS ssSrvcStat;


    /*
     * Open the Service Controller
     */
    schSCManager = OpenSCManager(
         NULL,                   /* local machine           */
         NULL,                   /* ServicesActive database */
         SC_MANAGER_ALL_ACCESS); /* full access rights      */

    if (schSCManager == NULL) {
        goto iassExit;
    }


    /*
     * Try to open the Alerter Service
     */


    /* Open a handle to the service. */

    schService = OpenService(
         schSCManager,           /* SCManager database  */
         TEXT("Alerter"),        /* name of service     */
         SERVICE_QUERY_STATUS | SERVICE_QUERY_CONFIG | SERVICE_CHANGE_CONFIG | SERVICE_START
    );

    if (schService == NULL) {
        goto iassExit;
    }

    /*
     * Query the Alerter service to see if it has been started
     */

    if (!QueryServiceStatus(schService, &ssSrvcStat )) {
        goto iassExit;
    }


    if (ssSrvcStat.dwCurrentState != SERVICE_RUNNING) {
        fRunning = StartAlerterService(schService);
    } else {

        fRunning = TRUE;
    }


iassExit:
    if (!fRunning) {
        MsgBoxParam(hDlg, IDS_SYSDM_NOALERTER, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION );
    }

    if (schService != NULL) {
        CloseServiceHandle(schService);
    }

    if (schSCManager != NULL) {
        CloseServiceHandle(schSCManager);
    }

    return fRunning;
}


BOOL
VerifyDumpPath(
    IN HWND hDlg
    )
{
    
    TCHAR szPath[MAX_PATH];
    TCHAR szExpPath[MAX_PATH];
    LPTSTR psz;
    TCHAR ch;
    UINT uType;

    if( GetDlgItemText(hDlg, IDC_STARTUP_CDMP_FILENAME, szPath,
            ARRAYSIZE(szPath)) == 0) {

        MsgBoxParam(hDlg, IDS_SYSDM_DEBUGGING_FILENAME, IDS_SYSDM_TITLE, MB_ICONSTOP | MB_OK);
        return FALSE;
    }

    /*
     * Expand any environment vars, and then check to make sure it
     * is a fully quallified path
     */
     
    // if it has a '%' in it, then try to expand it
    
    if (ExpandEnvironmentStrings(szPath, szExpPath, ARRAYSIZE(szExpPath)) >= ARRAYSIZE(szExpPath)) {
        MsgBoxParam(hDlg, IDS_SYSDM_DEBUGGING_PATHLONG, IDS_SYSDM_TITLE, MB_ICONSTOP | MB_OK,
                (DWORD)MAX_PATH);
        return FALSE;
    }

    // now cannonicalize it

    GetFullPathName( szExpPath, ARRAYSIZE(szPath), szPath, &psz );

    // check to see that it already was cannonicalized

    if (lstrcmp( szPath, szExpPath ) != 0) {
        MsgBoxParam(hDlg, IDS_SYSDM_DEBUGGING_UNQUALIFIED, IDS_SYSDM_TITLE, MB_ICONSTOP | MB_OK );
        return FALSE;
    }

    /*
     * check the drive (don't allow remote)
     */

    ch = szPath[3];
    szPath[3] = TEXT('\0');
    if (IsPathSep(szPath[0]) || ((uType = GetDriveType(szPath)) !=
            DRIVE_FIXED && uType != DRIVE_REMOVABLE)) {
        MsgBoxParam(hDlg, IDS_SYSDM_DEBUGGING_DRIVE, IDS_SYSDM_TITLE, MB_ICONSTOP | MB_OK );
        return FALSE;
    }
    szPath[3] = ch;

    /*
     * if path is non-exstant, tell user and let him decide what to do
     */

    if (GetFileAttributes(szPath) == 0xFFFFFFFFL && GetLastError() !=
        ERROR_FILE_NOT_FOUND && MsgBoxParam(hDlg, IDS_SYSDM_DEBUGGING_PATH, IDS_SYSDM_TITLE,
            MB_ICONQUESTION | MB_YESNO ) == IDYES) {
        return FALSE;
    }

    return TRUE;
}

    
    

BOOL
CoreDumpValidFile(
    HWND hDlg
    )
{
    switch (GetDumpSelection (hDlg)) {

        case DUMP_TYPE_NONE:
            return TRUE;

        case DUMP_TYPE_MINI:
            return VerifyDumpPath (hDlg);
            

        case DUMP_TYPE_SUMMARY:
        case DUMP_TYPE_FULL:
            return VerifyDumpPath (hDlg);
            
        default:
            ASSERT (FALSE);
            return TRUE;
    }

    return FALSE;
}


int
APIENTRY
CoreDumpDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static BOOL fInitialized = FALSE;

    switch (message)
    {
    case WM_INITDIALOG:
        g_fStartupInitializing = TRUE;
        fInitialized = CoreDumpInit(hDlg);
        g_fStartupInitializing = FALSE;
        return RET_CONTINUE;
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {
            case IDOK:
                return(CoreDumpHandleOk(fInitialized, hDlg, wParam, lParam));
                break;

            case IDCANCEL:
                if (fInitialized) {
                    VirtualCloseKey();
                    CoreDumpCloseKey();
                }
                // Let the Startup/Recovery dlg proc also handle IDOK
                return(RET_NO_CHANGE);
                break;

            case IDC_STARTUP_CDMP_TYPE: {
                SwapDumpSelection (hDlg);
            }
            // Fall through

            case IDC_STARTUP_CDMP_FILENAME:
            case IDC_STARTUP_CDMP_LOG:
            case IDC_STARTUP_CDMP_SEND:
            case IDC_STARTUP_CDMP_OVERWRITE:
            case IDC_STARTUP_CDMP_AUTOREBOOT:
                if (!g_fStartupInitializing) {
                    gfCoreDumpChanged = TRUE;
                }
                break;
            default: {
                // indicat not handled
                return RET_CONTINUE;
            }
        }
        break; // WM_COMMAND

    case WM_DESTROY:
        return RET_CONTINUE;
        break;

    default:
        return RET_CONTINUE;
    }

    return RET_BREAK;
}

int
CoreDumpHandleOk(
    IN BOOL fInitialized,
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
    )
{
    BOOL fRegChg;
    NTSTATUS Status;
    DWORD Ret;
    int iRet = RET_NO_CHANGE;
    SYSTEM_MEMORY_CONFIGURATION MemoryConfig = {0};

    if (fInitialized && gfCoreDumpChanged)
    {
        // Validate crashdump file name.
        if (!CoreDumpValidFile(hDlg))
        {
            SetFocus(GetDlgItem(hDlg, IDC_STARTUP_CDMP_FILENAME));
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            iRet = RET_ERROR;
            return iRet;
        }


        Status = GetMemoryConfiguration(&MemoryConfig);

        if (NT_SUCCESS (Status) &&
            MemoryConfig.BootPartitionPageFileSize <
            CoreDumpGetRequiredFileSize (hDlg))
        {
            // Warn that the dump file may be truncated.
            Ret = MsgBoxParam (hDlg,
                               IDS_SYSDM_DEBUGGING_MINIMUM,
                               IDS_SYSDM_TITLE,
                               MB_ICONEXCLAMATION | MB_YESNO,
                               (MemoryConfig.BootDrive ? MemoryConfig.BootDrive : TEXT('?')),
                               (DWORD) (CoreDumpGetRequiredFileSize (hDlg) / MBYTE)
                               );

            if (Ret == IDNO)
            {
                return RET_ERROR;
            }
        }

        // If the Alert button is checked, make sure the alerter service
        // is started.
        if (IsDlgButtonChecked(hDlg, IDC_STARTUP_CDMP_SEND))
        {
            IsAlerterSvcStarted(hDlg);
        }

        fRegChg = CoreDumpUpdateRegistry (hDlg, ghkeyCrashCtrl);

        // Clean up registry stuff
        CoreDumpCloseKey();
        VirtualCloseKey();

        if (fRegChg)
        {
            // Notify the kernel to reread the crashdump parameters from the registry.
            Status = NtSetSystemInformation(SystemCrashDumpStateInformation, NULL, 0);
            if (NT_SUCCESS(Status))
            {
                iRet = RET_CHANGE_NO_REBOOT;
            }
            else
            {
                iRet = RET_RECOVER_CHANGE;
            }
        }
    } else {
        iRet = RET_NO_CHANGE;
    }

    return(iRet);
}

void
CoreDumpInitErrorExit(
    HWND hDlg,
    HKEY hk
    )
{
    MsgBoxParam(hDlg, IDS_SYSDM_NOOPEN_RECOVER_GROUP, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION);
    if( hk == ghkeyMemMgt )
        VirtualCloseKey();

    DisableCoreDumpControls(hDlg);

    HourGlass(FALSE);
    return;
}


DWORD
GetDumpSelection(
    HWND hDlg
    )
{
    HWND hControl;

    hControl = GetDlgItem (hDlg, IDC_STARTUP_CDMP_TYPE);
    return ComboBox_GetCurSel ( hControl );
}

VOID
DisableCoreDumpControls(
    HWND hDlg
    )
{
    EnableWindow( GetDlgItem (hDlg, IDC_STARTUP_CDMP_GRP), FALSE);
    EnableWindow( GetDlgItem (hDlg, IDC_STARTUP_CDMP_TXT1), FALSE);
    EnableWindow( GetDlgItem (hDlg, IDC_STARTUP_CDMP_LOG ), FALSE);
    EnableWindow( GetDlgItem (hDlg, IDC_STARTUP_CDMP_SEND), FALSE);
    EnableWindow( GetDlgItem (hDlg, IDC_STARTUP_CDMP_TYPE), FALSE);
    EnableWindow( GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILENAME), FALSE);
    EnableWindow( GetDlgItem (hDlg, IDC_STARTUP_CDMP_OVERWRITE), FALSE);
    EnableWindow( GetDlgItem (hDlg, IDC_STARTUP_CDMP_AUTOREBOOT), FALSE);
}

VOID
SwapDumpSelection(
    HWND hDlg
    )
{
    //
    // If there is no dump type, disable some controls. If this is a minidump
    // disable overwrite and change "File Name:" to "Mini Dump Directory:"
    //

    switch (GetDumpSelection (hDlg)) {

        case DUMP_TYPE_NONE:
            EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_CDMP_OVERWRITE), FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILENAME), FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILE_LABEL), FALSE);
            SetWindowText (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILENAME),
                           CrashDumpFile
                           );
            Static_SetText (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILE_LABEL),
                            DumpFileText
                            );
            break;

        case DUMP_TYPE_MINI:
            EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_CDMP_OVERWRITE), FALSE);
            EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILENAME), TRUE);
            EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILE_LABEL), TRUE);
            SetWindowText (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILENAME),
                           MiniDumpDirectory
                           );
            Static_SetText (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILE_LABEL),
                            MiniDumpDirText
                            );
            break;

        default:
            EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_CDMP_OVERWRITE), TRUE);
            EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILENAME), TRUE);
            EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILE_LABEL), TRUE);
            SetWindowText (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILENAME),
                           CrashDumpFile
                           );
            Static_SetText (GetDlgItem (hDlg, IDC_STARTUP_CDMP_FILE_LABEL),
                             DumpFileText
                             );
    }
}

BOOL
GetSystemDrive(
    OUT TCHAR * Drive
    )
{
    TCHAR WindowsDir [ MAX_PATH ];

    if (!GetWindowsDirectory (WindowsDir, ARRAYSIZE (WindowsDir))) {
        return FALSE;
    }

    if (!isalpha (*WindowsDir)) {
        return FALSE;
    }

    *Drive = *WindowsDir;

    return TRUE;
}

NTSTATUS
GetMemoryConfiguration(
    OUT SYSTEM_MEMORY_CONFIGURATION * MemoryConfig
    )
{
    BOOL Succ;
    TCHAR SystemDrive;
    NTSTATUS Status;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    ULONGLONG iMaxPageFileSize;

    Status = NtQuerySystemInformation(
                        SystemBasicInformation,
                        &BasicInfo,
                        sizeof(BasicInfo),
                        NULL
                        );

    if (NT_SUCCESS (Status)) {
        Status;
    }

    MemoryConfig->PhysicalMemorySize =
            (ULONG64) BasicInfo.NumberOfPhysicalPages *
            (ULONG64) BasicInfo.PageSize;

    MemoryConfig->PageSize = BasicInfo.PageSize;

    //
    // Get the Boot-partition pagefile size.
    //

    Succ = GetSystemDrive (&SystemDrive);

    if (!Succ) {
        return FALSE;
    }

    MemoryConfig->BootDrive = (WCHAR) toupper (SystemDrive);

    SystemDrive = tolower(SystemDrive) - 'a';

    //
    // A big memory machine is one that has more memory than we can write to
    // at crashdump time.
    //

    iMaxPageFileSize = GetMaxPagefileSizeInMB(SystemDrive);
    iMaxPageFileSize *= (1024 * 1024); // MaxPageFileSize stored in megabytes
    if ((ULONGLONG)MemoryConfig->PhysicalMemorySize >= iMaxPageFileSize) { 
        MemoryConfig->BigMemory = TRUE;
    } else {
        MemoryConfig->BigMemory = FALSE;
    }

    //
    // NOTE: apf is a global exposed by virtual.c
    //

    Succ = VirtualGetPageFiles ( apf );

    if (!Succ) {
        return FALSE;
    }

    //
    // This is the file size in terms of megabytes.
    //

    MemoryConfig->BootPartitionPageFileSize = apf [ SystemDrive ].nMinFileSize;

    //
    // Convert to bytes.
    //

    MemoryConfig->BootPartitionPageFileSize *= MBYTE;

    VirtualFreePageFiles ( apf );

    return STATUS_SUCCESS;

}

BOOL
CheckInitFromRegistry(
    IN HWND hDlg,
    IN DWORD ControlId,
    IN HKEY RegKey,
    IN LPTSTR ValueName,
    IN BOOL Default
    )
{
    DWORD Data;
    BOOL DataSize;
    BOOL Value;

    DataSize = sizeof (Data);

    if (ERROR_SUCCESS != SHRegGetValue(RegKey, NULL, ValueName, SRRF_RT_REG_DWORD, NULL, (LPBYTE) &Data, &DataSize))
    {
        Value = Default;
    } 
    else 
    {
        Value = Data ? TRUE : FALSE;
    }

    return CheckDlgButton (hDlg, ControlId, Value);
}


BOOL
ComboAddStringFromResource(
    IN HWND hDlg,
    IN DWORD ControlId,
    IN HINSTANCE ModuleHandle,
    IN DWORD ResourceId,
    IN DWORD ItemData
    )
{
    DWORD Res;
    DWORD Item;
    HWND hControl;
    DWORD Result;
    WCHAR Buffer[512];

    Res = LoadString(ModuleHandle, ResourceId, Buffer, ARRAYSIZE(Buffer));
    if (Res == 0)
    {
        return FALSE;
    }

    hControl = GetDlgItem(hDlg, ControlId);
    Item = ComboBox_InsertString(hControl, -1, Buffer);
    ComboBox_SetItemData(hControl, Item, ItemData);

    return TRUE;
}


BOOL
StoreCheckboxToReg(
    IN HWND hDlg,
    IN DWORD ControlId,
    IN HKEY hKey,
    IN LPCTSTR RegValueName
    )
{
    DWORD Checked;

    Checked = IsDlgButtonChecked (hDlg, ControlId);

    RegSetValueEx(
            hKey,
            RegValueName,
            0,
            REG_DWORD,
            (LPBYTE) &Checked,
            sizeof (Checked)
            );

    return TRUE;
}


BOOL
StoreStringToReg(
    IN HWND hDlg,
    IN DWORD ControlId,
    IN HKEY hKey,
    IN LPCTSTR RegValueName
    )
{
    TCHAR Buffer [ MAX_PATH ];

    GetDlgItemText (hDlg, ControlId, Buffer, ARRAYSIZE(Buffer));

    //
    // Check the buffer for valid file-name??
    //

    RegSetValueEx (
            hKey,
            RegValueName,
            0,
            REG_EXPAND_SZ,
            (LPBYTE) Buffer,
            (wcslen (Buffer) + 1) * sizeof (*Buffer)
            );

    return TRUE;
}

static DWORD SelectionToType [] = { 0, 3, 2, 1 };

DWORD
GetDumpTypeFromRegistry(
    HKEY Key
    )
{
    DWORD DumpType;
    DWORD DataSize = sizeof (DumpType);
    if (ERROR_SUCCESS != SHRegGetValue(Key, NULL, REG_DUMP_TYPE_VALUE_NAME, SRRF_RT_REG_DWORD, 
                                       NULL, (LPBYTE) &DumpType, &DataSize) ||
        DumpType > 3) 
    {
        DumpType = DUMP_TYPE_MINI;
    } 
    else 
    {
        DumpType = SelectionToType [ DumpType ];
    }

    return DumpType;
}


BOOL CoreDumpInit(HWND hDlg)
{
    BOOL fRet;
    BOOL Succ;
    NTSTATUS Status;
    DWORD DataSize;
    DWORD DumpType;
    DWORD Type;
    VCREG_RET vcVirt;
    VCREG_RET vcCore;
    SYSTEM_MEMORY_CONFIGURATION MemoryConfig;

    HourGlass (TRUE);

    // Do no put anything before the initialization of the globals, here.
    vcVirt = VirtualOpenKey();

    if( vcVirt == VCREG_ERROR )
    {
        CoreDumpInitErrorExit(hDlg, NULL);
        return FALSE;
    }

    vcCore = CoreDumpOpenKey();
    if (vcCore == VCREG_ERROR)
    {
        CoreDumpInitErrorExit(hDlg, ghkeyMemMgt);
        return FALSE;
    }
    else if (vcCore == VCREG_READONLY || vcVirt == VCREG_READONLY)
    {
        DisableCoreDumpControls (hDlg);
    }
    else
    {
        Status = GetMemoryConfiguration (&SystemMemoryConfiguration);
        if (!NT_SUCCESS (Status))
        {
            return FALSE;
        }
    }

    Status = GetMemoryConfiguration (&MemoryConfig);
    if (!NT_SUCCESS (Status))
    {
        return FALSE;
    }

    Succ = LoadString (hInstance, IDS_CRASHDUMP_DUMP_FILE, DumpFileText, ARRAYSIZE(DumpFileText));
    Succ = LoadString (hInstance, IDS_CRASHDUMP_MINI_DIR, MiniDumpDirText, ARRAYSIZE(MiniDumpDirText));

    // Special Case: Server Product does not want ability to disable logging
    // of crashdumps.
    if (!IsOS(OS_ANYSERVER))
    {
        CheckInitFromRegistry(
                    hDlg,
                    IDC_STARTUP_CDMP_LOG,
                    ghkeyCrashCtrl,
                    REG_LOG_EVENT_VALUE_NAME,
                    TRUE
                    );
    }
    else
    {
        CheckDlgButton (hDlg, IDC_STARTUP_CDMP_LOG, TRUE);
        EnableWindow ( GetDlgItem (hDlg, IDC_STARTUP_CDMP_LOG), FALSE);
    }

    CheckInitFromRegistry(hDlg, IDC_STARTUP_CDMP_SEND, ghkeyCrashCtrl,REG_SEND_ALERT_VALUE_NAME, TRUE);
    CheckInitFromRegistry(hDlg, IDC_STARTUP_CDMP_OVERWRITE, ghkeyCrashCtrl, REG_OVERWRITE_VALUE_NAME, TRUE);
    CheckInitFromRegistry(hDlg, IDC_STARTUP_CDMP_AUTOREBOOT, ghkeyCrashCtrl, REG_AUTOREBOOT_VALUE_NAME, TRUE);
    ComboAddStringFromResource(hDlg, IDC_STARTUP_CDMP_TYPE, hInstance,                  // Global hInstance
                    IDS_CRASHDUMP_NONE, 0);

#ifdef _WIN64
    ComboAddStringFromResource(hDlg, IDC_STARTUP_CDMP_TYPE, hInstance, IDS_CRASHDUMP_MINI_WIN64, 0);
#else
    ComboAddStringFromResource(hDlg, IDC_STARTUP_CDMP_TYPE, hInstance, IDS_CRASHDUMP_MINI, 0);
#endif
    ComboAddStringFromResource(hDlg, IDC_STARTUP_CDMP_TYPE, hInstance, IDS_CRASHDUMP_SUMMARY, 0 );

    // Special case: Server Products do not allow full memory dumps.
    DumpType = GetDumpTypeFromRegistry(ghkeyCrashCtrl);
    if (MemoryConfig.PhysicalMemorySize < LARGE_MEMORY_THRESHOLD)
    {        
        ComboAddStringFromResource(hDlg, IDC_STARTUP_CDMP_TYPE, hInstance, IDS_CRASHDUMP_FULL, 0);
    }
    else
    {
        if (DumpType == DUMP_TYPE_FULL)
        {
            DumpType = DUMP_TYPE_SUMMARY;
        }
    }

    ComboBox_SetCurSel(GetDlgItem (hDlg, IDC_STARTUP_CDMP_TYPE), DumpType);

    fRet = FALSE;

    DataSize = sizeof (CrashDumpFile);
    if (ERROR_SUCCESS == SHRegGetValue(ghkeyCrashCtrl, NULL, REG_DUMPFILE_VALUE_NAME, SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND,
                                         NULL, (LPBYTE) CrashDumpFile, &DataSize))
    {
        DataSize = sizeof (MiniDumpDirectory);
        if (ERROR_SUCCESS == SHRegGetValue(ghkeyCrashCtrl, NULL, REG_MINIDUMP_DIR_VALUE_NAME, SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND,
                                             NULL, (LPBYTE) MiniDumpDirectory, &DataSize))
        {
            // Update the selection fields of the dialog.
            SwapDumpSelection (hDlg);
            fRet = TRUE;
        }
    }

    HourGlass(FALSE);

    return fRet;
}



BOOL
CoreDumpUpdateRegistry(
    HWND hDlg,
    HKEY hKey
    )
{
    DWORD Selection;

    StoreCheckboxToReg(
                hDlg,
                IDC_STARTUP_CDMP_LOG,
                hKey,
                REG_LOG_EVENT_VALUE_NAME
                );

    StoreCheckboxToReg(
                hDlg,
                IDC_STARTUP_CDMP_SEND,
                hKey,
                REG_SEND_ALERT_VALUE_NAME
                );

    StoreCheckboxToReg(
                hDlg,
                IDC_STARTUP_CDMP_OVERWRITE,
                hKey,
                REG_OVERWRITE_VALUE_NAME
                );

    StoreCheckboxToReg(
                hDlg,
                IDC_STARTUP_CDMP_AUTOREBOOT,
                hKey,
                REG_AUTOREBOOT_VALUE_NAME
                );

    Selection = GetDumpSelection (hDlg);

    if (Selection == DUMP_TYPE_MINI) {

        StoreStringToReg (
                    hDlg,
                    IDC_STARTUP_CDMP_FILENAME,
                    hKey,
                    REG_MINIDUMP_DIR_VALUE_NAME
                    );

    } else {

        StoreStringToReg(
                    hDlg,
                    IDC_STARTUP_CDMP_FILENAME,
                    hKey,
                    REG_DUMPFILE_VALUE_NAME
                    );
    }


    if (Selection > 3) {
        Selection = 3;
    }

    Selection = SelectionToType [ Selection ];
    RegSetValueEx (
            hKey,
            REG_DUMP_TYPE_VALUE_NAME,
            0,
            REG_DWORD,
            (LPBYTE) &Selection,
            sizeof (Selection)
            );

    return TRUE;
}


ULONG64
EstimateSummaryDumpSize(
    ULONG64 PhysicalMemorySize
    )
{
    ULONG64 Size;

    //
    // Very rough guesses at the size of the summary dump.
    //

    if (PhysicalMemorySize < 128 * MBYTE) {

        Size = 50 * MBYTE;

    } else if (PhysicalMemorySize < 4 * GBYTE) {

        Size = 200 * MBYTE;

    } else if (PhysicalMemorySize < 8 * GBYTE) {

        Size = 400 * MBYTE;

    } else {

        Size = 800 * MBYTE;
    }

    return Size;
}


ULONG64
CoreDumpGetRequiredFileSize(
    IN HWND hDlg OPTIONAL
    )
{
    ULONG64 Size;
    DWORD DumpType;
    NTSTATUS Status;
    SYSTEM_MEMORY_CONFIGURATION MemoryConfig;


    //
    // If we were passed a hDlg, get the selection from the dlg. Otherwise,
    // get the selection from the registry.
    //

    if (hDlg != NULL) {

        //
        // Get selection from dlg.
        //

        DumpType = GetDumpSelection ( hDlg );

    } else {

        HKEY hKey;
        DWORD Err;

        //
        // Get selection from registry.
        //

        Err = OpenRegKey (CRASH_CONTROL_KEY,
                          &hKey
                          );

        if (Err == VCREG_ERROR) {
            return DUMP_TYPE_MINI;
        }

        ASSERT ( hKey );
        DumpType = GetDumpTypeFromRegistry ( hKey );
        CloseRegKey ( hKey );
    }

    switch (DumpType) {

        case DUMP_TYPE_NONE:
            Size = 0;
            break;

        case DUMP_TYPE_MINI:
            Size = 64 * KBYTE;
            break;

        case DUMP_TYPE_SUMMARY:

            Status = GetMemoryConfiguration (&MemoryConfig);

            if (NT_SUCCESS (Status)) {
                Size = EstimateSummaryDumpSize (MemoryConfig.PhysicalMemorySize);
            } else {
                //
                // A (large) shot in the dark.
                //
                Size = 800 * MBYTE;
            }
            break;

        case DUMP_TYPE_FULL:

            Status = GetMemoryConfiguration (&MemoryConfig);

            if (NT_SUCCESS (Status)) {
                Size = MemoryConfig.PhysicalMemorySize;
            } else {
                Size = 0;
            }

            break;

        default:
            Size = 0;
            ASSERT (FALSE);
    }

    return Size;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\edtenvar.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    edtenvar.h

Abstract:

    Public declarations for the Edit Environment Variables dialog of the
    System Control Panel Applet
    
Author:

    Scott Hallock (scotthal) 11-Nov-1997

Revision History:


--*/

//
// Preprocessor definitions
//
#define SYSTEM_VAR        1
#define USER_VAR          2
#define INVALID_VAR_TYPE  0xeeee

#define EDIT_VAR          1
#define NEW_VAR           2
#define INVALID_EDIT_TYPE 0xeeee

#define EDIT_NO_CHANGE    0
#define EDIT_CHANGE       1
#define EDIT_ERROR       (-1)

#define EDIT_ENVVAR_CAPTION_LENGTH 128

//
// Global variables
//
extern UINT g_VarType;
extern UINT g_EditType;
extern TCHAR g_szVarName[BUFZ];
extern TCHAR g_szVarValue[BUFZ];

//
// Function prototypes
//
INT_PTR
APIENTRY
EnvVarsEditDlg(
    IN HWND hDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\envvar.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    envvar.h

Abstract:

    Public declarations for the Environment Variables dialog of the 
    System Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#ifndef _SYSDM_ENVVAR_H_
#define _SYSDM_ENVVAR_H_

#define MAX_USER_NAME   100

#define BUFZ              4096
#define MAX_VALUE_LEN     1024

//  Environment variables structure
typedef struct
{
    DWORD  dwType;
    LPTSTR szValueName;
    LPTSTR szValue;
    LPTSTR szExpValue;
} ENVARS, *PENVAR;

HPROPSHEETPAGE 
CreateEnvVarsPage(
    IN HINSTANCE hInst
);

INT_PTR 
APIENTRY 
EnvVarsDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);



#endif // _SYSDM_ENVVAR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\envvar.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    envvar.c

Abstract:

    Implements the Environment Variables dialog of the System 
    Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#include "sysdm.h"

#include <help.h>
// C Runtime
#include <stddef.h>
#include <stdlib.h>
#include <string.h>
#include <debug.h>

// for Hydra
#include <winsta.h>


//==========================================================================
//                             Local Definitions
//==========================================================================
#define LB_SYSVAR   1
#define LB_USERVAR  2

#define SYSTEMROOT TEXT("SystemRoot")
#define SYSTEMDRIVE TEXT("SystemDrive")

//==========================================================================
//                            Typedefs and Structs
//==========================================================================

//  Registry valuename linked-list structure
typedef struct _regval
{
    struct _regval *prvNext;
    LPTSTR szValueName;
} REGVAL;


//==========================================================================
//                             Local Functions
//==========================================================================
void EVDoCommand(HWND hDlg, HWND hwndCtl, int idCtl, int iNotify );
void EVSave(HWND hDlg);
void EVCleanUp (HWND hDlg);
PENVAR GetVar(HWND hDlg, UINT VarType, int iSelection);
int  FindVar (HWND hwndLB, LPTSTR szVar);

void
SetVar(
    IN HWND hDlg,
    IN UINT VarType,
    IN LPCTSTR szVarName,
    IN LPCTSTR szVarValue
);

void
DeleteVar(
    IN HWND hDlg,
    IN UINT VarType,
    IN LPCTSTR szVarName
);

//
// New.../Edit... subdialog functions
//
INT_PTR
APIENTRY
EnvVarsEditDlg(
    IN HWND hDlg,
    IN UINT uMsg,
    IN WPARAM wParam,
    IN LPARAM lParam
);

void
EVDoEdit(
    IN HWND hWnd,
    IN UINT VarType,
    IN UINT EditType,
    IN int  iSelection
);
 
BOOL 
ExpandSystemVar( 
    IN LPCTSTR pszSrc, 
    OUT LPTSTR pszDst, 
    IN DWORD cchDst 
);

//==========================================================================
//                      "Global" Variables for this page
//==========================================================================
BOOL bEditSystemVars = FALSE;
DWORD cxLBSysVars = 0;
BOOL bUserVars = TRUE;

//
// Help ID's
//

DWORD aEnvVarsHelpIds[] = {
    IDC_STATIC,                   NO_HELP,
    IDC_ENVVAR_SYS_USERGROUP,     (IDH_ENV + 2),
    IDC_ENVVAR_SYS_LB_USERVARS,   (IDH_ENV + 2),
    IDC_ENVVAR_SYS_SYSGROUP,      (IDH_ENV + 0),
    IDC_ENVVAR_SYS_LB_SYSVARS,    (IDH_ENV + 0),
    IDC_ENVVAR_SYS_NEWUV,         (IDH_ENV + 7),
    IDC_ENVVAR_SYS_EDITUV,        (IDH_ENV + 8),
    IDC_ENVVAR_SYS_NDELUV,        (IDH_ENV + 9),
    IDC_ENVVAR_SYS_NEWSV,         (IDH_ENV + 10),
    IDC_ENVVAR_SYS_EDITSV,        (IDH_ENV + 11),
    IDC_ENVVAR_SYS_DELSV,         (IDH_ENV + 12),
    0, 0
};

TCHAR szUserEnv[] = TEXT( "Environment" );
TCHAR szSysEnv[]  = TEXT( "System\\CurrentControlSet\\Control\\Session Manager\\Environment" );

HRESULT
_AddVarToListbox(HWND    hwndListBox,
                 DWORD   dwIndex,
                 LPTSTR  pszValueName,
                 LPTSTR  pszValue,
                 DWORD   dwType)
{
    HRESULT hr;
    ENVARS* penvar = (ENVARS *) LocalAlloc (LPTR, sizeof(ENVARS));
    if (!penvar)
    {
        hr = E_OUTOFMEMORY;
    }
    else
    {
        TCHAR szExpValue[BUFZ];
        if (!ExpandSystemVar (pszValue, szExpValue, ARRAYSIZE(szExpValue)))
        {
            hr = E_FAIL;
        }
        else
        {
            penvar->szValueName = StrDup(pszValueName);
            penvar->szValue     = StrDup(pszValue);
            penvar->szExpValue  = StrDup(szExpValue);
            penvar->dwType      = dwType;

            if (!penvar->szValueName || !penvar->szValue || !penvar->szExpValue)
            {
                hr = E_OUTOFMEMORY;
            }
            else
            {
                LV_ITEM item;
                int n;

                item.mask = LVIF_TEXT | LVIF_PARAM;
                item.iItem = (dwIndex - 1);
                item.iSubItem = 0;
                item.pszText = penvar->szValueName;
                item.lParam = (LPARAM) penvar;

                n = (int)SendMessage (hwndListBox, LVM_INSERTITEM, 0, (LPARAM) &item);

                if (n == -1)
                {
                    hr = E_FAIL;
                }
                else
                {
                    item.mask = LVIF_TEXT;
                    item.iItem = n;
                    item.iSubItem = 1;
                    item.pszText = penvar->szExpValue;

                    SendMessage (hwndListBox, LVM_SETITEMTEXT, n, (LPARAM) &item);

                    hr = S_OK;
                }
            }
        }
    }

    if (FAILED(hr))
    {
        if (penvar)
        {
            LocalFree(penvar->szValueName);
            LocalFree(penvar->szValue);
            LocalFree(penvar->szExpValue);
            LocalFree(penvar);
        }
    }

    return hr;
}

DWORD
_LoadEnvVars(HKEY hkeyEnv,
             HWND hwndListBox)
{
    TCHAR szValueName[BUFZ] = {0};
    TCHAR szValue[BUFZ] = {0};
    DWORD dwBufz = ARRAYSIZE(szValueName);
    DWORD dwValz = sizeof(szValue);
    DWORD dwIndex = 0;
    DWORD dwCount = 0;
    DWORD dwType;

    //  Read all values until an error is encountered

    while (ERROR_SUCCESS == RegEnumValue(hkeyEnv,
                                         dwIndex++, // Index'th value name/data
                                         szValueName,    // Ptr to ValueName buffer
                                         &dwBufz,   // Size of ValueName buffer
                                         NULL,      // Title index return
                                         &dwType,   // Type code of entry
                                         (LPBYTE) szValue,   // Ptr to ValueData buffer
                                         &dwValz))  // Size of ValueData buffer
    {
        if (dwValz < sizeof(szValue) &&                        // must not be truncated
            ((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ))) // and must be an SZ or EXPAND_SZ
        {
            if (SUCCEEDED(_AddVarToListbox(hwndListBox, dwIndex, szValueName, szValue, dwType)))
            {
                dwCount++;
            }
        }
        dwBufz = ARRAYSIZE(szValueName); // reset
        dwValz = sizeof(szValue);
    }

    return dwCount;        
}

BOOL 
InitEnvVarsDlg(
    IN HWND hDlg
)
/*++

Routine Description:

    Initializes the environment variables page

Arguments:

    hDlg -
        Supplies window handle

Return Value:

    TRUE if successful
    FALSE if an error occurs

--*/
{
    TCHAR szBuffer1[200];
    TCHAR szBuffer2[300];
    TCHAR szUserName[MAX_USER_NAME];
    DWORD cchUserName = ARRAYSIZE(szUserName);

    HWND hwndTemp;
    HKEY hkeyEnv;
    DWORD dwBufz, dwValz, dwIndex, dwType;
    LONG Error;
    int     n;
    LV_COLUMN col;
    RECT rect;
    int cxFirstCol;
    DWORD dwSysRegMode;
    LV_ITEM item;


    HourGlass (TRUE);


    //
    // Create the first column
    //

    LoadString (hInstance, IDS_ENVVAR_VARIABLE_HEADING, szBuffer1, ARRAYSIZE(szBuffer1));

    if (!GetClientRect (GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS), &rect)) {
        rect.right = 300;
    }

    cxFirstCol = (int)(rect.right * .3);

    col.mask = LVCF_FMT | LVCF_SUBITEM | LVCF_TEXT | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    col.cx = cxFirstCol;
    col.pszText = szBuffer1;
    col.iSubItem = 0;

    SendDlgItemMessage (hDlg, IDC_ENVVAR_SYS_LB_SYSVARS, LVM_INSERTCOLUMN,
                        0, (LPARAM) &col);

    SendDlgItemMessage (hDlg, IDC_ENVVAR_SYS_LB_USERVARS, LVM_INSERTCOLUMN,
                        0, (LPARAM) &col);


    //
    // Create the second column
    //

    LoadString (hInstance, IDS_ENVVAR_VALUE_HEADING, szBuffer1, ARRAYSIZE(szBuffer1));

    col.cx = rect.right - cxFirstCol - GetSystemMetrics(SM_CYHSCROLL);
    col.iSubItem = 1;

    SendDlgItemMessage (hDlg, IDC_ENVVAR_SYS_LB_SYSVARS, LVM_INSERTCOLUMN,
                        1, (LPARAM) &col);

    SendDlgItemMessage (hDlg, IDC_ENVVAR_SYS_LB_USERVARS, LVM_INSERTCOLUMN,
                        1, (LPARAM) &col);


    ////////////////////////////////////////////////////////////////////
    // Display System Variables from registry in listbox
    ////////////////////////////////////////////////////////////////////


    cxLBSysVars = 0;
    hkeyEnv = NULL;

    // If user is an admin, then try to open the System Environment variables area with R/W, allow to edit
    if (IsUserAnAdmin())
    {
        dwSysRegMode = KEY_READ | KEY_WRITE;
        bEditSystemVars = TRUE;
    }
    else // If not ad admin, open with Read-Only, disallow edit of System Env variables area
    {
        dwSysRegMode = KEY_READ;
        bEditSystemVars = FALSE;
    }

    if (ERROR_SUCCESS == RegOpenKeyEx (HKEY_LOCAL_MACHINE, szSysEnv, 0, dwSysRegMode, &hkeyEnv)) 
    {
        _LoadEnvVars(hkeyEnv, GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS));
        RegCloseKey (hkeyEnv);
    }


    ////////////////////////////////////////////////////////////////////
    //  Display USER variables from registry in listbox
    ////////////////////////////////////////////////////////////////////


    //
    // Set the "User Environments for <username>" string
    //

    LoadString(hInstance, IDS_USERENVVARS, szBuffer1, ARRAYSIZE(szBuffer1));
    if (GetUserName(szUserName, &cchUserName) &&
        SUCCEEDED(StringCchPrintf(szBuffer2, ARRAYSIZE(szBuffer2), szBuffer1, szUserName)))
    {
        SetDlgItemText (hDlg, IDC_ENVVAR_SYS_USERGROUP, szBuffer2);
    }

    Error = RegCreateKeyEx(HKEY_CURRENT_USER, szUserEnv, 0, NULL, 0, KEY_READ, NULL, &hkeyEnv, NULL);

    if (Error == ERROR_SUCCESS)
    {
        _LoadEnvVars(hkeyEnv, GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS));

        RegCloseKey (hkeyEnv);
    }
    else
    {
        //  Report opening USER Environment key
        if (MsgBoxParam (hDlg, IsUserAnAdmin() ? IDS_SYSDM_NOOPEN_USER_UNK : IDS_SYSDM_NOOPEN_USER_NOTADMIN, 
                          IDS_SYSDM_TITLE, MB_OKCANCEL | MB_ICONEXCLAMATION) == IDCANCEL)
        {
            HourGlass (FALSE);
            return FALSE;
        }
    }

    //
    // Select the first items in the listviews
    // It is important to set the User listview first, and
    // then the system.  When the system listview is set,
    // we will receive a LVN_ITEMCHANGED notification and
    // clear the focus in the User listview.  But when someone
    // tabs to the control the arrow keys will work correctly.
    //

    item.mask = LVIF_STATE;
    item.iItem = 0;
    item.iSubItem = 0;
    item.state = LVIS_SELECTED | LVIS_FOCUSED;
    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

    SendDlgItemMessage (hDlg, IDC_ENVVAR_SYS_LB_USERVARS,
                        LVM_SETITEMSTATE, 0, (LPARAM) &item);

    SendDlgItemMessage (hDlg, IDC_ENVVAR_SYS_LB_SYSVARS,
                        LVM_SETITEMSTATE, 0, (LPARAM) &item);



    // Set extended LV style for whole line selection
    SendDlgItemMessage(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);
    SendDlgItemMessage(hDlg, IDC_ENVVAR_SYS_LB_USERVARS, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

    HourGlass (FALSE);

    //
    // Disable System Var Editing buttons if
    // user is not an administrator
    //
    EnableWindow(
        GetDlgItem(hDlg, IDC_ENVVAR_SYS_NEWSV),
        bEditSystemVars
    );
    EnableWindow(
        GetDlgItem(hDlg, IDC_ENVVAR_SYS_EDITSV),
        bEditSystemVars
    );
    EnableWindow(
        GetDlgItem(hDlg, IDC_ENVVAR_SYS_DELSV),
        bEditSystemVars
    );

    return TRUE;
}


INT_PTR
APIENTRY 
EnvVarsDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles messages sent to the Environment Variables dialog box

Arguments:

    hDlg -
        Supplies window handle

    uMsg -
        Supplies message being sent

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
{
    INT i = 0;
    HWND hWndTemp = NULL;

    switch (uMsg)
    {
    case WM_INITDIALOG:

        if (!InitEnvVarsDlg(hDlg)) {
            EndDialog (hDlg, 0);
        }
        break;


    case WM_NOTIFY:

        switch (((NMHDR FAR*)lParam)->code)
        {
        case LVN_KEYDOWN:
            switch (((NMHDR FAR*)lParam)->idFrom) {
                case IDC_ENVVAR_SYS_LB_USERVARS:
                    i = IDC_ENVVAR_SYS_NDELUV;
                    break;
                case IDC_ENVVAR_SYS_LB_SYSVARS:
                    i = IDC_ENVVAR_SYS_DELSV;
                    break;
                default:
                    return(FALSE);
                    break;
            } // switch

            hWndTemp = GetDlgItem(hDlg, i);

            if ((VK_DELETE == ((LV_KEYDOWN FAR *) lParam)->wVKey)) {
                if (IsWindowEnabled(hWndTemp)) {
                    SendMessage(
                        hDlg,
                        WM_COMMAND,
                        MAKEWPARAM(i, BN_CLICKED),
                        (LPARAM) hWndTemp
                    );
                } // if (IsWindowEnabled...
                else {
                    MessageBeep(MB_ICONASTERISK);
                } // else
            } // if (VK_DELETE...
            break;

            
        case NM_DBLCLK:
            switch (((NMHDR FAR*)lParam)->idFrom) {
                case IDC_ENVVAR_SYS_LB_USERVARS:
                    i = IDC_ENVVAR_SYS_EDITUV;
                    break;
                case IDC_ENVVAR_SYS_LB_SYSVARS:
                    i = IDC_ENVVAR_SYS_EDITSV;
                    break;
                default:
                    return(FALSE);
                    break;
            } // switch

            hWndTemp = GetDlgItem(hDlg, i);

            if (IsWindowEnabled(hWndTemp)) {
                SendMessage(
                    hDlg,
                    WM_COMMAND,
                    MAKEWPARAM(i, BN_CLICKED),
                    (LPARAM) hWndTemp
                );
            } // if (IsWindowEnabled...
            else {
                MessageBeep(MB_ICONASTERISK);
            } // else
            break;

        default:
            return FALSE;
        }
        break;


    case WM_COMMAND:
        EVDoCommand(hDlg, (HWND)lParam, LOWORD(wParam), HIWORD(wParam));
        break;

    case WM_DESTROY:
        EVCleanUp (hDlg);
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP, (DWORD_PTR) (LPSTR) aEnvVarsHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) aEnvVarsHelpIds);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

void 
EVDoCommand(
    IN HWND hDlg, 
    IN HWND hwndCtl, 
    IN int idCtl, 
    IN int iNotify 
)
/*++

Routine Description:

    Handles WM_COMMAND messages sent to Environment Variables dialog box

Arguments:

    hDlg -
        Supplies window handle

    hwndCtl -
        Supplies window handle of control which sent the WM_COMMAND

    idCtl -
        Supplies ID of control which sent the WM_COMMAND

    iNotify -
        Supplies notification code

Return Value:

    None

--*/
{
    TCHAR   szTemp[MAX_PATH];
    int     i;
    HWND    hwndTemp;
    PENVAR  penvar;

    switch (idCtl) {
        case IDOK:
            EVSave(hDlg);
            EndDialog(hDlg, 0);
            break;

        case IDCANCEL:
            EndDialog(hDlg, 0);
            break;

        case IDC_ENVVAR_SYS_EDITSV:
            EVDoEdit(
                hDlg, 
                SYSTEM_VAR,
                EDIT_VAR,
                GetSelectedItem(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS))
            );
            break;

        case IDC_ENVVAR_SYS_EDITUV:
            EVDoEdit(
                hDlg, 
                USER_VAR,
                EDIT_VAR,
                GetSelectedItem(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS))
            );
            break;

        case IDC_ENVVAR_SYS_NEWSV:
            EVDoEdit(hDlg, SYSTEM_VAR, NEW_VAR, -1);
            break;

        case IDC_ENVVAR_SYS_NEWUV:
            EVDoEdit(hDlg, USER_VAR, NEW_VAR, -1); 
            break;

        case IDC_ENVVAR_SYS_DELSV:
            i = GetSelectedItem(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS));
            if (-1 != i)
            {
                penvar = GetVar(hDlg, SYSTEM_VAR, i);
                if (penvar)
                {
                    DeleteVar(hDlg, SYSTEM_VAR, penvar->szValueName);
                }
            } // if
            break;

        case IDC_ENVVAR_SYS_NDELUV:
            i = GetSelectedItem(GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS));
            if (-1 != i)
            {
                penvar = GetVar(hDlg, USER_VAR, i);
                if (penvar)
                {
                    DeleteVar(hDlg, USER_VAR, penvar->szValueName);
                }
            } // if
            break;

        default:
            break;
    } // switch

    return;

}

void
DeleteVar(
    IN HWND hDlg,
    IN UINT VarType,
    IN LPCTSTR szVarName
)
/*++

Routine Description:

    Deletes an environment variable of a given name and type

Arguments:

    hDlg -
        Supplies window handle

    VarType -
        Supplies variable type (user or system)

    szVarName -
        Supplies variable name

Return Value:

    None, although it really should have one someday.

--*/
{
    TCHAR   szTemp2[MAX_PATH];
    int     i, n;
    TCHAR  *bBuffer;
    TCHAR  *pszTemp;
    LPTSTR  pszString;
    HWND    hwndTemp;
    ENVARS *penvar;
    LV_ITEM item;

    // Delete listbox entry that matches value in szVarName
    //  If found, delete entry else ignore
    if (szVarName[0] &&
        SUCCEEDED(StringCchCopy(szTemp2, ARRAYSIZE(szTemp2), szVarName)))
    {
        //  Determine which Listbox to use (SYSTEM or USER vars)
        switch (VarType) {
            case SYSTEM_VAR:
                i = IDC_ENVVAR_SYS_LB_SYSVARS;
                break;

            case USER_VAR:
            default:
                i = IDC_ENVVAR_SYS_LB_USERVARS;
                break;

        } // switch (VarType)

        hwndTemp = GetDlgItem (hDlg, i);

        n = FindVar (hwndTemp, szTemp2);

        if (n != -1)
        {
            // Free existing strings (listbox and ours)

            item.mask = LVIF_PARAM;
            item.iItem = n;
            item.iSubItem = 0;


            if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
                penvar = (ENVARS *) item.lParam;

            } else {
                penvar = NULL;
            }


            if (penvar) {
                LocalFree (penvar->szValueName);
                LocalFree (penvar->szValue);
                LocalFree (penvar->szExpValue);
                LocalFree ((LPVOID) penvar);
            }

            SendMessage (hwndTemp, LVM_DELETEITEM, n, 0L);
            PropSheet_Changed(GetParent(hDlg), hDlg);

            //  Fix selection state in listview
            if (n > 0) {
                n--;
            }

            item.mask = LVIF_STATE;
            item.iItem = n;
            item.iSubItem = 0;
            item.state = LVIS_SELECTED | LVIS_FOCUSED;
            item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

            SendDlgItemMessage (hDlg, i,
                                LVM_SETITEMSTATE, n, (LPARAM) &item);

        }
    }
}

void
SetVar(
    IN HWND hDlg,
    IN UINT VarType,
    IN LPCTSTR szVarName,
    IN LPCTSTR szVarValue
)
/*++

Routine Description:

    Given an environment variable's type (system or user), name, and value,
    creates a ENVVARS structure for that environment variable and inserts
    it into the proper list view control, deleteing any existing variable
    of the same name.

Arguments:

    hDlg -
        Supplies window handle

    VarType -
        Supplies the type of the environment variable (system or user)

    szVarName -
        Supplies the name of the environment variable

    szVarValue -
        Supplies the value of the environment variable

Return Value:

    None, although it really should have one someday.

--*/
{
    TCHAR   szTemp2[BUFZ];
    int     i, n;
    TCHAR  *bBuffer;
    TCHAR  *pszTemp;
    LPTSTR  pszString;
    HWND    hwndTemp;
    int     idTemp;
    ENVARS *penvar;
    LV_ITEM item;

    if (SUCCEEDED(StringCchCopy(szTemp2, ARRAYSIZE(szTemp2), szVarName)))
    {

        //  Strip trailing whitespace from end of Env Variable
        i = lstrlen(szTemp2) - 1;
        while (i >= 0)
        {
            if (iswspace(szTemp2[i]))
                szTemp2[i--] = TEXT('\0');
            else
                break;
        }

        // Make sure variable name does not contain the "=" sign.
        pszTemp = StrChr (szTemp2, TEXT('='));
        if (pszTemp)
            *pszTemp = TEXT('\0');

        if (szTemp2[0] == TEXT('\0'))
            return;

        bBuffer = (TCHAR *) LocalAlloc (LPTR, BUFZ * sizeof(TCHAR));
        if (bBuffer)
        {
            pszString = (LPTSTR) LocalAlloc (LPTR, BUFZ * sizeof(TCHAR));
            if (pszString)
            {
                if (SUCCEEDED(StringCchCopy(bBuffer, BUFZ, szVarValue)))
                {
                    //  Determine which Listbox to use (SYSTEM or USER vars)
                    switch (VarType)
                    {
                        case SYSTEM_VAR:
                            idTemp = IDC_ENVVAR_SYS_LB_SYSVARS;
                            break;

                        case USER_VAR:
                        default:
                            idTemp = IDC_ENVVAR_SYS_LB_USERVARS;
                            break;

                    } // switch (VarType)
                    hwndTemp = GetDlgItem(hDlg, idTemp);

                    n = FindVar(hwndTemp, szTemp2);
                    if (n != -1)
                    {
                        // Free existing strings (listview and ours)

                        item.mask = LVIF_PARAM;
                        item.iItem = n;
                        item.iSubItem = 0;

                        if (SendMessage(hwndTemp, LVM_GETITEM, 0, (LPARAM) &item))
                        {
                            penvar = (ENVARS *) item.lParam;
                        }
                        else
                        {
                            penvar = NULL;
                        }

                        if (penvar)
                        {
                            LocalFree(penvar->szValueName);
                            LocalFree(penvar->szValue);
                            LocalFree(penvar->szExpValue);
                        }

                        SendMessage(hwndTemp, LVM_DELETEITEM, n, 0L);
                    }
                    else
                    {
                        //  Get some storage for new Env Var
                        penvar = (ENVARS *) LocalAlloc(LPTR, sizeof(ENVARS));
                    }

                    //  If there are two '%' chars in string, then this is a
                    //  REG_EXPAND_SZ style environment string
                    pszTemp = StrChr (bBuffer, TEXT('%'));
                    if (penvar)
                    {
                        if (pszTemp && StrChr (pszTemp, TEXT('%')))
                            penvar->dwType = REG_EXPAND_SZ;
                        else
                            penvar->dwType = REG_SZ;
                    }

                    switch (VarType)
                    {
                    case SYSTEM_VAR:
                        ExpandSystemVar(bBuffer, pszString, BUFZ);
                        break;

                    case USER_VAR:
                        ExpandEnvironmentStrings (bBuffer, pszString, BUFZ);
                        break;

                    default:
                        break;

                    } // switch

                    n = -1;
                    if (penvar)
                    {
                        penvar->szValueName = StrDup (szTemp2);
                        if (penvar->szValueName)
                        {
                            penvar->szValue     = StrDup (bBuffer);
                            if (penvar->szValue)
                            {
                                penvar->szExpValue  = StrDup (pszString);
                                if (penvar->szExpValue)
                                {
                                    item.mask = LVIF_TEXT | LVIF_PARAM;
                                    item.iItem = ListView_GetItemCount(hwndTemp);
                                    item.iSubItem = 0;
                                    item.pszText = penvar->szValueName;
                                    item.lParam = (LPARAM) penvar;

                                    n = (int)SendMessage (hwndTemp, LVM_INSERTITEM, 0, (LPARAM) &item);
                                }
                            }
                        }

                        if (n == -1) // on failure, free memory
                        {
                            LocalFree(penvar->szExpValue);
                            LocalFree(penvar->szValueName);
                            LocalFree(penvar->szValue);
                        }
                        else // success!
                        {
                            item.mask = LVIF_TEXT;
                            item.iItem = n;
                            item.iSubItem = 1;
                            item.pszText = penvar->szExpValue;

                            SendMessage (hwndTemp, LVM_SETITEMTEXT, n, (LPARAM) &item);

                            item.mask = LVIF_STATE;
                            item.iItem = n;
                            item.iSubItem = 0;
                            item.state = LVIS_SELECTED | LVIS_FOCUSED;
                            item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

                            SendDlgItemMessage (hDlg, idTemp, LVM_SETITEMSTATE, n, (LPARAM) &item);
                        }
                    }
                }
                LocalFree(pszString);
            }
            LocalFree(bBuffer);
        }
    }
}

void
EVDoEdit(
    IN HWND hWnd,
    IN UINT VarType,
    IN UINT EditType,
    IN int iSelection
)
/*++

Routine Description:

    Sets up for, executes, and cleans up after an Environment Variable
    New... or Edit... dialog.  Called when user presses a New... or Edit...
    button.

Arguments:

    hWnd -
        Supplies window handle

    VarType -
        Supplies the type of the variable:  User (USER_VAR) or 
        System (SYSTEM_VAR)

    EditType -
        Supplies the type of the edit:  create New (NEW_VAR) or 
        Edit existing (EDIT_VAR)

    iSelection -
        Supplies the currently selected variable of type VarType.  This
        value is ignored if EditType is NEW_VAR.

Return Value:

    None.  May alter the contents of a list view control as a side effect.

--*/
{
    LRESULT Result = 0;
    BOOL fVarChanged = FALSE;
    HWND hWndLB = NULL;
    ENVARS *penvar = NULL;
    LV_ITEM item;

    ASSERT((-1 != iSelection) || (NEW_VAR == EditType));

    g_VarType = VarType;
    g_EditType = EditType;

    penvar = GetVar(hWnd, VarType, iSelection);

    switch (EditType) {
        case NEW_VAR:
            ZeroMemory((LPVOID) g_szVarName, sizeof(g_szVarName));
            ZeroMemory((LPVOID) g_szVarValue, sizeof(g_szVarValue));
            break;

        case EDIT_VAR:
            if (!penvar ||
                FAILED(StringCchCopy(g_szVarName, ARRAYSIZE(g_szVarName), penvar->szValueName)) ||
                FAILED(StringCchCopy(g_szVarValue, ARRAYSIZE(g_szVarValue), penvar->szValue)))
            {
                MessageBeep(MB_ICONASTERISK);
                return;
            }
            break;

        case INVALID_EDIT_TYPE:
        default:
            return;
    } // switch
    
    Result = DialogBox(
        hInstance,
        (LPTSTR) MAKEINTRESOURCE(IDD_ENVVAREDIT),
        hWnd,
        EnvVarsEditDlg
    );

    //
    // Only update the list view control if the user
    // actually changed or created a variable
    //
    switch (Result) {
        case EDIT_CHANGE:
            if (EDIT_VAR == EditType) {
                fVarChanged = 
                    lstrcmp(penvar->szValueName, g_szVarName) ||
                    lstrcmp(penvar->szValue, g_szVarValue);
            } // if (EDIT_VAR...
            else if (NEW_VAR == EditType) {
                fVarChanged =
                    lstrlen(g_szVarName) && lstrlen(g_szVarValue);
            } // else if (NEW_VAR...
            else {
                fVarChanged = FALSE;
            } // else

            if (fVarChanged) {
                if (EDIT_VAR == EditType) {
                    DeleteVar(hWnd, VarType, penvar->szValueName);
                } // if (EDIT_VAR...
                SetVar(hWnd, VarType, g_szVarName, g_szVarValue);
            } // if (fVarChanged)
            break;

        default:
        break;
    } // switch (Result)

    g_VarType = INVALID_VAR_TYPE;
    g_EditType = INVALID_EDIT_TYPE;
    return; 
}

PENVAR
GetVar(
    IN HWND hDlg, 
    IN UINT VarType, 
    IN int iSelection
)
/*++

Routine Description:

    Returns a given System or User environment variable, as stored
    in the System or User environment variable listview control.

    Changing the structure returned by this routine is not
    recommended, because it will alter the values actually stored
    in the listview control.

Arguments:

    hDlg -
        Supplies window handle

    VarType -
        Supplies variable type--System or User

    iSelection -
        Supplies the selection index into the listview control of
        the desired environment variable

Return Value:

    Pointer to a valid ENVARS structure if successful.

    NULL if unsuccessful.

--*/
{
    HWND hWndLB = NULL;
    PENVAR penvar = NULL;
    LV_ITEM item;

    switch (VarType)
    {
        case SYSTEM_VAR:
            hWndLB = GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_SYSVARS);
            break;

        case USER_VAR:
            hWndLB = GetDlgItem(hDlg, IDC_ENVVAR_SYS_LB_USERVARS);
            break;

        case INVALID_VAR_TYPE:
        default:
            return NULL;
    } // switch (VarType)

    item.mask = LVIF_PARAM;
    item.iItem = iSelection;
    item.iSubItem = 0;
    if (iSelection >= 0 && SendMessage (hWndLB, LVM_GETITEM, 0, (LPARAM) &item))
    {
        penvar = (ENVARS *) item.lParam;
    }
    else
    {
        penvar = NULL;
    }
    
    return penvar;
}

int 
FindVar(
    IN HWND hwndLV, 
    IN LPTSTR szVar
)
/*++

Routine Description:

    Find the USER Environment variable that matches passed string
    and return its listview index or -1

Arguments:

    hwndLV -
        Supplies window handle to the list view control containing the
        environment variables

    szVar -
        Supplies the variable name in string form

Return Value:

    List view item index which matches the passed in string if the string
    is the name of an environment variable

    -1 if the passed in string is not the name of an environment variable

--*/
{
    LV_FINDINFO FindInfo;


    FindInfo.flags = LVFI_STRING;
    FindInfo.psz = szVar;

    return (int)(SendMessage (hwndLV, LVM_FINDITEM, (WPARAM) -1, (LPARAM) &FindInfo));
}

//
// Hydra's
// WinStationBroadcastSystemMessage(
//
typedef
LONG
(*PWINSTABSM_ROUTINE) (
                    HANDLE  hServer,
                    BOOL    sendToAllWinstations,   // you set this to TRUE
                    ULONG   sessionID,          // set to NULL, due to above
                    ULONG   timeOut,
                    DWORD   dwFlags,
                    DWORD   *lpdwRecipients,
                    ULONG   uiMessage,
                    WPARAM  wParam,
                    LPARAM  lParam,
                    LONG    *pResponse);

PWINSTABSM_ROUTINE               fp_WinStaBroadcastSystemMessage;

// load winsta.dll (if any) and initialize the global function pointers to use
HANDLE 
InitializeHydraInterface(
    void
    )
{
    HANDLE  hwinStaLib=NULL;

    //
    // Load the Terminal Server base library that contains the user message dispatch
    // routines if termial server is running.
    //
    if (hwinStaLib = LoadLibrary(TEXT("WINSTA.DLL"))) 
    {
        fp_WinStaBroadcastSystemMessage = (PWINSTABSM_ROUTINE)GetProcAddress(
                             hwinStaLib,"WinStationBroadcastSystemMessage");

        if (fp_WinStaBroadcastSystemMessage )
        {
            return (hwinStaLib);
        }
        else
        {
            // this must not be a NT5 running Terminal Services, which means
            // it could be NT5 WKS, or some flavor of NT4.
            // So, we just bail out, no problem.
            FreeLibrary(hwinStaLib);
            return (NULL);
        }
    }

    return NULL;
}

void
_DeleteEnvVars(IN HKEY hkey)
{
    TCHAR   szTemp[BUFZ];
    REGVAL* prvFirst;
    REGVAL* prvRegVal;
    DWORD dwBufz = ARRAYSIZE(szTemp);
    DWORD dwIndex = 0;
    DWORD dwType;
    
    prvFirst = NULL;
    
    while (!RegEnumValue(hkey,
                         dwIndex++, // Index'th value name/data
                         szTemp,    // Ptr to ValueName buffer
                         &dwBufz,   // Size of ValueName buffer
                         NULL,      // Title index return
                         &dwType,   // Type code of entry
                         NULL,      // Ptr to ValueData buffer
                         NULL))     // Size of ValueData buffer
    {
        if ((dwType == REG_SZ) || (dwType == REG_EXPAND_SZ))
        {
            REGVAL* prvRegValNew = (REGVAL *) LocalAlloc (LPTR, sizeof(REGVAL));
            if (prvRegValNew)
            {
                prvRegValNew->szValueName = StrDup(szTemp);
                if (!prvRegValNew->szValueName)
                {
                    LocalFree(prvRegValNew);
                }
                else
                {
                    if (prvFirst)
                    {
                        prvRegVal->prvNext = prvRegValNew;
                        prvRegVal = prvRegVal->prvNext;
                    }
                    else
                    {
                        prvFirst = prvRegVal = prvRegValNew;
                    }
                }
            }
        }
        dwBufz = ARRAYSIZE(szTemp);
    }

    //  Now traverse the list, deleting them all

    prvRegVal = prvFirst;

    while (prvRegVal)
    {
        RegDeleteValue (hkey, prvRegVal->szValueName);

        LocalFree (prvRegVal->szValueName);

        prvFirst  = prvRegVal;
        prvRegVal = prvRegVal->prvNext;

        LocalFree ((LPVOID) prvFirst);
    }
}



void 
EVSave(
    IN HWND hDlg
)
/*++

Routine Description:

    Saves the environment variables in the registry

Arguments:

    hDlg -
        Supplies window handle

Return Value:

    None

--*/
{
    int     selection;
    int     i, n;
    TCHAR  *bBuffer;
    TCHAR  *pszTemp;
    HWND    hwndTemp;
    ENVARS *penvar;
    HKEY    hkeyEnv;
    DWORD   dwBufz, dwIndex, dwType;
    LV_ITEM item;

    HourGlass (TRUE);

    /////////////////////////////////////////////////////////////////
    //  Set all new USER environment variables to current values
    //  but delete all old environment variables first
    /////////////////////////////////////////////////////////////////

    if (RegOpenKeyEx (HKEY_CURRENT_USER, szUserEnv, 0,
                     KEY_READ | KEY_WRITE | DELETE, &hkeyEnv)
            == ERROR_SUCCESS)
    {
        _DeleteEnvVars(hkeyEnv);

        ///////////////////////////////////////////////////////////////
        //  Set all new USER environment variables to current values
        ///////////////////////////////////////////////////////////////

        hwndTemp = GetDlgItem (hDlg, IDC_ENVVAR_SYS_LB_USERVARS);

        if ((n = (int)SendMessage (hwndTemp, LVM_GETITEMCOUNT, 0, 0L)) != LB_ERR)
        {

            item.mask = LVIF_PARAM;
            item.iSubItem = 0;

            for (i = 0; i < n; i++)
            {

                item.iItem = i;

                if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
                    penvar = (ENVARS *) item.lParam;

                } else {
                    penvar = NULL;
                }

                if (penvar) {
                    if (RegSetValueEx (hkeyEnv,
                                       penvar->szValueName,
                                       0L,
                                       penvar->dwType,
                              (LPBYTE) penvar->szValue,
                                       (lstrlen (penvar->szValue)+1) * sizeof(TCHAR)))
                    {
                        //  Report error trying to set registry values

                        if (MsgBoxParam (hDlg, IsUserAnAdmin() ? IDS_SYSDM_NONEW_ENV_UNK : IDS_SYSDM_NONEW_ENV_NOTADMIN, IDS_SYSDM_TITLE,
                            MB_OKCANCEL | MB_ICONEXCLAMATION) == IDCANCEL)
                            break;
                    }
                }
            }
        }

        RegFlushKey (hkeyEnv);
        RegCloseKey (hkeyEnv);
    }
    else
    {
        //  Report opening USER Environment key
        if (MsgBoxParam (hDlg, IsUserAnAdmin() ? IDS_SYSDM_NOOPEN_USER_UNK : IDS_SYSDM_NOOPEN_USER_NOTADMIN, IDS_SYSDM_TITLE,
                       MB_OKCANCEL | MB_ICONEXCLAMATION) == IDCANCEL)
            goto Exit;
    }

    /////////////////////////////////////////////////////////////////
    //  Set all new SYSTEM environment variables to current values
    //  but delete all old environment variables first
    /////////////////////////////////////////////////////////////////

    if (!bEditSystemVars)
        goto SkipSystemVars;

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                       szSysEnv,
                       0,
                       KEY_READ | KEY_WRITE | DELETE,
                       &hkeyEnv)
            == ERROR_SUCCESS)
    {
        _DeleteEnvVars(hkeyEnv);

        ///////////////////////////////////////////////////////////////
        //  Set all new SYSTEM environment variables to current values
        ///////////////////////////////////////////////////////////////

        hwndTemp = GetDlgItem (hDlg, IDC_ENVVAR_SYS_LB_SYSVARS);

        if ((n = (int)SendMessage (hwndTemp, LVM_GETITEMCOUNT, 0, 0L)) != LB_ERR)
        {
            item.mask = LVIF_PARAM;
            item.iSubItem = 0;

            for (i = 0; i < n; i++)
            {
                item.iItem = i;

                if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
                    penvar = (ENVARS *) item.lParam;

                } else {
                    penvar = NULL;
                }

                if (penvar) {
                    if (RegSetValueEx (hkeyEnv,
                                       penvar->szValueName,
                                       0L,
                                       penvar->dwType,
                              (LPBYTE) penvar->szValue,
                                       (lstrlen (penvar->szValue)+1) * sizeof(TCHAR)))
                    {
                        //  Report error trying to set registry values

                        if (MsgBoxParam (hDlg, IsUserAnAdmin() ? IDS_SYSDM_NONEW_ENV_UNK : IDS_SYSDM_NONEW_ENV_NOTADMIN, IDS_SYSDM_TITLE,
                            MB_OKCANCEL | MB_ICONEXCLAMATION) == IDCANCEL)
                            break;
                    }
                }
            }
        }

        RegFlushKey (hkeyEnv);
        RegCloseKey (hkeyEnv);
    }
    else
    {
        //  Report opening SYSTEM Environment key
        if (MsgBoxParam (hDlg, IsUserAnAdmin() ? IDS_SYSDM_NOOPEN_SYS_UNK : IDS_SYSDM_NOOPEN_SYS_NOTADMIN, IDS_SYSDM_TITLE,
                       MB_OKCANCEL | MB_ICONEXCLAMATION) == IDCANCEL)
            goto Exit;
    }

SkipSystemVars:


    // Send public message announcing change to Environment
    SendMessageTimeout( (HWND)-1, WM_WININICHANGE, 0L, (LPARAM)szUserEnv,
                                            SMTO_ABORTIFHUNG, 1000, NULL );

    // the folllowing block will send a message to all terminal server session
    // if and only if this is a NT5 and terminal services has been enabled.
    if ( IsUserAnAdmin() )
    {
        HANDLE  hwinStaLib;
        // if this is an NT5, then we get a valid handle to winsta.dll library
        // and the function pointer will be valid/initialized
        hwinStaLib = InitializeHydraInterface();
        if ( hwinStaLib) 
        {
            // these are not used
            DWORD   dwRecipients=0;
            LONG    dwResponse=0;

            // Broadcast the message to all hydra sessions (if any)
            fp_WinStaBroadcastSystemMessage( SERVERNAME_CURRENT, TRUE, 0, 
                                     1 /*timeout in seconds*/ , BSF_NOHANG,
                                     &dwRecipients,
                                     WM_WININICHANGE, 0L, 
                                     (LPARAM)szUserEnv,
                                     &dwResponse );

            //Close the handle to Winsta
            FreeLibrary (hwinStaLib);
        }
    }

Exit:

    HourGlass (FALSE);
}


void 
EVCleanUp(
    IN HWND hDlg
)
/*++

Routine Description:

    Frees memory allocated for environment variables

Arguments:

    hDlg -
        Supplies window handle

Return Value:

    None.

--*/
{
    int     i, n;
    HWND    hwndTemp;
    ENVARS *penvar;
    LV_ITEM item;


    //
    //  Free alloc'd strings and memory for UserEnvVars list box items
    //

    hwndTemp = GetDlgItem (hDlg, IDC_ENVVAR_SYS_LB_USERVARS);
    n = (int)SendMessage (hwndTemp, LVM_GETITEMCOUNT, 0, 0L);

    item.mask = LVIF_PARAM;
    item.iSubItem = 0;

    for (i = 0; i < n; i++) {

        item.iItem = i;

        if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
            penvar = (ENVARS *) item.lParam;
        } else {
            penvar = NULL;
        }

        if (penvar) {
            LocalFree (penvar->szValueName);
            LocalFree (penvar->szValue);
            LocalFree (penvar->szExpValue);
            LocalFree ((LPVOID) penvar);
        }
    }


    //
    //  Free alloc'd strings and memory for SysEnvVars list box items
    //

    hwndTemp = GetDlgItem (hDlg, IDC_ENVVAR_SYS_LB_SYSVARS);
    n = (int)SendMessage (hwndTemp, LVM_GETITEMCOUNT, 0, 0L);

    for (i = 0; i < n; i++) {

        item.iItem = i;

        if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
            penvar = (ENVARS *) item.lParam;
        } else {
            penvar = NULL;
        }

        if (penvar) {
            LocalFree (penvar->szValueName);
            LocalFree (penvar->szValue);
            LocalFree (penvar->szExpValue);
            LocalFree ((LPVOID) penvar);
        }
    }
}


BOOL 
ExpandSystemVar( 
    IN LPCTSTR pszSrc, 
    OUT LPTSTR pszDst, 
    IN DWORD cchDst 
) 
/*++

Routine Description:

    Private version of ExpandEnvironmentStrings() which only expands
    references to the variables "SystemRoot" and "SystemDrive".

    This behavior is intended to match the way SMSS expands system
    environment variables.

Arguments:

    pszSrc -
        Supplies the system variable value to be expanded.

    pszDst -
        Returns the expanded system variable value.

    cchDst -
        Supplies the size, in characters, of the buffer pointed to
        by pszDst

Return Value:

    TRUE if there was room in the supplied buffer for the entire
    expanded string.

    FALSE if there was insufficient space in the supplied buffer
    for the entire expanded string.

--*/
{
    TCHAR ch;
    LPTSTR p;
    TCHAR szVar[BUFZ];
    DWORD cch;

    do {

        ch = *pszSrc++;

        if (ch != TEXT('%') ) {

            // no space left, truncate string and return false
            if (--cchDst == 0) {
                *pszDst = TEXT('\0');
                return FALSE;
            }

            *pszDst++ = ch;

        } else {
            /*
             * Expand variable
             */
            // look for the next '%'
            p = szVar;
            while( *pszSrc != TEXT('\0') && *pszSrc != TEXT('%') )
                    *p++ = *pszSrc++;

            *p = TEXT('\0');

            if (*pszSrc == TEXT('\0')) {
                // end of string, first '%' must be literal
                cch = lstrlen(szVar) + 1;

                // no more space, return false
                if (cch + 1 > cchDst) {
                    *pszDst++ = TEXT('\0');
                    return FALSE;
                }

                *pszDst++ = TEXT('%');
                CopyMemory( pszDst, szVar, cch * sizeof(TCHAR));
                return TRUE;

            } else {
                // we found the ending '%' sign, expand that string

                //
                // We're expanding a SYSTEM variable, so only expand
                // references to SystemRoot and SystemDrive.
                //
                if ((!lstrcmpi(szVar, SYSTEMROOT)) || (!lstrcmpi(szVar, SYSTEMDRIVE))) {
                    cch = GetEnvironmentVariable(szVar, pszDst, cchDst);
                } /* if */
                else {
                    cch = 0;
                } /* else */

                if (cch == 0 || cch >= cchDst) {
                    //String didn't expand, copy it as a literal
                    cch = lstrlen(szVar);

                    // no space left, trunc string and return FALSE
                    if (cch + 2 + 1 > cchDst ) {
                        *pszDst = TEXT('\0');
                        return FALSE;
                    }

                    *pszDst++ = TEXT('%');

                    CopyMemory(pszDst, szVar, cch * sizeof(TCHAR));
                    pszDst += cch;

                    *pszDst++ = TEXT('%');

                    // cchDst -= two %'s and the string
                    cchDst -= (2 + cch);

                } else {
                    // string was expanded in place, bump pointer past its end
                    pszDst += cch;
                    cchDst -= cch;
                }

                // continue with next char after ending '%'
                pszSrc++;
            }
        }

    } while( ch != TEXT('\0') );

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\general.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    general.h

Abstract:

    Public declarations for the General tab of the System Control Panel
    Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#ifndef _SYSDM_GENERAL_H_
#define _SYSDM_GENERAL_H_

INT_PTR 
APIENTRY GeneralDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);

#endif // _SYSDM_GENERAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\general.cpp ===
//*************************************************************
//
//  General.cpp  -   General property sheet page
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1996-2000
//  All rights reserved
//
//*************************************************************
// NT base apis
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>

#include <sysdm.h>
#include <regstr.h>
#include <help.h>
#include <shellapi.h>
#include <shlapip.h>
#include <shlobjp.h>
#include <regapix.h>
#include <wininet.h>
#include <wbemcli.h>        // Contains the WMI APIs: IWbemLocator, etc.
#include <ccstock.h>        // Contains IID_PPV_ARG()
#include <debug.h>          // For TraceMsg()
#include <stdio.h>
#include <math.h>
#include <winbrand.h>

#define CP_ENGLISH                          1252        // This is the English code page.

#ifdef DEBUG
#undef TraceMsg 
#define TraceMsg(nTFFlags, str, n1)         DbgPrintf(TEXT(str) TEXT("\n"), n1)
#else // DEBUG
#endif // DEBUG

#define SYSCPL_ASYNC_COMPUTER_INFO (WM_APP + 1)

#define SZ_REGKEY_MYCOMP_OEMLINKS           TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\MyComputer\\OEMLinks")
#define SZ_REGKEY_MYCOMP_OEMENGLISH         TEXT("1252")
#define SZ_ATCOMPATIBLE                     TEXT("AT/AT COMPATIBLE")

#define SZ_WMI_WIN32PROCESSOR_ATTRIB_NAME           L"Name"                 // Example, "Intel Pentium III Xeon processor"
#define SZ_WMI_WIN32PROCESSOR_ATTRIB_SPEED          L"CurrentClockSpeed"   // Example, "550".
#define SZ_WMI_WIN32PROCESSOR_ATTRIB_MAXSPEED       L"MaxClockSpeed"   // Example, "550".

#define SZ_WMI_WQL_QUERY_STRING                     L"select Name,CurrentClockSpeed,MaxClockSpeed from Win32_Processor"

#define MHZ_TO_GHZ_THRESHHOLD          1000

// if cpu speed comes back slower than WMI_WIN32PROCESSOR_SPEEDSTEP_CUTOFF,
//   assume we're in power-save mode, display max speed instead.
#define WMI_WIN32PROCESSOR_SPEEDSTEP_CUTOFF         50  

#define FEATURE_IGNORE_ATCOMPAT
#define FEATURE_LINKS

#define MAX_URL_STRING                  (INTERNET_MAX_SCHEME_LENGTH \
                                        + sizeof("://") \
                                        + INTERNET_MAX_PATH_LENGTH)

#define MAX_PROCESSOR_DESCRIPTION               MAX_URL_STRING


// Globals for this page
static const WCHAR c_szEmpty[] = TEXT("");
static const WCHAR c_szCRLF[] = TEXT("\r\n");

static const WCHAR c_szAboutKey[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion");
static const WCHAR c_szAboutRegisteredOwner[] = REGSTR_VAL_REGOWNER;
static const WCHAR c_szAboutRegisteredOrganization[] = REGSTR_VAL_REGORGANIZATION;
static const WCHAR c_szAboutProductId[] = REGSTR_VAL_PRODUCTID;
static const WCHAR c_szAboutAnotherSerialNumber[] = TEXT("Plus! VersionNumber");
static const WCHAR c_szAboutAnotherProductId[] = TEXT("Plus! ProductId");

// oeminfo stuff
static const WCHAR c_szSystemDir[] = TEXT("System\\");
static const WCHAR c_szOemFile[] = TEXT("OemInfo.Ini");
static const WCHAR c_szOemImageFile[] = TEXT("OemLogo.Bmp");
static const WCHAR c_szOemGenSection[] = TEXT("General");
static const WCHAR c_szOemSupportSection[] = TEXT("Support Information");
static const WCHAR c_szOemName[] = TEXT("Manufacturer");
static const WCHAR c_szOemModel[] = TEXT("Model");
static const WCHAR c_szOemSupportLinePrefix[] = TEXT("line");
static const WCHAR c_szDefSupportLineText[] = TEXT("@");

static const WCHAR SZ_REGKEY_HARDWARE_CPU[] = TEXT("HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0");
static const WCHAR c_szMemoryManagement[] = TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management");
static const WCHAR c_szPhysicalAddressExtension[] = TEXT("PhysicalAddressExtension");
static const WCHAR c_szIndentifier[] = TEXT("Identifier");
static const WCHAR SZ_REGVALUE_PROCESSORNAMESTRING[] = TEXT("ProcessorNameString");

#define SZ_REGKEY_HARDWARE                  TEXT("HARDWARE\\DESCRIPTION\\System")

#define SZ_REGKEY_USE_WMI                   TEXT("UseWMI")


// Help ID's
int g_nStartOfOEMLinks = 0;

DWORD aGeneralHelpIds[] = {
    IDC_GEN_WINDOWS_IMAGE,         NO_HELP,
    IDC_TEXT_1,                    (IDH_GENERAL + 0),
    IDC_GEN_VERSION_0,             (IDH_GENERAL + 1),
    IDC_GEN_VERSION_1,             (IDH_GENERAL + 1),
    IDC_GEN_VERSION_2,             (IDH_GENERAL + 1),
    IDC_GEN_VERSION_3,             (IDH_GENERAL + 1),
    IDC_TEXT_3,                    (IDH_GENERAL + 3),
    IDC_GEN_REGISTERED_0,          (IDH_GENERAL + 3),
    IDC_GEN_REGISTERED_1,          (IDH_GENERAL + 3),
    IDC_GEN_REGISTERED_2,          (IDH_GENERAL + 3),
    IDC_GEN_REGISTERED_3,          (IDH_GENERAL + 3),
    IDC_GEN_OEM_IMAGE,             NO_HELP,
    IDC_TEXT_4,                    (IDH_GENERAL + 6),
    IDC_GEN_MACHINE_0,             (IDH_GENERAL + 7),
    IDC_GEN_MACHINE_1,             (IDH_GENERAL + 8),
    IDC_GEN_MACHINE_2,             (IDH_GENERAL + 9),
    IDC_GEN_MACHINE_3,             (IDH_GENERAL + 10),
    IDC_GEN_MACHINE_4,             (IDH_GENERAL + 11),
    IDC_GEN_MACHINE_5,             NO_HELP,
    IDC_GEN_MACHINE_6,             NO_HELP,
    IDC_GEN_MACHINE_7,             NO_HELP,
    IDC_GEN_MACHINE_8,             NO_HELP,
    IDC_GEN_OEM_SUPPORT,           (IDH_GENERAL + 12),
    IDC_GEN_REGISTERED_2,          (IDH_GENERAL + 14),
    IDC_GEN_REGISTERED_3,          (IDH_GENERAL + 15),
    IDC_GEN_MACHINE,               (IDH_GENERAL + 7),
    IDC_GEN_OEM_NUDGE,             NO_HELP,
    0, 0
};


//
// Macros
//

#define BytesToK(pDW)   (*(pDW) = (*(pDW) + 512) / 1024)        // round up

//
// Function proto-types
//

INT_PTR APIENTRY PhoneSupportProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
DWORD WINAPI InitGeneralDlgThread(LPVOID lpParam);

typedef struct {
    WCHAR szProcessorDesc[MAX_PROCESSOR_DESCRIPTION];
    WCHAR szProcessorClockSpeed[MAX_PROCESSOR_DESCRIPTION];
} PROCESSOR_INFO;

typedef struct {
    LONGLONG llMem;
    PROCESSOR_INFO pi;
    BOOL fShowProcName;
    BOOL fShowProcSpeed;
} INITDLGSTRUCT;

#define GETOEMFILE_OEMDATA  0
#define GETOEMFILE_OEMIMAGE 1

HRESULT _GetOemFile(LPWSTR szOemFile, UINT cchOemFile, DWORD dwFlags)
{
    HRESULT hr;
    LPCWSTR szFileName = (GETOEMFILE_OEMDATA == dwFlags) ? c_szOemFile : c_szOemImageFile;

    szOemFile[0] = 0;

    // first look in system directory
    if (!GetSystemDirectory(szOemFile, cchOemFile))
    {
        hr = E_FAIL;
    }
    else
    {
        if (!PathAppend(szOemFile, szFileName))
        {
            hr = E_FAIL;
        }
        else
        {
            if (PathFileExists(szOemFile))
            {
                hr = S_OK;
            }
            else // if it's not there, then look in %windir%\system (on 9X oems would put files here)
            {
                if (!GetWindowsDirectory(szOemFile, ARRAYSIZE(szOemFile)))
                {
                    hr = E_FAIL;
                }
                else
                {
                    if (PathAppend(szOemFile, c_szSystemDir) &&
                        PathAppend(szOemFile, szFileName) &&
                        PathFileExists(szOemFile))
                    {
                        hr = S_OK;
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }
            }
        }
    }
    return hr;
}

HRESULT _SetMachineInfoLine(HWND hDlg, int idControl, LPCWSTR pszText, BOOL fSetTabStop)
{
    HRESULT hr = S_OK;

#ifdef FEATURE_LINKS
    HWND hwndItem = GetDlgItem(hDlg, idControl);

    SetDlgItemText(hDlg, idControl, pszText);
    if (fSetTabStop)
    {
        // We also want to add the WS_TABSTOP attribute for accessibility.
        SetWindowLong(hwndItem, GWL_STYLE, (WS_TABSTOP | GetWindowLong(hwndItem, GWL_STYLE)));
    }
    else
    {
        // We want to remove the tab stop behavior and we do that by removing
        // the LWIS_ENABLED attribute
        LWITEM item = {0};

        item.mask       = (LWIF_ITEMINDEX | LWIF_STATE);
        item.stateMask  = LWIS_ENABLED;
        item.state      = 0;     // 0 if we want it disabled.
        item.iLink      = 0;

        hr = (SendMessage(hwndItem, LWM_SETITEM, 0, (LPARAM)&item) ? S_OK : E_FAIL);
    }

#else // FEATURE_LINKS
    SetDlgItemText(hDlg, idControl, pszText);
#endif // FEATURE_LINKS

    return hr;
}


//*************************************************************
//  Purpose:    Sets or clears an image in a static control.
//
//  Parameters: control  -   handle of static control
//              resource -   resource / filename of bitmap
//              fl       -   SCB_ flags:
//                SCB_FROMFILE      'resource' specifies a filename instead of a resource
//                SCB_REPLACEONLY   only put the new image up if there was an old one
//
//  Return:     (BOOL) TRUE if successful
//                     FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              5/24/95     ericflo    Ported
//*************************************************************
#define SCB_FROMFILE     (0x1)
#define SCB_REPLACEONLY  (0x2)
BOOL SetClearBitmap(HWND control, LPCWSTR resource, UINT fl)
{
    HBITMAP hbm = (HBITMAP)SendMessage(control, STM_GETIMAGE, IMAGE_BITMAP, 0);

    if(hbm)
    {
        DeleteObject(hbm);
    }
    else if(fl & SCB_REPLACEONLY)
    {
        return FALSE;
    }

    if(resource)
    {
        SendMessage(control, STM_SETIMAGE, IMAGE_BITMAP, (LPARAM)
            LoadImage(hInstance, resource, IMAGE_BITMAP, 0, 0,
            LR_LOADTRANSPARENT | LR_LOADMAP3DCOLORS |
            ((fl & SCB_FROMFILE)? LR_LOADFROMFILE : 0)));
    }

    return
        ((HBITMAP)SendMessage(control, STM_GETIMAGE, IMAGE_BITMAP, 0) != NULL);
}

BOOL IsLowColor (HWND hDlg)
{
    BOOL fLowColor = FALSE;
    HDC hdc = GetDC(hDlg);
    if (hdc)
    {
        INT iColors = GetDeviceCaps(hdc, NUMCOLORS);
        fLowColor = ((iColors != -1) && (iColors <= 256));
        ReleaseDC(hDlg, hdc);
    }
    return fLowColor;
}

HRESULT _GetLinkInfo(HKEY hkey, LPCWSTR pszLanguageKey, int nIndex, LPWSTR pszLink, SIZE_T cchNameSize)
{
    HRESULT hr;
    DWORD cbSize = (DWORD)(cchNameSize * sizeof(pszLink[0]));
    WCHAR szIndex[10];
    

    hr = StringCchPrintf(szIndex, ARRAYSIZE(szIndex), TEXT("%03d"), nIndex);
    if (SUCCEEDED(hr))
    {
        DWORD dwError = SHRegGetValue(hkey,
                                      pszLanguageKey,
                                      szIndex,
                                      SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND,
                                      NULL,
                                      (void *) pszLink, 
                                      &cbSize);
        hr = HRESULT_FROM_WIN32(dwError);
    }
    
    return hr;
}


// GSierra is worried that if we allow admins to put an arbirary
// number of OEM links that they will abuse the privalage.
// So we use this arbitrary limit.  PMs may want to change it in
// the future.
#define ARTIFICIAL_MAX_SLOTS            3

HRESULT AddOEMHyperLinks(HWND hDlg, int * pControlID)
{
    HKEY hkey;
    DWORD dwError;
    HRESULT hr;
    
    g_nStartOfOEMLinks = *pControlID;
    dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_REGKEY_MYCOMP_OEMLINKS, 0, KEY_READ, &hkey);
    hr = HRESULT_FROM_WIN32(dwError);
    
    if (SUCCEEDED(hr))
    {
        int nIndex;

        // While we have room and haven't hit the limit.
        for (nIndex = 0; ((nIndex <= ARTIFICIAL_MAX_SLOTS) &&
               (*pControlID <= LAST_GEN_MACHINES_SLOT)); nIndex++)
        {
            WCHAR szLink[2 * MAX_URL_STRING];
            WCHAR szLanguageKey[10];

            hr = StringCchPrintf(szLanguageKey, ARRAYSIZE(szLanguageKey), TEXT("%u"), GetACP());
            if (SUCCEEDED(hr))
            {
                hr = _GetLinkInfo(hkey, szLanguageKey, nIndex, szLink, ARRAYSIZE(szLink));
                if (FAILED(hr) && (CP_ENGLISH != GetACP()))
                {
                    // We failed to find it in the natural language, so try English.
                    hr = _GetLinkInfo(hkey, SZ_REGKEY_MYCOMP_OEMENGLISH, nIndex, szLink, ARRAYSIZE(szLink));
                }
            }

            if (SUCCEEDED(hr))
            {
                // TODO: Find out how to turn on the link control and set the URL.
                _SetMachineInfoLine(hDlg, *pControlID, szLink, TRUE);
            }

            (*pControlID)++;
        }

        RegCloseKey(hkey);
    }

    return hr;
}


HRESULT HrSysAllocStringW(IN const OLECHAR * pwzSource, OUT BSTR * pbstrDest)
{
    HRESULT hr = S_OK;

    if (pbstrDest)
    {
        *pbstrDest = SysAllocString(pwzSource);
        if (pwzSource)
        {
            if (*pbstrDest)
                hr = S_OK;
            else
                hr = E_OUTOFMEMORY;
        }
    }

    return hr;
}


HRESULT SetWMISecurityBlanket(IN IUnknown * punk, IUnknown * punkToPass)
{
    IClientSecurity * pClientSecurity;
    HRESULT hr = punk->QueryInterface(IID_PPV_ARG(IClientSecurity, &pClientSecurity));
    TraceMsg(TF_ALWAYS, "IEnumWbemClassObject::QueryInterface(IClientSecurity) called and hr=%#08lx", hr);

    if (SUCCEEDED(hr))
    {
        // Nuke after we get this working. RPC_C_AUTHN_NONE , RPC_C_AUTHZ_NAME 
        hr = pClientSecurity->SetBlanket(punk, RPC_C_AUTHN_WINNT, RPC_C_AUTHZ_NONE, NULL,
                        RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, NULL, EOAC_NONE);
        TraceMsg(TF_ALWAYS, "IClientSecurity::SetBlanket() called and hr=%#08lx", hr);
        pClientSecurity->Release();
    }

    return hr;
}


// DESCRIPTION:
//      WMI's Win32_Processor object will return a lot of rich information.
// We use this because we want rich information even if the processor doesn't
// provide it (like intel pre-Willette).  Millennium uses cpuid.asm as a
// hack and we want to prevent from copying that because there is a political
// pressure from the NT team to intel to have the processors provide this
// information.  That way the OS doesn't need to rev to include new processor
// names when they are released.  WMI does something to generate good results
// (\admin\wmi\WBEM\Providers\Win32Provider\Providers\processor.cpp) which
// includes asm.  I don't know if it's the exact same logic as Millennium and
// I don't care.  The important fact is that they are the only ones to maintain
// any hard coded list.  Therefore we are willing to use their poorly written
// API so we can re-use code and get out of the maintaince problems.
HRESULT GetWMI_Win32_Processor(OUT IEnumWbemClassObject ** ppEnumProcessors)
{
    HRESULT hr = E_NOTIMPL;

    *ppEnumProcessors = NULL;
    // Our second try is to use the WMI automation object.  It has a Win32_Processor object
    // that can give us a good Description, even when SZ_REGVALUE_PROCESSORNAMESTRING
    // isn't set.
    IWbemLocator * pLocator;

    hr = CoCreateInstance(CLSID_WbemLocator, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IWbemLocator, &pLocator));
    if (SUCCEEDED(hr))
    {
        hr = E_OUTOFMEMORY;
        BSTR bstrLocalMachine = SysAllocString(L"root\\cimv2");
        if (bstrLocalMachine)
        {
            IWbemServices * pIWbemServices;

            hr = pLocator->ConnectServer(bstrLocalMachine, NULL, NULL, 0L, 0L, NULL, NULL, &pIWbemServices);
            TraceMsg(TF_ALWAYS, "IWbemLocator::ConnectServer() called and hr=%#08lx", hr);
            if (SUCCEEDED(hr))
            {
                hr = E_OUTOFMEMORY;
                BSTR bstrQueryLang = SysAllocString(L"WQL");
                BSTR bstrQuery = SysAllocString(SZ_WMI_WQL_QUERY_STRING);
                if (bstrQueryLang && bstrQuery)
                {
                    IEnumWbemClassObject * pEnum = NULL;
                    hr = pIWbemServices->ExecQuery(bstrQueryLang, bstrQuery, (WBEM_FLAG_RETURN_IMMEDIATELY | WBEM_FLAG_FORWARD_ONLY), NULL , &pEnum);                        
                    TraceMsg(TF_ALWAYS, "IWbemServices::CreateInstanceEnum() called and hr=%#08lx", hr);
                    if (SUCCEEDED(hr))
                    {
                        hr = SetWMISecurityBlanket(pEnum, pIWbemServices);
                        TraceMsg(TF_ALWAYS, "SetWMISecurityBlanket() called and hr=%#08lx", hr);
                        if (SUCCEEDED(hr))
                        {
                            hr = pEnum->QueryInterface(IID_PPV_ARG(IEnumWbemClassObject, ppEnumProcessors));
                        }
                        pEnum->Release();
                    }
                }
                SysFreeString(bstrQuery); // SysFreeString is happy to take NULL             
                SysFreeString(bstrQueryLang);
                pIWbemServices->Release();
            }
            SysFreeString(bstrLocalMachine);
        }
        pLocator->Release();
    }

    return hr;
}


HRESULT GetProcessorDescFromWMI(PROCESSOR_INFO *ppi)
{
    IEnumWbemClassObject * pEnumProcessors;
    HRESULT hr = GetWMI_Win32_Processor(&pEnumProcessors);

    if (SUCCEEDED(hr))
    {
        IWbemClassObject * pProcessor;
        ULONG ulRet;

        // Currently we only care about the first processor.
        hr = pEnumProcessors->Next(WBEM_INFINITE, 1, &pProcessor, &ulRet);
        TraceMsg(TF_ALWAYS, "IEnumWbemClassObject::Next() called and hr=%#08lx", hr);
        if (SUCCEEDED(hr))
        {
            VARIANT varProcessorName = {0};

            hr = pProcessor->Get(SZ_WMI_WIN32PROCESSOR_ATTRIB_NAME, 0, &varProcessorName, NULL, NULL);
            if (SUCCEEDED(hr))
            {
                VARIANT varProcessorSpeed = {0};

                hr = pProcessor->Get(SZ_WMI_WIN32PROCESSOR_ATTRIB_SPEED, 0, &varProcessorSpeed, NULL, NULL);
                if (SUCCEEDED(hr) && 
                    VT_I4   == varProcessorSpeed.vt && 
                    varProcessorSpeed.lVal < WMI_WIN32PROCESSOR_SPEEDSTEP_CUTOFF) // we're in speed step power-saving mode
                {
                    hr = pProcessor->Get(SZ_WMI_WIN32PROCESSOR_ATTRIB_MAXSPEED, 0, &varProcessorSpeed, NULL, NULL);
                }

                if (SUCCEEDED(hr))
                {
                    if ((VT_BSTR == varProcessorName.vt) && (VT_I4 == varProcessorSpeed.vt))
                    {       
                        
                        if (FAILED(StringCchCopy(ppi->szProcessorDesc, ARRAYSIZE(ppi->szProcessorDesc), varProcessorName.bstrVal)))
                        {
                            ppi->szProcessorDesc[0] = 0; 
                        }

                        WCHAR szTemplate[MAX_PATH];
                        UINT idStringTemplate = IDS_PROCESSOR_SPEED;
                        szTemplate[0] = 0;

                        if (MHZ_TO_GHZ_THRESHHOLD <= varProcessorSpeed.lVal)
                        {
                            WCHAR szSpeed[20];
                            double dGHz = (varProcessorSpeed.lVal / (double)1000.0);

                            // Someone released a "1.13 GHz" chip, so let's display that correctly...
                            if (FAILED(StringCchPrintf(szSpeed, ARRAYSIZE(szSpeed), TEXT("%1.2f"), dGHz)))
                            {
                                ppi->szProcessorClockSpeed[0] = 0;
                            }
                            else
                            {
                                LoadString(hInstance, IDS_PROCESSOR_SPEEDGHZ, szTemplate, ARRAYSIZE(szTemplate));
                                if (FAILED(StringCchPrintf(ppi->szProcessorClockSpeed, ARRAYSIZE(ppi->szProcessorClockSpeed), szTemplate, szSpeed)))
                                {
                                    ppi->szProcessorClockSpeed[0] = 0;
                                }
                            }
                        }
                        else
                        {
                            LoadString(hInstance, IDS_PROCESSOR_SPEED, szTemplate, ARRAYSIZE(szTemplate));
                            if (FAILED(StringCchPrintf(ppi->szProcessorClockSpeed, ARRAYSIZE(ppi->szProcessorClockSpeed), szTemplate, varProcessorSpeed.lVal)))
                            {
                                ppi->szProcessorClockSpeed[0] = 0;
                            }
                        }
                    }
                    else
                    {
                        hr = E_FAIL;
                    }
                }

                VariantClear(&varProcessorSpeed);
            }

            VariantClear(&varProcessorName);
            pProcessor->Release();
        }

        pEnumProcessors->Release();
    }

    return hr;
}


HRESULT GetProcessorInfoFromRegistry(HKEY hkey, PROCESSOR_INFO *ppi)
{
    HRESULT hr = E_FAIL;
    WCHAR szTemp[MAX_PROCESSOR_DESCRIPTION];
    *szTemp = NULL;
    DWORD cbData = sizeof(szTemp);
    //To avoid copying blank string.
    if ((SHRegGetValue(hkey, NULL, SZ_REGVALUE_PROCESSORNAMESTRING, SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND, NULL, (LPBYTE)szTemp, &cbData) == ERROR_SUCCESS) &&
        (*szTemp != NULL) && (cbData > 1))
    {
        //ISSUE - How do I get the processor clock speed. 
        hr = StringCchCopy (ppi->szProcessorDesc, ARRAYSIZE(ppi->szProcessorDesc), szTemp);
    }
    return hr;
}



// This is the number of chars that will fit on one line in our dialog
// with the current layout.
#define SIZE_CHARSINLINE            30

BOOL _GetProcessorDescription(PROCESSOR_INFO* ppi, BOOL* pbShowClockSpeed)
{
    BOOL bShowProcessorInfo = FALSE;
    *pbShowClockSpeed = TRUE;
    HKEY hkey;

    // In general, WMI is a lowse API.  However, they provide the processor description on
    // downlevel so we need them.  They implement this in a hacky way so we want them to
    // maintain the hack and all the problems associated with it.  We need to turn this feature
    // off until they fix their bugs.  Currently, they call JET which recently regressed and
    // causes their API to take 10-20 seconds.  -BryanSt
    if (SHRegGetBoolUSValue(SZ_REGKEY_HARDWARE, SZ_REGKEY_USE_WMI, FALSE, TRUE))
    {
        if (SUCCEEDED(GetProcessorDescFromWMI(ppi)))
        {
            bShowProcessorInfo = TRUE;
        }
    }


    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_REGKEY_HARDWARE_CPU, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        // Try for ProcessorNameString if present.
        // This registry entry will contain the most correct description of the processor
        // because it came directly from the CPU.  AMD and Cyrix support this but
        // intel won't until Willette.
        if (FAILED(GetProcessorInfoFromRegistry(hkey, ppi)))
        {
            if (!bShowProcessorInfo)
            {
                // Our last try is to use the generic Identifier.  This is normally formatted like,
                // "x86 Family 6 Model 7 Stepping 3" but it's better than nothing.
                DWORD cbData = sizeof(ppi->szProcessorDesc);
                if (SHRegGetValue(hkey, NULL, c_szIndentifier, SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND, NULL, (LPBYTE)ppi->szProcessorDesc, &cbData) == ERROR_SUCCESS)
                {
                    bShowProcessorInfo = TRUE;
                    *pbShowClockSpeed = FALSE;
                }
            }
        }
        RegCloseKey(hkey);
    }

    return bShowProcessorInfo;    
}

void _SetProcessorDescription(HWND hDlg, PROCESSOR_INFO* ppi, BOOL bShowClockSpeed, BOOL bShowProcessorInfo, int * pnControlID)
{
    if (bShowProcessorInfo)
    {
        WCHAR szProcessorLine1[MAX_PATH];
        WCHAR szProcessorLine2[MAX_PATH];

        // We need to get the CPU name from the CPU itself so we don't
        // need to rev our OS's INF files every time they ship a new processor.  So we guaranteed
        // them that we would display whatever string they provide in whatever way they provide it
        // up to 49 chars.  The layout on the dlg doesn't allow 49 chars on one line so we need to wrap
        // in that case.  Whistler #159510.
        // Don't change this without talking to me (BryanSt) or JVert.
        //
        // Note: there is often talk of stripping leading spaces.  Intel even asks software to do this.
        //   (http://developer.intel.com/design/processor/future/manuals/CPUID_Supplement.htm)
        // However, we SHOULD NOT do this.  This call was defined and standardized by AMD long ago. 
        //   The rule we make is they must be compatible with AMDs existing implementation.
        //   (http://www.amd.com/products/cpg/athlon/techdocs/pdf/20734.pdf)
        // Contact JVert for questions on stripping leading spaces.
        
        StringCchCopy(szProcessorLine1, ARRAYSIZE(szProcessorLine1), ppi->szProcessorDesc); // display string, truncation ok
        szProcessorLine2[0] = 0;

        if (SIZE_CHARSINLINE < lstrlen(szProcessorLine1))
        {
            // Now word wrap
            WCHAR* pszWrapPoint = StrRChr(szProcessorLine1, szProcessorLine1 + SIZE_CHARSINLINE, TEXT(' '));
            if (pszWrapPoint)
            {
                StringCchCopy(szProcessorLine2, ARRAYSIZE(szProcessorLine2), pszWrapPoint + 1); // display string, truncation ok
                *pszWrapPoint = 0;
            }
            else // if no space found, just wrap at SIZE_CHARSINLINE
            {
                StringCchCopy(szProcessorLine2, ARRAYSIZE(szProcessorLine2), &szProcessorLine1[SIZE_CHARSINLINE]); // display string, truncation ok
                szProcessorLine1[SIZE_CHARSINLINE] = 0;
            }
        }

        _SetMachineInfoLine(hDlg, (*pnControlID)++, szProcessorLine1, FALSE);
        if (szProcessorLine2[0])
        {
            _SetMachineInfoLine(hDlg, (*pnControlID)++, szProcessorLine2, FALSE);
        }

        if (bShowClockSpeed)
        {
           _SetMachineInfoLine(hDlg, (*pnControlID)++, ppi->szProcessorClockSpeed, FALSE);
        }
    }
}


typedef struct _OSNAMEIDPAIR {
    UINT iOSType;
    UINT iOSName;
    BOOL fWinBrandDll;
} OSNAMEIDPAIR;

//*************************************************************
//  Purpose:    Initalize the general page
//
//  Parameters: hDlg -  Handle to the dialog box
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/20/95    ericflo    Ported
//*************************************************************
VOID InitGeneralDlg(HWND hDlg)
{
    OSVERSIONINFO ver;
    WCHAR szScratch1[64];
    WCHAR szScratch2[64];
    DWORD cbData;
    HKEY hkey;
    int ctlid;
    UINT id;
    HMODULE hResourceDll = hInstance;

    // Set the default bitmap
    SetClearBitmap(GetDlgItem(hDlg, IDC_GEN_WINDOWS_IMAGE), 
                   IsLowColor(hDlg) ? MAKEINTRESOURCE(IDB_WINDOWS_256) : MAKEINTRESOURCE(IDB_WINDOWS), 0);

    /////////////////////////
    // Version info

    ctlid = IDC_GEN_VERSION_0;

    // Query for the build number information
    ver.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    
    if (!GetVersionEx(&ver)) {
        return;
    }

    // Major Branding ("Microsoft Windows XP", ".NET Server 2003", etc.)
    if (IsOS(OS_ANYSERVER))
    {
        id = IDS_WINVER_WINDOWSDOTNET;
    }
    else
    {
        id = IDS_WINVER_WINDOWSXP;
    }
    LoadString(hInstance, id, szScratch1, ARRAYSIZE(szScratch1));
    SetDlgItemText(hDlg, ctlid++, szScratch1);

    // Minor Branding ("Personal", "Professional", "64-Bit Edition", etc)
    szScratch1[0] = TEXT('\0');
    id = 0;
    // note: OS_EMBEDDED must be before any options that may co-occur with OS_EMBEDDED
#ifndef _WIN64
    OSNAMEIDPAIR rgID[] = {{OS_EMBEDDED, IDS_WINVER_EMBEDDED, FALSE},
                           {OS_MEDIACENTER, IDS_WINVER_MEDIACENTER_SYSDM_CPL, TRUE},
                           {OS_TABLETPC, IDS_WINVER_TABLETPC_SYSDM_CPL, TRUE},
                           {OS_PERSONAL, IDS_WINVER_PERSONAL, FALSE}, 
                           {OS_PROFESSIONAL, IDS_WINVER_PROFESSIONAL, FALSE}, 
                           //{OS_APPLIANCE, IDS_WINVER_APPLIANCE_SYSDM_CPL, TRUE},
                           {OS_SERVER, IDS_WINVER_SERVER, FALSE}, 
                           {OS_ADVSERVER, IDS_WINVER_ADVANCEDSERVER, FALSE}, 
                           {OS_DATACENTER, IDS_WINVER_DATACENTER, FALSE},
                           {OS_BLADE, IDS_WINVER_BLADE, FALSE},
                           {OS_SMALLBUSINESSSERVER, IDS_WINVER_SBS, FALSE}};
#else
    OSNAMEIDPAIR rgID[] = {{OS_PROFESSIONAL, IDS_WINVER_PROFESSIONAL_WIN64, FALSE}, 
                           {OS_SERVER, IDS_WINVER_SERVER, FALSE}, 
                           {OS_ADVSERVER, IDS_WINVER_ADVANCEDSERVER, FALSE}, 
                           {OS_DATACENTER, IDS_WINVER_DATACENTER, FALSE}};
#endif

    for (int i = 0; i < ARRAYSIZE(rgID); i++)
    {
        if (IsOS(rgID[i].iOSType))
        {
            id = (rgID[i].iOSName);

            // If this resource lives in the special Windows branding DLL,
            // attempt to load the DLL now. If this fails, just leave this
            // string empty.

            if (rgID[i].fWinBrandDll)
            {
                hResourceDll = LoadLibraryEx(TEXT("winbrand.dll"), NULL, LOAD_LIBRARY_AS_DATAFILE);

                if (hResourceDll == NULL)
                {
                    // This will result in an empty string, which is
                    // acceptable for this very unlikely scenario.

                    id = 0;
                    hResourceDll = hInstance;
                }
            }
            break;
        }
    };

    LoadString(hResourceDll, id, szScratch1, ARRAYSIZE(szScratch1));

    if (hResourceDll != hInstance)
    {
        FreeLibrary(hResourceDll);
    }

    SetDlgItemText(hDlg, ctlid++, szScratch1);
        
    // Version Year and/or Debug-ness
    if (GetSystemMetrics(SM_DEBUG)) 
    {
        LoadString(hInstance, IDS_DEBUG, szScratch2, ARRAYSIZE(szScratch2));
        if (!IsOS(OS_ANYSERVER))
        {
            // non-srv / debug = "Version 2003 (Debug)"
            LoadString(hInstance, IDS_WINVER_YEAR, szScratch1, ARRAYSIZE(szScratch1));
            StringCchCat(szScratch1, ARRAYSIZE(szScratch1), L" ");
            StringCchCat(szScratch1, ARRAYSIZE(szScratch1), szScratch2);
            // ISSUE-aidanl-2002-09-12 - this should be rewritten eventually using %1 and %2
            //                           (we can get away with it here b/c few people see debug builds)
        }
        else
        {
            // server / debug = "(Debug)"
            StringCchCopy(szScratch1, ARRAYSIZE(szScratch1), szScratch2);
        }
    } 
    else 
    {
        if (!IsOS(OS_ANYSERVER))
        {
            // non-srv / free  = "Version 2003"
            LoadString(hInstance, IDS_WINVER_YEAR, szScratch1, ARRAYSIZE(szScratch1));
        }
        else
        {
            // server / free  = line not present
            szScratch1[0] = 0;
        }
    }
    if (szScratch1[0])
    {
        SetDlgItemText(hDlg, ctlid++, szScratch1);
    }

    // Service Pack (if any)
    SetDlgItemText(hDlg, ctlid++, ver.szCSDVersion);

    /////////////////////////
    // User Info / Product ID

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, c_szAboutKey, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        // Do registered user info
        ctlid = IDC_GEN_REGISTERED_0;  // start here and use more as needed

        cbData = sizeof(szScratch2);
        if((SHRegGetValue(hkey, NULL, c_szAboutRegisteredOwner,
            SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND, NULL, (LPBYTE)szScratch2, &cbData) == ERROR_SUCCESS) &&
            (cbData > 1))
        {
            SetDlgItemText(hDlg, ctlid++, szScratch2);
        }

        cbData = sizeof(szScratch2);
        if((SHRegGetValue(hkey, NULL, c_szAboutRegisteredOrganization,
            SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND, NULL, (LPBYTE)szScratch2, &cbData) == ERROR_SUCCESS) &&
            (cbData > 1))
        {
            SetDlgItemText(hDlg, ctlid++, szScratch2);
        }

        cbData = sizeof(szScratch2);
        if((SHRegGetValue(hkey, NULL, c_szAboutProductId,
            SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND, NULL, (LPBYTE)szScratch2, &cbData) == ERROR_SUCCESS) &&
            (cbData > 1))
        {
            SetDlgItemText(hDlg, ctlid++, szScratch2);
        }

        cbData = sizeof(szScratch2);
        if((SHRegGetValue(hkey, NULL, c_szAboutAnotherProductId,
                          SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND, NULL, (LPBYTE)szScratch2, &cbData) == ERROR_SUCCESS) &&
            (cbData > 1))
        {
            SetDlgItemText(hDlg, ctlid++, szScratch2);
        }

        RegCloseKey(hkey);
    }    

    SHCreateThread(InitGeneralDlgThread, hDlg, CTF_COINIT | CTF_FREELIBANDEXIT, NULL);
}

DWORD WINAPI InitGeneralDlgThread(LPVOID lpParam)
{
    SYSTEM_BASIC_INFORMATION BasicInfo;
    NTSTATUS Status;
    
    if (!lpParam)
        return -1;
    
    INITDLGSTRUCT* pids = (INITDLGSTRUCT*)LocalAlloc(LPTR, sizeof(INITDLGSTRUCT));
    if (pids)
    {
        // Memory
        Status = NtQuerySystemInformation(
                    SystemBasicInformation,
                    &BasicInfo,
                    sizeof(BasicInfo),
                    NULL
                   );

        if (NT_SUCCESS(Status))
        {
            LONGLONG nTotalBytes = BasicInfo.NumberOfPhysicalPages; 

            nTotalBytes *= BasicInfo.PageSize;

            // WORKAROUND - NtQuerySystemInformation doesn't really return the total available physical
            // memory, it instead just reports the total memory seen by the Operating System. Since
            // some amount of memory is reserved by BIOS, the total available memory is reported 
            // incorrectly. To work around this limitation, we convert the total bytes to 
            // the nearest 4MB value
        
            #define ONEMB 1048576  //1MB = 1048576 bytes.
            double nTotalMB =  (double)(nTotalBytes / ONEMB);
            pids->llMem = (LONGLONG)((ceil(ceil(nTotalMB) / 4.0) * 4.0) * ONEMB);
        }

        pids->fShowProcName = _GetProcessorDescription(&pids->pi, &pids->fShowProcSpeed);

        PostMessage((HWND)lpParam, SYSCPL_ASYNC_COMPUTER_INFO, (WPARAM)pids, 0);
    }

    return 0;
}

VOID CompleteGeneralDlgInitialization(HWND hDlg, INITDLGSTRUCT* pids)
{
    WCHAR oemfile[MAX_PATH];
    int ctlid;
    NTSTATUS Status;
    HKEY hkey;
    WCHAR szScratch1[64];
    WCHAR szScratch2[64];
    WCHAR szScratch3[64];
    DWORD cbData;

    // Do machine info
    ctlid = IDC_GEN_MACHINE_0;  // start here and use controls as needed

    // if OEM name is present, show logo and check for phone support info
    if (SUCCEEDED(_GetOemFile(oemfile, ARRAYSIZE(oemfile), GETOEMFILE_OEMDATA)))
    {
        if (GetPrivateProfileString(c_szOemGenSection, c_szOemName, c_szEmpty,
                                    szScratch1, ARRAYSIZE(szScratch1), oemfile)) // we don't care about truncation
        {
            _SetMachineInfoLine(hDlg, ctlid++, szScratch1, FALSE);

            if(GetPrivateProfileString(c_szOemGenSection, c_szOemModel,
                                       c_szEmpty, szScratch1, ARRAYSIZE(szScratch1), oemfile)) // we don't care about truncation
            {
                _SetMachineInfoLine(hDlg, ctlid++, szScratch1, FALSE);
            }

            if (SUCCEEDED(StringCchCopy(szScratch2, ARRAYSIZE(szScratch2), c_szOemSupportLinePrefix)) &&
                SUCCEEDED(StringCchCat(szScratch2, ARRAYSIZE(szScratch2), TEXT("1"))))
            {
                if(GetPrivateProfileString(c_szOemSupportSection,
                                           szScratch2, c_szEmpty, szScratch1, ARRAYSIZE(szScratch1), oemfile)) // sure
                {
                    HWND wnd = GetDlgItem(hDlg, IDC_GEN_OEM_SUPPORT);

                    EnableWindow(wnd, TRUE);
                    ShowWindow(wnd, SW_SHOW);
                }

                if (SUCCEEDED(_GetOemFile(oemfile, ARRAYSIZE(oemfile), GETOEMFILE_OEMIMAGE)) &&
                    SetClearBitmap(GetDlgItem(hDlg, IDC_GEN_OEM_IMAGE), oemfile, SCB_FROMFILE))
                {
                    ShowWindow(GetDlgItem(hDlg, IDC_GEN_OEM_NUDGE), SW_SHOWNA);
                    ShowWindow(GetDlgItem(hDlg, IDC_GEN_MACHINE), SW_HIDE);
                }
            }
        }
    }

    // Get Processor Description
    _SetProcessorDescription(hDlg, &pids->pi, pids->fShowProcSpeed, pids->fShowProcName, &ctlid);

    // System identifier
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_REGKEY_HARDWARE, 0, KEY_READ, &hkey) == ERROR_SUCCESS)
    {
        cbData = sizeof(szScratch2);
        if (SHRegGetValue(hkey, NULL, c_szIndentifier, SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND, 0, (LPBYTE)szScratch2, &cbData) == ERROR_SUCCESS)
        {
            // Some OEMs put "AT/AT Compatible" as the System Identifier.  Since this
            // is completely obsolete, we may want to have a feature that simply ignores
            // it.
#ifdef FEATURE_IGNORE_ATCOMPAT
            if (StrCmpI(szScratch2, SZ_ATCOMPATIBLE))
#endif // FEATURE_IGNORE_ATCOMPAT
            {
                _SetMachineInfoLine(hDlg, ctlid++, szScratch2, FALSE);
            }
        }

        RegCloseKey(hkey);
    }            
        
    StrFormatByteSize(pids->llMem, szScratch1, ARRAYSIZE(szScratch1));
    LoadString(hInstance, IDS_XDOTX_MB, szScratch3, ARRAYSIZE(szScratch3));
    if (SUCCEEDED(StringCchPrintf(szScratch2, ARRAYSIZE(szScratch2), szScratch3, szScratch1)))
    {
        _SetMachineInfoLine(hDlg, ctlid++, szScratch2, FALSE);
    }
    

    // Physical address extension
    Status = RegOpenKey(
        HKEY_LOCAL_MACHINE,
        c_szMemoryManagement,
        &hkey
    );
    if (ERROR_SUCCESS == Status)
    {
        DWORD paeEnabled;

        Status = SHRegGetValue(hkey, 
                               NULL,
                               c_szPhysicalAddressExtension,
                               SRRF_RT_REG_DWORD,
                               NULL,
                               (LPBYTE)&paeEnabled,
                               &cbData);

        if (ERROR_SUCCESS == Status &&
            sizeof(paeEnabled) == cbData &&
            0 != paeEnabled) {
            LoadString(hInstance, IDS_PAE, szScratch1, ARRAYSIZE(szScratch1));
            _SetMachineInfoLine(hDlg, ctlid++, szScratch1, FALSE);
        }

        RegCloseKey(hkey);
    }

    AddOEMHyperLinks(hDlg, &ctlid);    
}

HRESULT _DisplayHelp(LPHELPINFO lpHelpInfo)
{
    // We will call WinHelp() unless it's an OEM link
    // because in that case, we don't know what to show.
    if ((g_nStartOfOEMLinks <= lpHelpInfo->iCtrlId) &&      // Is it outside of the IDC_GEN_MACHINE_* range used by OEM Links?
        (LAST_GEN_MACHINES_SLOT >= lpHelpInfo->iCtrlId) &&   // Is it outside of the IDC_GEN_MACHINE_* range used by OEM Links?
        (IDC_GEN_OEM_SUPPORT != lpHelpInfo->iCtrlId))       // Is it outside of the IDC_GEN_MACHINE_* range used by OEM Links?
    {
        int nIndex;

        // This item is an OEM link, so let's mark it as "No Help".
        for (nIndex = 0; nIndex < ARRAYSIZE(aGeneralHelpIds); nIndex++)
        {
            if ((DWORD)lpHelpInfo->iCtrlId == aGeneralHelpIds[nIndex])
            {
                aGeneralHelpIds[nIndex + 1] = NO_HELP;
                break;
            }

            nIndex++;   // We need to skip every other entry because it's a list.
        }
    }

    WinHelp((HWND)lpHelpInfo->hItemHandle, HELP_FILE, HELP_WM_HELP, (DWORD_PTR) (LPSTR) aGeneralHelpIds);
    return S_OK;
}


//*************************************************************
//  Purpose:    Dialog box procedure for general tab
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/17/95    ericflo    Created
//*************************************************************
INT_PTR APIENTRY GeneralDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        InitGeneralDlg(hDlg);
        break;

    case WM_NOTIFY:
        switch (((NMHDR FAR*)lParam)->code)
        {
        case PSN_APPLY:
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
            return TRUE;

        default:
            return FALSE;
        }
        break;

    case WM_COMMAND:
        if (wParam == IDC_GEN_OEM_SUPPORT) {
            DialogBox(hInstance, MAKEINTRESOURCE(IDD_PHONESUP),
                      GetParent(hDlg), PhoneSupportProc);
        }
        break;

    case WM_SYSCOLORCHANGE:
        {
            WCHAR oemfile[MAX_PATH];

            if (SUCCEEDED(_GetOemFile(oemfile, ARRAYSIZE(oemfile), GETOEMFILE_OEMIMAGE)))
            {
                SetClearBitmap(GetDlgItem(hDlg, IDC_GEN_OEM_IMAGE), oemfile, SCB_FROMFILE | SCB_REPLACEONLY);

                SetClearBitmap(GetDlgItem(hDlg, IDC_GEN_WINDOWS_IMAGE), 
                               IsLowColor(hDlg) ? MAKEINTRESOURCE(IDB_WINDOWS_256) : MAKEINTRESOURCE(IDB_WINDOWS), 0);
            }
        }
        break;

    case SYSCPL_ASYNC_COMPUTER_INFO:
        {
            if (wParam)
            {
                CompleteGeneralDlgInitialization(hDlg, (INITDLGSTRUCT*)wParam);
                LocalFree((HLOCAL)wParam);
            }
        }        
        break;
    case WM_DESTROY:
        SetClearBitmap(GetDlgItem(hDlg, IDC_GEN_OEM_IMAGE), NULL, 0);
        SetClearBitmap(GetDlgItem(hDlg, IDC_GEN_WINDOWS_IMAGE), NULL, 0);
        break;

    case WM_HELP:      // F1
        _DisplayHelp((LPHELPINFO) lParam);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
        (DWORD_PTR) (LPSTR) aGeneralHelpIds);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}


//*************************************************************
//
//  PhoneSupportProc()
//
//  Purpose:    Dialog box procedure for OEM phone support dialog
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              11/17/95    ericflo    Created
//
//*************************************************************

INT_PTR APIENTRY PhoneSupportProc(HWND hDlg, UINT uMsg,
                               WPARAM wParam, LPARAM lParam)
{
    switch(uMsg) {

        case WM_INITDIALOG:
        {
            HWND hwndEdit = GetDlgItem(hDlg, IDC_SUPPORT_TEXT);
            WCHAR oemfile[MAX_PATH];
            WCHAR szText[ 256 ];
            WCHAR szLine[ 12 ];
            LPWSTR pszEnd = szLine + lstrlen(c_szOemSupportLinePrefix);

            if (SUCCEEDED(_GetOemFile(oemfile, ARRAYSIZE(oemfile), GETOEMFILE_OEMDATA)))
            {
                GetPrivateProfileString(c_szOemGenSection, c_szOemName, c_szEmpty,
                                        szText, ARRAYSIZE(szText), oemfile);
                SetWindowText(hDlg, szText);

                if (SUCCEEDED(StringCchCopy(szLine, ARRAYSIZE(szLine), c_szOemSupportLinePrefix)))
                {
                    SendMessage (hwndEdit, WM_SETREDRAW, FALSE, 0);

                    HRESULT hr = S_OK;
                    for(UINT i = 1; SUCCEEDED(hr); i++) // 1-based by design
                    {
                        hr = StringCchPrintf(pszEnd, ARRAYSIZE(szLine) - lstrlen(c_szOemSupportLinePrefix), TEXT("%u"), i);
                        if (SUCCEEDED(hr))
                        {                            
                            GetPrivateProfileString(c_szOemSupportSection,
                                                    szLine, c_szDefSupportLineText, szText, ARRAYSIZE(szText) - 2,
                                                    oemfile); // truncation fine
                            
                            if(!lstrcmpi(szText, c_szDefSupportLineText)) // because we passed in szText as default, this
                            {                                             // means GetPrivateProfileString failed
                                hr = E_FAIL;
                            }
                            else
                            {                                
                                hr = StringCchCat(szText, ARRAYSIZE(szText), c_szCRLF);
                                if (SUCCEEDED(hr))
                                {
                                    
                                    SendMessage(hwndEdit, EM_SETSEL, (WPARAM)-1, (LPARAM)-1);
                                    
                                    SendMessage(hwndEdit, EM_REPLACESEL, 0, (LPARAM)szText);
                                }
                            }
                        }
                    }
                }

                SendMessage (hwndEdit, WM_SETREDRAW, TRUE, 0);
            }
            break;
        }

        case WM_COMMAND:

            switch (LOWORD(wParam)) {
                 case IDOK:
                 case IDCANCEL:
                     EndDialog(hDlg, 0);
                     break;

                 default:
                     return FALSE;
            }
            break;

        default:
            return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\hardware.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    hardware.h

Abstract:

    Public declarations for the Hardware tab of the System 
    Control Panel Applet

Author:

    William Hsieh (williamh) 03-Jul-1997

Revision History:

    17-Oct-1997 scotthal
        Complete overhaul

--*/
#ifndef _SYSDM_HARDWARE_H_
#define _SYSDM_HARDWARE_H_

//
// Constants and macros
//
#define DEVMGR_FILENAME 	L"devmgr.dll"
#define WIZARD_FILENAME 	L"hdwwiz.cpl"
#define WIZARD_PARAMETERS	L""
#define WIZARD_VERB         L"CPLOpen"
#define DEVMGR_EXECUTE_PROC_NAME "DeviceManager_ExecuteW"

//
// Type definitions
//
typedef BOOL (*PDEVMGR_EXECUTE_PROC)(HWND hwnd, HINSTANCE hInst, LPCTSTR MachineName, int nCmdShow);

INT_PTR 
APIENTRY 
HardwareDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);

#endif // _SYSDM_HARDWARE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\netid.cpp ===
// Copyright (C) 1997 Microsoft Corporation
// 
// Network ID Tab hook
// 
// 3-07-98 sburns



#include "sysdm.h"



HPROPSHEETPAGE
CreateNetIDPage(int, DLGPROC)
{
   TCHAR szDllName[MAX_PATH] = {0};
   LoadString(hInstance, IDS_NETID_DLL_NAME, szDllName, ARRAYSIZE(szDllName));

   HPROPSHEETPAGE result = 0;
   HINSTANCE netid = ::LoadLibrary(szDllName);

   if (netid)
   {
      typedef HPROPSHEETPAGE (*CreateProc)();

      CreateProc proc =
         reinterpret_cast<CreateProc>(
            ::GetProcAddress(netid, "CreateNetIDPropertyPage"));

      if (proc)
      {
         result = proc();
      }
   }

   return result;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\netid.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    netid.h

Abstract:

    Public declarations for the Network ID tab of the System Control 
    Panel Applet


--*/
#ifndef _SYSDM_NETID_H_
#define _SYSDM_NETID_H_

//
// Public function prototypes
//


HPROPSHEETPAGE
CreateNetIDPage(
    int,
    DLGPROC
);



#endif // _SYSDM_NETID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\hardware.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    hardware.c

Abstract:

    Implements the Hardware tab of the System Control Panel Applet

Author:

    William Hsieh (williamh) 03-Jul-1997

Revision History:

    17-Oct-1997 scotthal
        Complete overhaul

--*/
#include "sysdm.h"

//
// Help IDs
//
DWORD aHardwareHelpIds[] = {
    IDC_WIZARD_ICON,           (IDH_HARDWARE + 0),
    IDC_WIZARD_TEXT,           (IDH_HARDWARE + 0),
    IDC_WIZARD_START,          (IDH_HARDWARE + 1),
    IDC_DEVMGR_ICON,           (IDH_HARDWARE + 2),
    IDC_DEVMGR_TEXT,           (IDH_HARDWARE + 2),
    IDC_DEVMGR_START,          (IDH_HARDWARE + 3),
    IDC_HWPROFILES_ICON,       (IDH_HARDWARE + 4),
    IDC_HWPROFILES_START_TEXT, (IDH_HARDWARE + 4),
    IDC_HWPROFILES_START,      (IDH_HARDWARE + 5),
    IDC_DRIVER_SIGNING,          (IDH_HARDWARE + 6),
    0, 0
};

//
// Function prototypes
//
void 
InitHardwareDlg(
    IN HWND hDlg
);

BOOL
HardwareHandleCommand(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
);

void 
StartHardwareWizard(
    IN HWND hDlg
);

void 
StartDeviceManager(
    IN HWND hDlg
);

typedef HRESULT (WINAPI *PFNDRIVERSIGNING)(HWND hwnd, DWORD dwFlags);

BOOL ShowDriverSigning(HWND hDlg)
{
    BOOL bFound = FALSE;
    HMODULE hmod = LoadLibrary(TEXT("sigtab.dll"));
    if (hmod)
    {
        PFNDRIVERSIGNING pfn = (PFNDRIVERSIGNING)GetProcAddress(hmod, "DriverSigningDialog");
        if (pfn)
        {
            bFound = TRUE;
            if (hDlg)
                pfn(hDlg, 0);
        }
        FreeLibrary(hmod);
    }
    return bFound;
}



VOID 
InitHardwareDlg(
    IN HWND hDlg
)
/*++

Routine Description:

    Initialize the hardware page

Arguments:

    hDlg -
        Supplies the window handle

Return Value:

    None

--*/
{


    HICON hIconNew;
    HICON hIconOld;

    hIconNew = ExtractIcon(hInstance, WIZARD_FILENAME, 0);

    if (hIconNew && (HICON)1 != hIconNew) {
        hIconOld = (HICON)SendDlgItemMessage(hDlg, IDC_WIZARD_ICON, STM_SETICON, (WPARAM)hIconNew, 0);
        if(hIconOld) {
            DestroyIcon(hIconOld);
        }
    }

    hIconNew = ExtractIcon(hInstance, DEVMGR_FILENAME, 0);
    if (hIconNew && (HICON)1 != hIconNew) {
        hIconOld = (HICON)SendDlgItemMessage(hDlg, IDC_DEVMGR_ICON, STM_SETICON, (WPARAM)hIconNew, 0);
        if(hIconOld) {
            DestroyIcon(hIconOld);
        }
    }

    if (!ShowDriverSigning(NULL))
        ShowWindow(GetDlgItem(hDlg, IDC_DRIVER_SIGNING), SW_HIDE);
}


INT_PTR
APIENTRY 
HardwareDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles messages sent to the hardware tab

Arguments:

    hDlg -
        Supplies window handle

    uMsg -
        Supplies message being sent

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
{

    switch (uMsg) {
        case WM_INITDIALOG:
            InitHardwareDlg(hDlg);
            break;
    
        case WM_COMMAND:
            return HardwareHandleCommand(hDlg, wParam, lParam);
            break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP, (DWORD_PTR) (LPSTR) aHardwareHelpIds);
            break;
    
        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU, (DWORD_PTR) (LPSTR) aHardwareHelpIds);
            break;

        default:
            return(FALSE);
    } // switch

    return(TRUE);
}


BOOL
HardwareHandleCommand(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles WM_COMMAND messages sent to the Hardware tab

Arguments:

    hDlg -
        Supplies the window handle

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
{
    DWORD_PTR dwResult = 0;

    switch (LOWORD(wParam)) {
        case IDC_WIZARD_START:
            StartHardwareWizard(hDlg);
            break;

        case IDC_DEVMGR_START:
            StartDeviceManager(hDlg);
            break;

        case IDC_DRIVER_SIGNING:
            ShowDriverSigning(hDlg);
            break;

        case IDC_HWPROFILES_START:
            dwResult = DialogBox(
                hInstance,
                MAKEINTRESOURCE(DLG_HWPROFILES),
                hDlg,
                HardwareProfilesDlg
            );
            break;
        
        default:
            return(FALSE);
    } // switch

    return(TRUE);
}


void
StartHardwareWizard(
    IN HWND hDlg
)
/*++

Routine Description:

    Start the Hardware wizard

Arguments:

    hDlg -
        Supplies window handle

Return Value:

    None
--*/
{
    TCHAR szWizardPath[MAX_PATH];

    if (GetSystemDirectory(szWizardPath, ARRAYSIZE(szWizardPath)) &&
        PathAppend(szWizardPath, WIZARD_FILENAME))
    {
        SHELLEXECUTEINFO sei = {0};

        sei.cbSize = sizeof(sei);
        sei.hwnd = hDlg;
        sei.lpFile = szWizardPath;
        sei.lpParameters = WIZARD_PARAMETERS;
        sei.lpVerb = WIZARD_VERB;
        sei.nShow = SW_NORMAL;
        sei.hInstApp = hInstance;
        if (!ShellExecuteEx(&sei))
        {
	        if (ERROR_FILE_NOT_FOUND == GetLastError() ||
	            ERROR_PATH_NOT_FOUND == GetLastError())
	        {
	            // reinitialize the contents of the dialog in case
	            // user has fixed the problem
	            InitHardwareDlg(hDlg);
	        }
        }
    }
}


void
StartDeviceManager(
    IN HWND hDlg
)
/*++

Routine Description:

    Start Device Manager

Arguments:

    hDlg -
        Supplies window handle

Return Value:

    None

--*/
{
    HINSTANCE hDevMgr;

    PDEVMGR_EXECUTE_PROC    DevMgrProc;
    hDevMgr = LoadLibrary(DEVMGR_FILENAME);

    if (hDevMgr)
    {

    HourGlass(TRUE);

	DevMgrProc = (PDEVMGR_EXECUTE_PROC) GetProcAddress(hDevMgr, DEVMGR_EXECUTE_PROC_NAME);
	if (DevMgrProc)
	    (*DevMgrProc)(hDlg, hInstance, NULL, SW_NORMAL);
	else
	    MsgBoxParam(hDlg, IDS_SYSDM_NOEXPORTS_DEVMANPROG, IDS_SYSDM_TITLE, MB_OK | MB_ICONEXCLAMATION, DEVMGR_FILENAME);

	FreeLibrary(hDevMgr);

    HourGlass(FALSE);

    }
    else
    {
	MsgBoxParam(hDlg, IDS_SYSDM_NOLOAD_DEVMANPROG, IDS_SYSDM_TITLE, MB_OK | MB_ICONEXCLAMATION, DEVMGR_FILENAME);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\helpid.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    helpid.h

Abstract:

    Resource IDs for the System Control Panel Applet

Author:

    Scott Hallock (scotthal) 17-Oct-1997

Revision History:

    15-Oct-1997 scotthal
        Split Help IDs into their own header

--*/
#ifndef _SYSDM_HELPID_H_
#define _SYSDM_HELPID_H_

#define HELP_FILE           TEXT("sysdm.hlp")

#define IDH_HELPFIRST       5000

//
// Help IDs for the General tab
//
#define IDH_GENERAL         (IDH_HELPFIRST + 0000)
#define IDH_PERF            (IDH_HELPFIRST + 1000)
#define IDH_ENV             (IDH_HELPFIRST + 2000)
#define IDH_ENV_EDIT        (IDH_HELPFIRST + 2500)
#define IDH_STARTUP         (IDH_HELPFIRST + 3000)
#define IDH_HWPROFILE       (IDH_HELPFIRST + 4000)
#define IDH_USERPROFILE     (IDH_HELPFIRST + 5000)
#define IDH_HARDWARE        (IDH_HELPFIRST + 6000)
#define IDH_ADVANCED        (IDH_HELPFIRST + 7000)
#define IDH_PFR             (IDH_HELPFIRST + 9000)
#define IDH_DLGFIRST        (IDH_HELPFIRST + 3000)
#define IDH_DLG_VIRTUALMEM  (IDH_DLGFIRST + DLG_VIRTUALMEM)

#define IDH_HWP_PROPERTIES_SELECTION_CHECKBOX     9327

#endif // _SYSDM_HELPID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\hwprof.h ===
/*++

Copyright (c) 1995-1997  Microsoft Corporation

Module Name:

    hwprof.h

Abstract:

    Public declarations for the Hardware Profiles dialog.

Author:

    Paula Tomlinson (paulat) 8-22-1995

Revision History:

    22-Aug-1995     paulat
        Creation and initial implementation.

    17-Oc-1997 scotthal
        Split public declarations into their own header file

--*/
#ifndef _SYSDM_HWPROF_H_
#define _SYSDM_HWPROF_H_

//
// Public function prototypes
//
INT_PTR 
APIENTRY 
HardwareProfilesDlg(
    IN HWND hDlg, 
    IN UINT uMessage, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);

INT_PTR 
APIENTRY 
CopyProfileDlg(
    IN HWND hDlg, 
    IN UINT uMessage, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);

INT_PTR 
APIENTRY 
RenameProfileDlg(
    IN HWND hDlg, 
    IN UINT uMessage, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);

INT_PTR 
APIENTRY GeneralProfileDlg(
    IN HWND hDlg, 
    IN UINT uMessage, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);

#endif // _SYSDM_HWPROF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\hwprof.c ===
/*++

    Copyright (c) 1995-2001  Microsoft Corporation
  
    Module Name:
    
    hwprof.c
      
    Abstract:
        
    This module contains the dialog box procedure for the Hardware Profiles
    Dialog Box in the System Applet.
          
    Author:
            
    Paula Tomlinson (paulat) 8-22-1995
              
    Environment:
                
    User mode only.
                  
    Revision History:
                    
    22-Aug-1995     paulat
                      
    Creation and initial implementation.
                        
    21-Jan-1999     jamesca
                          
    Added handling for hardware profile aliases and hardware-detected
    profile attributes.
                            
--*/


//
// include files
//

#include "sysdm.h"
#include <stdlib.h>
#include <usp10.h>
#include <dbt.h>

//
// private types and definitions
//

#define MAX_PROFILES             9999
#define MAX_ALIASES              9999
#define MAX_FRIENDLYNAME_LEN     80
#define MAX_PROFILEID_LEN        5
#define MAX_DOCKID_LEN           128
#define MAX_SERIALNUM_LEN        128

#define MAX_USER_WAIT            500
#define MIN_USER_WAIT            0
#define DEFAULT_USER_WAIT        30

#define MAX_GUID_STRING_LEN      39   // 38 chars + terminating null

typedef struct HWPROFILE_s {
    HWND     hParent;
    ULONG    ulFromProfileID;
    TCHAR    szFromFriendlyName[MAX_FRIENDLYNAME_LEN];
    ULONG    ulToProfileID;
    TCHAR    szToFriendlyName[MAX_FRIENDLYNAME_LEN];
} HWPROFILE, *PHWPROFILE;


typedef struct HWPROF_VALUES_s {
    ULONG    ulAction;
    ULONG    ulProfile;
    ULONG    ulPreferenceOrder;
    ULONG    ulDockState;
    BOOL     bAliasable;
    BOOL     bCloned;
    BOOL     bPortable;
    ULONG    ulCreatedFrom;
    WCHAR    szDockID[MAX_DOCKID_LEN];
    WCHAR    szSerialNumber[MAX_SERIALNUM_LEN];
    WCHAR    szFriendlyName[MAX_FRIENDLYNAME_LEN];
} HWPROF_VALUES, *PHWPROF_VALUES;


typedef struct HWPROF_INFO_s {
    ULONG             ulNumProfiles;
    ULONG             ulActiveProfiles;
    PHWPROF_VALUES    pHwProfValues;
    ULONG             ulSelectedProfile;
    ULONG             ulSelectedProfileIndex;
    BOOL              bPortable;
    BOOL              bHwDetectedPortable;
    ULONG             ulUndockedProfileNameCount;
    ULONG             ulDockedProfileNameCount;
    ULONG             ulUnknownProfileNameCount;
} HWPROF_INFO, *PHWPROF_INFO;


#define HWP_NO_ACTION   0x00000000
#define HWP_DELETE      0x00000001
#define HWP_CREATE      0x00000002
#define HWP_RENAME      0x00000004
#define HWP_REORDER     0x00000008
#define HWP_PROPERTIES  0x00000010
#define HWP_NEWPROFILE  0x00001000

//
// private prototypes
//

BOOL
GetCurrentProfile(
                  PULONG  pulProfile
                  );

BOOL
GetRegProfileCount(
                   PULONG   pulProfiles
                   );

BOOL
FillProfileList(
                HWND  hDlg
                );

BOOL
IsProfileNameInUse(
                   HWND     hDlg,
                   LPTSTR   pszFriendlyName
                   );

BOOL
CopyHardwareProfile(
                    HWND   hDlg,
                    ULONG_PTR ulIndex,
                    ULONG  ulProfile,
                    LPTSTR szNewFriendlyName
                    );

BOOL
RenameHardwareProfile(
                      HWND   hDlg,
                      ULONG_PTR ulIndex,
                      ULONG  ulProfile,
                      LPTSTR szNewFriendlyName
                      );

BOOL
DeleteHardwareProfile(
                      HWND   hDlg,
                      ULONG_PTR ulIndex
                      );

BOOL
GetUserWaitInterval(
                    PULONG   pulWait
                    );

BOOL
SetUserWaitInterval(
                    ULONG   ulWait
                    );

BOOL
GetFreeProfileID(
                 PHWPROF_INFO   pInfo,
                 PULONG         pulProfile
                 );

ULONG
GetOriginalProfile(
                   PHWPROF_INFO  pInfo,
                   ULONG         ulProfile,
                   ULONG         ulBufferIndex
                   );

BOOL
DeleteRank(
           PHWPROF_INFO   pInfo,
           ULONG          ulRank
           );

BOOL
FlushProfileChanges(
                    HWND hDlg,
                    HWND hList
                    );

BOOL
WriteProfileInfo(
                 PHWPROF_VALUES pProfValues
                 );

BOOL
RemoveNewProfiles(
                  PHWPROF_INFO   pInfo
                  );

BOOL
SwapPreferenceOrder(
                    HWND  hDlg,
                    HWND  hList,
                    ULONG_PTR ulIndex1,
                    ULONG_PTR ulIndex2
                    );

BOOL
DeleteProfileDependentTree(
                           ULONG ulProfile
                           );

BOOL
CopyAliasEntries(
                 ULONG ulSrcProfile,
                 ULONG ulDestProfile
                 );

BOOL
DeleteAliasEntries(
                   ULONG ulProfile
                   );

BOOL
CopyAliasEntryType(
                   ULONG  ulSrcProfile,
                   ULONG  ulDestProfile,
                   LPWSTR szSubKeyName
                   );

BOOL
DeleteAliasEntryType(
                     ULONG  ulProfile,
                     LPWSTR szSubKeyName
                     );

VOID
AdjustProfileTypeCounter(
                         PHWPROF_INFO   pInfo,
                         ULONG          ulDockState,
                         BOOL           bIncrement
                         );

BOOL
StripCurrentTag(
                LPTSTR   szOriginalName,
                ULONG    ulProfile,
                ULONG    ulCurrentProfile
                );

BOOL
AppendCurrentTag(
                 LPTSTR   szTaggedName,
                 UINT     cchTaggedName,
                 LPCTSTR  szOriginalName,
                 ULONG    ulProfile,
                 ULONG    ulCurrentProfile
                 );

BOOL
CreateHwProfileFriendlyName(
                            IN  HWND    hDlg,
                            IN  ULONG   ulDockState,
                            OUT LPTSTR  szFriendlyName,
                            IN  UINT    cchFriendlyName
                            );

VOID
DisplayPrivateMessage(
                      HWND  hDlg,
                      UINT  uiPrivateError
                      );

VOID
DisplaySystemMessage(
                     HWND  hWnd,
                     UINT  uiSystemError
                     );

BOOL
UpdateOrderButtonState(
                       HWND  hDlg
                       );

BOOL
DisplayProperties(
                  IN HWND           hOwnerDlg,
                  IN PHWPROF_INFO   pProfValues
                  );

typedef BOOL (CALLBACK FAR * LPFNADDPROPSHEETPAGE)(HPROPSHEETPAGE, LPARAM);


//
// global strings
//
WCHAR pszErrorCaption[MAX_PATH];
WCHAR pszRegDefaultFriendlyName[MAX_FRIENDLYNAME_LEN];
WCHAR pszCurrentTag[64];
WCHAR pszUnavailable[64];
WCHAR pszDocked[64];
WCHAR pszUndocked[64];
WCHAR pszUnknown[64];

WCHAR pszRegIDConfigDB[] = TEXT("System\\CurrentControlSet\\Control\\IDConfigDB");
WCHAR pszRegHwProfiles[] = TEXT("System\\CurrentControlSet\\Hardware Profiles");
WCHAR pszRegKnownDockingStates[] =  TEXT("Hardware Profiles");
WCHAR pszRegCurrentDockInfo[] =     TEXT("CurrentDockInfo");
WCHAR pszRegDockingState[] =        TEXT("DockingState");
WCHAR pszRegAlias[] =               TEXT("Alias");
WCHAR pszRegAcpiAlias[] =           TEXT("AcpiAlias");
WCHAR pszRegProfileNumber[] =       TEXT("ProfileNumber");
WCHAR pszRegCurrentConfig[] =       TEXT("CurrentConfig");
WCHAR pszRegUserWaitInterval[] =    TEXT("UserWaitInterval");
WCHAR pszRegFriendlyName[] =        TEXT("FriendlyName");
WCHAR pszRegPristine[] =            TEXT("Pristine");
WCHAR pszRegHwProfileGuid[] =       TEXT("HwProfileGuid");
WCHAR pszRegPreferenceOrder[] =     TEXT("PreferenceOrder");
WCHAR pszRegDockState[] =           TEXT("DockState");
WCHAR pszRegAliasable[] =           TEXT("Aliasable");
WCHAR pszRegCloned[] =              TEXT("Cloned");
WCHAR pszRegIsPortable[] =          TEXT("IsPortable");
WCHAR pszRegDockID[] =              TEXT("DockID");
WCHAR pszRegSerialNumber[] =        TEXT("SerialNumber");
WCHAR pszRegAcpiSerialNumber[] =    TEXT("AcpiSerialNumber");
WCHAR pszRegPropertyProviders[] =   TEXT("PropertyProviders");
WCHAR pszRegDocked[] =              TEXT("Docked");
WCHAR pszRegUndocked[] =            TEXT("Undocked");
WCHAR pszRegUnknown[] =             TEXT("Unknown");

//
// global mutex for synchronization
//
WCHAR  pszNamedMutex[] =            TEXT("System-HardwareProfiles-PLT");
HANDLE g_hMutex = NULL;

//
// global info for property sheet extensions
//
#define MAX_EXTENSION_PROVIDERS  32
HMODULE        hLibs[MAX_EXTENSION_PROVIDERS];
HPROPSHEETPAGE hPages[MAX_EXTENSION_PROVIDERS];
ULONG          ulNumPages = 0;
BOOL           bAdmin = FALSE;


static int HwProfileHelpIds[] = {
    IDD_HWP_PROFILES,        (IDH_HWPROFILE + IDD_HWP_PROFILES),
        IDD_HWP_PROPERTIES,      (IDH_HWPROFILE + IDD_HWP_PROPERTIES),
        IDD_HWP_COPY,            (IDH_HWPROFILE + IDD_HWP_COPY),
        IDD_HWP_RENAME,          (IDH_HWPROFILE + IDD_HWP_RENAME),
        IDD_HWP_DELETE,          (IDH_HWPROFILE + IDD_HWP_DELETE),
        IDD_HWP_ST_MULTIPLE,     (IDH_HWPROFILE + IDD_HWP_ST_MULTIPLE),
        IDD_HWP_WAITFOREVER,     (IDH_HWPROFILE + IDD_HWP_WAITFOREVER),
        IDD_HWP_WAITUSER,        (IDH_HWPROFILE + IDD_HWP_WAITUSER),
        IDD_HWP_SECONDS,         (IDH_HWPROFILE + IDD_HWP_SECONDS),
        IDD_HWP_SECSCROLL,       (IDH_HWPROFILE + IDD_HWP_SECSCROLL),
        IDD_HWP_COPYTO,          (IDH_HWPROFILE + IDD_HWP_COPYTO),
        IDD_HWP_COPYTO_CAPTION,  (IDH_HWPROFILE + IDD_HWP_COPYTO),
        IDD_HWP_COPYFROM,        (IDH_HWPROFILE + IDD_HWP_COPYFROM),
        IDD_HWP_ST_DOCKID,       (IDH_HWPROFILE + IDD_HWP_ST_DOCKID),
        IDD_HWP_ST_SERIALNUM,    (IDH_HWPROFILE + IDD_HWP_ST_SERIALNUM),
        IDD_HWP_DOCKID,          (IDH_HWPROFILE + IDD_HWP_DOCKID),
        IDD_HWP_SERIALNUM,       (IDH_HWPROFILE + IDD_HWP_SERIALNUM),
        IDD_HWP_PORTABLE,        (IDH_HWPROFILE + IDD_HWP_PORTABLE),
        IDD_HWP_ALIASABLE,       IDH_HWP_PROPERTIES_SELECTION_CHECKBOX,
        IDD_HWP_UNKNOWN,         (IDH_HWPROFILE + IDD_HWP_UNKNOWN),
        IDD_HWP_DOCKED,          (IDH_HWPROFILE + IDD_HWP_DOCKED),
        IDD_HWP_UNDOCKED,        (IDH_HWPROFILE + IDD_HWP_UNDOCKED),
        IDD_HWP_ST_PROFILE,      (IDH_HWPROFILE + IDD_HWP_ST_PROFILE),
        IDD_HWP_ORDERUP,         (IDH_HWPROFILE + IDD_HWP_ORDERUP),
        IDD_HWP_ORDERDOWN,       (IDH_HWPROFILE + IDD_HWP_ORDERDOWN),
        IDD_HWP_RENAMEFROM,      (IDH_HWPROFILE + IDD_HWP_RENAMEFROM),
        IDD_HWP_RENAMETO,        (IDH_HWPROFILE + IDD_HWP_RENAMETO),
        IDD_HWP_RENAMETO_CAPTION,(IDH_HWPROFILE + IDD_HWP_RENAMETO),
        IDD_HWP_WAITUSER_TEXT_1, (IDH_HWPROFILE + IDD_HWP_SECSCROLL),
        IDD_HWP_UNUSED_1,        -1,
        IDD_HWP_UNUSED_2,        -1,
        IDD_HWP_UNUSED_3,        -1,
        IDD_HWP_UNUSED_4,        -1,
        IDD_HWP_UNUSED_5,        -1,
        IDD_HWP_UNUSED_6,        -1,
        0, 0
};


/**-------------------------------------------------------------------------**/
INT_PTR
APIENTRY
HardwareProfilesDlg(
                    HWND    hDlg,
                    UINT    uMessage,
                    WPARAM  wParam,
                    LPARAM  lParam
                    )
                    
{
    BOOL           Status;
    ULONG          ulCurrentProfile, ulSelectedProfile,
        ulWait, ulBufferIndex = 0;
    ULONG_PTR      ulIndex;
    LONG           lValue;
    TCHAR          szProfileName[MAX_PATH], szName[MAX_PATH];
    HWND           hList;
    int            nValue;
    HWPROFILE      HwSelectedProfile;
    LPNM_UPDOWN    pUDData;
    PHWPROF_INFO   pInfo;
    HICON          hIcon;
    
    
    switch (uMessage)
    {
    case WM_INITDIALOG:
        bAdmin = IsUserAnAdmin();
        
        //
        // attempt to claim the named mutex and lock other instances of
        // this dialog box out
        //
        g_hMutex = CreateMutex(NULL, TRUE, pszNamedMutex);
        
        if (g_hMutex == NULL) {
            
            if (GetLastError() == ERROR_ALREADY_EXISTS) {
                DisplayPrivateMessage(hDlg, HWP_ERROR_IN_USE);
            } else {
                DisplaySystemMessage(hDlg, GetLastError());
            }
            
            EndDialog(hDlg, FALSE);
            return FALSE;
        }
        
        //
        // load some global strings
        //
        LoadString(hInstance, HWP_CURRENT_TAG, pszCurrentTag, 64);
        LoadString(hInstance, HWP_UNAVAILABLE, pszUnavailable, 64);
        LoadString(hInstance, HWP_UNKNOWN_PROFILE,  pszUnknown, 64);
        LoadString(hInstance, HWP_DOCKED_PROFILE,   pszDocked, 64);
        LoadString(hInstance, HWP_UNDOCKED_PROFILE, pszUndocked, 64);
        LoadString(hInstance, HWP_ERROR_CAPTION, pszErrorCaption, MAX_PATH);
        LoadString(hInstance, HWP_DEF_FRIENDLYNAME, pszRegDefaultFriendlyName,
            MAX_FRIENDLYNAME_LEN);
        
        //
        // fill the profiles listbox with all installed profiles,
        // this will also select the current profile
        //
        if (!FillProfileList(hDlg)) {
            EndDialog(hDlg, FALSE);
            return FALSE;
        }
        
        pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
        
        //
        // place the icons on the up and down selection buttons
        //
        SendDlgItemMessage(
            hDlg, IDD_HWP_ORDERUP, BM_SETIMAGE, (WPARAM)IMAGE_ICON,
            (LPARAM)LoadIcon(hInstance, MAKEINTRESOURCE(UP_ICON)));
        
        SendDlgItemMessage(
            hDlg, IDD_HWP_ORDERDOWN, BM_SETIMAGE, (WPARAM)IMAGE_ICON,
            (LPARAM)LoadIcon(hInstance, MAKEINTRESOURCE(DOWN_ICON)));
        
        //
        // update button enable/disable states
        //
        UpdateOrderButtonState(hDlg);
        
        //
        // disable Delete for the current profile
        //
        EnableWindow(GetDlgItem(hDlg, IDD_HWP_DELETE), FALSE);
        
        //
        // disable copy if we're already at the max number of profiles
        // (including the pristine profile)
        //
        if ((pInfo->ulNumProfiles+1) > MAX_PROFILES) {
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_COPY), FALSE);
        }
        
        //
        // initialize the user wait setting
        //
        SendDlgItemMessage(hDlg, IDD_HWP_SECSCROLL, UDM_SETBASE, 10, 0);
        SendDlgItemMessage(hDlg, IDD_HWP_SECSCROLL, UDM_SETRANGE, 0,
            MAKELONG((SHORT)MAX_USER_WAIT, (SHORT)MIN_USER_WAIT));
        SendDlgItemMessage(hDlg, IDD_HWP_SECONDS, EM_LIMITTEXT, 3, 0L);
        
        GetUserWaitInterval(&ulWait);
        
        if (ulWait == 0xFFFFFFFF) {
            CheckRadioButton(hDlg, IDD_HWP_WAITFOREVER, IDD_HWP_WAITUSER,
                IDD_HWP_WAITFOREVER);
            SendDlgItemMessage(hDlg, IDD_HWP_SECSCROLL, UDM_SETPOS, 0,
                DEFAULT_USER_WAIT);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_SECONDS), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_SECSCROLL), FALSE);
        }
        else {
            CheckRadioButton(hDlg, IDD_HWP_WAITFOREVER, IDD_HWP_WAITUSER,
                IDD_HWP_WAITUSER);
            SendDlgItemMessage(hDlg, IDD_HWP_SECSCROLL, UDM_SETPOS, 0, ulWait);
        }
        
        //
        // Disable all actions if user not part of administrators local group
        //
        if (!bAdmin) {
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_ORDERUP),    FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_PROPERTIES), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_COPY),       FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_RENAME),     FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_DELETE),     FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_ORDERDOWN),  FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_WAITFOREVER),FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_WAITUSER),   FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_WAITUSER_TEXT_1), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_SECONDS),    FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_SECSCROLL),  FALSE);
        }
        return 0;
        
        
      case WM_HELP:
          WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, HELP_FILE,
              HELP_WM_HELP, (DWORD_PTR)(LPTSTR)HwProfileHelpIds);
          break;
          
      case WM_CONTEXTMENU:
          WinHelp((HWND)wParam, HELP_FILE, HELP_CONTEXTMENU,
              (DWORD_PTR)(LPTSTR)HwProfileHelpIds);
          break;
          
      case WM_DESTROY:
          //
          // only free the buffer if we've already initialized
          //
          pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
          
          if (pInfo) {
              LocalFree((HLOCAL)pInfo->pHwProfValues);
              LocalFree((HLOCAL)pInfo);
              
              hIcon = (HICON)SendDlgItemMessage(
                  hDlg, IDD_HWP_ORDERUP, BM_GETIMAGE, 0, 0);
              if (hIcon) {
                  DeleteObject(hIcon);
              }
              
              hIcon = (HICON)SendDlgItemMessage(
                  hDlg, IDD_HWP_ORDERDOWN, BM_GETIMAGE, 0, 0);
              if (hIcon) {
                  DeleteObject(hIcon);
              }
          }
          break;
          
      case WM_DEVICECHANGE:
          //
          // If a hardware profile change event takes place while the dialog is
          // up, just dismiss the dialog because things have changed.
          //
          if (wParam == DBT_CONFIGCHANGED) {
              EndDialog(hDlg, FALSE);
              return FALSE;
          }
          break;
          
      case WM_COMMAND:
          {
              switch (LOWORD(wParam))
              {
              case IDOK:
                  if (bAdmin) {
                      //
                      // save the user wait interval in the registry
                      //
                      if (IsDlgButtonChecked(hDlg, IDD_HWP_WAITFOREVER)) {
                          ulWait = 0xFFFFFFFF;
                      }
                      else {
                          ulWait = GetDlgItemInt(hDlg, IDD_HWP_SECONDS,
                              &Status, FALSE);
                          if (!Status  ||  ulWait > MAX_USER_WAIT) {
                              TCHAR szCaption[MAX_PATH];
                              TCHAR szMsg[MAX_PATH];
                              
                              LoadString(hInstance, HWP_ERROR_CAPTION, szCaption, MAX_PATH);
                              LoadString(hInstance, HWP_INVALID_WAIT, szMsg, MAX_PATH);
                              
                              MessageBox(hDlg, szMsg, szCaption,
                                  MB_OK | MB_ICONEXCLAMATION);
                              
                              SetFocus(GetDlgItem(hDlg, IDD_HWP_SECONDS));
                              
                              return(TRUE);
                          }
                      }
                      SetUserWaitInterval(ulWait);
                      
                      //
                      // flush the pending changes in profile buffer
                      //
                      hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);
                      FlushProfileChanges(hDlg, hList);
                  }
                  EndDialog(hDlg, 0);
                  break;
                  
              case IDCANCEL:
                  pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
                  
                  if (pInfo) {
                      //
                      // If profile modifications have already been commited from
                      // within the Property Sheet, that's okay. But if accessing
                      // Properties caused any profiles to be created then they
                      // should be removed now since the user is effectively
                      // cancelling that creation now by cancelling from the main
                      // Hardware Profiles dialog.
                      //
                      if (bAdmin) {
                          RemoveNewProfiles(pInfo);
                      }
                  }
                  SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_NOERROR);
                  EndDialog(hDlg, 0);
                  break;
                  
              case IDD_HWP_ORDERUP:
                  //
                  // move selected profile "up" in preference order
                  //
                  hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);
                  
                  ulIndex = SendMessage(hList, LB_GETCURSEL, 0, 0);
                  if (ulIndex == LB_ERR) {
                      break;
                  }
                  
                  pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
                  
                  //
                  // if we're not already at the top, swap preferences
                  //
                  if (ulIndex > 0) {
                      SwapPreferenceOrder(hDlg, hList, ulIndex, ulIndex-1);
                      UpdateOrderButtonState(hDlg);
                      PropSheet_Changed(GetParent(hDlg), hDlg);
                  }
                  break;
                  
                  
              case IDD_HWP_ORDERDOWN:
                  //
                  // move selected profile "down" in preference order
                  //
                  hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);
                  
                  ulIndex = SendMessage(hList, LB_GETCURSEL, 0, 0);
                  if (ulIndex == LB_ERR) {
                      break;
                  }
                  
                  pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
                  
                  //
                  // if we're not already at the bottom, swap preferences
                  //
                  if (ulIndex < pInfo->ulNumProfiles-1) {
                      SwapPreferenceOrder(hDlg, hList, ulIndex, ulIndex+1);
                      UpdateOrderButtonState(hDlg);
                      PropSheet_Changed(GetParent(hDlg), hDlg);
                  }
                  break;
                  
                  
              case IDD_HWP_PROFILES:
                  //
                  // selection changed, enable/disable Delete button based
                  // on whether it's the current config that is selected
                  //
                  
                  if (bAdmin) {
                      
                      if (HIWORD(wParam) == LBN_DBLCLK) {
                          SendMessage(hDlg, WM_COMMAND, MAKELONG(IDD_HWP_PROPERTIES,0), 0);
                      }
                      else if (HIWORD(wParam) == LBN_SELCHANGE) {
                          
                          if (!GetCurrentProfile(&ulCurrentProfile)) {
                              break;
                          }
                          
                          if ((ulIndex = SendMessage((HWND)lParam,
                              LB_GETCURSEL, 0, 0)) == LB_ERR) {
                              break;
                          }
                          
                          if ((lValue = (LONG)SendMessage((HWND)lParam, LB_GETITEMDATA,
                              ulIndex, 0)) == LB_ERR) {
                              break;
                          }
                          
                          if ((ULONG)lValue == ulCurrentProfile) {
                              EnableWindow(GetDlgItem(hDlg, IDD_HWP_DELETE), FALSE);
                          }
                          else {
                              EnableWindow(GetDlgItem(hDlg, IDD_HWP_DELETE), TRUE);
                          }
                          
                          
                          //
                          // update button enable/disable states
                          //
                          UpdateOrderButtonState(hDlg);
                      }
                  }
                  break;
                  
                  
              case IDD_HWP_WAITFOREVER:
                  //
                  // if user chooses wait forever, disable the seconds control
                  //
                  if (HIWORD(wParam) == BN_CLICKED) {
                      EnableWindow(GetDlgItem(hDlg, IDD_HWP_SECONDS), FALSE);
                      EnableWindow(GetDlgItem(hDlg, IDD_HWP_SECSCROLL), FALSE);
                      PropSheet_Changed(GetParent(hDlg), hDlg);
                  }
                  break;
                  
                  
              case IDD_HWP_WAITUSER:
                  //
                  // if user chooses a wait interval, reenable seconds control
                  //
                  if (HIWORD(wParam) == BN_CLICKED) {
                      EnableWindow(GetDlgItem(hDlg, IDD_HWP_SECONDS), TRUE);
                      EnableWindow(GetDlgItem(hDlg, IDD_HWP_SECSCROLL), TRUE);
                      PropSheet_Changed(GetParent(hDlg), hDlg);
                  }
                  break;
                  
                  
              case IDD_HWP_PROPERTIES:
                  //
                  // retrieve the profile buffer
                  //
                  pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
                  
                  //
                  // get the selected profile
                  //
                  hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);
                  
                  ulIndex = SendMessage(hList, LB_GETCURSEL, 0, 0);
                  if (ulIndex == LB_ERR) {
                      break;
                  }
                  
                  //
                  // find the profile entry in the buffer that matches the selection
                  //
                  hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);
                  ulSelectedProfile = (ULONG)SendMessage(hList, LB_GETITEMDATA, ulIndex, 0);
                  
                  while (ulBufferIndex < pInfo->ulNumProfiles) {
                      if (pInfo->pHwProfValues[ulBufferIndex].ulProfile == ulSelectedProfile) {
                          break;
                      }
                      ulBufferIndex++;
                  }
                  
                  //
                  // commit the changes for this profile before calling Properties
                  //
                  WriteProfileInfo(&pInfo->pHwProfValues[ulBufferIndex]);
                  
                  //
                  // pass the HWPROF_VALUES struct for the selected profile
                  // to the property sheet page when it's created. The
                  // property sheet may update some of these fields and
                  // may also commit changes for this profile to the registry.
                  //
                  pInfo->ulSelectedProfileIndex = ulBufferIndex;
                  pInfo->ulSelectedProfile = (ULONG)SendMessage(hList, LB_GETITEMDATA,
                      ulIndex, 0);
                  
                  DisplayProperties(hDlg, pInfo);
                  //DisplayProperties(hDlg, &pInfo->pHwProfValues[ulBufferIndex]);
                  break;
                  
                  
              case IDD_HWP_COPY:               
                  //
                  // retrieve the profile buffer
                  //
                  pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
                  
                  //
                  // get the selected profile, this is the "From" selection
                  //
                  hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);
                  
                  ulIndex = SendMessage(hList, LB_GETCURSEL, 0, 0);
                  if (ulIndex == LB_ERR) {
                      break;
                  }

                  if (!SafeGetListBoxText(hList, (UINT)ulIndex, 
                                          HwSelectedProfile.szFromFriendlyName,
                                          ARRAYSIZE(HwSelectedProfile.szFromFriendlyName)))
                  {
                      break;
                  }

                  HwSelectedProfile.ulFromProfileID =
                      (ULONG)SendMessage(hList, LB_GETITEMDATA, ulIndex, 0);
                  
                  //
                  // find the profile entry in the buffer that matches the selection
                  //
                  ulBufferIndex = 0;
                  while (ulBufferIndex < pInfo->ulNumProfiles) {
                      if (pInfo->pHwProfValues[ulBufferIndex].ulProfile == HwSelectedProfile.ulFromProfileID) {
                          break;
                      }
                      ulBufferIndex++;
                  }
                  
                  
                  //
                  // determine the next suggested name for the given profile
                  //
                  if (!CreateHwProfileFriendlyName(hDlg,
                                                   pInfo->pHwProfValues[ulBufferIndex].ulDockState,
                                                   HwSelectedProfile.szToFriendlyName,
                                                   ARRAYSIZE(HwSelectedProfile.szToFriendlyName)))
                  {
                      break;
                  }
                  
                  //
                  // pass selected profile info to copy profile dialog box
                  //
                  
                  HwSelectedProfile.hParent = hDlg;
                  
                  if (!DialogBoxParam(hInstance,
                      MAKEINTRESOURCE(DLG_HWP_COPY), hDlg,
                      CopyProfileDlg,
                      (LPARAM)&HwSelectedProfile)) {
                      //
                      // if returns FALSE, either user canceled or no work
                      // required
                      //
                      break;
                  }
                  
                  //
                  // clone the profile in the in-memory profile buffer
                  // and update the display
                  //
                  CopyHardwareProfile(
                      hDlg,
                      ulIndex,
                      HwSelectedProfile.ulFromProfileID,
                      HwSelectedProfile.szToFriendlyName);
                  
                  UpdateOrderButtonState(hDlg);
                  PropSheet_Changed(GetParent(hDlg), hDlg);
                  break;
                  
                  
              case IDD_HWP_RENAME:
                  //
                  // get the selected profile
                  //
                  hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);
                  
                  ulIndex = SendMessage(hList, LB_GETCURSEL, 0, 0);
                  if (ulIndex == LB_ERR) {
                      break;
                  }

                  if (!SafeGetListBoxText(hList, (UINT)ulIndex, 
                                          HwSelectedProfile.szFromFriendlyName,
                                          ARRAYSIZE(HwSelectedProfile.szFromFriendlyName)))
                  {
                      break;
                  }
                  HwSelectedProfile.ulFromProfileID =
                      (ULONG)SendMessage(hList, LB_GETITEMDATA, ulIndex, 0);
                  
                  //
                  // strip off the current tag if it exists "(Current)"
                  //
                  GetCurrentProfile(&ulCurrentProfile);
                  
                  StripCurrentTag(
                      HwSelectedProfile.szFromFriendlyName,
                      HwSelectedProfile.ulFromProfileID,
                      ulCurrentProfile);
                  
                  // pass selected profile info to rename profile dialog box
                  //
                  
                  HwSelectedProfile.hParent = hDlg;
                  
                  if (!DialogBoxParam(hInstance,
                      MAKEINTRESOURCE(DLG_HWP_RENAME), hDlg,
                      RenameProfileDlg,
                      (LPARAM)&HwSelectedProfile)) {
                      //
                      // if returns FASLE, either user canceled or no work
                      // required (i.e., user chose same name or zero-length
                      // name)
                      //
                      break;
                  }
                  
                  //
                  // rename the profile in the in-memory profile buffer
                  // and update the display
                  //
                  RenameHardwareProfile(
                      hDlg,
                      ulIndex,
                      HwSelectedProfile.ulFromProfileID,
                      HwSelectedProfile.szToFriendlyName);
                  
                  PropSheet_Changed(GetParent(hDlg), hDlg);
                  break;
                  
                  
              case IDD_HWP_DELETE: {
                  
                  TCHAR szCaption[MAX_PATH];
                  TCHAR szMsg[MAX_PATH];
                  TCHAR szMsg1[MAX_PATH];
                  
                  //
                  // get the selected profile
                  //
                  hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);
                  
                  ulIndex = SendMessage(hList, LB_GETCURSEL, 0, 0);
                  if (ulIndex == LB_ERR) {
                      break;
                  }
                  
                  //
                  // confirm that user really wants to delete the profile
                  // (the confirm message has a substitute symbol for
                  // profile name)
                  //
                  if (!SafeGetListBoxText(hList, (UINT)ulIndex, 
                                          szProfileName,
                                          ARRAYSIZE(szProfileName)))
                  {
                      break;
                  }

                  LoadString(hInstance, HWP_CONFIRM_DELETE_CAP, szCaption, MAX_PATH);
                  LoadString(hInstance, HWP_CONFIRM_DELETE, szMsg1, MAX_PATH);
                  
                  StringCchPrintf(szMsg, ARRAYSIZE(szMsg), szMsg1, szProfileName); // display string, truncation ok
                  
                  if (MessageBox(hDlg, szMsg, szCaption,
                      MB_YESNO | MB_ICONQUESTION) != IDNO) 
                  {
                      //
                      // mark the profile as deleted in the in-memory buffer
                      // and update the display
                      //
                      DeleteHardwareProfile(hDlg, ulIndex);
                      
                      UpdateOrderButtonState(hDlg);
                      PropSheet_Changed(GetParent(hDlg), hDlg);
                  }

                  break;
                                   }
                  
              case IDD_HWP_SECONDS:
                  
                  if (HIWORD(wParam) == EN_UPDATE) {
                      PropSheet_Changed(GetParent(hDlg), hDlg);
                  }
                  break;
                  
              default:
                  return FALSE;
          }
          break;
          
       } // case WM_COMMAND...
       
       default:
           return FALSE;
           break;
    }
    
    return TRUE;
    
} // HardwareProfilesDlg



/**-------------------------------------------------------------------------**/
INT_PTR
APIENTRY
CopyProfileDlg(
               HWND    hDlg,
               UINT    uMessage,
               WPARAM  wParam,
               LPARAM  lParam
               )
               
{
    PHWPROFILE  pHwProfile;
    static HIMC himcOrg;
    
    
    switch (uMessage)
    {
    case WM_INITDIALOG:
        //
        // the profile info struct is passed in lparam, save in
        // Window word for thread-safe use in later messages
        //
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pHwProfile = (PHWPROFILE)lParam;
        
        //
        // initialize "To" and "From" fields
        //
        SendDlgItemMessage(hDlg, IDD_HWP_COPYTO, EM_LIMITTEXT,
            MAX_FRIENDLYNAME_LEN-1, 0L);
        SetDlgItemText(hDlg, IDD_HWP_COPYFROM, pHwProfile->szFromFriendlyName);
        SetDlgItemText(hDlg, IDD_HWP_COPYTO, pHwProfile->szToFriendlyName);
        SendDlgItemMessage(hDlg, IDD_HWP_COPYTO, EM_SETSEL, 0, -1);
        SetFocus(GetDlgItem(hDlg, IDD_HWP_COPYTO));
        //
        // Remove any association the window may have with an input context,
        // because we don't allow to use DBCS in H/W profile name.
        //
        himcOrg = ImmAssociateContext(GetDlgItem(hDlg, IDD_HWP_COPYTO), (HIMC)NULL);
        return FALSE;
        
    case WM_DEVICECHANGE:
        //
        // If a hardware profile change event takes place while the dialog is
        // up, just dismiss the dialog because things have changed.
        //
        if (wParam == DBT_CONFIGCHANGED) {
            EndDialog(hDlg, FALSE);
            return FALSE;
        }
        break;
        
    case WM_DESTROY:
        if (himcOrg)
            ImmAssociateContext(GetDlgItem(hDlg, IDD_HWP_COPYTO), himcOrg);
        return FALSE;
        
    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, HELP_FILE,
            HELP_WM_HELP, (DWORD_PTR)(LPTSTR)HwProfileHelpIds);
        break;
        
    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPTSTR)HwProfileHelpIds);
        break;
        
        
    case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
            case IDOK:
                pHwProfile = (PHWPROFILE)GetWindowLongPtr(hDlg, DWLP_USER);
                
                GetDlgItemText(hDlg, IDD_HWP_COPYTO,
                    pHwProfile->szToFriendlyName, MAX_FRIENDLYNAME_LEN);
                
                
                if (pHwProfile->szToFriendlyName == NULL ||
                    *pHwProfile->szToFriendlyName == '\0') {
                    //
                    // accept request to copy to zero-length string but
                    // do nothing (return FALSE from DialogBox call)
                    //
                    EndDialog(hDlg, FALSE);
                    return TRUE;
                }
                
                //
                // Check for duplicates
                //
                
                if (IsProfileNameInUse(pHwProfile->hParent,
                    pHwProfile->szToFriendlyName)) {
                    //
                    // if name already used by a different profile (including
                    // the name of this profile), deny the request, but don't
                    // end the dialog box
                    //
                    DisplayPrivateMessage(hDlg, HWP_ERROR_PROFILE_IN_USE);
                    break;
                }
                
                //
                // Check for complex script names
                //
                if (S_OK == ScriptIsComplex(pHwProfile->szToFriendlyName, lstrlen(pHwProfile->szToFriendlyName), SIC_COMPLEX))
                {
                    DisplayPrivateMessage(hDlg, HWP_ERROR_COMPLEX_SCRIPT);
                    break;
                }                  
                
                //
                // otherwise, we'll accept the name
                //
                EndDialog(hDlg,TRUE);
                break;
                
            case IDCANCEL:
                EndDialog(hDlg,FALSE);
                break;
                
            default:
                return FALSE;
            }
            break;
            
        } // case WM_COMMAND...
        
    default:
        return FALSE;
        break;
    }
    
    return TRUE;
    
} // CopyProfileDlg



/**-------------------------------------------------------------------------**/
INT_PTR
APIENTRY
RenameProfileDlg(
                 HWND    hDlg,
                 UINT    uMessage,
                 WPARAM  wParam,
                 LPARAM  lParam
                 )
                 
{
    PHWPROFILE  pHwProfile;
    ULONG       ulReturn;
    static HIMC himcOrg;
    
    
    switch (uMessage)
    {
    case WM_INITDIALOG:
        //
        // the profile info struct is passed in lparam, save in
        // Window word for thread-safe use in later messages
        //
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pHwProfile = (PHWPROFILE)lParam;
        
        //
        // initialize "To" and "From" fields
        //
        SendDlgItemMessage(hDlg, IDD_HWP_RENAMETO, EM_LIMITTEXT,
            MAX_FRIENDLYNAME_LEN-1, 0L);
        SetDlgItemText(hDlg, IDD_HWP_RENAMEFROM, pHwProfile->szFromFriendlyName);
        SetDlgItemText(hDlg, IDD_HWP_RENAMETO, pHwProfile->szFromFriendlyName);
        SendDlgItemMessage(hDlg, IDD_HWP_RENAMETO, EM_SETSEL, 0, -1);
        SetFocus(GetDlgItem(hDlg, IDD_HWP_RENAMETO));
        //
        // Remove any association the window may have with an input context,
        // because we don't allow to use DBCS in H/W profile name.
        //
        himcOrg = ImmAssociateContext(GetDlgItem(hDlg, IDD_HWP_RENAMETO), (HIMC)NULL);
        return FALSE;
        
        
    case WM_DESTROY:
        if (himcOrg)
            ImmAssociateContext(GetDlgItem(hDlg, IDD_HWP_RENAMETO), himcOrg);
        return FALSE;
        
    case WM_DEVICECHANGE:
        //
        // If a hardware profile change event takes place while the dialog is
        // up, just dismiss the dialog because things have changed.
        //
        if (wParam == DBT_CONFIGCHANGED) {
            EndDialog(hDlg, FALSE);
            return FALSE;
        }
        break;
        
        
    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, HELP_FILE,
            HELP_WM_HELP, (DWORD_PTR)(LPTSTR)HwProfileHelpIds);
        break;
        
    case WM_CONTEXTMENU:
        WinHelp((HWND)wParam, HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR)(LPTSTR)HwProfileHelpIds);
        break;
        
        
    case WM_COMMAND:
        {
            switch (LOWORD(wParam))
            {
            case IDOK:
                pHwProfile = (PHWPROFILE)GetWindowLongPtr(hDlg, DWLP_USER);
                
                ulReturn = GetDlgItemText(hDlg, IDD_HWP_RENAMETO,
                    pHwProfile->szToFriendlyName, MAX_FRIENDLYNAME_LEN);
                
                
                if (pHwProfile->szToFriendlyName == NULL ||
                    *pHwProfile->szToFriendlyName == '\0') {
                    //
                    // accept request to copy to zero-length string but
                    // do nothing (return FALSE from DialogBox call)
                    //
                    EndDialog(hDlg, FALSE);
                    return TRUE;
                }
                
                if (lstrcmpi(pHwProfile->szToFriendlyName,
                    pHwProfile->szFromFriendlyName) == 0) {
                    //
                    // accept request to rename to same name but do
                    // nothing (return FALSE from DialogBox call)
                    //
                    EndDialog(hDlg, FALSE);
                    return TRUE;
                }
                
                //
                // Check for duplicates
                //
                
                if (IsProfileNameInUse(pHwProfile->hParent,
                    pHwProfile->szToFriendlyName)) {
                    //
                    // if name already used by a different profile, deny
                    // the request, but don't end the dialog box
                    //
                    DisplayPrivateMessage(hDlg, HWP_ERROR_PROFILE_IN_USE);
                    break;
                }
                
                //
                // Check for complex script names
                //
                if (S_OK == ScriptIsComplex(pHwProfile->szToFriendlyName, lstrlen(pHwProfile->szToFriendlyName), SIC_COMPLEX))
                {
                    DisplayPrivateMessage(hDlg, HWP_ERROR_COMPLEX_SCRIPT);
                    break;
                }                  
                
                //
                // otherwise, we'll accept the name
                //
                EndDialog(hDlg,TRUE);
                break;
                
            case IDCANCEL:
                EndDialog(hDlg,FALSE);
                break;
                
            default:
                return FALSE;
            }
            break;
            
        } // case WM_COMMAND...
        
    default:
        return FALSE;
        break;
    }
    
    return TRUE;
    
} // RenameProfileDlg




/**-------------------------------------------------------------------------**/
BOOL
GetCurrentProfile(
                  PULONG  pulProfile
                  )
{
    WCHAR    RegStr[MAX_PATH];
    ULONG    ulSize;
    HKEY     hKey;
    
    
    //
    // open the IDConfigDB key
    //
    if (RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, pszRegIDConfigDB, 0,
        KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS) {
        
        DisplaySystemMessage(NULL, ERROR_REGISTRY_CORRUPT);
        return FALSE;
    }
    
    //
    // retrieve the CurrentConfig value
    //
    ulSize = sizeof(*pulProfile);
    if (SHRegGetValue(
        hKey, NULL, pszRegCurrentConfig, SRRF_RT_REG_DWORD, NULL,
        (LPBYTE)pulProfile, &ulSize) != ERROR_SUCCESS) {
        
        RegCloseKey(hKey);
        DisplaySystemMessage(NULL, ERROR_REGISTRY_CORRUPT);
        return FALSE;
    }
    
    RegCloseKey(hKey);
    return TRUE;
    
} // GetCurrentProfile


/**-------------------------------------------------------------------------**/
BOOL
GetRegProfileCount(
                   PULONG   pulProfiles
                   )
{
    WCHAR   RegStr[MAX_PATH];
    HKEY    hKey;
    BOOL    fRet;
    
    
    //
    // open the Known Docking States key
    //
    
    if (FAILED(StringCchPrintf(RegStr, ARRAYSIZE(RegStr), TEXT("%s\\%s"), pszRegIDConfigDB, pszRegKnownDockingStates)))
    {
        *pulProfiles = 0;
        fRet = FALSE;
    }
    else
    {
        if (ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegStr, 
            0, KEY_READ, &hKey))
        {
            *pulProfiles = 0;
            DisplaySystemMessage(NULL, ERROR_REGISTRY_CORRUPT);
            fRet = FALSE;
        }
        else
        {
            //
            // find out the total number of profiles
            //
            if (ERROR_SUCCESS != RegQueryInfoKey(hKey, NULL, NULL, NULL, pulProfiles, 
                NULL, NULL, NULL, NULL, NULL, NULL, NULL))
            {
                *pulProfiles = 0;
                RegCloseKey(hKey);
                DisplaySystemMessage(NULL, ERROR_REGISTRY_CORRUPT);
                fRet = FALSE;
            }
            else
            {
                ASSERT(*pulProfiles > 0);  // The key for the pristine profile should be there, at least.
                *pulProfiles-= 1;          // Don't count the pristine in the number or working profiles.
                
                RegCloseKey(hKey);
                fRet = TRUE;
            }
        }
    }
    
    return fRet;
    
} // GetRegProfileCount

/**-------------------------------------------------------------------------**/
BOOL
FillProfileList(
                HWND  hDlg
                )
                
{
    HWND           hList;
    ULONG          ulCurrentProfile, ulCurrentIndex;
    ULONG          ulIndex=0, ulSize=0;
    ULONG          enumIndex = 0, ulProfileID=0;
    ULONG          ulCurrentDockingState = 0;
    ULONG          ulDockID = 0, ulSerialNumber=0;
    HKEY           hKey = NULL, hCfgKey = NULL;
    HKEY           hCurrent = NULL;
    WCHAR          RegStr[MAX_PATH], szName[MAX_PATH];
    ULONG          RegStatus = ERROR_SUCCESS;
    WCHAR          szFriendlyName[MAX_FRIENDLYNAME_LEN];
    WCHAR          szProfile[MAX_PROFILEID_LEN];
    PHWPROF_INFO   pInfo;
    LRESULT        lReturn;
    REGSAM         sam;
    
    
    //
    // retrieve a handle to the listbox window
    //
    hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);
    
    //
    // retrieve the id of the current profile
    //
    if (!GetCurrentProfile(&ulCurrentProfile)) {
        DisplaySystemMessage(hDlg, ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    
    //
    // allocate a buffer for the main profile info struct
    //
    pInfo = (PHWPROF_INFO) LocalAlloc(LPTR, sizeof(HWPROF_INFO));
    
    if (pInfo == NULL) {
        DisplaySystemMessage(hDlg, ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    
    //
    // save the number of profiles currently in the registry
    //
    if (!GetRegProfileCount(&(pInfo->ulNumProfiles))) {
        LocalFree((HLOCAL)pInfo);
        return FALSE;
    }
    
    pInfo->ulActiveProfiles = pInfo->ulNumProfiles;
    
    //
    // Initialize the hardware detected portable flag
    //
    pInfo->bHwDetectedPortable = FALSE;
    
    //
    // allocate a buffer to hold all the profile values
    //
    pInfo->pHwProfValues = (PHWPROF_VALUES) LocalAlloc(LPTR, sizeof(HWPROF_VALUES) * pInfo->ulNumProfiles);
    
    if (pInfo->pHwProfValues == NULL) {
        LocalFree((HLOCAL)pInfo);
        return FALSE;
    }
    
    SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pInfo);
    
    //
    // clear the listbox and turn redraw off
    //
    SendMessage(hList, LB_RESETCONTENT, 0, 0);
    SendMessage(hList, WM_SETREDRAW, (WPARAM)FALSE, 0);
    
    //
    // open the Hardware Profiles key
    //
    if (FAILED(StringCchPrintf(RegStr, ARRAYSIZE(RegStr), 
                               TEXT("%s\\%s"), pszRegIDConfigDB, pszRegKnownDockingStates)))
    {
        LocalFree((HLOCAL)pInfo->pHwProfValues);
        LocalFree((HLOCAL)pInfo);
        return FALSE;
    }
    
    if (RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, RegStr, 0,
        KEY_QUERY_VALUE | KEY_ENUMERATE_SUB_KEYS,
        &hKey) != ERROR_SUCCESS) {
        
        DisplaySystemMessage(hDlg, ERROR_REGISTRY_CORRUPT);
        LocalFree((HLOCAL)pInfo->pHwProfValues);
        LocalFree((HLOCAL)pInfo);
        return FALSE;
    }
    
    //
    // read the values for the name generating counters
    //
    ulSize = sizeof(pInfo->ulUndockedProfileNameCount);
    
    if (SHRegGetValue(hKey, NULL, pszRegUndocked, SRRF_RT_REG_DWORD, NULL,
        (LPBYTE)&pInfo->ulUndockedProfileNameCount, &ulSize)) {
        pInfo->ulUnknownProfileNameCount = 0;
    }
    
    ulSize = sizeof(pInfo->ulDockedProfileNameCount);

    if (SHRegGetValue(hKey, NULL, pszRegDocked, SRRF_RT_REG_DWORD, NULL,
        (LPBYTE)&pInfo->ulDockedProfileNameCount, &ulSize)) {
        pInfo->ulUnknownProfileNameCount = 0;
    }
    
    ulSize = sizeof(pInfo->ulUnknownProfileNameCount);

    if (SHRegGetValue(hKey, NULL, pszRegUnknown, SRRF_RT_REG_DWORD, NULL,
        (LPBYTE)&pInfo->ulUnknownProfileNameCount, &ulSize)) {
        pInfo->ulUnknownProfileNameCount = 0;
    }
    
    //
    // pad the list box with a blank entry for each profile
    // (this facilitates adding the profiles in rank order
    //
    for (ulIndex = 0; ulIndex < pInfo->ulNumProfiles; ulIndex++) {
        SendMessage(hList, LB_ADDSTRING, 0, (LPARAM)(LPCTSTR)TEXT(" "));
    }
    
    //
    // enumerate each of the existing hardware profiles
    //
    ulIndex = 0;
    enumIndex = 0;
    while (RegStatus != ERROR_NO_MORE_ITEMS) {
        
        //
        // enumerate the profile key
        //
        ulSize = MAX_PROFILEID_LEN;
        RegStatus = RegEnumKeyEx(
            hKey, enumIndex, szProfile, &ulSize, NULL, NULL, NULL, NULL);
        
        if (RegStatus == ERROR_SUCCESS) {
            //
            // open the enumerated profile key
            //
            if (bAdmin) {
                sam = KEY_QUERY_VALUE | KEY_SET_VALUE;
            } 
            else 
            {
                sam = KEY_QUERY_VALUE;
            }
            
            if (RegOpenKeyEx(
                hKey, szProfile, 0, sam, &hCfgKey) != ERROR_SUCCESS) {
                
                RegCloseKey(hKey);
                LocalFree((HLOCAL)pInfo->pHwProfValues);
                LocalFree((HLOCAL)pInfo);
                if (bAdmin) {
                    DisplaySystemMessage(hDlg, ERROR_REGISTRY_CORRUPT);
                    return FALSE;
                }
                else {
                    return TRUE;
                }
            }
            
            //
            // if this is the Pristine profile, ignore it, and move on to the next.
            //
            
            ulProfileID = _wtoi(szProfile);
            
            if (!ulProfileID) {
                enumIndex++;
                RegCloseKey(hCfgKey);
                continue;
            }
            
            //----------------------------------------------------------
            // retrieve the profile registry info, save in buffer
            //----------------------------------------------------------
            
            //
            // aliasable
            //
            ulSize = sizeof(pInfo->pHwProfValues[ulIndex].bAliasable);
            if (SHRegGetValue(hCfgKey, NULL, pszRegAliasable, SRRF_RT_REG_DWORD, NULL,
                              (LPBYTE)&pInfo->pHwProfValues[ulIndex].bAliasable,
                               &ulSize) != ERROR_SUCCESS) 
            {
                pInfo->pHwProfValues[ulIndex].bAliasable = TRUE;
            }
            
            //
            // cloned
            //
            ulSize = sizeof(pInfo->pHwProfValues[ulIndex].bCloned);
            if (SHRegGetValue(hCfgKey, NULL, pszRegCloned, SRRF_RT_REG_DWORD, NULL,
                              (LPBYTE)&pInfo->pHwProfValues[ulIndex].bCloned,
                               &ulSize) != ERROR_SUCCESS) 
            {
                pInfo->pHwProfValues[ulIndex].bCloned = FALSE;
            }
            
            //
            // friendly name
            //
            ulSize = sizeof(pInfo->pHwProfValues[ulIndex].szFriendlyName);
            if (SHRegGetValue(hCfgKey, NULL, pszRegFriendlyName, SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND, NULL,
                              (LPBYTE)&pInfo->pHwProfValues[ulIndex].szFriendlyName,
                              &ulSize) != ERROR_SUCCESS) 
            {                
                //
                // if no FriendlyName then write out and use a default
                // value name (for compatibility with Win95)
                //
                if (bAdmin) {
                    
                    StringCchCopy(pInfo->pHwProfValues[ulIndex].szFriendlyName, 
                                  ARRAYSIZE(pInfo->pHwProfValues[ulIndex].szFriendlyName),
                                  pszRegDefaultFriendlyName); // truncation ok, this is for display ultimately
                    
                    RegSetValueEx(
                        hCfgKey, pszRegFriendlyName, 0, REG_SZ,
                        (LPBYTE)pszRegDefaultFriendlyName,
                        (lstrlen(pszRegDefaultFriendlyName)+1) * sizeof(TCHAR));
                }
            }
            
            //
            // preference order ranking
            //
            ulSize = sizeof(pInfo->pHwProfValues[ulIndex].ulPreferenceOrder);
            if (SHRegGetValue(hCfgKey, NULL, pszRegPreferenceOrder, SRRF_RT_REG_DWORD, NULL,
                              (LPBYTE)&pInfo->pHwProfValues[ulIndex].ulPreferenceOrder,
                              &ulSize) != ERROR_SUCCESS) 
            {                
                // FEATURE - rerank all profiles if this happens
            }
            
            //
            // dock state
            //
            ulSize = sizeof(pInfo->pHwProfValues[ulIndex].ulDockState);
            if (SHRegGetValue(hCfgKey, NULL, pszRegDockState, SRRF_RT_REG_DWORD, NULL,
                              (LPBYTE)&pInfo->pHwProfValues[ulIndex].ulDockState,
                              &ulSize) != ERROR_SUCCESS) 
            {                
                pInfo->pHwProfValues[ulIndex].ulDockState =
                    DOCKINFO_USER_SUPPLIED | DOCKINFO_DOCKED | DOCKINFO_UNDOCKED;
            }
            
            //
            // portable computer flag  - this is obsolete info, just save the current
            // setting if it exists and then delete it (might need the original
            // setting later)
            //
            ulSize = sizeof(pInfo->pHwProfValues[ulIndex].bPortable);
            if (SHRegGetValue(hCfgKey, NULL, pszRegIsPortable, SRRF_RT_REG_DWORD, NULL,
                                (LPBYTE)&pInfo->pHwProfValues[ulIndex].bPortable,
                                &ulSize) != ERROR_SUCCESS) {
                
                pInfo->pHwProfValues[ulIndex].bPortable = FALSE;
            }
            
            RegDeleteValue(hCfgKey, pszRegIsPortable);
            
            pInfo->pHwProfValues[ulIndex].ulProfile = _wtoi(szProfile);
            pInfo->pHwProfValues[ulIndex].ulAction = HWP_NO_ACTION;
            RegCloseKey(hCfgKey);
            
            //
            // If this is the current profile, open the CurrentDockInfo key
            //
            if (pInfo->pHwProfValues[ulIndex].ulProfile == ulCurrentProfile) {
                
                if (FAILED(StringCchPrintf(RegStr, ARRAYSIZE(RegStr), TEXT("%s\\%s"),
                                           pszRegIDConfigDB, pszRegCurrentDockInfo)) ||
                    ERROR_SUCCESS != RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegStr, 0, KEY_QUERY_VALUE, &hCurrent))
                {
                    
                    //
                    // Could not open the CurrentDockInfo key;
                    // Dock ID and Serial Number are unavailable
                    //
                    
                    pInfo->pHwProfValues[ulIndex].szDockID[0] = TEXT('\0');
                    pInfo->pHwProfValues[ulIndex].szSerialNumber[0] = TEXT('\0');
                    
                } 
                else 
                {
                    
                    //
                    // Retrieve the hardware-detected dock state for the current profile
                    //
                    ulSize = sizeof(ulCurrentDockingState);
                    if ((SHRegGetValue(hCurrent, NULL, pszRegDockingState, SRRF_RT_REG_DWORD, NULL,
                                         (LPBYTE)&ulCurrentDockingState,
                                         &ulSize) == ERROR_SUCCESS) && 
                        ulCurrentDockingState &&
                        !((ulCurrentDockingState & DOCKINFO_DOCKED) &&
                        (ulCurrentDockingState & DOCKINFO_UNDOCKED))) 
                    {
                        //
                        // if the hardware-detected dockstate is present and known,
                        // override the user-supplied dockstate
                        //
                        pInfo->bHwDetectedPortable = TRUE;
                        pInfo->pHwProfValues[ulIndex].ulDockState = ulCurrentDockingState;
                    } 
                    else 
                    {
                        //
                        // keep the user-supplied dockstate
                        //
                        pInfo->bHwDetectedPortable = FALSE;
                        ulCurrentDockingState = pInfo->pHwProfValues[ulIndex].ulDockState;
                    }
                    
                    if ((ulCurrentDockingState & DOCKINFO_UNDOCKED) &&
                        !(ulCurrentDockingState & DOCKINFO_DOCKED) &&
                        !(ulCurrentDockingState & DOCKINFO_USER_SUPPLIED)) {
                        //
                        // The hardware has detected an undocked state; set the global IsPortable flag
                        //
                        pInfo->bPortable = TRUE;
                        
                    } 
                    else if ((ulCurrentDockingState & DOCKINFO_DOCKED) &&
                        !(ulCurrentDockingState & DOCKINFO_UNDOCKED) &&
                        !(ulCurrentDockingState & DOCKINFO_USER_SUPPLIED)) 
                    {
                        //
                        // The hardware has detected a docked state; set the global IsPortable flag
                        //
                        pInfo->bPortable = TRUE;
                        
                        //
                        // Serial Number and DockID are only valid for docked Profiles
                        //
                        
                        //
                        // Retrieve the Serial Number for the current Profile.
                        //
                        // ("AcpiSerialNumber" is preferred because it is updated
                        // on Acpi dock events; "SerialNumber" is set only at boot
                        // time, from the BIOS, and may be inaccurate across Acpi
                        // dock transitions)
                        //
                        ulSize = sizeof(pInfo->pHwProfValues[ulIndex].szSerialNumber);
                        if (ERROR_SUCCESS != SHRegGetValue(hCurrent, NULL, pszRegAcpiSerialNumber, SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND, NULL,
                                                           (LPBYTE)&pInfo->pHwProfValues[ulIndex].szSerialNumber,
                                                           &ulSize))
                        {
                            //
                            // No Acpi Serial Number, but we know the machine is
                            // docked (based on the DockState from the PnP BIOS
                            // info) so check for a PnP BIOS SerialNumber
                            //
                            ulSize = sizeof(ulSerialNumber);
                            if (ERROR_SUCCESS != SHRegGetValue(hCurrent, NULL, pszRegSerialNumber, SRRF_RT_REG_DWORD, 
                                                                 NULL, (LPBYTE)&ulSerialNumber,
                                                                 &ulSize) != ERROR_SUCCESS ||
                                FAILED(StringCchPrintf(pInfo->pHwProfValues[ulIndex].szSerialNumber,
                                                       ARRAYSIZE(pInfo->pHwProfValues[ulIndex].szSerialNumber),
                                                       L"%X", (ULONG)ulSerialNumber)))
                            {
                                pInfo->pHwProfValues[ulIndex].szSerialNumber[0] = TEXT('\0');
                            }
                        }
                        
                        //
                        // Retrieve the DockID for the current Profile, if available.
                        //
                        ulSize = sizeof(ulSerialNumber);
                        if (ERROR_SUCCESS != SHRegGetValue(hCurrent, NULL, pszRegDockID, SRRF_RT_REG_DWORD, NULL,
                                                             (LPBYTE)&ulSerialNumber, &ulSize) ||
                            FAILED(StringCchPrintf(pInfo->pHwProfValues[ulIndex].szDockID, 
                                                   ARRAYSIZE(pInfo->pHwProfValues[ulIndex].szDockID),
                                                   L"%X", (ULONG)ulDockID)))
                        {
                            pInfo->pHwProfValues[ulIndex].szDockID[0] = TEXT('\0');
                        }
                        
                    }
                    
                }
                
         } 
         else 
         {
             //
             // Serial Number and DockID are only valid for the current Profile
             //         
             pInfo->pHwProfValues[ulIndex].szSerialNumber[0] = TEXT('\0');
             pInfo->pHwProfValues[ulIndex].szDockID[0] = TEXT('\0');
         }
         
         //
         // delete the blank string in this spot, add the friendly name
         // (append current tag if necessary)
         //
         SendMessage(hList, LB_DELETESTRING,
             pInfo->pHwProfValues[ulIndex].ulPreferenceOrder, 0);
         
         AppendCurrentTag(
             szName,        // new fixed up name
             ARRAYSIZE(szName),
             pInfo->pHwProfValues[ulIndex].szFriendlyName,
             pInfo->pHwProfValues[ulIndex].ulProfile,
             ulCurrentProfile);
         
         lReturn = SendMessage(hList, LB_INSERTSTRING,
             pInfo->pHwProfValues[ulIndex].ulPreferenceOrder,
             (LPARAM)(LPCTSTR)szName);
         
         
         //
         // store the profile id along with the entry so we
         // can associate the string and the profile id later
         //
         SendMessage(hList, LB_SETITEMDATA,
             (WPARAM)lReturn, pInfo->pHwProfValues[ulIndex].ulProfile);
         
         //
         // if this is the current profile, save the index
         //
         if (pInfo->pHwProfValues[ulIndex].ulProfile == ulCurrentProfile) {
             ulCurrentIndex = pInfo->pHwProfValues[ulIndex].ulPreferenceOrder;
         }
      }
      
      ulIndex++;
      enumIndex++;
      
   } // while
   
   RegCloseKey(hKey);
   
   //---------------------------------------------------------------------
   // migrate portable information
   //---------------------------------------------------------------------
   
   if (bAdmin) {
       sam = KEY_READ | KEY_WRITE;
   } 
   else 
   {
       sam = KEY_READ;
   }
   
   if (RegOpenKeyEx(
       HKEY_LOCAL_MACHINE, pszRegIDConfigDB, 0,
       sam, &hKey) == ERROR_SUCCESS) {
       
       if (pInfo->bHwDetectedPortable) {
           if (bAdmin) {
               //
               // Set the global IsPortable setting as identified by the Hardware
               //
               RegSetValueEx(hKey, pszRegIsPortable, 0, REG_DWORD,
                   (LPBYTE)&pInfo->bPortable, sizeof(pInfo->bPortable));
           }
           
       } 
       else 
       {
           //
           // Is there a global IsPortable setting?
           //
           ulSize = sizeof(pInfo->bPortable);
           if (SHRegGetValue(hKey, NULL, pszRegIsPortable, SRRF_RT_REG_DWORD, NULL,
                               (LPBYTE)&pInfo->bPortable, &ulSize) != ERROR_SUCCESS) {
               //
               // the global IsPortable flag isn't there, and the hardware did
               // not detect this as being a portable machine, so by default, it
               // is not.
               //
               pInfo->bPortable = FALSE;
           }
       }
       
       RegCloseKey(hKey);
   }
   
   SendMessage(hList, WM_SETREDRAW, (WPARAM)TRUE, 0);
   SendMessage(hList, LB_SETCURSEL, ulCurrentIndex, 0);
   
   return TRUE;
   
} // FillProfileList



/**-------------------------------------------------------------------------**/
BOOL
IsProfileNameInUse(
                   HWND     hDlg,
                   LPTSTR   pszFriendlyName
                   )
{
    ULONG          ulBufferIndex=0;
    PHWPROF_INFO   pInfo=NULL;
    
    
    //
    // retrieve the profile buffer
    //
    pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
    
    //
    // check each friendly name (that hasn't been deleted) for a
    // match (case-insensitive)
    //
    while (ulBufferIndex < pInfo->ulNumProfiles) {
        
        if (!(pInfo->pHwProfValues[ulBufferIndex].ulAction & HWP_DELETE)) {
            
            if (lstrcmpi(pInfo->pHwProfValues[ulBufferIndex].szFriendlyName,
                pszFriendlyName) == 0) {
                return TRUE;      // match, name is in use
            }
        }
        ulBufferIndex++;
    }
    
    return FALSE;  // no match found, name not in use
    
} // IsProfileNameInUse



/**-------------------------------------------------------------------------**/
BOOL
CopyHardwareProfile(
                    HWND   hDlg,
                    ULONG_PTR ulIndex,
                    ULONG  ulProfile,
                    LPTSTR szNewFriendlyName
                    )
{
    HWND           hList;
    ULONG          ulBufferIndex=0, ulNewBufferIndex=0;
    ULONG          ulNewProfile=0;
    ULONG_PTR      ulNewIndex=0;
    PHWPROF_INFO   pInfo=NULL;
    HLOCAL         hMem=NULL;
    WCHAR          szTemp[MAX_PATH];
    HKEY           hKey;
    LONG           RegStatus;
    
    
    //
    // retrieve the profile buffer
    //
    pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
    
    //
    // retrieve a handle to the listbox window
    //
    hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);
    
    //
    // find which entry in the buffer list matches this profile
    //
    while (ulBufferIndex < pInfo->ulNumProfiles) {
        if (pInfo->pHwProfValues[ulBufferIndex].ulProfile == ulProfile) {
            break;
        }
        ulBufferIndex++;
    }
    
    //
    // reallocate the profile buffer to hold another entry
    //
    pInfo->ulActiveProfiles++;
    pInfo->ulNumProfiles++;
    
    LocalUnlock(LocalHandle(pInfo->pHwProfValues));
    
    hMem = (PHWPROF_VALUES)LocalReAlloc(
        LocalHandle(pInfo->pHwProfValues),
        pInfo->ulNumProfiles * sizeof(HWPROF_VALUES),
        LMEM_MOVEABLE | LMEM_ZEROINIT);
    
    if (hMem == NULL) {
        DisplaySystemMessage(hDlg, ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }
    
    pInfo->pHwProfValues = (PHWPROF_VALUES)LocalLock(hMem);
    ulNewBufferIndex = pInfo->ulNumProfiles-1;
    
    //
    // find a free profile id to use
    //
    if (!GetFreeProfileID(pInfo, &ulNewProfile)) {
        return FALSE;
    }
    
    pInfo->pHwProfValues[ulNewBufferIndex].ulProfile = ulNewProfile;
    
    //
    // save the friendly name retrieved from the copy dialog box
    //
    StringCchCopy(pInfo->pHwProfValues[ulNewBufferIndex].szFriendlyName, 
                  ARRAYSIZE(pInfo->pHwProfValues[ulNewBufferIndex].szFriendlyName),
                  szNewFriendlyName); // truncation ok, this is used for display ultimately

    //
    // assume it's the last in the preference order (zero-based)
    //
    pInfo->pHwProfValues[ulNewBufferIndex].ulPreferenceOrder =
        pInfo->ulActiveProfiles - 1;
    
    //
    // copy the profile info from the selected profile to the new profile
    //
    pInfo->pHwProfValues[ulNewBufferIndex].ulDockState =
        pInfo->pHwProfValues[ulBufferIndex].ulDockState;
    
    //
    // new hardware profiles are (by default) not aliasable, unless no alias can
    // be copied for this profile.
    //
    pInfo->pHwProfValues[ulNewBufferIndex].bAliasable = FALSE;
    
    //
    // copied profiles are not clones of the pristine profile.
    //
    pInfo->pHwProfValues[ulNewBufferIndex].bCloned = FALSE;
    
    //pInfo->pHwProfValues[ulNewBufferIndex].bPortable =
    //            pInfo->pHwProfValues[ulBufferIndex].bPortable;
    
    if (FAILED(StringCchCopy(pInfo->pHwProfValues[ulNewBufferIndex].szDockID, 
                             ARRAYSIZE(pInfo->pHwProfValues[ulNewBufferIndex].szDockID),
                             pInfo->pHwProfValues[ulBufferIndex].szDockID)))
    {
        DisplaySystemMessage(hDlg, ERROR_BUFFER_OVERFLOW);
        return FALSE;
    }
    
    if (FAILED(StringCchCopy(pInfo->pHwProfValues[ulNewBufferIndex].szSerialNumber, 
               ARRAYSIZE(pInfo->pHwProfValues[ulNewBufferIndex].szSerialNumber), 
               pInfo->pHwProfValues[ulBufferIndex].szSerialNumber)))
    {
        DisplaySystemMessage(hDlg, ERROR_BUFFER_OVERFLOW);
        return FALSE;
    }
    
    //
    // save the original profile id this was copied from
    //
    pInfo->pHwProfValues[ulNewBufferIndex].ulCreatedFrom =
        GetOriginalProfile(pInfo, ulProfile, ulBufferIndex);
    
    //
    // increment the appropriate name-generating counter
    // (note that the counter is NOT symmetrically decreased whenever a profile
    // is deleted -- it increases over the lifetime of the system as new profiles
    // are created; this prevents us from assigning names that incrementally less
    // than names we have already assigned.)
    //
    AdjustProfileTypeCounter(pInfo,
        pInfo->pHwProfValues[ulNewBufferIndex].ulDockState, 
        TRUE);
    
    //
    // set the new profile in the listbox (at the end)
    //
    ulNewIndex = SendMessage(hList, LB_ADDSTRING, 0,
        (LPARAM)(LPTSTR)szNewFriendlyName);
    
    SendMessage(hList, LB_SETITEMDATA,
        (WPARAM)ulNewIndex,
        pInfo->pHwProfValues[ulNewBufferIndex].ulProfile);
    
    //
    // select the new profile
    //
    SendMessage(hList, LB_SETCURSEL, ulNewIndex, 0);
    
    //
    // mark the change
    //
    pInfo->pHwProfValues[ulNewBufferIndex].ulAction |= HWP_CREATE;
    
    //
    // disable copy if we're now at the max number of profiles
    //
    if ((pInfo->ulNumProfiles+1) >= MAX_PROFILES) {
        EnableWindow(GetDlgItem(hDlg, IDD_HWP_COPY), FALSE);
    }
    
    //
    // reenable delete since by definition the selection is not on the
    // current profile (whether it was before or not)
    //
    EnableWindow(GetDlgItem(hDlg, IDD_HWP_DELETE), TRUE);
    
    return TRUE;
    
} // CopyHardwareProfile



/**-------------------------------------------------------------------------**/
BOOL
RenameHardwareProfile(
                      HWND   hDlg,
                      ULONG_PTR ulIndex,
                      ULONG  ulProfile,
                      LPTSTR szNewFriendlyName
                      )
{
    HWND           hList;
    ULONG          ulBufferIndex=0, ulCurrentProfile=0;
    PHWPROF_INFO   pInfo=NULL;
    WCHAR          szName[MAX_PATH];
    
    
    //
    // retrieve the profile buffer
    //
    pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
    
    //
    // retrieve a handle to the listbox window
    //
    hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);
    
    //
    // find the profile entry in the buffer that matches the selection
    //
    while (ulBufferIndex < pInfo->ulNumProfiles) {
        if (pInfo->pHwProfValues[ulBufferIndex].ulProfile == ulProfile) {
            break;
        }
        ulBufferIndex++;
    }
    
    //
    // set the new friendly name in the listbox
    //
    GetCurrentProfile(&ulCurrentProfile);
    AppendCurrentTag(szName, ARRAYSIZE(szName), szNewFriendlyName, ulProfile, ulCurrentProfile);
    
    SendMessage(hList, LB_DELETESTRING, ulIndex, 0);
    SendMessage(hList, LB_INSERTSTRING, ulIndex, (LPARAM)(LPTSTR)szName);
    SendMessage(hList, LB_SETITEMDATA, ulIndex,
        pInfo->pHwProfValues[ulIndex].ulProfile);
    
    //
    // re-select the index (is this necessary?)
    //
    SendMessage(hList, LB_SETCURSEL, ulIndex, 0);
    
    //
    // mark the change
    //
    pInfo->pHwProfValues[ulBufferIndex].ulAction |= HWP_RENAME;
    
    return (SUCCEEDED(StringCchCopy(pInfo->pHwProfValues[ulBufferIndex].szFriendlyName, 
                                   ARRAYSIZE(pInfo->pHwProfValues[ulBufferIndex].szFriendlyName),
                                   szNewFriendlyName)));
} // RenameHardwareProfile



/**-------------------------------------------------------------------------**/
BOOL
DeleteHardwareProfile(
                      HWND   hDlg,
                      ULONG_PTR ulIndex
                      )
{
    HWND           hList;
    ULONG          ulBufferIndex=0, ulProfile=0, ulCurrentProfile=0;
    PHWPROF_INFO   pInfo=NULL;
    
    
    //
    // retrieve the profile buffer
    //
    pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
    
    //
    // retrieve a handle to the listbox window
    //
    hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);
    
    //
    // find the profile entry in the buffer that matches the selection
    //
    ulProfile = (ULONG)SendMessage(hList, LB_GETITEMDATA, ulIndex, 0);
    
    while (ulBufferIndex < pInfo->ulNumProfiles) {
        if (pInfo->pHwProfValues[ulBufferIndex].ulProfile == ulProfile) {
            break;
        }
        ulBufferIndex++;
    }
    
    //
    // readjust all the rankings to be consecutive
    //
    DeleteRank(pInfo, pInfo->pHwProfValues[ulBufferIndex].ulPreferenceOrder);
    
    //
    // decrement the count of active profiles
    //
    pInfo->ulActiveProfiles--;
    
    //
    // delete the friendly name in the listbox
    //
    SendMessage(hList, LB_DELETESTRING, ulIndex, 0);
    
    //
    // re-select the following index (same position)
    //
    if (ulIndex >= pInfo->ulActiveProfiles) {
        ulIndex = pInfo->ulActiveProfiles-1;
    }
    
    SendMessage(hList, LB_SETCURSEL, ulIndex, 0);
    
    //
    // mark the change
    //
    pInfo->pHwProfValues[ulBufferIndex].ulAction |= HWP_DELETE;
    
    //
    // enable copy if less than max number of profiles
    //
    if (pInfo->ulNumProfiles < MAX_PROFILES) {
        EnableWindow(GetDlgItem(hDlg, IDD_HWP_COPY), TRUE);
    }
    
    //
    // find the profile entry in the buffer that matches the new selection
    //
    ulProfile = (ULONG)SendMessage(hList, LB_GETITEMDATA, ulIndex, 0);
    ulBufferIndex = 0;
    
    while (ulBufferIndex < pInfo->ulNumProfiles) {
        if (pInfo->pHwProfValues[ulBufferIndex].ulProfile == ulProfile) {
            break;
        }
        ulBufferIndex++;
    }
    
    GetCurrentProfile(&ulCurrentProfile);
    
    //
    // if the newly selected entry is the current profile, disable delete
    //
    if (pInfo->pHwProfValues[ulBufferIndex].ulProfile == ulCurrentProfile) {
        EnableWindow(GetDlgItem(hDlg, IDD_HWP_DELETE), FALSE);
    }
    
    
    return TRUE;
    
} // DeleteHardwareProfiles



/**-------------------------------------------------------------------------**/
BOOL
GetUserWaitInterval(
                    PULONG   pulWait
                    )
{
    ULONG    ulSize;
    HKEY     hKey;
    
    
    //
    // open the IDConfigDB key
    //
    if(RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, pszRegIDConfigDB, 0,
        KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS) {
        
        DisplaySystemMessage(NULL, ERROR_REGISTRY_CORRUPT);
        return FALSE;
    }
    
    //
    // retrieve the UserWaitInterval value
    //
    ulSize = sizeof(*pulWait);
    if (SHRegGetValue(hKey, NULL, pszRegUserWaitInterval, SRRF_RT_REG_DWORD, NULL,
                        (LPBYTE)pulWait, &ulSize) != ERROR_SUCCESS) 
    {
        *pulWait = DEFAULT_USER_WAIT;
    }
    
    RegCloseKey(hKey);
    return TRUE;
    
} // GetUserWaitInterval



/**-------------------------------------------------------------------------**/
BOOL
SetUserWaitInterval(
                    ULONG   ulWait
                    )
{
    HKEY     hKey;
    
    
    if (bAdmin) {
        //
        // open the IDConfigDB key
        //
        if(RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, pszRegIDConfigDB, 0,
            KEY_SET_VALUE, &hKey) != ERROR_SUCCESS) {
            
            DisplaySystemMessage(NULL, ERROR_REGISTRY_CORRUPT);
            return FALSE;
        }
        
        //
        // set the UserWaitInterval value
        //
        if (RegSetValueEx(
            hKey, pszRegUserWaitInterval, 0, REG_DWORD,
            (LPBYTE)&ulWait, sizeof(ulWait)) != ERROR_SUCCESS) {
            RegCloseKey(hKey);
            return FALSE;
        }
        
        RegCloseKey(hKey);
    }
    
    return TRUE;
    
} // SetUserWaitInterval


/**-------------------------------------------------------------------------**/
BOOL
GetFreeProfileID(
                 PHWPROF_INFO   pInfo,
                 PULONG         pulProfile
                 )
                 
{
    ULONG    ulProfileID = 0, ulBufferIndex = 0;
    BOOL     bHit;
    
    
    //
    // find a profile id that isn't used
    //
    while (ulProfileID < MAX_PROFILES) {
        
        ulBufferIndex = 0;
        bHit = FALSE;
        
        while (ulBufferIndex < pInfo->ulNumProfiles) {
            
            if (ulProfileID == pInfo->pHwProfValues[ulBufferIndex].ulProfile) {
                bHit = TRUE;
                break;
            }
            
            ulBufferIndex++;
        }
        
        //
        // if I got all the way through the list without a hit, then this
        // profile id is free
        //
        if (!bHit) {
            *pulProfile = ulProfileID;
            return TRUE;
        }
        
        ulProfileID++;
    }
    
    *pulProfile = 0xFFFFFFFF;
    return FALSE;
    
} // GetFreeProfileID


/**-------------------------------------------------------------------------**/
ULONG
GetOriginalProfile(
                   PHWPROF_INFO  pInfo,
                   ULONG         ulProfile,
                   ULONG         ulBufferIndex
                   )
{
    ULONG   ulIndex, ulIndexCreatedFrom;
    
    //
    // if the specified profile is a newly created profile, then it is
    // by definition the first in the copy chain
    //
    if (!(pInfo->pHwProfValues[ulBufferIndex].ulAction & HWP_CREATE)) {
        return ulProfile;
    }
    
    ulIndex = ulBufferIndex;
    
    while (pInfo->pHwProfValues[ulIndex].ulAction & HWP_CREATE) {
        //
        // find which entry in the buffer list matches the "CopiedFrom" profile
        //
        ulIndexCreatedFrom = 0;
        
        while (ulIndexCreatedFrom < pInfo->ulNumProfiles) {
            if (pInfo->pHwProfValues[ulIndexCreatedFrom].ulProfile ==
                pInfo->pHwProfValues[ulIndex].ulCreatedFrom) {
                break;
            }
            ulIndexCreatedFrom++;
        }
        ulIndex = ulIndexCreatedFrom;
    }
    
    return pInfo->pHwProfValues[ulIndex].ulProfile;
    
} // GetOriginalProfile




/**-------------------------------------------------------------------------**/
BOOL
DeleteRank(
           PHWPROF_INFO   pInfo,
           ULONG          ulRank
           )
           
{
    ULONG ulIndex;
    
    //
    // for deleting a rank and readjusting the other ranks, just
    // scan through the list and for any rank that is greater than
    // the deleted rank, subtract one from the rank value
    //
    for (ulIndex = 0; ulIndex < pInfo->ulNumProfiles; ulIndex++) {
        //
        // if it's marked for delete, don't bother with it
        //
        if (!(pInfo->pHwProfValues[ulIndex].ulAction & HWP_DELETE)) {
            
            if (pInfo->pHwProfValues[ulIndex].ulPreferenceOrder > ulRank) {
                pInfo->pHwProfValues[ulIndex].ulPreferenceOrder--;
                pInfo->pHwProfValues[ulIndex].ulAction |= HWP_REORDER;
            }
        }
        
    }
    
    return TRUE;
    
} // DeleteRank



/**-------------------------------------------------------------------------**/
BOOL
FlushProfileChanges(
                    HWND hDlg,
                    HWND hList
                    )
{
    ULONG    ulIndex=0;
    HKEY     hKey = NULL, hDestKey = NULL, hSrcKey = NULL, hHwProf = NULL;
    WCHAR    RegStr[MAX_PATH];
    PHWPROF_INFO   pInfo=NULL;
    
    
    //
    // retrieve the profile buffer
    //
    pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
    
    
    //
    // First pass, process the changes for each profile (except delete)
    //
    while (ulIndex < pInfo->ulNumProfiles) {
        
        //
        // were any changes made to this profile?
        //
        if (pInfo->pHwProfValues[ulIndex].ulAction == HWP_NO_ACTION) {
            goto NextProfile;
        }
        
        //
        // save deleting for the second pass
        //
        if (pInfo->pHwProfValues[ulIndex].ulAction & HWP_DELETE) {
            goto NextProfile;
        }
        
        //
        // commit the changes for this profile
        //
        WriteProfileInfo(&pInfo->pHwProfValues[ulIndex]);
        
NextProfile:
        ulIndex++;
    }
    
    
    
    //
    // Second pass, process the delete requests
    //
    ulIndex = 0;
    while (ulIndex < pInfo->ulNumProfiles) {
        
        if (pInfo->pHwProfValues[ulIndex].ulAction & HWP_DELETE) {
            //
            // we only need to delete the key if it exists (if this
            // isn't a delete of a profile that was also just created)
            //
            if (!(pInfo->pHwProfValues[ulIndex].ulAction & HWP_CREATE)) {
                
                if (SUCCEEDED(StringCchPrintf(RegStr, ARRAYSIZE(RegStr), TEXT("%s\\%s"),
                    pszRegIDConfigDB, pszRegKnownDockingStates)))
                {
                    if (RegOpenKeyEx(
                        HKEY_LOCAL_MACHINE, RegStr, 0, KEY_WRITE,
                        &hKey) != ERROR_SUCCESS) {
                        
                        DisplaySystemMessage(hDlg, ERROR_REGISTRY_CORRUPT);
                        return FALSE;
                    }
                    else
                    {
                        if (SUCCEEDED(StringCchPrintf(RegStr, ARRAYSIZE(RegStr), 
                                                      TEXT("%04u"), pInfo->pHwProfValues[ulIndex].ulProfile)))
                        {           
                            RegDeleteKey(hKey, RegStr);
                            
                            //
                            // also delete the profile specific enum tree
                            //
                            DeleteProfileDependentTree(pInfo->pHwProfValues[ulIndex].ulProfile);
                            
                            //
                            // also delete the aliases to this profile
                            //
                            DeleteAliasEntries(pInfo->pHwProfValues[ulIndex].ulProfile);
                        }
                        RegCloseKey(hKey);
                    }
                }
                
            } 
            else {
                //
                // decrement the name-generating counter for profiles we are
                // deleting that we created this session (only if registry keys
                // were never created for this new profile)
                //
                AdjustProfileTypeCounter(pInfo,
                    pInfo->pHwProfValues[ulIndex].ulDockState, 
                    FALSE);
            }
            
        }
        ulIndex++;
    }
    
    //
    // commit global settings
    //
    if(RegOpenKeyEx(
        HKEY_LOCAL_MACHINE, pszRegIDConfigDB, 0,
        KEY_SET_VALUE, &hKey) == ERROR_SUCCESS) {
        
        RegSetValueEx(hKey, pszRegIsPortable, 0, REG_DWORD,
            (LPBYTE)&pInfo->bPortable, sizeof(pInfo->bPortable));
        
        if (RegOpenKeyEx(
            hKey, pszRegKnownDockingStates, 0,
            KEY_SET_VALUE, &hHwProf) == ERROR_SUCCESS) {
            
            if (pInfo->ulUndockedProfileNameCount > 0) {
                RegSetValueEx(hHwProf, pszRegUndocked, 0, REG_DWORD,
                    (LPBYTE)&pInfo->ulUndockedProfileNameCount, sizeof(pInfo->ulUndockedProfileNameCount));
            } 
            else 
            {
                RegDeleteValue(hHwProf, pszRegUndocked);
            }
            
            if (pInfo->ulDockedProfileNameCount > 0) {
                RegSetValueEx(hHwProf, pszRegDocked, 0, REG_DWORD,
                    (LPBYTE)&pInfo->ulDockedProfileNameCount, sizeof(pInfo->ulDockedProfileNameCount));
            } 
            else 
            {
                RegDeleteValue(hHwProf, pszRegDocked);
            }
            
            if (pInfo->ulUnknownProfileNameCount > 0) {
                RegSetValueEx(hHwProf, pszRegUnknown, 0, REG_DWORD,
                    (LPBYTE)&pInfo->ulUnknownProfileNameCount, sizeof(pInfo->ulUnknownProfileNameCount));
            } 
            else 
            {
                RegDeleteValue(hHwProf, pszRegUnknown);
            }
            
            RegCloseKey(hHwProf);
        }
        RegCloseKey(hKey);
    }
    
    return TRUE;
    
} // FlushProfileChanges



/**-------------------------------------------------------------------------**/
BOOL
WriteProfileInfo(
                 PHWPROF_VALUES pProfValues
                 )
{
    HKEY     hKey = NULL, hDestKey = NULL, hSrcKey = NULL;
    WCHAR    RegStr[MAX_PATH];
    UUID     NewGuid;
    LPTSTR   UuidString;
    TCHAR    szGuid[MAX_GUID_STRING_LEN];
    
    if (pProfValues->ulAction & HWP_DELETE) {
        return TRUE;      // skip it
    }
    
    //
    // form the registry key string
    //
    if (FAILED(StringCchPrintf(RegStr, ARRAYSIZE(RegStr),
               TEXT("%s\\%s\\%04u"), pszRegIDConfigDB,
               pszRegKnownDockingStates, pProfValues->ulProfile)))
    {
        return FALSE;
    }
    
    //
    // create the profile key if it's a new profile. Don't
    // worry about security because the profile subkey always
    // inherits the security of the parent Hardware Profiles key.
    //
    if (pProfValues->ulAction & HWP_CREATE) {
        
        if (RegCreateKeyEx(
            HKEY_LOCAL_MACHINE, RegStr, 0, NULL,
            REG_OPTION_NON_VOLATILE, KEY_WRITE,
            NULL, &hKey, NULL) != ERROR_SUCCESS) {
            return FALSE;
        }
        
        //
        // create a HwProfileGuid if its a new profile
        //
        if ((UuidCreate(&NewGuid) == RPC_S_OK) &&    
            (UuidToString(&NewGuid, &UuidString) == RPC_S_OK)) {                    
            
            //
            // put curly braces around the guid
            //
            if (SUCCEEDED(StringCchPrintf(szGuid, ARRAYSIZE(szGuid), TEXT("{%s}"), UuidString)))
            {
                RpcStringFree(&UuidString);
                
                //
                // save the new HwProfileGuid in the registry
                //
                RegSetValueEx(
                    hKey, pszRegHwProfileGuid, 0, REG_SZ,
                    (LPBYTE)szGuid,
                    (lstrlen(szGuid)+1) * sizeof(TCHAR) );         
            }
            else
            {
                return FALSE;
            }
        }
        
    } 
    else 
    {
        //
        // if not a create, just open the existing key
        //
        if (RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, RegStr, 0, KEY_SET_VALUE,
            &hKey) != ERROR_SUCCESS) {
            return FALSE;
        }
    }
    
    //
    // update preference order if modified
    //
    if ((pProfValues->ulAction & HWP_REORDER) ||
        (pProfValues->ulAction & HWP_CREATE)) {
        
        RegSetValueEx(
            hKey, pszRegPreferenceOrder, 0, REG_DWORD,
            (LPBYTE)&pProfValues->ulPreferenceOrder, sizeof(pProfValues->ulPreferenceOrder));
        
        pProfValues->ulAction &= ~HWP_REORDER;    // clear action
    }
    
    //
    // update friendly name if modified
    //
    if ((pProfValues->ulAction & HWP_RENAME) ||
        (pProfValues->ulAction & HWP_CREATE)) {
        
        RegSetValueEx(
            hKey, pszRegFriendlyName, 0, REG_SZ,
            (LPBYTE)pProfValues->szFriendlyName,
            (lstrlen(pProfValues->szFriendlyName)+1) * sizeof(TCHAR));
        
        pProfValues->ulAction &= ~HWP_RENAME;     // clear action
    }
    
    //
    // update property values if modified
    //
    if ((pProfValues->ulAction & HWP_PROPERTIES) ||
        (pProfValues->ulAction & HWP_CREATE)) {
        
        RegSetValueEx(
            hKey, pszRegDockState, 0, REG_DWORD,
            (LPBYTE)&pProfValues->ulDockState, sizeof(pProfValues->ulDockState));
        
        RegSetValueEx(
            hKey, pszRegAliasable, 0, REG_DWORD,
            (LPBYTE)&pProfValues->bAliasable, sizeof(pProfValues->bAliasable));
        
        pProfValues->ulAction &= ~HWP_PROPERTIES;    // clear action
    }
    
    
    if (pProfValues->ulAction & HWP_CREATE) {
        //
        // copy the profile enum info. Don't worry about security on
        // this createkey because the profile key always inherits the
        // security of the parent Hardware Profiles key.
        //
        if (SUCCEEDED(StringCchPrintf(RegStr, ARRAYSIZE(RegStr), TEXT("%s\\%04u"),
                                      pszRegHwProfiles, pProfValues->ulProfile)))
        {
            if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, RegStr, 0, NULL, REG_OPTION_NON_VOLATILE,
                                                KEY_WRITE, NULL, &hDestKey, NULL))
            {
                if (SUCCEEDED(StringCchPrintf(RegStr, ARRAYSIZE(RegStr), TEXT("%s\\%04u"),
                                              pszRegHwProfiles, pProfValues->ulCreatedFrom)))
                {
                    
                    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegStr, 0, KEY_READ, &hSrcKey))
                    {
                        SHCopyKey(hSrcKey, NULL, hDestKey, 0);
                        
                        //
                        // copy all aliases for the source profile to the destination as well.
                        //
                        if (!CopyAliasEntries(pProfValues->ulCreatedFrom, pProfValues->ulProfile)) 
                        {                            
                            //
                            // We didn't actually copy any aliases, so make sure this profile gets
                            // marked as "Aliasable" so that it shows up as a profile option at
                            // boot time.
                            //
                            pProfValues->bAliasable = TRUE;
                            RegSetValueEx(hKey, pszRegAliasable, 0, REG_DWORD,
                                          (LPBYTE)&pProfValues->bAliasable, sizeof(pProfValues->bAliasable));
                        }
                        pProfValues->ulAction &= ~HWP_CREATE;     // clear action
                        pProfValues->ulAction |= HWP_NEWPROFILE;  // created during this session
                        RegCloseKey(hSrcKey);
                    }
                }
                RegCloseKey(hDestKey);
            }
            
        }
    }
    
    RegCloseKey(hKey);
    
    return TRUE;
    
} // WriteProfileInfo


/**-------------------------------------------------------------------------**/
BOOL
RemoveNewProfiles(
                  PHWPROF_INFO   pInfo
                  )
{
    ULONG    ulIndex=0;
    HKEY     hKey = NULL;
    WCHAR    RegStr[MAX_PATH];
    
    
    //
    // check each profile for any HWP_NEWPROFILE flags
    //
    while (ulIndex < pInfo->ulNumProfiles) {
        
        if (pInfo->pHwProfValues[ulIndex].ulAction & HWP_NEWPROFILE) {
            
            if (SUCCEEDED(StringCchPrintf(RegStr, ARRAYSIZE(RegStr), 
                                          TEXT("%s\\%s"), pszRegIDConfigDB, pszRegKnownDockingStates)))
            {
                if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegStr, 0, KEY_WRITE,
                                 &hKey) == ERROR_SUCCESS) 
                {
                    if (SUCCEEDED(StringCchPrintf(RegStr, ARRAYSIZE(RegStr),
                                                  TEXT("%04u"), pInfo->pHwProfValues[ulIndex].ulProfile)))
                    {
                        RegDeleteKey(hKey, RegStr);
                        
                        //
                        // also delete the profile specific enum tree
                        //
                        DeleteProfileDependentTree(pInfo->pHwProfValues[ulIndex].ulProfile);
                        
                        //
                        // also delete aliases to this profile
                        //
                        DeleteAliasEntries(pInfo->pHwProfValues[ulIndex].ulProfile);
                        
                        //
                        // decrement the appropriate name-generating counter
                        // (note that the counter is only deleted for new profiles that are
                        // never fully commited; we don't make an attempt to decerement the
                        // counter when any profile is deleted, else we may get into a case
                        // where we assign a name to a new profile that in incrementally less
                        // than a name we had previously assigned.)
                        //
                        AdjustProfileTypeCounter(pInfo,
                                                 pInfo->pHwProfValues[ulIndex].ulDockState, 
                                                 FALSE);
                    }
                    RegCloseKey(hKey);
                }
            }
        }
        ulIndex++;
    }
    
    return TRUE;
    
} // RemoveNewProfiles



/**-------------------------------------------------------------------------**/
BOOL
SwapPreferenceOrder(
                    HWND  hDlg,
                    HWND  hList,
                    ULONG_PTR ulIndex1,
                    ULONG_PTR ulIndex2
                    )
                    
{
    BOOL     fRet = FALSE;
    ULONG    ulProfile1=0, ulProfile2=0;
    ULONG    ulBufferIndex1=0, ulBufferIndex2=0;
    WCHAR    szFriendlyName1[MAX_FRIENDLYNAME_LEN];
    WCHAR    szFriendlyName2[MAX_FRIENDLYNAME_LEN];
    ULONG    ulTemp=0;
    PHWPROF_INFO   pInfo=NULL;
    
    
    //
    // retrieve the profile buffer
    //
    pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
    
    //
    // retrieve the profile id for the two selected profile entries
    //
    ulProfile1 = (ULONG)SendMessage(hList, LB_GETITEMDATA, ulIndex1, 0);
    ulProfile2 = (ULONG)SendMessage(hList, LB_GETITEMDATA, ulIndex2, 0);
    
    //
    // find the profile entry in the buffer that matches these selections
    //
    while (ulBufferIndex1 < pInfo->ulNumProfiles) {
        if (pInfo->pHwProfValues[ulBufferIndex1].ulProfile == ulProfile1) {
            break;
        }
        ulBufferIndex1++;
    }
    
    while (ulBufferIndex2 < pInfo->ulNumProfiles) {
        if (pInfo->pHwProfValues[ulBufferIndex2].ulProfile == ulProfile2) {
            break;
        }
        ulBufferIndex2++;
    }
    
    //
    // swap the order values of the profiles in the in-memory buffer
    //
    ulTemp = pInfo->pHwProfValues[ulBufferIndex1].ulPreferenceOrder;
    pInfo->pHwProfValues[ulBufferIndex1].ulPreferenceOrder =
        pInfo->pHwProfValues[ulBufferIndex2].ulPreferenceOrder;
    pInfo->pHwProfValues[ulBufferIndex2].ulPreferenceOrder = ulTemp;
    
    //
    // mark both profiles as having been reordered
    //
    pInfo->pHwProfValues[ulBufferIndex1].ulAction |= HWP_REORDER;
    pInfo->pHwProfValues[ulBufferIndex2].ulAction |= HWP_REORDER;
    
    //
    // swap the positions in the list box
    //

    if (SafeGetListBoxText(hList, (UINT)ulIndex1, szFriendlyName1, ARRAYSIZE(szFriendlyName1)) &&
        SafeGetListBoxText(hList, (UINT)ulIndex2, szFriendlyName2, ARRAYSIZE(szFriendlyName2)))
    {
        SendMessage(hList, LB_DELETESTRING, ulIndex1, 0);
        SendMessage(hList, LB_INSERTSTRING, ulIndex1,
            (LPARAM)(LPTSTR)szFriendlyName2);
    
        SendMessage(hList, LB_DELETESTRING, ulIndex2, 0);
        SendMessage(hList, LB_INSERTSTRING, ulIndex2,
            (LPARAM)(LPTSTR)szFriendlyName1);
    
        SendMessage(hList, LB_SETITEMDATA, ulIndex1, ulProfile2);
        SendMessage(hList, LB_SETITEMDATA, ulIndex2, ulProfile1);
    
        //
        // finally, select the second index (the second index is the rank
        // position we're moving to)
        //
        SendMessage(hList, LB_SETCURSEL, ulIndex2, 0);

        fRet = TRUE;
    }
    
    return fRet;
    
} // SwapPreferenceOrder


/**-------------------------------------------------------------------------**/
BOOL
DeleteProfileDependentTree(
                           ULONG ulProfile
                           )
{
    BOOL fRet;
    TCHAR szProfile[5], szKey[MAX_PATH];
    LONG  RegStatus = ERROR_SUCCESS;
    HKEY  hHwProfKey, hCfgKey;
    ULONG ulIndex = 0, ulSize = 0;
    
    
    //
    // form the registry key string
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszRegHwProfiles, 0, KEY_WRITE,
                     &hHwProfKey) != ERROR_SUCCESS) 
    {
        DisplaySystemMessage(NULL, ERROR_REGISTRY_CORRUPT);
        fRet = FALSE;
    }
    else
    {
        if (FAILED(StringCchPrintf(szProfile, ARRAYSIZE(szProfile), TEXT("%04u"), ulProfile)))
        {
            fRet = FALSE;
        }
        else
        {
            SHDeleteKey(hHwProfKey, szProfile);
            fRet = TRUE;
        }
        
        RegCloseKey(hHwProfKey);
    }
    
    return fRet;
    
} // DeleteProfileDependentTree

/**-------------------------------------------------------------------------**/

BOOL
CopyAliasEntries(
                 ULONG ulSrcProfile,
                 ULONG ulDestProfile
                 )
{
    BOOL bNewAliasCreated = FALSE;
    
    bNewAliasCreated |= CopyAliasEntryType(ulSrcProfile, ulDestProfile, pszRegAlias);
    bNewAliasCreated |= CopyAliasEntryType(ulSrcProfile, ulDestProfile, pszRegAcpiAlias);    
    
    return bNewAliasCreated;
    
} // CopyAliasEntries

/**-------------------------------------------------------------------------**/

BOOL
DeleteAliasEntries(
                   ULONG ulProfile    
                   )
{
    BOOL bResult = TRUE;
    
    bResult |= DeleteAliasEntryType(ulProfile, pszRegAlias);
    bResult |= DeleteAliasEntryType(ulProfile, pszRegAcpiAlias);    
    
    return bResult;
    
} // CopyAliasEntries

/**-------------------------------------------------------------------------**/

BOOL
CopyAliasEntryType(
                   ULONG  ulSrcProfile,
                   ULONG  ulDestProfile,
                   LPWSTR szSubKeyName
                   )
{
    
    LONG   RegStatus = ERROR_SUCCESS;
    HKEY   hAliasRoot, hSrcKey, hDestKey;
    WCHAR  RegStr[MAX_PATH];
    WCHAR  szString[MAX_PATH];
    ULONG  ulAliasProfileNumber, ulNewAlias, ulSize, i;
    BOOL   bNewAliasCreated=FALSE;
    
    //
    // check all aliases under the "Alias" key
    //
    if (FAILED(StringCchPrintf(RegStr, ARRAYSIZE(RegStr), TEXT("%s\\%s"),
                               pszRegIDConfigDB, szSubKeyName)))
    {
        return FALSE;
    }
    
    RegStatus = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE, RegStr, 0, KEY_ALL_ACCESS,
            &hAliasRoot);
    if (RegStatus == ERROR_FILE_NOT_FOUND) {
        //
        // No Alias subkey, this could be ok if we have the other type.
        //
        RegStatus = ERROR_SUCCESS;
        return bNewAliasCreated;
   } else if (RegStatus != ERROR_SUCCESS) {
        //
        // Some other registry error occurred.
        //
        DisplaySystemMessage(NULL, ERROR_REGISTRY_CORRUPT);
        return FALSE;
   } else {
        //
        // enumerate all Alias subkeys
        //
       for (i=0; RegStatus == ERROR_SUCCESS; i++) {

            ulSize = MAX_PATH;
            
            RegStatus = RegEnumKey(hAliasRoot, i, szString, ulSize);
            
            if (RegStatus == ERROR_SUCCESS) {
                
                if (RegOpenKeyEx(hAliasRoot, szString, 0, KEY_READ, &hSrcKey) == ERROR_SUCCESS) 
                {
                    
                    ulSize = sizeof(ulAliasProfileNumber);                    
                    if (SHRegGetValue(hSrcKey, NULL, pszRegProfileNumber, SRRF_RT_REG_DWORD, NULL,
                                            (LPBYTE)&ulAliasProfileNumber, 
                                            &ulSize) == ERROR_SUCCESS) 
                    {
                        
                        //
                        // Check if we need to copy this one
                        //
                        if (ulSrcProfile == ulAliasProfileNumber) {
                            
                            //
                            // Find an unused Alias subkey name
                            //          
                            ulNewAlias = 0;
                            while (ulNewAlias < MAX_ALIASES) 
                            {
                                ulNewAlias++;
                                if (FAILED(StringCchPrintf(RegStr, ARRAYSIZE(RegStr),
                                                           TEXT("%s\\%s\\%04u"),
                                                           pszRegIDConfigDB,
                                                           szSubKeyName,
                                                           ulNewAlias)))
                                {
                                    break;
                                }
                                else
                                {
                                    RegStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
                                        RegStr, 0, KEY_ALL_ACCESS, 
                                        &hDestKey);
                                    
                                    if (RegStatus == ERROR_SUCCESS) {
                                        RegCloseKey(hDestKey);
                                        continue;
                                    } 
                                    else if (RegStatus == ERROR_FILE_NOT_FOUND) 
                                    {
                                        RegStatus = ERROR_SUCCESS;
                                        break;
                                    } 
                                    else 
                                    {
                                        break;
                                    }
                                }
                            }
                            
                            if ((RegStatus != ERROR_SUCCESS) || (ulNewAlias >= MAX_ALIASES)) {
                                RegCloseKey(hSrcKey);
                                break;
                            }
                            
                            if (SUCCEEDED(StringCchPrintf(RegStr, ARRAYSIZE(RegStr), 
                                                          TEXT("%s\\%s\\%04u"), 
                                                          pszRegIDConfigDB, szSubKeyName, ulNewAlias)))
                            {
                                if (ERROR_SUCCESS == RegCreateKeyEx(HKEY_LOCAL_MACHINE, RegStr, 0, NULL, REG_OPTION_NON_VOLATILE,
                                                                    KEY_WRITE, NULL, &hDestKey, NULL))
                                {
                                    //
                                    // copy this alias entry 
                                    //   
                                    SHCopyKey(hSrcKey, NULL, hDestKey, 0);
                                    
                                    RegSetValueEx(
                                        hDestKey, pszRegProfileNumber, 0, REG_DWORD,
                                        (LPBYTE)&ulDestProfile, sizeof(ulDestProfile));
                                    
                                    bNewAliasCreated = TRUE;
                                    if (ulNewAlias < (ULONG)_wtoi(szString)) {
                                        // kick the enumeration index up one, else we'll
                                        // find the key we just copied again.
                                        i++;
                                    }
                                    
                                    RegCloseKey(hDestKey);
                                }
                            }
                        }
                    }
                    RegCloseKey(hSrcKey);
                }
            }
        }
        RegCloseKey(hAliasRoot);
   }
   
   return bNewAliasCreated;
   
} // CopyAliasEntryType

/**-------------------------------------------------------------------------**/

BOOL
DeleteAliasEntryType(
                     ULONG  ulProfile,
                     LPWSTR szSubKeyName
                     )
                     
{
    BOOL   fRet;
    LONG   RegStatus = ERROR_SUCCESS;
    HKEY   hAliasRoot;
    HKEY   hAliasSubKey;
    WCHAR  RegStr[MAX_PATH];
    WCHAR  szString[MAX_PATH];
    ULONG  ulAliasProfileNumber, ulSize, i;
    BOOL   bDeleted = FALSE;
    
    //
    // check all aliases under the "Alias" key
    //
    if (FAILED(StringCchPrintf(RegStr, ARRAYSIZE(RegStr), TEXT("%s\\%s"), pszRegIDConfigDB, szSubKeyName)))
    {
        fRet = FALSE;
    }
    else
    {    
        RegStatus = RegOpenKeyEx(HKEY_LOCAL_MACHINE, RegStr, 0, KEY_READ, &hAliasRoot);
        if (RegStatus == ERROR_FILE_NOT_FOUND) 
        {
            fRet = TRUE;
        } 
        else if (RegStatus != ERROR_SUCCESS) 
        {
            DisplaySystemMessage(NULL, ERROR_REGISTRY_CORRUPT);
            fRet = FALSE;
        }
        else
        {
    
            //
            // enumerate all subkeys
            //
            RegStatus = ERROR_SUCCESS;
    
            for (i=0; RegStatus == ERROR_SUCCESS; ) {
        
                ulSize = MAX_PATH;
        
                RegStatus = RegEnumKey(hAliasRoot, i, szString, ulSize);
                bDeleted = FALSE;
        
                if (RegStatus == ERROR_SUCCESS) {
                    if (RegOpenKeyEx(hAliasRoot, szString, 0, KEY_READ, &hAliasSubKey) == ERROR_SUCCESS) 
                    {             
                        ulSize = sizeof(ulAliasProfileNumber);
                        if (SHRegGetValue(hAliasSubKey, NULL, pszRegProfileNumber, SRRF_RT_REG_DWORD, NULL,
                                            (LPBYTE)&ulAliasProfileNumber, 
                                            &ulSize) == ERROR_SUCCESS) 
                        {                    
                            if (ulProfile == ulAliasProfileNumber) 
                            {
                                //
                                // delete this alias entry 
                                //
                                RegCloseKey(hAliasSubKey);
                                hAliasSubKey = NULL;
                                RegDeleteKey(hAliasRoot, szString);
                                bDeleted = TRUE;
                            }
                        }
                        if (hAliasSubKey) RegCloseKey(hAliasSubKey);
                    }
                }
                if (!bDeleted) i++;
            }   
            RegCloseKey(hAliasRoot);

            fRet = TRUE;
        }
    }
    
    return fRet;
    
} // DeleteAliasEntryType

/**-------------------------------------------------------------------------**/
VOID
AdjustProfileTypeCounter(
                         PHWPROF_INFO   pInfo,
                         ULONG          ulDockState,
                         BOOL           bIncrement
                         )
{
    PULONG pCounter;
    
    //
    // use the counter corresponding to the given DockState.
    //
    if ((ulDockState & DOCKINFO_DOCKED) &&
        (ulDockState & DOCKINFO_UNDOCKED)) {       
        pCounter = &pInfo->ulUnknownProfileNameCount;
    } else if (ulDockState & DOCKINFO_DOCKED) {
        pCounter = &pInfo->ulDockedProfileNameCount;
    } else if (ulDockState & DOCKINFO_UNDOCKED) {
        pCounter = &pInfo->ulUndockedProfileNameCount;
    } else {
        pCounter = &pInfo->ulUnknownProfileNameCount;
    }
    
    //
    // increment or decrement the counter, as requested.
    //
    if (bIncrement) {
        *pCounter += 1;
    } else if (!bIncrement && (*pCounter > 0)) {
        *pCounter -= 1;        
    } else {
        *pCounter = 0;
    }
}

/**-------------------------------------------------------------------------**/
BOOL
StripCurrentTag(
                LPTSTR   szFriendlyName,
                ULONG    ulProfile,
                ULONG    ulCurrentProfile
                )
{
    ULONG ulTagLen, ulNameLen;
    
    
    if (ulProfile == ulCurrentProfile) {
        
        ulTagLen = lstrlen(pszCurrentTag);
        ulNameLen = lstrlen(szFriendlyName);
        
        if (ulNameLen < ulTagLen) {
            return TRUE;   // nothing to do
        }
        
        if (lstrcmpi(&szFriendlyName[ulNameLen - ulTagLen], pszCurrentTag) == 0) {
            //
            // truncate the string before the current tag
            //
            szFriendlyName[ulNameLen - ulTagLen - 1] = '\0';
        }
    }
    
    return TRUE;
    
} // StripCurrentTag


/**-------------------------------------------------------------------------**/
BOOL
AppendCurrentTag(
                 LPTSTR   szTaggedName,
                 UINT     cchTaggedName,
                 LPCTSTR  szOriginalName,
                 ULONG    ulProfile,
                 ULONG    ulCurrentProfile
                 )
{
    
    BOOL fRet = FALSE;
    if (SUCCEEDED(StringCchCopy(szTaggedName, cchTaggedName, szOriginalName)))
    {
        //
        // if the profile is the current profile, then append the tag
        // (let's user easily identify it as current)
        //
        if (ulProfile == ulCurrentProfile) 
        {
            fRet = SUCCEEDED(StringCchCat(szTaggedName, cchTaggedName, TEXT(" "))) &&
                   SUCCEEDED(StringCchCat(szTaggedName, cchTaggedName, pszCurrentTag));
        }
        else
        {
            fRet = TRUE;
        }
    }
    
    return fRet;
    
} // AppendCurrentTag


/**-------------------------------------------------------------------------**/
BOOL
CreateHwProfileFriendlyName(
                            IN  HWND       hDlg,
                            IN  ULONG      ulDockState,
                            OUT LPTSTR     szFriendlyName,
                            IN  UINT       cchFriendlyName
                            )
{
    
    PHWPROF_INFO   pInfo;
    LPTSTR         szPrefix;
    PULONG         pulIndex;
    BOOL           bUnknown=FALSE, bUniqueFriendlyName=FALSE;
    
    //
    // retrieve the profile buffer
    //
    pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
    
    //
    // based on the DockState, determine the appropriate label to use and get a
    // pointer to its counter index
    //
    if ((ulDockState & DOCKINFO_DOCKED) &&
        (ulDockState & DOCKINFO_UNDOCKED)) {
        szPrefix = pszUnknown;
        pulIndex = &pInfo->ulUnknownProfileNameCount;
        bUnknown = TRUE;
    }
    else if (ulDockState & DOCKINFO_DOCKED) {
        szPrefix = pszDocked;
        pulIndex = &pInfo->ulDockedProfileNameCount;
    }
    else if (ulDockState & DOCKINFO_UNDOCKED) {
        szPrefix = pszUndocked;
        pulIndex = &pInfo->ulUndockedProfileNameCount;
    }
    else {
        szPrefix = pszUnknown;
        pulIndex = &pInfo->ulUnknownProfileNameCount;
        bUnknown = TRUE;
    }
    
    while ((!bUniqueFriendlyName) && (*pulIndex < MAX_PROFILES)) {
        //
        // as long as we don't have a unique name, build a FriendlyName based on
        // the DockState and counter index
        //
        if (bUnknown || (*pulIndex > 0)) 
        {
            if (FAILED(StringCchPrintf(szFriendlyName, cchFriendlyName, TEXT("%s %u"), szPrefix, *pulIndex + 1)))
            {
                return FALSE;
            }
        } else {
            if (FAILED(StringCchCopy(szFriendlyName, cchFriendlyName, szPrefix)))
            {
                return FALSE;
            }
        }
        
        if (IsProfileNameInUse(hDlg,szFriendlyName)) {
            //
            // if this friendly name is in use, increment the counter to reflect this
            //
            *pulIndex += 1;
        } else {
            //
            // a unique friendly name has been generated
            //
            bUniqueFriendlyName = TRUE;
        }
    }
    
    if (!bUniqueFriendlyName) {
        //
        // if unable to generate a unique friendly name, just use some default.
        // the user may have to deal with any errors arising from duplicate names
        // is this name is already taken
        //
        if (FAILED(StringCchCopy(szFriendlyName, cchFriendlyName, pszRegDefaultFriendlyName)))
        {
            return FALSE;
        }
    }
    
    return TRUE;
    
} // CreateHwProfileFriendlyName


/**-------------------------------------------------------------------------**/
VOID
DisplayPrivateMessage(
                      HWND  hWnd,
                      UINT  uiPrivateError
                      )
{
    WCHAR szMessage[MAX_PATH];
    
    
    LoadString(hInstance, uiPrivateError, szMessage, MAX_PATH);
    MessageBox(hWnd, szMessage, pszErrorCaption, MB_OK | MB_ICONSTOP);
    
    return;
}


/**-------------------------------------------------------------------------**/
VOID
DisplaySystemMessage(
                     HWND  hWnd,
                     UINT  uiSystemError
                     )
{
    WCHAR szMessage[MAX_PATH];
    
    //
    // retrieve the string matching the Win32 system error
    //
    FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
                  NULL,
                  uiSystemError,
                  MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
                  szMessage,
                  ARRAYSIZE(szMessage),
                  NULL);
    
    //
    // display a message box with this error
    //
    MessageBox(
        hWnd,
        szMessage,
        pszErrorCaption,
        MB_OK | MB_ICONSTOP);
    
    return;
    
} // DisplaySystemMessage


/**--------------------------------------------------------------------------**/
BOOL
UpdateOrderButtonState(
                       HWND  hDlg
                       )
{
    PHWPROF_INFO   pInfo;
    ULONG_PTR      ulIndex = 0;
    HWND           hList;
    
    
    pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
    
    hList = GetDlgItem(hDlg, IDD_HWP_PROFILES);
    
    if ((ulIndex = SendMessage(hList,
        LB_GETCURSEL, 0, 0)) == LB_ERR) {
        return FALSE;
    }
    
    if (ulIndex == 0) {
        //
        // if focus currently on the button we're about to disable,
        // change focus first or focus will be lost.
        //
        if (GetFocus() == GetDlgItem(hDlg, IDD_HWP_ORDERUP)) {
            SendMessage(hDlg, DM_SETDEFID, IDD_HWP_ORDERDOWN, 0L);
            SetFocus(GetDlgItem(hDlg, IDD_HWP_ORDERDOWN));
        }
        EnableWindow(GetDlgItem(hDlg, IDD_HWP_ORDERUP), FALSE);
    } else {
        EnableWindow(GetDlgItem(hDlg, IDD_HWP_ORDERUP), TRUE);
    }
    
    if (ulIndex < pInfo->ulActiveProfiles-1) {
        EnableWindow(GetDlgItem(hDlg, IDD_HWP_ORDERDOWN), TRUE);
    } else {
        //
        // if focus currently on the button we're about to disable,
        // change focus first or focus will be lost.
        //
        if (GetFocus() == GetDlgItem(hDlg, IDD_HWP_ORDERDOWN)) {
            SendMessage(hDlg, DM_SETDEFID, IDD_HWP_PROPERTIES, 0L);
            SetFocus(GetDlgItem(hDlg, IDD_HWP_PROPERTIES));
        }
        EnableWindow(GetDlgItem(hDlg, IDD_HWP_ORDERDOWN), FALSE);
    }
    
    
    
    
    return TRUE;
}


/**-------------------------------------------------------------------------**/
BOOL CALLBACK AddPropSheetPageProc(
                                   HPROPSHEETPAGE  hpage,
                                   LPARAM  lParam
                                   )
{
    hPages[ulNumPages] = hpage;
    
    return TRUE;
    
} // AddPropSheetPageProc


/**--------------------------------------------------------------------------**/
BOOL
DisplayProperties(
                  IN HWND           hOwnerDlg,
                  IN PHWPROF_INFO   pInfo
                  )
{
    BOOL              bStatus;
    LPTSTR            pszProviderList = NULL, pszProvider = NULL;
    PROPSHEETPAGE     PropPage;
    PROPSHEETHEADER   PropHeader;
    FARPROC           lpProc;
    ULONG             i, ulSize = 0;
    HKEY              hKey = NULL;
    
    
    //
    // create the first page (General)
    //
    ulNumPages = 0;
    
    PropPage.dwSize        = sizeof(PROPSHEETPAGE);
    PropPage.dwFlags       = PSP_DEFAULT;
    PropPage.hInstance     = hInstance;
    PropPage.pszTemplate   = MAKEINTRESOURCE(DLG_HWP_GENERAL);
    PropPage.pszIcon       = NULL;
    PropPage.pszTitle      = NULL;
    PropPage.pfnDlgProc    = GeneralProfileDlg;
    PropPage.lParam        = (LPARAM)pInfo;
    PropPage.pfnCallback   = NULL;
    
    hPages[0] = CreatePropertySheetPage(&PropPage);
    if (hPages[0] == NULL) {
        return FALSE;
    }
    
    ulNumPages++;
    
    //
    // open the IDConfigDB key
    //
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszRegIDConfigDB, 0,
        KEY_QUERY_VALUE, &hKey) != ERROR_SUCCESS) {
        return FALSE;
    }
    
    
    //---------------------------------------------------------------
    // Are there any other property pages?
    //---------------------------------------------------------------
    
    if (SHRegGetValue(hKey, NULL, pszRegPropertyProviders, SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND, NULL,
                      NULL, &ulSize) == ERROR_SUCCESS) 
    {       
        pszProviderList = LocalAlloc(LPTR, ulSize);
        
        if (pszProviderList != NULL) {
            //
            // read list of providers
            //
            if (SHRegGetValue(hKey, NULL, pszRegPropertyProviders, SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND, NULL,
                              (LPBYTE)pszProviderList, &ulSize) == ERROR_SUCCESS) 
            {
                //
                // Ask each provider to create and register it's property page
                //
                for (pszProvider = pszProviderList;
                *pszProvider;
                pszProvider += lstrlen(pszProvider) + 1) {
                    
                    if (ulNumPages >= MAX_EXTENSION_PROVIDERS) {
                        break;      // stop at max number of pages
                    }
                    
                    //
                    // load the provider DLL
                    //
                    hLibs[ulNumPages] = LoadLibrary(pszProvider);
                    if (hLibs[ulNumPages] != NULL) {
                        
                        lpProc = GetProcAddress(hLibs[ulNumPages],
                            "ExtensionPropSheetPageProc");
                        if (lpProc != NULL) {
                            //
                            // pass the profile ID to the provider as the lParam value
                            //
                            if ((lpProc)(NULL,
                                &AddPropSheetPageProc,
                                pInfo->ulSelectedProfile)) {
                                ulNumPages++;
                            }
                        }
                    }
                }
            }
            LocalFree(pszProviderList);
        }
    }
    
    RegCloseKey(hKey);
    
    
    //
    // create the property sheet
    //
    PropHeader.dwSize      = sizeof(PROPSHEETHEADER);
    PropHeader.dwFlags     = PSH_PROPTITLE | PSH_NOAPPLYNOW;
    PropHeader.hwndParent  = hOwnerDlg;
    PropHeader.hInstance   = hInstance;
    PropHeader.pszIcon     = NULL;   //MAKEINTRESOURCE(DOCK_ICON);
    PropHeader.pszCaption  =
        pInfo->pHwProfValues[pInfo->ulSelectedProfileIndex].szFriendlyName;
    PropHeader.nPages      = ulNumPages;
    PropHeader.phpage      = hPages;
    PropHeader.nStartPage  = 0;
    PropHeader.pfnCallback = NULL;
    
    if (PropertySheet(&PropHeader) == 1) {
        bStatus = FALSE;
    } 
    else 
    {
        bStatus = TRUE;
    }
    
    //
    // cleanup extension page info
    //
    for (i = 1; i < ulNumPages; i++) {
        FreeLibrary(hLibs[i]);
    }
    
    return bStatus;
    
} // DisplayProperties



/**-------------------------------------------------------------------------**/
INT_PTR
APIENTRY
GeneralProfileDlg(
                  HWND    hDlg,
                  UINT    uMessage,
                  WPARAM  wParam,
                  LPARAM  lParam
                  )
                  
{
    PHWPROF_INFO      pInfo = NULL;
    PHWPROF_VALUES    pProfInfo = NULL;
    ULONG             ulReturn, ulIndex;
    
    switch (uMessage)
    {
    case WM_INITDIALOG:
        
        if (!lParam) {
            break;
        }
        
        //
        // on WM_INITDIALOG call, lParam points to the property sheet page.
        // The lParam field in the property sheet page struct is set by,
        // caller. When I created the property sheet, I passed in a pointer
        // to a HWPROF_INFO struct. Save this in the user window long so I
        // can access it on later messages.
        //
        pInfo = (PHWPROF_INFO)((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pInfo);
        
        pProfInfo = (PHWPROF_VALUES)(&(pInfo->pHwProfValues[pInfo->ulSelectedProfileIndex]));
        
        SetDlgItemText(hDlg, IDD_HWP_ST_PROFILE, pProfInfo->szFriendlyName);
        
        //
        // for pre-beta hwprofile code, the dockstate might have originally
        // been set to zero which is invalid, use 0x111 instead
        //
        if (pProfInfo->ulDockState == 0) {
            pProfInfo->ulDockState =
                DOCKINFO_USER_SUPPLIED | DOCKINFO_DOCKED | DOCKINFO_UNDOCKED;
        }
        
        //
        // initialize the dock state radio buttons
        //
        if ((pProfInfo->ulDockState & DOCKINFO_DOCKED) &&
            (pProfInfo->ulDockState & DOCKINFO_UNDOCKED)) {
            
            CheckRadioButton(hDlg, IDD_HWP_UNKNOWN, IDD_HWP_UNDOCKED, IDD_HWP_UNKNOWN);
        }
        else if (pProfInfo->ulDockState & DOCKINFO_DOCKED) {
            CheckRadioButton(hDlg, IDD_HWP_UNKNOWN, IDD_HWP_UNDOCKED, IDD_HWP_DOCKED);
        }
        else if (pProfInfo->ulDockState & DOCKINFO_UNDOCKED) {
            CheckRadioButton(hDlg, IDD_HWP_UNKNOWN, IDD_HWP_UNDOCKED, IDD_HWP_UNDOCKED);
        }
        else {
            CheckRadioButton(hDlg, IDD_HWP_UNKNOWN, IDD_HWP_UNDOCKED, IDD_HWP_UNKNOWN);
        }
        
        //
        // if the user-specified bit is not set then the dock state
        // was determined from the hardware so don't allow changing it
        //
        if (pProfInfo->ulDockState & DOCKINFO_USER_SUPPLIED) {
        }
        else {
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_PORTABLE), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_DOCKED), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNDOCKED), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNKNOWN), FALSE);
        }
        
        //
        // initialize the dock id and serial # static control
        //
        if (pProfInfo->szSerialNumber[0] &&
            (pProfInfo->szSerialNumber[0] != TEXT('0'))) {
            SetDlgItemText(hDlg, IDD_HWP_SERIALNUM, pProfInfo->szSerialNumber);
        }
        else {
            SetDlgItemText(hDlg, IDD_HWP_SERIALNUM, pszUnavailable);
        }
        
        if (pProfInfo->szDockID[0] &&
            (pProfInfo->szDockID[0] != TEXT('0'))) {
            SetDlgItemText(hDlg, IDD_HWP_DOCKID, pProfInfo->szDockID);
            //
            // if dock id is available then docking state is known
            // and cannot be over-ridden (this is a redundant check,
            // the dock state should be accurate)
            //
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_PORTABLE), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_DOCKED), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNDOCKED), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNKNOWN), FALSE);
        }
        else {
            SetDlgItemText(hDlg, IDD_HWP_DOCKID, pszUnavailable);
        }
        
        //
        // initialize the portable checkbox-groupbox
        //
        if (pInfo->bPortable) {
            CheckDlgButton(hDlg, IDD_HWP_PORTABLE, BST_CHECKED);
        }
        else {
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_DOCKED), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNDOCKED), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNKNOWN), FALSE);
        }
        
        //
        // Don't allow changing the global IsPortable Flag if it was determined
        // from the hardware
        //
        if (pInfo->bHwDetectedPortable) {
            EnableWindow(GetDlgItem(hDlg, IDD_HWP_PORTABLE), FALSE);
        }
        
        //
        // initialize the aliasable checkbox
        //
        if (pProfInfo->bAliasable) {
            CheckDlgButton(hDlg, IDD_HWP_ALIASABLE, BST_CHECKED);
        }
        else {
            CheckDlgButton(hDlg, IDD_HWP_ALIASABLE, BST_UNCHECKED);
        }
        
        SetFocus(GetDlgItem(hDlg, IDD_HWP_PORTABLE));
        return FALSE;
        
      case WM_DEVICECHANGE:
          //
          // If a hardware profile change event takes place while the dialog is
          // up, just dismiss the dialog because things have changed.
          //
          if (wParam == DBT_CONFIGCHANGED) {
              PropSheet_PressButton(GetParent(hDlg), PSBTN_CANCEL);
              return TRUE;
          }
          break;
          
      case WM_NOTIFY:
          
          if (!lParam) {
              break;
          }
          
          switch (((NMHDR *)lParam)->code) {
              
          case PSN_APPLY:
              
              pInfo = (PHWPROF_INFO)GetWindowLongPtr(hDlg, DWLP_USER);
              pProfInfo = (PHWPROF_VALUES)(&(pInfo->pHwProfValues[pInfo->ulSelectedProfileIndex]));
              
              //
              // unchecked --> checked case
              //
              if (!pInfo->bPortable && IsDlgButtonChecked(hDlg, IDD_HWP_PORTABLE)) {
                  pInfo->bPortable = TRUE;
              }
              //
              // checked --> unchecked case
              //
              else if (pInfo->bPortable && !IsDlgButtonChecked(hDlg, IDD_HWP_PORTABLE)) {
                  
                  TCHAR szCaption[MAX_PATH];
                  TCHAR szMsg[MAX_PATH];
                  
                  LoadString(hInstance, HWP_ERROR_CAPTION, szCaption, MAX_PATH);
                  LoadString(hInstance, HWP_CONFIRM_NOT_PORTABLE, szMsg, MAX_PATH);
                  
                  //
                  // confirm with user that other profiles will be set to unknown
                  //
                  if (MessageBox(hDlg, szMsg, szCaption,
                      MB_OKCANCEL | MB_ICONQUESTION) == IDCANCEL) {
                      
                      SetWindowLongPtr(hDlg, DWLP_MSGRESULT, TRUE);   // don't apply
                      return TRUE;
                  }
                  
                  for (ulIndex = 0; ulIndex < pInfo->ulNumProfiles; ulIndex++) {
                      
                      if (pInfo->pHwProfValues[ulIndex].ulDockState & 
                          DOCKINFO_USER_SUPPLIED) {
                          //
                          // only user-specified dock states will be changed
                          //
                          pInfo->pHwProfValues[ulIndex].ulDockState =
                              DOCKINFO_USER_SUPPLIED | DOCKINFO_DOCKED | DOCKINFO_UNDOCKED;
                          pInfo->pHwProfValues[ulIndex].ulAction = HWP_PROPERTIES;                           
                      }
                      
                  }
                  pInfo->bPortable = FALSE;
              }
              
              //
              // if user-specified dock state, then update the profile values
              // with current ui settings
              //
              if (pProfInfo->ulDockState & DOCKINFO_USER_SUPPLIED) {
                  
                  if (IsDlgButtonChecked(hDlg, IDD_HWP_DOCKED)) {
                      pProfInfo->ulDockState |= DOCKINFO_DOCKED;
                      pProfInfo->ulDockState &= ~DOCKINFO_UNDOCKED;
                  }
                  else if (IsDlgButtonChecked(hDlg, IDD_HWP_UNDOCKED)) {
                      pProfInfo->ulDockState |= DOCKINFO_UNDOCKED;
                      pProfInfo->ulDockState &= ~DOCKINFO_DOCKED;
                  }
                  else {
                      pProfInfo->ulDockState |= (DOCKINFO_UNDOCKED | DOCKINFO_DOCKED);
                  }
              }
              
              //
              // aliasable unchecked --> checked case
              //
              if (!pProfInfo->bAliasable && IsDlgButtonChecked(hDlg, IDD_HWP_ALIASABLE)) {
                  pProfInfo->bAliasable = TRUE;
              } 
              //
              // aliasable checked --> unchecked case
              //
              else if (pProfInfo->bAliasable && !IsDlgButtonChecked(hDlg, IDD_HWP_ALIASABLE)) {
                  pProfInfo->bAliasable = FALSE;
              } 
              
              //
              // commit the changes for this profile
              //
              pProfInfo->ulAction |= HWP_PROPERTIES;
              WriteProfileInfo(pProfInfo);
              
              SetWindowLongPtr(hDlg, DWLP_MSGRESULT, FALSE);   // TRUE if error
              break;
              
          case PSN_RESET:
              //
              // user canceled the property sheet
              //
              break;
          }
          break;
          
          
          case WM_HELP:
              WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, HELP_FILE,
                  HELP_WM_HELP, (DWORD_PTR)(LPTSTR)HwProfileHelpIds);
              break;
              
          case WM_CONTEXTMENU:
              WinHelp((HWND)wParam, HELP_FILE, HELP_CONTEXTMENU,
                  (DWORD_PTR)(LPTSTR)HwProfileHelpIds);
              break;
              
              
          case WM_COMMAND:
              {
                  switch (LOWORD(wParam))
                  {
                  case IDD_HWP_PORTABLE:
                      //
                      // if user chooses portable
                      //
                      if (!IsDlgButtonChecked(hDlg, IDD_HWP_PORTABLE)) {
                          CheckRadioButton(hDlg, IDD_HWP_UNKNOWN, IDD_HWP_UNDOCKED, IDD_HWP_UNKNOWN);
                          EnableWindow(GetDlgItem(hDlg, IDD_HWP_DOCKED), FALSE);
                          EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNDOCKED), FALSE);
                          EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNKNOWN), FALSE);
                      }
                      else {
                          EnableWindow(GetDlgItem(hDlg, IDD_HWP_DOCKED), TRUE);
                          EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNDOCKED), TRUE);
                          EnableWindow(GetDlgItem(hDlg, IDD_HWP_UNKNOWN), TRUE);
                      }
                      break;
                      
                  default:
                      return FALSE;
                  }
                  break;
                  
              } // case WM_COMMAND...
              
          default:
              return FALSE;
              break;
    }
    
    return TRUE;
    
} // GeneralProfileDlg
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\perf.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    perf.c

Abstract:

    Implements the Performance dialog of the System Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul
        
    10-Jul-2000 SilviuC
        Added the LargeSystemCache setting.    

--*/
#include <sysdm.h>
#include <help.h>

#define PROCESS_PRIORITY_SEPARATION_MASK    0x00000003
#define PROCESS_PRIORITY_SEPARATION_MAX     0x00000002
#define PROCESS_PRIORITY_SEPARATION_MIN     0x00000000

#define PROCESS_QUANTUM_VARIABLE_MASK       0x0000000c
#define PROCESS_QUANTUM_VARIABLE_DEF        0x00000000
#define PROCESS_QUANTUM_VARIABLE_VALUE      0x00000004
#define PROCESS_QUANTUM_FIXED_VALUE         0x00000008
#define PROCESS_QUANTUM_LONG_MASK           0x00000030
#define PROCESS_QUANTUM_LONG_DEF            0x00000000
#define PROCESS_QUANTUM_LONG_VALUE          0x00000010
#define PROCESS_QUANTUM_SHORT_VALUE         0x00000020

//
// Globals
//

HKEY  m_hKeyPerf = NULL;
TCHAR m_szRegPriKey[] = TEXT( "SYSTEM\\CurrentControlSet\\Control\\PriorityControl" );
TCHAR m_szRegPriority[] = TEXT( "Win32PrioritySeparation" );

HKEY  m_hKeyMemoryManagement = NULL;
TCHAR m_szRegMemoryManagementKey[] = TEXT( "SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Memory Management" );
TCHAR m_szRegLargeSystemCache[] = TEXT( "LargeSystemCache" );


//
// Help ID's
//

// ISSUE: SilviuC: 07/11/2000: IDC_PERF_CACHE_XXX should get help IDs when help is written

DWORD aPerformanceHelpIds[] =
{
    IDC_STATIC,                  NO_HELP,
    IDC_PERF_VM_ALLOCD,          (IDH_PERF + 1),
    IDC_PERF_VM_ALLOCD_LABEL,    (IDH_PERF + 1),
    IDC_PERF_GROUP,              NO_HELP,
    IDC_PERF_TEXT,               (IDH_PERF + 3),
    IDC_PERF_TEXT2,              NO_HELP,
    IDC_PERF_WORKSTATION,        (IDH_PERF + 4),
    IDC_PERF_SERVER,             (IDH_PERF + 5),
    IDC_PERF_VM_GROUP,           NO_HELP,
    IDC_PERF_VM_ALLOCD_TEXT,     NO_HELP,
    IDC_PERF_CHANGE,             (IDH_PERF + 7),
    IDC_PERF_CACHE_GROUP,        NO_HELP,
    IDC_PERF_CACHE_TEXT,         NO_HELP,
    IDC_PERF_CACHE_TEXT2,        NO_HELP,
    IDC_PERF_CACHE_APPLICATION,  (IDH_PERF + 14),
    IDC_PERF_CACHE_SYSTEM,       (IDH_PERF + 15),
    0, 0
};


INT_PTR
APIENTRY 
PerformanceDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles messages sent to Performance dialog

Arguments:

    hDlg -
        Supplies window handle

    uMsg -
        Supplies message being sent

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
    {
    static int    iNewChoice = 0;
    LONG   RegRes;
    DWORD  Type, Value, Length;
    DWORD  CacheType;
    DWORD  CacheValue = 0;
    DWORD  CacheLength;
    static int InitPos;
    static int InitRegVal, InitCacheRegVal;
    static int NewRegVal, NewCacheRegVal;
    static BOOL fVMInited = FALSE;
    static BOOL fTempPfWarningShown = FALSE;
    BOOL fTempPf;
    BOOL fWorkstationProduct = !IsOS(OS_ANYSERVER);
    BOOL fAdministrator = IsUserAnAdmin();
    BOOL fVariableQuanta = FALSE;
    BOOL fShortQuanta = FALSE;
    BOOL fFailedToOpenMmKey = FALSE;

    switch (uMsg)
    {
    case WM_INITDIALOG:

        InitPos = 0;
        InitRegVal = 0;
        InitCacheRegVal = 0;

        //
        // initialize from the registry
        //

        RegRes = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                               m_szRegPriKey,
                               0,
                               fAdministrator ? KEY_QUERY_VALUE | KEY_SET_VALUE : KEY_QUERY_VALUE,
                               &m_hKeyPerf );

        if (RegRes == ERROR_SUCCESS)
        {
            Length = sizeof( Value );
            RegRes = SHRegGetValue(m_hKeyPerf,
                                   NULL,
                                   m_szRegPriority,
                                   SRRF_RT_DWORD,
                                   &Type,
                                   (LPBYTE) &Value,
                                   &Length );

            if (RegRes == ERROR_SUCCESS)
            {
                InitRegVal = Value;
                InitPos = InitRegVal & PROCESS_PRIORITY_SEPARATION_MASK;
                if (InitPos > PROCESS_PRIORITY_SEPARATION_MAX)
                {
                    InitPos = PROCESS_PRIORITY_SEPARATION_MAX;
                }

            }
        }

        if ((RegRes != ERROR_SUCCESS) || (!fAdministrator))
        {
            EnableWindow(GetDlgItem(hDlg, IDC_PERF_WORKSTATION), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_PERF_SERVER), FALSE);
        }

        NewRegVal = InitRegVal;

        //
        // determine if we are using fixed or variable quantums
        //
        switch (InitRegVal & PROCESS_QUANTUM_VARIABLE_MASK)
        {
        case PROCESS_QUANTUM_VARIABLE_VALUE:
            fVariableQuanta = TRUE;
            break;

        case PROCESS_QUANTUM_FIXED_VALUE:
            fVariableQuanta = FALSE;
            break;

        case PROCESS_QUANTUM_VARIABLE_DEF:
        default:
            if (fWorkstationProduct)
            {
                fVariableQuanta = TRUE;
            }
            else
            {
                fVariableQuanta = FALSE;
            }
            break;
        }

        //
        // determine if we are using long or short
        //
        switch (InitRegVal & PROCESS_QUANTUM_LONG_MASK)
        {
        case PROCESS_QUANTUM_LONG_VALUE:
            fShortQuanta = FALSE;
            break;

        case PROCESS_QUANTUM_SHORT_VALUE:
            fShortQuanta = TRUE;
            break;

        case PROCESS_QUANTUM_LONG_DEF:
        default:
            if (fWorkstationProduct)
            {
                fShortQuanta = TRUE;
            }
            else
            {
                fShortQuanta = FALSE;
            }
            break;
        }

        //
        // Short, Variable Quanta == Workstation-like interactive response
        // Long, Fixed Quanta == Server-like interactive response
        //
        if (fVariableQuanta && fShortQuanta)
        {
            iNewChoice = PROCESS_PRIORITY_SEPARATION_MAX;

            CheckRadioButton(
                            hDlg,
                            IDC_PERF_WORKSTATION,
                            IDC_PERF_SERVER,
                            IDC_PERF_WORKSTATION
                            );
        } // if
        else
        {
            iNewChoice = PROCESS_PRIORITY_SEPARATION_MIN;

            CheckRadioButton(
                            hDlg,
                            IDC_PERF_WORKSTATION,
                            IDC_PERF_SERVER,
                            IDC_PERF_SERVER
                            );
        } // else


        //
        // Initialize the `memory usage' part.
        //

        fFailedToOpenMmKey = FALSE;

        RegRes = RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                               m_szRegMemoryManagementKey,
                               0,
                               fAdministrator ? KEY_QUERY_VALUE | KEY_SET_VALUE : KEY_QUERY_VALUE,
                               &m_hKeyMemoryManagement );

        if (RegRes == ERROR_SUCCESS)
        {
            CacheValue = 0;
            CacheLength = sizeof( CacheValue );

            RegRes = SHRegGetValue( m_hKeyMemoryManagement,
                                    NULL,
                                    m_szRegLargeSystemCache,
                                    SRRF_RT_DWORD,
                                    &CacheType,
                                    (LPBYTE) &CacheValue,
                                    &CacheLength );

            if (RegRes == ERROR_SUCCESS && CacheValue != 0)
            {
                CheckRadioButton(hDlg,
                                 IDC_PERF_CACHE_APPLICATION,
                                 IDC_PERF_CACHE_SYSTEM,
                                 IDC_PERF_CACHE_SYSTEM);
            }
            else
            {
                CheckRadioButton(hDlg,
                                 IDC_PERF_CACHE_APPLICATION,
                                 IDC_PERF_CACHE_SYSTEM,
                                 IDC_PERF_CACHE_APPLICATION);
            }
        }
        else
        {
            fFailedToOpenMmKey = TRUE;
        }

        if (fFailedToOpenMmKey || (!fAdministrator))
        {
            CheckRadioButton(hDlg,
                             IDC_PERF_CACHE_APPLICATION,
                             IDC_PERF_CACHE_SYSTEM,
                             IDC_PERF_CACHE_APPLICATION);

            EnableWindow(GetDlgItem(hDlg, IDC_PERF_CACHE_APPLICATION), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_PERF_CACHE_SYSTEM), FALSE);
        }


        InitCacheRegVal = CacheValue;
        NewCacheRegVal = CacheValue;

        //
        // Init the virtual memory part
        //
        if (VirtualInitStructures())
        {
            fVMInited = TRUE;
            SetDlgItemMB( hDlg, IDC_PERF_VM_ALLOCD, VirtualMemComputeAllocated(hDlg, &fTempPf) );
            //
            // If the system created a temp pagefile, warn the user that
            // the total pagefile size may appear a bit large, but only
            // do so once per System Applet invokation.
            //
            if (fTempPf && !fTempPfWarningShown)
            {
                MsgBoxParam(
                           hDlg,
                           IDS_TEMP_PAGEFILE_WARN,
                           IDS_SYSDM_TITLE,
                           MB_ICONINFORMATION | MB_OK
                           );
                fTempPfWarningShown = TRUE;
            } // if (fTempPf...
        }
        break;

    case WM_DESTROY:
        //
        // If the dialog box is going away, then close the
        // registry key.
        //


        if (m_hKeyPerf)
        {
            RegCloseKey( m_hKeyPerf );
            m_hKeyPerf = NULL;
        }

        if (m_hKeyMemoryManagement)
        {
            RegCloseKey( m_hKeyMemoryManagement );
            m_hKeyMemoryManagement = NULL;
        }

        if (fVMInited)
        {
            VirtualFreeStructures();
        }
        break;


    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
        case PSN_APPLY:
            // 
            // Save new time quantum stuff, if it has changed
            //
            NewRegVal &= ~PROCESS_PRIORITY_SEPARATION_MASK;
            NewRegVal |= iNewChoice;

            if (NewRegVal != InitRegVal)
            {
                Value = NewRegVal;

                if (m_hKeyPerf)
                {
                    Type = REG_DWORD;
                    Length = sizeof( Value );
                    RegSetValueEx( m_hKeyPerf,
                                   m_szRegPriority,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE) &Value,
                                   Length );
                    InitRegVal = Value;

                    //
                    // Kernel monitors this part of the 
                    // registry, so don't tell user he has to reboot
                    //
                }
            }

            //
            // Save `LargeSystemCache' if value changed
            //

            if (InitCacheRegVal != NewCacheRegVal) {

                CacheValue = NewCacheRegVal;

                if (m_hKeyMemoryManagement) {
                    CacheType = REG_DWORD;
                    CacheLength = sizeof( CacheValue );
                    RegSetValueEx( m_hKeyMemoryManagement,
                                   m_szRegLargeSystemCache,
                                   0,
                                   REG_DWORD,
                                   (LPBYTE) &CacheValue,
                                   CacheLength );

                    InitCacheRegVal = CacheValue;

                    //
                    // Request a reboot if things changed
                    //

                    MsgBoxParam(
                               hDlg,
                               IDS_SYSDM_RESTART,
                               IDS_SYSDM_TITLE,
                               MB_OK | MB_ICONINFORMATION
                               );

                    g_fRebootRequired = TRUE;
                }
            }
            break;
        }
        break;

    case WM_COMMAND:
        {
            BOOL fEnableApply = (LOWORD(wParam) != IDC_PERF_CHANGE);

            LRESULT lres;

            switch (LOWORD(wParam))
            {
            case IDC_PERF_CHANGE:
                {
                    lres = DialogBox(
                                    hInstance, 
                                    MAKEINTRESOURCE(DLG_VIRTUALMEM),
                                    hDlg, 
                                    VirtualMemDlg
                                    );

                    if (fVMInited)
                    {
                        SetDlgItemMB(
                                    hDlg, 
                                    IDC_PERF_VM_ALLOCD, 
                                    VirtualMemComputeAllocated(hDlg, NULL) 
                                    );
                    }
                    if (lres != RET_NO_CHANGE)
                    {
                        fEnableApply = TRUE;

                        if (lres != RET_CHANGE_NO_REBOOT)
                        {
                            MsgBoxParam(
                                       hDlg,
                                       IDS_SYSDM_RESTART,
                                       IDS_SYSDM_TITLE,
                                       MB_OK | MB_ICONINFORMATION
                                       );

                            g_fRebootRequired = TRUE;
                        }
                    }
                }
                break;

            case IDC_PERF_WORKSTATION:
                if (BN_CLICKED == HIWORD(wParam))
                {
                    //
                    // Workstations have maximum foreground boost
                    //
                    iNewChoice = PROCESS_PRIORITY_SEPARATION_MAX;

                    //
                    // Workstations have variable, short quanta
                    NewRegVal &= ~PROCESS_QUANTUM_VARIABLE_MASK;
                    NewRegVal |= PROCESS_QUANTUM_VARIABLE_VALUE;
                    NewRegVal &= ~PROCESS_QUANTUM_LONG_MASK;
                    NewRegVal |= PROCESS_QUANTUM_SHORT_VALUE;
                } // if    
                break;

            case IDC_PERF_SERVER:
                if (BN_CLICKED == HIWORD(wParam))
                {
                    //
                    // Servers have minimum foreground boost
                    //
                    iNewChoice = PROCESS_PRIORITY_SEPARATION_MIN;

                    //
                    // Servers have fixed, long quanta
                    //
                    NewRegVal &= ~PROCESS_QUANTUM_VARIABLE_MASK;
                    NewRegVal |= PROCESS_QUANTUM_FIXED_VALUE;
                    NewRegVal &= ~PROCESS_QUANTUM_LONG_MASK;
                    NewRegVal |= PROCESS_QUANTUM_LONG_VALUE;
                } // if
                break;

            case IDC_PERF_CACHE_APPLICATION:
                if (BN_CLICKED == HIWORD(wParam))
                {
                    NewCacheRegVal = 0;
                } // if    
                break;

            case IDC_PERF_CACHE_SYSTEM:
                if (BN_CLICKED == HIWORD(wParam))
                {
                    NewCacheRegVal = 1;
                } // if
                break;
            }

            if (fEnableApply)
            {
                // Enable the "Apply" button because changes have happened.
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
            }
        }
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
                (DWORD_PTR) (LPSTR) aPerformanceHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
                (DWORD_PTR) (LPSTR) aPerformanceHelpIds);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\pfrscpl.h ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    pfrscpl.h

Abstract:
    Implements fault reporting for unhandled exceptions

Revision History:
    created     derekm      08/07/00

******************************************************************************/

#ifndef PFRSCPL_H
#define PFRSCPL_H

INT_PTR APIENTRY PFRDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
BOOL LoadPFRResourceStrings(void);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\perf.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    perf.h

Abstract:

    Public declarations for the Performance dialog of the 
    System Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#ifndef _SYSDM_PERF_H_
#define _SYSDM_PERF_H_

//
//  Reboot switch for crashdump dlg
//

#define RET_ERROR               (-1)
#define RET_NO_CHANGE           0x00
#define RET_VIRTUAL_CHANGE      0x01
#define RET_RECOVER_CHANGE      0x02
#define RET_CHANGE_NO_REBOOT    0x04
#define RET_CONTINUE            0x08
#define RET_BREAK               0x10

#define RET_VIRT_AND_RECOVER (RET_VIRTUAL_CHANGE | RET_RECOVER_CHANGE)



//
// Public function declarations
//
HPROPSHEETPAGE 
CreatePerformancePage(
    IN HINSTANCE hInst
);

INT_PTR 
APIENTRY 
PerformanceDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);

#endif // _SYSDM_PERF_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\pfrscpl.cpp ===
/******************************************************************************

Copyright (c) 2000 Microsoft Corporation

Module Name:
    pfrscpl.cpp

Abstract:
    Implements fault reporting for unhandled exceptions

Revision History:
    created     derekm      08/07/00

******************************************************************************/

#include "sysdm.h"
#include <commctrl.h>
#include <commdlg.h>
#include <debug.h>
#include "pfrscpl.h"
#include "pfrcfg.h"
#include "help.h"
#include "resource.h"
#include "malloc.h"
#include "windowsx.h"

///////////////////////////////////////////////////////////////////////////////
// data structures

#define KERNELLI        1
#define PROGLI          2
#define EXWINCOMP       0x80000000
#define EXALLMS         0x40000000
#define EXNOREM         0xc0000000 // EXWINCOMP | EXALLMS
#define WM_SETEIELVSEL  WM_APP

const DWORD c_dxLVChkPixels = 30;

struct SAddDlg
{
    WCHAR   wszApp[MAX_PATH];
};

struct SMainDlg
{
    CPFFaultClientCfg   *pcfg;
    EEnDis              eedReport;
    EEnDis              eedShowUI;
    EIncEx              eieKernel;
    EIncEx              eieApps;
    EIncEx              eieShut;
    DWORD               iLastSel;
    BOOL                fRW;
    BOOL                fForceQueue;
};

struct SProgDlg
{
    CPFFaultClientCfg   *pcfg;
    EIncEx              eieApps;
    EIncEx              eieMS;
    EIncEx              eieWinComp;
    DWORD               iLastSelE;
    DWORD               iLastSelI;
    DWORD               cchMax;
    DWORD               cxMaxE;
    DWORD               cxMaxI;
    BOOL                fRW;
    BOOL                fShowIncRem;
};

///////////////////////////////////////////////////////////////////////////////
// Global stuff

// help IDs
static DWORD g_rgPFER[] = 
{
    IDC_STATIC,         NO_HELP,
    IDC_PFR_EXADD,      (IDH_PFR),
    IDC_PFR_EXREM,      (IDH_PFR + 1),
    IDC_PFR_INCADD,     (IDH_PFR + 2),
    IDC_PFR_INCREM,     (IDH_PFR + 3),
    IDC_PFR_DISABLE,    (IDH_PFR + 4),
    IDC_PFR_ENABLE,     (IDH_PFR + 5),
    IDC_PFR_ENABLEOS,   (IDH_PFR + 6),
    IDC_PFR_ENABLEPROG, (IDH_PFR + 6),
    IDC_PFR_DETAILS,    (IDH_PFR + 7),
    IDC_PFR_INCLIST,    (IDH_PFR + 10),
    IDC_PFR_NEWPROG,    (IDH_PFR + 11),
    IDC_PFR_BROWSE,     (IDH_PFR + 13),
    IDC_PFR_EXLIST,     (IDH_PFR + 14),
    IDC_PFR_SHOWUI,     (IDH_PFR + 15),
    IDC_PFR_DEFALL,     (IDH_PFR + 16),
    IDC_PFR_DEFNONE,    (IDH_PFR + 16),
    IDC_PFR_ENABLESHUT, (IDH_PFR + 17),
    IDC_PFR_FORCEQ,     (IDH_PFR + 18),
    0, 0
};

// resource strings
TCHAR   g_szWinComp[256]    = { TEXT('\0') };
TCHAR   g_szOk[256]         = { TEXT('\0') };
WCHAR   g_wszTitle[256]     = { L'\0' };
WCHAR   g_wszFilter[256]    = { L'\0' };
WCHAR   g_wszMSProg[256]    = { L'\0' };



///////////////////////////////////////////////////////////////////////////////
// utility functions

// **************************************************************************
BOOL LoadPFRResourceStrings(void)
{
    LoadString(hInstance, IDS_PFR_WINCOMP, g_szWinComp, ARRAYSIZE(g_szWinComp));
    LoadString(hInstance, IDS_PFR_OK, g_szOk, ARRAYSIZE(g_szOk));
    LoadStringW(hInstance, IDS_PFR_FILTER, g_wszFilter, ARRAYSIZE(g_wszFilter)); 
    LoadStringW(hInstance, IDS_PFR_MSPROG, g_wszMSProg, ARRAYSIZE(g_wszMSProg));
    LoadStringW(hInstance, IDS_PFR_TITLE, g_wszTitle, ARRAYSIZE(g_wszTitle));
    return TRUE;
}

// **************************************************************************
static BOOL InitializePFLV(EPFListType epflt, HWND hlc, DWORD *pcchMax,
                           DWORD *pcxMax, CPFFaultClientCfg *pcfg)
{
    LVCOLUMN    lvc;
    LVITEMW     lvi;
    HRESULT     hr;
    LPWSTR      wszApp;
    DWORD       dwExStyle, i, cchApps, cApps, dwChecked, cxMax;
    RECT        rect;
    int         iList;

    if (pcchMax == NULL || pcfg == NULL || hlc == NULL || pcxMax == NULL)
        return FALSE;

    // set up the list control
    SendMessage(hlc, LVM_SETUNICODEFORMAT, TRUE, 0);
    dwExStyle = (LVS_EX_CHECKBOXES | LVS_EX_FULLROWSELECT);
    SendMessage(hlc, LVM_SETEXTENDEDLISTVIEWSTYLE, dwExStyle, dwExStyle);

    GetClientRect(hlc, &rect);
    *pcxMax = rect.right - GetSystemMetrics(SM_CYHSCROLL);


    ZeroMemory(&lvc, sizeof(lvc));
    lvc.mask = LVCF_FMT;
    lvc.fmt  = LVCFMT_LEFT;
    ListView_InsertColumn(hlc, 0, &lvc); 

    hr = pcfg->InitList(epflt);
    if (FAILED(hr))
        return FALSE;

    hr = pcfg->get_ListRegInfo(epflt, &cchApps, &cApps);
    if (FAILED(hr))
        return FALSE;

    cchApps++;
    if (cchApps > *pcchMax)
        *pcchMax = cchApps;

    __try 
    {
        wszApp = (LPWSTR)_alloca(cchApps * sizeof(WCHAR));
    }
    __except (GetExceptionCode() == STATUS_STACK_OVERFLOW) 
    {
        wszApp = NULL;
        _resetstkoflw();    
    }

    if (wszApp == NULL)
        return FALSE;

    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask       = LVIF_PARAM | LVIF_TEXT | LVIF_STATE;
    lvi.stateMask  = LVIS_STATEIMAGEMASK;
    lvi.state      = 0;
    lvi.pszText    = wszApp;

    for (i = 0; i < cApps; i++)
    {
        hr = pcfg->get_ListRegApp(epflt, i, wszApp, cchApps + 1, &dwChecked);
        if (FAILED(hr))
            return FALSE;

        cxMax = (DWORD)SendMessageW(hlc, LVM_GETSTRINGWIDTHW, 0, (LPARAM)wszApp);
        cxMax += c_dxLVChkPixels;
        if (cxMax > *pcxMax)
            *pcxMax = cxMax;

        lvi.iItem  = i;
        lvi.lParam = 1 + ((dwChecked == 1) ? 1 : 0);
        iList = (int)SendMessageW(hlc, LVM_INSERTITEMW, 0, (LPARAM)&lvi);
        if (iList >= 0)
            ListView_SetCheckState(hlc, iList, (dwChecked == 1));
    }

    ListView_SetColumnWidth(hlc, 0, *pcxMax);

    if (cApps > 0)
    {
        ListView_SetItemState(hlc, 0, LVIS_FOCUSED | LVIS_SELECTED,
                              LVIS_FOCUSED | LVIS_SELECTED);
    }

    return TRUE;
}



///////////////////////////////////////////////////////////////////////////////
// Add Program dialog proc

// **************************************************************************
static UINT_PTR CALLBACK OFNHookProc(HWND hdlg, UINT uMsg, WPARAM wParam, 
                                     LPARAM lParam)
{
    HWND hwndFile;

    switch(uMsg)
    {
        case WM_INITDIALOG:
            hwndFile = GetParent(hdlg);
            if (hwndFile != NULL)
                SendMessage(hwndFile, CDM_SETCONTROLTEXT, IDOK, (LPARAM)g_szOk);

            return TRUE;

        default:
            return FALSE;
    }

    return FALSE;
}

// **************************************************************************
#define LAUNCHOFN_OFFSET    10

static BOOL LaunchOFNDialog(HWND hdlg, LPWSTR wszFile, DWORD cchFile)
{
    OPENFILENAMEW   ofn;
    WCHAR           wszFilePath[2 * MAX_PATH];
    WCHAR           wszInitalDir[] = L"\\";
    WCHAR           wszFilter[MAX_PATH], *pwsz;
    DWORD           dw;

    if (wszFile == NULL || cchFile == 0)
    {
        return FALSE;
    }

    // the filter string needs to be of the form <Description>\0<Extension>\0\0
    ZeroMemory(wszFilter, sizeof(wszFilter));
    
    COMPILETIME_ASSERT(sizeof(wszFilter) >= sizeof(g_wszFilter)); // should always be bigger
    
    StringCchCopy(wszFilter, ARRAYSIZE(wszFilter), g_wszFilter);

    dw = wcslen(g_wszFilter);
    if (dw < (ARRAYSIZE(wszFilter) - LAUNCHOFN_OFFSET))
    {
        pwsz = wszFilter + dw + 1;
    }
    else
    {
        pwsz = wszFilter + ARRAYSIZE(wszFilter) - LAUNCHOFN_OFFSET;
        ZeroMemory(pwsz, LAUNCHOFN_OFFSET * sizeof(WCHAR));
        pwsz++;
    }
    
    EVAL(SUCCEEDED(StringCchCopy(pwsz, LAUNCHOFN_OFFSET, L"*.exe"))); // should always be room

    wszFilePath[0] = L'\0';
    ZeroMemory(&ofn, sizeof(ofn));
    
    ofn.lStructSize     = sizeof(ofn);
    ofn.hwndOwner       = hdlg;
    ofn.lpstrFilter     = wszFilter;
    ofn.lpstrFile       = wszFilePath;
    ofn.nMaxFile        = ARRAYSIZE(wszFilePath);
    ofn.lpstrFileTitle  = wszFile;
    ofn.nMaxFileTitle   = cchFile;
    ofn.lpstrInitialDir = wszInitalDir;
    ofn.lpstrTitle      = g_wszTitle;
    ofn.Flags           = OFN_DONTADDTORECENT | OFN_ENABLESIZING | 
                          OFN_EXPLORER | OFN_FILEMUSTEXIST | 
                          OFN_HIDEREADONLY | OFN_NOCHANGEDIR | 
                          OFN_PATHMUSTEXIST | OFN_SHAREAWARE;
    ofn.lpstrDefExt     = NULL;
    ofn.lpfnHook        = OFNHookProc;

    // get the filename & fill in the edit box with it
    return GetOpenFileNameW(&ofn);
}

// **************************************************************************
static INT_PTR APIENTRY PFRAddDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, 
                                      LPARAM lParam)
{
    BOOL fShowErr = FALSE;
    
    switch (uMsg)
    {
        case WM_INITDIALOG:
            {
                HWND    hbtn;

                SetWindowLongPtr(hdlg, DWLP_USER, lParam);

                // disable the ok button cuz we know that we don't have anything
                //  in the 'filename' edit box
                hbtn = GetDlgItem(hdlg, IDOK);
                if (hbtn != NULL)
                    EnableWindow(hbtn, FALSE);
            }

            break;

        // F1 help
        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, 
                    HELP_FILE, HELP_WM_HELP, (DWORD_PTR)g_rgPFER);
            break;

        // right-click help
        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, HELP_FILE, HELP_CONTEXTMENU,
                    (DWORD_PTR)g_rgPFER);
            break;
    
        case WM_COMMAND:
            switch (LOWORD(wParam)) 
            {
                // browse button
                case IDC_PFR_BROWSE:
                {
                    WCHAR   wszFile[2 * MAX_PATH];

                    // get the filename & fill in the edit box with it
                    if (LaunchOFNDialog(hdlg, wszFile, ARRAYSIZE(wszFile)))
                        SetDlgItemTextW(hdlg, IDC_PFR_NEWPROG, wszFile);

                    break;
                }

                // Ok button
                case IDOK:
                {
                    SAddDlg *psad;

                    psad = (SAddDlg *)GetWindowLongPtr(hdlg, DWLP_USER);
                    if (psad != NULL)
                    {
                        WCHAR *wszText, *pwsz;
                        DWORD cch;
                        HWND  hwndText;
                        BOOL  fReplaceWSpace = TRUE;

                        hwndText = GetDlgItem(hdlg, IDC_PFR_NEWPROG);
                        if (hwndText == NULL)
                        {
                            fShowErr = TRUE;
                            goto done;
                        }

                        cch = GetWindowTextLength(hwndText);
                        if (cch == 0)
                        {
                            fShowErr = TRUE;
                            goto done;
                        }

                        cch++;

                        __try 
                        {
                            wszText = (LPWSTR)_alloca(cch * sizeof(WCHAR));
                        } 
                        __except (GetExceptionCode() == STATUS_STACK_OVERFLOW) 
                        {
                            wszText = NULL;
                            _resetstkoflw();    
                        }

                        if (wszText == NULL)
                        {
                            fShowErr = TRUE;
                            goto done;
                        }

                        *psad->wszApp = L'\0';
                        *wszText      = L'\0';
                        GetDlgItemTextW(hdlg, IDC_PFR_NEWPROG, wszText, cch);
                        
                        // make sure that we only have the exe name-  probably
                        //  should verify that it IS an exe, but it's possible
                        //  we'd want to trap on other file types as well, so
                        //  don't for now.
                        // And while we're at it, rip off any trailing 
                        //  whitespace (preceeding whitespace is apparently ok)
                        cch = wcslen(wszText);
                        if (cch > 0)
                        {
                            for(pwsz = wszText + cch - 1; pwsz > wszText; pwsz--)
                            {
                                if (fReplaceWSpace)
                                {
                                    if (iswspace(*pwsz))
                                        *pwsz = L'\0';
                                    else
                                        fReplaceWSpace = FALSE;
                                }

                                if (*pwsz == L'\\')
                                {
                                    pwsz++;
                                    break;
                                }
                            }

                            if (*pwsz == L'\\')
                                pwsz++;
                        }

                        cch = wcslen(pwsz);
                        if (cch >= MAX_PATH || cch == 0)
                        {
                            fShowErr = TRUE;
                            goto done;
                        }

                        if (FAILED(StringCchCopy(psad->wszApp, ARRAYSIZE(psad->wszApp), pwsz)))
                        {
                            psad->wszApp[0] = L'\0';
                        }
                    }

                    EndDialog(hdlg, IDOK);
                    break;
                }
            
                // cancel button
                case IDCANCEL:
                    EndDialog(hdlg, IDCANCEL);
                    break;

                case IDC_PFR_NEWPROG:
                    if (HIWORD(wParam) == EN_CHANGE)
                    {
                        HWND    hbtn, hedt;
                        
                        hbtn = GetDlgItem(hdlg, IDOK);
                        hedt = (HWND)(DWORD_PTR)lParam;
                        if (hedt != NULL && hbtn != NULL)
                        {
                            if (GetWindowTextLength(hedt) != 0)
                                EnableWindow(hbtn, TRUE);
                            else
                                EnableWindow(hbtn, FALSE);
                        }
                    }
                    break;
                              
                // return FALSE to indicate that we didn't handle the msg
                default:
                    return FALSE;
            }
            break;

        // return FALSE to indicate that we didn't handle the msg
        default:
            return FALSE;
    }


done:
    if (fShowErr)
    {
        TCHAR szMsg[256];

        LoadString(hInstance, IDS_PFR_BADFILE, szMsg, ARRAYSIZE(szMsg));
        MessageBox(hdlg, szMsg, NULL, MB_OK | MB_ICONERROR);
    }

    
    return FALSE;
}

///////////////////////////////////////////////////////////////////////////////
// Programs dialog proc

// **************************************************************************
static BOOL InitProgDlg(HWND hdlg, SProgDlg *pspd)
{
    CPFFaultClientCfg   *pcfg;
    LVITEMW             lvi;
    DWORD               cxMax;
    HWND                hlc, hbtn;
    BOOL                fRet = FALSE;
    int                 iList, cItems;

    if (pspd == NULL)
        goto done;

    pcfg = pspd->pcfg;

    // fill in the exclude list
    hlc = GetDlgItem(hdlg, IDC_PFR_EXLIST);
    if (hlc == NULL)
        goto done;

    if (InitializePFLV(epfltExclude, hlc, &pspd->cchMax, &pspd->cxMaxE,
                       pcfg) == FALSE)
        goto done;

    // fill in the include list
    hlc = GetDlgItem(hdlg, IDC_PFR_INCLIST);
    if (hlc == NULL)
        goto done;

    if (InitializePFLV(epfltInclude, hlc, &pspd->cchMax, &pspd->cxMaxI, 
                       pcfg) == FALSE)
        goto done;


    pspd->fShowIncRem = TRUE;

    // add the item to the include list that lets users include all MS apps
    pspd->eieMS = pcfg->get_IncMSApps();

    // Note that we set lParam to 1 or 2.  This is because we need to ignore 
    //  the first notification message for the list item + the 2nd one if the
    //  check state is set.  Processing these two messages leads to corruption
    //  in the configuration settings    
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask      = LVIF_PARAM | LVIF_TEXT | LVIF_STATE;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    lvi.state     = 0;
    lvi.pszText   = g_wszMSProg;
    lvi.iItem     = 0;
    lvi.lParam    = (1 + ((pspd->eieMS == eieInclude) ? 1 : 0)) | EXALLMS;
    iList = (int)SendMessageW(hlc, LVM_INSERTITEMW, 0, (LPARAM)&lvi);
    if (iList >= 0)
        ListView_SetCheckState(hlc, iList, (pspd->eieMS == eieInclude));

    cxMax = (DWORD)SendMessageW(hlc, LVM_GETSTRINGWIDTHW, 0, (LPARAM)g_wszMSProg);
    cxMax += c_dxLVChkPixels;
    if (cxMax > pspd->cxMaxI)
    {
        pspd->cxMaxI = cxMax;
        ListView_SetColumnWidth(hlc, 0, cxMax);
    }

    // add the item to the include list that lets users exclude all windows
    //  components
    pspd->eieWinComp = pcfg->get_IncWinComp();

    // Note that we set lParam to 1 or 2.  This is because we need to ignore 
    //  the first notification message for the list item + the 2nd one if the
    //  check state is set.  Processing these two messages leads to corruption
    //  in the configuration settings    
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask      = LVIF_PARAM | LVIF_TEXT | LVIF_STATE;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    lvi.state     = 0;
    lvi.pszText   = g_szWinComp;
    lvi.iItem     = 1;
    lvi.lParam    = (1 + ((pspd->eieWinComp == eieInclude) ? 1 : 0)) | EXWINCOMP;
    iList = (int)SendMessageW(hlc, LVM_INSERTITEMW, 0, (LPARAM)&lvi);
    if (iList >= 0)
        ListView_SetCheckState(hlc, iList, (pspd->eieWinComp == eieInclude));

    cxMax = (DWORD)SendMessageW(hlc, LVM_GETSTRINGWIDTHW, 0, (LPARAM)g_szWinComp);
    cxMax += c_dxLVChkPixels;
    if (cxMax > pspd->cxMaxI)
    {
        pspd->cxMaxI = cxMax;
        ListView_SetColumnWidth(hlc, 0, cxMax);
    }

    // do misc setup on the exclusion list (disabling the remove button, 
    //  setting the initial focus)
    hlc = GetDlgItem(hdlg, IDC_PFR_EXLIST);
    cItems = ListView_GetItemCount(hlc);
    if (cItems == 0)
    {
        hbtn = GetDlgItem(hdlg, IDC_PFR_EXREM);
        if (hbtn != NULL)
            EnableWindow(hbtn, FALSE);
    }
    else
    {
        ListView_SetItemState(hlc, 0, LVIS_FOCUSED | LVIS_SELECTED,
                              LVIS_FOCUSED | LVIS_SELECTED);
    }

    // do misc setup on the inclusion list (disabling the remove button, 
    //  setting the initial focus)
    hlc = GetDlgItem(hdlg, IDC_PFR_INCLIST);
    ListView_SetItemState(hlc, 0, LVIS_FOCUSED | LVIS_SELECTED,
                          LVIS_FOCUSED | LVIS_SELECTED);
    
    cItems = ListView_GetItemCount(hlc);
    if (cItems < 3)
    {
        hbtn = GetDlgItem(hdlg, IDC_PFR_INCREM);
        if (hbtn != NULL)
            EnableWindow(hbtn, FALSE);

        pspd->fShowIncRem = FALSE;
    }
    
    // set up the radio buttons- if we are in 'include all' mode, then
    //  we don't need the inclusion list.
    if (((DWORD)pspd->eieApps & eieIncMask) == eieInclude)
    {
        CheckDlgButton(hdlg, IDC_PFR_DEFALL, BST_CHECKED);
        CheckDlgButton(hdlg, IDC_PFR_DEFNONE, BST_UNCHECKED);

        hlc = GetDlgItem(hdlg, IDC_PFR_INCLIST);
        if (hlc != NULL)
            EnableWindow(hlc, FALSE);
        hbtn = GetDlgItem(hdlg, IDC_PFR_INCREM);
        if (hbtn != NULL)
            EnableWindow(hbtn, FALSE);
        hbtn = GetDlgItem(hdlg, IDC_PFR_INCADD);
        if (hbtn != NULL)
            EnableWindow(hbtn, FALSE);
    }
    else
    {
        CheckDlgButton(hdlg, IDC_PFR_DEFALL, BST_UNCHECKED);
        CheckDlgButton(hdlg, IDC_PFR_DEFNONE, BST_CHECKED);
        EnableWindow(hlc, TRUE);
    }

    fRet = TRUE;

done:
    if (fRet == FALSE)
    {
        TCHAR   szMsg[MAX_PATH];
        LoadString(hInstance, IDS_PFR_CFGREADERR, szMsg, ARRAYSIZE(szMsg));
        MessageBox(hdlg, szMsg, NULL, MB_OK | MB_ICONERROR);
    }

    return fRet;
}

// **************************************************************************
static BOOL AddProgramToList(HWND hdlg, HWND hlc, SProgDlg *pspd,
                             EPFListType epflt)
{
    CPFFaultClientCfg   *pcfg = NULL;
    HRESULT             hr;
    SAddDlg             sad;
    LVITEMW             lvi;
    DWORD               cch, cxMax, *pcxMax;
    TCHAR               szMsg[256];
    HWND                hbtn;
    int                 nID, cItems;

    if (pspd == NULL)
        return FALSE;

    pcfg = pspd->pcfg;

    ZeroMemory(&sad, sizeof(sad));
    nID = (int)DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_PFR_ADDPROG), 
                              hdlg, PFRAddDlgProc, (LPARAM)&sad);
    if (nID == IDCANCEL || sad.wszApp[0] == L'\0')
        return FALSE;

    if (pcfg->IsOnList(epfltInclude, sad.wszApp))
    {
        LoadString(hInstance, IDS_PFR_ISONLISTI, szMsg, ARRAYSIZE(szMsg));
        if (epflt == epfltExclude)
        {
            TCHAR   szTmp[256];
            LoadString(hInstance, IDS_PFR_ADDTOEX, szTmp, ARRAYSIZE(szTmp));
            StringCchCat(szMsg, ARRAYSIZE(szMsg), szTmp); // display string, truncation ok
        }

        MessageBox(hdlg, szMsg, NULL, MB_OK | MB_ICONERROR);
        return FALSE;
    }

    else if (pcfg->IsOnList(epfltExclude, sad.wszApp))
    {
        LoadString(hInstance, IDS_PFR_ISONLISTE, szMsg, ARRAYSIZE(szMsg));
        if (epflt == epfltInclude)
        {
            TCHAR   szTmp[256];
            LoadString(hInstance, IDS_PFR_ADDTOINC, szTmp, ARRAYSIZE(szTmp));
            StringCchCat(szMsg, ARRAYSIZE(szMsg), szTmp); // display string, truncation ok
        }

        MessageBox(hdlg, szMsg, NULL, MB_OK | MB_ICONERROR);
        return FALSE;
    }

    cItems = ListView_GetItemCount(hlc);

    // update the max string size if necessary
    cch = wcslen(sad.wszApp);
    if (cch >= pspd->cchMax)
        pspd->cchMax = cch + 1;

    // yay!  add it to the config class
    hr = pcfg->add_ListApp(epflt, sad.wszApp);
    if (FAILED(hr))
        return FALSE;

    pcxMax = (epflt == epfltInclude) ? &pspd->cxMaxI : &pspd->cxMaxE;
    cxMax = (DWORD)SendMessageW(hlc, LVM_GETSTRINGWIDTHW, 0, (LPARAM)sad.wszApp);
    cxMax += c_dxLVChkPixels;
    if (cxMax > *pcxMax)
    {
        *pcxMax = cxMax;
        ListView_SetColumnWidth(hlc, 0, cxMax);
    }

    // add it to the UI
    //  Note that we set lParam to 2.  This is because we need to ignore the 
    //   first two notification messages per entry sent to the wndproc because
    //   they are 'list initialization' messages and processing them leads to
    //   corruption in the configuration settings
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.mask      = LVIF_PARAM | LVIF_TEXT | LVIF_STATE;
    lvi.stateMask = LVIS_STATEIMAGEMASK;
    lvi.state     = 0;
    lvi.pszText   = sad.wszApp;
    lvi.iItem     = 0;
    lvi.lParam    = 2;
    nID = (int)SendMessageW(hlc, LVM_INSERTITEMW, 0, (LPARAM)&lvi);
    if (nID >= 0)
        ListView_SetCheckState(hlc, nID, TRUE);

    // if there are no items, then there is no currently selected item, so
    //  make sure this item gets selected.  In our handler for this message
    //  we will take care of setting the 'last selected item' field...
    if (cItems == 0)
    {
        ListView_SetItemState(hlc, nID, LVIS_FOCUSED | LVIS_SELECTED, 
                              LVIS_FOCUSED | LVIS_SELECTED);

        // Also, got to make sure we enable the 'Remove' button.  The only
        //  way we can get zero items in a list is in the exclude list cuz
        //  the include list always has the 'include MS apps' item.
        hbtn = GetDlgItem(hdlg, IDC_PFR_EXREM);
        if (hbtn != NULL)
            EnableWindow(hbtn, TRUE);
    }

    return TRUE;
}

// **************************************************************************
static BOOL DelProgramFromList(HWND hdlg, HWND hlc, SProgDlg *pspd, 
                               EPFListType epflt)
{
    LVITEMW lvi;
    HRESULT hr;
    LPWSTR  wszApp;
    DWORD   cItems, iSel;

    __try 
    {
        wszApp = (LPWSTR)_alloca(pspd->cchMax * sizeof(WCHAR));
    }
    __except (GetExceptionCode() == STATUS_STACK_OVERFLOW) 
    {
        wszApp = NULL;
        _resetstkoflw();    
    }

    if (wszApp == NULL)
        return FALSE;

    iSel = ((epflt == epfltInclude) ? pspd->iLastSelI : pspd->iLastSelE);

    // fetch the string for the item
    ZeroMemory(&lvi, sizeof(lvi));
    lvi.iItem      = iSel;
    lvi.mask       = LVIF_TEXT;
    lvi.pszText    = wszApp;
    lvi.cchTextMax = pspd->cchMax;
    if (SendMessageW(hlc, LVM_GETITEMW, 0, (LPARAM)&lvi))
    {
        // delete it from the config class
        hr = pspd->pcfg->del_ListApp(epflt, lvi.pszText);
        if (FAILED(hr))
            return FALSE;
    }

    // delete it from the UI
    if (ListView_DeleteItem(hlc, iSel) == FALSE)
        return FALSE;

    // reset the selection to be either the same index or one higher (if the
    //  user deleted the last item)
    cItems = ListView_GetItemCount(hlc);
    if (cItems == 0)
    {
        HWND hbtn;

        // only time we can ever hit zero items is in the exclude list cuz the
        //  include list always has the 'include MS apps' option.
        hbtn = GetDlgItem(hdlg, IDC_PFR_EXADD);
        if (hbtn != NULL)
        {
            SetFocus(hbtn);
            SendMessage(hdlg, DM_SETDEFID, IDC_PFR_EXADD, 0);
        }
        hbtn = GetDlgItem(hdlg, IDC_PFR_EXREM);
        if (hbtn != NULL)
            EnableWindow(hbtn, FALSE);
        pspd->iLastSelI = 0;
        return TRUE;
    }


    // if cItems <= iSel, then we just deleted the last index, so decrement the
    //  select index down 1.
    else if (cItems <= iSel)
    {
        iSel--;
    }

    // this will convieniently take care of setting the appropriate iLastSel
    //  field
    ListView_SetItemState(hlc, iSel, LVIS_FOCUSED | LVIS_SELECTED, 
                          LVIS_FOCUSED | LVIS_SELECTED);

    return TRUE;

}

// **************************************************************************
static INT_PTR APIENTRY PFRProgDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, 
                                       LPARAM lParam)
{
    CPFFaultClientCfg   *pcfg = NULL;
    SProgDlg            *pspd = (SProgDlg *)GetWindowLongPtr(hdlg, DWLP_USER);
    HRESULT             hr;
    HWND                hlc, hbtn;

    if (pspd != NULL)
        pcfg = pspd->pcfg;

    switch(uMsg)
    {
        case WM_INITDIALOG:
            SetWindowLongPtr(hdlg, DWLP_USER, lParam);
            if (InitProgDlg(hdlg, (SProgDlg *)lParam) == FALSE)
                EndDialog(hdlg, IDCANCEL);

            break;

        // F1 help
        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, 
                    HELP_FILE, HELP_WM_HELP, (DWORD_PTR)g_rgPFER);
            break;

        // right-click help
        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, HELP_FILE, HELP_CONTEXTMENU,
                    (DWORD_PTR)g_rgPFER);
            break;
    
        case WM_COMMAND:
        {
            switch (LOWORD(wParam)) 
            {
                case IDOK:
                    if (pspd->fRW)
                    {
                        hr = pcfg->CommitChanges(epfltExclude);
                        if (SUCCEEDED(hr))
                        {
                            hr = pcfg->CommitChanges(epfltInclude);
                            if (SUCCEEDED(hr))
                            {
                                pcfg->set_IncWinComp(pspd->eieWinComp);
                                pcfg->set_IncMSApps(pspd->eieMS);
                                pcfg->set_AllOrNone(pspd->eieApps);
                                hr = pcfg->Write();
                            }
                        }

                        if (FAILED(hr))
                        {
                            TCHAR   szMsg[MAX_PATH];
                            if (hr != HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
                            {
                                LoadString(hInstance, IDS_PFR_CFGWRITEERR, szMsg,
                                           ARRAYSIZE(szMsg));
                            }
                            else
                            {
                                LoadString(hInstance, IDS_PFR_NOTADMIN, szMsg,
                                           ARRAYSIZE(szMsg));
                            }
                            MessageBox(hdlg, szMsg, NULL, MB_OK | MB_ICONERROR);
                            pcfg->ClearChanges(epfltExclude);
                            pcfg->ClearChanges(epfltInclude);
                        }
                    }
                    else
                    {
                        TCHAR   szMsg[MAX_PATH];
                        LoadString(hInstance, IDS_PFR_NOTADMIN, szMsg,
                                   ARRAYSIZE(szMsg));
                        MessageBox(hdlg, szMsg, NULL, MB_OK | MB_ICONERROR);
                    }

                    EndDialog(hdlg, IDOK);
                    break;

                case IDCANCEL:
                    EndDialog(hdlg, IDCANCEL);
                    break;

                case IDC_PFR_DEFNONE:
                    pspd->eieApps = (EIncEx)(((DWORD)pspd->eieApps & eieDisableMask) | 
                                             eieExclude);

                    // enable the include list.
                    hlc = GetDlgItem(hdlg, IDC_PFR_INCLIST);
                    if (hlc != NULL)
                        EnableWindow(hlc, TRUE);
                    hbtn = GetDlgItem(hdlg, IDC_PFR_INCADD);
                    if (hbtn != NULL)
                        EnableWindow(hbtn, TRUE);
                    hbtn = GetDlgItem(hdlg, IDC_PFR_INCREM);
                    if (hbtn != NULL)
                        EnableWindow(hbtn, pspd->fShowIncRem);

                    break;

                case IDC_PFR_DEFALL:
                    pspd->eieApps = (EIncEx)(((DWORD)pspd->eieApps & eieDisableMask) | 
                                             eieInclude);

                    // disable the include list.
                    hlc = GetDlgItem(hdlg, IDC_PFR_INCLIST);
                    if (hlc != NULL)
                        EnableWindow(hlc, FALSE);
                    hbtn = GetDlgItem(hdlg, IDC_PFR_INCADD);
                    if (hbtn != NULL)
                        EnableWindow(hbtn, FALSE);
                    hbtn = GetDlgItem(hdlg, IDC_PFR_INCREM);
                    if (hbtn != NULL)
                        EnableWindow(hbtn, FALSE);

                    break;

                case IDC_PFR_INCADD:
                    hlc = GetDlgItem(hdlg, IDC_PFR_INCLIST);
                    if (hlc != NULL)
                        return AddProgramToList(hdlg, hlc, pspd, epfltInclude);
                    break;

                case IDC_PFR_EXADD:
                    hlc = GetDlgItem(hdlg, IDC_PFR_EXLIST);
                    if (hlc != NULL)
                        return AddProgramToList(hdlg, hlc, pspd, epfltExclude);
                    break;

                case IDC_PFR_INCREM:
                    hlc = GetDlgItem(hdlg, IDC_PFR_INCLIST);
                    if (hlc != NULL)
                        return DelProgramFromList(hdlg, hlc, pspd, epfltInclude);
                    break;

                case IDC_PFR_EXREM:
                    hlc = GetDlgItem(hdlg, IDC_PFR_EXLIST);
                    if (hlc != NULL)
                        return DelProgramFromList(hdlg, hlc, pspd, epfltExclude);
                    break;

                default:
                    return FALSE;
            }
            
            break;
        }

        case WM_SETEIELVSEL:
        {
            hlc = GetDlgItem(hdlg, (int)wParam);
            if (ListView_GetItemCount(hlc) > 0)
            {
                int     iSel;

                if (wParam == IDC_PFR_EXLIST)
                    iSel = pspd->iLastSelE;
                else
                    iSel = pspd->iLastSelI;

                ListView_SetItemState(hlc, iSel, 
                                      LVIS_FOCUSED | LVIS_SELECTED, 
                                      LVIS_FOCUSED | LVIS_SELECTED);
            }

            break;
        }

        case WM_NOTIFY:
        {
            EPFListType epflt;
            NMLISTVIEW  *pnmlv = (NMLISTVIEW *)lParam;
            LVITEMW     lvi;
            NMHDR       *pnmh  = (NMHDR *)lParam;
            DWORD       dw;
            UINT        uiBtn;
            BOOL        fCheck;
            int         iSel;

            if ((pnmh->code != LVN_ITEMCHANGED &&
                 pnmh->code != NM_SETFOCUS) ||
                (pnmh->idFrom != IDC_PFR_EXLIST && 
                 pnmh->idFrom != IDC_PFR_INCLIST))
                return FALSE;

            hlc = pnmh->hwndFrom;

            uiBtn = (pnmh->idFrom == IDC_PFR_EXLIST) ? IDC_PFR_EXREM : 
                                                       IDC_PFR_INCREM;
            hbtn = GetDlgItem(hdlg, uiBtn);

            // check and see if there are any selected items
            iSel = (int)SendMessage(hlc, LVM_GETNEXTITEM, -1, LVNI_SELECTED);
            if (iSel < 0)
            {
                EnableWindow(hbtn, FALSE);
                if (pnmh->idFrom == IDC_PFR_INCLIST)
                    pspd->fShowIncRem = FALSE;
            }

            else 
            {
                if (pnmh->code == NM_SETFOCUS)
                {
                    PostMessage(hdlg, WM_SETEIELVSEL, pnmh->idFrom, pnmh->code);
                    return TRUE;
                }
            }
            
            // if it doesn't fit this condition, don't give a rat's patootie
            //  about it
            if ((pnmlv->uChanged & LVIF_STATE) == 0 ||
                (pnmlv->uNewState ^ pnmlv->uOldState) == 0)
                return FALSE;

            // hack cuz we get 1 or 2 messages when inserting items into the 
            //  list & initially setting their check state.  Want to not 
            //  process those messages.  The exception is the 'include
            //  ms apps' item which we can process any number of times
            if ((pnmlv->lParam & ~EXNOREM) > 0)
            {
                ZeroMemory(&lvi, sizeof(lvi));
                lvi.iItem  = pnmlv->iItem;
                lvi.mask   = LVIF_PARAM;
                lvi.lParam = (pnmlv->lParam - 1) | (pnmlv->lParam & EXNOREM);
                SendMessageW(hlc, LVM_SETITEM, 0, (LPARAM)&lvi);
                return TRUE;
            }


            // did the selection change?
            if ((pnmlv->uNewState & LVIS_SELECTED) != 0)
            {
                if (pnmh->idFrom == IDC_PFR_INCLIST)
                {
                    pspd->iLastSelI = pnmlv->iItem;
                    
                    // we need to disable the exclude remove button if we hit
                    //  the 'exclude non ms apps' item
                    if (hbtn != NULL)
                    {
                        if ((pnmlv->lParam & EXNOREM) != 0)
                        {
                            // disable the remove button- but if the remove 
                            //  button had focus, we need to reset the focus
                            //  or nothing on the dialog will have focus.
                            if (GetFocus() == hbtn)
                            {
                                HWND hbtnAdd;
                                hbtnAdd = GetDlgItem(hdlg, IDC_PFR_INCADD);
                                if (hbtnAdd != NULL)
                                {
                                    SetFocus(hbtnAdd);
                                    SendMessage(hdlg, DM_SETDEFID, IDC_PFR_INCADD, 0);
                                }

                            }

                            pspd->fShowIncRem = FALSE;
                            EnableWindow(hbtn, FALSE);
                        }
                        else
                        {
                            pspd->fShowIncRem = TRUE;
                            EnableWindow(hbtn, TRUE);
                        }
                    }

                }
                else
                {
                    pspd->iLastSelE = pnmlv->iItem;
                    if (hbtn != NULL)
                        EnableWindow(hbtn, TRUE);
                }
            }

            // if we don't have a check-state change, can bail now.
            if (((pnmlv->uNewState ^ pnmlv->uOldState) & 0x3000) == 0)
                return TRUE;

            fCheck = ListView_GetCheckState(hlc, pnmlv->iItem);
            if (pnmh->idFrom == IDC_PFR_EXLIST)
                epflt = epfltExclude;
            else
                epflt = epfltInclude;

            // did we modify the 'exclude non ms apps' item? 
            if ((pnmlv->lParam & EXNOREM) != 0)
            {
                if ((pnmlv->lParam & EXALLMS) != 0)
                    pspd->eieMS = ((fCheck) ? eieInclude : eieExclude);
                else
                    pspd->eieWinComp = ((fCheck) ? eieInclude : eieExclude);
            }

            // nope, modified a regular item
            else
            {
                LPWSTR  wszApp;

                __try
                {
                    wszApp = (LPWSTR)_alloca(pspd->cchMax * sizeof(WCHAR));
                }
                __except(GetExceptionCode() == STATUS_STACK_OVERFLOW)
                {
                    wszApp = NULL;
                    _resetstkoflw();    
                }
                if (wszApp == NULL)
                    return FALSE;
            
                // got to fetch it to make sure we have a unicode string
                ZeroMemory(&lvi, sizeof(lvi));
                lvi.iItem      = pnmlv->iItem;
                lvi.mask       = LVIF_TEXT;
                lvi.pszText    = wszApp;
                lvi.cchTextMax = pspd->cchMax;
                if (SendMessageW(hlc, LVM_GETITEMW, 0, (LPARAM)&lvi))
                {
                    hr = pcfg->mod_ListApp(epflt, lvi.pszText, fCheck);
                    if (FAILED(hr))
                        return FALSE;
                }

            }

            break;
        }

        default:
            return FALSE;
    }

    return FALSE;
}


///////////////////////////////////////////////////////////////////////////////
// Main PFR dialog proc

// **************************************************************************
static BOOL InitMainDlg(HWND hdlg)
{
    CPFFaultClientCfg   *pcfg = NULL;
    SMainDlg            *psmd = NULL;
    BOOL                fRet = FALSE;
    UINT                ui;
    HWND                hbtn, hchk;

    LoadPFRResourceStrings();

    hbtn = GetDlgItem(hdlg, IDC_PFR_DETAILS);
    if (hbtn == NULL)
        goto done;

    psmd = new SMainDlg;
    if (psmd == NULL)
        goto done;

    pcfg = new CPFFaultClientCfg;
    if (pcfg == NULL)
        goto done;

    // see if this user has write access to the appropriate registry
    //  locations
    psmd->fRW = pcfg->HasWriteAccess();
    if (FAILED(pcfg->Read((psmd->fRW) ? eroCPRW : eroCPRO)))
        goto done;

    psmd->eedReport   = pcfg->get_DoReport();
    psmd->eieKernel   = pcfg->get_IncKernel();
    psmd->eieApps     = pcfg->get_AllOrNone();
    psmd->eedShowUI   = pcfg->get_ShowUI();
    psmd->eieShut     = pcfg->get_IncShutdown();
    psmd->fForceQueue = pcfg->get_ForceQueueMode();
    psmd->iLastSel    = 0;

    // if ShowUI is completely disabled, then so should reporting- the control
    //  panel does not support entering corporate mode.
    if (psmd->eedShowUI == eedDisabled)
        psmd->eedReport = eedDisabled;

    psmd->pcfg = pcfg;
    SetWindowLongPtr(hdlg, DWLP_USER, (LONG_PTR)psmd);

    // set up the kernel checkbox
    ui = (psmd->eieKernel == eieInclude) ? BST_CHECKED : BST_UNCHECKED;
    CheckDlgButton(hdlg, IDC_PFR_ENABLEOS, ui);

    // set up the programs checkbox
    ui = ((psmd->eieApps & eieDisableMask) == 0) ? BST_CHECKED : BST_UNCHECKED;
    CheckDlgButton(hdlg, IDC_PFR_ENABLEPROG, ui);

    // set up the notification checkbox
    ui = (psmd->eedShowUI == eedEnabled) ? BST_CHECKED : BST_UNCHECKED;
    CheckDlgButton(hdlg, IDC_PFR_SHOWUI, ui);

    // set up the shutdown checkbox on server only
    if (pcfg->get_IsServer())
    {
        ui = (psmd->eieShut == eieInclude) ? BST_CHECKED : BST_UNCHECKED;
        CheckDlgButton(hdlg, IDC_PFR_ENABLESHUT, ui);

        ui = (psmd->fForceQueue) ? BST_CHECKED : BST_UNCHECKED;
        CheckDlgButton(hdlg, IDC_PFR_FORCEQ, ui);
    }

    // set up the radio buttons
    if (psmd->eedReport == eedDisabled)
    {
        CheckRadioButton(hdlg, IDC_PFR_DISABLE, IDC_PFR_ENABLE, IDC_PFR_DISABLE);

        hchk = GetDlgItem(hdlg, IDC_PFR_SHOWUI);
        if (hchk != NULL)
            EnableWindow(hchk, TRUE);

        hchk = GetDlgItem(hdlg, IDC_PFR_ENABLEOS);
        if (hchk != NULL)
            EnableWindow(hchk, FALSE);

        hchk = GetDlgItem(hdlg, IDC_PFR_ENABLEPROG);
        if (hchk != NULL)
            EnableWindow(hchk, FALSE);

        hbtn = GetDlgItem(hdlg, IDC_PFR_DETAILS);
        if (hbtn != NULL)
            EnableWindow(hbtn, FALSE);

        if (pcfg->get_IsServer())
        {
            hbtn = GetDlgItem(hdlg, IDC_PFR_ENABLESHUT);
            if (hbtn != NULL)
                EnableWindow(hbtn, FALSE);

            hbtn = GetDlgItem(hdlg, IDC_PFR_FORCEQ);
            if (hbtn != NULL)
                EnableWindow(hbtn, FALSE);
        }
    }
    else
    {
        CheckRadioButton(hdlg, IDC_PFR_DISABLE, IDC_PFR_ENABLE, IDC_PFR_ENABLE);

        hchk = GetDlgItem(hdlg, IDC_PFR_SHOWUI);
        if (hchk != NULL)
            EnableWindow(hchk, FALSE);

        hchk = GetDlgItem(hdlg, IDC_PFR_ENABLEOS);
        if (hchk != NULL)
            EnableWindow(hchk, TRUE);

        hchk = GetDlgItem(hdlg, IDC_PFR_ENABLEPROG);
        if (hchk != NULL)
            EnableWindow(hchk, TRUE);

        if (pcfg->get_IsServer())
        {
            hbtn = GetDlgItem(hdlg, IDC_PFR_ENABLESHUT);
            if (hbtn != NULL)
                EnableWindow(hbtn, TRUE);
        }

        if ((psmd->eieApps & eieDisableMask) != 0)
        {
            hbtn = GetDlgItem(hdlg, IDC_PFR_DETAILS);
            if (hbtn != NULL)
                EnableWindow(hbtn, FALSE);

            if (pcfg->get_IsServer())
            {
                hbtn = GetDlgItem(hdlg, IDC_PFR_FORCEQ);
                if (hbtn != NULL)
                    EnableWindow(hbtn, FALSE);
            }
        }
    }

    fRet = TRUE;
    psmd = NULL;
    pcfg = NULL;

done:
    if (fRet == FALSE)
    {
        TCHAR   szMsg[MAX_PATH];
        LoadString(hInstance, IDS_PFR_CFGREADERR, szMsg, ARRAYSIZE(szMsg));
        MessageBox(hdlg, szMsg, NULL, MB_OK | MB_ICONERROR);
    }
    
    if (psmd != NULL)
        delete psmd;
    if (pcfg != NULL)
        delete pcfg;

    return fRet;
}

// **************************************************************************
static inline INT_PTR LaunchSubDialog(HWND hdlgParent, DWORD dwDlgToLaunch, 
                                      SMainDlg *psmd)
{
    if (dwDlgToLaunch == PROGLI)
    {
        SProgDlg spd;

        ZeroMemory(&spd, sizeof(spd));
        spd.pcfg    = psmd->pcfg;
        spd.eieApps = psmd->eieApps;
        spd.eieMS   = psmd->pcfg->get_IncMSApps();
        spd.fRW     = psmd->fRW;
        if (DialogBoxParam(hInstance, MAKEINTRESOURCE(IDD_PFR_PROG), 
                           hdlgParent, PFRProgDlgProc, (LPARAM)&spd) == IDOK)
        {
            psmd->eieApps = psmd->pcfg->get_AllOrNone();
        }
    }

    else
    {
        return IDCANCEL;
    }

    return IDOK;
}


// **************************************************************************
INT_PTR APIENTRY PFRDlgProc(HWND hdlg, UINT uMsg, WPARAM wParam, 
                            LPARAM lParam)
{
    CPFFaultClientCfg   *pcfg = NULL;
    SMainDlg            *psmd = (SMainDlg *)GetWindowLongPtr(hdlg, DWLP_USER);
    HWND                hbtn, hchk;

    if (psmd != NULL)
        pcfg = psmd->pcfg;

    switch(uMsg)
    {
        case WM_INITDIALOG:
            if (InitMainDlg(hdlg) == FALSE)
                EndDialog(hdlg, IDCANCEL);
            break;

        case WM_DESTROY:
            if (psmd != NULL)
            {
                if (psmd->pcfg != NULL)
                    delete psmd->pcfg;
            
                delete psmd;
                SetWindowLongPtr(hdlg, DWLP_USER, NULL);
            }
            break;
            
        // F1 help
        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, 
                    HELP_FILE, HELP_WM_HELP, (DWORD_PTR)g_rgPFER);
            break;

        // right-click help
        case WM_CONTEXTMENU:
            WinHelp((HWND)wParam, HELP_FILE, HELP_CONTEXTMENU,
                    (DWORD_PTR)g_rgPFER);
            break;
    
        case WM_COMMAND:
        {
            switch (LOWORD(wParam)) 
            {
                case IDOK:
                    if (psmd->fRW)
                    {
                        HRESULT hr;

                        pcfg->set_AllOrNone(psmd->eieApps);
                        pcfg->set_DoReport(psmd->eedReport);
                        pcfg->set_IncKernel(psmd->eieKernel);
                        pcfg->set_ShowUI(psmd->eedShowUI);
                        if (pcfg->get_IsServer())
                        {
                            pcfg->set_IncShutdown(psmd->eieShut);
                            pcfg->set_ForceQueueMode(psmd->fForceQueue);
                        }

                        hr = pcfg->Write();
                        if (FAILED(hr))
                        {
                            TCHAR   szMsg[MAX_PATH];

                            if (hr != HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED))
                            {
                                LoadString(hInstance, IDS_PFR_CFGWRITEERR, szMsg,
                                           ARRAYSIZE(szMsg));
                            }
                            else
                            {
                                LoadString(hInstance, IDS_PFR_NOTADMIN, szMsg,
                                           ARRAYSIZE(szMsg));
                            }
                            MessageBox(hdlg, szMsg, NULL, MB_OK | MB_ICONERROR);
                        }
                    }
                    else
                    {
                        TCHAR   szMsg[MAX_PATH];

                        LoadString(hInstance, IDS_PFR_NOTADMIN, szMsg,
                                   ARRAYSIZE(szMsg));
                        MessageBox(hdlg, szMsg, NULL, MB_OK | MB_ICONERROR);
                    }

                    EndDialog(hdlg, IDOK);
                    break;

                case IDCANCEL:
                    EndDialog(hdlg, IDCANCEL);
                    break;

                case IDC_PFR_ENABLE:
                {
                    LVITEM lvi;

                    psmd->eedReport = eedEnabled;

                    // if UI is disbaled, then implicitly enable it (but don't
                    //  change the check state of the 'show UI' checkbox) cuz
                    //  we only support headless uploading thru policy.
                    if (psmd->eedShowUI == eedDisabled)
                        psmd->eedShowUI = eedEnabledNoCheck;

                    hchk = GetDlgItem(hdlg, IDC_PFR_SHOWUI);
                    if (hchk != NULL)
                        EnableWindow(hchk, FALSE);

                    hchk = GetDlgItem(hdlg, IDC_PFR_ENABLEOS);
                    if (hchk != NULL)
                        EnableWindow(hchk, TRUE);

                    hchk = GetDlgItem(hdlg, IDC_PFR_ENABLEPROG);
                    if (hchk != NULL)
                        EnableWindow(hchk, TRUE);

                    if (pcfg->get_IsServer())
                    {
                        hbtn = GetDlgItem(hdlg, IDC_PFR_ENABLESHUT);
                        if (hbtn != NULL)
                            EnableWindow(hbtn, TRUE);
                    }

                    if ((psmd->eieApps & eieDisableMask) == 0)
                    {
                        hbtn = GetDlgItem(hdlg, IDC_PFR_DETAILS);
                        if (hbtn != NULL)
                            EnableWindow(hbtn, TRUE);

                        if (pcfg->get_IsServer())
                        {
                            hbtn = GetDlgItem(hdlg, IDC_PFR_FORCEQ);
                            if (hbtn != NULL)
                                EnableWindow(hbtn, TRUE);
                        }
                    }

                    break;
                }

                case IDC_PFR_DISABLE:
                {
                    psmd->eedReport = eedDisabled;

                    // if UI isn't explicitly enabled, disable it- it was 
                    //  implicity enabled when the user previously enabled 
                    //  reporting
                    if (psmd->eedShowUI == eedEnabledNoCheck)
                        psmd->eedShowUI = eedDisabled;

                    hchk = GetDlgItem(hdlg, IDC_PFR_SHOWUI);
                    if (hchk != NULL)
                        EnableWindow(hchk, TRUE);

                    hchk = GetDlgItem(hdlg, IDC_PFR_ENABLEOS);
                    if (hchk != NULL)
                        EnableWindow(hchk, FALSE);

                    hchk = GetDlgItem(hdlg, IDC_PFR_ENABLEPROG);
                    if (hchk != NULL)
                        EnableWindow(hchk, FALSE);

                    hbtn = GetDlgItem(hdlg, IDC_PFR_DETAILS);
                    if (hbtn != NULL)
                        EnableWindow(hbtn, FALSE);

                    if (pcfg->get_IsServer())
                    {
                        hbtn = GetDlgItem(hdlg, IDC_PFR_ENABLESHUT);
                        if (hbtn != NULL)
                            EnableWindow(hbtn, FALSE);
                        
                        hbtn = GetDlgItem(hdlg, IDC_PFR_FORCEQ);
                        if (hbtn != NULL)
                            EnableWindow(hbtn, FALSE);
                    }
                    
                    break;
                }

                case IDC_PFR_DETAILS:
                {
                    // don't need to check if this is a valid thing to bring up
                    //  a dialog for cuz the details button should not be 
                    //  available if it isn't
                    return LaunchSubDialog(hdlg, PROGLI, psmd);
                    break;
                }

                case IDC_PFR_SHOWUI:
                {
                    if (IsDlgButtonChecked(hdlg, IDC_PFR_SHOWUI) == BST_UNCHECKED)
                        psmd->eedShowUI = eedDisabled;
                    else if (psmd->eedReport == eedEnabled)
                        psmd->eedShowUI = eedEnabledNoCheck;
                    else
                        psmd->eedShowUI = eedEnabled;
                    break;
                }

                case IDC_PFR_ENABLEOS:
                {
                    if (IsDlgButtonChecked(hdlg, IDC_PFR_ENABLEOS) == BST_UNCHECKED)
                        psmd->eieKernel = eieExclude;
                    else
                        psmd->eieKernel = eieInclude;
                    break;
                }

                case IDC_PFR_ENABLEPROG:
                {
                    DWORD dw;
                    
                    hbtn = GetDlgItem(hdlg, IDC_PFR_DETAILS);
                    if (pcfg->get_IsServer())
                        hchk = GetDlgItem(hdlg, IDC_PFR_FORCEQ);
                    else
                        hchk = NULL;
                    if (IsDlgButtonChecked(hdlg, IDC_PFR_ENABLEPROG) == BST_UNCHECKED)
                    {
                        dw = (DWORD)psmd->eieApps | eieDisableMask;
                        if (hbtn != NULL)
                            EnableWindow(hbtn, FALSE);
                        if (hchk != NULL)
                            EnableWindow(hchk, FALSE);
                    }
                    else
                    {
                        dw = (DWORD)psmd->eieApps & eieIncMask;
                        if (hbtn != NULL)
                            EnableWindow(hbtn, TRUE);
                        if (hchk != NULL)
                            EnableWindow(hchk, TRUE);
                    }

                    psmd->eieApps = (EIncEx)dw;

                    break;
                }

                case IDC_PFR_ENABLESHUT:
                    if (pcfg->get_IsServer())
                    {
                        if (IsDlgButtonChecked(hdlg, IDC_PFR_ENABLESHUT) == BST_UNCHECKED)
                            psmd->eieShut = eieExclude;
                        else
                            psmd->eieShut = eieInclude;
                    }

                case IDC_PFR_FORCEQ:
                    if (pcfg->get_IsServer())
                    {
                        if (IsDlgButtonChecked(hdlg, IDC_PFR_FORCEQ) == BST_UNCHECKED)
                            psmd->fForceQueue = FALSE;
                        else
                            psmd->fForceQueue = TRUE;
                    }
                    

                default:
                    return FALSE;

            }

            break;
        }

        default:
            return FALSE;

    }

    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\profile.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    profile.h

Abstract:

    Public declarations for the User Profiles tab of the
    System Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#ifndef _SYSDM_PROFILE_H_
#define _SYSDM_PROFILE_H_

//
// Flags
//

#define USERINFO_FLAG_DIRTY             1
#define USERINFO_FLAG_CENTRAL_AVAILABLE 2
#define USERINFO_FLAG_ACCOUNT_UNKNOWN   4

//
// Profile types : obtained from ds\security\gina\userenv\profile\profile.h
//

#define USERINFO_LOCAL                  0
#define USERINFO_FLOATING               1
#define USERINFO_MANDATORY              2
#define USERINFO_BACKUP                 3
#define USERINFO_TEMP                   4
#define USERINFO_READONLY               5


typedef struct _USERINFO {
    DWORD     dwFlags;
    LPTSTR    lpSid;
    LPTSTR    lpProfile;
    LPTSTR    lpUserName;
    DWORD     dwProfileType;
    DWORD     dwProfileStatus;
} USERINFO, *LPUSERINFO;

typedef struct _UPCOPYINFO {
    DWORD         dwFlags;
    PSID          pSid;
    LPUSERINFO    lpUserInfo;
    BOOL          bDefaultSecurity;   
} UPCOPYINFO, *LPUPCOPYINFO;


INT_PTR 
APIENTRY 
UserProfileDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);

#endif // _SYSDM_PROFILE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\profile.cpp ===
//*************************************************************
//
//  Profile.c   - User Profile tab
//
//  Microsoft Confidential
//  Copyright (c) Microsoft Corporation 1996
//  All rights reserved
//
//*************************************************************

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "sysdm.h"
#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <userenv.h>
#include <userenvp.h>
#include <getuser.h>
#include <objsel.h>
#include <strsafe.h>


#define TEMP_PROFILE                 TEXT("Temp profile (sysdm.cpl)")
#define USER_CRED_LOCATION           TEXT("Application Data\\Microsoft\\Credentials")
#define PROFILE_MAPPING              TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\ProfileList")
#define WINLOGON_KEY                 TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define SYSTEM_POLICIES_KEY          TEXT("Software\\Policies\\Microsoft\\Windows\\System")
#define READONLY_RUP                 TEXT("ReadOnlyProfile")
#define PROFILE_LOCALONLY            TEXT("LocalProfile")
#define PRF_USERSID                  1


//
// Globals
//

const TCHAR c_szNTUserIni[] = TEXT("ntuser.ini");
#define PROFILE_GENERAL_SECTION      TEXT("General")
#define PROFILE_EXCLUSION_LIST       TEXT("ExclusionList")
DWORD g_dwProfileSize;

//
// Help ID's
//
// IDH_USERPROFILE + 20 is used in the OpenUserBrowser routine.
//
DWORD aUserProfileHelpIds[] = {
    IDC_UP_LISTVIEW,              (IDH_USERPROFILE + 0),
    IDC_UP_DELETE,                (IDH_USERPROFILE + 1),
    IDC_UP_TYPE,                  (IDH_USERPROFILE + 2),
    IDC_UP_COPY,                  (IDH_USERPROFILE + 3),
    IDC_UP_ICON,                  (DWORD) -1,
    IDC_UP_TEXT,                  (DWORD) -1,

    // Change Type dialog
    IDC_UPTYPE_LOCAL,             (IDH_USERPROFILE + 4),
    IDC_UPTYPE_FLOAT,             (IDH_USERPROFILE + 5),
    // removed IDC_UPTYPE_SLOW, IDC_UPTYPE_SLOW_TEXT
    IDC_UPTYPE_GROUP,             (IDH_USERPROFILE + 12),

    // Copy To dialog
    IDC_COPY_PROFILE,             (IDH_USERPROFILE + 7),
    IDC_COPY_PATH,                (IDH_USERPROFILE + 7),
    IDC_COPY_BROWSE,              (IDH_USERPROFILE + 8),
    IDC_COPY_USER,                (IDH_USERPROFILE + 9),
    IDC_COPY_CHANGE,              (IDH_USERPROFILE + 10),
    IDC_COPY_GROUP,               (IDH_USERPROFILE + 9),

    0, 0
};


//
// Local function proto-types
//

BOOL InitUserProfileDlg (HWND hDlg, LPARAM lParam);
BOOL FillListView (HWND hDlg, BOOL bAdmin);
BOOL RecurseDirectory (LPTSTR lpDir, UINT cchBuffer, LPTSTR lpExcludeList);
VOID UPSave (HWND hDlg);
VOID UPCleanUp (HWND hDlg);
BOOL IsProfileInUse (LPTSTR lpSid);
void UPDoItemChanged(HWND hDlg, int idCtl);
void UPDeleteProfile(HWND hDlg);
void UPChangeType(HWND hDlg);
void UPOnLink(WPARAM wParam);
INT_PTR APIENTRY ChangeTypeDlgProc (HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
void UPCopyProfile(HWND hDlg);
INT_PTR APIENTRY UPCopyDlgProc (HWND hDlg, UINT uMsg,WPARAM wParam, LPARAM lParam);
BOOL UPCreateProfile (HWND hDlg, LPUPCOPYINFO lpUPCopyInfo, LPTSTR lpDest, PSECURITY_DESCRIPTOR pSecDesc);
VOID UPDisplayErrorMessage(HWND hWnd, UINT uiSystemError, LPTSTR szMsgPrefix);
BOOL ApplyHiveSecurity(LPTSTR lpHiveName, PSID pSid);
BOOL CheckSemicolon (LPTSTR lpDir, UINT cchBuffer);
LPTSTR ConvertExclusionList (LPCTSTR lpSourceDir, LPCTSTR lpExclusionList);
BOOL ReadExclusionList(HKEY hKeyUser, LPTSTR szExcludeList, DWORD cchExcludeList);
BOOL ReadExclusionListFromIniFile(LPCTSTR lpSourceDir, LPTSTR szExcludeList, DWORD cchExcludeList);
HRESULT UPGetUserSelection(HWND hDlg, LPUSERDETAILS lpUserDetails);
BOOL ConfirmDirectory(HWND hDlg, LPTSTR szDir);
HRESULT CopyNonHiveNtUserFiles(LPCTSTR lpSrcDir, LPCTSTR lpDestDir);
LPTSTR CheckSlashEx(LPTSTR lpDir, UINT cchBuffer, UINT* pcchRemain );


//*************************************************************
//
//  UserProfileDlgProc()
//
//  Purpose:    Dialog box procedure for profile tab
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              10/11/95    ericflo    Created
//
//*************************************************************

INT_PTR APIENTRY UserProfileDlgProc (HWND hDlg, UINT uMsg,
                                  WPARAM wParam, LPARAM lParam)
{
    switch (uMsg) {
        case WM_INITDIALOG:
           if (!InitUserProfileDlg (hDlg, lParam)) {
               EndDialog(hDlg, FALSE);
           }
           return TRUE;


    case WM_NOTIFY:

        switch (((NMHDR FAR*)lParam)->code)
        {
        case LVN_ITEMCHANGED:
            UPDoItemChanged(hDlg, (int) wParam);
            break;

        case LVN_ITEMACTIVATE:
            PostMessage (hDlg, WM_COMMAND, IDC_UP_TYPE, 0);
            break;

        case LVN_COLUMNCLICK:
            break;

        case NM_CLICK:
        case NM_RETURN:
            UPOnLink(wParam);
            break;

        default:
            return FALSE;
        }
        break;

    case WM_DESTROY:
        UPCleanUp (hDlg);
        break;

    case WM_COMMAND:

        switch (LOWORD(wParam)) {
            case IDC_UP_DELETE:
                UPDeleteProfile(hDlg);
                break;

            case IDC_UP_TYPE:
                UPChangeType(hDlg);
                break;

            case IDC_UP_COPY:
                UPCopyProfile(hDlg);
                break;

            case IDOK:
                UPSave(hDlg);
                EndDialog(hDlg, FALSE);
                break;
                
            case IDCANCEL:
                EndDialog(hDlg, FALSE);
                break;

            default:
                break;

        }
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
        (DWORD_PTR) (LPSTR) aUserProfileHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
        (DWORD_PTR) (LPSTR) aUserProfileHelpIds);
        return (TRUE);

    }

    return (FALSE);
}

//*************************************************************
//
//  InitUserProfileDlg()
//
//  Purpose:    Initializes the User Profiles page
//
//  Parameters: hDlg    -   Dialog box handle
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              1/26/96     ericflo    Created
//
//*************************************************************

BOOL InitUserProfileDlg (HWND hDlg, LPARAM lParam)
{
    TCHAR szHeaderName[30];
    LV_COLUMN col;
    RECT rc;
    HWND hLV;
    INT iTotal = 0, iCurrent;
    HWND hwndTemp;
    BOOL bAdmin;
    HCURSOR hOldCursor;


    hOldCursor = SetCursor (LoadCursor(NULL, IDC_WAIT));

    hLV = GetDlgItem(hDlg, IDC_UP_LISTVIEW);

    // Set extended LV style for whole line selection
    SendMessage(hLV, LVM_SETEXTENDEDLISTVIEWSTYLE, 0, LVS_EX_FULLROWSELECT);

    //
    // Insert Columns
    //

    GetClientRect (hLV, &rc);
    LoadString(hInstance, IDS_UP_NAME, szHeaderName, ARRAYSIZE(szHeaderName));
    col.mask = LVCF_FMT | LVCF_TEXT | LVCF_SUBITEM | LVCF_WIDTH;
    col.fmt = LVCFMT_LEFT;
    iCurrent = (int)(rc.right * .40);
    iTotal += iCurrent;
    col.cx = iCurrent;
    col.pszText = szHeaderName;
    col.iSubItem = 0;

    ListView_InsertColumn (hLV, 0, &col);


    LoadString(hInstance, IDS_UP_SIZE, szHeaderName, ARRAYSIZE(szHeaderName));
    iCurrent = (int)(rc.right * .15);
    iTotal += iCurrent;
    col.cx = iCurrent;
    col.fmt = LVCFMT_RIGHT;
    col.iSubItem = 1;
    ListView_InsertColumn (hLV, 1, &col);


    LoadString(hInstance, IDS_UP_TYPE, szHeaderName, ARRAYSIZE(szHeaderName));
    col.iSubItem = 2;
    iCurrent = (int)(rc.right * .15);
    iTotal += iCurrent;
    col.cx = iCurrent;
    col.fmt = LVCFMT_LEFT;
    ListView_InsertColumn (hLV, 2, &col);

    LoadString(hInstance, IDS_UP_STATUS, szHeaderName, ARRAYSIZE(szHeaderName));
    col.iSubItem = 3;
    iCurrent = (int)(rc.right * .15);
    iTotal += iCurrent;
    col.cx = iCurrent;
    col.fmt = LVCFMT_LEFT;
    ListView_InsertColumn (hLV, 3, &col);

    LoadString(hInstance, IDS_UP_MOD, szHeaderName, ARRAYSIZE(szHeaderName));
    col.iSubItem = 4;
    col.cx = rc.right - iTotal - GetSystemMetrics(SM_CYHSCROLL);
    col.fmt = LVCFMT_LEFT;
    ListView_InsertColumn (hLV, 4, &col);

    bAdmin = IsUserAnAdmin();


    if (!bAdmin) {
        POINT pt;

        //
        // If the user is not an admin, then we hide the
        // delete and copy to buttons
        //

        hwndTemp = GetDlgItem (hDlg, IDC_UP_DELETE);
        GetWindowRect (hwndTemp, &rc);
        EnableWindow (hwndTemp, FALSE);
        ShowWindow (hwndTemp, SW_HIDE);

        hwndTemp = GetDlgItem (hDlg, IDC_UP_COPY);
        EnableWindow (hwndTemp, FALSE);
        ShowWindow (hwndTemp, SW_HIDE);

        //
        // Move the Change Type button over
        //

        pt.x = rc.left;
        pt.y = rc.top;
        ScreenToClient (hDlg, &pt);

        SetWindowPos (GetDlgItem (hDlg, IDC_UP_TYPE),
                      HWND_TOP, pt.x, pt.y, 0, 0,
                      SWP_NOSIZE | SWP_NOZORDER);

    }

    if (IsOS(OS_ANYSERVER))
    {
        //
        // Adjust the text displayed for the Users & Passwords link.
        // There is no Control Panel applet per se on Server.  The functionality
        // is accessed through MMC.
        //
        TCHAR szTitle[80];
        if (0 < LoadString(hInstance, IDS_UP_UPLINK_SERVER, szTitle, ARRAYSIZE(szTitle)))
        {
            SetWindowText(GetDlgItem(hDlg, IDC_UP_UPLINK), szTitle);
        }
    }
        
    //
    // Fill the user accounts
    //

    if (!FillListView (hDlg, bAdmin)) {
        SetCursor(hOldCursor);
        return FALSE;
    }
    
    SetCursor(hOldCursor);

    return TRUE;
}

//*************************************************************
//
//  AddUser()
//
//  Purpose:    Adds a new user to the listview
//
//
//  Parameters: hDlg            -   handle to the dialog box
//              lpSid           -   Sid (text form)
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              1/26/96     ericflo    Created
//
//*************************************************************

BOOL AddUser (HWND hDlg, LPTSTR lpSid, DWORD dwFlags)
{
    LONG Error;
    HKEY hKeyPolicy, hKeyProfile;
    TCHAR szBuffer[2*MAX_PATH];
    TCHAR szBuffer2[MAX_PATH];
    TCHAR szTemp[100];
    TCHAR szTemp2[100];
    DWORD dwBufSize, dwBuf2Size;
    PSID pSid;
    DWORD dwSize, dwProfileFlags;
    SID_NAME_USE SidName;
    LV_ITEM item;
    INT iItem;
    HWND hwndTemp;
    HKEY hkeyUser;
    HANDLE hFile;
    WIN32_FIND_DATA fd;
    LPTSTR lpEnd;
    SYSTEMTIME systime;
    FILETIME   ftLocal;
    TCHAR szProfileSize[20];
    INT iTypeID, iStatusID;
    DWORD dwProfileType, dwProfileStatus, dwSysProfileType=0;
    LPUSERINFO lpUserInfo;
    BOOL bCentralAvailable = FALSE, bAccountUnknown;
    TCHAR szExcludeList[2*MAX_PATH+1];
    LPTSTR lpExcludeList = NULL; 
    UINT cchRemaining;
    HRESULT hr;
    DWORD dwFileAttr;
    BOOL bGotTime = FALSE;

    //
    // Open the user's info
    //

    hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("%s\\%s"), PROFILE_MAPPING, lpSid);
    if (FAILED(hr)) {
        return FALSE;
    }

    Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         szBuffer,
                         0,
                         KEY_READ,
                         &hkeyUser);

    if (Error != ERROR_SUCCESS) {
        return FALSE;
    }

    //
    // If PI_HIDEPROFILE flag is set then do not display
    // the user in system applet
    //

    dwSize = sizeof(DWORD);
    Error = RegQueryValueEx (hkeyUser,
                             TEXT("Flags"),
                             NULL,
                             NULL,
                             (LPBYTE) &dwProfileFlags,
                             &dwSize);

    if (Error == ERROR_SUCCESS && (dwProfileFlags & PI_HIDEPROFILE)) {
        RegCloseKey (hkeyUser);
        return FALSE;
    }
   

    //
    // Query for the user's central profile location
    //

    dwSize = sizeof(szBuffer2);
    Error = RegQueryValueEx (hkeyUser,
                             TEXT("CentralProfile"),
                             NULL,
                             NULL,
                             (LPBYTE) szBuffer2,
                             &dwSize);

    if ((Error == ERROR_SUCCESS) && (szBuffer2[0] != TEXT('\0'))) {
        bCentralAvailable = TRUE;
    }


    //
    // Query for the user's local profile
    //

    dwSize = sizeof(szBuffer2);
    Error = RegQueryValueEx (hkeyUser,
                             TEXT("ProfileImagePath"),
                             NULL,
                             NULL,
                             (LPBYTE) szBuffer2,
                             &dwSize);

    if (Error != ERROR_SUCCESS) {
        RegCloseKey (hkeyUser);
        return FALSE;
    }


    //
    // Profile paths need to be expanded
    //

    dwSize = ExpandEnvironmentStrings (szBuffer2, szBuffer, ARRAYSIZE(szBuffer));
    if (!dwSize || dwSize > ARRAYSIZE(szBuffer)) {
        RegCloseKey (hkeyUser);
        return FALSE;
    }

    if (FAILED(StringCchCopy(szBuffer2, ARRAYSIZE(szBuffer2), szBuffer))) {
        RegCloseKey (hkeyUser);
        return FALSE;
    }

    //
    //  Check if this directory exists
    //
    dwFileAttr = GetFileAttributes(szBuffer);

    if (dwFileAttr != INVALID_FILE_ATTRIBUTES)
    {
        //
        //  Directory exist, get the timestamp of the user hive and profile size
        //
        lpEnd = CheckSlashEx(szBuffer, ARRAYSIZE(szBuffer), &cchRemaining);
        if (!lpEnd)
        {
            RegCloseKey(hkeyUser);
            return FALSE;
        }

        if (FAILED(StringCchCopy(lpEnd, cchRemaining, TEXT("ntuser.man")))) {
            RegCloseKey (hkeyUser);
            return FALSE;
        }

        ZeroMemory(&fd, sizeof(fd));
        hFile = FindFirstFile (szBuffer, &fd);

        if (hFile != INVALID_HANDLE_VALUE)
        {
            FindClose (hFile);
            bGotTime = TRUE;
        }
        else
        {
            if (FAILED(StringCchCopy(lpEnd, cchRemaining, TEXT("ntuser.dat")))) {
                RegCloseKey (hkeyUser);
                return FALSE;
            }

            hFile = FindFirstFile (szBuffer, &fd);
            if (hFile != INVALID_HANDLE_VALUE)
            {
                FindClose(hFile);
                bGotTime = TRUE;
            }    
        }
        
        *lpEnd = TEXT('\0');

        
        //
        // Get the exclusionlist from the registry or ini files
        //

        if (dwFlags & PRF_USERSID)
            ReadExclusionList(NULL, szExcludeList, ARRAYSIZE(szExcludeList));
        else
            ReadExclusionListFromIniFile(szBuffer, szExcludeList, ARRAYSIZE(szExcludeList));


        //
        // Convert the exclusionlist read from the registry to a Null terminated list
        // readable by recursedirectory.
        //

        if (szExcludeList[0] != TEXT('\0'))
            lpExcludeList = ConvertExclusionList (szBuffer, szExcludeList);
        else
            lpExcludeList = NULL;

        //
        // Get the profile size
        //

        g_dwProfileSize = 0;
        *lpEnd = TEXT('\0');

        if (!RecurseDirectory (szBuffer, ARRAYSIZE(szBuffer), lpExcludeList)) {
            g_dwProfileSize = (DWORD) (-1); // Something is wrong, set the size to -1
        }

        if (lpExcludeList) {
            LocalFree (lpExcludeList);
            lpExcludeList = NULL;
        }
    }
    else
    {
        //
        //  We cannot get the attributes of the profile directory, it may not exist, or
        //  we don't have access permission to it, set the profile size to -1 to indicate
        //  this error.
        //
        g_dwProfileSize = (DWORD) (-1);
    }

    if (g_dwProfileSize == (DWORD) (-1))
    {
        if (FAILED(StringCchCopy(szProfileSize, ARRAYSIZE(szProfileSize), TEXT("-1"))))
        {
            RegCloseKey(hkeyUser);
            return FALSE;
        }
    }
    else if (!StrFormatByteSize((LONGLONG)g_dwProfileSize, szProfileSize, ARRAYSIZE(szProfileSize))) {
        RegCloseKey (hkeyUser);
        return FALSE;
    }


    //
    // check out the state information to determine profile status.
    // If the user is not logged on currently then report the status
    // of last session.
    //

    dwSize = sizeof(DWORD);
    Error = RegQueryValueEx (hkeyUser,
                             TEXT("State"),
                             NULL,
                             NULL,
                             (LPBYTE) &dwSysProfileType,
                             &dwSize);


    //
    // The constants being used come from
    // windows\gina\userenv\profile\profile.h
    //

    if (dwSysProfileType & 0x00008000) {
        dwProfileStatus = USERINFO_BACKUP;
    }
    else if (dwSysProfileType & 0x00000001) {
        dwProfileStatus = USERINFO_MANDATORY;
    } 
    else if ((dwSysProfileType & 0x00000800) ||
             (dwSysProfileType & 0x00000080)) {
        dwProfileStatus = USERINFO_TEMP;
    }
    else if (dwSysProfileType & 0x00000010) {
        dwProfileStatus = USERINFO_FLOATING;
    } 
    else {
        dwProfileStatus = USERINFO_LOCAL;
    }

    if (dwSysProfileType & 0x00000001) {
        dwProfileType = USERINFO_MANDATORY;
    } 
    else {
    
        if (bCentralAvailable) {
            dwProfileType = USERINFO_FLOATING;
        } 
        else {
            dwProfileType = USERINFO_LOCAL;
        }

        // Check User Preference

        HKEY hkeyPreference;

        if (RegOpenKeyEx(hkeyUser,
                         TEXT("Preference"),
                         0,
                         KEY_READ,
                         &hkeyPreference) == ERROR_SUCCESS)
        {
            DWORD         dwType;
            dwSize = sizeof(dwProfileType);
            Error = RegQueryValueEx (hkeyPreference,
                                     TEXT("UserPreference"),
                                     NULL,
                                     &dwType,
                                     (LPBYTE) &dwProfileType,
                                     &dwSize);
            RegCloseKey(hkeyPreference);
        }

        // Check User Preference in .bak if exist
        if (FAILED(StringCchPrintf(szBuffer,
                                   ARRAYSIZE(szBuffer),
                                   TEXT("%s\\%s.bak\\Preference"),
                                   PROFILE_MAPPING,
                                   lpSid))) {
            RegCloseKey (hkeyUser);
            return FALSE;
        }
        
        Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             szBuffer,
                             0,
                             KEY_READ,
                             &hKeyProfile);


        if (Error == ERROR_SUCCESS) {

            dwSize = sizeof(dwProfileType);
            RegQueryValueEx(hKeyProfile,
                            TEXT("UserPreference"),
                            NULL,
                            NULL,
                            (LPBYTE) &dwProfileType,
                            &dwSize);

            RegCloseKey (hKeyProfile);
        }
        
        // Check machine policy for disabling roaming profile
        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         SYSTEM_POLICIES_KEY,
                         0, KEY_READ,
                         &hKeyPolicy) == ERROR_SUCCESS) {
            DWORD dwTmpVal;

            dwSize = sizeof(dwTmpVal);
            Error = RegQueryValueEx(hKeyPolicy,
                            PROFILE_LOCALONLY,
                            NULL, NULL,
                            (LPBYTE) &dwTmpVal,
                            &dwSize);

            RegCloseKey (hKeyPolicy);
            if (Error == ERROR_SUCCESS && dwTmpVal == 1) {
                dwProfileType = USERINFO_LOCAL;
            }
        }

        if (dwProfileType == USERINFO_FLOATING) {

            BOOL bReadOnly = FALSE;
            HKEY hSubKey;

            //
            // Check for a roaming profile security/read only preference
            //

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_READ,
                             &hSubKey) == ERROR_SUCCESS) {

                dwSize = sizeof(bReadOnly);
                RegQueryValueEx(hSubKey, READONLY_RUP, NULL, NULL,
                                (LPBYTE) &bReadOnly, &dwSize);

                RegCloseKey(hSubKey);
            }


            //
            // Check for a roaming profile security/read only policy
            //

            if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SYSTEM_POLICIES_KEY, 0, KEY_READ,
                             &hSubKey) == ERROR_SUCCESS) {

                dwSize = sizeof(bReadOnly);
                RegQueryValueEx(hSubKey, READONLY_RUP, NULL, NULL,
                                (LPBYTE) &bReadOnly, &dwSize);
                RegCloseKey(hSubKey);
            }


            if (bReadOnly) {
                dwProfileType = USERINFO_READONLY;
            }
        }           
    }        

    switch (dwProfileStatus) {
        case USERINFO_MANDATORY:
            iStatusID = IDS_UP_MANDATORY;
            break;

        case USERINFO_BACKUP:
            iStatusID = IDS_UP_BACKUP;
            break;

        case USERINFO_TEMP:
            iStatusID = IDS_UP_TEMP;
            break;

        case USERINFO_FLOATING:
            iStatusID = IDS_UP_FLOATING;
            break;

        default:
            iStatusID = IDS_UP_LOCAL;
            break;
    }

    switch (dwProfileType) {
        case USERINFO_MANDATORY:
            iTypeID = IDS_UP_MANDATORY;
            break;

        case USERINFO_READONLY:
            iTypeID = IDS_UP_READONLY;
            break;

        case USERINFO_FLOATING:
            iTypeID = IDS_UP_FLOATING;
            break;

        default:
            iTypeID = IDS_UP_LOCAL;
            break;
    }

    //
    // Get the friendly display name
    //

    Error = RegQueryValueEx (hkeyUser, TEXT("Sid"), NULL, NULL, NULL, &dwSize);

    if (Error != ERROR_SUCCESS) {
        RegCloseKey (hkeyUser);
        return FALSE;
    }


    pSid = LocalAlloc (LPTR, dwSize);

    if (!pSid) {
        RegCloseKey (hkeyUser);
        return FALSE;
    }


    Error = RegQueryValueEx (hkeyUser,
                             TEXT("Sid"),
                             NULL,
                             NULL,
                             (LPBYTE)pSid,
                             &dwSize);

    if (Error != ERROR_SUCCESS) {
        RegCloseKey (hkeyUser);
        LocalFree (pSid);
        return FALSE;
    }


    //
    // Get the friendly names
    //

    szTemp[0] = TEXT('\0');

    dwBufSize = ARRAYSIZE(szTemp);
    dwBuf2Size = ARRAYSIZE(szTemp2);

    if (!LookupAccountSid (NULL, pSid, szTemp, &dwBufSize,
                           szTemp2, &dwBuf2Size, &SidName)) {

        //
        // Unknown account
        //

        LoadString (hInstance, IDS_UP_ACCUNKNOWN, szBuffer, ARRAYSIZE(szBuffer));
        bAccountUnknown = TRUE;

    } else {

        if (szTemp[0] != TEXT('\0')) {
            //
            // Build the display name
            //

            if (FAILED(StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("%s\\%s"), szTemp2, szTemp))) {
                LoadString (hInstance, IDS_UP_ACCUNKNOWN, szBuffer, ARRAYSIZE(szBuffer));
                bAccountUnknown = TRUE;
            }
            else {
                bAccountUnknown = FALSE;
            }

        } else {

            //
            // Account deleted.
            //

            LoadString (hInstance, IDS_UP_ACCDELETED, szBuffer, ARRAYSIZE(szBuffer));
            bAccountUnknown = TRUE;
        }
    }

    //
    // Free the sid
    //

    LocalFree (pSid);

    //
    // Allocate a UserInfo structure
    //

    dwSize = lstrlen (lpSid) + 1;
    dwBuf2Size = lstrlen (szBuffer2) + 1;
    dwBufSize = lstrlen (szBuffer) + 1;


    lpUserInfo = (LPUSERINFO) LocalAlloc(LPTR, (sizeof(USERINFO) +
                                              dwSize * sizeof(TCHAR) +
                                              dwBuf2Size * sizeof(TCHAR) + 
                                              dwBufSize * sizeof(TCHAR)));

    if (!lpUserInfo) {
        RegCloseKey (hkeyUser);
        return FALSE;
    }

    lpUserInfo->dwFlags = (bCentralAvailable ? USERINFO_FLAG_CENTRAL_AVAILABLE : 0);
    lpUserInfo->dwFlags |= (bAccountUnknown ? USERINFO_FLAG_ACCOUNT_UNKNOWN : 0);    
    lpUserInfo->lpSid = (LPTSTR)((LPBYTE)lpUserInfo + sizeof(USERINFO));
    lpUserInfo->lpProfile = (LPTSTR) (lpUserInfo->lpSid + dwSize);
    lpUserInfo->lpUserName = (LPTSTR) (lpUserInfo->lpProfile + dwBuf2Size);

    if (FAILED(StringCchCopy(lpUserInfo->lpSid, dwSize, lpSid))) {
        ASSERT (FALSE);
    }
    if (FAILED(StringCchCopy(lpUserInfo->lpProfile, dwBuf2Size, szBuffer2))) {
        ASSERT (FALSE);
    }
    lpUserInfo->dwProfileType = dwProfileType;
    lpUserInfo->dwProfileStatus = dwProfileStatus;
    if (FAILED(StringCchCopy(lpUserInfo->lpUserName, dwBufSize, szBuffer))) {
        ASSERT (FALSE);
    }


    //
    // Add the item to the listview
    //

    hwndTemp = GetDlgItem (hDlg, IDC_UP_LISTVIEW);


    item.mask = LVIF_TEXT | LVIF_PARAM;
    item.iItem = 0;
    item.iSubItem = 0;
    item.pszText = szBuffer;
    item.lParam = (LPARAM) lpUserInfo;

    iItem = ListView_InsertItem (hwndTemp, &item);


    //
    // Add the profile size
    //

    item.mask = LVIF_TEXT;
    item.iItem = iItem;
    item.iSubItem = 1;
    item.pszText = szProfileSize;

    SendMessage (hwndTemp, LVM_SETITEMTEXT, iItem, (LPARAM) &item);


    //
    // Add the profile type
    //

    LoadString (hInstance, iTypeID, szTemp, ARRAYSIZE(szTemp));

    item.mask = LVIF_TEXT;
    item.iItem = iItem;
    item.iSubItem = 2;
    item.pszText = szTemp;

    SendMessage (hwndTemp, LVM_SETITEMTEXT, iItem, (LPARAM) &item);

    //
    // Add the profile status
    //

    LoadString (hInstance, iStatusID, szTemp, ARRAYSIZE(szTemp));

    item.mask = LVIF_TEXT;
    item.iItem = iItem;
    item.iSubItem = 3;
    item.pszText = szTemp;

    SendMessage (hwndTemp, LVM_SETITEMTEXT, iItem, (LPARAM) &item);


    if (bGotTime)
    {
        //
        // Convert it to local time
        //

        if (!FileTimeToLocalFileTime(&fd.ftLastAccessTime, &ftLocal)) {
            ftLocal = fd.ftLastAccessTime;
        }


        //
        // Add the time/date stamp
        //

        FileTimeToSystemTime (&ftLocal, &systime);

        GetDateFormat (LOCALE_USER_DEFAULT, DATE_SHORTDATE, &systime,
                        NULL, szBuffer, MAX_PATH);
    }

    item.mask = LVIF_TEXT;
    item.iItem = iItem;
    item.iSubItem = 4;
    item.pszText = bGotTime ? szBuffer : TEXT("");

    SendMessage (hwndTemp, LVM_SETITEMTEXT, iItem, (LPARAM) &item);

    RegCloseKey (hkeyUser);

    return TRUE;
}

//*************************************************************
//
//  FillListView()
//
//  Purpose:    Fills the listview with either all the profiles
//              or just the current user profile depending if
//              the user has Admin privilages
//
//  Parameters: hDlg            -   Dialog box handle
//              bAdmin          -   User an admin
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              1/26/96     ericflo    Created
//
//*************************************************************

BOOL FillListView (HWND hDlg, BOOL bAdmin)
{
    LV_ITEM item;
    BOOL bRetVal = FALSE;
    LPTSTR lpUserSid;

    lpUserSid = GetSidString();

    //
    // If the current user has admin privilages, then
    // he/she can see all the profiles on this machine,
    // otherwise the user only gets their profile.
    //

    if (bAdmin) {

        DWORD SubKeyIndex = 0;
        TCHAR SubKeyName[100];
        DWORD cchSubKeySize;
        HKEY hkeyProfiles;
        LONG Error;


        //
        // Open the profile list
        //

        Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                             PROFILE_MAPPING,
                             0,
                             KEY_READ,
                             &hkeyProfiles);

        if (Error != ERROR_SUCCESS) {
            if (lpUserSid)
                DeleteSidString (lpUserSid);
            return FALSE;
        }


        cchSubKeySize = ARRAYSIZE(SubKeyName);

        while (TRUE) {

            //
            // Get the next sub-key name
            //

            Error = RegEnumKey(hkeyProfiles, SubKeyIndex, SubKeyName, cchSubKeySize);


            if (Error != ERROR_SUCCESS) {

                if (Error == ERROR_NO_MORE_ITEMS) {

                    //
                    // Successful end of enumeration
                    //

                    Error = ERROR_SUCCESS;

                }

                break;
            }


            if ((lpUserSid) && (lstrcmp(SubKeyName, lpUserSid) == 0))
                AddUser (hDlg, SubKeyName, PRF_USERSID);
            else
                AddUser (hDlg, SubKeyName, 0);


            //
            // Go enumerate the next sub-key
            //

            SubKeyIndex ++;
        }

        //
        // Close the registry
        //

        RegCloseKey (hkeyProfiles);

        bRetVal = ((Error == ERROR_SUCCESS) ? TRUE : FALSE);

    } else {

        //
        // The current user doesn't have admin privilages
        //

        if (lpUserSid) {
            AddUser (hDlg, lpUserSid, PRF_USERSID);
            bRetVal = TRUE;
        }
    }

    if (bRetVal) {
        //
        // Select the first item
        //

        item.mask = LVIF_STATE;
        item.iItem = 0;
        item.iSubItem = 0;
        item.state = LVIS_SELECTED | LVIS_FOCUSED;
        item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

        SendDlgItemMessage (hDlg, IDC_UP_LISTVIEW,
                            LVM_SETITEMSTATE, 0, (LPARAM) &item);
    }

    if (lpUserSid)
        DeleteSidString (lpUserSid);

    return (bRetVal);
}

//*************************************************************
//
//  CheckSemicolon()
//
//  Purpose:    Checks for an ending semicolon and adds one if
//              it is missing.
//
//  Parameters: lpDir   -   directory
//              cchSize -   buffer size in character
//
//  Return:     TRUE   - success
//              FALSE  - Insufficient buffer space
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/19/95     ericlfo    Created
//
//*************************************************************
BOOL CheckSemicolon (LPTSTR lpDir, UINT cchBuffer)
{
    UINT  cchDir = lstrlen(lpDir);
    LPTSTR lpEnd;

    lpEnd = lpDir + cchDir;

    if (*(lpEnd - 1) != TEXT(';')) {
        if (cchDir + 1 >= cchBuffer) {
            return FALSE;  // No space to put ;, should never happen
        }
        *lpEnd =  TEXT(';');
        lpEnd++;
        *lpEnd =  TEXT('\0');
    }

    return TRUE;
}

//*************************************************************
//
//  ReadExclusionList()
//
//  Purpose:    Reads the exclusionlist for the user from the 
//              hkcu part of the registry
//
//  Parameters: hKeyUser - Key to user's hive, NULL if HKCU
//              szExclusionList - Buffer for exclusionList to be read into
//              cchExcludeList  - Size of the buffer
//
//  Return:     FALSE on error
//
//*************************************************************

BOOL ReadExclusionList(HKEY hKeyUser, LPTSTR szExcludeList, DWORD cchExcludeList)
{
    TCHAR szExcludeList2[MAX_PATH];
    TCHAR szExcludeList1[MAX_PATH];
    HKEY  hKey = NULL;
    DWORD dwSize;
    HRESULT hr;

    //
    // Check for a list of directories to exclude both user preferences
    // and user policy
    //

    szExcludeList1[0] = TEXT('\0');
    if (RegOpenKeyEx (hKeyUser ? hKeyUser : HKEY_CURRENT_USER,
                      WINLOGON_KEY, 0, 
                      KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(szExcludeList1);
        if (RegQueryValueEx (hKey,
                             TEXT("ExcludeProfileDirs"),
                             NULL,
                             NULL,
                             (LPBYTE) szExcludeList1,
                             &dwSize) != ERROR_SUCCESS) {

            // ignore user exclusion list
            szExcludeList1[0] = TEXT('\0');
        }

        RegCloseKey (hKey);
    }

    szExcludeList2[0] = TEXT('\0');
    if (RegOpenKeyEx (HKEY_CURRENT_USER,
                      SYSTEM_POLICIES_KEY,
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwSize = sizeof(szExcludeList2);
        if (RegQueryValueEx (hKey,
                             TEXT("ExcludeProfileDirs"),
                             NULL,
                             NULL,
                             (LPBYTE) szExcludeList2,
                             &dwSize) != ERROR_SUCCESS) {

            // ignore policy exclusion list
            szExcludeList2[0] = TEXT('\0');
        }

        RegCloseKey (hKey);
    }


    //
    // Merge the user preferences and policy together
    //

    szExcludeList[0] = TEXT('\0');

    if (szExcludeList1[0] != TEXT('\0')) {
        hr = StringCchCopy(szExcludeList, cchExcludeList, szExcludeList1);
        if (FAILED(hr)) {
            szExcludeList[0] = TEXT('\0');
            return FALSE;
        }

        if (!CheckSemicolon(szExcludeList, cchExcludeList)) {
            szExcludeList[0] = TEXT('\0');
            return FALSE;
        }
    }

    if (szExcludeList2[0] != TEXT('\0')) {
        hr = StringCchCat(szExcludeList, cchExcludeList, szExcludeList2);
        if (FAILED(hr)) {
            szExcludeList[0] = TEXT('\0');
            return FALSE;
        }
    }

    return TRUE;
}

//*************************************************************
//
//  ReadExclusionListFromIniFile()
//
//  Purpose:    Reads the exclusionlist for the user from the 
//              ntuser.ini from the local profile
//
//  Parameters: 
//              (in) lpSourceDir     - Profile Directory
//                   szExclusionList - Buffer for exclusionList to be read into
//                   cchExcludeList  - Size of the buffer
//
//  Return:     FALSE on error
//
//
//*************************************************************

BOOL ReadExclusionListFromIniFile(LPCTSTR lpSourceDir, LPTSTR szExcludeList, DWORD cchExcludeList)
{
    TCHAR szNTUserIni[MAX_PATH];
    LPTSTR lpEnd;

    //
    // Get the exclusion list from the cache
    //

    szExcludeList[0] = TEXT('\0');

    if (FAILED(StringCchCopy(szNTUserIni, ARRAYSIZE(szNTUserIni), lpSourceDir))) {
        return FALSE;
    }
    lpEnd = CheckSlashEx(szNTUserIni, ARRAYSIZE(szNTUserIni), NULL);
    if (!lpEnd)
    {
        return FALSE;
    }
    if (FAILED(StringCchCat(szNTUserIni, ARRAYSIZE(szNTUserIni), c_szNTUserIni))) {
        return FALSE;
    }

    GetPrivateProfileString (PROFILE_GENERAL_SECTION,
                             PROFILE_EXCLUSION_LIST,
                             TEXT(""), 
                             szExcludeList,
                             cchExcludeList,
                             szNTUserIni);

    return TRUE;
}

//*************************************************************
//
//  ConvertExclusionList()
//
//  Purpose:    Converts the semi-colon profile relative exclusion
//              list to fully qualified null terminated exclusion
//              list
//
//  Parameters: lpSourceDir     -  Profile root directory
//              lpExclusionList -  List of directories to exclude
//
//  Return:     List if successful
//              NULL if an error occurs
//
//*************************************************************

LPTSTR ConvertExclusionList (LPCTSTR lpSourceDir, LPCTSTR lpExclusionList)
{
    LPTSTR lpExcludeList = NULL, lpInsert, lpEnd, lpTempList;
    LPCTSTR lpTemp, lpDir;
    TCHAR szTemp[MAX_PATH];
    DWORD dwSize = 2;  // double null terminator
    DWORD dwStrLen;
    UINT  cchRemaining;
    HRESULT hr;


    //
    // Setup a temp buffer to work with
    //
    hr = StringCchCopy(szTemp, ARRAYSIZE(szTemp), lpSourceDir);
    if (FAILED(hr)) {
        return NULL;
    }
    lpEnd = CheckSlashEx(szTemp, ARRAYSIZE(szTemp), &cchRemaining);
    if (!lpEnd)
    {
        return NULL;
    }

    //
    // Loop through the list
    //

    lpTemp = lpDir = lpExclusionList;

    while (*lpTemp) {

        //
        // Look for the semicolon separator
        //

        while (*lpTemp && ((*lpTemp) != TEXT(';'))) {
            lpTemp++;
        }


        //
        // Remove any leading spaces
        //

        while (*lpDir == TEXT(' ')) {
            lpDir++;
        }

        //
        // Check whether the entry is empty
        //

        if (lpDir == lpTemp) {
            // If we are at the end of the exclusion list, we're done
            if (!*lpTemp) {
                goto Exit;
            }

            //
            // Prep for the next entry
            //

            lpTemp++;
            lpDir = lpTemp;
            continue;
        }

        //
        // Put the directory name on the temp buffer
        //

        *lpEnd = TEXT('\0');
        hr = StringCchCatN(lpEnd, cchRemaining, lpDir, (int)(lpTemp - lpDir));
        if (FAILED(hr)) {
            LocalFree (lpExcludeList);
            lpExcludeList = NULL;
            goto Exit;
        }

        //
        // Add the string to the exclusion list
        //

        if (lpExcludeList) {

            dwStrLen = lstrlen (szTemp) + 1;
            dwSize += dwStrLen;

            lpTempList = (LPTSTR) LocalReAlloc (lpExcludeList, dwSize * sizeof(TCHAR),
                                       LMEM_MOVEABLE | LMEM_ZEROINIT);

            if (!lpTempList) {
                LocalFree (lpExcludeList);
                lpExcludeList = NULL;
                goto Exit;
            }

            lpExcludeList = lpTempList;

            lpInsert = lpExcludeList + dwSize - dwStrLen - 1;
            hr = StringCchCopy(lpInsert, dwStrLen, szTemp);
            if (FAILED(hr)) {
                LocalFree (lpExcludeList);
                lpExcludeList = NULL;
                goto Exit;
            }

        } else {

            dwSize += lstrlen (szTemp);
            lpExcludeList = (LPTSTR) LocalAlloc (LPTR, dwSize * sizeof(TCHAR));

            if (!lpExcludeList) {
                goto Exit;
            }

            hr = StringCchCopy(lpExcludeList, dwSize, szTemp);
            if (FAILED(hr)) {
                LocalFree (lpExcludeList);
                lpExcludeList = NULL;
                goto Exit;
            }
        }


        //
        // If we are at the end of the exclusion list, we're done
        //

        if (!(*lpTemp)) {
            goto Exit;
        }


        //
        // Prep for the next entry
        //

        lpTemp++;
        lpDir = lpTemp;
    }

Exit:

    return lpExcludeList;
}

//*************************************************************
//
//  RecurseDirectory()
//
//  Purpose:    Recurses through the subdirectories counting the size.
//
//  Parameters: lpDir     -   Directory
//              cchBuffer -   Buffer size in char
//              lpExcludeList -   Null-termed list of dirs to be skipped (optional)             
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              1/30/96     ericflo    Created
//
// Notes:
//      The buffer size expected is MAX_PATH+4 for some internal processing
// We should fix this to be better post Win 2K.
//*************************************************************

BOOL RecurseDirectory (LPTSTR lpDir, UINT cchBuffer, LPTSTR lpExcludeList)
{
    HANDLE hFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fd;
    LPTSTR lpEnd, lpTemp;
    BOOL bResult = TRUE;
    BOOL bSkip;
    UINT cchRemaining;
    HRESULT hr;


    //
    // Setup the ending pointer
    //

    lpEnd = CheckSlashEx(lpDir, cchBuffer, &cchRemaining); 
    if (!lpEnd)
    {
        bResult = FALSE;
        goto RecurseDir_Exit;
    }

    //
    // Append *.* to the source directory
    //

    hr = StringCchCopy(lpEnd, cchRemaining, TEXT("*.*"));
    if (FAILED(hr)) {
        bResult = FALSE;
        goto RecurseDir_Exit;
    }

    //
    // Search through the source directory
    //

    hFile = FindFirstFile(lpDir, &fd);

    if (hFile == INVALID_HANDLE_VALUE) {

        if ( (GetLastError() == ERROR_FILE_NOT_FOUND) ||
             (GetLastError() == ERROR_PATH_NOT_FOUND) ) {

            //
            // bResult is already initialized to TRUE, so
            // just fall through.
            //

        } else {

            bResult = FALSE;
        }

        goto RecurseDir_Exit;
    }


    do {

        //
        // Append the file / directory name to the working buffer
        //

        // skip the file if the path > MAX_PATH
        
        if ((UINT)(1+lstrlen(fd.cFileName)+lstrlen(lpDir)+lstrlen(TEXT("\\*.*"))) >= cchBuffer) {
            continue;
        }

        hr = StringCchCopy(lpEnd, cchRemaining, fd.cFileName);
        if (FAILED(hr)) {
            bResult = FALSE;
            goto RecurseDir_Exit;
        }

        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            // Check for "." and ".."
            //

            if (!lstrcmpi(fd.cFileName, TEXT("."))) {
                continue;
            }

            if (!lstrcmpi(fd.cFileName, TEXT(".."))) {
                continue;
            }

            //
            // Check for reparse point
            //

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_REPARSE_POINT) {
                continue;
            }

            //
            // Check if this directory should be excluded
            //

            if (lpExcludeList) {

                bSkip = FALSE;
                lpTemp = lpExcludeList;

                while (*lpTemp) {

                    if (lstrcmpi (lpTemp, lpDir) == 0) {
                        bSkip = TRUE;
                        break;
                    }

                    lpTemp += lstrlen (lpTemp) + 1;
                }

                if (bSkip) 
                    continue;
            }

            //
            // Found a directory.
            //
            // 1)  Change into that subdirectory on the source drive.
            // 2)  Recurse down that tree.
            // 3)  Back up one level.
            //

            //
            // Recurse the subdirectory
            //

            if (!RecurseDirectory(lpDir, cchBuffer, lpExcludeList)) {
                bResult = FALSE;
                goto RecurseDir_Exit;
            }

        } else {

            //
            // Found a file, add the filesize
            //

            g_dwProfileSize += fd.nFileSizeLow;
        }


        //
        // Find the next entry
        //

    } while (FindNextFile(hFile, &fd));


RecurseDir_Exit:

    //
    // Remove the file / directory name appended above
    //

    if (lpEnd)
    {
        *lpEnd = TEXT('\0');
    }


    //
    // Close the search handle
    //

    if (hFile != INVALID_HANDLE_VALUE) {
        FindClose(hFile);
    }

    return bResult;
}

//*************************************************************
//
//  UPCleanUp()
//
//  Purpose:    Free's resources for this dialog box
//
//  Parameters: hDlg    -   Dialog box handle
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              1/31/96     ericflo    Created
//
//*************************************************************

VOID UPCleanUp (HWND hDlg)
{
    int           i, n;
    HWND          hwndTemp;
    LPUSERINFO    lpUserInfo;
    LV_ITEM       item;


    //
    //  Free memory used for the listview items
    //

    hwndTemp = GetDlgItem (hDlg, IDC_UP_LISTVIEW);
    n = (int)SendMessage (hwndTemp, LVM_GETITEMCOUNT, 0, 0L);

    item.mask = LVIF_PARAM;
    item.iSubItem = 0;

    for (i = 0; i < n; i++) {

        item.iItem = i;

        if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
            lpUserInfo = (LPUSERINFO) item.lParam;

        } else {
            lpUserInfo = NULL;
        }

        LocalFree (lpUserInfo);
    }
}

//*************************************************************
//
//  UPSave()
//
//  Purpose:    Saves the settings
//
//  Parameters: hDlg    -   Dialog box handle
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              1/31/96     ericflo    Created
//
//*************************************************************

VOID UPSave (HWND hDlg)
{
    int           i, n;
    HWND          hwndTemp;
    LPUSERINFO    lpUserInfo;
    LV_ITEM       item;
    TCHAR         szBuffer[MAX_PATH];
    HKEY          hkeyUser;
    LONG          Error;


    //
    //  Save type info
    //

    hwndTemp = GetDlgItem (hDlg, IDC_UP_LISTVIEW);
    n = (int)SendMessage (hwndTemp, LVM_GETITEMCOUNT, 0, 0L);

    item.mask = LVIF_PARAM;
    item.iSubItem = 0;

    for (i = 0; i < n; i++) {

        item.iItem = i;

        if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
            lpUserInfo = (LPUSERINFO) item.lParam;

        } else {
            lpUserInfo = NULL;
        }

        if (lpUserInfo) {

            if (lpUserInfo->dwFlags & USERINFO_FLAG_DIRTY) {

                lpUserInfo->dwFlags &= ~USERINFO_FLAG_DIRTY;

                if (FAILED(StringCchPrintf(szBuffer,
                                           ARRAYSIZE(szBuffer),
                                           TEXT("%s\\%s\\Preference"), 
                                           PROFILE_MAPPING,
                                           lpUserInfo->lpSid))) {
                    continue;
                }

                Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                     szBuffer,
                                     0,
                                     KEY_SET_VALUE,
                                     &hkeyUser);

                if (Error != ERROR_SUCCESS) {
                    continue;
                }

                RegSetValueEx (hkeyUser,
                               TEXT("UserPreference"),
                               0,
                               REG_DWORD,
                               (LPBYTE) &lpUserInfo->dwProfileType,
                               sizeof(DWORD));

                RegCloseKey(hkeyUser);
            }
        }
    }
}

//*************************************************************
//
//  IsProfileInUse()
//
//  Purpose:    Determines if the given profile is currently in use
//
//  Parameters: lpSid   -   Sid (text) to test
//
//  Return:     TRUE if in use
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/7/96      ericflo    Created
//
//*************************************************************

BOOL IsProfileInUse (LPTSTR lpSid)
{
    LONG lResult;
    HKEY hkeyProfile;


    lResult = RegOpenKeyEx (HKEY_USERS, lpSid, 0, KEY_READ, &hkeyProfile);

    if (lResult == ERROR_SUCCESS) {
        RegCloseKey (hkeyProfile);
        return TRUE;
    }

    return FALSE;
}

void UPDoItemChanged(HWND hDlg, int idCtl)
{
    int     selection;
    HWND    hwndTemp;
    LPUSERINFO lpUserInfo;
    LV_ITEM item;


    hwndTemp = GetDlgItem (hDlg, idCtl);

    selection = GetSelectedItem (hwndTemp);

    if (selection != -1)
    {
        item.mask = LVIF_PARAM;
        item.iItem = selection;
        item.iSubItem = 0;

        if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
            lpUserInfo = (LPUSERINFO) item.lParam;

        } else {
            lpUserInfo = NULL;
        }

        if (lpUserInfo) {

            //
            //  Set the "Delete" button state
            //

            if (IsProfileInUse(lpUserInfo->lpSid)) {
                EnableWindow (GetDlgItem (hDlg, IDC_UP_DELETE), FALSE);

            } else {
                EnableWindow (GetDlgItem (hDlg, IDC_UP_DELETE), TRUE);
            }


            //
            // Set the "Change Type" button state
            //

            OSVERSIONINFOEXW version;
            version.dwOSVersionInfoSize = sizeof(version);

            if (GetVersionEx((LPOSVERSIONINFO)&version) && 
                (version.wSuiteMask & VER_SUITE_PERSONAL)) {
                ShowWindow(GetDlgItem (hDlg, IDC_UP_TYPE), SW_HIDE);
            }
            else if((lpUserInfo->dwProfileType == USERINFO_MANDATORY) || 
                    (lpUserInfo->dwProfileType == USERINFO_BACKUP)) {
                EnableWindow (GetDlgItem (hDlg, IDC_UP_TYPE), FALSE);
            } else {
                EnableWindow (GetDlgItem (hDlg, IDC_UP_TYPE), TRUE);
            }

            //
            // Set the "Copy To" button state
            //

            if ((lpUserInfo->dwFlags & USERINFO_FLAG_ACCOUNT_UNKNOWN) ||
                IsProfileInUse(lpUserInfo->lpSid)) {
                EnableWindow (GetDlgItem (hDlg, IDC_UP_COPY), FALSE);
            } else {
                EnableWindow (GetDlgItem (hDlg, IDC_UP_COPY), TRUE);
            }
        }
    }
    else {

        //
        // If nothing is selected set all buttons to inactive
        //
        
        EnableWindow (GetDlgItem (hDlg, IDC_UP_DELETE), FALSE);
        EnableWindow (GetDlgItem (hDlg, IDC_UP_TYPE), FALSE);
        EnableWindow (GetDlgItem (hDlg, IDC_UP_COPY), FALSE);
    }
}

//*************************************************************

void 
UPOnLink(WPARAM wParam)
{
    switch(wParam)
    {
    case IDC_UP_UPLINK:
        {
            SHELLEXECUTEINFO execinfo = {0};

            execinfo.cbSize = sizeof(execinfo);
            execinfo.nShow = SW_SHOW;
            execinfo.lpVerb = TEXT("open");
            execinfo.lpFile = TEXT("control");
            execinfo.lpParameters = TEXT("userpasswords");

            ShellExecuteEx(&execinfo);
        }
        break;
    default:
        break;
    }
    
}

//*************************************************************
//
//  UPDeleteProfile()
//
//  Purpose:    Deletes a user's profile
//
//  Parameters: hDlg    -   Dialog box handle
//
//  Return:
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/8/96      ericflo    Created
//
//*************************************************************

void UPDeleteProfile(HWND hDlg)
{
    int     selection;
    HWND    hwndTemp;
    LPUSERINFO lpUserInfo;
    LV_ITEM item;
    TCHAR   szName[100];
    TCHAR   szBuffer1[100];
    TCHAR   szBuffer2[200];
    HCURSOR hOldCursor;


    //
    // Get the selected profile
    //

    hwndTemp = GetDlgItem (hDlg, IDC_UP_LISTVIEW);

    selection = GetSelectedItem (hwndTemp);

    if (selection == -1) {
        return;
    }

    item.mask = LVIF_PARAM;
    item.iItem = selection;
    item.iSubItem = 0;

    if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
        lpUserInfo = (LPUSERINFO) item.lParam;

    } else {
        lpUserInfo = NULL;
    }

    if (!lpUserInfo) {
        return;
    }


    //
    // Confirm that the user really wants to delete the profile
    //

    szBuffer1[0] = TEXT('\0');
    ListView_GetItemText (hwndTemp, selection, 0, szName, ARRAYSIZE(szName));

    LoadString (hInstance, IDS_UP_CONFIRM, szBuffer1, ARRAYSIZE(szBuffer1));
    if (FAILED(StringCchPrintf(szBuffer2, ARRAYSIZE(szBuffer2), szBuffer1, szName))) {
        return;
    }

    LoadString (hInstance, IDS_UP_CONFIRMTITLE, szBuffer1, ARRAYSIZE(szBuffer1));
    if (MessageBox (hDlg, szBuffer2, szBuffer1,
                    MB_ICONQUESTION | MB_DEFBUTTON2| MB_YESNO) == IDNO) {
        return;
    }

    //
    // Delete the profile and remove the entry from the listview
    //

    hOldCursor = SetCursor (LoadCursor(NULL, IDC_WAIT));


    if (!DeleteProfile (lpUserInfo->lpSid, NULL, NULL)) {
        TCHAR szMsg[MAX_PATH];

        szMsg[0] = TEXT('\0');

        LoadString (hInstance, IDS_UP_DELETE_ERROR, szMsg, ARRAYSIZE(szMsg));

        UPDisplayErrorMessage(hDlg, GetLastError(), szMsg);    
    }    


    if (ListView_DeleteItem(hwndTemp, selection)) {
        LocalFree (lpUserInfo);
    }


    //
    // Select another item
    //

    if (selection > 0) {
        selection--;
    }

    item.mask = LVIF_STATE;
    item.iItem = selection;
    item.iSubItem = 0;
    item.state = LVIS_SELECTED | LVIS_FOCUSED;
    item.stateMask = LVIS_SELECTED | LVIS_FOCUSED;

    SendDlgItemMessage (hDlg, IDC_UP_LISTVIEW,
                        LVM_SETITEMSTATE, selection, (LPARAM) &item);


    SetCursor(hOldCursor);
}


//*************************************************************
//
//  UPChangeType()
//
//  Purpose:    Display the "Change Type" dialog box
//
//  Parameters: hDlg    -   Dialog box handle
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/09/96     ericflo    Created
//
//*************************************************************

void UPChangeType(HWND hDlg)
{
    int     selection, iTypeID;
    HWND    hwndTemp;
    LPUSERINFO lpUserInfo;
    LV_ITEM item;
    TCHAR   szType[100];


    //
    // Get the selected profile
    //

    hwndTemp = GetDlgItem (hDlg, IDC_UP_LISTVIEW);

    selection = GetSelectedItem (hwndTemp);

    if (selection == -1) {
        return;
    }

    item.mask = LVIF_PARAM;
    item.iItem = selection;
    item.iSubItem = 0;

    if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
        lpUserInfo = (LPUSERINFO) item.lParam;

    } else {
        lpUserInfo = NULL;
    }

    if (!lpUserInfo) {
        return;
    }

    // if profile type is mandatory then don't display change type dialog box.
    // Although change type button is disabled for mandatory profile this function 
    // can be still executed with double clicking on profile item.

    if (lpUserInfo->dwProfileType == USERINFO_MANDATORY || 
        lpUserInfo->dwProfileType == USERINFO_BACKUP) {
        return;
    }

    //
    // Display the Change Type dialog
    //

    if (!DialogBoxParam (hInstance, MAKEINTRESOURCE(IDD_UP_TYPE), hDlg,
                         ChangeTypeDlgProc, (LPARAM)lpUserInfo)) {
        return;
    }


    //
    // Activate the Apply button
    //

    PropSheet_Changed(GetParent(hDlg), hDlg);


    //
    // Mark this item as 'dirty' so it will be saved
    //

    lpUserInfo->dwFlags |= USERINFO_FLAG_DIRTY;


    //
    // Fix the 'Type' field in the display
    //

    switch (lpUserInfo->dwProfileType) {
        case USERINFO_MANDATORY:
            iTypeID = IDS_UP_MANDATORY;
            break;

        case USERINFO_READONLY:
            iTypeID = IDS_UP_READONLY;
            break;

        case USERINFO_FLOATING:
            iTypeID = IDS_UP_FLOATING;
            break;

        default:
            iTypeID = IDS_UP_LOCAL;
            break;
    }


    LoadString (hInstance, iTypeID, szType, ARRAYSIZE(szType));

    item.mask = LVIF_TEXT;
    item.iItem = selection;
    item.iSubItem = 2;
    item.pszText = szType;

    SendMessage (hwndTemp, LVM_SETITEMTEXT, selection, (LPARAM) &item);

}

//*************************************************************
//
//  ChangeTypeDlgProc()
//
//  Purpose:    Dialog box procedure for changing the profile type
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/9/96      ericflo    Created
//
//*************************************************************

INT_PTR APIENTRY ChangeTypeDlgProc (HWND hDlg, UINT uMsg,
                                 WPARAM wParam, LPARAM lParam)
{
    LPUSERINFO lpUserInfo;
    HKEY hKeyPolicy;

    switch (uMsg) {
        case WM_INITDIALOG:
           lpUserInfo = (LPUSERINFO) lParam;

           if (!lpUserInfo) {
               EndDialog(hDlg, FALSE);
               break;
           }
           else {
               TCHAR      szMsg[MAX_PATH], szMsg1[MAX_PATH];
               
               szMsg[0] = TEXT('\0');

               LoadString (hInstance, IDS_UP_CHANGETYPEMSG, szMsg, ARRAYSIZE(szMsg));
               
               StringCchPrintf (szMsg1, ARRAYSIZE(szMsg1), szMsg, lpUserInfo->lpUserName);

               SetDlgItemText (hDlg, IDC_UPTYPE_GROUP, szMsg1);
               
           }

           SetWindowLongPtr (hDlg, GWLP_USERDATA, (LPARAM) lpUserInfo);



           if (lpUserInfo->dwFlags & USERINFO_FLAG_CENTRAL_AVAILABLE) {

               if (lpUserInfo->dwProfileType == USERINFO_LOCAL) {
                   CheckRadioButton (hDlg, IDC_UPTYPE_LOCAL, IDC_UPTYPE_FLOAT,
                                     IDC_UPTYPE_LOCAL);

                   if (lpUserInfo->dwProfileStatus == USERINFO_TEMP) {
                       EnableWindow (GetDlgItem(hDlg, IDC_UPTYPE_FLOAT), FALSE);
                       EnableWindow (GetDlgItem(hDlg, IDOK), FALSE);
                       SetDefButton(hDlg, IDCANCEL);
                   }
                   else if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                                    SYSTEM_POLICIES_KEY,
                                    0, KEY_READ,
                                    &hKeyPolicy) == ERROR_SUCCESS) {
                       DWORD dwTmpVal, dwSize;

                       dwSize = sizeof(dwTmpVal);
                       RegQueryValueEx(hKeyPolicy,
                                       PROFILE_LOCALONLY,
                                       NULL, NULL,
                                       (LPBYTE) &dwTmpVal,
                                       &dwSize);

                       RegCloseKey (hKeyPolicy);
                       if (dwTmpVal == 1) {   
                           EnableWindow (GetDlgItem(hDlg, IDC_UPTYPE_FLOAT), FALSE);
                           EnableWindow (GetDlgItem(hDlg, IDOK), FALSE);
                           SetDefButton(hDlg, IDCANCEL);
                       }
                   }    

               }
               else if (lpUserInfo->dwProfileStatus == USERINFO_TEMP) {
                   CheckRadioButton (hDlg, IDC_UPTYPE_LOCAL, IDC_UPTYPE_FLOAT,
                                     IDC_UPTYPE_FLOAT);
                   EnableWindow (GetDlgItem(hDlg, IDC_UPTYPE_LOCAL), FALSE);
                   EnableWindow (GetDlgItem(hDlg, IDOK), FALSE);
                   SetDefButton(hDlg, IDCANCEL);
               }
               else {  // ProfileType is USERINFO_FLOATING
                   CheckRadioButton (hDlg, IDC_UPTYPE_LOCAL, IDC_UPTYPE_FLOAT,
                                     IDC_UPTYPE_FLOAT);
               }              
 
           } else {

               CheckRadioButton (hDlg, IDC_UPTYPE_LOCAL, IDC_UPTYPE_FLOAT,
                                 IDC_UPTYPE_LOCAL);
               EnableWindow (GetDlgItem(hDlg, IDC_UPTYPE_FLOAT), FALSE);
               EnableWindow (GetDlgItem(hDlg, IDOK), FALSE);
               SetDefButton(hDlg, IDCANCEL);
           }

           return TRUE;

        case WM_COMMAND:

          switch (LOWORD(wParam)) {
              case IDOK:

                  lpUserInfo = (LPUSERINFO) GetWindowLongPtr(hDlg, GWLP_USERDATA);

                  if (!lpUserInfo) {
                      EndDialog (hDlg, FALSE);
                      break;
                  }

                  //
                  // Determine what the user wants
                  //

                  if (IsDlgButtonChecked(hDlg, IDC_UPTYPE_LOCAL)) {
                      lpUserInfo->dwProfileType = USERINFO_LOCAL;
                  } else {
                      BOOL bReadOnly = FALSE;
                      HKEY hSubKey;
                      DWORD dwSize;

                      //
                      // Check for a roaming profile security/read only preference
                      //

                      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, WINLOGON_KEY, 0, KEY_READ,
                                       &hSubKey) == ERROR_SUCCESS) {

                          dwSize = sizeof(bReadOnly);
                          RegQueryValueEx(hSubKey, READONLY_RUP, NULL, NULL,
                                          (LPBYTE) &bReadOnly, &dwSize);

                          RegCloseKey(hSubKey);
                      }


                      //
                      // Check for a roaming profile security/read only policy
                      //

                      if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, SYSTEM_POLICIES_KEY, 0, KEY_READ,
                                       &hSubKey) == ERROR_SUCCESS) {

                          dwSize = sizeof(bReadOnly);
                          RegQueryValueEx(hSubKey, READONLY_RUP, NULL, NULL,
                                          (LPBYTE) &bReadOnly, &dwSize);
                          RegCloseKey(hSubKey);
                      }


                      if (bReadOnly) {
                          lpUserInfo->dwProfileType = USERINFO_READONLY;
                      }
                      else {
                          lpUserInfo->dwProfileType = USERINFO_FLOATING;
                      }

                  }

                  EndDialog(hDlg, TRUE);
                  break;

              case IDCANCEL:
                  EndDialog(hDlg, FALSE);
                  break;

              default:
                  break;

          }
          break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (DWORD_PTR) (LPSTR) aUserProfileHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPSTR) aUserProfileHelpIds);
            return (TRUE);

    }

    return (FALSE);
}

//*************************************************************
//
//  UPInitCopyDlg()
//
//  Purpose:    Initializes the copy profile dialog
//
//  Parameters: hDlg    -   Dialog box handle
//              lParam  -   lParam (lpUserInfo)
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/26/96     ericflo    Created
//
//*************************************************************

BOOL UPInitCopyDlg (HWND hDlg, LPARAM lParam)
{
    LPUSERINFO lpUserInfo;
    LPUPCOPYINFO lpUPCopyInfo;
    HKEY hKey;
    LONG lResult;
    TCHAR szBuffer[MAX_PATH];
    TCHAR szTemp[100];
    TCHAR szTemp2[100];
    DWORD dwTempSize = 100, dwTemp2Size = 100;
    PSID pSid;
    DWORD dwSize;
    SID_NAME_USE SidName;
    HRESULT hr;

    lpUserInfo = (LPUSERINFO) lParam;

    if (!lpUserInfo) {
        SetLastError(ERROR_NOT_ENOUGH_MEMORY);
        return FALSE;
    }

    //
    // Create a CopyInfo structure
    //

    lpUPCopyInfo = (LPUPCOPYINFO) LocalAlloc(LPTR, sizeof(UPCOPYINFO));

    if (!lpUPCopyInfo) {
        return FALSE;
    }

    lpUPCopyInfo->dwFlags = 0;
    lpUPCopyInfo->lpUserInfo = lpUserInfo;
    lpUPCopyInfo->bDefaultSecurity = TRUE;


    //
    // Get the user's sid
    //

    hr = StringCchPrintf(szBuffer, ARRAYSIZE(szBuffer), TEXT("%s\\%s"), PROFILE_MAPPING, lpUserInfo->lpSid);
    if (FAILED(hr)) {
        LocalFree (lpUPCopyInfo);
        SetLastError(HRESULT_CODE(hr));
        return FALSE;
    }
    
    lResult = RegOpenKeyEx (HKEY_LOCAL_MACHINE,
                            szBuffer,
                            0,
                            KEY_READ,
                            &hKey);

    if (lResult != ERROR_SUCCESS) {
        LocalFree (lpUPCopyInfo);
        SetLastError(lResult);
        return FALSE;
    }

    //
    // Query for the sid size
    //

    dwSize = 0;
    lResult = RegQueryValueEx (hKey,
                               TEXT("Sid"),
                               NULL,
                               NULL,
                               NULL,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        RegCloseKey (hKey);
        LocalFree (lpUPCopyInfo);
        SetLastError(lResult);
        return FALSE;
    }


    //
    // Actually get the sid
    //

    pSid = LocalAlloc (LPTR, dwSize);

    if (!pSid) {
        RegCloseKey (hKey);
        LocalFree (lpUPCopyInfo);
        SetLastError(ERROR_OUTOFMEMORY);
        return FALSE;
    }

    lResult = RegQueryValueEx (hKey,
                               TEXT("Sid"),
                               NULL,
                               NULL,
                               (LPBYTE) pSid,
                               &dwSize);

    if (lResult != ERROR_SUCCESS) {
        RegCloseKey (hKey);
        LocalFree (pSid);
        LocalFree (lpUPCopyInfo);
        SetLastError(lResult);
        return FALSE;
    }

    lpUPCopyInfo->pSid = pSid;

    RegCloseKey (hKey);


    //
    // Get the friendly name
    //

    if (!LookupAccountSid (NULL, pSid, szTemp, &dwTempSize,
                           szTemp2, &dwTemp2Size, &SidName)) {
        LocalFree (pSid);
        LocalFree (lpUPCopyInfo);
        return FALSE;
    }


    //
    // Display nothing in the edit control till user sets it
    // explicitly
    //

    szBuffer[0] = TEXT('\0');

    SetDlgItemText (hDlg, IDC_COPY_USER, szBuffer);



    //
    // Save the copyinfo structure in the extra words
    //

    SetWindowLongPtr (hDlg, GWLP_USERDATA, (LPARAM) lpUPCopyInfo);
    EnableWindow (GetDlgItem(hDlg, IDOK), FALSE);
    SetDefButton(hDlg, IDCANCEL);

    return TRUE;
}

//*************************************************************
//
//  UPCopyProfile()
//
//  Purpose:    Displays the copy profile dialog box
//
//  Parameters: hDlg    -   Dialog box handle
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/13/96     ericflo    Created
//
//*************************************************************

void UPCopyProfile(HWND hDlg)
{
    int     selection, iTypeID;
    HWND    hwndTemp;
    LPUSERINFO lpUserInfo;
    LV_ITEM item;


    //
    // Get the selected profile
    //

    hwndTemp = GetDlgItem (hDlg, IDC_UP_LISTVIEW);

    selection = GetSelectedItem (hwndTemp);

    if (selection == -1) {
        return;
    }

    item.mask = LVIF_PARAM;
    item.iItem = selection;
    item.iSubItem = 0;

    if (SendMessage (hwndTemp, LVM_GETITEM, 0, (LPARAM) &item)) {
        lpUserInfo = (LPUSERINFO) item.lParam;

    } else {
        lpUserInfo = NULL;
    }

    if (!lpUserInfo) {
        return;
    }

    //
    // Display the Copy Profile dialog
    //

    if (!DialogBoxParam (hInstance, MAKEINTRESOURCE(IDD_UP_COPY), hDlg,
                         UPCopyDlgProc, (LPARAM)lpUserInfo)) {
        return;
    }
}


//*************************************************************
//
//  UPCopyDlgProc()
//
//  Purpose:    Dialog box procedure for copying a profile
//
//  Parameters: hDlg    -   handle to the dialog box
//              uMsg    -   window message
//              wParam  -   wParam
//              lParam  -   lParam
//
//  Return:     TRUE if message was processed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/13/96     ericflo    Created
//
//*************************************************************

INT_PTR APIENTRY UPCopyDlgProc (HWND hDlg, UINT uMsg,
                             WPARAM wParam, LPARAM lParam)
{
    LPUPCOPYINFO lpUPCopyInfo;
    WIN32_FILE_ATTRIBUTE_DATA fad;


    switch (uMsg) {
        case WM_INITDIALOG:

           if (!UPInitCopyDlg(hDlg, lParam)) {
               UPDisplayErrorMessage(hDlg, GetLastError(), NULL);
               EndDialog(hDlg, FALSE);
           }
           return TRUE;

        case WM_COMMAND:

          switch (LOWORD(wParam)) {
              case IDOK:
                  {
                  TCHAR szDir[MAX_PATH];
                  DWORD cchDir;
                  TCHAR szTemp[MAX_PATH];
                  HCURSOR hOldCursor;

                  lpUPCopyInfo = (LPUPCOPYINFO) GetWindowLongPtr(hDlg, GWLP_USERDATA);

                  if (!lpUPCopyInfo) {
                      EndDialog (hDlg, FALSE);
                      break;
                  }

                  if (!GetDlgItemText (hDlg, IDC_COPY_PATH, szTemp, ARRAYSIZE(szTemp))) {
                      break;
                  }

                  cchDir = ExpandEnvironmentStrings (szTemp, szDir, ARRAYSIZE(szDir));
                  if (!cchDir || cchDir > MAX_PATH) {
                      break;
                  }

                  //
                  // If the directory already exists "Warn the user"
                  //

                  if (GetFileAttributesEx (szDir, GetFileExInfoStandard, &fad)) {

                      if (!ConfirmDirectory(hDlg, szDir))
                          break;
                      
                      //
                      // If it is just a file, delete it
                      //
                      // If it is a directory and if the user has decided the
                      // user that needs to have permissions, then delete the directory.
                      // and set ACLs using this Sid.
                      //
                      // Otherwise if the directory doesn't exist use the default ACLs.
                      // if it does exist, use the current ACLs
                      //
                      
                      if (!(fad.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)) {
                          SetFileAttributes(szDir, FILE_ATTRIBUTE_NORMAL);
                          DeleteFile(szDir);
                      }
                      else if (!(lpUPCopyInfo->bDefaultSecurity)) {

                          if (!Delnode(szDir)) {
                              WCHAR szTitle[100], szMsgFmt[100], szMessage[600];

                              if (!LoadString (hInstance, IDS_UP_ERRORTITLE, szTitle, ARRAYSIZE(szTitle)))
                                  break;

                              if (!LoadString (hInstance, IDS_UP_DELNODE_ERROR, szMsgFmt, ARRAYSIZE(szMsgFmt)))
                                  break;

                              StringCchPrintf(szMessage, ARRAYSIZE(szMessage), szMsgFmt, szDir);
                              MessageBox(hDlg, szMessage, szTitle, MB_OK | MB_ICONSTOP);
                              break;
                          }

                      }
                  }
    
                  hOldCursor = SetCursor (LoadCursor(NULL, IDC_WAIT));

                  if (!UPCreateProfile (hDlg, lpUPCopyInfo, szDir, NULL)) {
                      SetCursor(hOldCursor);
                      break;
                  }

                  LocalFree (lpUPCopyInfo->pSid);
                  LocalFree (lpUPCopyInfo);
                  SetCursor(hOldCursor);
                  EndDialog(hDlg, TRUE);
                  }
                  break;

              case IDCANCEL:
                  lpUPCopyInfo = (LPUPCOPYINFO) GetWindowLongPtr(hDlg, GWLP_USERDATA);

                  if (lpUPCopyInfo) {
                      LocalFree (lpUPCopyInfo->pSid);
                      LocalFree(lpUPCopyInfo);
                  }

                  EndDialog(hDlg, FALSE);
                  break;

              case IDC_COPY_BROWSE:
                  {
                  BROWSEINFO BrowseInfo;
                  TCHAR      szBuffer[MAX_PATH];
                  LPITEMIDLIST pidl;


                  LoadString(hInstance, IDS_UP_DIRPICK, szBuffer, ARRAYSIZE(szBuffer));

                  BrowseInfo.hwndOwner = hDlg;
                  BrowseInfo.pidlRoot = NULL;
                  BrowseInfo.pszDisplayName = szBuffer;
                  BrowseInfo.lpszTitle = szBuffer;
                  BrowseInfo.ulFlags = BIF_RETURNONLYFSDIRS;
                  BrowseInfo.lpfn = NULL;
                  BrowseInfo.lParam = 0;

                  pidl = SHBrowseForFolder (&BrowseInfo);

                  if (pidl) {
                     SHGetPathFromIDList(pidl, szBuffer);
                     SHFree (pidl);
                     SetDlgItemText (hDlg, IDC_COPY_PATH, szBuffer);
                     SetFocus (GetDlgItem(hDlg, IDOK));
                  }

                  }
                  break;

              case IDC_COPY_PATH:
                  if (HIWORD(wParam) == EN_UPDATE) {
                      if (SendDlgItemMessage(hDlg, IDC_COPY_PATH,
                                             EM_LINELENGTH, 0, 0)) {
                          EnableWindow (GetDlgItem(hDlg, IDOK), TRUE);
                          SetDefButton(hDlg, IDOK);
                      } else {
                          EnableWindow (GetDlgItem(hDlg, IDOK), FALSE);
                          SetDefButton(hDlg, IDCANCEL);
                      }
                  }
                  break;

              case IDC_COPY_PROFILE:
                     SetFocus (GetDlgItem(hDlg, IDC_COPY_PATH));
                     break;

              case IDC_COPY_CHANGE:
                  {

                  LPUSERDETAILS lpUserDetails;
                  DWORD dwSize = 1024;
                  TCHAR szUserName[200];
                  PSID pNewSid;


                  lpUPCopyInfo = (LPUPCOPYINFO) GetWindowLongPtr(hDlg, GWLP_USERDATA);

                  if (!lpUPCopyInfo) {
                      EndDialog (hDlg, FALSE);
                      break;
                  }

                  lpUserDetails = (LPUSERDETAILS) LocalAlloc (LPTR, dwSize);

                  if (!lpUserDetails) {
                      break;
                  }
                  
                  if (UPGetUserSelection(hDlg, lpUserDetails) != S_OK) {
                      LocalFree(lpUserDetails);
                      break;
                  }

                  // Save our new sid
                  //

                  lpUPCopyInfo->bDefaultSecurity = FALSE;   // at this point user has selected a Sid

                  LocalFree (lpUPCopyInfo->pSid);
                  lpUPCopyInfo->pSid = lpUserDetails->psidUser;

                  // Update the edit control
                  StringCchCopy(szUserName, ARRAYSIZE(szUserName), lpUserDetails->pszDomainName);
                  StringCchCat(szUserName, ARRAYSIZE(szUserName), TEXT("\\"));
                  StringCchCat(szUserName, ARRAYSIZE(szUserName), lpUserDetails->pszAccountName);
                  SetDlgItemText (hDlg, IDC_COPY_USER, szUserName);

                  LocalFree(lpUserDetails->pszDomainName);
                  LocalFree(lpUserDetails->pszAccountName);

                  // Cleanup
                  LocalFree (lpUserDetails);
                  }
                  break;

              default:
                  break;

          }
          break;

        case WM_HELP:      // F1
            WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
            (DWORD_PTR) (LPSTR) aUserProfileHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPSTR) aUserProfileHelpIds);
            return (TRUE);

    }

    return (FALSE);
}


//*************************************************************
//
//  ConfirmDirectory()
//
//  Purpose:    Confirms the directory selected
//
//  Parameters: 
//              hDlg    -   handle to the parent Dialogbox
//              szDir   - Direcory selected by user that exists
//
//  Return:     TRUE if it is confirmed
//              FALSE if not
//
//  Comments:
//
//  History:    Date        Author     Comment
//              6/24/99     ushaji     Created
//
//*************************************************************

BOOL ConfirmDirectory(HWND hDlg, LPTSTR szDir)
{
    LPTSTR szMsgTemplate=NULL, szMsg1=NULL, szMsg=NULL;
    BOOL bRetVal = FALSE;

    szMsgTemplate = (LPTSTR) LocalAlloc(LPTR, sizeof(TCHAR)*MAX_PATH);

    if (!szMsgTemplate)
        goto Exit;

    szMsg1 = (LPTSTR) LocalAlloc(LPTR, sizeof(TCHAR)*MAX_PATH);

    if (!szMsg1)
        goto Exit;

        
    szMsg = (LPTSTR) LocalAlloc(LPTR, sizeof(TCHAR)*(500+MAX_PATH));

    if (!szMsg)
        goto Exit;
                          
    if (!LoadString (hInstance, IDS_UP_CONFIRMCOPYMSG, szMsgTemplate, MAX_PATH)) {
        goto Exit;
    }

    StringCchPrintf (szMsg, 500+MAX_PATH, szMsgTemplate, szDir);
                      
    if (!LoadString (hInstance, IDS_UP_CONFIRMCOPYTITLE, szMsg1, MAX_PATH)) {
        goto Exit;
    }

    if (MessageBox(hDlg, szMsg, szMsg1, 
                   MB_YESNO | MB_ICONQUESTION | MB_DEFBUTTON2) == IDYES)
        bRetVal = TRUE;

Exit:
    LocalFree(szMsgTemplate);
    LocalFree(szMsg);
    LocalFree(szMsg1);
        
    return bRetVal;
}


//*************************************************************
//
//  UPGetUserSelection()
//
//  Purpose:    Shows a UI and gets the user to select a
//              username
//
//  Parameters: hDlg          - Parent window handle
//              lpUserDetails - Pointer to an allocated user details
//                              structure which gets filled up if required
//
//
//  Return:     TRUE if successful
//              FALSE if an error occurs or user chooses cancel
//
//  Comments:
//
//  History:    Date        Author     Comment
//              4/14/99     ushaji     adapted from Rahulth
//
//*************************************************************

HRESULT UPGetUserSelection(HWND hDlg, LPUSERDETAILS lpUserDetails)
{
    PCWSTR                  apwszAttribs[] = {L"ObjectSid"};
    DWORD                   dwError = ERROR_SUCCESS;
    HRESULT                 hr = S_FALSE;
    IDsObjectPicker       * pDsObjectPicker = NULL;
    DSOP_INIT_INFO          InitInfo;
    const ULONG             cbNumScopes = 3;
    DSOP_SCOPE_INIT_INFO    ascopes[cbNumScopes];
    IDataObject           * pdo = NULL;
    STGMEDIUM               stgmedium = {TYMED_HGLOBAL, NULL};
    UINT                    cf = 0;
    PDS_SELECTION_LIST      pDsSelList = NULL;
    FORMATETC               formatetc = {
                                        (CLIPFORMAT)cf,
                                        NULL,
                                        DVASPECT_CONTENT,
                                        -1,
                                        TYMED_HGLOBAL
                                        };
    
    PDS_SELECTION           pDsSelection = NULL;
    BOOL                    bAllocatedStgMedium = FALSE;
    SAFEARRAY             * pVariantArr = NULL;
    PSID                    pSid = NULL;
    SID_NAME_USE            eUse;    
    DWORD                   dwNameLen, dwDomLen, dwSize;
   
    ZeroMemory(lpUserDetails, sizeof(USERDETAILS));
    
    // This code is not uninitializing COM.
    hr = CoInitialize(NULL);
    if (FAILED(hr))
    {
        goto Exit;
    }
    
    hr = CoCreateInstance(CLSID_DsObjectPicker, NULL, CLSCTX_INPROC_SERVER, IID_IDsObjectPicker, (void **) &pDsObjectPicker);
    if (FAILED(hr))
    {
        goto Exit;
    }

    //Initialize the scopes
    ZeroMemory (ascopes, cbNumScopes * sizeof (DSOP_SCOPE_INIT_INFO));
    
    ascopes[0].cbSize = sizeof (DSOP_SCOPE_INIT_INFO);
    ascopes[0].flType = DSOP_SCOPE_TYPE_ENTERPRISE_DOMAIN;
    ascopes[0].flScope = DSOP_SCOPE_FLAG_STARTING_SCOPE;

    ascopes[0].FilterFlags.Uplevel.flBothModes = DSOP_FILTER_USERS                  |
                                                 DSOP_FILTER_BUILTIN_GROUPS         |
                                                 DSOP_FILTER_WELL_KNOWN_PRINCIPALS  |
                                                 DSOP_FILTER_UNIVERSAL_GROUPS_DL    |
                                                 DSOP_FILTER_UNIVERSAL_GROUPS_SE    |
                                                 DSOP_FILTER_GLOBAL_GROUPS_DL       |
                                                 DSOP_FILTER_GLOBAL_GROUPS_SE       |
                                                 DSOP_FILTER_DOMAIN_LOCAL_GROUPS_DL |
                                                 DSOP_FILTER_DOMAIN_LOCAL_GROUPS_SE;

    ascopes[1].cbSize = sizeof (DSOP_SCOPE_INIT_INFO);
    ascopes[1].flType = DSOP_SCOPE_TYPE_GLOBAL_CATALOG         |
                        DSOP_SCOPE_TYPE_EXTERNAL_UPLEVEL_DOMAIN;
    ascopes[1].FilterFlags.Uplevel.flBothModes =
                                        ascopes[0].FilterFlags.Uplevel.flBothModes;
    
    ascopes[2].cbSize = sizeof (DSOP_SCOPE_INIT_INFO);
    ascopes[2].flType = DSOP_SCOPE_TYPE_TARGET_COMPUTER           |
                        DSOP_SCOPE_TYPE_DOWNLEVEL_JOINED_DOMAIN   |
                        DSOP_SCOPE_TYPE_EXTERNAL_DOWNLEVEL_DOMAIN;

    ascopes[2].FilterFlags.flDownlevel = DSOP_DOWNLEVEL_FILTER_USERS                |
                                         DSOP_DOWNLEVEL_FILTER_LOCAL_GROUPS         |
                                         DSOP_DOWNLEVEL_FILTER_GLOBAL_GROUPS        |
                                         DSOP_DOWNLEVEL_FILTER_WORLD                |
                                         DSOP_DOWNLEVEL_FILTER_AUTHENTICATED_USER   |
                                         DSOP_DOWNLEVEL_FILTER_DIALUP               |
                                         DSOP_DOWNLEVEL_FILTER_INTERACTIVE          |
                                         DSOP_DOWNLEVEL_FILTER_NETWORK;

    
    //Populate the InitInfo structure that is used to initialize the object
    //picker.
    ZeroMemory (&InitInfo, sizeof (InitInfo));
    
    InitInfo.cbSize = sizeof (InitInfo);
    InitInfo.cDsScopeInfos = cbNumScopes;
    InitInfo.aDsScopeInfos = ascopes;
    InitInfo.cAttributesToFetch = 1;
    InitInfo.apwzAttributeNames = apwszAttribs;
    
    hr = pDsObjectPicker->Initialize (&InitInfo);
    if (FAILED(hr))
    {
        goto Exit;
    }
    
    hr = pDsObjectPicker->InvokeDialog (hDlg, &pdo);
    if (FAILED(hr))
    {
        goto Exit;
    }
    
    if (S_FALSE == hr)
    {   //the user hit cancel
        goto Exit;
    }
    
    //if we are here, the user chose, OK, so find out what group was chosen
    cf = RegisterClipboardFormat (CFSTR_DSOP_DS_SELECTION_LIST);
    if (0 == cf)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }
    
    //set the clipformat for the formatetc structure
    formatetc.cfFormat = (CLIPFORMAT)cf;
    hr = pdo->GetData (&formatetc, &stgmedium);
    if (FAILED(hr))
    {
        goto Exit;
    }
    
    bAllocatedStgMedium = TRUE;
    
    pDsSelList = (PDS_SELECTION_LIST) GlobalLock(stgmedium.hGlobal);
    if (NULL == pDsSelList)
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    if (!pDsSelList->cItems)    //some item must have been selected
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }

    pDsSelection = &(pDsSelList->aDsSelection[0]);

    //we must get the ObjectSid attribute, otherwise we fail
    if (! (VT_ARRAY & pDsSelection->pvarFetchedAttributes->vt))
    {
        hr = E_UNEXPECTED;
        goto Exit;
    }
    
    pVariantArr = pDsSelection->pvarFetchedAttributes->parray;
    pSid = (PSID) pVariantArr->pvData;
    
    //store away the string representation of this sid
    dwSize = GetLengthSid (pSid);
    
    lpUserDetails->psidUser = LocalAlloc (LPTR, dwSize);
    
    if (!lpUserDetails->psidUser) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }
    
    if (!CopySid (dwSize, lpUserDetails->psidUser, pSid)) {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    lpUserDetails->pszDomainName =  (LPTSTR) LocalAlloc (LPTR, MAX_PATH*sizeof(TCHAR));
    lpUserDetails->pszAccountName = (LPTSTR) LocalAlloc (LPTR, MAX_PATH*sizeof(TCHAR));

    if ((!lpUserDetails->pszDomainName) || (!lpUserDetails->pszAccountName)) {
        hr = E_OUTOFMEMORY;
        goto Exit;
    }

    dwNameLen = dwDomLen = MAX_PATH;

    if (!LookupAccountSid (NULL, pSid, lpUserDetails->pszAccountName, &dwNameLen, 
                           lpUserDetails->pszDomainName, &dwDomLen,
                           &eUse))
    {
        hr = HRESULT_FROM_WIN32(GetLastError());
        goto Exit;
    }

    hr = S_OK;

    
Exit:
    if (pDsSelList)
        GlobalUnlock (stgmedium.hGlobal);

    if (bAllocatedStgMedium)
        ReleaseStgMedium (&stgmedium);

    if (pdo)
        pdo->Release();

    if (pDsObjectPicker)
        pDsObjectPicker->Release ();
    
    if (hr != S_OK) {
        LocalFree(lpUserDetails->psidUser);
        LocalFree(lpUserDetails->pszDomainName);
        LocalFree(lpUserDetails->pszAccountName);
    }

    return hr;
}


//*************************************************************
//
//  UPCreateProfile()
//
//  Purpose:    Creates a copy of the specified profile with
//              the correct security.
//
//  Parameters: lpUPCopyInfo  -   Copy Dialog information
//              lpDest      -   Destination directory
//              pNewSecDesc -   New security descriptor
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/13/96     ericflo    Created
//
//*************************************************************

BOOL UPCreateProfile (HWND hDlg, LPUPCOPYINFO lpUPCopyInfo, LPTSTR lpDest,
                      PSECURITY_DESCRIPTOR pNewSecDesc)
{
    HKEY RootKey, hKey;
    SECURITY_DESCRIPTOR sd;
    SECURITY_ATTRIBUTES sa;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidUser = NULL, psidSystem = NULL, psidAdmin = NULL;
    DWORD cbAcl, AceIndex, dwSize;
    ACE_HEADER * lpAceHeader;
    HANDLE hFile;
    BOOL bMandatory = FALSE;
    TCHAR szTempPath[MAX_PATH];
    TCHAR szBuffer[MAX_PATH];
    TCHAR szHive[MAX_PATH];
    BOOL bRetVal = FALSE;
    HKEY hKeyProfile;
    LONG Error;
    LPTSTR lpEnd;
    TCHAR szExcludeList[2 * MAX_PATH + 1];
    DWORD dwErr = 0;
    BOOL bSecurityFailed = TRUE;
    UINT cchRemaining;
    HRESULT hr;

    
    // Getting the previous last error so that we can set the last error to this in the end.
    dwErr = GetLastError();


    if (!lpDest || !(*lpDest)) {
        SetLastError(ERROR_INVALID_PARAMETER);
        return FALSE;
    }


    //
    // Create the security descriptor
    //

    //
    // User Sid
    //

    psidUser = lpUPCopyInfo->pSid;


    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         dwErr = GetLastError();
         goto Exit;
    }


    //
    // Get the admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         dwErr = GetLastError();
         goto Exit;
    }


    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin)) + sizeof(ACL) +
            (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) LocalAlloc(LPTR, cbAcl);
    if (!pAcl) {
        dwErr = GetLastError();
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        dwErr = GetLastError();
        goto Exit;
    }



    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    AceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidUser)) {
        dwErr = GetLastError();
        goto Exit;
    }


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidSystem)) {
        dwErr = GetLastError();
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, FILE_ALL_ACCESS, psidAdmin)) {
        dwErr = GetLastError();
        goto Exit;
    }


    //
    // Now the inheritable ACEs
    //

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidUser)) {
        dwErr = GetLastError();
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (void **)&lpAceHeader)) {
        dwErr = GetLastError();
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        dwErr = GetLastError();
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (void **)&lpAceHeader)) {
        dwErr = GetLastError();
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        dwErr = GetLastError();
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (void **)&lpAceHeader)) {
        dwErr = GetLastError();
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        dwErr = GetLastError();
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        dwErr = GetLastError();
        goto Exit;
    }

    //
    // Add the security descriptor to the sa structure
    //

    sa.nLength = sizeof(sa);
    sa.lpSecurityDescriptor = &sd;
    sa.bInheritHandle = FALSE;


    //
    // Create the destination directory
    //

    dwErr = SHCreateDirectoryEx (hDlg, lpDest, &sa);
    if (ERROR_SUCCESS != dwErr && ERROR_ALREADY_EXISTS != dwErr) {
        goto Exit;
    }


    //
    // Save/copy the user's profile to a temp file
    //

    dwSize = GetTempPath(ARRAYSIZE(szTempPath), szTempPath);
    if (!dwSize || dwSize >= MAX_PATH) {
        dwErr = dwSize ? ERROR_INSUFFICIENT_BUFFER : GetLastError();
        goto Exit;
    }

    //
    // GetTempFileName is lame in the sense it does not take output
    // buffer length - so potentially it can overflow the buffer.
    // So we want to ensure a 20 [3(prefix)+3(suffix)+1(null)+some hex string) char
    // buffer left for file name generation to be safe
    //

    if (dwSize > ARRAYSIZE(szTempPath) - 20) {
        dwErr = ERROR_INSUFFICIENT_BUFFER;
        goto Exit;
    }

    if (!GetTempFileName (szTempPath, TEXT("TMP"), 0, szBuffer)) {
        dwErr = GetLastError();
        goto Exit;
    }

    DeleteFile (szBuffer);


    //
    // Determine if we are working with a mandatory profile
    //

    hr = StringCchCopy(szHive, ARRAYSIZE(szHive), lpUPCopyInfo->lpUserInfo->lpProfile);
    if (FAILED(hr)) {
        dwErr = HRESULT_CODE(hr);
        goto Exit;
    }
    lpEnd = CheckSlashEx(szHive, ARRAYSIZE(szHive), &cchRemaining);
    if (!lpEnd)
    {
        dwErr = ERROR_INSUFFICIENT_BUFFER;
        goto Exit;
    }
    
    hr = StringCchCopy(lpEnd, cchRemaining, TEXT("ntuser.man"));
    if (FAILED(hr)) {
        dwErr = HRESULT_CODE(hr);
        goto Exit;
    }

    hFile = CreateFile(szHive, GENERIC_READ, FILE_SHARE_READ, NULL,
                       OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);


    if (hFile != INVALID_HANDLE_VALUE) {
        CloseHandle (hFile);
        bMandatory = TRUE;
    }


    //
    // Test if the requested profile is in use.
    //

    if (IsProfileInUse (lpUPCopyInfo->lpUserInfo->lpSid)) {


        Error = RegOpenKeyEx (HKEY_USERS, lpUPCopyInfo->lpUserInfo->lpSid, 0,
                              KEY_READ, &hKeyProfile);

        if (Error != ERROR_SUCCESS) {
            dwErr = Error;
            goto Exit;
        }

        Error = MyRegSaveKey (hKeyProfile, szBuffer);

        RegCloseKey (hKeyProfile);

        if (Error != ERROR_SUCCESS) {
            DeleteFile (szBuffer);
            dwErr = Error;
            goto Exit;
        }

    } else {

       if (!bMandatory) {
           hr = StringCchCopy(lpEnd, cchRemaining, TEXT("ntuser.dat"));
           if (FAILED(hr)) {
               dwErr = HRESULT_CODE(hr);
               goto Exit;
           }
       }

       if (!CopyFile(szHive, szBuffer, FALSE)) {
           dwErr = GetLastError();
           goto Exit;
       }
    }

    //
    // Apply security to the hive
    //

    Error = MyRegLoadKey (HKEY_USERS, TEMP_PROFILE, szBuffer);

    if (Error != ERROR_SUCCESS) {
        DeleteFile (szBuffer);
        dwErr = Error;
        goto Exit;
    }

    bRetVal = ApplyHiveSecurity(TEMP_PROFILE, psidUser);


    //
    // Query for the user's exclusion list
    //

    if (bRetVal) {

        //
        // if it has come till here, we have managed to set the ACLs correctly
        //

        bSecurityFailed = FALSE;

        //
        // Open the root of the user's profile
        //

        if (RegOpenKeyEx(HKEY_USERS, TEMP_PROFILE, 0, KEY_READ, &RootKey) == ERROR_SUCCESS) {

            //
            // Check for a list of directories to exclude both user preferences
            // and user policy
            //

            szExcludeList[0] = TEXT('\0');

            if (!ReadExclusionList(RootKey, szExcludeList, ARRAYSIZE(szExcludeList))) {
                szExcludeList[0] = TEXT('\0');
            }

            // Always exclude USER_CRED_LOCATION

            if (szExcludeList[0] != TEXT('\0')) {
                if (!CheckSemicolon(szExcludeList, ARRAYSIZE(szExcludeList))) {
                    szExcludeList[0] = TEXT('\0');
                }
            }
            StringCchCat(szExcludeList, ARRAYSIZE(szExcludeList), USER_CRED_LOCATION);

            RegCloseKey (RootKey);
        }
    }
    else {
        dwErr = GetLastError();
    }

    //
    // Unload the hive first then check for ApplyHiveSecurity failure
    //

    Error = MyRegUnLoadKey(HKEY_USERS, TEMP_PROFILE);

    if (Error != ERROR_SUCCESS) {
        DeleteFile (szBuffer);
        StringCchCat(szBuffer, ARRAYSIZE(szBuffer), TEXT(".log"));
        DeleteFile (szBuffer);
        dwErr = Error;
        goto Exit;
    }

    if (bSecurityFailed) {
        DeleteFile (szBuffer);
        StringCchCat(szBuffer, ARRAYSIZE(szBuffer), TEXT(".log"));
        DeleteFile (szBuffer);
        goto Exit; // dwErr already set from ApplyHiveSecurity
    }

    //
    // Copy the profile without the hive
    //

    bRetVal = CopyProfileDirectoryEx (lpUPCopyInfo->lpUserInfo->lpProfile,
                                      lpDest,
                                      CPD_IGNOREHIVE |
                                      CPD_COPYIFDIFFERENT |
                                      CPD_SYNCHRONIZE |
                                      CPD_USEEXCLUSIONLIST |
                                      CPD_IGNORESECURITY |
                                      CPD_DELDESTEXCLUSIONS,
                                      NULL,
                                      (szExcludeList[0] != TEXT('\0')) ?
                                      szExcludeList : NULL);

    if (!bRetVal) {
        dwErr = GetLastError();
        DeleteFile(szBuffer);
        StringCchCat(szBuffer, ARRAYSIZE(szBuffer), TEXT(".log"));
        DeleteFile (szBuffer);
        goto Exit;
    }

    //
    // Now copy the hive
    //

    hr = StringCchCopy(szHive, ARRAYSIZE(szHive), lpDest);
    if (FAILED(hr))
    {
        dwErr = HRESULT_CODE(hr);
        bRetVal = FALSE;
    }
    else
    {
        lpEnd = CheckSlashEx(szHive, ARRAYSIZE(szHive), &cchRemaining);
        if (!lpEnd)
        {
            dwErr = ERROR_INSUFFICIENT_BUFFER;
            bRetVal = FALSE;
        }
        else
        {
            hr = StringCchCopy (lpEnd, cchRemaining, bMandatory ? TEXT("ntuser.man") : TEXT("ntuser.dat"));
            if (FAILED(hr)) {
                dwErr = HRESULT_CODE(hr);
                bRetVal = FALSE;
            }
        }
    }

    //
    // Setting the file attributes first
    //
    
    if (bRetVal) {
        SetFileAttributes (szHive, FILE_ATTRIBUTE_NORMAL);

        bRetVal = CopyFile (szBuffer, szHive, FALSE);
        if (!bRetVal) {
            dwErr = GetLastError();    
        }
    }
  
    if (!bRetVal) {

        TCHAR szMsg[MAX_PATH], szMsgTemplate[MAX_PATH];

        szMsg[0] = szMsgTemplate[0] = TEXT('\0');

        LoadString (hInstance, IDS_UP_COPYHIVE_ERROR, szMsgTemplate, ARRAYSIZE(szMsgTemplate));
        
        StringCchPrintf(szMsg, ARRAYSIZE(szMsg), szMsgTemplate, szHive);

        UPDisplayErrorMessage(hDlg, dwErr, szMsg);    
    }
        

    //
    // Delete the temp file (and log file)
    //

    DeleteFile (szBuffer);
    StringCchCat(szBuffer, ARRAYSIZE(szBuffer), TEXT(".log"));
    DeleteFile (szBuffer);

    //
    // Since we use CPD_IGNOREHIVE, all "ntuser*.*" file will be skipped, including "ntuser.pol" and
    // "ntuser.ini" etc, now copy those files also, but we need to skip the hive files
    //
    if (bRetVal)
    {
        hr = CopyNonHiveNtUserFiles(lpUPCopyInfo->lpUserInfo->lpProfile, lpDest);

        if (FAILED(hr))
        {
            bRetVal = FALSE;
            dwErr = HRESULT_CODE(hr);
        }
    }


Exit:

    //
    // Free the sids and acl
    //

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    LocalFree (pAcl);

    if ((!bRetVal) && (bSecurityFailed)) {
        TCHAR szMsg[MAX_PATH];

        szMsg[0] = TEXT('\0');

        LoadString (hInstance, IDS_UP_SETSECURITY_ERROR, szMsg, ARRAYSIZE(szMsg));

        UPDisplayErrorMessage(hDlg, dwErr, szMsg);    
    }
    
    SetLastError(dwErr);

    return (bRetVal);
}





//*************************************************************
//
//  UPDisplayErrorMessage()
//
//  Purpose:    Display an error message
//
//  Parameters: hWnd            -   parent window handle
//              uiSystemError   -   Error code
//
//  Return:     void
//
//  Comments:
//
//  History:    Date        Author     Comment
//              2/14/96     ericflo    Created
//
//*************************************************************

VOID UPDisplayErrorMessage(HWND hWnd, UINT uiSystemError, LPTSTR szMsgPrefix)
{
   TCHAR szMessage[MAX_PATH];
   TCHAR szTitle[100];
   LPTSTR lpEnd;

   if (szMsgPrefix) {
      StringCchCopy(szMessage, ARRAYSIZE(szMessage), szMsgPrefix);
   }
   else {
      szMessage[0] = TEXT('\0');
   }

   lpEnd = szMessage+lstrlen(szMessage);
    
   //
   // retrieve the string matching the Win32 system error
   //

   FormatMessage(
            FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,
            NULL,
            uiSystemError,
            MAKELANGID(LANG_NEUTRAL, SUBLANG_NEUTRAL),
            lpEnd,
            MAX_PATH-lstrlen(szMessage),
            NULL);

   //
   // display a message box with this error
   //

   LoadString (hInstance, IDS_UP_ERRORTITLE, szTitle, ARRAYSIZE(szTitle));
   MessageBox(hWnd, szMessage, szTitle, MB_OK | MB_ICONSTOP);

   return;

}

//*************************************************************
//
//  ApplySecurityToRegistryTree()
//
//  Purpose:    Applies the passed security descriptor to the passed
//              key and all its descendants.  Only the parts of
//              the descriptor inddicated in the security
//              info value are actually applied to each registry key.
//
//  Parameters: RootKey   -     Registry key
//              pSD       -     Security Descriptor
//
//  Return:     ERROR_SUCCESS if successful
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/19/95     ericflo    Created
//
//*************************************************************

DWORD ApplySecurityToRegistryTree(HKEY RootKey, PSECURITY_DESCRIPTOR pSD)

{
    DWORD Error;
    DWORD SubKeyIndex;
    LPTSTR SubKeyName;
    HKEY SubKey;
    DWORD cchSubKeySize = MAX_PATH + 1;



    //
    // First apply security
    //

    RegSetKeySecurity(RootKey, DACL_SECURITY_INFORMATION, pSD);


    //
    // Open each sub-key and apply security to its sub-tree
    //

    SubKeyIndex = 0;

    SubKeyName = (LPTSTR) LocalAlloc (LPTR, cchSubKeySize * sizeof(TCHAR));

    if (!SubKeyName) {
        return GetLastError();
    }

    while (TRUE) {

        //
        // Get the next sub-key name
        //

        Error = RegEnumKey(RootKey, SubKeyIndex, SubKeyName, cchSubKeySize);


        if (Error != ERROR_SUCCESS) {

            if (Error == ERROR_NO_MORE_ITEMS) {

                //
                // Successful end of enumeration
                //

                Error = ERROR_SUCCESS;

            }

            break;
        }


        //
        // Open the sub-key
        //

        Error = RegOpenKeyEx(RootKey,
                             SubKeyName,
                             0,
                             WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                             &SubKey);

        if (Error == ERROR_SUCCESS) {

            //
            // Apply security to the sub-tree
            //

            ApplySecurityToRegistryTree(SubKey, pSD);


            //
            // We're finished with the sub-key
            //

            RegCloseKey(SubKey);
        }


        //
        // Go enumerate the next sub-key
        //

        SubKeyIndex ++;
    }


    LocalFree (SubKeyName);

    return Error;

}

//*************************************************************
//
//  ApplyHiveSecurity()
//
//  Purpose:    Initializes the new user hive created by copying
//              the default hive.
//
//  Parameters: lpHiveName      -   Name of hive in HKEY_USERS
//              pSid            -   Sid (used by CreateNewUser)
//
//  Return:     TRUE if successful
//              FALSE if an error occurs
//
//  Comments:
//
//  History:    Date        Author     Comment
//              7/18/95     ericflo    Created
//
//*************************************************************

BOOL ApplyHiveSecurity(LPTSTR lpHiveName, PSID pSid)
{
    DWORD Error;
    HKEY RootKey;
    SECURITY_DESCRIPTOR sd;
    SID_IDENTIFIER_AUTHORITY authNT = SECURITY_NT_AUTHORITY;
    PACL pAcl = NULL;
    PSID  psidUser = pSid, psidSystem = NULL, psidAdmin = NULL;
    DWORD cbAcl, AceIndex;
    ACE_HEADER * lpAceHeader;
    BOOL bRetVal = FALSE;



    //
    // Get the system sid
    //

    if (!AllocateAndInitializeSid(&authNT, 1, SECURITY_LOCAL_SYSTEM_RID,
                                  0, 0, 0, 0, 0, 0, 0, &psidSystem)) {
         goto Exit;
    }


    //
    // Get the admin sid
    //

    if (!AllocateAndInitializeSid(&authNT, 2, SECURITY_BUILTIN_DOMAIN_RID,
                                  DOMAIN_ALIAS_RID_ADMINS, 0, 0,
                                  0, 0, 0, 0, &psidAdmin)) {
         goto Exit;
    }


    //
    // Allocate space for the ACL
    //

    cbAcl = (2 * GetLengthSid (psidUser)) + (2 * GetLengthSid (psidSystem)) +
            (2 * GetLengthSid (psidAdmin)) + sizeof(ACL) +
            (6 * (sizeof(ACCESS_ALLOWED_ACE) - sizeof(DWORD)));


    pAcl = (PACL) LocalAlloc(LPTR, cbAcl);
    if (!pAcl) {
        goto Exit;
    }


    if (!InitializeAcl(pAcl, cbAcl, ACL_REVISION)) {
        goto Exit;
    }



    //
    // Add Aces for User, System, and Admin.  Non-inheritable ACEs first
    //

    AceIndex = 0;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidUser)) {
        goto Exit;
    }


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidSystem)) {
        goto Exit;
    }

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, KEY_ALL_ACCESS, psidAdmin)) {
        goto Exit;
    }


    //
    // Now the inheritable ACEs
    //

    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidUser)) {
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (void **)&lpAceHeader)) {
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidSystem)) {
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (void **)&lpAceHeader)) {
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    AceIndex++;
    if (!AddAccessAllowedAce(pAcl, ACL_REVISION, GENERIC_ALL, psidAdmin)) {
        goto Exit;
    }

    if (!GetAce(pAcl, AceIndex, (void **)&lpAceHeader)) {
        goto Exit;
    }

    lpAceHeader->AceFlags |= (OBJECT_INHERIT_ACE | CONTAINER_INHERIT_ACE | INHERIT_ONLY_ACE);


    //
    // Put together the security descriptor
    //

    if (!InitializeSecurityDescriptor(&sd, SECURITY_DESCRIPTOR_REVISION)) {
        goto Exit;
    }


    if (!SetSecurityDescriptorDacl(&sd, TRUE, pAcl, FALSE)) {
        goto Exit;
    }


    //
    // Open the root of the user's profile
    //

    Error = RegOpenKeyEx(HKEY_USERS,
                         lpHiveName,
                         0,
                         WRITE_DAC | KEY_ENUMERATE_SUB_KEYS | READ_CONTROL,
                         &RootKey);

    if (Error == ERROR_SUCCESS) {

        //
        // Set the security descriptor on the entire tree
        //

        Error = ApplySecurityToRegistryTree(RootKey, &sd);


        if (Error == ERROR_SUCCESS) {
            bRetVal = TRUE;
        }

        RegFlushKey (RootKey);

        RegCloseKey(RootKey);
    }


Exit:

    //
    // Free the sids and acl
    //

    if (psidSystem) {
        FreeSid(psidSystem);
    }

    if (psidAdmin) {
        FreeSid(psidAdmin);
    }

    LocalFree (pAcl);


    return(bRetVal);

}


HRESULT CopyNonHiveNtUserFiles(LPCTSTR lpSrcDir, LPCTSTR lpDestDir)
{
    HRESULT hr = E_FAIL;
    TCHAR   lpSrcBuffer[MAX_PATH];
    TCHAR   lpDestBuffer[MAX_PATH];
    LPTSTR  lpSrcEnd = NULL;
    UINT    cchSrcEnd = 0;
    LPTSTR  lpDestEnd = NULL;
    UINT    cchDestEnd = 0;
    HANDLE  hFile = INVALID_HANDLE_VALUE;
    WIN32_FIND_DATA fd;

    //
    //  Prepare the buffers
    //
    
    hr = StringCchCopy(lpSrcBuffer, ARRAYSIZE(lpSrcBuffer), lpSrcDir);
    if (FAILED(hr))
    {
        goto Exit;
    }
    lpSrcEnd = CheckSlashEx(lpSrcBuffer, ARRAYSIZE(lpSrcBuffer), &cchSrcEnd);
    if (!lpSrcEnd)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }
    hr = StringCchCopy(lpDestBuffer, ARRAYSIZE(lpDestBuffer), lpDestDir);
    if (FAILED(hr))
    {
        goto Exit;
    }
    lpDestEnd = CheckSlashEx(lpDestBuffer, ARRAYSIZE(lpDestBuffer), &cchDestEnd);
    if (!lpDestEnd)
    {
        hr = HRESULT_FROM_WIN32(ERROR_INSUFFICIENT_BUFFER);
        goto Exit;
    }

    //
    //  Search "ntuser*.*"
    //

    hr = StringCchCopy(lpSrcEnd, cchSrcEnd, TEXT("ntuser*.*"));
    if (FAILED(hr))
    {
        goto Exit;
    }
        
    hFile = FindFirstFile(lpSrcBuffer, &fd);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        do
        {
            //
            // Skip hive files
            //

            if (CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, fd.cFileName, -1, TEXT("ntuser.man"), -1) == CSTR_EQUAL ||
                CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, fd.cFileName, -1, TEXT("ntuser.dat"), -1) == CSTR_EQUAL ||
                CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, fd.cFileName, -1, TEXT("ntuser.tmp"), -1) == CSTR_EQUAL ||
                CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, fd.cFileName, -1, TEXT("ntuser.man.log"), -1) == CSTR_EQUAL ||
                CompareString(LOCALE_INVARIANT, NORM_IGNORECASE, fd.cFileName, -1, TEXT("ntuser.dat.log"), -1) == CSTR_EQUAL )
            {
                continue;                
            }

            //
            //  Construct file names
            //
            
            hr = StringCchCopy (lpSrcEnd, cchSrcEnd, fd.cFileName);
            if (FAILED(hr))
            {
                goto Exit;
            }

            hr = StringCchCopy (lpDestEnd, cchDestEnd, fd.cFileName);
            if (FAILED(hr))
            {
                goto Exit;
            }

            //
            //  Clear the dest file attribute in case it exists
            //
            
            SetFileAttributes (lpDestBuffer, FILE_ATTRIBUTE_NORMAL);

            //
            //  Now copy the file
            //
            
            if(!CopyFile(lpSrcBuffer, lpDestBuffer, FALSE))
            {
                hr = HRESULT_FROM_WIN32(GetLastError());
                goto Exit;
            }   
        } while (FindNextFile(hFile, &fd));

        FindClose(hFile);
        hFile = INVALID_HANDLE_VALUE;
    }

    hr = S_OK;

Exit:

    if (hFile != INVALID_HANDLE_VALUE)
        FindClose(hFile);
        
    return hr;
}

//*************************************************************
//
//  CheckSlashEx()
//
//  Purpose:    Checks for an ending slash and adds one if
//              it is missing. It will take the buffer size
//              to make it safe (not overflow the buffer).
//
//  Parameters: lpDir      -   directory
//              cchBuffer  -   buffer size
//              pcchRemain -   buffer remained after patch '\'
//                             can be NULL if not needed.
//
//  Return:     Pointer to the end of the string, NULL for 
//              overflowed buffer.
//
//  Comments:
//
//  History:    Date        Author     Comment
//              06/19/95    ericflo    Created
//              02/11/02    mingzhu    Make it safe
//
//*************************************************************
LPTSTR CheckSlashEx(LPTSTR lpDir, UINT cchBuffer, UINT* pcchRemain )
{
    LPTSTR lpEnd = NULL;
    UINT   cchLen = lstrlen(lpDir);

    if (cchLen >= cchBuffer - 1) // Overflowed or full buffer
    {
        //DmAssert(cchLen == cchBuffer - 1); // Should never happen
        if (pcchRemain)
            *pcchRemain = 0;
        lpEnd = NULL;
    }
    else
    {
        lpEnd = lpDir + cchLen;
        if (pcchRemain)
            *pcchRemain = cchBuffer - 1 - cchLen;
        if (*(lpEnd - 1) != TEXT('\\'))
        {
            *lpEnd =  TEXT('\\');
            lpEnd++;
            *lpEnd =  TEXT('\0');
            if (pcchRemain)
                (*pcchRemain) --;
        }
    }
    return lpEnd;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\sid.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    sid.c

Abstract:

    SID management functions

Author:

    (davidc) 26-Aug-1992

--*/
// NT base apis
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>

#include "sysdm.h"


LPTSTR 
GetSidString(
    void
)
/*++

Routine Description:

    Allocates and returns a string representing the sid of the current user
    The returned pointer should be freed using DeleteSidString().

Arguments:

    None

Return Value:

    Returns a pointer to the string or NULL on failure.

--*/
{
    NTSTATUS NtStatus;
    PSID UserSid;
    UNICODE_STRING UnicodeString;
    LPTSTR lpEnd;

    //
    // Get the user sid
    //

    UserSid = GetUserSid();
    if (UserSid == NULL) {
        return NULL;
    }

    //
    // Convert user SID to a string.
    //

    NtStatus = RtlConvertSidToUnicodeString(
                            &UnicodeString,
                            UserSid,
                            (BOOLEAN)TRUE // Allocate
                            );
    //
    // We're finished with the user sid
    //

    DeleteUserSid(UserSid);

    //
    // See if the conversion to a string worked
    //

    if (!NT_SUCCESS(NtStatus)) {
        return NULL;
    }

    return(UnicodeString.Buffer);
}


VOID 
DeleteSidString(
    IN LPTSTR SidString
)
/*++

Routine Description:

    Frees up a sid string previously returned by GetSidString()

Arguments:

    SidString -
        Supplies string to free

Return Value:

    None

--*/
{

    UNICODE_STRING String;

    RtlInitUnicodeString(&String, SidString);

    RtlFreeUnicodeString(&String);
}


PSID 
GetUserSid(
    void
)
/*++

Routine Description:

    Allocs space for the user sid, fills it in and returns a pointer. Caller
    The sid should be freed by calling DeleteUserSid.

    Note the sid returned is the user's real sid, not the per-logon sid.

Arguments:

    None

Return Value:

    Returns pointer to sid or NULL on failure.

--*/
{
    PTOKEN_USER pUser;
    PSID pSid;
    DWORD BytesRequired = 200;
    NTSTATUS status;
    HANDLE UserToken;


    if (!OpenProcessToken (GetCurrentProcess(), TOKEN_READ, &UserToken)) {
        return NULL;
    }

    //
    // Allocate space for the user info
    //

    pUser = (PTOKEN_USER)LocalAlloc(LMEM_FIXED, BytesRequired);


    if (pUser == NULL) {
        CloseHandle (UserToken);
        return NULL;
    }


    //
    // Read in the UserInfo
    //

    status = NtQueryInformationToken(
                 UserToken,                 // Handle
                 TokenUser,                 // TokenInformationClass
                 pUser,                     // TokenInformation
                 BytesRequired,             // TokenInformationLength
                 &BytesRequired             // ReturnLength
                 );

    if (status == STATUS_BUFFER_TOO_SMALL) {
        HLOCAL pTemp;

        //
        // Allocate a bigger buffer and try again.
        //

        pTemp = LocalReAlloc(pUser, BytesRequired, LMEM_MOVEABLE);
        if (pTemp == NULL) {
            LocalFree((HLOCAL) pUser);
            CloseHandle (UserToken);
            return NULL;
        }
        else
        {
            pUser = (PTOKEN_USER)pTemp;
        }

        status = NtQueryInformationToken(
                     UserToken,             // Handle
                     TokenUser,             // TokenInformationClass
                     pUser,                 // TokenInformation
                     BytesRequired,         // TokenInformationLength
                     &BytesRequired         // ReturnLength
                     );

    }

    if (!NT_SUCCESS(status)) {
        LocalFree(pUser);
        CloseHandle (UserToken);
        return NULL;
    }


    BytesRequired = RtlLengthSid(pUser->User.Sid);
    pSid = LocalAlloc(LMEM_FIXED, BytesRequired);
    if (pSid == NULL) {
        LocalFree(pUser);
        CloseHandle (UserToken);
        return NULL;
    }


    status = RtlCopySid(BytesRequired, pSid, pUser->User.Sid);

    LocalFree(pUser);

    if (!NT_SUCCESS(status)) {
        LocalFree(pSid);
        pSid = NULL;
    }

    CloseHandle (UserToken);

    return pSid;
}


VOID 
DeleteUserSid(
    IN PSID Sid
)
/*++

Routine Description:

    Deletes a user sid previously returned by GetUserSid()

Arguments:

    Sid -
        Supplies sid to delete

Return Value:

    None

--*/
{
    LocalFree(Sid);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\resource.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    resource.h

Abstract:

    Resource IDs for the System Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#ifndef _SYSDM_RESOURCE_H_
#define _SYSDM_RESOURCE_H_

//
// Icons
//
#define ID_ICON                       1
#define IDI_PROFILE                   2
#define DOCK_ICON                     3
#define UP_ICON                       4
#define DOWN_ICON                     5
#define IDI_COMPUTER                  6
#define PERF_ICON                     7
#define ENVVAR_ICON                   8
#define CRASHDUMP_ICON                9

//
// Bitmaps
//
#define IDB_WINDOWS                   1
#define IDB_WINDOWS_256               2
#define IDB_PFR_CHECK                 5
#define IDB_PFR_CHECKG                6
#define IDB_PFR_UNCHECK               7

//
// String table constants
//
#define IDS_NAME                                        1
#define IDS_INFO                                        2
#define IDS_TITLE                                       3
#define IDS_DEBUG                                       4
#define IDS_XDOTX_MB                                    5
#define IDS_PAGESIZE                                    6
#define IDS_DUMPFILE                                    7
#define IDS_USERENVVARS                                 8
#define IDS_UP_NAME                                     9
#define IDS_UP_SIZE                                     10
#define IDS_UP_TYPE                                     11
#define IDS_UP_STATUS                                   12
#define IDS_UP_MOD                                      13
// UNUSED                                               14
#define IDS_UP_LOCAL                                    15
#define IDS_UP_FLOATING                                 16
#define IDS_UP_MANDATORY                                17
#define IDS_UP_CONFIRM                                  18
#define IDS_UP_CONFIRMTITLE                             19
#define IDS_UP_DIRPICK                                  20
#define IDS_UP_ERRORTITLE                               21

#define IDS_UP_ACCUNKNOWN                               22
#define IDS_UP_ACCDELETED                               23
#define IDS_UP_CHANGETYPEMSG                            24
#define IDS_UP_CONFIRMCOPYMSG                           25
#define IDS_UP_CONFIRMCOPYTITLE                         26
#define IDS_UP_DELETE_ERROR                             27
#define IDS_UP_SETSECURITY_ERROR                        28
#define IDS_UP_COPYHIVE_ERROR                           29
#define IDS_UP_BACKUP                                   30
#define IDS_UP_TEMP                                     31
#define IDS_UP_READONLY                                 32
#define IDS_PROCESSOR_SPEED                             33
#define IDS_PROCESSOR_SPEEDGHZ                          34
#define IDS_PERFOPTIONS                                 35
#define IDS_UP_UPLINK_SERVER                            36

#define IDS_PAE                                         50

#define IDS_NETID_DLL_NAME                              55
#define IDS_TEMP_PAGEFILE_WARN                          56

#define IDS_CRASHDUMP_NONE                              75
#define IDS_CRASHDUMP_MINI                              76
#define IDS_CRASHDUMP_SUMMARY                           77
#define IDS_CRASHDUMP_FULL                              78
#define IDS_CRASHDUMP_DUMP_FILE                         79
#define IDS_CRASHDUMP_MINI_DIR                          80
#define IDS_CRASHDUMP_MINI_WIN64                        81

#define IDS_INSUFFICIENT_MEMORY                         100
#define IDS_SYSDM_TITLE                                 101

#define IDS_SYSDM_ENTERSECONDS                          114

#define IDS_SYSDM_NOOPEN_USER_UNK                       118
#define IDS_SYSDM_NONEW_ENV_UNK                         119

#define IDS_SYSDM_NOOPEN_VM_NOTUSER                     121
//#define IDS_SYSDM_NOOPEN_VM_NOTADMIN                  122
#define IDS_SYSDM_PAGEFILESIZE_START                    123
#define IDS_SYSDM_PAGEFILESIZE_MAX                      124
#define IDS_SYSDM_PAGEFILESIZE_TOOSMALL                 125
#define IDS_SYSDM_PAGEFILESIZE_TOOSMALL_NAMED           126
#define IDS_SYSDM_CANNOTREAD                            127
#define IDS_SYSDM_MB                                    128
#define IDS_SYSDM_NOCHANGE_BOOTINI                      129
#define IDS_SYSDM_PAGEFILESIZE_TOOSMALL_GROW            130
#define IDS_SYSDM_NOOPEN_SYS_UNK                        131
#define IDS_SYSDM_NOOPEN_RECOVER_GROUP                  132
//#define IDS_SYSDM_NOOPEN_RECOVER_UNK                  133
#define IDS_SYSDM_SAVE_ERROR                            134
#define IDS_SYSDM_OVERWRITE                             135
#define IDS_SYSDM_NOTENOUGHSPACE_PAGE                   136
#define IDS_SYSDM_NOTENOUGHSPACE_CRASHRECOVER           137
#define IDS_SYSDM_RECOVERY_MINIMUM                      138
#define IDS_SYSDM_DEBUGGING_MINIMUM                     139
#define IDS_SYSDM_DEBUGGING_FILENAME                    140
#define IDS_SYSDM_DEBUGGING_DRIVE                       141
#define IDS_SYSDM_DEBUGGING_PATH                        142
#define IDS_SYSDM_DEBUGGING_PATHLONG                    143
#define IDS_SYSDM_DEBUGGING_UNQUALIFIED                 144
#define IDS_SYSDM_NOALERTER                             148
#define IDS_SYSDM_CANNOTOPENFILE                        149
#define IDS_SYSDM_ENTERINITIALSIZE                      150
#define IDS_SYSDM_ENTERMAXIMUMSIZE                      151
#define IDS_SYSDM_RESTART                               152
#define IDS_SYSDM_DONTKNOWCURRENT                       153
#define IDS_SYSDM_NOOPEN_SYS_NOTADMIN                   154

#define IDS_ENVVAR_VARIABLE_HEADING                     160
#define IDS_ENVVAR_VALUE_HEADING                        161
#define IDS_SYSDM_NOLOAD_DEVMANPROG                     162
#define IDS_SYSDM_NOEXPORTS_DEVMANPROG                  163

#define IDS_SYSDM_NOOPEN_USER_NOTADMIN                  170
#define IDS_SYSDM_NONEW_ENV_NOTADMIN                    171

#define IDS_WINVER_WINDOWSXP                            180
#define IDS_WINVER_WINDOWSDOTNET                        181
#define IDS_WINVER_YEAR                                 182

#define IDS_WINVER_PROFESSIONAL_WIN64                   188
#define IDS_WINVER_EMBEDDED                             189
#define IDS_WINVER_PERSONAL                             190
#define IDS_WINVER_PROFESSIONAL                         191
#define IDS_WINVER_SERVER                               192
#define IDS_WINVER_ADVANCEDSERVER                       193
#define IDS_WINVER_DATACENTER                           194

#define IDS_WINVER_BLADE                                196
#define IDS_WINVER_SBS                                  197

//
// Edit Environment Variable strings
//
#define IDS_NEW_SYSVAR_CAPTION                          200
#define IDS_EDIT_SYSVAR_CAPTION                         201
#define IDS_NEW_USERVAR_CAPTION                         202
#define IDS_EDIT_USERVAR_CAPTION                        203

//
// Profile using new constants after 3000
//

#define IDS_UP_DELNODE_ERROR                            3000

#define IDS_PFR_OK                                      4000
#define IDS_PFR_FILTER                                  4001
#define IDS_PFR_TITLE                                   4002
#define IDS_PFR_CFGREADERR                              4003
#define IDS_PFR_CFGWRITEERR                             4004
#define IDS_PFR_WINCOMP                                 4005
#define IDS_PFR_KERNEL                                  4006
#define IDS_PFR_PROG                                    4007
#define IDS_PFR_MSPROG                                  4008
#define IDS_PFR_NOTADMIN                                4009
#define IDS_PFR_ISWINCOMP                               4010
#define IDS_PFR_ISONLISTI                               4011
#define IDS_PFR_ADDTOEX                                 4012
#define IDS_PFR_ADDTOINC                                4013
#define IDS_PFR_BADFILE                                 4014
#define IDS_PFR_ISONLISTE                               4015
#define IDS_PFR_DEFINC                                  4016
#define IDS_PFR_DEFEX                                   4017


#define HWP                         60

#define HWP_DEF_FRIENDLYNAME        HWP+0
#define HWP_CURRENT_TAG             HWP+1
#define HWP_UNAVAILABLE             HWP+2
#define HWP_ERROR_CAPTION           HWP+3
#define HWP_ERROR_PROFILE_IN_USE    HWP+4
#define HWP_ERROR_IN_USE            HWP+5
#define HWP_CONFIRM_DELETE_CAP      HWP+6
#define HWP_CONFIRM_DELETE          HWP+7
#define HWP_INVALID_WAIT            HWP+8
#define HWP_CONFIRM_NOT_PORTABLE    HWP+9
#define HWP_UNKNOWN_PROFILE         HWP+10
#define HWP_DOCKED_PROFILE          HWP+11
#define HWP_UNDOCKED_PROFILE        HWP+12
#define HWP_ERROR_COMPLEX_SCRIPT    HWP+13
//
// Dialog box ID's
//
#define DLG_VIRTUALMEM              41
#define IDD_ENVVAREDIT              42
#define IDD_USERPROFILE             100
#define IDD_GENERAL                 101
#define IDD_PHONESUP                102
#define IDD_ADVANCEDPERF            103
#define IDD_STARTUP                 104
#define IDD_ENVVARS                 105
#define DLG_HWPROFILES              106
#define DLG_HWP_RENAME              107
#define DLG_HWP_COPY                108
#define DLG_HWP_GENERAL             109
#define IDD_UP_TYPE                 110
#define IDD_UP_COPY                 111
#define IDD_VISUALEFFECTS           112
#define IDD_ADVANCED                115
#define IDD_HARDWARE                2000
#define IDD_PFR_REPORT              4100
#define IDD_PFR_REPORTSRV           4101
#define IDD_PFR_PROG                4102
#define IDD_PFR_ADDPROG             4103



//
// Shared text id's
//
#define IDC_TEXT_1                 10
#define IDC_TEXT_2                 11
#define IDC_TEXT_3                 12
#define IDC_TEXT_4                 13


//
// General page
//
// BEGIN DONTCHANGEORDER
// Do not change the order of these items.  They must be contiguous. (see general.cpp)
#define IDC_GEN_WINDOWS_IMAGE            51
#define IDC_GEN_VERSION_0                52
#define IDC_GEN_VERSION_1                53
#define IDC_GEN_VERSION_2                54
#define IDC_GEN_VERSION_3                55
#define IDC_GEN_REGISTERED_0             56
#define IDC_GEN_REGISTERED_1             57
#define IDC_GEN_REGISTERED_2             58
#define IDC_GEN_REGISTERED_3             59
#define IDC_GEN_OEM_NUDGE                60
#define IDC_GEN_MACHINE                  61
#define IDC_GEN_OEM_IMAGE                62
#define IDC_GEN_MACHINE_0                63
#define IDC_GEN_MACHINE_1                64
#define IDC_GEN_MACHINE_2                65
#define IDC_GEN_MACHINE_3                66
#define IDC_GEN_MACHINE_4                67
#define IDC_GEN_MACHINE_5                68
#define IDC_GEN_OEM_SUPPORT              69
#define IDC_GEN_MACHINE_6                70
#define IDC_GEN_MACHINE_7                71
#define IDC_GEN_MACHINE_8                72

#define LAST_GEN_MACHINES_SLOT           IDC_GEN_MACHINE_8
#define MAX_GEN_MACHINES_SLOT            (LAST_GEN_MACHINES_SLOT - IDC_GEN_MACHINE_0)

// END DONTCHANGEORDER


//
// Phone support dialog
//
#define IDC_SUPPORT_TEXT                 70

//
// Performace dialog
//
#define IDC_PERF_CHANGE                 201
#define IDC_PERF_VM_ALLOCD              202
#define IDC_PERF_GROUP                  203
#define IDC_PERF_WORKSTATION            204
#define IDC_PERF_SERVER                 205
#define IDC_PERF_VM_GROUP               206
#define IDC_PERF_VM_ALLOCD_LABEL        207
#define IDC_PERF_TEXT                   208
#define IDC_PERF_CACHE_GROUP            209
#define IDC_PERF_CACHE_TEXT             210
#define IDC_PERF_CACHE_APPLICATION      211
#define IDC_PERF_CACHE_SYSTEM           212
#define IDC_PERF_VM_ALLOCD_TEXT         213
#define IDC_PERF_TEXT2                  214
#define IDC_PERF_CACHE_TEXT2            215

//
// Startup page
//
#define IDC_STARTUP_SYS_OS                300
#define IDC_STARTUP_SYS_SECONDS           301
#define IDC_STARTUP_SYS_SECSCROLL         302
#define IDC_STARTUP_SYS_ENABLECOUNTDOWN   303
#define IDC_STARTUP_SYSTEM_GRP            304
#define IDC_STARTUP_SYS_SECONDS_LABEL     305
#define IDC_STARTUP_SYS_EDIT_LABEL        306
#define IDC_SYS_EDIT_BUTTION              307
#define IDC_STARTUP_SYS_OS_LABEL          308
#define IDC_STARTUP_AUTOLKG               309
#define IDC_STARTUP_AUTOLKG_SECONDS_LABEL 310
#define IDC_STARTUP_AUTOLKG_SECONDS       311
#define IDC_STARTUP_AUTOLKG_SECSCROLL     312

#define IDC_STARTUP_CDMP_GRP             601
#define IDC_STARTUP_CDMP_TXT1            602
#define IDC_STARTUP_CDMP_LOG             603
#define IDC_STARTUP_CDMP_SEND            604
#define IDC_STARTUP_CDMP_FILENAME        606
#define IDC_STARTUP_CDMP_OVERWRITE       607
#define IDC_STARTUP_CDMP_AUTOREBOOT      608
#define IDC_STARTUP_CDMP_TYPE            610
#define IDC_STARTUP_CDMP_FILE_LABEL      611
#define IDC_STARTUP_CDMP_DEBUGINFO_GROUP 612

//
// Environment Variables dialog
//
#define IDC_ENVVAR_SYS_LB_SYSVARS       400
#define IDC_ENVVAR_SYS_LB_USERVARS      402
#define IDC_ENVVAR_SYS_NEWSV            407
#define IDC_ENVVAR_SYS_EDITSV           408
#define IDC_ENVVAR_SYS_DELSV            409
#define IDC_ENVVAR_SYS_USERGROUP        411
#define IDC_ENVVAR_SYS_NEWUV            412
#define IDC_ENVVAR_SYS_EDITUV           413
#define IDC_ENVVAR_SYS_NDELUV           414
#define IDC_ENVVAR_SYS_SYSGROUP         415

#define IDC_ENVVAR_SYS_SETUV            405
#define IDC_ENVVAR_SYS_DELUV            406

//
// Environment Variables "New..."/"Edit.." dialog
//
#define IDC_ENVVAR_EDIT_NAME_LABEL      100
#define IDC_ENVVAR_EDIT_NAME            101
#define IDC_ENVVAR_EDIT_VALUE_LABEL     102
#define IDC_ENVVAR_EDIT_VALUE           103

//
// Exception Reporting dialog
//
#define IDC_PFR                          4200
#define IDC_PFR_INCADD                   IDC_PFR + 0
#define IDC_PFR_INCREM                   IDC_PFR + 1
#define IDC_PFR_EXADD                    IDC_PFR + 2
#define IDC_PFR_EXREM                    IDC_PFR + 3
#define IDC_PFR_DISABLE                  IDC_PFR + 4
#define IDC_PFR_ENABLE                   IDC_PFR + 5
#define IDC_PFR_DETAILS                  IDC_PFR + 6
#define IDC_PFR_DEFALL                   IDC_PFR + 7
#define IDC_PFR_DEFNONE                  IDC_PFR + 8
#define IDC_PFR_INCLIST                  IDC_PFR + 9
#define IDC_PFR_NEWPROG                  IDC_PFR + 10
#define IDC_PFR_BROWSE                   IDC_PFR + 11
#define IDC_PFR_EXLIST                   IDC_PFR + 12
#define IDC_PFR_REPICON                  IDC_PFR + 13
#define IDC_PFR_SHOWUI                   IDC_PFR + 14
#define IDC_PFR_ENABLEOS                 IDC_PFR + 15
#define IDC_PFR_ENABLEPROG               IDC_PFR + 16
#define IDC_PFR_ENABLESHUT               IDC_PFR + 17
#define IDC_PFR_FORCEQ                   IDC_PFR + 18
#define IDC_PFR_TEXT                     IDC_PFR + 98
#define IDC_ADV_PFR_BTN                  IDC_PFR + 99


//
// IF IDS ARE ADDED OR REMOVED, THEN ADD/REMOVE THE CORRESPONDING
// HELP IDS IN HWPROF.C ALSO!!
//
#define IDD_HWP_PROFILES                300
#define IDD_HWP_PROPERTIES              301
#define IDD_HWP_COPY                    302
#define IDD_HWP_RENAME                  303
#define IDD_HWP_DELETE                  304
#define IDD_HWP_ST_MULTIPLE             305
#define IDD_HWP_WAITFOREVER             307
#define IDD_HWP_WAITUSER                308
#define IDD_HWP_SECONDS                 309
#define IDD_HWP_SECSCROLL               310
#define IDD_HWP_COPYTO                  311
#define IDD_HWP_COPYFROM                312
#define IDD_HWP_ST_DOCKID               313
#define IDD_HWP_ST_SERIALNUM            314
#define IDD_HWP_DOCKID                  315
#define IDD_HWP_SERIALNUM               316
#define IDD_HWP_PORTABLE                317
#define IDD_HWP_ALIASABLE               318
#define IDD_HWP_UNKNOWN                 319
#define IDD_HWP_DOCKED                  320
#define IDD_HWP_UNDOCKED                321
#define IDD_HWP_ST_PROFILE              322
#define IDD_HWP_ORDERUP                 323
#define IDD_HWP_ORDERDOWN               324
#define IDD_HWP_RENAMEFROM              325
#define IDD_HWP_RENAMETO                326
#define IDD_HWP_WAITUSER_TEXT_1         327
#define IDD_HWP_UNUSED_1                340
#define IDD_HWP_UNUSED_2                341
#define IDD_HWP_UNUSED_3                342
#define IDD_HWP_UNUSED_4                343
#define IDD_HWP_UNUSED_5                344
#define IDD_HWP_UNUSED_6                345
#define IDD_HWP_COPYTO_CAPTION          346
#define IDD_HWP_RENAMETO_CAPTION        347

//
// NOTE: The following ID ranges are reserved for use by property
// page providers for the Hardware Profiles and should not be used
// by the main hardware profiles dialog or the Hardware Profiles
// General property page. All property page providers (dlls that
// add pages to the Hardware Profiles properties) will use help
// IDs within the range allocated for Hardware Profiles (IDH_HWPROFILE)
//
// RESERVE FOR:
//
//      No Net Property Page Extension:
//          Control IDs:    500-549
//          Help IDs:       IDH_HWPROFILE+500 - IDH_HWPROFILE+550
//
//      Other Property Page Extensions...
//
//          Control IDs:    550-599  - reserved for later use
//          Control IDs:    600-649  - reserved for later use
//          Control IDs:    650-699  - reserved for later use
//


//
// Static text id
//
#define IDC_STATIC                -1


//
// User profile page
//
#define IDC_UP_LISTVIEW         1000
#define IDC_UP_DELETE           1001
#define IDC_UP_TYPE             1002
#define IDC_UP_COPY             1003
#define IDC_UP_ICON             1004
#define IDC_UP_TEXT             1005
#define IDC_UP_UPLINK           1006

//
// User profile 'change type' dialog
//
#define IDC_UPTYPE_LOCAL        1020
#define IDC_UPTYPE_FLOAT        1021
// these dwords 1022, 1023 were used as slowlink text, removing..
#define IDC_UPTYPE_GROUP        1024


//
// User profile 'copy to' dialog
//
#define IDC_COPY_PATH           1030
#define IDC_COPY_BROWSE         1031
#define IDC_COPY_USER           1032
#define IDC_COPY_CHANGE         1033
#define IDC_COPY_GROUP          1034
#define IDC_COPY_PROFILE        1035

//
// Virtual Mem dlg
//
#define IDD_VM_DRIVE_HDR        1140
#define IDD_VM_PF_SIZE_LABEL    1142
#define IDD_VM_DRIVE_LABEL      1144
#define IDD_VM_SPACE_LABEL      1146
#define IDD_VM_MIN_LABEL        1148
#define IDD_VM_RECOMMEND_LABEL  1150
#define IDD_VM_ALLOCD_LABEL     1152
#define IDD_VM_VOLUMES          1160
#define IDD_VM_SF_DRIVE         1161
#define IDD_VM_SF_SPACE         1162
#define IDD_VM_SF_SIZE          1163
#define IDD_VM_SF_SIZEMAX       1164
#define IDD_VM_SF_SET           1165
#define IDD_VM_MIN              1166
#define IDD_VM_RECOMMEND        1167
#define IDD_VM_ALLOCD           1168
#define IDD_VM_ST_INITSIZE      1169
#define IDD_VM_ST_MAXSIZE       1170
#define IDD_VMEM_ICON           1171
#define IDD_VMEM_MESSAGE        1172
#define IDD_VM_REG_SIZE_LIM     1173
#define IDD_VM_REG_SIZE_TXT     1174
#define IDD_VM_CUSTOMSIZE_RADIO 1176
#define IDD_VM_RAMBASED_RADIO   1177
#define IDD_VM_NOPAGING_RADIO   1178


//
// Hardware dlg
//
#define IDC_WIZARD_ICON           2001
#define IDC_WIZARD_TEXT           2002
#define IDC_WIZARD_START          2003
#define IDC_DEVMGR_ICON           2004
#define IDC_DEVMGR_TEXT           2005
#define IDC_DEVMGR_START          2006
#define IDC_HWPROFILES_START      2007
#define IDC_HWPROFILES_ICON       2008
#define IDC_HWPROFILES_START_TEXT 2009
#define IDC_DRIVER_SIGNING        2010


//
// Visual Effects dlg
//
// Do not change the order of IDC_VFX_??? entries, we loop over these in visualfx.cpp
#define IDC_VFX_TREE            2020
#define IDC_VFX_AUTO            2021
#define IDC_VFX_BESTLOOKS       2022
#define IDC_VFX_BESTPERF        2023
#define IDC_VFX_CUSTOM          2024
#define IDC_VFX_TITLE           2030

//
// Advanced dlg
//
#define IDC_ADV_PERF_TEXT       101
#define IDC_ADV_PERF_BTN        110
#define IDC_ADV_PROF_TEXT       201
#define IDC_ADV_PROF_BTN        210
#define IDC_ADV_ENV_TEXT        121
#define IDC_ADV_ENV_BTN         130
#define IDC_ADV_RECOVERY_TEXT   141
#define IDC_ADV_RECOVERY_BTN    150

// Property sheet titles
#define IDS_PROPSHEET_TITLE_GENERAL   10000
#define IDS_PROPSHEET_TITLE_HARDWARE  10001
#define IDS_PROPSHEET_TITLE_ADVANCED  10002
#endif // _SYSDM_RESOURCE_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\srcfg.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-2000  Microsoft Corporation
All rights reserved

Module Name:

    srcfg.h

Abstract:

    Public declarations for the System Restore tab of the System Control
    Panel Applet.

Author:

    skkhang 15-Jun-2000

--*/
#ifndef _SYSDM_SRCFG_H_
#define _SYSDM_SRCFG_H_

//
// Public function prototypes
//
HPROPSHEETPAGE
CreateSystemRestorePage(
    int,
    DLGPROC
);


#endif // _SYSDM_SRCFG_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\sid.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    sid.h

Abstract:

    Public declarations for SID management functions

Author:

    (davidc) 26-Aug-1992

Revision History:

    17-Oct-1997 scotthal
        Split public declarations into separate header

--*/
#ifndef _SYSDM_SID_H_
#define _SYSDM_SID_H_

//
// Public function prototypes
//
LPTSTR 
GetSidString(
    void
);

VOID 
DeleteSidString(
    IN LPTSTR SidString
);

PSID 
GetUserSid(
    void
);

VOID 
DeleteUserSid(
    IN PSID Sid
);

#endif // _SYSDM_SID_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\startup.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    startup.c

Abstract:

    Implements the Startup/Recovery dialog of the System
    Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#include <sysdm.h>

#ifdef _X86_
extern TCHAR szBootIni[];
#endif 

//
// Globals for this dialog
//

#define CSEC_START_MAX    9999        // Maximum number of seconds allowed

BOOL g_fStartupInitializing;
BOOL g_fRebootRequired = FALSE;

#if defined(_X86_) || defined(EFI_NVRAM_ENABLED)
BOOL g_fSystemStartupEnabled = TRUE;
#else
BOOL g_fSystemStartupEnabled = FALSE;
#endif

//
// Help ID's
//

DWORD aStartupHelpIds[] = {
    IDC_STARTUP_SYS_OS_LABEL,              (IDH_STARTUP + 0),
    IDC_STARTUP_SYS_OS,                    (IDH_STARTUP + 0),
    IDC_STARTUP_SYS_ENABLECOUNTDOWN,       (IDH_STARTUP + 1),
    IDC_STARTUP_SYS_SECONDS,               (IDH_STARTUP + 2),
    IDC_STARTUP_SYS_SECONDS_LABEL,         (IDH_STARTUP + 2),
    IDC_STARTUP_CDMP_TXT1,                 (IDH_STARTUP + 3),
    IDC_STARTUP_CDMP_LOG,                  (IDH_STARTUP + 4),
    IDC_STARTUP_CDMP_SEND,                 (IDH_STARTUP + 5),
    IDC_STARTUP_CDMP_FILENAME,             (IDH_STARTUP + 7),
    IDC_STARTUP_CDMP_OVERWRITE,            (IDH_STARTUP + 13),
    IDC_STARTUP_CDMP_AUTOREBOOT,           (IDH_STARTUP + 9),
    IDC_STARTUP_SYSTEM_GRP,                (IDH_STARTUP + 10),
    IDC_STARTUP_SYS_SECSCROLL,             (IDH_STARTUP + 11),
    IDC_STARTUP_CDMP_GRP,                  (IDH_STARTUP + 12),
    IDC_STARTUP_CDMP_DEBUGINFO_GROUP,      (IDH_STARTUP + 14),
    IDC_STARTUP_CDMP_TYPE,                 (IDH_STARTUP + 8),
    IDC_STARTUP_CDMP_FILE_LABEL,           (IDH_STARTUP + 7),
    IDC_STARTUP_SYS_EDIT_LABEL,            (IDH_STARTUP + 15),
    IDC_SYS_EDIT_BUTTION,                  (IDH_STARTUP + 16),
    0, 0
};


INT_PTR
APIENTRY 
StartupDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
)
/*++

Routine Description:

    Handles messages sent to the Startup/Recovery dialog box

Arguments:

    hDlg -
        Supplies window handle

    uMsg -
        Supplies message being sent

    wParam -
        Supplies message parameter

    lParam -
        Supplies message parameter

Return Value:

    TRUE if message was handled
    FALSE if message was unhandled

--*/
{
    int iRet;

    // If any controls on this page are touched by the user,
    // enable the "Apply" button.
    if ((WM_COMMAND == uMsg) && (!g_fStartupInitializing)) {
        switch (HIWORD(wParam)) {
            case EN_CHANGE:
            case BN_CLICKED:
            case CBN_SELCHANGE:
                PropSheet_Changed(GetParent(hDlg), hDlg);
                break;

            default:
                break;
        } // switch (HIWORD(wParam))
    } // if ((WM_COMMAND...

    // Call the Core Dump stuff first.  Only handle
    // messages not handled by the Core Dump stuff.
    iRet = CoreDumpDlgProc(hDlg, uMsg, wParam, lParam);

    switch( iRet ) {
        case RET_CONTINUE: {
            break;
        }

        case RET_BREAK: {
            return TRUE;
        }

        case RET_ERROR: {
            SetWindowLongPtr (hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
            return TRUE;
        }

        case RET_CHANGE_NO_REBOOT:
        case RET_NO_CHANGE: {
            break;
        }

        case RET_VIRTUAL_CHANGE:
        case RET_RECOVER_CHANGE:
        case RET_VIRT_AND_RECOVER: {
            g_fRebootRequired = TRUE;

            MsgBoxParam(
                hDlg, 
                IDS_SYSDM_RESTART, 
                IDS_SYSDM_TITLE,
                MB_OK | MB_ICONINFORMATION
            );

            break;
        }
    }

    switch (uMsg)
    {
    case WM_INITDIALOG:
        g_fStartupInitializing = TRUE;

        StartListInit(hDlg, wParam, lParam);
        AutoAdvancedBootInit(hDlg, wParam, lParam);

        g_fStartupInitializing = FALSE;
        if (!IsUserAnAdmin())
        {
            EnableWindow(GetDlgItem(hDlg, IDC_SYS_EDIT_BUTTION), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_SYS_EDIT_LABEL), FALSE);

            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECONDS_LABEL), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECONDS), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECSCROLL), FALSE);

            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_FILE_LABEL), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_FILENAME), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_CDMP_OVERWRITE), FALSE);
        }
        if (!g_fSystemStartupEnabled || !IsUserAnAdmin())
        {
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_SYSTEM_GRP), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_SYS_OS), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_SYS_OS_LABEL), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS_LABEL), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_SYS_EDIT_LABEL), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_SYS_EDIT_BUTTION), FALSE);
        }
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case IDC_STARTUP_AUTOLKG: 
            if (HIWORD(wParam) == BN_CLICKED) {
                BOOL fEnabled;

                fEnabled = !IsDlgButtonChecked(hDlg, IDC_STARTUP_AUTOLKG);

                CheckDlgButton(hDlg, IDC_STARTUP_AUTOLKG, fEnabled);
                EnableWindow(GetDlgItem (hDlg, IDC_STARTUP_AUTOLKG_SECONDS), fEnabled);
                EnableWindow(GetDlgItem (hDlg, IDC_STARTUP_AUTOLKG_SECSCROLL), fEnabled);
            }
            break;

        case IDC_STARTUP_SYS_ENABLECOUNTDOWN:
            if (HIWORD(wParam) == BN_CLICKED) {
                int timeout;

                timeout = IsDlgButtonChecked(hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN) ? 0 : 30;
                CheckDlgButton(hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN,
                                 (BOOL) timeout);
                SetDlgItemInt(hDlg, IDC_STARTUP_SYS_SECONDS, timeout, FALSE);
                EnableWindow(GetDlgItem (hDlg, IDC_STARTUP_SYS_SECONDS), (BOOL) timeout);
                EnableWindow(GetDlgItem (hDlg, IDC_STARTUP_SYS_SECSCROLL), (BOOL) timeout);

            }
            break;

        case IDOK: {
            int r1, r2;

            if((RET_BREAK != StartListExit(hDlg, wParam, lParam)) && 
               (RET_BREAK != AutoAdvancedBootExit(hDlg, wParam, lParam))) 
            {
                EndDialog(hDlg, 0);
            } // if

            break;
        }

        case IDCANCEL:

            AutoAdvancedBootExit(hDlg, wParam, lParam);
            EndDialog(hDlg, 0);
            break;

        case IDC_STARTUP_SYS_SECONDS:
            if (HIWORD(wParam) == EN_UPDATE) {
                if (!CheckVal(hDlg, IDC_STARTUP_SYS_SECONDS, FORMIN, FORMAX, IDS_SYSDM_ENTERSECONDS)) {
                    SetDlgItemInt(hDlg, IDC_STARTUP_SYS_SECONDS, FORDEF, FALSE); 
                    SendMessage((HWND) lParam, EM_SETSEL, 0, -1);
                    
                } // if (!CheckVal(...

            } // if (HIWORD(wParam == EN_UPDATE)

            break;

        case IDC_STARTUP_AUTOLKG_SECONDS:
            if (HIWORD(wParam) == EN_UPDATE) 
            {
                if (!CheckVal(hDlg, IDC_STARTUP_AUTOLKG_SECONDS, 0, 200, IDS_SYSDM_ENTERSECONDS)) 
                {
                    SetDlgItemInt(hDlg, IDC_STARTUP_AUTOLKG_SECONDS, 30, FALSE); 
                    SendMessage((HWND) lParam, EM_SETSEL, 0, -1);
                } // if (!CheckVal(...

            } // if (HIWORD(wParam == EN_UPDATE)

            break;

        case IDC_SYS_EDIT_BUTTION:
            {
                // invoke notepad.exe to edit boot.ini file
                DWORD dwFileAttr;
                SHELLEXECUTEINFO ExecInfo = {0};
#ifdef _X86_
                ExecInfo.lpParameters    = szBootIni;
#else
                ExecInfo.lpParameters    = TEXT("c:\\boot.ini");
#endif // _X86_
                ExecInfo.lpFile          = TEXT("%windir%\\system32\\NOTEPAD.EXE");
                ExecInfo.fMask           = SEE_MASK_DOENVSUBST;
                ExecInfo.nShow           = SW_SHOWNORMAL;
                ExecInfo.cbSize          = sizeof(SHELLEXECUTEINFO);
           
                //  Change Read-only file attrs on Boot.ini file if necessary
                if ((dwFileAttr = GetFileAttributes (ExecInfo.lpParameters)) != 0xFFFFFFFF) 
                {
                    if (dwFileAttr & FILE_ATTRIBUTE_READONLY) 
                    {
                        SetFileAttributes (ExecInfo.lpParameters, dwFileAttr & ~FILE_ATTRIBUTE_READONLY);
                    }
                }

                ShellExecuteEx(&ExecInfo);
            }
            break;


        } // switch (LOWORD(wParam))
        break;

    case WM_DESTROY:
        StartListDestroy(hDlg, wParam, lParam);
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
        (DWORD_PTR) (LPSTR) aStartupHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
        (DWORD_PTR) (LPSTR) aStartupHelpIds);
        break;

    default:
        return FALSE;
    }
        
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\startup.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    startup.h

Abstract:

    Public declarations for the Startup/Recovery dialog of the System
    Control Panel Applet

Notes:

    The virtual memory settings and the crash dump (core dump) settings
    are tightly-coupled.  Therefore, crashdmp.c and startup.h have some
    heavy dependencies on virtual.c and virtual.h (and vice versa).

    On the other hand, the startup OS settings and the crash dump settings
    have almost nothing in common, so you won't see a lot of dependencies
    between these files (strlst.c/startup.c and crashdmp.c), even
    though they're on the same dialog.

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#ifndef _SYSDM_STARTUP_H_
#define _SYSDM_STARTUP_H_

//
// Constants
//

// Range of valid "Display startup list for..." values
#define FORMIN       0
#define FORMAX     999
// Length of WCHAR buffer needed to hold "Display startup list for..." value
#define FOR_MAX_LENGTH 20

// Default "Display startup list for..." value
#define FORDEF      30

// Crash dump constants
#define IDRV_DEF_BOOT       2       // Asssume booting from C:
#define MIN_SWAPSIZE        2       // Min swap file size.
#define ONE_MEG             1048576

// Set during initialization so we don't think changes made to controls
// during initialization are the same as changes made to controls by
// the user.

extern BOOL g_fStartupInitializing;

//
// Function Declarations
//
HPROPSHEETPAGE 
CreateStartupPage(
    IN HINSTANCE hInst
);

INT_PTR 
APIENTRY 
StartupDlgProc(
    IN HWND hDlg, 
    IN UINT uMsg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);


//
// Functions implemented in strtlst.c
//
void 
StartListInit( 
    IN HWND hDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam 
);

int 
StartListExit(
    IN HWND hDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam 
);

void 
StartListDestroy(
    IN HWND hDlg, 
    IN WPARAM wParam, 
    IN LPARAM lParam
);

BOOL 
CheckVal( 
    IN HWND hDlg, 
    IN WORD wID, 
    IN WORD wMin, 
    IN WORD wMax, 
    IN WORD wMsgID 
);

void
AutoAdvancedBootInit(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
);

int
AutoAdvancedBootExit(
    IN HWND hDlg,
    IN WPARAM wParam,
    IN LPARAM lParam
);

//
// Get the system drive. Exported by crashdmp.c.
//

BOOL
GetSystemDrive(
    OUT TCHAR * Drive
    );

ULONG64
CoreDumpGetRequiredFileSize(
    IN HWND hDlg OPTIONAL
    );

//
// This isn't a real dlg proc -- the return value is a bool.
//

int
APIENTRY
CoreDumpDlgProc(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    );


#endif // _SYSDM_STATUP_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\srcfg.cpp ===
/*++

Microsoft Confidential
Copyright (c) 1992-2000  Microsoft Corporation
All rights reserved

Module Name:
    srcfg.cpp

Abstract:
    Adds System Restore tab to the System Control Panel Applet if necessary.

Author:
    skkhang 15-Jun-2000

NOTE (7/26/00 skkhang):
    Now there is no code to unload srrstr.dll, because property page proc
    cannot unload the DLL. It is acceptable for the current CPL mechanism --
    using a separate process rundll32.exe which would clean up any loaded
    DLLs during termination. However, if system CPL is loaded in the context
    of, e.g., Shell itself, srrstr.dll will be leaked.

    One possible solution is to place a proxy property page proc in this file
    and calls the real proc in srrstr.dll only when srrstr.dll is loaded
    in the memory. Of course, even in that case, determination of whether to
    show SR Tab or not must be made first of all.

--*/

#include "sysdm.h"


typedef HPROPSHEETPAGE (WINAPI *SRGETPAGEPROC)();

static LPCWSTR  s_cszSrSysCfgDllName = L"srrstr.dll";
static LPCSTR   s_cszSrGetPageProc   = "SRGetCplPropPage";



HPROPSHEETPAGE
CreateSystemRestorePage(int, DLGPROC)
{
    HPROPSHEETPAGE hRet = NULL;

    HMODULE hModSR = LoadLibrary( s_cszSrSysCfgDllName );
    if (hModSR)
    {        
        SRGETPAGEPROC pfnGetPage = (SRGETPAGEPROC)::GetProcAddress( hModSR, s_cszSrGetPageProc );
        if (pfnGetPage)
        {
            hRet = pfnGetPage();
        }
        
        if (!hRet)
        {
            ::FreeLibrary( hModSR );
        }
    }

    return hRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\sysdm.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    sysdm.h

Abstract:

    Applet-wide declaraions and definitions for the 
    System Control Panel Applet.

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#ifndef _SYSDM_H_
#define _SYSDM_H_

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntexapi.h>
#include <windows.h>
#include <commctrl.h>
#include <comctrlp.h>
#include <shellapi.h>
#include <shlobj.h>
#include <shlobjp.h>
#include <shlwapi.h>
#include <shlwapip.h>
#include <cpl.h>
#define STRSAFE_NO_DEPRECATE
#include <strsafe.h>

#ifdef __cplusplus
extern "C" {
#endif // __cplusplus
#include "resource.h"
#include "helpid.h"
#include "util.h"
#include "sid.h"
#include "general.h"
#include "netid.h"
#include "hardware.h"
#include "hwprof.h"
#include "profile.h"
#include "advanced.h"
#include "perf.h"
#include "virtual.h"
#include "startup.h"
#include "envvar.h"
#include "edtenvar.h"
#include "syspart.h"
#include "pfrscpl.h"
#include "srcfg.h"
#include "visualfx.h"

//
// Global variables
//
extern TCHAR g_szErrMem[ 200 ];         //  Low memory message
extern TCHAR g_szSystemApplet[ 100 ];   //  "System Control Panel Applet" title
extern HINSTANCE hInstance;
extern TCHAR g_szNull[];
extern BOOL g_fRebootRequired;


//
// Macros
//

#define ARRAYSIZE(a) (sizeof(a)/sizeof(a[0]))

#define SetLBWidth( hwndLB, szStr, cxCurWidth )     SetLBWidthEx( hwndLB, szStr, cxCurWidth, 0)

#define IsPathSep(ch)       ((ch) == TEXT('\\') || (ch) == TEXT('/'))
#define IsWhiteSpace(ch)    ((ch) == TEXT(' ') || (ch) == TEXT('\t') || (ch) == TEXT('\n') || (ch) == TEXT('\r'))
#define IsDigit(ch)         ((ch) >= TEXT('0') && (ch) <= TEXT('9'))

#define DigitVal(ch)        ((ch) - TEXT('0'))

#define MAX_PAGES           16  // Arbitrary Maximum number of pages in the System Control Panel.


typedef HPROPSHEETPAGE (*PSPCALLBACK)(int idd, DLGPROC pfnDlgProc);

typedef struct
{
    PSPCALLBACK pfnCreatePage;
    int idd;
    DLGPROC pfnDlgProc;
}
PSPINFO;

HPROPSHEETPAGE CreatePage(int idd, DLGPROC pfnDlgProc);


//
// Debugging macros
//
#if DBG
#   define  DBG_CODE    1

void DbgPrintf( LPTSTR szFmt, ... );
void DbgStopX(LPSTR mszFile, int iLine, LPTSTR szText );

#   define  DBGSTOP( t )        DbgStopX( __FILE__, __LINE__, TEXT(t) )
#   define  DBGSTOPX( f, l, t ) DbgStopX( f, l, TEXT(t) )
#   define  DBGPRINTF(p)        DbgPrintf p
#   define  DBGOUT(t)           DbgPrintf( TEXT("SYSDM.CPL: %s\n"), TEXT(t) )
#else

#   define  DBGSTOP( t )
#   define  DBGSTOPX( f, l, t )
#   define  DBGPRINTF(p)
#   define  DBGOUT(t)
#endif

#ifdef __cplusplus
} // extern "C"
#endif // __cplusplus

#endif // _SYSDM_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\sysdm.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    sysdm.c 

Abstract:

    Initialization code for System Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#include "sysdm.h"
#include <shsemip.h>
#include <regstr.h>

//
// Global Variables
//
HINSTANCE hInstance;
TCHAR szShellHelp[]       = TEXT("ShellHelp");
TCHAR g_szNull[] = TEXT("");
UINT  uiShellHelp;

TCHAR g_szErrMem[ 200 ];           //  Low memory message
TCHAR g_szSystemApplet[ 100 ];     //  "System Control Panel Applet" title

//
// Function prototypes
//

void 
RunApplet(
    IN HWND hwnd, 
    IN LPTSTR lpCmdLine
);
void _GetStartingPage(IN LPTSTR lpCmdLine, IN PROPSHEETHEADER* ppsh, INT* piStartPage, LPTSTR pszStartPage, INT cchStartPage);
BOOL CALLBACK _AddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam);


BOOL 
WINAPI
DllInitialize(
    IN HINSTANCE hInstDLL, 
    IN DWORD dwReason, 
    IN LPVOID lpvReserved
)
/*++

Routine Description:

    Main entry point.

Arguments:

    hInstDLL -
        Supplies DLL instance handle.

    dwReason -
        Supplies the reason DllInitialize() is being called.

    lpvReserved -
        Reserved, NULL.

Return Value:

    BOOL

--*/
{
    if (dwReason != DLL_PROCESS_ATTACH) {
        return TRUE;
    }

    hInstance = hInstDLL;

    return TRUE;
}


LONG 
APIENTRY
CPlApplet( 
    IN HWND hwnd, 
    IN WORD wMsg, 
    IN LPARAM lParam1, 
    IN LPARAM lParam2
)
/*++

Routine Description:

    Control Panel Applet entry point.

Arguments:

    hwnd -
        Supplies window handle.

    wMsg -
        Supplies message being sent.

    lParam1 -
        Supplies parameter to message.

    lParam2 -
        Supplies parameter to message.

Return Value:

    Nonzero if message was handled.
    Zero if message was unhandled. 

--*/
{

    LPCPLINFO lpCPlInfo;

    switch (wMsg) {

        case CPL_INIT:
            uiShellHelp = RegisterWindowMessage (szShellHelp);

            LoadString( hInstance, IDS_INSUFFICIENT_MEMORY,   g_szErrMem,       ARRAYSIZE( g_szErrMem ) );
            LoadString( hInstance, IDS_SYSDM_TITLE, g_szSystemApplet, ARRAYSIZE( g_szSystemApplet ) );

            return (LONG) TRUE;

        case CPL_GETCOUNT:
            return 1;

        case CPL_INQUIRE:

            lpCPlInfo = (LPCPLINFO)lParam2;

            lpCPlInfo->idIcon = ID_ICON;
            lpCPlInfo->idName = IDS_NAME;
            lpCPlInfo->idInfo = IDS_INFO;

            return (LONG) TRUE;

        case CPL_DBLCLK:

            lParam2 = 0L;
            // fall through...

        case CPL_STARTWPARMS:
            RunApplet(hwnd, (LPTSTR)lParam2);
            return (LONG) TRUE;
    }
    return (LONG)0;

}

HPROPSHEETPAGE CreatePage(int idd, DLGPROC pfnDlgProc)
{
    PROPSHEETPAGE psp;
    psp.dwSize = sizeof(psp);
    psp.dwFlags = PSP_DEFAULT;
    psp.hInstance = hInstance;
    psp.pszTemplate = MAKEINTRESOURCE(idd);
    psp.pfnDlgProc = pfnDlgProc;
    return CreatePropertySheetPage(&psp);
}

static const PSPINFO c_pspCB[] =
{
    { CreatePage,               IDD_GENERAL,    GeneralDlgProc  },
    { CreateNetIDPage,          0,              NULL            },
    { CreatePage,               IDD_HARDWARE,   HardwareDlgProc },
    { CreatePage,               IDD_ADVANCED,   AdvancedDlgProc },
    { CreateSystemRestorePage,  0,              NULL            },
};

void 
RunApplet(
    IN HWND hwnd, 
    IN LPTSTR lpCmdLine
)
/*++

Routine Description:

    CPL_STARTWPARMS message handler.  Called when the user
    runs the Applet.

    PropSheet initialization occurs here.

Arguments:

    hwnd -
        Supplies window handle.

    lpCmdLine -
        Supplies the command line used to invoke the applet.

Return Value:

    none

--*/
{
    HRESULT hrOle = CoInitialize(0);

    if (!SHRestricted(REST_MYCOMPNOPROP))
    {
        if (lpCmdLine && *lpCmdLine && !lstrcmp(lpCmdLine, TEXT("-1")))
        {
            // -1 means Performance Options cpl
            DoPerformancePS(NULL);
        }
        else
        {
            HPROPSHEETPAGE hPages[MAX_PAGES];
            PROPSHEETHEADER psh;
            UINT iPage = 0;
            HPSXA hpsxa = NULL;
            INT i;
            INT iStartPage;
            TCHAR szStartPage[MAX_PATH];

            ZeroMemory(&psh, sizeof(psh));

            if (SUCCEEDED(hrOle))
            {
                // this call is needed to allow the WMI calls to get the processor information
                CoInitializeSecurity(NULL, -1, NULL, NULL, RPC_C_AUTHN_LEVEL_CONNECT, RPC_C_IMP_LEVEL_IMPERSONATE, 
                                     NULL, EOAC_NONE, 0);
            }

            LinkWindow_RegisterClass();

            psh.dwSize = sizeof(PROPSHEETHEADER);
            psh.dwFlags = 0;
            psh.hwndParent = hwnd;
            psh.hInstance = hInstance;
            psh.pszCaption = MAKEINTRESOURCE(IDS_TITLE);
            psh.phpage = hPages;

            for (i = 0; i < ARRAYSIZE(c_pspCB); i++)
            {
                hPages[iPage] = c_pspCB[i].pfnCreatePage(c_pspCB[i].idd, c_pspCB[i].pfnDlgProc);
                if (hPages[iPage] != NULL)
                {
                    iPage++;
                }
            }

            psh.nPages = iPage; 

            // add any extra property pages from the shell ext hooks in the registry
            // 8 extensions should be enough. Desk.cpl also does the same.
            hpsxa = SHCreatePropSheetExtArray( HKEY_LOCAL_MACHINE, REGSTR_PATH_CONTROLSFOLDER TEXT("\\System"), 8 );
            if (hpsxa != NULL )
                SHAddFromPropSheetExtArray( hpsxa, _AddPropSheetPage, (LPARAM)&psh ); 

            szStartPage[0] = 0;
            _GetStartingPage(lpCmdLine, &psh, &iStartPage, szStartPage, ARRAYSIZE(szStartPage));
            if (szStartPage[0])
            {
                psh.dwFlags |= PSH_USEPSTARTPAGE;
                psh.pStartPage = szStartPage;
            }
            else
            {
                psh.nStartPage = iStartPage;
            }

            if (PropertySheet (&psh) == ID_PSREBOOTSYSTEM)
            {
                RestartDialogEx(hwnd, NULL, EWX_REBOOT, SHTDN_REASON_MAJOR_SYSTEM | SHTDN_REASON_MINOR_RECONFIG | SHTDN_REASON_FLAG_PLANNED);
            }

            if (hpsxa != NULL)
                SHDestroyPropSheetExtArray(hpsxa);
        
            LinkWindow_UnregisterClass(hInstance);
        }
    }

    if (SUCCEEDED(hrOle))
    {
        CoUninitialize();
    }
}


BOOL CALLBACK _AddPropSheetPage(HPROPSHEETPAGE hpage, LPARAM lParam)
{
    PROPSHEETHEADER FAR * ppsh = (PROPSHEETHEADER FAR *)lParam;

    if( hpage && ( ppsh->nPages < MAX_PAGES ) )
    {
        ppsh->phpage[ppsh->nPages++] = hpage;
        return TRUE;
    }
    return FALSE;
}

void _GetStartingPage(IN LPTSTR lpCmdLine, IN PROPSHEETHEADER* ppsh, INT* piStartPage, LPTSTR pszStartPage, INT cchStartPage)
{
    *piStartPage = 0;
    if (lpCmdLine && *lpCmdLine)
    {
        if (!StrToIntEx(lpCmdLine, STIF_DEFAULT, piStartPage) &&
            (*lpCmdLine == TEXT('@')))
        {
            LPTSTR pszComma = StrChr(lpCmdLine, TEXT(','));
            if (pszComma)
            {
                HINSTANCE hInstanceDLL;
                *pszComma = 0;
                hInstanceDLL = LoadLibrary(lpCmdLine + 1);
                if (hInstanceDLL)
                {
                    UINT idResource = StrToInt(++pszComma);
                    LoadString(hInstanceDLL, idResource, pszStartPage, cchStartPage);
                    FreeLibrary(hInstanceDLL);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\strtlst.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    strtlst.c

Abstract:

    Implements the controls in the "Startup" group on the
    Startup/Recovery dialog of the System Control Panel Applet

Revision History:

    23-Jan-1996 JonPa
        ported from NT3.51's system.cpl

--*/
#include "sysdm.h"

///////////////////////////////////////////////////////////////
//          Persistant  vars
///////////////////////////////////////////////////////////////
static TCHAR *pszBoot = NULL;
static int nOriginalSelection;
static int nOriginalTimeout;

HANDLE hBootStatusData = NULL;

/*
 * These functions in SETUPDLL.DLL are ANSI only!!!!
 *
 * Therefore any functions working with this DLL MUST remain ANSI only.
 * The functions are GetRGSZEnvVar and UpdateNVRAM.
 * The structure CPEnvBuf MUST also remain ANSI only.
 */
typedef int (WINAPI *GETNVRAMPROC)(CHAR **, USHORT, CHAR *, USHORT);
typedef int (WINAPI *WRITENVRAMPROC)(DWORD, PSZ *, PSZ *);

#ifdef _X86_

TCHAR szBootIni[]     = TEXT( "c:\\boot.ini" );
TCHAR szBootLdr[]     = TEXT( "boot loader" );
TCHAR szFlexBoot[]    = TEXT( "flexboot" );
TCHAR szMultiBoot[]   = TEXT( "multiboot" );
TCHAR szTimeout[]     = TEXT( "timeout" );
TCHAR szDefault[]     = TEXT( "default" );
TCHAR szOS[]          = TEXT( "operating systems" );

#define BUFZ        4096

//
// For NEC PC98. Following definition comes from user\inc\kbd.h.
// The value must be the same as value in kbd.h.
//
#define NLSKBD_OEM_NEC   0x0D

TCHAR x86DetermineSystemPartition( IN HWND hdlg );

#endif

#if defined(EFI_NVRAM_ENABLED)

//
// IsEfi() is always true on IA64 machines. Therefore this determination can
// be made at compile time. When x86 EFI machines are supported, the check
// will need to be made at run time on x86.
//

#if defined(_IA64_)
#define IsEfi() TRUE
#else
BOOLEAN
IsEfi(
    VOID
    );
#endif

typedef struct _MY_BOOT_ENTRY {
    LIST_ENTRY ListEntry;
    PWSTR FriendlyName;
    int Index;
    LOGICAL Show;
    LOGICAL Ordered;
    PBOOT_ENTRY NtBootEntry;
} MY_BOOT_ENTRY, *PMY_BOOT_ENTRY;

LIST_ENTRY BootEntries;
PBOOT_ENTRY_LIST BootEntryList = NULL;
PBOOT_OPTIONS BootOptions;

#define ADD_OFFSET(_p,_o) (PVOID)((PUCHAR)(_p) + (_p)->_o)

#endif // defined(EFI_NVRAM_ENABLED)

     // v-pshuan: since the Silicon Graphics visual workstations boot
     // ARC style, this code needs to be compiled for _X86_ as well.

static HMODULE hmodSetupDll;   // hmod for setup - has api we need
static GETNVRAMPROC fpGetNVRAMvar;  // address of function for getting nvram vars
BOOL fCanUpdateNVRAM;

#define MAX_BOOT_ENTRIES 10

typedef struct tagEnvBuf
{
  int     cEntries;
  CHAR *  pszVars[MAX_BOOT_ENTRIES];
  // v-pshuan: this implies a maximum of 10 boot entries are supported
  // although no error checking is performed in the existing parsing code
  // to make sure there aren't more than 10 boot entries.
} CPEnvBuf;

//*************************************************************
//
//  StringToIntA
//
//  Purpose:    atoi
//
//  Parameters: LPSTR sz - pointer of string to convert
//
//  Return:     void
//
//  WARNING:  Unlike StringToInt, this one does not skip leading
//  white space
//
//*************************************************************
int StringToIntA( LPSTR sz ) {
    int i = 0;

    while( IsDigit( *sz ) ) {
        i = i * 10 + (*sz - '0');
        sz++;
    }

    return i;
}

////////////////////////////////////////////////////////////////////////////
//  CP_MAX_ENV assumes entire env. var. value < maxpath +
//  add 20 for various quotes
//  and 10 more for commas (see list description below)
////////////////////////////////////////////////////////////////////////////
#define CP_MAX_ENV   (MAX_PATH + 30)

CPEnvBuf CPEBOSLoadIdentifier;
BOOL fAutoLoad;

//////////////////////////////////////////////////////////////////////
//
// Identify whether we are running on an x86 system which nevertheless
// boots using the ARC path (no c:\boot.ini)
//
//////////////////////////////////////////////////////////////////////

BOOL Is_ARCx86(void)
{
    TCHAR identifier[256];
    ULONG identifierSize = sizeof(identifier);
    HKEY hSystemKey = NULL;
    BOOL rval = FALSE;

    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                     TEXT("HARDWARE\\DESCRIPTION\\System"),
                     0,
                     KEY_QUERY_VALUE,
                     &hSystemKey) == ERROR_SUCCESS) {
        if ((SHRegGetValue(hSystemKey,
                           NULL,
                           TEXT("Identifier"),
                           SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND,
                           NULL,
                           (LPBYTE) identifier,
                           &identifierSize) == ERROR_SUCCESS) &&
            (StrStr(identifier, TEXT("ARCx86")) != NULL)) 
        {
            rval = TRUE;
        }
        RegCloseKey(hSystemKey);
    }
    return rval;
}

////////////////////////////////////////////////////////////////////////////
//
//  This routine will query the ARC NVRAM for an option passed
//  in szName and fill in the argv style pointer passed in.
//
////////////////////////////////////////////////////////////////////////////

BOOL GetRGSZEnvVar(CPEnvBuf * pEnvBuf, PCHAR pszName)
{
    CHAR   *pszCur, *p;
    int     cb, i;
    CHAR   *rgtmp[1];
    CHAR    rgchOut[CP_MAX_ENV*MAX_BOOT_ENTRIES];

    // GetNVRAMVar takes an argv[] style paramater as input, so crock
    // one up.
    rgtmp[0] = pszName;

    // GetNVRAMVar returns a 'list' of the form
    //   open-curly"string1","string2","string3"close-curly
    //
    // an empty environment string will be 5 bytes:
    // open-curly""close-curly[null-terminator]

    cb = fpGetNVRAMvar (rgtmp, (USHORT)1,
                rgchOut, (USHORT) CP_MAX_ENV*MAX_BOOT_ENTRIES);

    pEnvBuf->cEntries = 0;

    // if cb was equal to 5, the string was empty (see above comment)
    if (cb > 5)
    {
        // break the string up into array of separate strings that
        // can be put into a listbox.
        pszCur = rgchOut;

        // skip first open-curly brace
        pszCur++;

        // counter for array of strings
        i = 0;
        while (*pszCur != '}')
        {
            p = pEnvBuf->pszVars[i] = LocalAlloc (LPTR, MAX_PATH);
            
            // PREFIX change to prevent a potential NULL dereference
            if (!p)
            {
                pEnvBuf->cEntries = i;
                return FALSE;
            }

            // skip first quote
            pszCur++;
            while (*pszCur != '"')
               *p++ = *pszCur++;

            // skip the close quote
            pszCur++;

            // null terminate destination
            *p = '\0';

            // skip the comma if not at end of string
            if (*pszCur == ',')
            {
               pszCur++;
               // and go to next string
            }
            i++;
        }
        pEnvBuf->cEntries = i;
    }

    return pEnvBuf->cEntries;
}

////////////////////////////////////////////////////////////////////////////
//
//  This routine will free the memory allocated by GetRGSZEnvVar
//
//  History:
//      22-Apr-1996 JonPa   Created it.
//
////////////////////////////////////////////////////////////////////////////
void FreeRGSZEnvVar(CPEnvBuf * pEnvBuf) {
    int i;

    for( i = 0; i < pEnvBuf->cEntries; i++ ) {
        LocalFree( pEnvBuf->pszVars[i] );
    }
}

////////////////////////////////////////////////////////////////////////////
// The user has made a choice among the entries.
// Now we have to arrange all the strings stored in NVRAM so
// that they  have the same ordering.  The selection is passed in,
// so what this  function does is if selection is M, it makes the Mth item
// appear first in each of the 5 environment strings and the other items
// follow it in the list.
//
// Then if the timeout button is checked, it updates the AUTOLOAD variable
// to "yes" and set the COUNTDOWN variable to the number of seconds in the
// edit control.
//
////////////////////////////////////////////////////////////////////////////

BOOL UpdateNVRAM(HWND hdlg, int selection, int timeout)
{
    CHAR *rgszVRAM[5] = { "SYSTEMPARTITION",
                          "OSLOADER",
                          "OSLOADPARTITION",
                          "OSLOADFILENAME",
                          "OSLOADOPTIONS"
                        };
    CPEnvBuf rgcpeb[5];


    WRITENVRAMPROC fpWriteNVRAMVar;
    int iTemp, jTemp;
    CHAR *pszSwap;
    CHAR szTemp[10];
    HMODULE hmodSetupDLL;
    BOOL bChecked;

    // args and charray are needed for call to SetNVRamVar() in SETUP
    PSZ args[2];
    CHAR chArray[CP_MAX_ENV*MAX_BOOT_ENTRIES];
    PSZ pszReturn;

    hmodSetupDll = LoadLibrary(TEXT("setupdll.dll"));
    if (!hmodSetupDll)
    {
        return FALSE;
    }

    fpWriteNVRAMVar = (WRITENVRAMPROC) GetProcAddress(hmodSetupDll, "SetNVRAMVar");
    if (!fpWriteNVRAMVar)
    {
        FreeLibrary (hmodSetupDll);
        return FALSE;
    }

    // 0 is always the selection when the dialog is brought up,
    // so as an optimization don't update the nvram if it's
    // not necessary.
    if (selection != 0)
    {
       // read in the strings from NVRAM.  the number of strings (other than
       // LOADIDENTIFIER is 5)
       for (iTemp = 0; iTemp < 5; iTemp++)
       {
           GetRGSZEnvVar (&rgcpeb[iTemp], rgszVRAM[iTemp]);
           // now re-order the strings to swap the 'selection-th' item
           // string with the first string.
           pszSwap = rgcpeb[iTemp].pszVars[0];
           rgcpeb[iTemp].pszVars[0] = rgcpeb[iTemp].pszVars[selection];
           rgcpeb[iTemp].pszVars[selection] = pszSwap;
       }
       // now do the same for the LOADIDENTIFIER, (this was set up earlier
       // in the processing the INITDIALOG message).
       pszSwap = CPEBOSLoadIdentifier.pszVars[0];
       CPEBOSLoadIdentifier.pszVars[0] = CPEBOSLoadIdentifier.pszVars[selection];
       CPEBOSLoadIdentifier.pszVars[selection] = pszSwap;

       // now write to NVRAM:  first write LOADIDENTIFIER, then the other 5
       // variables.
       args[0] = (PSZ)"LOADIDENTIFIER";
       args[1] = chArray;

       chArray[0] = '\0';
       for (iTemp = 0; iTemp < CPEBOSLoadIdentifier.cEntries; iTemp++)
       {
           if (FAILED(StringCchCatA(chArray, ARRAYSIZE(chArray), CPEBOSLoadIdentifier.pszVars[iTemp])) ||
               FAILED(StringCchCatA(chArray, ARRAYSIZE(chArray), ";")))
           {
               FreeLibrary (hmodSetupDll);
               return FALSE;
           }
       }
       // remove the last semi-colon:
       chArray[lstrlenA(chArray)-1] = '\0';

       fpWriteNVRAMVar ((DWORD)2, args, &pszReturn);

       for (iTemp = 0; iTemp < 5; iTemp++)
       {
           args[0] = rgszVRAM[iTemp];
           args[1] = chArray;
           chArray[0] = '\0';
           for (jTemp = 0; jTemp < rgcpeb[iTemp].cEntries; jTemp++)
           {
               if (FAILED(StringCchCatA(chArray, ARRAYSIZE(chArray), rgcpeb[iTemp].pszVars[jTemp])) ||
                   FAILED(StringCchCatA(chArray, ARRAYSIZE(chArray), ";")))
               {
                   FreeLibrary (hmodSetupDll);
                   return FALSE;
               }
           }
           chArray[lstrlenA(chArray)-1] = '\0';

           fpWriteNVRAMVar ((DWORD)2, args, &pszReturn);

           // We are done with this variable... Free the resources it consumes
           FreeRGSZEnvVar( &rgcpeb[iTemp] );
       }

    }
    args[0] = "AUTOLOAD";
    if (bChecked = IsDlgButtonChecked (hdlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN))
       args[1] = "YES";
    else
       args[1] = "";

    fpWriteNVRAMVar ((DWORD)2, args, &pszReturn);
    // This is a temporary hack workaround for the fact that the
    // AUTOLOAD variable seems to be broken on Alpha
    //if (bChecked)
    //{
        args[0] = "COUNTDOWN";
        args[1] = szTemp;
        StringCchPrintfA(szTemp, ARRAYSIZE(szTemp), "%d", timeout);
        fpWriteNVRAMVar ((DWORD)2, args, &pszReturn);
    //}
    FreeLibrary (hmodSetupDll);

    return TRUE;
}

#if defined(EFI_NVRAM_ENABLED)

////////////////////////////////////////////////////////////////////////////
//
//  This routine frees allocations related to EFI Boot Manager information
//  from NVRAM.
//
////////////////////////////////////////////////////////////////////////////

VOID
FreeEfiBootEntries (
                    VOID
                    )
{
    PLIST_ENTRY listEntry;
    PMY_BOOT_ENTRY myBootEntry;
    
    while (!IsListEmpty(&BootEntries)) 
    {
        listEntry = RemoveHeadList(&BootEntries);
        myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);
        LocalFree(myBootEntry);
    }
    LocalFree(BootEntryList);
    BootEntryList = NULL;
    
    LocalFree(BootOptions);
    BootOptions = NULL;

    return;

} // FreeEfiBootEntries

////////////////////////////////////////////////////////////////////////////
//
//  This routine reads EFI Boot Manager information from NVRAM.
//
////////////////////////////////////////////////////////////////////////////

BOOL
ReadEfiBootEntries (
    VOID
    )
{
    NTSTATUS status;
    ULONG length;
    ULONG count;
    PULONG order = NULL;
    PBOOT_ENTRY_LIST bootEntryList;
    PBOOT_ENTRY bootEntry;
    PMY_BOOT_ENTRY myBootEntry;
    PLIST_ENTRY listEntry;
    LONG i;
    BOOLEAN wasEnabled;
    BOOL retval = FALSE;

    InitializeListHead(&BootEntries);

    //
    // Enable the privilege that is necessary to query NVRAM.
    //

    status = RtlAdjustPrivilege(
                SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                TRUE,
                FALSE,
                &wasEnabled
                );
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    //
    // Get the global system boot options.
    //
    length = 0;
    status = NtQueryBootOptions(NULL, &length);

    if (status != STATUS_BUFFER_TOO_SMALL) {

        ASSERT(FALSE);
        goto error;

    } else {

        BootOptions = LocalAlloc(LPTR, length);
        if (BootOptions == NULL) {
            goto error;
        }

        status = NtQueryBootOptions(BootOptions, &length);

        if (status != STATUS_SUCCESS) {
            ASSERT(FALSE);
            goto error;
        }
    }

    //
    // Get the system boot order list.
    //
    count = 0;
    status = NtQueryBootEntryOrder(NULL, &count);

    if (status != STATUS_BUFFER_TOO_SMALL) {

        if (status == STATUS_SUCCESS) {

            //
            // There are no entries in the boot order list. Strange but
            // possible.
            //
            count = 0;

        } else {

            //
            // An unexpected error occurred.
            //
            ASSERT(FALSE);
            goto error;
        }
    }

    if (count != 0) {

        order = LocalAlloc(LPTR, count * sizeof(ULONG));
        if (order == NULL) {
            goto error;
        }

        status = NtQueryBootEntryOrder(order, &count);

        if (status != STATUS_SUCCESS) {

            //
            // An unexpected error occurred.
            //
            ASSERT(FALSE);
            goto error;
        }
    }

    //
    // Get all existing boot entries.
    //
    length = 0;
    status = NtEnumerateBootEntries(NULL, &length);

    if (status != STATUS_BUFFER_TOO_SMALL) {

        if (status == STATUS_SUCCESS) {

            //
            // Somehow there are no boot entries in NVRAM.
            //
            goto error;

        } else {

            //
            // An unexpected error occurred.
            //
            ASSERT(FALSE);
            goto error;
        }
    }

    ASSERT(length != 0);
    
    BootEntryList = LocalAlloc(LPTR, length);
    if (BootEntryList == NULL) {
        goto error;
    }

    status = NtEnumerateBootEntries(BootEntryList, &length);

    if (status != STATUS_SUCCESS) {
        ASSERT(FALSE);
        goto error;
    }

    //
    // Convert the boot entries into our internal representation.
    //
    bootEntryList = BootEntryList;

    while (TRUE) {

        bootEntry = &bootEntryList->BootEntry;

        //
        // Allocate an internal structure for the boot entry.
        //
        myBootEntry = LocalAlloc(LPTR, sizeof(MY_BOOT_ENTRY));
        if (myBootEntry == NULL) {
            goto error;
        }

        RtlZeroMemory(myBootEntry, sizeof(MY_BOOT_ENTRY));

        //
        // Save the address of the NT boot entry.
        //
        myBootEntry->NtBootEntry = bootEntry;

        //
        // Save the address of the entry's friendly name.
        //
        myBootEntry->FriendlyName = ADD_OFFSET(bootEntry, FriendlyNameOffset);

        //
        // Link the new entry into the list.
        //
        InsertTailList(&BootEntries, &myBootEntry->ListEntry);

        //
        // Move to the next entry in the enumeration list, if any.
        //
        if (bootEntryList->NextEntryOffset == 0) {
            break;
        }
        bootEntryList = ADD_OFFSET(bootEntryList, NextEntryOffset);
    }

    //
    // Boot entries are returned in an unspecified order. They are currently
    // in the SpBootEntries list in the order in which they were returned.
    // Sort the boot entry list based on the boot order. Do this by walking
    // the boot order array backwards, reinserting the entry corresponding to
    // each element of the array at the head of the list.
    //

    for (i = (LONG)count - 1; i >= 0; i--) {

        for (listEntry = BootEntries.Flink;
             listEntry != &BootEntries;
             listEntry = listEntry->Flink) {

            myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);

            if (myBootEntry->NtBootEntry->Id == order[i] ) {

                //
                // We found the boot entry with this ID. Move it to the
                // front of the list.
                //

                myBootEntry->Ordered = TRUE;

                RemoveEntryList(&myBootEntry->ListEntry);
                InsertHeadList(&BootEntries, &myBootEntry->ListEntry);

                break;
            }
        }
    }

    //
    // Free the boot order list.
    //
    if (count != 0) {
        LocalFree(order);
        order = NULL;
    }

    //
    // We don't want to show entries that are not in the boot order list.
    // We don't want to show removable media entries (for floppy or CD).
    // We do show non-NT entries.
    //
    count = 0;
    for (listEntry = BootEntries.Flink;
         listEntry != &BootEntries;
         listEntry = listEntry->Flink) {

        myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);

        if (myBootEntry->Ordered &&
            ((myBootEntry->NtBootEntry->Attributes & BOOT_ENTRY_ATTRIBUTE_REMOVABLE_MEDIA) == 0)) {
            myBootEntry->Show = TRUE;
            count++;
        }
    }

    //
    // If we don't have any entries to show, disable the dialog box entirely.
    //
    if (count == 0) {
        goto error;
    }

    retval = TRUE;

done:

    if (!wasEnabled) {
        status = RtlAdjustPrivilege(
                    SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                    FALSE,
                    FALSE,
                    &wasEnabled
                    );
    }

    return retval;

error:

    //
    // An error occurred. Clean up all allocations.
    //
    LocalFree(order);
    FreeEfiBootEntries();

    goto done;

} // ReadEfiBootEntries

////////////////////////////////////////////////////////////////////////////
//
// EFI version of UpdateNVRAM.
//
// The user has made a choice among the entries. Rewrite the boot order
// list to put the user's selection at the front. Also update the Timeout
// variable.
//
////////////////////////////////////////////////////////////////////////////

BOOL
WriteEfiBootEntries (
    HWND hdlg,
    int selection,
    int timeout
    )
{
    NTSTATUS status;
    BOOLEAN wasEnabled;
    BOOL retval = FALSE;

    //
    // Enable the privilege that is necessary to query NVRAM.
    //

    status = RtlAdjustPrivilege(
                SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                TRUE,
                FALSE,
                &wasEnabled
                );
    if (!NT_SUCCESS(status)) {
        return FALSE;
    }

    //
    // 0 is always the selection when the dialog is brought up,
    // so as an optimization don't update the nvram if it's
    // not necessary.
    //
    if (selection != 0) {

        //
        // Walk the boot entry list, looking for (a) the entry with combo box
        // index 0, and (b) the selected entry. We want to swap these two
        // entries.
        //

        PLIST_ENTRY listEntry;
        PMY_BOOT_ENTRY myBootEntry;
        PMY_BOOT_ENTRY firstEntry = NULL;
        PMY_BOOT_ENTRY selectedEntry = NULL;
        PLIST_ENTRY previousEntry;
        ULONG count;
        PULONG order;

        for (listEntry = BootEntries.Flink;
             listEntry != &BootEntries;
             listEntry = listEntry->Flink) {

            myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);

            if (myBootEntry->Show) {
                if (myBootEntry->Index == 0) {
                    firstEntry = myBootEntry;
                } else if (myBootEntry->Index == selection) {
                    selectedEntry = myBootEntry;
                }
            }
        }

        ASSERT(firstEntry != NULL);
        ASSERT(selectedEntry != NULL);
        ASSERT(selectedEntry != firstEntry);

        //
        // Swap the entries. Capture the address of the entry before the first
        // entry (which might be the list head). Remove the first entry from
        // the list and insert it after the selected entry. Remove the selected
        // entry from the list and insert it after the captured entry.
        //

        previousEntry = firstEntry->ListEntry.Blink;
        RemoveEntryList(&firstEntry->ListEntry);
        InsertHeadList(&selectedEntry->ListEntry, &firstEntry->ListEntry);
        RemoveEntryList(&selectedEntry->ListEntry);
        InsertHeadList(previousEntry, &selectedEntry->ListEntry);

        //
        // Build the new boot order list. Insert all ordered boot entries
        // into the list.
        //
        count = 0;
        for (listEntry = BootEntries.Flink;
             listEntry != &BootEntries;
             listEntry = listEntry->Flink) {

            myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);
            if (myBootEntry->Ordered) {
                count++;
            }
        }
        order = LocalAlloc(LPTR, count * sizeof(ULONG));
        if (order == NULL) {
            goto done;
        }

        count = 0;
        for (listEntry = BootEntries.Flink;
             listEntry != &BootEntries;
             listEntry = listEntry->Flink) {

            myBootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);
            if (myBootEntry->Ordered) {
                order[count++] = myBootEntry->NtBootEntry->Id;
            }
        }
    
        //
        // Write the new boot entry order list to NVRAM.
        //
        status = NtSetBootEntryOrder(order, count);
        LocalFree(order);
        if (!NT_SUCCESS(status)) {
            goto done;
        }
    }

    //
    // Write the new timeout value to NVRAM.
    //
    if (!IsDlgButtonChecked(hdlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN)) {
        timeout = 0xffffffff;
    }

    if (timeout != BootOptions->Timeout) {

        BootOptions->Timeout = timeout;

        status = NtSetBootOptions(BootOptions, BOOT_OPTIONS_FIELD_TIMEOUT);
        if (!NT_SUCCESS(status)) {
            goto done;
        }
    }

    retval = TRUE;

done:

    if (!wasEnabled) {
        status = RtlAdjustPrivilege(
                    SE_SYSTEM_ENVIRONMENT_PRIVILEGE,
                    FALSE,
                    FALSE,
                    &wasEnabled
                    );
    }
    
    return retval;

} // WriteEfiBootEntries

#endif // defined(EFI_NVRAM_ENABLED)

#ifdef _X86_
BOOL WriteableBootIni( LPTSTR szBootIni, HWND hDlg ) {
    BOOL bOK;
    DWORD dwFileAttr;
    HANDLE hFile;

    bOK = TRUE;

    //  Change Read-only file attrs on Boot.ini file if necessary
    if ((dwFileAttr = GetFileAttributes (szBootIni)) != 0xFFFFFFFF) {
        if (dwFileAttr & FILE_ATTRIBUTE_READONLY) {
            if (!SetFileAttributes (szBootIni, dwFileAttr & ~FILE_ATTRIBUTE_READONLY))
            {
                bOK = FALSE;
            }
        }
    }

    if (bOK)
    {

        hFile = CreateFile( szBootIni, GENERIC_WRITE | GENERIC_READ, FILE_SHARE_WRITE | FILE_SHARE_READ, NULL,
                OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL );

        if (hFile != INVALID_HANDLE_VALUE) {
            CloseHandle(hFile);
        } else {
            if (GetLastError() == ERROR_FILE_NOT_FOUND || GetLastError() == ERROR_PATH_NOT_FOUND) {
                MsgBoxParam (hDlg, IDS_SYSDM_CANNOTOPENFILE, IDS_SYSDM_TITLE, MB_OK | MB_ICONEXCLAMATION, szBootIni);
            }
            bOK = FALSE;
        }

        //  Restore read-only attr, if necessary, after writes
        if (dwFileAttr != 0xFFFFFFFF && (dwFileAttr & FILE_ATTRIBUTE_READONLY)) {
            SetFileAttributes (szBootIni, dwFileAttr);
        }
    }

    return bOK;
}
#endif

void StartListInit( HWND hDlg, WPARAM wParam, LPARAM lParam ) {
    HWND    hwndTemp;
    HMODULE hmodSetupDll;
    int     iTemp;
    int     n;
   int timeout;
#ifdef _X86_
    int     i;
    TCHAR   szTemp2[MAX_PATH];
    int     selection;
    TCHAR  *pszKeyName;
    LPTSTR  pszLine;
    TCHAR  *pszValue;
    TCHAR  *pszTemp;

    //  ANSI string pointers

    LPWSTR  pszSectionHead;
    LPWSTR  pszSection;
#endif

#if defined(EFI_NVRAM_ENABLED)

    if (IsEfi()) {

        ShowWindow(GetDlgItem(hDlg, IDC_SYS_EDIT_BUTTION), FALSE);
        ShowWindow(GetDlgItem(hDlg, IDC_STARTUP_SYS_EDIT_LABEL), FALSE);

        hwndTemp = GetDlgItem (hDlg, IDC_STARTUP_SYS_OS);

        fCanUpdateNVRAM = ReadEfiBootEntries();

        if (fCanUpdateNVRAM) {

            PLIST_ENTRY listEntry;
            PMY_BOOT_ENTRY bootEntry;

            for (listEntry = BootEntries.Flink;
                 listEntry != &BootEntries;
                 listEntry = listEntry->Flink) {
                bootEntry = CONTAINING_RECORD(listEntry, MY_BOOT_ENTRY, ListEntry);
                if (bootEntry->Show) {
                    bootEntry->Index = (int)SendMessage (hwndTemp, CB_ADDSTRING, 0,
                                                         (LPARAM)bootEntry->FriendlyName);
                }
            }

            // the first one is the selection we want (offset 0)
            SendMessage (hwndTemp, CB_SETCURSEL, 0, 0L);
            nOriginalSelection = 0;

            SendDlgItemMessage (hDlg, IDC_STARTUP_SYS_SECONDS,
                                EM_LIMITTEXT, 3, 0L);
            SendDlgItemMessage (hDlg, IDC_STARTUP_SYS_SECSCROLL,
                      UDM_SETRANGE, 0, (LPARAM)MAKELONG(999,0));

            if (BootOptions->Timeout != 0xffffffff) {

                if (BootOptions->Timeout > 999) {
                    BootOptions->Timeout = 999;
                }

                SetDlgItemInt(
                   hDlg,
                   IDC_STARTUP_SYS_SECONDS,
                   BootOptions->Timeout,
                   FALSE
                );
                CheckDlgButton (hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN, TRUE);

            } else {

                SetDlgItemInt(
                   hDlg,
                   IDC_STARTUP_SYS_SECONDS,
                   0,
                   FALSE
                );
                CheckDlgButton (hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN, FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_SYS_SECONDS), FALSE);
                EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_SYS_SECSCROLL), FALSE);
            }

        } else {

            // if can't set variables (no privilege), disable controls
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS_LABEL), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_SECSCROLL), FALSE);
            EnableWindow (hwndTemp, FALSE);
        }

    } else

#endif // defined(EFI_NVRAM_ENABLED)

#ifdef _X86_
    if (Is_ARCx86())
#endif
    {
        ////////////////////////////////////////////////////////////////////
        //  Read info from NVRAM environment variables
        ////////////////////////////////////////////////////////////////////

        // Init to 0 so we won't try to free garbage if we cant load setup.dll
        CPEBOSLoadIdentifier.cEntries = 0;

        fCanUpdateNVRAM = FALSE;
        fAutoLoad = FALSE;
        hwndTemp = GetDlgItem (hDlg, IDC_STARTUP_SYS_OS);
        if (hmodSetupDll = LoadLibrary(TEXT("setupdll")))
        {
            if (fpGetNVRAMvar = (GETNVRAMPROC)GetProcAddress(hmodSetupDll, "GetNVRAMVar"))
            {
                if (fCanUpdateNVRAM = GetRGSZEnvVar (&CPEBOSLoadIdentifier, "LOADIDENTIFIER"))
                {
                    for (iTemp = 0; iTemp < CPEBOSLoadIdentifier.cEntries; iTemp++)
                        n = (int)SendMessageA (hwndTemp, CB_ADDSTRING, 0,
                                          (LPARAM)CPEBOSLoadIdentifier.pszVars[iTemp]);
                    // the first one is the selection we want (offset 0)
                    SendMessage (hwndTemp, CB_SETCURSEL, 0, 0L);
                    SendDlgItemMessage (hDlg, IDC_STARTUP_SYS_SECONDS,
                              EM_LIMITTEXT, 3, 0L);
                    SendDlgItemMessage (hDlg, IDC_STARTUP_SYS_SECSCROLL,
                              UDM_SETRANGE, 0, (LPARAM)MAKELONG(999,0));

                }
                // fCanUpdateNVRAM is a global that gets set up above
                if (fCanUpdateNVRAM)
                {
                   // This is a temporary hack workaround for the
                   // fact that the AUTOLOAD variable seems to
                   // be broken on Alpha
                   CPEnvBuf cpebTimeout;
                   
                   if (GetRGSZEnvVar(&cpebTimeout, "COUNTDOWN")) {
                      timeout = StringToIntA(cpebTimeout.pszVars[0]);
                      fAutoLoad = (BOOL) timeout;
                      SetDlgItemInt(
                         hDlg,
                         IDC_STARTUP_SYS_SECONDS,
                         timeout,
                         FALSE
                      );
                      FreeRGSZEnvVar(&cpebTimeout);
                   } // if

                   CheckDlgButton (hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN, fAutoLoad);
                   if (!fAutoLoad)
                   {
                       EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_SYS_SECONDS), FALSE);
                       EnableWindow (GetDlgItem (hDlg, IDC_STARTUP_SYS_SECSCROLL), FALSE);
                   }
                }
            }
            FreeLibrary (hmodSetupDll);
        }
        if (!fCanUpdateNVRAM) {
            // if can't set variables (no privilege), disable controls
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS_LABEL), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_SECSCROLL), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_OS), FALSE);
        }

        // default to 5 seconds for now.
    }
#ifdef _X86_
    else
    {
        ////////////////////////////////////////////////////////////////////
        //  Read info from boot.ini file and initialize OS Group box items
        ////////////////////////////////////////////////////////////////////

        InitializeArcStuff();

        //
        //  Get correct Boot Drive - this was added because after someone
        //  boots the system, they can ghost or change the drive letter
        //  of their boot drive from "c:" to something else.
        //

        szBootIni[0] = x86DetermineSystemPartition (hDlg);

        //
        //  Make sure we have access to BOOT.INI
        //
        if (!WriteableBootIni(szBootIni, hDlg)) {
            // if can't set variables (no privilege), disable controls
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS_LABEL), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_ENABLECOUNTDOWN), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_SECSCROLL), FALSE);
            EnableWindow (GetDlgItem(hDlg, IDC_STARTUP_SYS_OS), FALSE);
        }

        //
        //  Determine which section [boot loader]
        //                          [flexboot]
        //                       or [multiboot] is in file
        //
        n = GetPrivateProfileString (szBootLdr, NULL, NULL, szTemp2,
                                     ARRAYSIZE(szTemp2), szBootIni);
        if (n != 0)
            pszBoot = szBootLdr;
        else
        {
            n = GetPrivateProfileString (szFlexBoot, NULL, NULL, szTemp2,
                                         ARRAYSIZE(szTemp2), szBootIni);
            if (n != 0)
                pszBoot = szFlexBoot;
            else
            {
                n = GetPrivateProfileString (szMultiBoot, NULL, NULL, szTemp2,
                                             ARRAYSIZE(szTemp2), szBootIni);
                if (n != 0)
                {
                    pszBoot = szMultiBoot;
                }
                else
                {
                    //
                    //  This final case is here because I want to DEFAULT
                    //  to "[boot loader]" as the section name to use in
                    //  the event that we do not find any section in the
                    //  boot.ini file.
                    //

                    pszBoot = szBootLdr;
                }
            }
        }

        //  Get info under [*pszBoot] section - timeout & default OS path

        timeout = GetPrivateProfileInt (pszBoot, szTimeout, 0, szBootIni);

        SetDlgItemInt (hDlg, IDC_STARTUP_SYS_SECONDS, timeout, FALSE);

        nOriginalTimeout = timeout;

        //
        //  Get the "Default" os selection
        //

        szTemp2[0] = TEXT('\0');

        GetPrivateProfileString (pszBoot, szDefault, NULL, szTemp2,
                                 ARRAYSIZE(szTemp2), szBootIni);

        //
        //  Display all choices under [operating system] in boot.ini file
        //  in combobox for selection
        //

        hwndTemp = GetDlgItem (hDlg, IDC_STARTUP_SYS_OS);

        selection = -1;

        pszSectionHead = pszSection = (LPWSTR) LocalAlloc (LPTR, BUFZ * sizeof(WCHAR));
        if (!pszSection)
        {
            goto ContinueSystemInit;
        }

        //
        //  Get entire section under OS to properly show user choices
        //

        n = GetPrivateProfileSection (szOS, pszSection, BUFZ, szBootIni);

        if ((n >= BUFZ-2) || (n == 0))
        {
            //  Error reading data
            goto ContinueSystemInit;
        }

        //
        //  Check for api errors and NoOptions
        //

        if ((pszSection == NULL) || ((*pszSection == TEXT('\0')) && (*(pszSection+1) == TEXT('\0'))))
        {
            goto ContinueSystemInit;
        }

        //
        //  Continue until we reach end of buffer, marked by Double '\0'
        //

        while (*(pszSection+1) != TEXT('\0'))
        {
            pszLine = pszSection;

            //
            //  Get pointer to next line in buffer.
            //

            pszSection += lstrlen (pszSection) + 1;

            //
            //  Find LHS/RHS delimiter to separate strings
            //

            pszValue = StrStr(pszLine, TEXT("="));

            if (pszValue && (pszValue != pszLine))
            {
                *pszValue = '\0';
                pszValue++;
            }
            else
            {
                pszValue = pszLine;
            }

            //
            //  Put it into combobox (if no descriptive name, use path)
            //

            n = (int)SendMessage (hwndTemp, CB_ADDSTRING, 0, (LPARAM) (LPTSTR) pszValue);

            //
            //  Find the first selection that matches the "default" selection
            //

            if ((selection == -1)  && !lstrcmp (pszLine, szTemp2))
                selection = n;

            //
            //  Also attach pointer to KeyName (i.e. boot path) to each item
            //

            pszTemp = StrDup(pszLine);
            SendMessage (hwndTemp, CB_SETITEMDATA, n, (LPARAM)pszTemp); // if not allocated, set it to NULL
        }

        // If no selection was found up to this point, choose 0, because
        // that is the default value that loader would choose.

        if (selection == -1)
            selection = 0;

        SendDlgItemMessage (hDlg, IDC_STARTUP_SYS_SECONDS, EM_LIMITTEXT, 3, 0L);
        SendDlgItemMessage (hDlg, IDC_STARTUP_SYS_SECSCROLL,
                              UDM_SETRANGE, 0, (LPARAM)MAKELONG(999,0));


        //  Check or uncheck the checkbox based on the timeout value
        SendDlgItemMessage(
            hDlg,
            IDC_STARTUP_SYS_ENABLECOUNTDOWN,
            BM_SETCHECK,
            (WPARAM) (BOOL) timeout,
            (LPARAM) 0L
        );
        EnableWindow(
            GetDlgItem(hDlg, IDC_STARTUP_SYS_SECONDS), 
            (BOOL) timeout
        );
        EnableWindow(
            GetDlgItem(hDlg, IDC_STARTUP_SYS_SECSCROLL), 
            (BOOL) timeout
        );

        //  This call should force correct settings for the checkbox
        //  and "Showlist for xx seconds" controls
        nOriginalSelection = selection;

        SendMessage (hwndTemp, CB_SETCURSEL, selection, 0L);

ContinueSystemInit:

        LocalFree(pszSectionHead);
    }
#endif  // _X86_
}


//
//  IE. We need to handle CANCEL case.
//
int StartListExit(HWND hDlg, WPARAM wParam, LPARAM lParam ) {
    HWND hwndTemp;
    int  selection, timeout;
#ifdef _X86_
    DWORD dwFileAttr;
    BOOL bOK;
    TCHAR   szBuffer[BUFZ]; // we build this up and write it to boot.ini
    TCHAR*  pszSlidingPtr;  // we slide this along szBuffer

    TCHAR   szTemp[BUFZ];
    
    int     n;
    TCHAR  *pszTemp;
    int     iTemp;
#endif

    /////////////////////////////////////////////////////////////////
    //  Write new info to boot.ini file
    /////////////////////////////////////////////////////////////////

    hwndTemp = GetDlgItem (hDlg, IDC_STARTUP_SYS_OS);

    selection = (int)SendMessage (hwndTemp, CB_GETCURSEL, 0, 0L);

    if ((selection == CB_ERR) || (selection == CB_ERRSPACE))
        selection = nOriginalSelection;

    timeout   = GetDlgItemInt (hDlg, IDC_STARTUP_SYS_SECONDS, NULL, FALSE);

#if defined(EFI_NVRAM_ENABLED)
    if (IsEfi()) {
        if (fCanUpdateNVRAM) {

            TCHAR szTextNew[MAX_PATH];
            TCHAR szTextTop[MAX_PATH];

            WriteEfiBootEntries(hDlg, selection, timeout);

            /*
             * Now reorder list to match NVRAM
             */
            // Get the current text
            if (SafeGetComboBoxListText(hwndTemp, selection, szTextNew, ARRAYSIZE(szTextNew)) &&
                SafeGetComboBoxListText(hwndTemp, 0, szTextTop, ARRAYSIZE(szTextTop)))
            {
                // Set the new text to the 0th entry in the list
                SendMessage( hwndTemp, CB_DELETESTRING, 0, 0 );
                SendMessage( hwndTemp, CB_INSERTSTRING, 0, (LPARAM)szTextNew);
    
                // Set old top text selected item
                SendMessage( hwndTemp, CB_DELETESTRING, selection, 0 );
                SendMessage( hwndTemp, CB_INSERTSTRING, selection, (LPARAM)szTextTop);
    
                // Now point the current selection back to the top of the list, so it matches
                // what the user just chose
                SendMessage( hwndTemp, CB_SETCURSEL, 0, 0);
            }
        }

    } else
#endif // defined(EFI_NVRAM_ENABLED)

#ifdef _X86_
    if (Is_ARCx86())
#endif
    {
    if (fCanUpdateNVRAM) {
        TCHAR szTextNew[MAX_PATH];
        TCHAR szTextTop[MAX_PATH];

        UpdateNVRAM (hDlg, selection, timeout);

        /*
         * Now reorder list to match NVRAM
         */
        // Get the current text
        if (SafeGetComboBoxListText(hwndTemp, selection, szTextNew, ARRAYSIZE(szTextNew)) &&
            SafeGetComboBoxListText(hwndTemp, 0, szTextTop, ARRAYSIZE(szTextTop)))
        {
            // Set the new text to the 0th entry in the list
            SendMessage( hwndTemp, CB_DELETESTRING, 0, 0 );
            SendMessage( hwndTemp, CB_INSERTSTRING, 0, (LPARAM)szTextNew);

            // Set old top text selected item
            SendMessage( hwndTemp, CB_DELETESTRING, selection, 0 );
            SendMessage( hwndTemp, CB_INSERTSTRING, selection, (LPARAM)szTextTop);

            // Now point the current selection back to the top of the list, so it matches
            // what the user just chose
            SendMessage( hwndTemp, CB_SETCURSEL, 0, 0);
        }
    }
    }
#ifdef _X86_
    else
    {
    if ((selection != nOriginalSelection) || (timeout != nOriginalTimeout))
    {
        bOK = TRUE;

        //  Change Read-only file attrs on Boot.ini file if necessary
        if ((dwFileAttr = GetFileAttributes (szBootIni)) != 0xFFFFFFFF)
            if (dwFileAttr & FILE_ATTRIBUTE_READONLY)
                if (!SetFileAttributes (szBootIni,
                           dwFileAttr & ~FILE_ATTRIBUTE_READONLY))
                {
BootIniWriteError:
                    bOK = FALSE;
                    MsgBoxParam (hDlg, IDS_SYSDM_NOCHANGE_BOOTINI, IDS_SYSDM_TITLE, MB_OK | MB_ICONINFORMATION);
                }

        if (bOK)
        {
            //
            //  Write new [operating systems] section and
            //  set "default" selection in boot.ini file.
            //

            if (selection != nOriginalSelection)
            {
                pszSlidingPtr = szBuffer;

                //  Get the User's selection and write it in the
                //  section buffer first.  Then get all other items.
                pszTemp = (LPTSTR) SendMessage(hwndTemp, CB_GETITEMDATA, selection, 0L);

                if (SafeGetComboBoxListText(hwndTemp, selection, szTemp, ARRAYSIZE(szTemp)))
                {
                    if (FAILED(StringCchPrintf(pszSlidingPtr, 
                                               ARRAYSIZE(szBuffer) - (pszSlidingPtr - szBuffer), 
                                               TEXT("%s=%s"), 
                                               pszTemp, 
                                               szTemp)))
                    {
                        goto BootIniWriteError;
                    }
                    else
                    {
                        pszSlidingPtr += (lstrlen (pszSlidingPtr) + 1);

                        //  Set "default" selection in boot.ini file
                        if (!WritePrivateProfileString (pszBoot, szDefault, pszTemp, szBootIni))
                        {
                            goto BootIniWriteError;
                        }
                    }
                }

                //  Get the rest of the selections
                n = (int)SendMessage (hwndTemp, CB_GETCOUNT, 0, 0L);
                if (n != LB_ERR)
                {
                    for (iTemp = 0; iTemp < n; iTemp++)
                    {
                        //  Skip the User's selection since we got it
                        //  above.
                        if (iTemp == selection)
                            continue;

                        pszTemp = (LPTSTR) SendMessage (hwndTemp, CB_GETITEMDATA, iTemp, 0L);

                        if (SafeGetComboBoxListText(hwndTemp, iTemp, szTemp, ARRAYSIZE(szTemp)))
                        {
                            if (FAILED(StringCchPrintf(pszSlidingPtr, 
                                                       ARRAYSIZE(szBuffer) - (pszSlidingPtr - szBuffer), 
                                                       TEXT("%s=%s"), 
                                                       pszTemp, 
                                                       szTemp)))
                            {
                                goto BootIniWriteError;
                            }

                            pszSlidingPtr += (lstrlen (pszSlidingPtr) + 1);
                        }
                    }
                }

                //  Double-Null terminate the buffer
                *pszSlidingPtr = TEXT('\0');

                //  Write new section under OS
                if (!WritePrivateProfileSectionW(szOS, szBuffer, szBootIni))
                {
                    goto BootIniWriteError;
                }
            }

            if (timeout != nOriginalTimeout)
            {
                GetDlgItemText (hDlg, IDC_STARTUP_SYS_SECONDS, szTemp, ARRAYSIZE(szTemp));

                if (!CheckVal (hDlg, IDC_STARTUP_SYS_SECONDS, FORMIN, FORMAX, IDS_SYSDM_ENTERSECONDS))
                    return RET_BREAK;

                //  Write timeout value to file

                if (!WritePrivateProfileString (pszBoot, szTimeout,
                                               szTemp, szBootIni))
                    goto BootIniWriteError;
            }

            //  Restore read-only attr, if necessary, after writes
            if (dwFileAttr != 0xFFFFFFFF && (dwFileAttr & FILE_ATTRIBUTE_READONLY)) {
                    SetFileAttributes (szBootIni, dwFileAttr);
            }
        }
    }
    }
#endif // _X86_

    return RET_CONTINUE;

}


BOOL CheckVal( HWND hDlg, WORD wID, WORD wMin, WORD wMax, WORD wMsgID )
{
    WORD nVal;
    BOOL bOK;
    HWND hVal;
    WCHAR szTemp[FOR_MAX_LENGTH];

    if( wMin > wMax )
    {
        nVal = wMin;
        wMin = wMax;
        wMax = nVal;
    }

    nVal = (WORD) GetDlgItemInt( hDlg, wID, &bOK, FALSE );

    //
    // This is a hack to make the null string act equivalent to zero
    //
    if (!bOK) {
       bOK = !GetDlgItemTextW( hDlg, wID, szTemp, FOR_MAX_LENGTH );
    }

    if( !bOK || ( nVal < wMin ) || ( nVal > wMax ) )
    {
        MsgBoxParam( hDlg, wMsgID, IDS_SYSDM_TITLE,
                      MB_OK | MB_ICONERROR, wMin, wMax );

        SendMessage( hDlg, WM_NEXTDLGCTL,
                     (WPARAM) ( hVal = GetDlgItem( hDlg, wID ) ), 1L );

//        SendMessage(hVal, EM_SETSEL, NULL, MAKELONG(0, 32767));

        SendMessage( hVal, EM_SETSEL, 0, 32767 );

        return( FALSE );
    }

    return( TRUE );
}



//////////////////////////////////////////////////////
//
// Frees the data (if any) associated with the strings in the combo box
//
//////////////////////////////////////////////////////
void StartListDestroy(HWND hDlg, WPARAM wParam, LPARAM lParam) {

#if defined(EFI_NVRAM_ENABLED)
    if (IsEfi()) {
        FreeEfiBootEntries();
    } else
#endif // defined(EFI_NVRAM_ENABLED)

#ifdef _X86_
    if (Is_ARCx86())
#endif
    {
    // Reference vars to make compiler happy
    FreeRGSZEnvVar(&CPEBOSLoadIdentifier);
    return;

    (void)hDlg;
    (void)wParam;
    (void)lParam;
    }
#ifdef _X86_
    else
    {

    // Only X86 has data in the combo
    int     n;
    HWND    hwndTemp;
    int     iTemp;
    TCHAR   *pszTemp;


    //
    //  Free strings stored in the listbox
    //
    hwndTemp = GetDlgItem (hDlg, IDC_STARTUP_SYS_OS);

    n = (int)SendMessage (hwndTemp, CB_GETCOUNT, 0, 0L);

    if (n != LB_ERR)
    {
        for (iTemp = 0; iTemp < n; iTemp++)
        {
            pszTemp = (LPTSTR) SendMessage (hwndTemp,
                                            CB_GETITEMDATA,
                                            iTemp, 0L);

            if (pszTemp && 
                pszTemp != (LPTSTR) CB_ERR)
            {
                LocalFree (pszTemp);
            }
        }
    }
    }
#endif // _X86_
}

void AutoAdvancedBootInit( HWND hDlg, WPARAM wParam, LPARAM lParam ) {
    BOOL fEnabled = FALSE;
    UCHAR cTimeout = 0;

    NTSTATUS status;

#ifdef _X86_

    //
    // Initialize the boot status data.
    //

    status = RtlLockBootStatusData(&hBootStatusData);

    if(NT_SUCCESS(status)) {

        RtlGetSetBootStatusData(hBootStatusData,
                                TRUE,
                                RtlBsdItemAabEnabled,
                                &fEnabled,
                                sizeof(BOOL),
                                NULL);

        RtlGetSetBootStatusData(hBootStatusData,
                                TRUE,
                                RtlBsdItemAabTimeout,
                                &cTimeout,
                                sizeof(UCHAR),
                                NULL);

        SetDlgItemInt(hDlg, IDC_STARTUP_AUTOLKG_SECONDS, cTimeout, FALSE);
        CheckDlgButton(hDlg, IDC_STARTUP_AUTOLKG, fEnabled);
    
        SendDlgItemMessage(hDlg, IDC_STARTUP_AUTOLKG_SECONDS, EM_LIMITTEXT, 3, 0L);
        SendDlgItemMessage(hDlg, 
                           IDC_STARTUP_AUTOLKG_SECSCROLL,
                           UDM_SETRANGE, 
                           0, 
                           (LPARAM)MAKELONG(999,0));


        if(!fEnabled) {
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECONDS_LABEL), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECONDS), FALSE);
            EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECSCROLL), FALSE);
        }
    } else {
        EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECONDS_LABEL), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECONDS), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECSCROLL), FALSE);
    }
#else 

    ShowWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG), FALSE);
    ShowWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECONDS_LABEL), FALSE);
    ShowWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECONDS), FALSE);
    ShowWindow(GetDlgItem(hDlg, IDC_STARTUP_AUTOLKG_SECSCROLL), FALSE);

#endif

    return;
}

//
//  IE. We need to handle CANCEL case.
//
int AutoAdvancedBootExit(HWND hDlg, WPARAM wParam, LPARAM lParam ) {

    BOOL fEnabled;

    UINT iTime;
    UCHAR cTimeout;

    NTSTATUS status;

#if _X86_
    if(LOWORD(wParam) != IDCANCEL) {
    
        //
        // Read the setting of the enabled checkbox.
        //
    
        fEnabled = IsDlgButtonChecked(hDlg, IDC_STARTUP_AUTOLKG);
    
        if(fEnabled) {
            iTime = GetDlgItemInt(hDlg, IDC_STARTUP_AUTOLKG_SECONDS, NULL, FALSE);
            cTimeout = (UCHAR) min(iTime, 0xff);
        }
    
        //
        // If we got access in AutoAdvancedBootInit, write the boot status data and exit.
        //
    
        if (hBootStatusData)
        {
            RtlGetSetBootStatusData(hBootStatusData,
                                    FALSE,
                                    RtlBsdItemAabEnabled,
                                    &fEnabled,
                                    sizeof(BOOL),
                                    NULL);
    
            if(fEnabled) {
                RtlGetSetBootStatusData(hBootStatusData,
                                        FALSE,
                                        RtlBsdItemAabTimeout,
                                        &cTimeout,
                                        sizeof(UCHAR),
                                        NULL);
            }
        }
    }
    
    if (hBootStatusData)            
    {
        RtlUnlockBootStatusData(hBootStatusData);
        hBootStatusData = NULL;    
    }
#endif

    return RET_CONTINUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\syspart.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1998  Microsoft Corporation
All rights reserved

Module Name:

    syspart.h

Abstract:

    Declares the one lousy function that code outside of
    syspart.c needs to be able to see.

Author:

    Scott Hallock (scotthal) 28-Apr-1998

Revision History:

--*/

BOOL InitializeArcStuff();
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\syspart.c ===
/*++

Copyright (c) 1998 Microsoft Corporation

Module Name:

    syspart.c

Abstract:

    Routines to determine the system partition on x86 machines.

Author:

    Ted Miller (tedm) 30-June-1994

Revision History:

    24-Apr-1997 scotthal
        re-horked for system applet

--*/

#include "sysdm.h"
#include <ntdddisk.h>

BOOL g_fInitialized = FALSE;

//
// NT-specific routines we use from ntdll.dll
//
//NTSYSAPI
NTSTATUS
(NTAPI *NtOpenSymLinkRoutine)(
    OUT PHANDLE LinkHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

//NTSYSAPI
NTSTATUS
(NTAPI *NtQuerSymLinkRoutine)(
    IN HANDLE LinkHandle,
    IN OUT PUNICODE_STRING LinkTarget,
    OUT PULONG ReturnedLength OPTIONAL
    );

//NTSYSAPI
NTSTATUS
(NTAPI *NtQuerDirRoutine) (
    IN HANDLE DirectoryHandle,
    OUT PVOID Buffer,
    IN ULONG Length,
    IN BOOLEAN ReturnSingleEntry,
    IN BOOLEAN RestartScan,
    IN OUT PULONG Context,
    OUT PULONG ReturnLength OPTIONAL
    );

//NTSYSAPI
NTSTATUS
(NTAPI *NtOpenDirRoutine) (
    OUT PHANDLE DirectoryHandle,
    IN ACCESS_MASK DesiredAccess,
    IN POBJECT_ATTRIBUTES ObjectAttributes
    );

BOOL
MatchNTSymbolicPaths(
    PCTSTR lpDeviceName,
    PCTSTR lpSysPart,
    PCTSTR lpMatchName
    );


IsNEC98(
    VOID
    )
{
    static BOOL Checked = FALSE;
    static BOOL Is98;

    if(!Checked) {

        Is98 = ((GetKeyboardType(0) == 7) && ((GetKeyboardType(1) & 0xff00) == 0x0d00));

        Checked = TRUE;
    }

    return(Is98);
}

BOOL
GetPartitionInfo(
    IN  TCHAR                  Drive,
    OUT PPARTITION_INFORMATION PartitionInfo
    )

/*++

Routine Description:

    Fill in a PARTITION_INFORMATION structure with information about
    a particular drive.

Arguments:

    Drive - supplies drive letter whose partition info is desired.

    PartitionInfo - upon success, receives partition info for Drive.

Return Value:

    Boolean value indicating whether PartitionInfo has been filled in.

--*/
{
    TCHAR DriveName[8];
    HANDLE hDisk;
    BOOL fRet;
    DWORD DataSize;

    if (FAILED(PathBuildFancyRoot(DriveName, ARRAYSIZE(DriveName), Drive)))
    {
        fRet = FALSE;
    }
    else
    {
        hDisk = CreateFile(
                    DriveName,
                    GENERIC_READ,
                    FILE_SHARE_READ | FILE_SHARE_WRITE,
                    NULL,
                    OPEN_EXISTING,
                    0,
                    NULL
                    );

        if(hDisk == INVALID_HANDLE_VALUE) 
        {
            fRet = FALSE;
        }
        else
        {
            fRet = DeviceIoControl(
                    hDisk,
                    IOCTL_DISK_GET_PARTITION_INFO,
                    NULL,
                    0,
                    PartitionInfo,
                    sizeof(PARTITION_INFORMATION),
                    &DataSize,
                    NULL
                    );

            CloseHandle(hDisk);
        }
    }

    return fRet;
}

BOOL
ArcPathToNtPath(
    IN  LPCTSTR arcPathParam,
    OUT LPTSTR  NtPath,
    IN  UINT    NtPathBufferLen
    )
{
    BOOL fRet = FALSE;
    WCHAR arcPath[256];
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Obja;
    HANDLE ObjectHandle;
    NTSTATUS Status;
    WCHAR Buffer[512];

    PWSTR ntPath;

    if (SUCCEEDED(StringCchCopy(arcPath, ARRAYSIZE(arcPath), L"\\ArcName\\")) &&
        SUCCEEDED(StringCchCat(arcPath, ARRAYSIZE(arcPath), arcPathParam)))
    {
        UnicodeString.Buffer = arcPath;
        UnicodeString.Length = (USHORT)lstrlenW(arcPath)*sizeof(WCHAR);
        UnicodeString.MaximumLength = UnicodeString.Length + sizeof(WCHAR);

        InitializeObjectAttributes(
            &Obja,
            &UnicodeString,
            OBJ_CASE_INSENSITIVE,
            NULL,
            NULL
            );

        Status = (*NtOpenSymLinkRoutine)(
                    &ObjectHandle,
                    READ_CONTROL | SYMBOLIC_LINK_QUERY,
                    &Obja
                    );

        if(NT_SUCCESS(Status)) 
        {
            //
            // Query the object to get the link target.
            //
            UnicodeString.Buffer = Buffer;
            UnicodeString.Length = 0;
            UnicodeString.MaximumLength = sizeof(Buffer)-sizeof(WCHAR);

            Status = (*NtQuerSymLinkRoutine)(ObjectHandle,&UnicodeString,NULL);

            CloseHandle(ObjectHandle);

            if(NT_SUCCESS(Status)) 
            {
                Buffer[UnicodeString.Length/sizeof(WCHAR)] = 0;

                if (SUCCEEDED(StringCchCopy(NtPath, NtPathBufferLen, Buffer)))
                {
                    fRet = TRUE;
                }
            }
        }
    }

    return fRet;
}


BOOL
AppearsToBeSysPart(
    IN PDRIVE_LAYOUT_INFORMATION DriveLayout,
    IN TCHAR                     Drive
    )
{
    PARTITION_INFORMATION PartitionInfo,*p;
    BOOL IsPrimary;
    UINT i;
    DWORD d;

    LPTSTR BootFiles[] = { TEXT("BOOT.INI"),
                           TEXT("NTLDR"),
                           TEXT("NTDETECT.COM"),
                           NULL
                         };

    TCHAR FileName[MAX_PATH];

    Drive = (TCHAR)tolower(Drive);
    ASSERT(Drive >= 'a' || Drive <= 'z');

    //
    // Get partition information for this partition.
    //
    if(!GetPartitionInfo(Drive,&PartitionInfo)) {
        return(FALSE);
    }

    //
    // See if the drive is a primary partition.
    //
    IsPrimary = FALSE;
    for(i=0; i<min(DriveLayout->PartitionCount,4); i++) {

        p = &DriveLayout->PartitionEntry[i];

        if((p->PartitionType != PARTITION_ENTRY_UNUSED)
        && (p->StartingOffset.QuadPart == PartitionInfo.StartingOffset.QuadPart)
        && (p->PartitionLength.QuadPart == PartitionInfo.PartitionLength.QuadPart)) {

            IsPrimary = TRUE;
            break;
        }
    }

    if(!IsPrimary) {
        return(FALSE);
    }

    //
    // Don't rely on the active partition flag.  This could easily not be accurate
    // (like user is using os/2 boot manager, for example).
    //

    //
    // See whether all NT boot files are present on this drive.
    //
    for(i=0; BootFiles[i]; i++) 
    {
        PathBuildRoot(FileName, Drive-'a');
        if (!PathAppend(FileName, BootFiles[i]) ||
            !PathFileExists(FileName))
        {
            return(FALSE);
        }
    }

    return(TRUE);
}


DWORD
QueryHardDiskNumber(
    IN  TCHAR   DriveLetter
    )

{
    DWORD                   dwRet = -1;
    TCHAR                   driveName[10];
    HANDLE                  h;
    BOOL                    b;
    STORAGE_DEVICE_NUMBER   number;
    DWORD                   bytes;

    if (SUCCEEDED(PathBuildFancyRoot(driveName, ARRAYSIZE(driveName), tolower(DriveLetter) - 'a')))
    {
        
        h = CreateFile(driveName, GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL,
                       INVALID_HANDLE_VALUE);
        if (INVALID_HANDLE_VALUE != h) 
        {            
            if (DeviceIoControl(h, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0,
                                &number, sizeof(number), &bytes, NULL))
            {
                dwRet = number.DeviceNumber;
            }
            CloseHandle(h);
        }
    }

    return dwRet;
}

TCHAR
x86DetermineSystemPartition(
    IN  HWND   ParentWindow
    )

/*++

Routine Description:

    Determine the system partition on x86 machines.

    On Win95, we always return C:. For NT, read on.

    The system partition is the primary partition on the boot disk.
    Usually this is the active partition on disk 0 and usually it's C:.
    However the user could have remapped drive letters and generally
    determining the system partition with 100% accuracy is not possible.

    The one thing we can be sure of is that the system partition is on
    the physical hard disk with the arc path multi(0)disk(0)rdisk(0).
    We can be sure of this because by definition this is the arc path
    for bios drive 0x80.

    This routine determines which drive letters represent drives on
    that physical hard drive, and checks each for the nt boot files.
    The first drive found with those files is assumed to be the system
    partition.

    If for some reason we cannot determine the system partition by the above
    method, we simply assume it's C:.

Arguments:

    ParentWindow - supplies window handle for window to be the parent for
        any dialogs, etc.

    SysPartDrive - if successful, receives drive letter of system partition.

Return Value:

    Boolean value indicating whether SysPartDrive has been filled in.
    If FALSE, the user will have been infomred about why.

--*/

{
    
    BOOL  GotIt;
    TCHAR NtDevicePath[256];
    DWORD NtDevicePathLen;
    LPTSTR p;
    DWORD PhysicalDriveNumber;
    TCHAR Buffer[512];
    TCHAR FoundSystemPartition[20], temp[5];
    HANDLE hDisk;
    PDRIVE_LAYOUT_INFORMATION DriveLayout;
    DWORD DriveLayoutSize;
    TCHAR Drive;
    BOOL b;
    DWORD DataSize;
    DWORD BootPartitionNumber, cnt;
    PPARTITION_INFORMATION Start, i;

    if (!g_fInitialized) {
        GotIt = FALSE;
        goto c0;
    }

    if(IsNEC98())
    {
        *Buffer = TEXT('c');  // initialize to C in case GetWindowDirectory fails.
        if (!GetWindowsDirectory(Buffer, ARRAYSIZE(Buffer)))
        {
            *Buffer = TEXT('c');  // initialize to C in case GetWindowDirectory fails.
        }

        return Buffer[0];
    }

    //
    // The system partition must be on multi(0)disk(0)rdisk(0)
    // If we can't translate that ARC path then something is really wrong.
    // We assume C: because we don't know what else to do.
    //
    b = ArcPathToNtPath(
            TEXT("multi(0)disk(0)rdisk(0)"),
            NtDevicePath,
            sizeof(NtDevicePath)/sizeof(TCHAR)
            );

    if(!b) {

        //
        // Missed.  Try scsi(0) in case the user is using ntbootdd.sys
        //
        b = ArcPathToNtPath(
                TEXT("scsi(0)disk(0)rdisk(0)"),
                NtDevicePath,
                sizeof(NtDevicePath)/sizeof(TCHAR)
                );
        if(!b) {
            GotIt = FALSE;
            goto c0;
        }
    }

    //
    // The arc path for a disk device is usually linked
    // to partition0. Get rid of the partition part of the name.
    //
    CharLower(NtDevicePath);
    if(p = StrStr(NtDevicePath,TEXT("\\partition"))) {
        *p = 0;
    }

    NtDevicePathLen = lstrlen(NtDevicePath);

    //
    // Determine the physical drive number of this drive.
    // If the name is not of the form \device\harddiskx then
    // something is very wrong. Just assume we don't understand
    // this device type, and return C:.
    //
    if(memcmp(NtDevicePath,TEXT("\\device\\harddisk"),16*sizeof(TCHAR))) {
        Drive = TEXT('C');
        GotIt = TRUE;
        goto c0;
    }

    PhysicalDriveNumber = StrToInt(NtDevicePath+16);
    if (FAILED(StringCchPrintf(Buffer,
                               ARRAYSIZE(Buffer),
                               TEXT("\\\\.\\PhysicalDrive%u"),
                               PhysicalDriveNumber)))
    {
        GotIt = FALSE;
        goto c0;
    }

    //
    // Get drive layout info for this physical disk.
    // If we can't do this something is very wrong.
    //
    hDisk = CreateFile(Buffer,
                       GENERIC_READ,
                       FILE_SHARE_READ | FILE_SHARE_WRITE,
                       NULL,
                       OPEN_EXISTING,
                       0,
                       NULL);

    if(hDisk == INVALID_HANDLE_VALUE) {
        GotIt = FALSE;
        goto c0;
    }

    //
    // Get partition information.
    //
    DriveLayoutSize = 1024;
    DriveLayout = LocalAlloc(LPTR, DriveLayoutSize);
    if(!DriveLayout) {
        GotIt = FALSE;
        goto c1;
    }

    if (FAILED(StringCchCopy(FoundSystemPartition, ARRAYSIZE(FoundSystemPartition), TEXT("Partition"))))
    {
        GotIt = FALSE;
        goto c2;
    }

retry:

    b = DeviceIoControl(
            hDisk,
            IOCTL_DISK_GET_DRIVE_LAYOUT,
            NULL,
            0,
            (PVOID)DriveLayout,
            DriveLayoutSize,
            &DataSize,
            NULL
            );

    if(!b) {

        if(GetLastError() == ERROR_INSUFFICIENT_BUFFER) {

            DriveLayoutSize += 1024;
            if(p = LocalReAlloc((HLOCAL)DriveLayout,DriveLayoutSize, 0L)) {
                (PVOID)DriveLayout = p;
            } else {
                GotIt = FALSE;
                goto c2;
            }
            goto retry;
        } else {
            GotIt = FALSE;
            goto c2;
        }
    }else{
        // Now walk the Drive_Layout to find the boot partition
        
        Start = DriveLayout->PartitionEntry;
        cnt = 0;

        for( i = Start; cnt < DriveLayout->PartitionCount; i++ ){
            cnt++;
            if( i->BootIndicator == TRUE ){
                BootPartitionNumber = i->PartitionNumber;
                if (FAILED(StringCchPrintf(temp, ARRAYSIZE(temp), TEXT("%d"), BootPartitionNumber)) ||
                    FAILED(StringCchCat(FoundSystemPartition, ARRAYSIZE(FoundSystemPartition), temp)))
                {
                    GotIt = FALSE;
                    goto c2;
                }


                break;
            }
        }

    }

    //
    // The system partition can only be a drive that is on
    // this disk.  We make this determination by looking at NT drive names
    // for each drive letter and seeing if the NT equivalent of
    // multi(0)disk(0)rdisk(0) is a prefix.
    //
    GotIt = FALSE;
    for(Drive=TEXT('a'); Drive<=TEXT('z'); Drive++) 
    {

        TCHAR DriveName[4];
        PathBuildRoot(DriveName, Drive - 'a');
        if(VMGetDriveType(DriveName) == DRIVE_FIXED) 
        {
            if(QueryDosDevice(DriveName,Buffer,sizeof(Buffer)/sizeof(TCHAR))) {

                if( MatchNTSymbolicPaths(NtDevicePath,FoundSystemPartition,Buffer)) {
                    //
                    // Now look to see whether there's an nt boot sector and
                    // boot files on this drive.
                    //
                    if(AppearsToBeSysPart(DriveLayout,Drive)) {
                        GotIt = TRUE;
                        break;
                    }
                }
            }
        }
    }

    if(!GotIt) {
        //
        // Strange case, just assume C:
        //
        GotIt = TRUE;
        Drive = TEXT('C');
    }

c2:
    LocalFree(DriveLayout);
    
c1:
    CloseHandle(hDisk);
c0:
    if(GotIt) {
        return(Drive);
    }
    else {
        return(TEXT('C'));
    }
}

BOOL
InitializeArcStuff(
    )
{
    HMODULE NtdllLib;

    //
    // On NT ntdll.dll had better be already loaded.
    //
    NtdllLib = LoadLibrary(TEXT("NTDLL"));
    if(!NtdllLib) {

        return(FALSE);

    }

    (FARPROC)NtOpenSymLinkRoutine = GetProcAddress(NtdllLib,"NtOpenSymbolicLinkObject");
    (FARPROC)NtQuerSymLinkRoutine = GetProcAddress(NtdllLib,"NtQuerySymbolicLinkObject");
    (FARPROC)NtOpenDirRoutine = GetProcAddress(NtdllLib,"NtOpenDirectoryObject");
    (FARPROC)NtQuerDirRoutine = GetProcAddress(NtdllLib,"NtQueryDirectoryObject");


    if(!NtOpenSymLinkRoutine || !NtQuerSymLinkRoutine || !NtOpenDirRoutine || !NtQuerDirRoutine) {

        FreeLibrary(NtdllLib);

        return(FALSE);
    }

    //
    // We don't need the extraneous handle any more.
    //
    FreeLibrary(NtdllLib);

    return(g_fInitialized = TRUE);
}


BOOL
MatchNTSymbolicPaths(
    PCTSTR lpDeviceName,
    PCTSTR lpSysPart,
    PCTSTR lpMatchName
    )
/*
    
    Introduced this routine to mend the old way of finding if we determined the right system partition.
   
   Arguments:
    lpDeviceName    -  This should be the symbolic link (\Device\HarddiskX) name for the arcpath 
                       multi/scsi(0)disk(0)rdisk(0) which is the arcpath for bios drive 0x80.  
                       Remember that we strip the PartitionX part to get just \Device\HarddiskX.
                       
    lpSysPart       -  When we traverse the lpDeviceName directory we compare the symbolic link corresponding to
                       lpSysPart and see if it matches lpMatchName
                       
    lpMatchName     -  This is the symbolic name that a drive letter translates to (got by calling 
                       QueryDosDevice() ). 
                       
   So it boils down to us trying to match a drive letter to the system partition on bios drive 0x80.


*/
{
    NTSTATUS Status;
    UNICODE_STRING UnicodeString;
    OBJECT_ATTRIBUTES Attributes;
    HANDLE DirectoryHandle, SymLinkHandle;
    POBJECT_DIRECTORY_INFORMATION DirInfo;
    BOOLEAN RestartScan, ret;
    UCHAR DirInfoBuffer[ 512 ];
    WCHAR Buffer[1024];
    WCHAR pDevice[512], pMatch[512], pSysPart[20];
    ULONG Context = 0;
    ULONG ReturnedLength;
    

    if (FAILED(StringCchCopy(pDevice,ARRAYSIZE(pDevice),lpDeviceName)) ||
        FAILED(StringCchCopy(pMatch,ARRAYSIZE(pMatch),lpMatchName)) ||
        FAILED(StringCchCopy(pSysPart,ARRAYSIZE(pSysPart),lpSysPart)))
    {
        return FALSE;
    }


    UnicodeString.Buffer = pDevice;
    UnicodeString.Length = (USHORT)lstrlenW(pDevice)*sizeof(WCHAR);
    UnicodeString.MaximumLength = UnicodeString.Length + sizeof(WCHAR);

    InitializeObjectAttributes( &Attributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                NULL,
                                NULL
                              );
    Status = (*NtOpenDirRoutine)( &DirectoryHandle,
                                    DIRECTORY_QUERY,
                                    &Attributes
                                  );
    if (!NT_SUCCESS( Status ))
        return(FALSE);
        

    RestartScan = TRUE;
    DirInfo = (POBJECT_DIRECTORY_INFORMATION)DirInfoBuffer;
    ret = FALSE;
    while (TRUE) {
        Status = (*NtQuerDirRoutine)( DirectoryHandle,
                                         (PVOID)DirInfo,
                                         sizeof( DirInfoBuffer ),
                                         TRUE,
                                         RestartScan,
                                         &Context,
                                         &ReturnedLength
                                       );

        //
        //  Check the status of the operation.
        //

        if (!NT_SUCCESS( Status )) {
            if (Status == STATUS_NO_MORE_ENTRIES) {
                Status = STATUS_SUCCESS;
                }

            break;
            }

        if (!wcsncmp( DirInfo->TypeName.Buffer, L"SymbolicLink", DirInfo->TypeName.Length ) && 
            !_wcsnicmp( DirInfo->Name.Buffer, pSysPart, DirInfo->Name.Length ) ) {


            UnicodeString.Buffer = DirInfo->Name.Buffer;
            UnicodeString.Length = (USHORT)lstrlenW(DirInfo->Name.Buffer)*sizeof(WCHAR);
            UnicodeString.MaximumLength = UnicodeString.Length + sizeof(WCHAR);
            InitializeObjectAttributes( &Attributes,
                                &UnicodeString,
                                OBJ_CASE_INSENSITIVE,
                                DirectoryHandle,
                                NULL
                              );


            Status = (*NtOpenSymLinkRoutine)(
                &SymLinkHandle,
                READ_CONTROL | SYMBOLIC_LINK_QUERY,
                &Attributes
                );

            if(NT_SUCCESS(Status)) {
                //
                // Query the object to get the link target.
                //
                UnicodeString.Buffer = Buffer;
                UnicodeString.Length = 0;
                UnicodeString.MaximumLength = sizeof(Buffer)-sizeof(WCHAR);
        
                Status = (*NtQuerSymLinkRoutine)(SymLinkHandle,&UnicodeString,NULL);
        
                CloseHandle(SymLinkHandle);
                
                if( NT_SUCCESS(Status)){
            
                    if (!_wcsnicmp(UnicodeString.Buffer, pMatch, (UnicodeString.Length/sizeof(WCHAR)))) {
                        ret = TRUE;
                        break;
                    }
                }
            
            }

        }

        RestartScan = FALSE;
    }
    CloseHandle( DirectoryHandle );

    return( ret );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\visualfx.h ===
INT_PTR WINAPI VisualEffectsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\virtual.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    virtual.h

Abstract:

    Public declarations for the Change Virtual Memory dialog of the System
    Control Panel Applet

Notes:

    The virtual memory settings and the crash dump (core dump) settings
    are tightly-coupled.  Therefore, virtual.c and virtual.h have some
    heavy dependencies on crashdmp.c and startup.h (and vice versa).

Author:

    Byron Dazey 06-Jun-1992

Revision History:

    15-Oct-1997 scotthal
        Split public declarations into separate header

--*/
#ifndef _SYSDM_VIRTUAL_H_
#define _SYSDM_VIRTUAL_H_

//
// Some debugging macros shared by the virtual mem and crash dump stuff
//
#ifdef VM_DBG
#   pragma message(__FILE__"(19): warning !!!! : compiled for DEBUG ONLY!" )
#   define  DPRINTF(p)  DBGPRINTF(p)
#   define  DOUT(S)     DBGOUT(S)
#else
#   define  DPRINTF(p)
#   define  DOUT(S)
#endif

//
// Constants
//
#define MAX_DRIVES          26      // Max number of drives.

//
// Type Definitions
//
typedef struct
{
    BOOL fCanHavePagefile;      // TRUE if the drive can have a pagefile.
    BOOL fCreateFile;           // TRUE if user hits [SET] and no pagefile
    DWORD nMinFileSize;         // Minimum size of pagefile in MB.
    DWORD nMaxFileSize;         // Max size of pagefile in MB.
    DWORD nMinFileSizePrev;     // Previous minimum size of pagefile in MB.
    DWORD nMaxFileSizePrev;     // Previous max size of pagefile in MB.
    LPTSTR  pszPageFile;        // Path to page file if it exists on that drv
    BOOL fRamBasedPagefile;     // TRUE if the pagefile size should always match RAM
    BOOL fRamBasedPrev;     // TRUE if the pagefile size should always match RAM
} PAGING_FILE; //  Swap file structure

//
// Global Variables
//
extern HKEY ghkeyMemMgt;
extern PAGING_FILE apf[MAX_DRIVES];
extern PAGING_FILE apfOriginal[MAX_DRIVES];

//
// Public function prototypes
//
INT_PTR
APIENTRY
VirtualMemDlg(
    IN HWND hDlg,
    IN UINT message,
    IN WPARAM wParam,
    IN LPARAM lParam
);

BOOL
VirtualInitStructures(
    void
);

void
VirtualFreeStructures(
    void
);

INT
VirtualMemComputeAllocated(
    IN HWND hWnd,
    OUT BOOL *pfTempPf
);

VCREG_RET 
VirtualOpenKey( 
    void 
);

void 
VirtualCloseKey(
    void
);

BOOL 
VirtualGetPageFiles(
    OUT PAGING_FILE *apf
);

void 
VirtualFreePageFiles(
    IN PAGING_FILE *apf
);

BOOL 
VirtualMemUpdateRegistry(
    VOID
);

int 
VirtualMemPromptForReboot(
    IN HWND hDlg
);

DWORD
GetFreeSpaceMB(
    IN INT iDrive
);

VOID 
SetDlgItemMB(
    IN HWND hDlg, 
    IN INT idControl, 
    IN DWORD dwMBValue
);

#endif // _SYSDM_VIRTUAL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\visualfx.cpp ===
#include "sysdm.h"
#include <windowsx.h>
#include "shlapip.h"
#include "regstr.h"
#include "ccstock.h"
#include "shguidp.h"
#include "ieguidp.h"
#include "help.h"

#define REGSTRA_EXPLORER_VISUALFX  "Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\VisualEffects"
#define REGSTRA_VISUALFX_SETTING   "VisualFXSetting"

#define VISUALFX_SETTING_AUTO    0x0
#define VISUALFX_SETTING_LOOKS   0x1
#define VISUALFX_SETTING_PERF    0x2
#define VISUALFX_SETTING_CUSTOM  0x3

DWORD aVisualFXHelpIds[] =
{
    IDC_VFX_TITLE,               NO_HELP,
    IDC_VFX_TREE,                NO_HELP,
    IDC_VFX_BESTLOOKS,           (IDH_PERF + 10),
    IDC_VFX_BESTPERF,            (IDH_PERF + 11),
    IDC_VFX_AUTO,                (IDH_PERF + 12),
    IDC_VFX_CUSTOM,              (IDH_PERF + 19),
    0, 0
};

class CVisualEffectsDlg
{
public:
    INT_PTR DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT Init();

    CVisualEffectsDlg();
    virtual ~CVisualEffectsDlg();

private:
    void _EnableApply();
    void _SetItemCheckState(HTREEITEM hti, BOOL fCheck);
    void _OnCommand(WORD wID);
    void _OnInitDialog(HWND hDlg);
    void _OnNotify(LPNMHDR pnm);

    WORD  _wMode;
    HWND  _hwndTree;
    HWND  _hDlg;
    IRegTreeOptions *_prto;
    BOOL  _fDirtyTree;
    BOOL  _fTreeInit;
};

CVisualEffectsDlg::CVisualEffectsDlg() : _hwndTree(NULL), _hDlg(NULL), _prto(NULL), _fDirtyTree(FALSE), _fTreeInit(FALSE), _wMode(VISUALFX_SETTING_AUTO)
{
}

CVisualEffectsDlg::~CVisualEffectsDlg()
{
    ATOMICRELEASE(_prto);
}

HRESULT CVisualEffectsDlg::Init()
{
    return CoCreateInstance(CLSID_CRegTreeOptions, NULL, CLSCTX_INPROC_SERVER, 
                                IID_PPV_ARG(IRegTreeOptions, &_prto));
}

void CVisualEffectsDlg::_EnableApply()
{
    if( !_fTreeInit )
    {
        // Enable the "Apply" button because changes have happened.
        _fDirtyTree = TRUE;
        SendMessage(GetParent(_hDlg), PSM_CHANGED, (WPARAM)_hDlg, 0L);
    }
}

void CVisualEffectsDlg::_SetItemCheckState(HTREEITEM hti, BOOL fCheck)
{
    TVITEM tvi;
    tvi.hItem = hti;
    tvi.mask = TVIF_HANDLE | TVIF_IMAGE | TVIF_SELECTEDIMAGE;
    
    if (TreeView_GetItem(_hwndTree, &tvi))
    {
        tvi.iImage = fCheck ? IDCHECKED : IDUNCHECKED;
        tvi.iSelectedImage = tvi.iImage;

        TreeView_SetItem(_hwndTree, &tvi);
    }
}

void CVisualEffectsDlg::_OnCommand(WORD wID)
{
    if (wID != _wMode)
    {
        _wMode = wID;
        switch (wID)
        {
        case IDC_VFX_BESTLOOKS:
        case IDC_VFX_BESTPERF:
            {
                BOOL fCheck = (wID == IDC_VFX_BESTLOOKS);
                for (HTREEITEM hti = TreeView_GetRoot(_hwndTree); hti != NULL; 
                        hti = TreeView_GetNextItem(_hwndTree, hti, TVGN_NEXT))
                {
                    _SetItemCheckState(hti, fCheck);
                }
            }
            _EnableApply();
            break;

        case IDC_VFX_AUTO:
            _prto->WalkTree(WALK_TREE_RESTORE);
            _EnableApply();
            break;
        case IDC_VFX_CUSTOM:
            break;
        }
    }
}

void CVisualEffectsDlg::_OnInitDialog(HWND hDlg)
{
    _hDlg = hDlg;
    _hwndTree = GetDlgItem(hDlg, IDC_VFX_TREE);

    DWORD cbData, dwData;
    cbData = sizeof(dwData);
    if (ERROR_SUCCESS != SHRegGetUSValue(TEXT(REGSTRA_EXPLORER_VISUALFX), TEXT(REGSTRA_VISUALFX_SETTING), NULL, &dwData, &cbData, FALSE, NULL, 0))
    {
        dwData = VISUALFX_SETTING_AUTO;
    }

    _fTreeInit = TRUE;
    _prto->InitTree(_hwndTree, HKEY_LOCAL_MACHINE, REGSTRA_EXPLORER_VISUALFX, NULL);
    SendMessage(GetDlgItem(_hDlg, IDC_VFX_AUTO + dwData), BM_CLICK, 0, 0);
    _fTreeInit = FALSE;
}

void CVisualEffectsDlg::_OnNotify(LPNMHDR pnm)
{
    switch (pnm->code)
    {
    case NM_CLICK:
    case NM_DBLCLK:
        if (pnm->idFrom == IDC_VFX_TREE)
        {
            TV_HITTESTINFO ht;

            DWORD dwPos = GetMessagePos();                  // get where we were hit
            ht.pt.x = GET_X_LPARAM(dwPos);
            ht.pt.y = GET_Y_LPARAM(dwPos);
            ScreenToClient(_hwndTree, &ht.pt);       // translate it to our window

            // retrieve the item hit
            HTREEITEM hti = TreeView_HitTest(_hwndTree, &ht);
            if (hti)
            {
                if (VISUALFX_SETTING_CUSTOM != _wMode)
                {
                    CheckRadioButton(_hDlg, IDC_VFX_AUTO, IDC_VFX_CUSTOM, IDC_VFX_CUSTOM);
                }
                _prto->ToggleItem(hti);
                _EnableApply();
            }
        }
        break;

    case TVN_KEYDOWN:
        if (((LPNMTVKEYDOWN)pnm)->wVKey == VK_SPACE)
        {
            if (VISUALFX_SETTING_CUSTOM != _wMode)
            {
                CheckRadioButton(_hDlg, IDC_VFX_AUTO, IDC_VFX_CUSTOM, IDC_VFX_CUSTOM);
            }
            _prto->ToggleItem((HTREEITEM)SendMessage(_hwndTree, TVM_GETNEXTITEM, (WPARAM)TVGN_CARET, 0L));
            _EnableApply();
        }
        break;

    case PSN_APPLY:
        if (_fDirtyTree)
        {
            _prto->WalkTree(WALK_TREE_SAVE);
            for (int i = IDC_VFX_AUTO; i <= IDC_VFX_CUSTOM; i++)
            {
                if (BST_CHECKED == SendMessage(GetDlgItem(_hDlg, i), BM_GETCHECK, 0, 0))
                {
                    DWORD dwData = VISUALFX_SETTING_AUTO + (i - IDC_VFX_AUTO);
                    SHRegSetUSValue(TEXT(REGSTRA_EXPLORER_VISUALFX), TEXT(REGSTRA_VISUALFX_SETTING), REG_DWORD, &dwData, sizeof(dwData), SHREGSET_FORCE_HKCU);
                    break;
                }
            }
            DWORD_PTR dwResult = 0;
            SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE, NULL, (LPARAM)TEXT("VisualEffects"),
                               SMTO_NOTIMEOUTIFNOTHUNG, 1000, &dwResult);
            _fDirtyTree = FALSE;
        }
        break;
    }
}

INT_PTR CVisualEffectsDlg::DlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_INITDIALOG:
        _OnInitDialog(hDlg);
        break;

    case WM_NOTIFY:
        _OnNotify(((LPNMHDR)lParam));
        break;

    case WM_COMMAND:
        _OnCommand(GET_WM_COMMAND_ID(wParam, lParam));
        break;

    case WM_DESTROY:
        _prto->WalkTree(WALK_TREE_DELETE);
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
                (DWORD_PTR) (LPSTR) aVisualFXHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
                (DWORD_PTR) (LPSTR) aVisualFXHelpIds);
        break;
    default:
        return FALSE;
    }

    return TRUE;
}

INT_PTR WINAPI VisualEffectsDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    INT_PTR fRet = FALSE;
    CVisualEffectsDlg* pve;

    if (uMsg == WM_INITDIALOG)
    {
        pve = new CVisualEffectsDlg();
        if (pve && FAILED(pve->Init()))
        {
            delete pve;
            pve = NULL;
        }
        SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)pve);
    }
    else
    {
        pve = (CVisualEffectsDlg*)GetWindowLongPtr(hDlg, DWLP_USER);
    }

    if (pve)
    {
        fRet = pve->DlgProc(hDlg, uMsg, wParam, lParam);
        if (uMsg == WM_DESTROY)
        {
            delete pve;
            SetWindowLongPtr(hDlg, DWLP_USER, NULL);
        }
    }

    return fRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\util.h ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    util.h

Abstract:

    Utility functions for System Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#ifndef _SYSDM_UTIL_H_
#define _SYSDM_UTIL_H_

//
// Type definitions
//
typedef enum {
    VCREG_OK,
    VCREG_READONLY,
    VCREG_ERROR,
} VCREG_RET;  // Error return codes from opening registry

//
// Public function prototypes
//
void 
ErrMemDlg( 
    IN HWND hParent 
);

LPTSTR 
SkipWhiteSpace( 
    IN LPTSTR sz 
);

int
StringToInt( 
    IN LPTSTR sz 
);

BOOL 
Delnode(
    IN LPTSTR lpDir
);

LONG 
MyRegSaveKey(
    IN HKEY hKey, 
    LPCTSTR lpSubKey
);

LONG 
MyRegLoadKey(
    IN HKEY hKey, 
    IN LPTSTR lpSubKey, 
    IN LPTSTR lpFile
);

LONG 
MyRegUnLoadKey(
    IN HKEY hKey, 
    IN LPTSTR lpSubKey
);

int 
GetSelectedItem(
    IN HWND hCtrl
);

DWORD
GetMaxPagefileSizeInMB(
    INT iDrive
);
                   
int 
MsgBoxParam( 
    IN HWND hWnd, 
    IN DWORD wText, 
    IN DWORD wCaption, 
    IN DWORD wType, 
    ... 
);

DWORD 
SetLBWidthEx(
    IN HWND hwndLB, 
    IN LPTSTR szBuffer, 
    IN DWORD cxCurWidth, 
    IN DWORD cxExtra
);

void
HourGlass(
    IN BOOL bOn
);

VOID
SetDefButton(
    IN HWND hwndDlg,
    IN int idButton
);

VCREG_RET 
OpenRegKey( 
    IN LPTSTR szKeyName, 
    OUT PHKEY phkMM 
);

LONG CloseRegKey( 
    IN HKEY hkey 
);

UINT 
VMGetDriveType(
    IN LPCTSTR lpszDrive
);

STDAPI
PathBuildFancyRoot(
    LPTSTR szRoot,
    UINT cchRoot,
    int iDrive);

BOOL
SafeGetListBoxText(
    HWND hList,
    UINT ulIndex,
    LPTSTR pszBuffer,
    UINT cchBuffer);

BOOL
SafeGetComboBoxListText(
    HWND hCombo,
    UINT ulIndex,
    LPTSTR pszBuffer,
    UINT cchBuffer);

#endif _SYSDM_UTIL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\virtual.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    virtual.c

Abstract:

    Implements the Change Virtual Memory dialog of the System
    Control Panel Applet

Notes:

    The virtual memory settings and the crash dump (core dump) settings
    are tightly-coupled.  Therefore, virtual.c and virtual.h have some
    heavy dependencies on crashdmp.c and startup.h (and vice versa).

Author:

    Byron Dazey 06-Jun-1992

Revision History:

    14-Apr-93 JonPa 
        maintain paging path if != \pagefile.sys

    15-Dec-93 JonPa 
        added Crash Recovery dialog

    02-Feb-1994 JonPa 
        integrated crash recover and virtual memory settings

    18-Sep-1995 Steve Cathcart 
        split system.cpl out from NT3.51 main.cpl

    12-Jan-1996 JonPa 
        made part of the new SUR pagified system.cpl

    15-Oct-1997 scotthal
        Split out CoreDump*() stuff into separate file
        
    09-Jul-2000 SilviuC
        Allow very big page files if architecture supports it.
        Allow booting without a page file.
        Allow the system to scale the page file size based on RAM changes.   

--*/
//==========================================================================
//                              Include files
//==========================================================================
// NT base apis
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <ntdddisk.h>
#include <help.h>

// Application specific
#include "sysdm.h"


//==========================================================================
//                     External Data Declarations
//==========================================================================
extern HFONT   hfontBold;

//==========================================================================
//                            Local Definitions
//==========================================================================

#define MAX_SIZE_LEN        8       // Max chars in the Swap File Size edit.
#define MIN_FREESPACE       5       // Must have 5 meg free after swap file
#define MIN_SUGGEST         22      // Always suggest at least 22 meg
#define CCHMBSTRING         12      // Space for localizing the "MB" string.

/*
 * Space for 26 pagefile info structures and 26 paths to pagefiles.
 */
#define PAGEFILE_INFO_BUFFER_SIZE MAX_DRIVES * sizeof(SYSTEM_PAGEFILE_INFORMATION) + \
                                  MAX_DRIVES * MAX_PATH * sizeof(TCHAR)

/*
 * Maximum length of volume info line in the listbox.
 *                           A:  [   Vol_label  ]   %d   -   %d
 */
#define MAX_VOL_LINE        (3 + 1 + MAX_PATH + 2 + 10 + 3 + 10)


/*
 * This amount will be added to the minimum page file size to determine
 * the maximum page file size if it is not explicitly specified.
 */
#define MAXOVERMINFACTOR    50


#define TABSTOP_VOL         22
#define TABSTOP_SIZE        122


/*
 * My privilege 'handle' structure
 */
typedef struct {
    HANDLE hTok;
    TOKEN_PRIVILEGES tp;
} PRIVDAT, *PPRIVDAT;

//==========================================================================
//                            Typedefs and Structs
//==========================================================================
// registry info for a page file (but not yet formatted).
//Note: since this structure gets passed to FormatMessage, all fields must
//be 4 bytes wide (or 8 bytes on Win64)
typedef struct
{
    LPTSTR pszName;
    DWORD_PTR nMin;
    DWORD_PTR nMax;
    DWORD_PTR chNull;
} PAGEFILDESC;



//==========================================================================
//                     Global Data Declarations
//==========================================================================
HKEY ghkeyMemMgt = NULL;
int  gcrefMemMgt = 0;
VCREG_RET gvcMemMgt =  VCREG_ERROR;
int     gcrefPagingFiles = 0;
TCHAR g_szSysDir[ MAX_PATH ];

//==========================================================================
//                     Local Data Declarations
//==========================================================================
/*
 * Virtual Memory Vars
 */

// Registry Key and Value Names
TCHAR szMemMan[] =
     TEXT("System\\CurrentControlSet\\Control\\Session Manager\\Memory Management");

TCHAR szSessionManager[] = TEXT("System\\CurrentControlSet\\Control\\Session Manager");

TCHAR szPendingRename[] = TEXT("PendingFileRenameOperations");
TCHAR szRenameFunkyPrefix[] = TEXT("\\??\\");

#ifndef VM_DBG
TCHAR szPagingFiles[] = TEXT("PagingFiles");
TCHAR szPagedPoolSize[] = TEXT("PagedPoolSize");
#else
// temp values for testing only!
TCHAR szPagingFiles[] = TEXT("TestPagingFiles");
TCHAR szPagedPoolSize[] = TEXT("TestPagedPoolSize");
#endif

/* Array of paging files.  This is indexed by the drive letter (A: is 0). */
PAGING_FILE apf[MAX_DRIVES];
PAGING_FILE apfOriginal[MAX_DRIVES];

// Other VM Vars
TCHAR szPagefile[] = TEXT("x:\\pagefile.sys");
TCHAR szNoPageFile[] = TEXT("TempPageFile");
TCHAR szMB[CCHMBSTRING];

DWORD dwFreeMB;
DWORD cmTotalVM;
DWORD cmRegSizeLim;
DWORD cmPagedPoolLim;
DWORD cmRegUsed;
static DWORD cxLBExtent;
static int cxExtra;

//
// Help IDs
//
DWORD aVirtualMemHelpIds[] = {
    IDC_STATIC,             NO_HELP,
    IDD_VM_VOLUMES,         NO_HELP,
    IDD_VM_DRIVE_HDR,       (IDH_DLG_VIRTUALMEM + 0),
    IDD_VM_PF_SIZE_LABEL,   (IDH_DLG_VIRTUALMEM + 1), 
    IDD_VM_DRIVE_LABEL,     (IDH_DLG_VIRTUALMEM + 2),
    IDD_VM_SF_DRIVE,        (IDH_DLG_VIRTUALMEM + 2),
    IDD_VM_SPACE_LABEL,     (IDH_DLG_VIRTUALMEM + 3),
    IDD_VM_SF_SPACE,        (IDH_DLG_VIRTUALMEM + 3),
    IDD_VM_ST_INITSIZE,     (IDH_DLG_VIRTUALMEM + 4),
    IDD_VM_SF_SIZE,         (IDH_DLG_VIRTUALMEM + 4),
    IDD_VM_ST_MAXSIZE,      (IDH_DLG_VIRTUALMEM + 5),
    IDD_VM_SF_SIZEMAX,      (IDH_DLG_VIRTUALMEM + 5),
    IDD_VM_SF_SET,          (IDH_DLG_VIRTUALMEM + 6),
    IDD_VM_MIN_LABEL,       (IDH_DLG_VIRTUALMEM + 7),
    IDD_VM_MIN,             (IDH_DLG_VIRTUALMEM + 7),
    IDD_VM_RECOMMEND_LABEL, (IDH_DLG_VIRTUALMEM + 8),
    IDD_VM_RECOMMEND,       (IDH_DLG_VIRTUALMEM + 8),
    IDD_VM_ALLOCD_LABEL,    (IDH_DLG_VIRTUALMEM + 9),
    IDD_VM_ALLOCD,          (IDH_DLG_VIRTUALMEM + 9),
    IDD_VM_CUSTOMSIZE_RADIO,(IDH_DLG_VIRTUALMEM + 12),
    IDD_VM_RAMBASED_RADIO,  (IDH_DLG_VIRTUALMEM + 13),
    IDD_VM_NOPAGING_RADIO,  (IDH_DLG_VIRTUALMEM + 14),
    0,0
};

/*

    Plan for splitting this into property sheets:

        1.  Make the VM and CC registry keys globals that are inited
            to NULL (or INVALID_HANDLE_VALUE).  Also make gvcVirt and
            vcCore to be globals (so we can tell how the reg was opened
            inside virtinit().)

        1.  Change all RegCloseKey's to VirtualCloseKey and CoreDumpCloseKey

        2.  Change VirtualOpenKey and CoreDumpOpenKey from macros to
            functions that return the global handles if they are already
            opened, or else opens them.

        3.  In the Perf and Startup pages, call VirtualOpenKey,
            CoreDumpOpenKey, and VirtualGetPageFiles.

        -- now we can call VirtualMemComputeAlloced() from the perf page
        -- we can also just execute the CrashDump code in the startup page

        4.  rewrite VirtInit to not try and open the keys again, but instesd
            use gvcVirt, vcCore, hkeyVM and kheyCC.

        4.  Write VirtualCloseKey and CoreDumpCloseKey as follows...
            4.a     If hkey == NULL return
            4.b     RegCloseKey(hkey)
            4.c     hkey = NULL

        5.  In the PSN_RESET and PSN_APPLY cases for Perf and Startup pages
            call VirtualCloseKey and CoreDumpCloseKey

*/



//==========================================================================
//                      Local Function Prototypes
//==========================================================================
static BOOL VirtualMemInit(HWND hDlg);
static BOOL ParsePageFileDesc(LPTSTR *ppszDesc, INT *pnDrive,
                  INT *pnMinFileSize, INT *pnMaxFileSize, LPTSTR *ppszName);
static VOID VirtualMemBuildLBLine(LPTSTR pszBuf, INT cchBuf, INT iDrive);
static INT GetMaxSpaceMB(INT iDrive);
static VOID VirtualMemSelChange(HWND hDlg);
static VOID VirtualMemUpdateAllocated(HWND hDlg);
int VirtualMemComputeTotalMax( void );
static BOOL VirtualMemSetNewSize(HWND hDlg);
void VirtualMemReconcileState();

BOOL GetAPrivilege( LPTSTR pszPrivilegeName, PPRIVDAT ppd );
BOOL ResetOldPrivilege( PPRIVDAT ppdOld );

DWORD VirtualMemDeletePagefile( LPTSTR szPagefile );

#define GetPageFilePrivilege( ppd )         \
        GetAPrivilege(SE_CREATE_PAGEFILE_NAME, ppd)

//==========================================================================
VCREG_RET VirtualOpenKey( void ) {

    DOUT("In VirtOpenKey" );

    if (gvcMemMgt == VCREG_ERROR) {
        gvcMemMgt = OpenRegKey( szMemMan, &ghkeyMemMgt );
    }

    if (gvcMemMgt != VCREG_ERROR)
        gcrefMemMgt++;

    DPRINTF((TEXT("SYSCPL.CPL: VirtOpenKey, cref=%d\n"), gcrefMemMgt ));
    return gvcMemMgt;
}

void VirtualCloseKey(void) {

    DOUT( "In VirtCloseKey" );

    if (gcrefMemMgt > 0) {
        gcrefMemMgt--;
        if (gcrefMemMgt == 0) {
            CloseRegKey( ghkeyMemMgt );
            gvcMemMgt = VCREG_ERROR;
        }
    }


    DPRINTF((TEXT("SYSCPL.CPL: VirtCloseKey, cref=%d\n"), gcrefMemMgt ));
}

LPTSTR SkipNonWhiteSpace( LPTSTR sz ) {
    while( *sz != TEXT('\0') && !IsWhiteSpace(*sz))
        sz++;

    return sz;
}

LPTSTR SZPageFileName (int i)
{
    if (apf[i].pszPageFile != NULL) {
        return  apf[i].pszPageFile;
    }

    szPagefile[0] = (TCHAR)(i + (int)TEXT('a'));
    return szPagefile;
}

void VirtualCopyPageFiles( PAGING_FILE *apfDest, BOOL fFreeOld, PAGING_FILE *apfSrc, BOOL fCloneStrings ) 
{
    int i;

    for (i = 0; i < MAX_DRIVES; i++) {
        if (fFreeOld && apfDest[i].pszPageFile != NULL) {
            LocalFree(apfDest[i].pszPageFile);
        }

        if (apfSrc != NULL) {
            apfDest[i] = apfSrc[i];

            if (fCloneStrings && apfDest[i].pszPageFile != NULL) {
                apfDest[i].pszPageFile = StrDup(apfDest[i].pszPageFile);
            }
        }
    }
}



/*
 * VirtualMemDlg
 *
 *
 *
 */

INT_PTR
APIENTRY
VirtualMemDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam
    )
{
    static int fEdtCtlHasFocus = 0;

    switch (message)
    {
    case WM_INITDIALOG:
        VirtualMemInit(hDlg);
        return TRUE;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDD_VM_VOLUMES:
            /*
             * Make edit control reflect the listbox selection.
             */
            if (HIWORD(wParam) == LBN_SELCHANGE)
                VirtualMemSelChange(hDlg);

            break;

        case IDD_VM_SF_SET:
            if (VirtualMemSetNewSize(hDlg))
                SetDefButton(hDlg, IDOK);
            break;

        case IDOK:
        {
            int iRet = VirtualMemPromptForReboot(hDlg);
            // RET_ERROR means the user told us not to overwrite an
            // existing file called pagefile.sys, so we shouldn't
            // end the dialog just yet.
            if (RET_ERROR == iRet) {
                break;
            }
            else if (RET_BREAK == iRet)
            {
                EndDialog(hDlg, iRet);
                HourGlass(FALSE);
                break;
            }
            else
            {
                VirtualMemUpdateRegistry();
                VirtualMemReconcileState();

                VirtualCloseKey();

                //
                // get rid of backup copy of pagefile structs
                //
                VirtualCopyPageFiles( apfOriginal, TRUE, NULL, FALSE );
                EndDialog(hDlg, iRet);
                HourGlass(FALSE);
                break;
            }
        }

        case IDCANCEL:
            //
            // get rid of changes and restore original values
            //
            VirtualCopyPageFiles( apf, TRUE, apfOriginal, FALSE );

            VirtualCloseKey();

            EndDialog(hDlg, RET_NO_CHANGE);
            HourGlass(FALSE);
            break;

        case IDD_VM_SF_SIZE:
        case IDD_VM_SF_SIZEMAX:
            switch(HIWORD(wParam))
            {
            case EN_CHANGE:
                if (fEdtCtlHasFocus != 0)
                    SetDefButton( hDlg, IDD_VM_SF_SET);
                break;

            case EN_SETFOCUS:
                fEdtCtlHasFocus++;
                break;

            case EN_KILLFOCUS:
                fEdtCtlHasFocus--;
                break;
            }
            break;

        case IDD_VM_NOPAGING_RADIO:
        case IDD_VM_RAMBASED_RADIO:
            if( HIWORD(wParam) == BN_CLICKED )
            {
                EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZE ), FALSE );
                EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZEMAX ), FALSE );
            }
            break;

        case IDD_VM_CUSTOMSIZE_RADIO:
            if( HIWORD(wParam) == BN_CLICKED )
            {
                EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZE ), TRUE );
                EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZEMAX ), TRUE );
            }
            break;

        default:
            break;
        }
        break;

    case WM_HELP:      // F1
        WinHelp((HWND)((LPHELPINFO) lParam)->hItemHandle, HELP_FILE, HELP_WM_HELP,
        (DWORD_PTR) (LPSTR) aVirtualMemHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, HELP_FILE, HELP_CONTEXTMENU,
        (DWORD_PTR) (LPSTR) aVirtualMemHelpIds);
        break;


    case WM_DESTROY:
    {

        VirtualFreePageFiles(apf);
        /*
         * The docs were not clear as to what a dialog box should return
         * for this message, so I am going to punt and let the defdlgproc
         * doit.
         */

        /* FALL THROUGH TO DEFAULT CASE! */
    }

    default:
        return FALSE;
        break;
    }

    return TRUE;
}

/*
 * BOOL VirtualGetPageFiles(PAGING_FILE *apf)
 *
 *  Fills in the PAGING_FILE array from the values stored in the registry
 */
BOOL VirtualGetPageFiles(PAGING_FILE *apf) {
    DWORD cbTemp;
    LPTSTR pszTemp;
    INT nDrive;
    INT nMinFileSize;
    INT nMaxFileSize;
    LPTSTR psz;
    DWORD dwDriveMask;
    int i;
    static TCHAR szDir[] = TEXT("?:");

    DPRINTF((TEXT("SYSCPL: In VirtualGetPageFile, cref=%d\n"), gcrefPagingFiles));

    if (gcrefPagingFiles++ > 0) {
        // Paging files already loaded
        return TRUE;
    }

    dwDriveMask = GetLogicalDrives();

    for (i = 0; i < MAX_DRIVES; dwDriveMask >>= 1, i++)
    {
        apf[i].fCanHavePagefile = FALSE;
        apf[i].nMinFileSize = 0;
        apf[i].nMaxFileSize = 0;
        apf[i].nMinFileSizePrev = 0;
        apf[i].nMaxFileSizePrev = 0;
        apf[i].fRamBasedPagefile = FALSE;
        apf[i].fRamBasedPrev = FALSE;
        apf[i].pszPageFile = NULL;

        if (dwDriveMask & 0x01)
        {
            szDir[0] = TEXT('a') + i;
            switch (VMGetDriveType(szDir))
            {
                case DRIVE_FIXED:
                    apf[i].fCanHavePagefile = TRUE;
                    break;

                default:
                    break;
            }
        }
    }

    if (SHRegGetValue(ghkeyMemMgt, NULL, szPagingFiles, SRRF_RT_REG_MULTI_SZ, NULL,
                         (LPBYTE) NULL, &cbTemp) != ERROR_SUCCESS)
    {
        // Could not get the current virtual memory settings size.
        return FALSE;
    }

    pszTemp = LocalAlloc(LPTR, cbTemp);
    if (pszTemp == NULL)
    {
        // Could not alloc a buffer for the vmem settings
        return FALSE;
    }


    pszTemp[0] = 0;
    if (SHRegGetValue(ghkeyMemMgt, NULL, szPagingFiles, SRRF_RT_REG_MULTI_SZ, NULL,
                         (LPBYTE) pszTemp, &cbTemp) != ERROR_SUCCESS)
    {
        // Could not read the current virtual memory settings.
        LocalFree(pszTemp);
        return FALSE;
    }

    psz = pszTemp;
    while (*psz)
    {
        LPTSTR pszPageName;

        /*
         * If the parse works, and this drive can have a pagefile on it,
         * update the apf table.  Note that this means that currently
         * specified pagefiles for invalid drives will be stripped out
         * of the registry if the user presses OK for this dialog.
         */
        if (ParsePageFileDesc(&psz, &nDrive, &nMinFileSize, &nMaxFileSize, &pszPageName))
        {
            if (apf[nDrive].fCanHavePagefile)
            {
                apf[nDrive].nMinFileSize =
                apf[nDrive].nMinFileSizePrev = nMinFileSize;

                apf[nDrive].nMaxFileSize =
                apf[nDrive].nMaxFileSizePrev = nMaxFileSize;

                apf[nDrive].fRamBasedPagefile =
                apf[nDrive].fRamBasedPrev = (nMinFileSize == 0 && nMaxFileSize == 0);

                apf[nDrive].pszPageFile = pszPageName;
            }
        }
    }

    LocalFree(pszTemp);
    return TRUE;
}

/*
 * VirtualFreePageFiles
 *
 * Frees data alloced by VirtualGetPageFiles
 *
 */
void VirtualFreePageFiles(PAGING_FILE *apf) {
    int i;

    DPRINTF((TEXT("SYSCPL: In VirtualFreePageFile, cref=%d\n"), gcrefPagingFiles));

    if (gcrefPagingFiles > 0) {
        gcrefPagingFiles--;

        if (gcrefPagingFiles == 0) {
            for (i = 0; i < MAX_DRIVES; i++) {
                if (apf[i].pszPageFile != NULL)
                    LocalFree(apf[i].pszPageFile);
            }
        }
    }
}



/*
 * VirtualInitStructures()
 *
 * Calls VirtualGetPageFiles so other helpers can be called from the Perf Page.
 *
 * Returns:
 *  TRUE if success, FALSE if failure
 */
BOOL VirtualInitStructures( void ) {
    VCREG_RET vcVirt;
    BOOL fRet = FALSE;

    vcVirt = VirtualOpenKey();

    if (vcVirt != VCREG_ERROR)
        fRet = VirtualGetPageFiles( apf );

    LoadString(hInstance, IDS_SYSDM_MB, szMB, CCHMBSTRING);

    return fRet;
}

void VirtualFreeStructures( void ) {
    VirtualFreePageFiles(apf);
    VirtualCloseKey();
}

/*
 * VirtualMemInit
 *
 * Initializes the Virtual Memory dialog.
 *
 * Arguments:
 *  HWND hDlg - Handle to the dialog window.
 *
 * Returns:
 *  TRUE
 */

static
BOOL
VirtualMemInit(
    HWND hDlg
    )
{
    TCHAR szTemp[MAX_VOL_LINE];
    DWORD i;
    INT iItem;
    HWND hwndLB;
    INT aTabs[2];
    RECT rc;
    VCREG_RET vcVirt;
    SYSTEM_BASIC_INFORMATION BasicInfo;
    NTSTATUS status;
    unsigned __int64 TotalPhys;

    HourGlass(TRUE);


    //
    // Load the "MB" string.
    //
    LoadString(hInstance, IDS_SYSDM_MB, szMB, CCHMBSTRING);

    ////////////////////////////////////////////////////////////////////
    //  List all drives
    ////////////////////////////////////////////////////////////////////

    vcVirt = VirtualOpenKey();

    if (vcVirt == VCREG_ERROR ) {
        //  Error - cannot even get list of paging files from  registry
        MsgBoxParam(hDlg, IDS_SYSDM_NOOPEN_VM_NOTUSER, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION);
        EndDialog(hDlg, RET_NO_CHANGE);
        HourGlass(FALSE);

        if (ghkeyMemMgt != NULL)
            VirtualCloseKey();
        return FALSE;
    }

    /*
     * To change Virtual Memory size or Crash control, we need access
     * to both the CrashCtl key and the PagingFiles value in the MemMgr key
     */
    if (vcVirt == VCREG_READONLY ) {
        /*
         * Disable some fields, because they only have Read access.
         */
        EnableWindow(GetDlgItem(hDlg, IDD_VM_SF_SIZE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_VM_ST_INITSIZE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_VM_ST_MAXSIZE), FALSE);
        EnableWindow(GetDlgItem(hDlg, IDD_VM_SF_SET), FALSE);
    }

    if (!VirtualGetPageFiles(apf)) {
        // Could not read the current virtual memory settings.
        MsgBoxParam(hDlg, IDS_SYSDM_CANNOTREAD, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION);
    }

    //
    // Save a backup copy of the current pagefile structs
    //
    VirtualCopyPageFiles( apfOriginal, FALSE, apf, TRUE );

    hwndLB = GetDlgItem(hDlg, IDD_VM_VOLUMES);
    aTabs[0] = TABSTOP_VOL;
    aTabs[1] = TABSTOP_SIZE;
    SendMessage(hwndLB, LB_SETTABSTOPS, 2, (LPARAM)aTabs);

    /*
     * Since SetGenLBWidth only counts tabs as one character, we must compute
     * the maximum extra space that the tab characters will expand to and
     * arbitrarily tack it onto the end of the string width.
     *
     * cxExtra = 1st Tab width + 1 default tab width (8 chrs) - strlen("d:\t\t");
     *
     * (I know the docs for LB_SETTABSTOPS says that a default tab == 2 dlg
     * units, but I have read the code, and it is really 8 chars)
     */
    rc.top = rc.left = 0;
    rc.bottom = 8;
    rc.right = TABSTOP_VOL + (4 * 8) - (4 * 4);
    MapDialogRect( hDlg, &rc );

    cxExtra = rc.right - rc.left;
    cxLBExtent = 0;

    for (i = 0; i < MAX_DRIVES; i++)
    {
        // Assume we don't have to create anything
        apf[i].fCreateFile = FALSE;

        if (apf[i].fCanHavePagefile)
        {
            VirtualMemBuildLBLine(szTemp, ARRAYSIZE(szTemp), i);
            iItem = (INT)SendMessage(hwndLB, LB_ADDSTRING, 0, (LPARAM)szTemp);
            SendMessage(hwndLB, LB_SETITEMDATA, iItem, i);
            // SetGenLBWidth(hwndLB, szTemp, &cxLBExtent, hfontBold, cxExtra);
            cxLBExtent = SetLBWidthEx( hwndLB, szTemp, cxLBExtent, cxExtra);
        }
    }

    SendDlgItemMessage(hDlg, IDD_VM_SF_SIZE, EM_LIMITTEXT, MAX_SIZE_LEN, 0L);
    SendDlgItemMessage(hDlg, IDD_VM_SF_SIZEMAX, EM_LIMITTEXT, MAX_SIZE_LEN, 0L);

    /*
     * Get the total physical memory in the machine.
     */
    status = NtQuerySystemInformation(
        SystemBasicInformation,
        &BasicInfo,
        sizeof(BasicInfo),
        NULL
    );
    if (NT_SUCCESS(status)) {
        TotalPhys = (unsigned __int64) BasicInfo.NumberOfPhysicalPages * BasicInfo.PageSize;
    }
    else {
        TotalPhys = 0;
    }

    SetDlgItemMB(hDlg, IDD_VM_MIN, MIN_SWAPSIZE);

    // Recommended pagefile size is 1.5 * RAM size these days.
    // Nonintegral multiplication with unsigned __int64s is fun!
    // This will obviously fail if the machine has total RAM
    // greater than 13194139533312 MB (75% of a full 64-bit address
    // space).  Hopefully by the time someone has such a beast we'll
    // have __int128s to hold the results of this calculation.

    TotalPhys >>= 20; // Bytes to MB
    TotalPhys *= 3; // This will always fit because of the operation above
    TotalPhys >>= 1; // x*3/2 == 1.5*x, more or less
    i = (DWORD) TotalPhys; // This cast actually causes the
                           // algorithm to fail if the machine has
                           // more than ~ 3.2 billion MB of RAM.
                           // At that point, either the Win32 API has
                           // to change to allow me to pass __int64s
                           // as message params, or we have to start
                           // reporting these stats in GB.
    SetDlgItemMB(hDlg, IDD_VM_RECOMMEND, max(i, MIN_SUGGEST));

    /*
     * Select the first drive in the listbox.
     */
    SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_SETCURSEL, 0, 0L);
    VirtualMemSelChange(hDlg);

    VirtualMemUpdateAllocated(hDlg);

    /*
     * Show RegQuota
     */
    cmTotalVM = VirtualMemComputeTotalMax();

    HourGlass(FALSE);

    return TRUE;
}


/*
 * ParseSDD
 */

int ParseSDD( LPTSTR psz, LPTSTR szPath, INT cchPath, INT *pnMinFileSize, INT *pnMaxFileSize) {
    int cMatched = 0;
    LPTSTR pszNext;

    psz = SkipWhiteSpace(psz);

    if (*psz) {
        int cch;

        cMatched++;
        pszNext = SkipNonWhiteSpace(psz);
        cch = (int)(pszNext - psz);

        if (cch < cchPath)
        {
            CopyMemory( szPath, psz, sizeof(TCHAR) * cch );
            szPath[cch] = TEXT('\0');

            psz = SkipWhiteSpace(pszNext);

            if (*psz) {
                cMatched++;
                pszNext = SkipNonWhiteSpace(psz);
                *pnMinFileSize = StringToInt( psz );

                psz = SkipWhiteSpace(pszNext);

                if (*psz) {
                    cMatched++;
                    *pnMaxFileSize = StringToInt( psz );
                }
            }
        }
    }

    return cMatched;
}

/*
 * ParsePageFileDesc
 *
 *
 *
 * Arguments:
 *
 * Returns:
 *
 */

static
BOOL
ParsePageFileDesc(
    LPTSTR *ppszDesc,
    INT *pnDrive,
    INT *pnMinFileSize,
    INT *pnMaxFileSize,
    LPTSTR *ppstr
    )
{
    LPTSTR psz;
    LPTSTR pszName = NULL;
    int cFields;
    TCHAR chDrive;
    TCHAR szPath[MAX_PATH];

    /*
     * Find the end of this REG_MULTI_SZ string and point to the next one
     */
    psz = *ppszDesc;
    *ppszDesc = psz + lstrlen(psz) + 1;

    /*
     * Parse the string from "filename minsize maxsize"
     */
    szPath[0] = TEXT('\0');
    *pnMinFileSize = 0;
    *pnMaxFileSize = 0;

    /* Try it without worrying about quotes */
    cFields = ParseSDD( psz, szPath, ARRAYSIZE(szPath), pnMinFileSize, pnMaxFileSize);

    if (cFields < 2)
        return FALSE;

    /*
     * Find the drive index
     */
    chDrive = (TCHAR)tolower(*szPath);

    if (chDrive < TEXT('a') || chDrive > TEXT('z'))
        return FALSE;

    *pnDrive = (INT)(chDrive - TEXT('a'));

    /* if the path != x:\pagefile.sys then save it */
    if (lstrcmpi(szPagefile + 1, szPath + 1) != 0)
    {
        pszName = StrDup(szPath);
        if (!pszName)
        {
            return FALSE;
        }
    }

    *ppstr = pszName;

    if (cFields < 3)
    {
        INT nSpace;

        // don't call GetDriveSpace if the drive is invalid
        if (apf[*pnDrive].fCanHavePagefile)
            nSpace = GetMaxSpaceMB(*pnDrive);
        else
            nSpace = 0;
        *pnMaxFileSize = min(*pnMinFileSize + MAXOVERMINFACTOR, nSpace);
    }

    /*
     * If the page file size in the registry is zero it means this is
     * a RAM based page file.
     */
    if (*pnMinFileSize == 0) {
        apf[*pnDrive].fRamBasedPagefile = TRUE;    
    }
    else {
        apf[*pnDrive].fRamBasedPagefile = FALSE;    
    }

    return TRUE;
}



/*
 * VirtualMemBuildLBLine
 *
 *
 *
 */

static
VOID
VirtualMemBuildLBLine(
    LPTSTR pszBuf,
    INT cchBuf,
    INT iDrive
    )
{
    HRESULT hr;

    TCHAR szVolume[MAX_PATH];
    TCHAR szTemp[MAX_PATH];

    PathBuildRoot(szTemp, iDrive);

    *szVolume = 0;
    if (!GetVolumeInformation(szTemp, szVolume, MAX_PATH, NULL, NULL, NULL, NULL, 0))
    {
        *szVolume = 0;
    }

    szTemp[2] = TEXT('\t');
    if (*szVolume)
    {
        hr = StringCchPrintf(pszBuf, cchBuf, TEXT("%s[%s]"),szTemp,szVolume);
    }
    else
    {
        hr = StringCchCopy(pszBuf, cchBuf, szTemp);
    }

    if (SUCCEEDED(hr))
    {
        if (apf[iDrive].fRamBasedPagefile) 
        {
            if (LoadString(hInstance, 164, szTemp, ARRAYSIZE(szTemp))) // what does 164 mean here?
            {
                hr = StringCchCat(pszBuf, cchBuf, szTemp);
            }
        }
        else if (apf[iDrive].nMinFileSize)
        {
            if (SUCCEEDED(StringCchPrintf(szTemp, ARRAYSIZE(szTemp), TEXT("\t%d - %d"),
                                          apf[iDrive].nMinFileSize, apf[iDrive].nMaxFileSize)))
            {
                hr = StringCchCat(pszBuf, cchBuf, szTemp);
            }
        }
    }
}



/*
 * SetDlgItemMB
 *
 *
 */

VOID SetDlgItemMB( HWND hDlg, INT idControl, DWORD dwMBValue ) 
{
    TCHAR szBuf[32];

    if (SUCCEEDED(StringCchPrintf(szBuf, ARRAYSIZE(szBuf), TEXT("%d %s"), dwMBValue, szMB)))
    {
        SetDlgItemText(hDlg, idControl, szBuf);
    }
}



/*
 * GetFreeSpaceMB
 *
 *
 *
 */

DWORD
GetFreeSpaceMB(
    INT iDrive
)
{
    TCHAR szDriveRoot[4];
    DWORD dwSectorsPerCluster;
    DWORD dwBytesPerSector;
    DWORD dwFreeClusters;
    DWORD dwClusters;
    DWORD iSpace;
    DWORD iSpaceExistingPagefile;
    HANDLE hff;
    WIN32_FIND_DATA ffd;
    ULARGE_INTEGER ullPagefileSize;


    PathBuildRoot(szDriveRoot, iDrive);

    if (!GetDiskFreeSpace(szDriveRoot, &dwSectorsPerCluster, &dwBytesPerSector,
            &dwFreeClusters, &dwClusters))
        return 0;

    iSpace = (INT)((dwSectorsPerCluster * dwFreeClusters) /
            (ONE_MEG / dwBytesPerSector));

    //
    // Be sure to include the size of any existing pagefile.
    // Because this space can be reused for a new paging file,
    // it is effectively "disk free space" as well.  The
    // FindFirstFile api is safe to use, even if the pagefile
    // is in use, because it does not need to open the file
    // to get its size.
    //
    iSpaceExistingPagefile = 0;
    if ((hff = FindFirstFile(SZPageFileName(iDrive), &ffd)) !=
        INVALID_HANDLE_VALUE)
    {
        ullPagefileSize.HighPart = ffd.nFileSizeHigh;
        ullPagefileSize.LowPart = ffd.nFileSizeLow;

        iSpaceExistingPagefile = (INT)(ullPagefileSize.QuadPart / (ULONGLONG)ONE_MEG);

        FindClose(hff);
    }

    return iSpace + iSpaceExistingPagefile;
}


/*
 * GetMaxSpaceMB
 *
 *
 *
 */

static
INT
GetMaxSpaceMB(
    INT iDrive
    )
{
    TCHAR szDriveRoot[4];
    DWORD dwSectorsPerCluster;
    DWORD dwBytesPerSector;
    DWORD dwFreeClusters;
    DWORD dwClusters;
    INT iSpace;


    PathBuildRoot(szDriveRoot, iDrive);

    if (!GetDiskFreeSpace(szDriveRoot, &dwSectorsPerCluster, &dwBytesPerSector,
                          &dwFreeClusters, &dwClusters))
        return 0;

    iSpace = (INT)((dwSectorsPerCluster * dwClusters) /
                   (ONE_MEG / dwBytesPerSector));

    return iSpace;
}


/*
 * VirtualMemSelChange
 *
 *
 *
 */

static
VOID
VirtualMemSelChange(
    HWND hDlg
    )
{
    TCHAR szDriveRoot[4];
    TCHAR szTemp[MAX_PATH];
    TCHAR szVolume[MAX_PATH];
    INT iSel;
    INT iDrive;
    INT nCrtRadioButtonId;
    BOOL fEditsEnabled;

    if ((iSel = (INT)SendDlgItemMessage(
            hDlg, IDD_VM_VOLUMES, LB_GETCURSEL, 0, 0)) == LB_ERR)
        return;

    iDrive = (INT)SendDlgItemMessage(hDlg, IDD_VM_VOLUMES,
            LB_GETITEMDATA, iSel, 0);

    PathBuildRoot(szDriveRoot, iDrive);
    PathBuildRoot(szTemp, iDrive);
    szTemp[2] = 0;    
    szVolume[0] = 0;

    if (GetVolumeInformation(szDriveRoot, szVolume, MAX_PATH, NULL, NULL, NULL, NULL, 0) && *szVolume)
    {
        if (FAILED(StringCchCat(szTemp, ARRAYSIZE(szTemp), TEXT("  ["))) ||
            FAILED(StringCchCat(szTemp, ARRAYSIZE(szTemp), szVolume)) ||
            FAILED(StringCchCat(szTemp, ARRAYSIZE(szTemp), TEXT("]"))))
        {
            szTemp[2] = 0; // if we fail to concat all the pieces, concat none           
        }
    }


    //LATER: should we also put up total drive size as well as free space?

    SetDlgItemText(hDlg, IDD_VM_SF_DRIVE, szTemp);
    SetDlgItemMB(hDlg, IDD_VM_SF_SPACE, GetFreeSpaceMB(iDrive));

    if ( apf[iDrive].fRamBasedPagefile ) 
    {
        //
        // Paging file size based on RAM size
        //

        nCrtRadioButtonId = IDD_VM_RAMBASED_RADIO;

        fEditsEnabled = FALSE;
    }
    else
    {
        if ( apf[iDrive].nMinFileSize != 0 ) 
        {
            //
            // Custom size paging file
            //

            nCrtRadioButtonId = IDD_VM_CUSTOMSIZE_RADIO;

            SetDlgItemInt(hDlg, IDD_VM_SF_SIZE, apf[iDrive].nMinFileSize, FALSE);
            SetDlgItemInt(hDlg, IDD_VM_SF_SIZEMAX, apf[iDrive].nMaxFileSize, FALSE);

            fEditsEnabled = TRUE;
        }
        else 
        {
            //
            // No paging file
            //
            
            nCrtRadioButtonId = IDD_VM_NOPAGING_RADIO;

            SetDlgItemText(hDlg, IDD_VM_SF_SIZE, TEXT(""));
            SetDlgItemText(hDlg, IDD_VM_SF_SIZEMAX, TEXT(""));

            fEditsEnabled = FALSE;
        }
    }

    //
    // Select the appropriate radio button
    //

    CheckRadioButton( 
        hDlg,
        IDD_VM_CUSTOMSIZE_RADIO,
        IDD_VM_NOPAGING_RADIO,
        nCrtRadioButtonId );

    //
    // Enable/disable the min & max size edit boxes
    //

    EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZE ), fEditsEnabled );
    EnableWindow( GetDlgItem( hDlg, IDD_VM_SF_SIZEMAX ), fEditsEnabled );
}



/*
 * VirtualMemUpdateAllocated
 *
 *
 *
 */

INT VirtualMemComputeAllocated( HWND hWnd , BOOL *pfTempPf) 
{
    BOOL fSuccess = FALSE;
    static BOOL fWarned = FALSE;
    ULONG ulPagefileSize = 0;
    unsigned __int64 PagefileSize;
    NTSTATUS result = ERROR_ACCESS_DENIED;
    SYSTEM_INFO SysInfo;
    PSYSTEM_PAGEFILE_INFORMATION pPagefileInfo = NULL;
    PSYSTEM_PAGEFILE_INFORMATION pCurrentPagefile = NULL;
    LONG lResult = ERROR_ACCESS_DENIED;
    DWORD dwValueType = 0;
    DWORD fTempPagefile = 0;
    DWORD cbSize = sizeof(DWORD);

    __try {
        pCurrentPagefile = pPagefileInfo = (PSYSTEM_PAGEFILE_INFORMATION) LocalAlloc(
            LPTR,
            PAGEFILE_INFO_BUFFER_SIZE
        );
        if (!pPagefileInfo) {
            __leave;
        } // if        
    
        // Get the page size in bytes
        GetSystemInfo(&SysInfo);

        // Get the sizes (in pages) of all of the pagefiles on the system
        result = NtQuerySystemInformation(
            SystemPageFileInformation,
            pPagefileInfo,
            PAGEFILE_INFO_BUFFER_SIZE,
            NULL
        );
        if (ERROR_SUCCESS != result) {
            __leave;
        } // if

        if (pfTempPf) {
            // Check to see if the system created a temporary pagefile
            lResult = SHRegGetValue(
                ghkeyMemMgt,
                NULL, 
                szNoPageFile,
                SRRF_RT_REG_DWORD,
                &dwValueType,
                (LPBYTE) &fTempPagefile,
                &cbSize
            );

            if ((ERROR_SUCCESS == lResult) && fTempPagefile) {
                *pfTempPf = TRUE;
            } // if (ERROR_SUCCESS...
            else {
                *pfTempPf = FALSE;
            } // else
        } // if (pfTempPf)
        
        // Add up pagefile sizes
        while (pCurrentPagefile->NextEntryOffset) {
            ulPagefileSize += pCurrentPagefile->TotalSize;
            ((LPBYTE) pCurrentPagefile) += pCurrentPagefile->NextEntryOffset;
        } // while
        ulPagefileSize += pCurrentPagefile->TotalSize;

        // Convert pages to bytes
        PagefileSize = (unsigned __int64) ulPagefileSize * SysInfo.dwPageSize;

        // Convert bytes to MB
        ulPagefileSize = (ULONG) (PagefileSize / ONE_MEG);

        fSuccess = TRUE;
        
    } // __try
    __finally {

        // If we failed to determine the pagefile size, then
        // warn the user that the reported size is incorrect,
        // once per applet invokation.
        if (!fSuccess && !fWarned) {
            MsgBoxParam(
                hWnd,
                IDS_SYSDM_DONTKNOWCURRENT,
                IDS_SYSDM_TITLE,
                MB_ICONERROR | MB_OK
            );
            fWarned = TRUE;
        } // if

        LocalFree(pPagefileInfo);

    } // __finally

    return(ulPagefileSize);
}

static VOID VirtualMemUpdateAllocated(
    HWND hDlg
    )
{

    SetDlgItemMB(hDlg, IDD_VM_ALLOCD, VirtualMemComputeAllocated(hDlg, NULL));
}


int VirtualMemComputeTotalMax( void ) {
    INT nTotalAllocated;
    INT i;

    for (nTotalAllocated = 0, i = 0; i < MAX_DRIVES; i++)
    {
        nTotalAllocated += apf[i].nMaxFileSize;
    }

    return nTotalAllocated;
}


/*
 * VirtualMemSetNewSize
 *
 *
 *
 */

static
BOOL
VirtualMemSetNewSize(
    HWND hDlg
    )
{
    DWORD nSwapSize;
    DWORD nSwapSizeMax;
    BOOL fTranslated;
    INT iSel;
    INT iDrive = 2; // default to C
    TCHAR szTemp[MAX_PATH];
    DWORD nFreeSpace;
    DWORD CrashDumpSizeInMbytes;
    TCHAR Drive;
    INT iBootDrive;
    BOOL fRamBasedPagefile = FALSE;

    //
    // Initialize variables for crashdump.
    //

    if (GetSystemDrive (&Drive)) {
        iBootDrive = tolower (Drive) - 'a';
    } else {
        iBootDrive = 0;
    }

    if ((iSel = (INT)SendDlgItemMessage(
            hDlg, IDD_VM_VOLUMES, LB_GETCURSEL, 0, 0)) != LB_ERR)
    {
        if (LB_ERR == 
              (iDrive = (INT)SendDlgItemMessage(hDlg, IDD_VM_VOLUMES,
                                                LB_GETITEMDATA, iSel, 0)))
        {
            return FALSE; // failure!
        }
    }


    CrashDumpSizeInMbytes =
            (DWORD) ( CoreDumpGetRequiredFileSize (NULL) / ONE_MEG );
    
    if( IsDlgButtonChecked( hDlg, IDD_VM_NOPAGING_RADIO ) == BST_CHECKED )
    {
        //
        // No paging file on this drive.
        //

        nSwapSize = 0;
        nSwapSizeMax = 0;
        fTranslated = TRUE;
    }
    else
    {
        if( IsDlgButtonChecked( hDlg, IDD_VM_RAMBASED_RADIO ) == BST_CHECKED )
        {
            MEMORYSTATUSEX MemoryInfo;

            //
            // User requested a RAM based page file. We will compute a page file
            // size based on the RAM currently available so that we can benefit of
            // all the verifications done below related to disk space available etc.
            // The final page file specification written to the registry will contain
            // zero sizes though because this is the way we signal that we
            // want a RAM based page file.
            //

            ZeroMemory (&MemoryInfo, sizeof(MemoryInfo));
            MemoryInfo.dwLength =  sizeof(MemoryInfo);

            if (GlobalMemoryStatusEx (&MemoryInfo)) 
            {
                fRamBasedPagefile = TRUE;

                //
                // We do not lose info because we first divide the RAM size to
                // 1Mb and only after that we convert to a DWORD.
                //

                nSwapSize = (DWORD)(MemoryInfo.ullTotalPhys / 0x100000) + 12;
                nSwapSizeMax = nSwapSize;
                fTranslated = TRUE;
            }
            else 
            {
                nSwapSize = 0;
                nSwapSizeMax = 0;
                fTranslated = TRUE;
            }
        }
        else
        {
            //
            // User requested a custom size paging file
            //

            nSwapSize = (INT)GetDlgItemInt(hDlg, IDD_VM_SF_SIZE,
                    &fTranslated, FALSE);
            if (!fTranslated)
            {
                MsgBoxParam(hDlg, IDS_SYSDM_ENTERINITIALSIZE, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION);
                SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
                return FALSE;
            }

            if ((nSwapSize < MIN_SWAPSIZE && nSwapSize != 0))
            {
                MsgBoxParam(hDlg, IDS_SYSDM_PAGEFILESIZE_START, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION,
					GetMaxPagefileSizeInMB(iDrive));
                SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
                return FALSE;
            }

            if (nSwapSize == 0)
            {
                nSwapSizeMax = 0;
            }
            else
            {
                nSwapSizeMax = (INT)GetDlgItemInt(hDlg, IDD_VM_SF_SIZEMAX,
                        &fTranslated, FALSE);
                if (!fTranslated)
                {
                    MsgBoxParam(hDlg, IDS_SYSDM_ENTERMAXIMUMSIZE, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION,
                            GetMaxPagefileSizeInMB(iDrive));
                    SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX));
                    return FALSE;
                }

                if (nSwapSizeMax < nSwapSize || nSwapSizeMax > GetMaxPagefileSizeInMB(iDrive))
                {
                    MsgBoxParam(hDlg, IDS_SYSDM_PAGEFILESIZE_MAX, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION,
                            GetMaxPagefileSizeInMB(iDrive));
                    SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX));
                    return FALSE;
                }
            }
        }
    }

    if (fTranslated && iSel != LB_ERR)
    {
        nFreeSpace = GetMaxSpaceMB(iDrive);

        if (nSwapSizeMax > nFreeSpace)
        {
            MsgBoxParam(hDlg, IDS_SYSDM_PAGEFILESIZE_TOOSMALL_NAMED, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION,
                         (TCHAR)(iDrive + TEXT('a')));
            SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX));
            return FALSE;
        }

        nFreeSpace = GetFreeSpaceMB(iDrive);

        if (nSwapSize > nFreeSpace)
        {
            MsgBoxParam(hDlg, IDS_SYSDM_PAGEFILESIZE_TOOSMALL, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION);
            SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
            return FALSE;
        }

        if (nSwapSize != 0 && nFreeSpace - nSwapSize < MIN_FREESPACE)
        {
            MsgBoxParam(hDlg, IDS_SYSDM_NOTENOUGHSPACE_PAGE, IDS_SYSDM_TITLE, MB_ICONEXCLAMATION,
                    (int)MIN_FREESPACE);
            SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
            return FALSE;
        }

        if (nSwapSizeMax > nFreeSpace)
        {
            if (MsgBoxParam(hDlg, IDS_SYSDM_PAGEFILESIZE_TOOSMALL_GROW, IDS_SYSDM_TITLE, MB_ICONINFORMATION |
                       MB_OKCANCEL, (TCHAR)(iDrive + TEXT('a'))) == IDCANCEL)
            {
                SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZEMAX));
                return FALSE;
            }
        }

        if (iDrive == iBootDrive &&
            (ULONG64) nSwapSize < CrashDumpSizeInMbytes) {

            DWORD Ret;
            
            //
            // The new boot drive page file size is less than we need for
            // crashdump. The message notifies the user that the resultant
            // dump file may be truncated.
            //
            // NOTE: DO NOT, turn off dumping at this point, because a valid
            // dump could still be generated.
            //
             
            Ret = MsgBoxParam (hDlg,
                               IDS_SYSDM_DEBUGGING_MINIMUM,
                               IDS_SYSDM_TITLE,
                               MB_ICONEXCLAMATION | MB_YESNO,
                               (TCHAR) ( iBootDrive + TEXT ('a') ),
                               (DWORD) CrashDumpSizeInMbytes
                               );

            if (Ret != IDYES) {
                SetFocus(GetDlgItem(hDlg, IDD_VM_SF_SIZE));
                return FALSE;
            }
        }

        apf[iDrive].nMinFileSize = nSwapSize;
        apf[iDrive].nMaxFileSize = nSwapSizeMax;
        apf[iDrive].fRamBasedPagefile = fRamBasedPagefile;

        // Remember if the page file does not exist so we can create it later
        if (GetFileAttributes(SZPageFileName(iDrive)) == 0xFFFFFFFF &&
                GetLastError() == ERROR_FILE_NOT_FOUND) {
            apf[iDrive].fCreateFile = TRUE;
        }

        VirtualMemBuildLBLine(szTemp, ARRAYSIZE(szTemp), iDrive);
        SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_DELETESTRING, iSel, 0);
        SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_INSERTSTRING, iSel,
                (LPARAM)szTemp);
        SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_SETITEMDATA, iSel,
                (LPARAM)iDrive);
        SendDlgItemMessage(hDlg, IDD_VM_VOLUMES, LB_SETCURSEL, iSel, 0L);

        cxLBExtent = SetLBWidthEx(GetDlgItem(hDlg, IDD_VM_VOLUMES), szTemp, cxLBExtent, cxExtra);

        if ( ( ! apf[iDrive].fRamBasedPagefile ) && ( apf[iDrive].nMinFileSize != 0 ) ) {
            SetDlgItemInt(hDlg, IDD_VM_SF_SIZE, apf[iDrive].nMinFileSize, FALSE);
            SetDlgItemInt(hDlg, IDD_VM_SF_SIZEMAX, apf[iDrive].nMaxFileSize, FALSE);
        }
        else {
            SetDlgItemText(hDlg, IDD_VM_SF_SIZE, TEXT(""));
            SetDlgItemText(hDlg, IDD_VM_SF_SIZEMAX, TEXT(""));
        }

        VirtualMemUpdateAllocated(hDlg);
        SetFocus(GetDlgItem(hDlg, IDD_VM_VOLUMES));
    }

    return TRUE;
}



/*
 * VirtualMemUpdateRegistry
 *
 *
 *
 */

BOOL
VirtualMemUpdateRegistry(
    VOID
    )
{
    LPTSTR pszBuf;
    TCHAR szTmp[MAX_DRIVES * 22];  //max_drives * sizeof(fmt_string)
    LONG i;
    INT c;
    int j;
    PAGEFILDESC aparm[MAX_DRIVES];
    static TCHAR szNULLs[] = TEXT("\0\0");

    c = 0;
    szTmp[0] = TEXT('\0');
    pszBuf = szTmp;

    for (i = 0; i < MAX_DRIVES; i++)
    {
        if (apf[i].fRamBasedPagefile || apf[i].nMinFileSize)
        {
            j = (c * 4);
            aparm[c].nMin = (apf[i].fRamBasedPagefile) ? 0 : apf[i].nMinFileSize;
            aparm[c].nMax = (apf[i].fRamBasedPagefile) ? 0 : apf[i].nMaxFileSize;
            aparm[c].chNull = (DWORD)TEXT('\0');
            aparm[c].pszName = StrDup(SZPageFileName(i));
            if (!aparm[c].pszName)
            {
                return FALSE;
            }

            if (SUCCEEDED(StringCchPrintf(pszBuf, ARRAYSIZE(szTmp), TEXT("%%%d!s! %%%d!d! %%%d!d!%%%d!c!"), j+1, j+2, j+3, j+4)))
            {
                pszBuf += lstrlen(pszBuf);
            }
            else
            {
                return FALSE;
            }
            c++;
        }
    }

    /*
     * Alloc and fill in the page file registry string
     */
    //since FmtMsg returns 0 for error, it can not return a zero length string
    //therefore, force string to be at least one space long.

    if (szTmp[0] == TEXT('\0')) {
        pszBuf = szNULLs;
        j = 1; //Length of string == 1 char (ZTerm null will be added later).
    } else {

        j = FormatMessage( FORMAT_MESSAGE_ALLOCATE_BUFFER |
                           FORMAT_MESSAGE_FROM_STRING | FORMAT_MESSAGE_MAX_WIDTH_MASK |
                           FORMAT_MESSAGE_ARGUMENT_ARRAY,
                           szTmp, 0, 0, (LPTSTR)&pszBuf, 1, (va_list *)aparm); // TODO: do we really want &pszBuf here?
    }


    for( i = 0; i < c; i++ )
        LocalFree(aparm[i].pszName);

    if (j == 0)
        return FALSE;

    i = RegSetValueEx (ghkeyMemMgt, szPagingFiles, 0, REG_MULTI_SZ,
                       (LPBYTE)pszBuf, sizeof(TCHAR) * (j+1));

    // free the string now that it is safely stored in the registry
    if (pszBuf != szNULLs)
        LocalFree(pszBuf);

    // if the string didn't get there, then return error
    if (i != ERROR_SUCCESS)
        return FALSE;


    /*
     * Now be sure that any previous pagefiles will be deleted on
     * the next boot.
     */
    for (i = 0; i < MAX_DRIVES; i++)
    {
        /*
         * Did this drive have a pagefile before, but does not have
         * one now?
         */
        if ((apf[i].nMinFileSizePrev != 0 || apf[i].fRamBasedPrev != FALSE) && apf[i].nMinFileSize == 0)
        {
            //
            // Hack workaround -- MoveFileEx() is broken
            //
            TCHAR szPagefilePath[MAX_PATH];

            if (SUCCEEDED(StringCchCopy(szPagefilePath, ARRAYSIZE(szPagefilePath), szRenameFunkyPrefix)) &&
                SUCCEEDED(StringCchCat(szPagefilePath, ARRAYSIZE(szPagefilePath), SZPageFileName(i))))
            {
                VirtualMemDeletePagefile(szPagefilePath);
            }
        }
    }

    return TRUE;
}

BOOL GetAPrivilege( LPTSTR szPrivilegeName, PPRIVDAT ppd ) {
    BOOL fRet = FALSE;
    HANDLE hTok;
    LUID luid;
    TOKEN_PRIVILEGES tpNew;
    DWORD cb;

    if (LookupPrivilegeValue( NULL, szPrivilegeName, &luid ) &&
                OpenProcessToken(GetCurrentProcess(),
                TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &hTok)) {

        tpNew.PrivilegeCount = 1;
        tpNew.Privileges[0].Luid = luid;
        tpNew.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

        if (AdjustTokenPrivileges(hTok, FALSE, &tpNew, sizeof(ppd->tp), &(ppd->tp), &cb))
        {
            fRet = TRUE;
        }
        else
        {
            GetLastError();
        }

        ppd->hTok = hTok;
    } else {
        ppd->hTok = NULL;
    }

    return fRet;
}



BOOL ResetOldPrivilege( PPRIVDAT ppdOld ) {
    BOOL fRet = FALSE;

    if (ppdOld->hTok != NULL ) 
    {
        if (AdjustTokenPrivileges(ppdOld->hTok, FALSE, &(ppdOld->tp), 0, NULL, NULL) &&
            ERROR_NOT_ALL_ASSIGNED != GetLastError())
        {
            fRet = TRUE;
        }

        CloseHandle( ppdOld->hTok );
        ppdOld->hTok = NULL;
    }

    return fRet;
}

/*
 * VirtualMemReconcileState
 *
 * Reconciles the n*FileSizePrev fields of apf with the n*FileSize fields.
 *
 */
void
VirtualMemReconcileState(
)
{
    INT i;

    for (i = 0; i < MAX_DRIVES; i++) {
        apf[i].nMinFileSizePrev = apf[i].nMinFileSize;
        apf[i].nMaxFileSizePrev = apf[i].nMaxFileSize;
        apf[i].fRamBasedPrev = apf[i].fRamBasedPagefile;
    } // for

}

/*
 * VirtualMemDeletePagefile
 *
 * Hack workaround -- MoveFileEx() is broken.
 *
 */
DWORD
VirtualMemDeletePagefile(
    IN LPTSTR pszPagefile
)
{
    HKEY hKey;
    BOOL fhKeyOpened = FALSE;
    DWORD dwResult;
    LONG lResult;
    LPTSTR pszBuffer = NULL;
    LPTSTR pszBufferEnd = NULL;
    DWORD dwValueType;
    DWORD cbRegistry;
    DWORD cbBuffer;
    DWORD cchPagefile;
    DWORD dwRetVal = ERROR_SUCCESS;

    __try {
        cchPagefile = lstrlen(pszPagefile) + 1;

        lResult = RegOpenKeyEx(
            HKEY_LOCAL_MACHINE,
            szSessionManager,
            0L,
            KEY_READ | KEY_WRITE,
            &hKey
        );
        if (ERROR_SUCCESS != lResult) {
            dwRetVal = lResult;
            __leave;
        } // if
        
        //
        // Find out of PendingFileRenameOperations exists, and,
        // if it does, how big it is
        //
        lResult = SHRegGetValue(
            hKey,
            NULL, 
            szPendingRename,
            SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND,
            &dwValueType,
            (LPBYTE) NULL,
            &cbRegistry
        );
        if (ERROR_SUCCESS != lResult) {
            //
            // If the value doesn't exist, we still need to set
            // it's size to one character so the formulas below (which are
            // written for the "we're appending to an existing string"
            // case) still work.
            //
            cbRegistry = sizeof(TCHAR);
        } // if

        //
        // Buffer needs to hold the existing registry value
        // plus the supplied pagefile path, plus two extra
        // terminating NULL characters.  However, we only have to add
        // room for one extra character, because we'll be overwriting
        // the terminating NULL character in the existing buffer.
        //
        cbBuffer = cbRegistry + ((cchPagefile + 1) * sizeof(TCHAR));

        pszBufferEnd = pszBuffer = (LPTSTR) LocalAlloc(LPTR, cbBuffer);
        if (!pszBuffer) {
            dwRetVal = ERROR_NOT_ENOUGH_MEMORY;
            __leave;
        } // if

        // 
        // Grab the existing value, if there is one
        //
        if (ERROR_SUCCESS == lResult) {
            lResult = SHRegGetValue(
                hKey,
                NULL, 
                szPendingRename,
                SRRF_RT_REG_SZ | SRRF_RT_REG_EXPAND_SZ | SRRF_NOEXPAND,
                &dwValueType,
                (LPBYTE) pszBuffer,
                &cbRegistry
            );
            if (ERROR_SUCCESS != lResult) {
                dwRetVal = ERROR_FILE_NOT_FOUND;
                __leave;
            } // if

            //
            // We'll start our scribbling right on the final
            // terminating NULL character of the existing 
            // value.
            //
            pszBufferEnd += (cbRegistry / sizeof(TCHAR)) - 1;
        } // if

        //
        // Copy in the supplied pagefile path.
        //
        if (FAILED(StringCchCopy(pszBufferEnd, cchPagefile, pszPagefile)))
        {
            dwRetVal = ERROR_INSUFFICIENT_BUFFER;
        }
        else
        {
            //
            // Add the final two terminating NULL characters
            // required for REG_MULTI_SZ-ness.  Yes, those indeces
            // are correct--when cchPagfile was calculated above,
            // we added one for its own terminating NULL character.
            //
            pszBufferEnd[cchPagefile] = TEXT('\0');
            pszBufferEnd[cchPagefile + 1] = TEXT('\0');

            dwValueType = REG_MULTI_SZ;

            lResult = RegSetValueEx(
                hKey,
                szPendingRename,
                0L,
                dwValueType,
                (CONST BYTE *) pszBuffer,
                cbBuffer
            );

            if (ERROR_SUCCESS != lResult) {
                dwRetVal = lResult;
            } // if
        }

    } // __try
    __finally {
        if (fhKeyOpened) 
        {
            RegCloseKey(hKey);
        } // if
        LocalFree(pszBuffer);
    } // __finally

    return dwRetVal;
}

/*
 * VirtualMemCreatePagefileFromIndex
 *
 *
 */
NTSTATUS
VirtualMemCreatePagefileFromIndex(
    IN INT i
)
{
    UNICODE_STRING us;
    LARGE_INTEGER liMin, liMax;
    NTSTATUS status;
    WCHAR wszPath[MAX_PATH*2];
    TCHAR szDrive[3];
    DWORD cch;

    HourGlass(TRUE);

    PathBuildRoot(szDrive, i);
    szDrive[2] = 0;
    cch = QueryDosDevice( szDrive, wszPath, ARRAYSIZE(wszPath));

    if (cch != 0) {

        // Concat the filename only (skip 'd:') to the nt device
        // path, and convert it to a UNICODE_STRING
        if (FAILED(StringCchCat(wszPath, ARRAYSIZE(wszPath), SZPageFileName(i) + 2)))
        {
            status = STATUS_BUFFER_OVERFLOW;
        }
        else
        {
            status = RtlInitUnicodeStringEx( &us, wszPath );
            if (status != STATUS_NAME_TOO_LONG)
            {
                liMin.QuadPart = ((LONGLONG)apf[i].nMinFileSize) * ONE_MEG;
                liMax.QuadPart = ((LONGLONG)apf[i].nMaxFileSize) * ONE_MEG;

                status = NtCreatePagingFile ( &us, &liMin, &liMax, 0L );
            }
        }

    }
    else
    {
        status = STATUS_NO_SUCH_DEVICE;
    }

    HourGlass(FALSE);

    return status;
}

/*
 * VirtualMemUpdateListboxFromIndex
 *
 */
void
VirtualMemUpdateListboxFromIndex(
    HWND hDlg,
    INT  i
)
{
    int j, cLBEntries, iTemp;
    int iLBEntry = -1;
    TCHAR szTemp[MAX_PATH];

    cLBEntries = (int)SendDlgItemMessage(
        (HWND) hDlg,
        (int) IDD_VM_VOLUMES,
        (UINT) LB_GETCOUNT,
        (WPARAM) 0,
        (LPARAM) 0
    );

    if (LB_ERR != cLBEntries) {
        // Loop through all the listbox entries, looking for the one
        // that corresponds to the drive index we were supplied.
        for (j = 0; j < cLBEntries; j++) {
            iTemp = (int)SendDlgItemMessage(
                (HWND) hDlg,
                (int) IDD_VM_VOLUMES,
                (UINT) LB_GETITEMDATA,
                (WPARAM) j,
                (LPARAM) 0
            );
            if (iTemp == i) {
                iLBEntry = j;
                break;
            } // if
        } // for

        if (-1 != iLBEntry) {
            // Found the desired entry, so update it.
            VirtualMemBuildLBLine(szTemp, ARRAYSIZE(szTemp), i);

            SendDlgItemMessage(
                hDlg,
                IDD_VM_VOLUMES,
                LB_DELETESTRING,
                (WPARAM) iLBEntry,
                0
            );

            SendDlgItemMessage(
                hDlg,
                IDD_VM_VOLUMES,
                LB_INSERTSTRING,
                (WPARAM) iLBEntry,
                (LPARAM) szTemp
            );

            SendDlgItemMessage(
                hDlg,
                IDD_VM_VOLUMES,
                LB_SETITEMDATA,
                (WPARAM) iLBEntry,
                (LPARAM) i
            );

            SendDlgItemMessage(
                hDlg,
                IDD_VM_VOLUMES,
                LB_SETCURSEL,
                (WPARAM) iLBEntry,
                0
            );

            if (apf[i].nMinFileSize) {
                SetDlgItemInt(hDlg, IDD_VM_SF_SIZE, apf[i].nMinFileSize, FALSE);
                SetDlgItemInt(hDlg, IDD_VM_SF_SIZEMAX, apf[i].nMaxFileSize, FALSE);
            }
            else {
                SetDlgItemText(hDlg, IDD_VM_SF_SIZE, TEXT(""));
                SetDlgItemText(hDlg, IDD_VM_SF_SIZEMAX, TEXT(""));
            }

            VirtualMemUpdateAllocated(hDlg);

        } // if (-1 != iLBEntry)


    } // if (LB_ERR...

    return;

}

/*
 * VirtualMemPromptForReboot
 *
 *
 *
 */

int
VirtualMemPromptForReboot(
    HWND hDlg
    )
{
    INT i, result;
    int iReboot = RET_NO_CHANGE;
    int iThisDrv;
    UNICODE_STRING us;
    LARGE_INTEGER liMin, liMax;
    NTSTATUS status;
    TCHAR szDrive[3];
    PRIVDAT pdOld;

    if (GetPageFilePrivilege(&pdOld)) 
    {
        // Have to make two passes through the list of pagefiles.
        // The first checks to see if files called "pagefile.sys" exist
        // on any of the drives that will be getting new pagefiles.
        // If there are existing files called "pagefile.sys" and the user
        // doesn't want any one of them to be overwritten, we bail out.
        // The second pass through the list does the actual work of
        // creating the pagefiles.

        for (i = 0; i < MAX_DRIVES; i++) {
            //
            // Did something change?
            //
            if (apf[i].nMinFileSize != apf[i].nMinFileSizePrev ||
                    apf[i].nMaxFileSize != apf[i].nMaxFileSizePrev ||
                    apf[i].fRamBasedPagefile != apf[i].fRamBasedPrev ||
                    apf[i].fCreateFile ) {
                // Assume we have permission to nuke existing files called pagefile.sys
                // (we'll confirm the assumption later)
                result = IDYES;
                if (0 != apf[i].nMinFileSize || FALSE != apf[i].fRamBasedPagefile) { // Pagefile wanted for this drive
                    if (0 == apf[i].nMinFileSizePrev) { // There wasn't one there before
                        if (!(((GetFileAttributes(SZPageFileName(i)) == 0xFFFFFFFF)) || (GetLastError() == ERROR_FILE_NOT_FOUND))) {
                            // A file named pagefile.sys exists on the drive
                            // We need to confirm that we can overwrite it
                            result = MsgBoxParam(
                                hDlg,
                                IDS_SYSDM_OVERWRITE,
                                IDS_SYSDM_TITLE,
                                MB_ICONQUESTION | MB_YESNO,
                                SZPageFileName(i)
                            );
                        } // if (!((GetFileAttributes...
                    } // if (0 == apf[i].nMinFileSizePrev)

                    if (IDYES != result) {
                        // User doesn't want us overwriting an existing
                        // file called pagefile.sys, so back out the changes
                        apf[i].nMinFileSize = apf[i].nMinFileSizePrev;
                        apf[i].nMaxFileSize = apf[i].nMaxFileSizePrev;
                        apf[i].fRamBasedPagefile = apf[i].fRamBasedPrev;
                        apf[i].fCreateFile = FALSE;

                        // Update the listbox
                        VirtualMemUpdateListboxFromIndex(hDlg, i);
                        SetFocus(GetDlgItem(hDlg, IDD_VM_VOLUMES));

                        // Bail, telling the DlgProc not to end the dialog
                        iReboot = RET_ERROR;
                        goto bailout;
                    } // if (IDYES != result)
                } // if (0 != apf[i].nMinFileSize)
            
            } // if
        } // for

        for (i = 0; i < MAX_DRIVES; i++)
        {
            //
            // Did something change?
            //
            if (apf[i].nMinFileSize != apf[i].nMinFileSizePrev ||
                    apf[i].nMaxFileSize != apf[i].nMaxFileSizePrev ||
                    apf[i].fRamBasedPagefile != apf[i].fRamBasedPrev ||
                    apf[i].fCreateFile ) {
                /*
                 * If we are strictly creating a *new* page file, or *enlarging*
                 * the minimum or maximum size of an existing page file, then
                 * we can try do it on the fly.  If no errors are returned by
                 * the system then no reboot will be required.
                 */

                // assume we will have to reboot
                iThisDrv = RET_VIRTUAL_CHANGE;

                /*
                 * IF we are creating a new page file
                 */
                if ((0 != apf[i].nMinFileSize || FALSE != apf[i].fRamBasedPagefile) && (0 == apf[i].nMinFileSizePrev)) {

                    status = VirtualMemCreatePagefileFromIndex(i);

                    if (NT_SUCCESS(status)) {
                        // made it on the fly, no need to reboot for this drive!
                        iThisDrv = RET_CHANGE_NO_REBOOT;
                    }
                }
                /*
                 * If we're enlarging the minimum or maximum size of an existing
                 * page file, we can try to do it on the fly
                 */
                else if ((apf[i].nMinFileSize != 0) &&
                    ((apf[i].nMinFileSize > apf[i].nMinFileSizePrev) ||
                    (apf[i].nMaxFileSize > apf[i].nMaxFileSizePrev))) {

                    status = VirtualMemCreatePagefileFromIndex(i);
                    if (NT_SUCCESS(status)) {
                        iThisDrv = RET_CHANGE_NO_REBOOT;
                    }

                } /* else if */

                // if this drive has changed, we must reboot
                if (RET_VIRTUAL_CHANGE == iThisDrv)
                {
                    iReboot |= RET_VIRTUAL_CHANGE;
                }

            }
        }

bailout:
        if (!ResetOldPrivilege( &pdOld ))
        {
            iReboot = RET_BREAK;
        }
    }

    //
    // If Nothing changed, then change our IDOK to IDCANCEL so System.cpl will
    // know not to reboot.
    //
    return iReboot;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\system\util.c ===
/*++

Microsoft Confidential
Copyright (c) 1992-1997  Microsoft Corporation
All rights reserved

Module Name:

    util.c

Abstract:

    Utility functions for System Control Panel Applet

Author:

    Eric Flo (ericflo) 19-Jun-1995

Revision History:

    15-Oct-1997 scotthal
        Complete overhaul

--*/
#include "sysdm.h"
#include <strsafe.h>
#include <ntdddisk.h>

//
// Constants
//
#define CCH_MAX_DEC 12             // Number of chars needed to hold 2^32

#define MAX_SWAPSIZE_X86        (4 * 1024)            // 4 Gb (number stored in megabytes)
#define MAX_SWAPSIZE_X86_PAE    (16 * 1024 * 1024)    // 16 Tb
#define MAX_SWAPSIZE_IA64       (32 * 1024 * 1024)    // 32 Tb
#define MAX_SWAPSIZE_AMD64      (16 * 1024 * 1024)    // 16 Tb

void
ErrMemDlg(
    IN HWND hParent
)
/*++

Routine Description:

    Displays "out of memory" message.

Arguments:

    hParent -
        Supplies parent window handle.

Return Value:

    None.

--*/
{
    MessageBox(
        hParent,
        g_szErrMem,
        g_szSystemApplet,
        MB_OK | MB_ICONHAND | MB_SYSTEMMODAL
    );
    return;
}

LPTSTR
SkipWhiteSpace(
    IN LPTSTR sz
)
/*++

Routine Description:

    SkipWhiteSpace
    For the purposes of this fuction, whitespace is space, tab,
    cr, or lf.

Arguments:

    sz -
        Supplies a string (which presumably has leading whitespace)

Return Value:

    Pointer to string without leading whitespace if successful.

--*/
{
    while( IsWhiteSpace(*sz) )
        sz++;

    return sz;
}

int 
StringToInt( 
    IN LPTSTR sz 
) 
/*++

Routine Description:

    TCHAR version of atoi

Arguments:

    sz -
        Supplies the string to convert

Return Value:

    Integer representation of the string

--*/
{
    int i = 0;

    sz = SkipWhiteSpace(sz);

    while( IsDigit( *sz ) ) {
        i = i * 10 + DigitVal( *sz );
        sz++;
    }

    return i;
}


BOOL 
Delnode_Recurse(
    IN LPTSTR lpDir
)
/*++

Routine Description:

    Recursive delete function for Delnode

Arguments:

    lpDir -
        Supplies directory to delete

Return Value:

    TRUE if successful.
    FALSE if an error occurs.

--*/
{
    WIN32_FIND_DATA fd;
    HANDLE hFile;

    //
    // Setup the current working dir
    //

    if (!SetCurrentDirectory (lpDir)) {
        return FALSE;
    }


    //
    // Find the first file
    //

    hFile = FindFirstFile(TEXT("*.*"), &fd);

    if (hFile == INVALID_HANDLE_VALUE) {

        if (GetLastError() == ERROR_FILE_NOT_FOUND) {
            return TRUE;
        } else {
            return FALSE;
        }
    }


    do {
        //
        // Check for "." and ".."
        //

        if (!lstrcmpi(fd.cFileName, TEXT("."))) {
            continue;
        }

        if (!lstrcmpi(fd.cFileName, TEXT(".."))) {
            continue;
        }


        if (fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) {

            //
            // Found a directory.
            //

            if (!Delnode_Recurse(fd.cFileName)) {
                FindClose(hFile);
                return FALSE;
            }

            if (fd.dwFileAttributes & FILE_ATTRIBUTE_READONLY) {
                fd.dwFileAttributes &= ~FILE_ATTRIBUTE_READONLY;
                SetFileAttributes (fd.cFileName, fd.dwFileAttributes);
            }


            RemoveDirectory (fd.cFileName);


        } else {

            //
            // We found a file.  Set the file attributes,
            // and try to delete it.
            //

            if ((fd.dwFileAttributes & FILE_ATTRIBUTE_READONLY) ||
                (fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)) {
                SetFileAttributes (fd.cFileName, FILE_ATTRIBUTE_NORMAL);
            }

            DeleteFile (fd.cFileName);

        }


        //
        // Find the next entry
        //

    } while (FindNextFile(hFile, &fd));


    //
    // Close the search handle
    //

    FindClose(hFile);


    //
    // Reset the working directory
    //

    if (!SetCurrentDirectory (TEXT(".."))) {
        return FALSE;
    }


    //
    // Success.
    //

    return TRUE;
}


BOOL 
Delnode(
    IN LPTSTR lpDir
)
/*++

Routine Description:

    Recursive function that deletes files and
    directories.

Arguments:

    lpDir -
        Supplies directory to delete.

Return Value:

    TRUE if successful
    FALSE if an error occurs

--*/
{
    TCHAR szCurWorkingDir[MAX_PATH];

    if (GetCurrentDirectory(ARRAYSIZE(szCurWorkingDir), szCurWorkingDir)) {

        Delnode_Recurse (lpDir);

        SetCurrentDirectory (szCurWorkingDir);

        if (!RemoveDirectory (lpDir)) {
            return FALSE;
        }

    } else {
        return FALSE;
    }

    return TRUE;

}

LONG 
MyRegSaveKey(
    IN HKEY hKey, 
    IN LPCTSTR lpSubKey
)
/*++

Routine Description:

    Saves a registry key.

Arguments:

    hKey -
        Supplies handle to a registry key.

    lpSubKey -
        Supplies the name of the subkey to save.

Return Value:

    ERROR_SUCCESS if successful.
    Error code from RegSaveKey() if an error occurs.

--*/
{

    HANDLE hToken = NULL;
    LUID luid;
    DWORD dwSize = 1024;
    PTOKEN_PRIVILEGES lpPrevPrivilages = NULL;
    TOKEN_PRIVILEGES tp;
    LONG error;


    //
    // Allocate space for the old privileges
    //

    lpPrevPrivilages = GlobalAlloc(GPTR, dwSize);

    if (!lpPrevPrivilages) {
        error = GetLastError();
        goto Exit;
    }


    if (!OpenProcessToken( GetCurrentProcess(),
                           TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, 
                           &hToken)) {
        error = GetLastError();
        goto Exit;
    }

    if (!LookupPrivilegeValue( NULL, SE_BACKUP_NAME, &luid )) {
        error = GetLastError();
        goto Exit;
    }

    tp.PrivilegeCount           = 1;
    tp.Privileges[0].Luid       = luid;
    tp.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    if (!AdjustTokenPrivileges( hToken, FALSE, &tp, dwSize, 
                                lpPrevPrivilages, &dwSize )) {

        if (GetLastError() == ERROR_MORE_DATA) {
            PTOKEN_PRIVILEGES lpTemp;

            lpTemp = GlobalReAlloc(lpPrevPrivilages, dwSize, GMEM_MOVEABLE);

            if (!lpTemp) {
                error = GetLastError();
                goto Exit;
            }

            lpPrevPrivilages = lpTemp;

            if (!AdjustTokenPrivileges( hToken, FALSE, &tp, dwSize, 
                                        lpPrevPrivilages, &dwSize )) {
                error = GetLastError();
                goto Exit;
            }

        } else {
            error = GetLastError();
            goto Exit;
        }

    }

    //
    // Save the hive
    //

    error = RegSaveKey(hKey, lpSubKey, NULL);

    if (!AdjustTokenPrivileges( hToken, FALSE, lpPrevPrivilages,
                                0, NULL, NULL )) {
        ASSERT(FALSE);
    }

Exit:

    if (hToken) {
        CloseHandle (hToken);
    }

    if (lpPrevPrivilages) {
        GlobalFree(lpPrevPrivilages);
    }

    return error;
}

LONG 
MyRegLoadKey(
    IN HKEY hKey, 
    IN LPTSTR lpSubKey, 
    IN LPTSTR lpFile
)
/*++

Routine Description:

    Loads a hive into the registry

Arguments:

    hKey -
        Supplies a handle to a registry key which will be the parent
        of the created key.

    lpSubKey -
        Supplies the name of the subkey to create.

    lpFile -
        Supplies the name of the file containing the hive.

Return Value:

    ERROR_SUCCESS if successful.
    Error code from RegLoadKey if unsuccessful.

--*/
{
    NTSTATUS Status;
    BOOLEAN WasEnabled;
    int error;

    //
    // Enable the restore privilege
    //

    Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);

    if (NT_SUCCESS(Status)) {

        error = RegLoadKey(hKey, lpSubKey, lpFile);

        //
        // Restore the privilege to its previous state
        //

        RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);


    } else {

        error = GetLastError();
    }

    return error;
}


LONG 
MyRegUnLoadKey(
    IN HKEY hKey, 
    IN LPTSTR lpSubKey
)
/*++

Routine Description:

    Unloads a registry key.

Arguments:

    hKey -
        Supplies handle to parent key

    lpSubKey -
        Supplies name of subkey to delete

Return Value:

    ERROR_SUCCESS if successful
    Error code if unsuccessful

--*/
{
    LONG error;
    NTSTATUS Status;
    BOOLEAN WasEnabled;


    //
    // Enable the restore privilege
    //

    Status = RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, TRUE, FALSE, &WasEnabled);

    if (NT_SUCCESS(Status)) {

        error = RegUnLoadKey(hKey, lpSubKey);

        //
        // Restore the privilege to its previous state
        //

        RtlAdjustPrivilege(SE_RESTORE_PRIVILEGE, WasEnabled, FALSE, &WasEnabled);

    } else {

        error = GetLastError();
    }

    return error;
}

int 
GetSelectedItem(
    IN HWND hCtrl
)
/*++

Routine Description:
    
    Determines which item in a list view control is selected

Arguments:

    hCtrl -
        Supplies handle to the desired list view control.

Return Value:

    The index of the selected item, if an item is selected.
    -1 if no item is selected.

--*/
{
    int i, n;

    n = (int)SendMessage (hCtrl, LVM_GETITEMCOUNT, 0, 0L);

    if (n != LB_ERR)
    {
        for (i = 0; i < n; i++)
        {
            if (SendMessage (hCtrl, LVM_GETITEMSTATE,
                             i, (LPARAM) LVIS_SELECTED) == LVIS_SELECTED) {
                return i;
            }
        }
    }

    return -1;
}

BOOL
_DriveIsNTFS(
    INT iDrive // drive to check on
)
{
    TCHAR szDrive[4];
    TCHAR szDriveNameBuffer[MAX_PATH];
    DWORD dwMaxFnameLen;
    DWORD dwFSFlags;
    TCHAR szDriveFormatName[MAX_PATH];
    BOOL fRetVal = FALSE;
    
    PathBuildRoot(szDrive, iDrive);
    if (GetVolumeInformation(szDrive, szDriveNameBuffer, ARRAYSIZE(szDriveNameBuffer), NULL, 
                             &dwMaxFnameLen, &dwFSFlags, szDriveFormatName, ARRAYSIZE(szDriveFormatName)))
    {
        if (StrStrI(szDriveFormatName, TEXT("NTFS")))
        {
            fRetVal = TRUE;
        }
    }

    return fRetVal;
}


DWORD
GetMaxPagefileSizeInMB(
    INT iDrive // drive to check on
)
{
#if defined(_AMD64_)
    return MAX_SWAPSIZE_AMD64;
#elif defined(_X86_)
    if ((USER_SHARED_DATA->ProcessorFeatures[PF_PAE_ENABLED]) && _DriveIsNTFS(iDrive))
    {
        return MAX_SWAPSIZE_X86_PAE;
    }
    else
    {
        return MAX_SWAPSIZE_X86;
    }
#elif defined(_IA64_)
    return MAX_SWAPSIZE_IA64;
#else
    return 0;
#endif
}

int 
MsgBoxParam( 
    IN HWND hWnd, 
    IN DWORD wText, 
    IN DWORD wCaption, 
    IN DWORD wType, 
    ... 
)
/*++

Routine Description:

    Combination of MessageBox and printf

Arguments:

    hWnd -
        Supplies parent window handle

    wText -
        Supplies ID of a printf-like format string to display as the
        message box text

    wCaption -
        Supplies ID of a string to display as the message box caption

    wType -
        Supplies flags to MessageBox()

Return Value:

    Whatever MessageBox() returns.

--*/

{
    TCHAR   szText[ 4 * MAX_PATH ], szCaption[ 2 * MAX_PATH ];
    int     ival;
    va_list parg;

    va_start( parg, wType );

    if( wText == IDS_INSUFFICIENT_MEMORY )
        goto NoMem;

    if( !LoadString( hInstance, wText, szCaption, ARRAYSIZE( szCaption ) ) )
        goto NoMem;

    if (FAILED(StringCchVPrintf(szText, ARRAYSIZE(szText), szCaption, parg)))
        goto NoMem;
    if( !LoadString( hInstance, wCaption, szCaption, ARRAYSIZE( szCaption ) ) )
        goto NoMem;
    if( (ival = MessageBox( hWnd, szText, szCaption, wType ) ) == 0 )
        goto NoMem;

    va_end( parg );

    return( ival );

NoMem:
    va_end( parg );

    ErrMemDlg( hWnd );
    return 0;
}


DWORD 
SetLBWidthEx(
    IN HWND hwndLB, 
    IN LPTSTR szBuffer, 
    IN DWORD cxCurWidth, 
    IN DWORD cxExtra
)
/*++

Routine Description:

    Set the width of a listbox, in pixels, acording to the size of the
    string passed in

Arguments:

    hwndLB -
        Supples listbox to resize

    szBuffer -
        Supplies string to resize listbox to

    cxCurWidth -
        Supplies current width of the listbox

    cxExtra -
        Supplies some kind of slop factor

Return Value:

    The new width of the listbox

--*/
{
    HDC     hDC;
    SIZE    Size;
    LONG    cx;
    HFONT   hfont, hfontOld;

    // Get the new Win4.0 thin dialog font
    hfont = (HFONT)SendMessage(hwndLB, WM_GETFONT, 0, 0);

    hDC = GetDC(hwndLB);

    // if we got a font back, select it in this clean hDC
    if (hfont != NULL)
        hfontOld = SelectObject(hDC, hfont);


    // If cxExtra is 0, then give our selves a little breathing space.
    if (cxExtra == 0) {
        GetTextExtentPoint32(hDC, TEXT("1234"), 4 /* lstrlen("1234") */, &Size);
        cxExtra = Size.cx;
    }

    // Set scroll width of listbox

    GetTextExtentPoint32(hDC, szBuffer, lstrlen(szBuffer), &Size);

    Size.cx += cxExtra;

    // Get the name length and adjust the longest name

    if ((DWORD) Size.cx > cxCurWidth)
    {
        cxCurWidth = Size.cx;
        SendMessage (hwndLB, LB_SETHORIZONTALEXTENT, (DWORD)Size.cx, 0L);
    }

    // retstore the original font if we changed it
    if (hfont != NULL)
        SelectObject(hDC, hfontOld);

    ReleaseDC(NULL, hDC);

    return cxCurWidth;
}

VOID 
SetDefButton(
    IN HWND hwndDlg,
    IN int idButton
)
/*++

Routine Description:

    Sets the default button for a dialog box or proppage
    The old default button, if any,  has its default status removed

Arguments:

    hwndDlg -
        Supplies window handle

    idButton -
        Supplies ID of button to make default

Return Value:

    None

--*/
{
    LRESULT lr;

    if (HIWORD(lr = SendMessage(hwndDlg, DM_GETDEFID, 0, 0)) == DC_HASDEFID)
    {
        HWND hwndOldDefButton = GetDlgItem(hwndDlg, LOWORD(lr));

        SendMessage (hwndOldDefButton,
                     BM_SETSTYLE,
                     MAKEWPARAM(BS_PUSHBUTTON, 0),
                     MAKELPARAM(TRUE, 0));
    }

    SendMessage( hwndDlg, DM_SETDEFID, idButton, 0L );
    SendMessage( GetDlgItem(hwndDlg, idButton),
                 BM_SETSTYLE,
                 MAKEWPARAM( BS_DEFPUSHBUTTON, 0 ),
                 MAKELPARAM( TRUE, 0 ));
}


void 
HourGlass( 
    IN BOOL bOn 
)
/*++

Routine Description:

    Turns hourglass mouse cursor on or off

Arguments:

    bOn -
        Supplies desired status of hourglass mouse cursor

Return Value:

    None

--*/
{
    if( !GetSystemMetrics( SM_MOUSEPRESENT ) )
        ShowCursor( bOn );

    SetCursor( LoadCursor( NULL, bOn ? IDC_WAIT : IDC_ARROW ) );
}

VCREG_RET 
OpenRegKey( 
    IN LPTSTR pszKeyName, 
    OUT PHKEY phk 
) 
/*++

Routine Description:

    Opens a subkey of HKEY_LOCAL_MACHINE

Arguments:

    pszKeyName -
        Supplies the name of the subkey to open

    phk -
        Returns a handle to the key if successfully opened
        Returns NULL if an error occurs

Return Value:

    VCREG_OK if successful
    VCREG_READONLY if the key was opened with read-only access
    VCREG_OK if an error occurred

*/
{
    LONG Error;

    Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszKeyName, 0,
            KEY_READ | KEY_WRITE, phk);

    if (Error != ERROR_SUCCESS)
    {
        Error = RegOpenKeyEx(HKEY_LOCAL_MACHINE, pszKeyName, 0, KEY_READ, phk);

        if (Error != ERROR_SUCCESS)
        {
            *phk = NULL;
            return VCREG_ERROR;
        }

        /*
         * We only have Read access.
         */
        return VCREG_READONLY;
    }

    return VCREG_OK;
}

LONG    
CloseRegKey( 
    IN HKEY hkey 
) 
/*++

Routine Description:

    Closes a registry key opened by OpenRegKey()

Arguments:

    hkey -
        Supplies handle to key to close

Return Value:

    Whatever RegCloseKey() returns

--*/
{
    return RegCloseKey(hkey);
}

/*
 * UINT VMGetDriveType( LPCTSTR lpszDrive )
 *
 * Gets the drive type.  This function differs from Win32's GetDriveType
 * in that it returns DRIVE_FIXED for lockable removable drives (like
 * bernolli boxes, etc).
 *
 * On IA64 we don't do this, however, requiring all pagefiles be on actual
 * fixed drives.
 */
const TCHAR c_szDevice[] = TEXT("\\Device");

UINT VMGetDriveType( LPCTSTR lpszDrive ) {
    UINT i;
    TCHAR szDevName[MAX_PATH];

    ASSERT(tolower(*lpszDrive) >= 'a' && tolower(*lpszDrive) <= 'z');

    // Check for subst drive
    if (QueryDosDevice( lpszDrive, szDevName, ARRAYSIZE( szDevName ) ) != 0) {

        // If drive does not start with '\Device', then it is not FIXED
        szDevName[ARRAYSIZE(c_szDevice) - 1] = '\0';
        if ( lstrcmpi(szDevName, c_szDevice) != 0 ) {
            return DRIVE_REMOTE;
        }
    }

    i = GetDriveType( lpszDrive );
#ifndef _WIN64
    if ( i == DRIVE_REMOVABLE ) {
        TCHAR szNtDrive[20];
        DWORD cb;
        DISK_GEOMETRY dgMediaInfo;
        HANDLE hDisk;

        /*
         * 'Removable' drive.  Check to see if it is a Floppy or lockable
         * drive.
         */

        if (SUCCEEDED(PathBuildFancyRoot(szNtDrive, ARRAYSIZE(szNtDrive), tolower(lpszDrive[0]) - 'a')))
        {
            hDisk = CreateFile(
                        szNtDrive,
                        /* GENERIC_READ */ 0,
                        FILE_SHARE_READ | FILE_SHARE_WRITE,
                        NULL,
                        OPEN_EXISTING,
                        0,
                        NULL
                        ); // fine

            if (hDisk != INVALID_HANDLE_VALUE ) {

                if (DeviceIoControl( hDisk, IOCTL_DISK_GET_MEDIA_TYPES, NULL,
                        0, &dgMediaInfo, sizeof(dgMediaInfo), &cb, NULL) == FALSE &&
                        GetLastError() != ERROR_MORE_DATA) {
                    /*
                     * Drive is not a floppy
                     */
                    i = DRIVE_FIXED;
                }

                CloseHandle(hDisk);
            } else if (GetLastError() == ERROR_ACCESS_DENIED) {
                /*
                 * Could not open the drive, either it is bad, or else we
                 * don't have permission.  Since everyone has permission
                 * to open floppies, then this must be a bernoulli type device.
                 */
                i = DRIVE_FIXED;
            }
        }
    }
#endif
    return i;
}

STDAPI
PathBuildFancyRoot(
    LPTSTR szRoot,
    UINT cchRoot,
    int iDrive
)
{
    return StringCchPrintf(szRoot, cchRoot, TEXT("\\\\.\\%c:"), iDrive + 'a');
}

__inline BOOL
_SafeGetHwndTextAux(
    HWND hwnd,
    UINT ulIndex,
    UINT msgGetLen,
    UINT msgGetString,
    LRESULT err,
    LPTSTR pszBuffer,
    UINT cchBuffer)
{
    BOOL fRet = FALSE;
    UINT cch = (UINT)SendMessage(hwnd, msgGetLen, (WPARAM)ulIndex, 0);
    if (cch < cchBuffer &&
        cch != err)
    {
        if (err != SendMessage(hwnd, msgGetString, (WPARAM)ulIndex, (LPARAM)pszBuffer))
        {
            fRet = TRUE;
        }

    }
    return fRet;
}

BOOL
SafeGetComboBoxListText(
    HWND hCombo,
    UINT ulIndex,
    LPTSTR pszBuffer,
    UINT cchBuffer)
{
    return _SafeGetHwndTextAux(hCombo, ulIndex, 
                               CB_GETLBTEXTLEN, CB_GETLBTEXT, CB_ERR,
                               pszBuffer, cchBuffer);
}

BOOL
SafeGetListBoxText(
    HWND hCombo,
    UINT ulIndex,
    LPTSTR pszBuffer,
    UINT cchBuffer)
{
    return _SafeGetHwndTextAux(hCombo, ulIndex, 
                               LB_GETTEXTLEN, LB_GETTEXT, LB_ERR,
                               pszBuffer, cchBuffer);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\utc\calendar.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    calendar.c

Abstract:

    This module implements the calendar control for the Date/Time applet.

Revision History:

--*/



//
//  Include Files.
//

#include "timedate.h"
#include "rc.h"




//
//  Constant Declarations.
//

#define DEF_FIRST_WEEKDAY   (6)

#define cBorderX             5
#define cBorderY             3
#define cBorderSelect        1

#define IS_FE_LANGUAGE(p)    (((p) == LANG_CHINESE)  ||         \
                              ((p) == LANG_JAPANESE) ||         \
                              ((p) == LANG_KOREAN))




//
//  Typedef Declarations.
//

//
//  Struture for global data.
//
typedef struct _CALINFO
{
    HWND    hwnd;       // the hwnd
    HFONT   hfontCal;   // the font to use
    BOOL    fFocus;     // do we have the focus
    int     cxBlank;    // size of a blank
    int     cxChar;     // the width of digits
    int     cyChar;     // the height of digits
} CALINFO, *PCALINFO;




////////////////////////////////////////////////////////////////////////////
//
//  GetFirstDayOfAnyWeek
//
//  For this function ONLY:
//    0 = Monday
//    6 = Sunday
//
////////////////////////////////////////////////////////////////////////////

int GetFirstDayOfAnyWeek()
{
    static int iDay = -1;

    if (iDay < 0)
    {
        TCHAR ch[2] = { 0 };

        *ch = TEXT('0') + DEF_FIRST_WEEKDAY;

        GetLocaleInfo(LOCALE_USER_DEFAULT, LOCALE_IFIRSTDAYOFWEEK, ch, 2);

        iDay = ( ((*ch >= TEXT('0')) && (*ch <= TEXT('6')))
                     ? ((int)*ch - TEXT('0'))
                     : DEF_FIRST_WEEKDAY );
    }

    return (iDay);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetLocalWeekday
//
////////////////////////////////////////////////////////////////////////////

int GetLocalWeekday()
{
    //
    //  Convert local first day to 0==sunday and subtract from today.
    //
    return ((wDateTime[WEEKDAY] + 7 - ((GetFirstDayOfAnyWeek() + 1) % 7)) % 7);
}

void DetermineDayOfWeek()
{
    FILETIME   FileTime;
    SYSTEMTIME SystemTime;

    SystemTime.wHour   = wDateTime[HOUR];
    SystemTime.wMinute = wDateTime[MINUTE];
    SystemTime.wSecond = wDateTime[SECOND];

    SystemTime.wMilliseconds = 0;

    SystemTime.wMonth  = wDateTime[MONTH];
    SystemTime.wDay    = wDateTime[DAY];
    SystemTime.wYear   = wDateTime[YEAR];
    SystemTimeToFileTime(&SystemTime, &FileTime);
    FileTimeToSystemTime(&FileTime, &SystemTime);
    wDateTime[WEEKDAY] = SystemTime.wDayOfWeek;
}

////////////////////////////////////////////////////////////////////////////
//
//  GetFirstDayOfTheMonth
//
////////////////////////////////////////////////////////////////////////////

int GetFirstDayOfTheMonth()
{
    DetermineDayOfWeek();
    return ((GetLocalWeekday() + 8 - (wDateTime[DAY] % 7)) % 7);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDaysOfTheMonth
//
////////////////////////////////////////////////////////////////////////////

int GetDaysOfTheMonth(
    int iMonth)
{
    int cDays;
    int nYear;

    //
    //  Calculate the number of days in the current month -
    //  add one if this is a leap year and the month is February.
    //
    if (iMonth <= 7)
    {
        cDays = 30 + (iMonth % 2);
    }
    else
    {
        cDays = 31 - (iMonth % 2);
    }

    if (iMonth == 2)
    {
        cDays = 28;
        nYear = wDateTime[YEAR];
        if ((nYear % 4 == 0) && ((nYear % 100 != 0) || (nYear % 400 == 0)))
        {
            cDays++;
        }
    }

    return (cDays);
}


////////////////////////////////////////////////////////////////////////////
//
//  AdjustDeltaDay
//
//  Adjust the day part of the current date
//
////////////////////////////////////////////////////////////////////////////

void AdjustDeltaDay(
    HWND hwnd,
    int iDay)
{
    GetTime();

    if (wDateTime[DAY] != iDay)
    {
        wPrevDateTime[DAY] = wDateTime[DAY] = (WORD)iDay;
        fDateDirty = TRUE;

        //
        //  Let our parent know that we changed.
        //
        FORWARD_WM_COMMAND( GetParent(hwnd),
                            GetWindowLong(hwnd, GWL_ID),
                            hwnd,
                            CBN_SELCHANGE,
                            SendMessage );
    }
}

int GetCalendarName(LPTSTR pszName, int cch)
{
    TCHAR    szDateString[100];
    SYSTEMTIME SystemTime;
    int cchResult = 0;

    SystemTime.wHour   = wDateTime[HOUR];
    SystemTime.wMinute = wDateTime[MINUTE];
    SystemTime.wSecond = wDateTime[SECOND];

    SystemTime.wMilliseconds = 0;

    SystemTime.wMonth  = wDateTime[MONTH];
    SystemTime.wDay    = wDateTime[DAY];
    SystemTime.wYear   = wDateTime[YEAR];

    if (0 != GetDateFormat(LOCALE_USER_DEFAULT, DATE_LONGDATE,
        &SystemTime, NULL, szDateString, ARRAYSIZE(szDateString)))
    {
        if ( NULL != pszName )
        {
            StringCchCopy( pszName, cch, szDateString );
        }

        cchResult = lstrlen(szDateString);
    }
    
    return cchResult;
}


////////////////////////////////////////////////////////////////////////////
//
//  ChangeCurrentDate
//
//  If we pass in iNewCol < 0, we simply want to invalidate todays date.
//  This is used when we gain and lose focus.
//
////////////////////////////////////////////////////////////////////////////

void ChangeCurrentDate(
    PCALINFO pci,
    int iNewCol,
    int iNewRow)
{
    int iFirstDay, iRow, iColumn;
    RECT rc, rcT;

    GetClientRect(pci->hwnd, &rc);
    iFirstDay = GetFirstDayOfTheMonth();
    iColumn = (wDateTime[DAY] - 1 + iFirstDay) % 7;
    iRow = 1 + ((wDateTime[DAY] - 1 + iFirstDay) / 7);

    rcT.left = (((rc.right - rc.left) * iColumn) / 7) + cBorderX - cBorderSelect;
    rcT.right = rcT.left + (pci->cxChar * 2) + (2 * cBorderSelect);
    rcT.top = ((rc.bottom - rc.top) * iRow ) / 7 + cBorderY - cBorderSelect;
    rcT.bottom = rcT.top + pci->cyChar + (2 * cBorderSelect);

    InvalidateRect(pci->hwnd, &rcT, FALSE);

    if (iNewCol >= 0)
    {
        AdjustDeltaDay(pci->hwnd, ((iNewRow - 1) * 7) + iNewCol + 1 - iFirstDay);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CalendarPaint
//
////////////////////////////////////////////////////////////////////////////

BOOL CalendarPaint(
    PCALINFO pci,
    HWND hwnd)
{
    RECT rc, rcT;
    PAINTSTRUCT ps;
    HDC hdc;
    int iWeek, iWeekDay, iDay, iMaxDays;
    int iFirstDayOfWeek, iFirstDayOfMonth;
    TCHAR pszDate[3];
    TCHAR szShortDay[25];
    DWORD dwbkColor;
    COLORREF o_TextColor;
    LCID Locale;
    LANGID LangID = GetUserDefaultLangID();
    BOOL IsFELang = IS_FE_LANGUAGE(PRIMARYLANGID(LangID));

    iFirstDayOfMonth = GetFirstDayOfTheMonth();
    iMaxDays = GetDaysOfTheMonth(wDateTime[MONTH]);
    iDay = 1;
    pszDate[0] = TEXT(' ');
    pszDate[1] = TEXT('0');

    //
    //  Paint the background of the dates page.
    //
    hdc = BeginPaint(hwnd, &ps);
    GetClientRect(hwnd, &rc);
    FillRect(hdc, &rc, GetSysColorBrush(COLOR_WINDOW));

    //
    //  The day specifier.
    //
    rcT.left = rc.left;
    rcT.right = rc.right;
    rcT.top = rc.top;
    rcT.bottom = rc.top + ((rc.bottom - rc.top) / 7);
    FillRect(hdc, &rcT, GetSysColorBrush(COLOR_INACTIVECAPTION));

    //
    //  Fill the page.
    //
    SetBkColor(hdc, GetSysColor(COLOR_WINDOW));
    SelectFont(hdc, pci->hfontCal);
    SetTextColor(hdc, GetSysColor(COLOR_WINDOWTEXT));

    //
    //  See if we need to calculate the size of characters.
    //
    if (pci->cxChar == 0)
    {
        DrawText(hdc, TEXT("0"), 1, &rcT, DT_CALCRECT);
        pci->cxChar = rcT.right - rcT.left;
        pci->cyChar = rcT.bottom - rcT.top;

        DrawText(hdc, TEXT(" "), 1, &rcT, DT_CALCRECT);
        pci->cxBlank = rcT.right - rcT.left;
    }

    for (iWeek = 1; (iWeek < 7); iWeek++)
    {
        for (iWeekDay = iFirstDayOfMonth;
             (iWeekDay < 7) && (iDay <= iMaxDays);
             iWeekDay++)
        {
            rcT.left = ((((rc.right - rc.left) * iWeekDay) / 7)) + cBorderX;
            rcT.top = (((rc.bottom - rc.top) * iWeek) / 7) + cBorderY;
            rcT.right = rcT.left + 20;
            rcT.bottom = rcT.top + 20;

            if (pszDate[1] == TEXT('9'))
            {
                pszDate[1] = TEXT('0');

                if (pszDate[0] == TEXT(' '))
                {
                    pszDate[0] = TEXT('1');
                }
                else
                {
                    pszDate[0] = pszDate[0] + 1;
                }
            }
            else
            {
                pszDate[1] = pszDate[1] + 1;
            }

            if (wDateTime[DAY] == iDay)
            {
                dwbkColor = GetBkColor(hdc);
                SetBkColor(hdc, GetSysColor(COLOR_ACTIVECAPTION));
                o_TextColor = GetTextColor(hdc);
                SetTextColor(hdc, GetSysColor(COLOR_CAPTIONTEXT));
            }

            ExtTextOut( hdc,
                        rcT.left,
                        rcT.top,
                        0,
                        &rcT,
                        (LPTSTR)pszDate,
                        2,
                        NULL );

            //
            //  If we drew it inverted - put it back.
            //
            if (wDateTime[DAY] == iDay)
            {
                //
                //  If we have the focus we also need to draw the focus
                //  rectangle for this item.
                //
                if (pci->fFocus)
                {
                    rcT.bottom = rcT.top + pci->cyChar;

                    if (iDay <= 9)
                    {
                        rcT.right = rcT.left + pci->cxChar + pci->cxBlank;
                    }
                    else
                    {
                        rcT.right = rcT.left + 2 * pci->cxChar;
                    }

                    DrawFocusRect(hdc, &rcT);
                }

                SetBkColor(hdc, dwbkColor);
                SetTextColor(hdc, o_TextColor);
            }

            iFirstDayOfMonth = 0;
            iDay++;
        }
    }

    //
    //  Set the FONT color for the SMTWTFS line.
    //
    dwbkColor = SetBkColor(hdc, GetSysColor(COLOR_INACTIVECAPTION));
    SetTextColor(hdc, GetSysColor(COLOR_INACTIVECAPTIONTEXT));

    iFirstDayOfWeek = GetFirstDayOfAnyWeek();

    if (!IsFELang)
    {
        //
        //  Not a FE locale.
        //
        //  If it's Arabic or Syriac, then we want to use the US locale to get the
        //  first letter of the abbreviated day name to display in the calendar.
        //
        Locale = ((PRIMARYLANGID(LangID) == LANG_ARABIC) || (PRIMARYLANGID(LangID) == LANG_SYRIAC))
                   ? MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT), SORT_DEFAULT)
                   : LOCALE_USER_DEFAULT;

        for (iWeekDay = 0; (iWeekDay < 7); iWeekDay++)
        {
            GetLocaleInfo( Locale,
                           LOCALE_SABBREVDAYNAME1 + (iWeekDay + iFirstDayOfWeek) % 7,
                           szShortDay,
                           sizeof(szShortDay) / sizeof(TCHAR) );

            if (*szShortDay)
            {
                *szShortDay = (TCHAR)CharUpper((LPTSTR)(DWORD_PTR)*szShortDay);
            }

            TextOut( hdc,
                     (((rc.right - rc.left) * iWeekDay) / 7) + cBorderX,
                     cBorderY,
                     szShortDay,
                     1 );
        }
    }
    else
    {
        //
        //  FE Locale.
        //
        for (iWeekDay = 0; (iWeekDay < 7); iWeekDay++)
        {
            GetLocaleInfo( LOCALE_USER_DEFAULT,
                           LOCALE_SABBREVDAYNAME1 + (iWeekDay + iFirstDayOfWeek) % 7,
                           szShortDay,
                           sizeof(szShortDay) / sizeof(TCHAR) );

            if (*szShortDay)
            {
                *szShortDay = (TCHAR)CharUpper((LPTSTR)(DWORD_PTR)*szShortDay);
            }

            if ((PRIMARYLANGID(LangID) == LANG_CHINESE) &&
                (lstrlen(szShortDay) == 3 ))
            {
                TextOut( hdc,
                         (((rc.right - rc.left) * iWeekDay) / 7) + cBorderX,
                         cBorderY,
                         (LangID == MAKELANGID( LANG_CHINESE,
                                                SUBLANG_CHINESE_HONGKONG ))
                           ? szShortDay
                           : szShortDay + 2,
                         1 );
            }
            else
            {
                TextOut( hdc,
                         (((rc.right - rc.left) * iWeekDay) / 7) + cBorderX,
                         cBorderY,
                         szShortDay,
                         lstrlen(szShortDay) );
            }
        }
    }

    SetBkColor(hdc, dwbkColor);
    EndPaint(hwnd, &ps);
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsValidClick
//
////////////////////////////////////////////////////////////////////////////

BOOL IsValidClick(
    HWND hwnd,
    int x,
    int y)
{
    int iT;

    if (y == 0)
    {
        return (FALSE);
    }

    iT = GetFirstDayOfTheMonth();

    if ((y == 1) && (x < iT))
    {
        return (FALSE);
    }

    iT += GetDaysOfTheMonth(wDateTime[MONTH]) - 1;

    if (y > ((iT / 7) + 1))
    {
        return (FALSE);
    }

    if ((y == ((iT / 7) + 1)) && (x > (iT % 7)))
    {
        return (FALSE);
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  HandleDateChange
//
////////////////////////////////////////////////////////////////////////////

BOOL HandleDateChange(
    PCALINFO pci,
    int x,
    int y)
{
    RECT rc, rcT;
    int ix, iy;

    GetClientRect(pci->hwnd, &rc);

    ix = (x * 7) / (rc.right - rc.left);
    iy = (y * 7) / (rc.bottom - rc.top);

    if (IsValidClick(pci->hwnd, ix, iy))
    {
        rcT.left = (((rc.right - rc.left) * ix)/ 7) + cBorderX - cBorderSelect;
        rcT.right = rcT.left + (2 * pci->cxChar) + (2 * cBorderSelect);
        rcT.top = ((rc.bottom - rc.top) * iy) / 7 + cBorderY - cBorderSelect;
        rcT.bottom = rcT.top + pci->cyChar + (2 * cBorderSelect);

        InvalidateRect(pci->hwnd, &rcT, FALSE);
        ChangeCurrentDate( pci,
                           (x * 7) / (rc.right - rc.left),
                           (y * 7) / (rc.bottom - rc.top) );

        NotifyWinEvent(EVENT_OBJECT_NAMECHANGE , pci->hwnd, OBJID_WINDOW, CHILDID_SELF);
        return (TRUE);
    }
    else
    {
        return (FALSE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  HandleKeyDown
//
////////////////////////////////////////////////////////////////////////////

void HandleKeyDown(
    PCALINFO pci,
    int vk,
    LPARAM lParam)
{
    RECT rcT;

    //
    //  First thing, lets try to figure out what the current x and y is.
    //
    int ix = GetLocalWeekday();
    int iy = (wDateTime[DAY] + GetFirstDayOfTheMonth() - 1) / 7;

    switch (vk)
    {
        case ( VK_LEFT ) :
        {
            ix--;
            if (ix < 0)
            {
                ix = 6;
                iy--;
            }
            break;
        }
        case ( VK_RIGHT ) :
        {
            ix++;
            if (ix == 7)
            {
                ix = 0;
                iy++;
            }
            break;
        }
        case ( VK_UP ) :
        {
            iy--;
            break;
        }
        case ( VK_DOWN ) :
        {
            iy++;
            break;
        }
        default :
        {
            //
            //  Ignore the character.
            //
            return;
        }
    }

    //
    //  The y's are offset for the days of the week.
    //
    iy++;
    if (!IsValidClick(pci->hwnd, ix, iy))
    {
        return;
    }

    GetClientRect(pci->hwnd, &rcT);
    rcT.left = ((rcT.right * ix) / 7) + cBorderX - cBorderSelect;
    rcT.right = rcT.left + (2 * pci->cxChar) + (2 * cBorderSelect);
    rcT.top = (rcT.bottom * iy) / 7 + cBorderY - cBorderSelect;
    rcT.bottom = rcT.top + pci->cyChar + (2 * cBorderSelect);

    InvalidateRect(pci->hwnd, &rcT, FALSE);

    //
    //  First try, simply call to change the date.
    //
    ChangeCurrentDate(pci, ix, iy);
    NotifyWinEvent(EVENT_OBJECT_NAMECHANGE , pci->hwnd, OBJID_WINDOW, CHILDID_SELF);
}


////////////////////////////////////////////////////////////////////////////
//
//  CalWndProc
//
////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK CalWndProc(
    HWND hwnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PCALINFO pci;

    pci = (PCALINFO)GetWindowLongPtr(hwnd, 0);

    switch (message)
    {
        case ( WM_CREATE ) :
        {
            pci = (PCALINFO)LocalAlloc(LPTR, sizeof(CALINFO));
            if (pci == 0)
            {
                return (-1);
            }

            pci->hwnd = hwnd;
            SetWindowLongPtr(hwnd, 0, (LONG_PTR)pci);

            GetDate();
            break;
        }
        case ( WM_NCDESTROY ) :
        {
            if (pci)
            {
                LocalFree((HLOCAL)pci);
            }
            break;
        }
        case ( WM_SETFONT ) :
        {
            if (wParam)
            {
                pci->hfontCal = (HFONT)wParam;
                pci->cxChar = 0;
            }
            break;
        }
        case ( WM_GETTEXT ) :
        {
            return GetCalendarName((LPTSTR)lParam, (int)wParam);   
        }
        case ( WM_GETTEXTLENGTH ) :
        {
            return GetCalendarName(NULL, 0);   
        }
        case ( WM_PAINT ) :
        {
            CalendarPaint(pci, hwnd);
            break;
        }
        case ( WM_LBUTTONDOWN ) :
        {
            SetFocus(hwnd);
            HandleDateChange(pci, LOWORD(lParam), HIWORD(lParam));
            break;
        }
        case ( WM_SETFOCUS ) :
        {
            pci->fFocus = TRUE;
            ChangeCurrentDate(pci, -1, -1);
            break;
        }
        case ( WM_KILLFOCUS ) :
        {
            pci->fFocus = FALSE;
            ChangeCurrentDate(pci, -1, -1);
            break;
        }
        case ( WM_KEYDOWN ) :
        {
            HandleKeyDown(pci, (int)wParam, lParam);
            break;
        }
        case ( WM_GETDLGCODE ) :
        {
            return (DLGC_WANTARROWS);
            break;
        }
        default :
        {
            return ( DefWindowProc(hwnd, message, wParam, lParam) );
        }
    }
    return (0);
}


////////////////////////////////////////////////////////////////////////////
//
//  CalendarInit
//
////////////////////////////////////////////////////////////////////////////

TCHAR const c_szCalClass[] = CALENDAR_CLASS;

BOOL CalendarInit(
    HANDLE hInstance)
{
    WNDCLASS wc;

    if (!GetClassInfo(hInstance, c_szCalClass, &wc))
    {
        wc.style         = CS_VREDRAW | CS_HREDRAW | CS_DBLCLKS;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = sizeof(PCALINFO);
        wc.hCursor       = NULL;
        wc.hbrBackground = NULL;
        wc.hIcon         = NULL;
        wc.lpszMenuName  = NULL;
        wc.lpszClassName = c_szCalClass;
        wc.hInstance     = hInstance;
        wc.lpfnWndProc   = CalWndProc;

        return (RegisterClass(&wc));
    }
    return (TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\utc\clock.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    clock.c

Abstract:

    This module implements the clock control for the Date/Time applet.

Revision History:

--*/



//
//  Include Files.
//

#include "timedate.h"
#include "rc.h"
#include "clock.h"




//
//  Constant Declarations.
//

#define TIMER_ID             1

#define SECONDSCALE          80
#define HHAND                TRUE
#define MHAND                FALSE
#define MAXBLOBWIDTH         25

#define REPAINT              0
#define HANDPAINT            1

#define OPEN_TLEN            450    /* < half second */

#define MINDESIREDHEIGHT     3




//
//  Macro Definitions.
//

#ifdef WIN32
  #define MoveTo(hdc, x, y)       MoveToEx(hdc, x, y, NULL)
  #define GetWindowPtr(w, o)      GetWindowLongPtr(w, o)
  #define SetWindowPtr(w, o, p)   SetWindowLongPtr(w, o, (LPARAM)(p))
#else
  #define GetWindowPtr(w, o)      GetWindowWord(w, o)
  #define SetWindowPtr(w, o, p)   SetWindowWord(w, o, p)
#endif




//
//  Typedef Declarations.
//

typedef struct
{
    int     hour;                   // 0 - 11 hours for analog clock
    int     minute;
    int     second;

} TIME;

typedef struct
{
    HWND    hWnd;               // Us.

    HWND    hwndGetTime;        // window to provide get/set time

    // Brushes
    HBRUSH  hbrColorWindow;
    HBRUSH  hbrBtnHighlight;
    HBRUSH  hbrForeground;
    HBRUSH  hbrBlobColor;

    // Pens
    HPEN    hpenForeground;
    HPEN    hpenBackground;
    HPEN    hpenBlobHlt;

    // Dimensions of clock
    RECT    clockRect;
    int     clockRadius;
    int     HorzRes;
    int     VertRes;
    int     aspectD;
    int     aspectN;

    // Position of clock
    POINT   clockCenter;

    TIME    oTime;
    TIME    nTime;

} CLOCKSTR, *PCLOCKSTR;

typedef struct
{
    SHORT x;
    SHORT y;

} TRIG;


//
//  Array containing the sine and cosine values for hand positions.
//
POINT rCircleTable[] =
{
    { 0,     -7999},
    { 836,   -7956},
    { 1663,  -7825},
    { 2472,  -7608},
    { 3253,  -7308},
    { 3999,  -6928},
    { 4702,  -6472},
    { 5353,  -5945},
    { 5945,  -5353},
    { 6472,  -4702},
    { 6928,  -4000},
    { 7308,  -3253},
    { 7608,  -2472},
    { 7825,  -1663},
    { 7956,  -836 },

    { 8000,  0    },
    { 7956,  836  },
    { 7825,  1663 },
    { 7608,  2472 },
    { 7308,  3253 },
    { 6928,  4000 },
    { 6472,  4702 },
    { 5945,  5353 },
    { 5353,  5945 },
    { 4702,  6472 },
    { 3999,  6928 },
    { 3253,  7308 },
    { 2472,  7608 },
    { 1663,  7825 },
    { 836,   7956 },

    {  0,    7999 },
    { -836,  7956 },
    { -1663, 7825 },
    { -2472, 7608 },
    { -3253, 7308 },
    { -4000, 6928 },
    { -4702, 6472 },
    { -5353, 5945 },
    { -5945, 5353 },
    { -6472, 4702 },
    { -6928, 3999 },
    { -7308, 3253 },
    { -7608, 2472 },
    { -7825, 1663 },
    { -7956, 836  },

    { -7999, -0   },
    { -7956, -836 },
    { -7825, -1663},
    { -7608, -2472},
    { -7308, -3253},
    { -6928, -4000},
    { -6472, -4702},
    { -5945, -5353},
    { -5353, -5945},
    { -4702, -6472},
    { -3999, -6928},
    { -3253, -7308},
    { -2472, -7608},
    { -1663, -7825},
    { -836 , -7956},
};




//
//  Function prototypes.
//

LRESULT CALLBACK ClockWndProc( HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam);

void ClockCreate(HWND hWnd, PCLOCKSTR np);
void ClockTimer(HWND hWnd, WPARAM idTimer, PCLOCKSTR np);
void ClockPaint(PCLOCKSTR np, HDC hDC, int hint);
void ClockTimerInterval( HWND hWnd, PCLOCKSTR np );
void CompClockDim(HWND hWnd, PCLOCKSTR np);
void CreateTools(PCLOCKSTR np);
void DeleteTools(PCLOCKSTR np);
void DrawFace(HDC hDC, PCLOCKSTR np);
void DrawFatHand( HDC hDC, int pos, HPEN hPen, BOOL hHand, PCLOCKSTR np);
void DrawHand( HDC hDC, int pos, HPEN hPen, int scale, int patMode, PCLOCKSTR np);





////////////////////////////////////////////////////////////////////////////
//
//  ClockInit
//
//  Registers the clock class.
//
////////////////////////////////////////////////////////////////////////////

TCHAR const c_szClockClass[] = CLOCK_CLASS;

BOOL ClockInit(
    HINSTANCE hInstance)
{
    WNDCLASS wc;

    if (!GetClassInfo(hInstance, c_szClockClass, &wc))
    {
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = sizeof(PCLOCKSTR);
        wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
        wc.hbrBackground = NULL;
        wc.hIcon         = NULL;
        wc.lpszMenuName  = NULL;
        wc.lpszClassName = c_szClockClass;
        wc.hInstance     = hInstance;
        wc.style         = CS_VREDRAW | CS_HREDRAW ;
        wc.lpfnWndProc   = ClockWndProc;

        return (RegisterClass(&wc));
    }
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetTimeClock
//
//  Gets the time that we should display on the clock.
//  The client could have specified a function to call to get this
//  or an HWND to pass a message to to get it from.
//
////////////////////////////////////////////////////////////////////////////

void GetTimeClock(
    TIME *pt,
    PCLOCKSTR np)
{
    SYSTEMTIME st;

    //
    //  Call our time provider or default to GetTime.
    //
    if (np->hwndGetTime)
    {
        SendMessage( np->hwndGetTime,
                     CLM_UPDATETIME,
                     CLF_GETTIME,
                     (LPARAM)(LPSYSTEMTIME)&st );
        pt->hour = st.wHour % 12;
        pt->minute = st.wMinute;
        pt->second = st.wSecond;
    }
    else
    {
#ifdef WIN32
        GetLocalTime(&st);

        pt->hour = st.wHour;
        pt->minute = st.wMinute;
        pt->second = st.wSecond;
#else
        //
        // No function call back and no HWND callback.
        //
        GetTime();
        pt->hour = wDateTime[HOUR] % 12;
        pt->minute = wDateTime[MINUTE];
        pt->second = wDateTime[SECOND];
#endif
     }
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateTools
//
////////////////////////////////////////////////////////////////////////////

void CreateTools(
    PCLOCKSTR np)
{
    #define BLOB_COLOR  RGB(0, 128, 128)

    np->hbrForeground   = GetSysColorBrush(COLOR_BTNSHADOW);
    np->hbrColorWindow  = GetSysColorBrush(COLOR_BTNFACE);
    np->hbrBlobColor    = CreateSolidBrush( BLOB_COLOR );
    np->hbrBtnHighlight = GetSysColorBrush(COLOR_BTNHIGHLIGHT);
    np->hpenForeground  = CreatePen(0, 1, GetSysColor(COLOR_WINDOWTEXT));
    np->hpenBackground  = CreatePen(0, 1, GetSysColor(COLOR_BTNFACE));
    np->hpenBlobHlt     = CreatePen(0, 1, RGB(0, 255, 255));
}


////////////////////////////////////////////////////////////////////////////
//
//  DeleteTools
//
////////////////////////////////////////////////////////////////////////////

void DeleteTools(
    PCLOCKSTR np)
{
//  DeleteObject(np->hbrForeground);
//  DeleteObject(np->hbrColorWindow);
    DeleteObject(np->hbrBlobColor);
//  DeleteObject(np->hbrBtnHighlight);
    DeleteObject(np->hpenForeground);
    DeleteObject(np->hpenBackground);
    DeleteObject(np->hpenBlobHlt);
}


////////////////////////////////////////////////////////////////////////////
//
//  CompClockDim
//
//  Calculates the clock dimensions.
//
////////////////////////////////////////////////////////////////////////////

void CompClockDim(
    HWND hWnd,
    PCLOCKSTR np)
{
    int i;
    int tWidth;
    int tHeight;

    tWidth = np->clockRect.right - np->clockRect.left;
    tHeight = np->clockRect.bottom - np->clockRect.top;

    if (tWidth > MulDiv(tHeight,np->aspectD,np->aspectN))
    {
        i = MulDiv(tHeight, np->aspectD, np->aspectN);
        np->clockRect.left += (tWidth - i) / 2;
        np->clockRect.right = np->clockRect.left + i;
    }
    else
    {
        i = MulDiv(tWidth, np->aspectN, np->aspectD);
        np->clockRect.top += (tHeight - i) / 2;
        np->clockRect.bottom = np->clockRect.top + i;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ClockTimerInterval
//
//  Sets the timer interval. Two things affect this interval:
//    1) if the window is iconic, or
//    2) if seconds option has been disabled
//  In both cases, timer ticks occur every half-minute. Otherwise, timer
//  every half-second.
//
////////////////////////////////////////////////////////////////////////////

void ClockTimerInterval(
    HWND hWnd,
    PCLOCKSTR np)
{
    //
    //  Update every 1/2 second in the opened state.
    //
    KillTimer(hWnd, TIMER_ID);
    SetTimer(hWnd, TIMER_ID, OPEN_TLEN, 0L);
}


////////////////////////////////////////////////////////////////////////////
//
//  ClockSize
//
//  Sizes the clock to the specified size.
//
////////////////////////////////////////////////////////////////////////////

void ClockSize(
    PCLOCKSTR np,
    int newWidth,
    int newHeight)
{
    SetRect(&np->clockRect, 0, 0, newWidth, newHeight);
    CompClockDim(np->hWnd, np);
    ClockTimerInterval(np->hWnd, np);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawFace
//
//  Draws the clock face.
//
////////////////////////////////////////////////////////////////////////////

void DrawFace(
    HDC hDC,
    PCLOCKSTR np)
{
    int i;
    RECT tRect;
    LPPOINT ppt;
    int blobHeight, blobWidth;

    blobWidth = MulDiv( MAXBLOBWIDTH,
                        (np->clockRect.right - np->clockRect.left),
                        np->HorzRes );
    blobHeight = MulDiv(blobWidth, np->aspectN, np->aspectD);

    if (blobHeight < 2)
    {
        blobHeight = 1;
    }

    if (blobWidth < 2)
    {
        blobWidth = 2;
    }

    InflateRect(&np->clockRect, -(blobHeight / 2), -(blobWidth / 2));

    np->clockRadius = (np->clockRect.right - np->clockRect.left - 8) / 2;
    np->clockCenter.y = np->clockRect.top +
                        ((np->clockRect.bottom - np->clockRect.top) / 2) - 1;
    np->clockCenter.x = np->clockRect.left + np->clockRadius + 3;

    for (i = 0; i < 60; i++)
    {
        ppt = rCircleTable + i;

        tRect.top  = MulDiv(ppt->y, np->clockRadius, 8000) + np->clockCenter.y;
        tRect.left = MulDiv(ppt->x, np->clockRadius, 8000) + np->clockCenter.x;

        if (i % 5)
        {
            //
            //  Draw a dot.
            //
            if (blobWidth > 2 && blobHeight >= 2)
            {
                tRect.right = tRect.left + 2;
                tRect.bottom = tRect.top + 2;
                FillRect(hDC, &tRect, GetStockObject(WHITE_BRUSH));
                OffsetRect(&tRect, -1, -1);
                FillRect(hDC, &tRect, np->hbrForeground);
                tRect.left++;
                tRect.top++;
                FillRect(hDC, &tRect, np->hbrColorWindow);
            }
        }
        else
        {
            tRect.right = tRect.left + blobWidth;
            tRect.bottom = tRect.top + blobHeight;
            OffsetRect(&tRect, -(blobWidth / 2) , -(blobHeight / 2));

            SelectObject(hDC, GetStockObject(BLACK_PEN));
            SelectObject(hDC, np->hbrBlobColor);

            Rectangle(hDC, tRect.left, tRect.top, tRect.right, tRect.bottom);
            SelectObject(hDC, np->hpenBlobHlt);
            MoveTo(hDC, tRect.left, tRect.bottom - 1);
            LineTo(hDC, tRect.left, tRect.top);
            LineTo(hDC, tRect.right - 1, tRect.top);
        }
    }

    InflateRect(&np->clockRect, blobHeight / 2, blobWidth / 2);
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawHand
//
//  Draws the hands of the clock.
//
////////////////////////////////////////////////////////////////////////////

void DrawHand(
    HDC hDC,
    int pos,
    HPEN hPen,
    int scale,
    int patMode,
    PCLOCKSTR np)
{
    LPPOINT lppt;
    int radius;

    MoveTo(hDC, np->clockCenter.x, np->clockCenter.y);
    radius = MulDiv(np->clockRadius, scale, 100);
    lppt = rCircleTable + pos;
    SetROP2(hDC, patMode);
    SelectObject(hDC, hPen);

    LineTo( hDC,
            np->clockCenter.x + MulDiv(lppt->x, radius, 8000),
            np->clockCenter.y + MulDiv(lppt->y, radius, 8000) );
}


////////////////////////////////////////////////////////////////////////////
//
//  Adjust
//
////////////////////////////////////////////////////////////////////////////

void Adjust(
    POINT *rgpt,
    int cPoint,
    int iDelta)
{
    int i;

    for (i = 0; i < cPoint; i++)
    {
        rgpt[i].x += iDelta;
        rgpt[i].y += iDelta;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  DrawFatHand
//
//  Draws either hour or minute hand.
//
////////////////////////////////////////////////////////////////////////////

void DrawFatHand(
    HDC hDC,
    int pos,
    HPEN hPen,
    BOOL hHand,
    PCLOCKSTR np)
{
    int m;
    int n;
    int scale;

    TRIG tip;
    TRIG stip;
    BOOL fErase;
    POINT rgpt[4];
    HBRUSH hbrInit, hbrControl = NULL;

    SetROP2(hDC, 13);
    fErase = (hPen == np->hpenBackground);

    SelectObject(hDC, hPen);

    scale = hHand ? 7 : 5;

    n = (pos + 15) % 60;
    m = MulDiv(np->clockRadius, scale, 100);

    stip.y = (SHORT)MulDiv(rCircleTable[n].y, m, 8000);
    stip.x = (SHORT)MulDiv(rCircleTable[n].x, m, 8000);

    scale = hHand ? 65 : 80;
    tip.y = (SHORT)MulDiv(rCircleTable[pos % 60].y, MulDiv(np->clockRadius, scale, 100), 8000);
    tip.x = (SHORT)MulDiv(rCircleTable[pos % 60].x, MulDiv(np->clockRadius, scale, 100), 8000);

    rgpt[0].x = np->clockCenter.x + stip.x;
    rgpt[0].y = np->clockCenter.y + stip.y;
    rgpt[1].x = np->clockCenter.x + tip.x;
    rgpt[1].y = np->clockCenter.y + tip.y;
    rgpt[2].x = np->clockCenter.x - stip.x;
    rgpt[2].y = np->clockCenter.y - stip.y;

    scale = hHand ? 15 : 20;

    n = (pos + 30) % 60;
    m = MulDiv(np->clockRadius, scale, 100);
    tip.y = (SHORT)MulDiv(rCircleTable[n].y, m, 8000);
    tip.x = (SHORT)MulDiv(rCircleTable[n].x, m, 8000);

    rgpt[3].x = np->clockCenter.x + tip.x;
    rgpt[3].y = np->clockCenter.y + tip.y;

    SelectObject(hDC, GetStockObject(NULL_PEN));

    if (fErase)
    {
        hbrControl = (HBRUSH)SendMessage(GetParent(np->hWnd), WM_CTLCOLORSTATIC, (WPARAM)hDC, (LPARAM)np->hWnd);
        hbrInit = SelectObject(hDC, hbrControl ? hbrControl : np->hbrColorWindow);
    }
    else
    {
        hbrInit = SelectObject(hDC, np->hbrBtnHighlight);
    }

    Adjust(rgpt, 4, -2);
    Polygon(hDC, rgpt, 4);

    if (!fErase)
    {
        SelectObject(hDC, np->hbrForeground);
    }

    Adjust(rgpt, 4, 4);
    Polygon(hDC, rgpt, 4);
  
    if (!fErase)
    {
        SelectObject(hDC, np->hbrBlobColor);
    }

    Adjust(rgpt, 4, -2);
    Polygon(hDC, rgpt, 4);

    //
    //  If we selected a brush in, reset it now.
    //
    if (fErase)
    {
        SelectObject(hDC, hbrInit);        
    }    
}


////////////////////////////////////////////////////////////////////////////
//
//  ClockPaint
//
//  Only paints the clock.
//
//  It assumes you have set nTime already.  This allows it to be called by
//  the timer or by the client.
//
////////////////////////////////////////////////////////////////////////////

void ClockPaint(
    PCLOCKSTR np,
    HDC hDC,
    int hint)
{
    SetBkMode(hDC, TRANSPARENT);

    if (hint == REPAINT)
    {
        //
        //  If doing a full repaint, we do not advance the time.
        //  Otherwise we will create artifacts when there is a clipping
        //  region.
        //
        DrawFace(hDC, np);

        DrawFatHand(hDC, np->oTime.hour * 5 + (np->oTime.minute / 12), np->hpenForeground, HHAND,np);
        DrawFatHand(hDC, np->oTime.minute, np->hpenForeground, MHAND,np);

        //
        //  Draw the second hand.
        //
        DrawHand(hDC, np->oTime.second, np->hpenBackground, SECONDSCALE, R2_NOT,np);
    }
    else if (hint == HANDPAINT)
    {
        DrawHand(hDC, np->oTime.second, np->hpenBackground, SECONDSCALE, R2_NOT, np);

        if (np->nTime.minute != np->oTime.minute || np->nTime.hour != np->oTime.hour)
        {
            DrawFatHand(hDC, np->oTime.minute, np->hpenBackground, MHAND, np);
            DrawFatHand(hDC, np->oTime.hour * 5 + (np->oTime.minute / 12), np->hpenBackground, HHAND,np);
            DrawFatHand(hDC, np->nTime.minute, np->hpenForeground, MHAND, np);
            DrawFatHand(hDC, (np->nTime.hour) * 5 + (np->nTime.minute / 12), np->hpenForeground, HHAND, np);
        }

        DrawHand(hDC, np->nTime.second, np->hpenBackground, SECONDSCALE, R2_NOT, np);
        np->oTime = np->nTime;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ClockTimer
//
//  Update the clock.  Called on a timer tick.
//
////////////////////////////////////////////////////////////////////////////

void ClockTimer(
    HWND hWnd,
    UINT_PTR idTimer,
    PCLOCKSTR np)
{
    HDC hDC;

    GetTimeClock(&np->nTime, np);

    if ((np->nTime.second == np->oTime.second) &&
        (np->nTime.minute == np->oTime.minute) &&
        (np->nTime.hour == np->oTime.hour))
    {
        return;
    }

    hDC = GetDC(hWnd);
    ClockPaint(np, hDC, HANDPAINT);
    ReleaseDC(hWnd, hDC);
}


////////////////////////////////////////////////////////////////////////////
//
//  ClockCreate
//
////////////////////////////////////////////////////////////////////////////

void ClockCreate(
    HWND hWnd,
    PCLOCKSTR np)
{
    int i;
    HDC hDC;
    int HorzSize;
    int VertSize;
    LPPOINT lppt;

    hDC = GetDC(hWnd);
    np->VertRes = GetDeviceCaps(hDC, VERTRES);
    np->HorzRes = GetDeviceCaps(hDC, HORZRES);
    VertSize= GetDeviceCaps(hDC, VERTSIZE);
    HorzSize= GetDeviceCaps(hDC, HORZSIZE);
    ReleaseDC(hWnd, hDC);
    np->aspectN = MulDiv(np->VertRes, 100, VertSize);
    np->aspectD = MulDiv(np->HorzRes, 100, HorzSize);

    //
    //  Instance stuff.
    //
    np->hWnd = hWnd;

    CreateTools(np);

    //
    //  Scale cosines for aspect ratio if this is the first instance.
    //
    for (i = 0; i < 60; i++)
    {
        lppt = rCircleTable + i;
        lppt->y = MulDiv(lppt->y, np->aspectN, np->aspectD);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ClockWndProc
//
//  Deals with the clock messages.
//
////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK ClockWndProc(
    HWND hWnd,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PCLOCKSTR np = (PCLOCKSTR)GetWindowPtr(hWnd, 0);

    switch (message)
    {
        case ( WM_DESTROY ) :
        {
            if (np)
            {
                KillTimer(hWnd, TIMER_ID);
                DeleteTools(np);
                LocalFree((HLOCAL)np);
                SetWindowPtr(hWnd, 0, 0);
            }
            break;
        }
        case ( WM_CREATE ) :
        {
            //
            //  Allocate the instance data space.
            //
            np = (PCLOCKSTR)LocalAlloc(LPTR, sizeof(CLOCKSTR));
            if (!np)
            {
                return (-1);
            }

            SetWindowPtr(hWnd, 0, np);

            ClockCreate(hWnd, np);

            SetLayout(GetDC(hWnd), LAYOUT_BITMAPORIENTATIONPRESERVED);

            //
            //  Loop if control panel time being changed.
            //
            GetTimeClock(&(np->nTime), np);
            do
            {
                GetTimeClock(&(np->oTime), np);
            } while (np->nTime.second == np->oTime.second &&
                     np->nTime.minute == np->oTime.minute &&
                     np->nTime.hour == np->oTime.hour);

            SetTimer(hWnd, TIMER_ID, OPEN_TLEN, 0L);

            ClockSize( np,
                       ((LPCREATESTRUCT)lParam)->cx,
                       ((LPCREATESTRUCT)lParam)->cy );
            break;
        }
        case ( WM_SIZE ) :
        {
            if (np)
            {
                ClockSize(np, LOWORD(lParam), HIWORD(lParam));
            }
            break;
        }
        case ( WM_PAINT ) :
        {
            PAINTSTRUCT ps;

            BeginPaint(hWnd, &ps);
            GetTimeClock(&(np->nTime), np);
            ClockPaint(np, ps.hdc, REPAINT);
            EndPaint(hWnd, &ps);

            break;
        }
        case ( WM_TIMECHANGE ) :
        {
            //
            //  I'm not top level - so I wont get this message.
            //
            InvalidateRect(hWnd, NULL, TRUE);
            if (np->hwndGetTime)
            {
                SYSTEMTIME System;

                GetTime();
                System.wHour = wDateTime[HOUR];
                System.wMinute = wDateTime[MINUTE];
                System.wSecond = wDateTime[SECOND];
                SendMessage( np->hwndGetTime,
                             CLM_UPDATETIME,
                             CLF_SETTIME,
                             (LPARAM)(LPSYSTEMTIME)&System );
            }

            // fall thru...
        }
        case ( WM_TIMER ) :
        {
            ClockTimer(hWnd, wParam, np);
            break;
        }
        case ( WM_SYSCOLORCHANGE ) :
        {
            DeleteTools(np);
            CreateTools(np);
            break;
        }
        case ( CLM_UPDATETIME ) :
        {
            //
            //  Force the clock to repaint. lParam will point to a
            //  SYSTEMTIME struct.
            //
            switch (wParam)
            {
                case ( CLF_SETTIME ) :
                {
                    //
                    //  Caller wants us to reflect a new time.
                    //
                    HDC hDC;
                    LPSYSTEMTIME lpSysTime = (LPSYSTEMTIME)lParam;

                    np->nTime.hour   = lpSysTime->wHour;
                    np->nTime.minute = lpSysTime->wMinute;
                    np->nTime.second = lpSysTime->wSecond;

                    hDC = GetDC(hWnd);
                    ClockPaint(np, hDC, HANDPAINT);
                    ReleaseDC(hWnd, hDC);
                    break;
                }
                case ( CLF_GETTIME ) :
                {
                    //
                    //  Caller wants to know what we think the time is.
                    //
                    LPSYSTEMTIME lpSysTime = (LPSYSTEMTIME)lParam;

                    lpSysTime->wHour = (WORD)np->nTime.hour;
                    lpSysTime->wMinute = (WORD)np->nTime.minute;
                    lpSysTime->wSecond = (WORD)np->nTime.second;
                    break;
                }
            }
            break;
        }
        case ( CLM_TIMEHWND ) :
        {
            //
            //  Get/Set the HWND that we ask to provide the time.
            //
            switch (wParam)
            {
                case ( CLF_SETHWND ) :
                {
                    //
                    //  Caller wants us to reflect a new time.
                    //
                    np->hwndGetTime = (HWND)lParam;
                    break;
                }
                case ( CLF_GETTIME ) :
                {
                    //
                    //  Caller wants to know what we think the time is.
                    //
                    *((HWND *)lParam) = np->hwndGetTime;
                    break;
                }
            }
            break;
        }
        default :
        {
            return ( DefWindowProc(hWnd, message, wParam, lParam) );
        }
    }

    return (0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\utc\clock.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    clock.h

Abstract:

    This module contains the information for the clock in the Date/Time
    applet.

Revision History:

--*/



//
//  Messages.
//

//
//  CLM_UPDATETIME
//
//  wParam: CLF_GETTIME or CLF_SETTIME (senders perspective)
//  lParam: pointer to LPSYSTEMTIME called to force reflection of new time
//  return: not used
//
#define CLF_GETTIME          0
#define CLF_SETTIME          1
#define CLM_UPDATETIME       (WM_USER + 102)


//
//  CLM_TIMEHWND
//
//  wParam: CLF_GETPROVIDERHWND or CLF_SETPROVIDERHWND
//  lParam: HWND of timer window
//  return: not used
//
#define CLF_GETHWND          0
#define CLF_SETHWND          1
#define CLM_TIMEHWND         (WM_USER + 103)




//
//  Function Prototypes.
//

BOOL
ClockInit(
    HINSTANCE hInstance);

BOOL
CalendarInit(
    HINSTANCE hInstance);
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\utc\date.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    date.c

Abstract:

    This module implements the textual representations of
    Day Month Year : Hours Min Seconds for the Date/Time applet.

Revision History:

--*/



//
//  Include Files.
//

#include "timedate.h"
#include <commctrl.h>
#include <prsht.h>
#include <regstr.h>
#include <imm.h>
#include "clock.h"
#include "mapctl.h"
#include "inettime.h"
#include "rc.h"
#include <help.h>
#include <windows.h>
#include <windowsx.h>




//
//  Constant Declarations.
//

#define TZNAME_SIZE          128
#define TZDISPLAYZ           128

#define BIAS_ONE_HOUR        (-60L)

#define ZONE_IMAGE_SCALE     (356)
#define ZONE_BIAS_SCALE      (-1440)
#define ZONE_IMAGE_LEFT      (120)
#define ZONE_IMAGE_WIDTH     (80)

#define BIAS_PLUS_12         (12L * BIAS_ONE_HOUR)
#define BIAS_MINUS_12        (- BIAS_PLUS_12)

#define TZ_HIT_NONE          (0)
#define TZ_HIT_BASE          (1)
#define TZ_HIT_PARTIAL       (2)
#define TZ_HIT_EXACT         (3)




//
//  Global Variables.
//

TCHAR const szIntl[] = TEXT("intl");

//
//  Default used if none could be found.
//
INTLSTRUCT IntlDef =
{
    TEXT("Other Country"),
    1, 0, 0, 0, 0, 2, 0, 1, 2, 1,
    TEXT("AM"),
    TEXT("PM"),
    TEXT("$"),
    TEXT(","),
    TEXT("."),
    TEXT("/"),
    TEXT(":"),
    TEXT(","),
    TEXT("dddd, MMMM dd, yyyy"),
    TEXT("M/d/yyyy"),
    TEXT("USA"),
    1, 0, 1, 0, 0x0409,
    TEXT("hh:mm:ss tt"),
    0, 1,
    TEXT(","),
    TEXT(".")
};

BOOL g_bFirstBoot = FALSE;   // for first boot during setup

int g_Time[3];               // time the user currently has set
int g_LastTime[3];           // last displayed time - to stop flicker

short wDateTime[7];                 // values for first 7 date/time items
short wPrevDateTime[7];             // only repaint fields if necessary
BOOL  fDateDirty;

//
//  Formatting strings for AM and PM
//
TCHAR sz1159[12];
TCHAR sz2359[12];

//
//  Are we in 24 hour time.  If not, is it AM or PM.
//
BOOL g_b24HR;
BOOL g_bPM;

//
//  This flag indicates if the user has tried to change the time.
//  If so, then we stop providing the system time and use the
//  time that we store internally. We send the clock control our
//  TimeProvider function.
//
WORD g_Modified = 0;
WORD g_WasModified = 0;

//
//  Which of the HMS MDY have leading zeros.
//
BOOL g_bLZero[6] = {FALSE, TRUE, TRUE, FALSE, FALSE, FALSE};

//
//  Ranges of HMS MDY
//
struct
{
    int nMax;
    int nMin;
} g_sDateInfo[] =
{
    23, 0,
    59, 0,
    59, 0,
    12, 1,
    31, 1,
    2099, 1980,
};

//
//  Time Zone info globals.
//
int g_nTimeZones = 0;
TIME_ZONE_INFORMATION g_tziCurrent, *g_ptziCurrent = NULL;

//
//  Registry location for Time Zone information.
//
TCHAR c_szTimeZones[] = TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones");

//
//  Time Zone data value keys.
//
TCHAR c_szTZDisplayName[]  = TEXT("Display");
TCHAR c_szTZStandardName[] = TEXT("Std");
TCHAR c_szTZDaylightName[] = TEXT("Dlt");
TCHAR c_szTZI[]            = TEXT("TZI");
TCHAR c_szTZMapInfo[]      = TEXT("MapID");

//
//  IME globals.
//
HIMC g_PrevIMCForDateField;




//
//  Context Help Ids.
//

const DWORD aDateTimeHelpIds[] =
{
    IDD_GROUPBOX1,      IDH_DATETIME_DATE_GROUP,
    IDD_GROUPBOX2,      IDH_DATETIME_TIME,
    DATETIME_CURTZ,     IDH_DATETIME_CURRENT_TIME_ZONE,
    DATETIME_CALENDAR,  IDH_DATETIME_DATE,
    DATETIME_CLOCK,     IDH_DATETIME_TIME,
    DATETIME_TBORDER,   IDH_DATETIME_TIME,
    DATETIME_HOUR,      IDH_DATETIME_TIME,
    DATETIME_TSEP1,     IDH_DATETIME_TIME,
    DATETIME_MINUTE,    IDH_DATETIME_TIME,
    DATETIME_TSEP2,     IDH_DATETIME_TIME,
    DATETIME_SECOND,    IDH_DATETIME_TIME,
    DATETIME_AMPM,      IDH_DATETIME_TIME,
    DATETIME_TARROW,    IDH_DATETIME_TIME,
    DATETIME_MONTHNAME, IDH_DATETIME_MONTH,
    DATETIME_YEAR,      IDH_DATETIME_YEAR,
    DATETIME_YARROW,    IDH_DATETIME_YEAR,
    IDD_TIMEZONES,      IDH_DATETIME_TIMEZONE,
//  IDD_TIMEMAP,        IDH_DATETIME_BITMAP,
    IDD_TIMEMAP,        NO_HELP,
    IDD_AUTOMAGIC,      IDH_DATETIME_DAYLIGHT_SAVE,

    0, 0
};




//
//  Typedef Declarations.
//

//
//  Registry info goes in this structure.
//
typedef struct tagTZINFO
{
    struct tagTZINFO *next;
    TCHAR            szDisplayName[TZDISPLAYZ];
    TCHAR            szStandardName[TZNAME_SIZE];
    TCHAR            szDaylightName[TZNAME_SIZE];
    int              ComboIndex;
    int              SeaIndex;
    int              LandIndex;
    int              MapLeft;
    int              MapWidth;
    LONG             Bias;
    LONG             StandardBias;
    LONG             DaylightBias;
    SYSTEMTIME       StandardDate;
    SYSTEMTIME       DaylightDate;

} TZINFO, *PTZINFO;

//
//  State info for the time zone page.
//
typedef struct
{
    PTZINFO zone;
    BOOL initializing;
    PTZINFO lookup[MAPCTL_MAX_INDICES];

} TZPAGE_STATE;



DWORD GetTextExtent(
    HDC hdc,
    LPCTSTR lpsz,
    int cb);

//
//for TS time zone redirection
//
extern BOOL g_bShowOnlyTimeZone;

////////////////////////////////////////////////////////////////////////////
//
//  ParseDateElement
//
//  Assumes that the character pointed to by pszElement is a
//  'M', 'd', or 'y', and checks if the string indicates a leading zero
//  or century.  The return value is a pointer to the next character,
//  which should be a separator or NULL.  A return value of NULL indicates
//  an error.
//
////////////////////////////////////////////////////////////////////////////

LPTSTR ParseDateElement(
    LPTSTR pszElement,
    BOOL *pbLZero)
{
    //
    //  Check for valid character.
    //
    switch (*pszElement)
    {
        case ( TEXT('y') ) :
        case ( TEXT('M') ) :
        case ( TEXT('d') ) :
        {
            break;
        }
        default:
        {
            return (NULL);
        }
    }

    ++pszElement;

    if (*pszElement != *(pszElement - 1))
    {
        *pbLZero = 0;
    }
    else
    {
        *pbLZero = 1;

        if (*pszElement++ == TEXT('y'))
        {
            if (!(*pszElement == TEXT('y')))
            {
                *pbLZero = 0;
            }
            else
            {
                if (!(*++pszElement == TEXT('y')))
                {
                    //
                    //  Found 3 y's, invalid format.
                    //
                    return (NULL);
                }
                else
                {
                    ++pszElement;
                }
            }
        }
    }

    return (pszElement);
}


int rgMoveTimeControls [] = 
{
    DATETIME_HOUR,
    DATETIME_MINUTE,
    DATETIME_SECOND,
    DATETIME_TSEP1,
    DATETIME_TSEP2
};


////////////////////////////////////////////////////////////////////////////
//
//  AdjustAMPMPosition
//
////////////////////////////////////////////////////////////////////////////
void AdjustAMPMPosition(HWND hwnd)
{
   TCHAR    szTimePrefix[5];
   static BOOL fMoved = FALSE;

   GetLocaleInfo(LOCALE_USER_DEFAULT, 
                 LOCALE_ITIMEMARKPOSN,
                 szTimePrefix,
                 ARRAYSIZE(szTimePrefix));

   if (!fMoved && szTimePrefix[0] == TEXT('1'))
   {
        RECT rLeftCtl, rAMPMCtl, rCurrCtl;
        HWND hwndAMPM, hwndCurr;
        int i, width;
        POINT pt;

        fMoved = TRUE;
        
        //Get rect of left most control (hours)
        GetWindowRect(GetDlgItem(hwnd, DATETIME_HOUR), &rLeftCtl);
        
        //Get rect of AM PM control
        hwndAMPM = GetDlgItem(hwnd, DATETIME_AMPM);
        GetWindowRect(hwndAMPM, &rAMPMCtl);
        width = rAMPMCtl.right - rAMPMCtl.left;
        
        //Shift all controls right by the AM PM control width
        for (i = 0; i < ARRAYSIZE(rgMoveTimeControls); i++)
        {
            hwndCurr = GetDlgItem(hwnd, rgMoveTimeControls[i]);
            GetWindowRect(hwndCurr, &rCurrCtl);
            pt.x = rCurrCtl.left;
            pt.y = rCurrCtl.top;
            ScreenToClient(hwnd, &pt);

            MoveWindow(hwndCurr, pt.x + width, 
                        pt.y,
                        rCurrCtl.right - rCurrCtl.left,
                        rCurrCtl.bottom - rCurrCtl.top,
                        TRUE);
        }
        
        //Move AM PM control left to where the hours were.
        pt.x = rLeftCtl.left;
        pt.y = rAMPMCtl.top;
        ScreenToClient(hwnd, &pt);
        MoveWindow(hwndAMPM, pt.x, 
                    pt.y,
                    rAMPMCtl.right - rAMPMCtl.left,
                    rAMPMCtl.bottom - rAMPMCtl.top,
                    TRUE);
        
   }
}


////////////////////////////////////////////////////////////////////////////
//
//  MonthUpperBound
//
////////////////////////////////////////////////////////////////////////////

int _fastcall MonthUpperBound(
    int nMonth,
    int nYear)
{
    switch (nMonth)
    {
        case ( 2 ) :
        {
            //
            //  A year is a leap year if it is divisible by 4 and is not
            //  a century year (multiple of 100) or if it is divisible by
            //  400.
            //
            return ( ((nYear % 4 == 0) &&
                      ((nYear % 100 != 0) || (nYear % 400 == 0))) ? 29 : 28 );
        }
        case ( 4 ) :
        case ( 6 ) :
        case ( 9 ) :
        case ( 11 ) :
        {
            return (30);
        }
    }

    return (31);
}


////////////////////////////////////////////////////////////////////////////
//
//  IsAMPM
//
//  True if PM.
//
////////////////////////////////////////////////////////////////////////////

BOOL IsAMPM(
    int iHour)
{
    return ((iHour >= 12) ? 1 : 0);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDateTime
//
////////////////////////////////////////////////////////////////////////////

void GetDateTime()
{
    SYSTEMTIME SystemTime;

    GetLocalTime(&SystemTime);

    wDateTime[HOUR]    = SystemTime.wHour;
    wDateTime[MINUTE]  = SystemTime.wMinute;
    wDateTime[SECOND]  = SystemTime.wSecond;
    wDateTime[MONTH]   = SystemTime.wMonth;
    wDateTime[DAY]     = SystemTime.wDay;
    wDateTime[YEAR]    = SystemTime.wYear;
    wDateTime[WEEKDAY] = SystemTime.wDayOfWeek;
}


////////////////////////////////////////////////////////////////////////////
//
//  GetTime
//
////////////////////////////////////////////////////////////////////////////

void GetTime()
{
    SYSTEMTIME SystemTime;

    GetLocalTime(&SystemTime);

    wDateTime[HOUR]   = SystemTime.wHour;
    wDateTime[MINUTE] = SystemTime.wMinute;
    wDateTime[SECOND] = SystemTime.wSecond;
}


////////////////////////////////////////////////////////////////////////////
//
//  GetDate
//
////////////////////////////////////////////////////////////////////////////

void GetDate()
{
    SYSTEMTIME SystemTime;

    GetLocalTime(&SystemTime);

    wDateTime[MONTH]   = SystemTime.wMonth;
    wDateTime[DAY]     = SystemTime.wDay;
    wDateTime[YEAR]    = SystemTime.wYear;
    wDateTime[WEEKDAY] = SystemTime.wDayOfWeek;
    fDateDirty = FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  SetTime
//
////////////////////////////////////////////////////////////////////////////

void SetTime()
{
    SYSTEMTIME SystemTime;

    SystemTime.wHour   = wDateTime[HOUR];
    SystemTime.wMinute = wDateTime[MINUTE];
    SystemTime.wSecond = wDateTime[SECOND];

    SystemTime.wMilliseconds = 0;

    SystemTime.wMonth  = wDateTime[MONTH];
    SystemTime.wDay    = wDateTime[DAY];
    SystemTime.wYear   = wDateTime[YEAR];

    SetLocalTime(&SystemTime);
    SetLocalTime(&SystemTime);
    fDateDirty = FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  SetDate
//
////////////////////////////////////////////////////////////////////////////

void SetDate()
{
    SYSTEMTIME SystemTime;

    SystemTime.wHour   = wDateTime[HOUR];
    SystemTime.wMinute = wDateTime[MINUTE];
    SystemTime.wSecond = wDateTime[SECOND];

    SystemTime.wMilliseconds = 0;

    SystemTime.wMonth  = wDateTime[MONTH];
    SystemTime.wDay    = wDateTime[DAY];
    SystemTime.wYear   = wDateTime[YEAR];

    SetLocalTime(&SystemTime);
    SetLocalTime(&SystemTime);
    fDateDirty = FALSE;
}


////////////////////////////////////////////////////////////////////////////
//
//  AdjustDelta
//
//  Alters the variables in wDeltaDateTime, allowing a CANCEL button
//  to perform its job by resetting the time as if it had never been
//  touched.  GetTime() & GetDate() should already have been called.
//
////////////////////////////////////////////////////////////////////////////

void AdjustDelta(
    HWND hDlg,
    int nIndex)
{
    int nDelta;

    //
    //  We dont do time this way any more.
    //
    if (nIndex <= SECOND && nIndex >= HOUR)
    {
        return;
    }

    //
    //  Get position of the buddy from either the date or the time.
    //
    nDelta = (int)SendDlgItemMessage( hDlg,
                                      nIndex <= SECOND
                                        ? DATETIME_TARROW
                                        : DATETIME_YARROW,
                                      UDM_GETPOS,
                                      0,
                                      0L );

    if ((nIndex == YEAR) && !g_bLZero[YEAR])
    {
        //
        //  Years before 80 are 2080.
        //  Range is 1980...2079.
        //
        if (nDelta < 80)
        {
            nDelta += 2000;
        }
        else
        {
            nDelta += 1900;
        }
    }

    //
    //  If our current recording of the time/date is not what we have
    //  now, do deltas.
    //
    if (wDateTime[nIndex] != nDelta)
    {
        //
        //  Previous value is current user's settings.
        //
        wPrevDateTime[nIndex] = wDateTime[nIndex] = (WORD)nDelta;
        fDateDirty = TRUE;
        
        //
        // If we are changing HMS, update the time.
        //
        if (nIndex <= SECOND)
        {
            nIndex = 0;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  AdjustDeltaMonth
//
//  Change the month part of wDateTime
//
////////////////////////////////////////////////////////////////////////////

extern int GetDaysOfTheMonth(int iMonth);

void AdjustDeltaMonth(
    int iMonth)
{
    GetTime();

    if (wDateTime[MONTH] != iMonth)
    {
        //
        //  Make sure the current day is valid in the new month.
        //
        if (wDateTime[DAY] > (WORD)GetDaysOfTheMonth(iMonth))
        {
            wDateTime[DAY] = (WORD)GetDaysOfTheMonth(iMonth);
        }

        wPrevDateTime[MONTH] = wDateTime[MONTH] = (WORD)iMonth;
        fDateDirty = TRUE;

        g_sDateInfo[DAY].nMax = MonthUpperBound( wDateTime[MONTH],
                                                 wDateTime[YEAR] );
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ReadShortDate
//
//  Verify that pszDate is one of MDY, DMY, or YMD.
//
////////////////////////////////////////////////////////////////////////////

int ReadShortDate(
    LPTSTR pszDate,
    BOOL *pbMonth,
    BOOL *pbDay,
    BOOL *pbYear)
{
    int i, nOrder;
    BOOL *pbOrder[3];
    TCHAR cHope[3];

    //
    //  nOrder :  0 = MDY
    //            1 = DMY
    //            2 = YMD
    //
    switch (cHope[0] = *pszDate)
    {
        case ( TEXT('M') ) :
        {
            nOrder = 0;
            pbOrder[0] = pbMonth;
            break;
        }
        case ( TEXT('d') ) :
        {
            nOrder = 1;
            pbOrder[0] = pbDay;
            break;
        }
        case ( TEXT('y') ) :
        {
            nOrder = 2;
            pbOrder[0] = pbYear;
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    //
    //  Sets element 1.
    //
    if (nOrder)         // 1 2
    {
        cHope[1] = TEXT('M');
        pbOrder[1] = pbMonth;
    }
    else                // 0
    {
        cHope[1] = TEXT('d');
        pbOrder[1] = pbDay;
    }

    //
    //  Sets element 2.
    //
    if (nOrder == 2)    // 2
    {
        cHope[2] = TEXT('d');
        pbOrder[2] = pbDay;
    }
    else                // 0 1
    {
        cHope[2] = TEXT('y');
        pbOrder[2] = pbYear;
    }

    //
    //  Verifies that pszDate is of the form MDY DMY YMD.
    //
    for (i = 0; i < 3; i++, pszDate++)
    {
        if (*pszDate != cHope[i])
        {
            return (-1 - nOrder);
        }

        if (!(pszDate = ParseDateElement(pszDate, pbOrder[i])))
        {
            return (-1 - nOrder);
        }
    }

    //
    //  Success.  Return MDY, DMY or YMD index.
    //
    return (nOrder);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMaxCharWidth
//
//  Determine the widest digit (safety against variable pitch fonts).
//
////////////////////////////////////////////////////////////////////////////

int GetMaxCharWidth(
    HDC hDC)
{
    UINT nNumWidth[10];
    UINT i, nMaxNumWidth;

    GetCharWidth32(hDC, TEXT('0'), TEXT('9'), nNumWidth);

    for (nMaxNumWidth = 0, i = 0; i < 10; i++)
    {
        if (nNumWidth[i] > nMaxNumWidth)
        {
            nMaxNumWidth = nNumWidth[i];
        }
    }

    return (nMaxNumWidth);
}
////////////////////////////////////////////////////////////////////////////
//
//  GetMaxSubstitutedCharWidth
//
//  Determine the widest digit (safety against variable pitch fonts), but
//  do it using strings so that if number substitution is on, we will get
//  the width of the number based on what will actually be displayed
//
////////////////////////////////////////////////////////////////////////////

int GetMaxSubstitutedCharWidth(
    HDC hDC)
{
    char sz[2] = "0";
    TCHAR szAMPM[12];
    LONG i, nMaxNumWidth;
    DWORD dwWidth;
    SIZE size;
    
    for (nMaxNumWidth = 0, i = 0; i < 10; (*sz)++, i++)
    {
        if (GetTextExtentPoint32A(hDC, sz, 1, &size) && size.cx > nMaxNumWidth)
            nMaxNumWidth = size.cx;
        
    }

    if (nMaxNumWidth <= 8)
    {
        GetProfileString(szIntl, TEXT("s1159"), IntlDef.s1159, szAMPM, ARRAYSIZE(szAMPM));
        dwWidth = LOWORD(GetTextExtent(hDC, szAMPM, lstrlen(szAMPM)));
        if (dwWidth > 22)
        {
            nMaxNumWidth = 10;
        }

        GetProfileString(szIntl, TEXT("s2359"), IntlDef.s2359, szAMPM, ARRAYSIZE(szAMPM));
        dwWidth = LOWORD(GetTextExtent(hDC, szAMPM, lstrlen(szAMPM)));
        if (dwWidth > 22)
        {
            nMaxNumWidth = 10;
        }
    }
    return (nMaxNumWidth);
}


////////////////////////////////////////////////////////////////////////////
//
//  ReflectAMPM
//
//  Sets the global g_bPM and updates the control to display AM or PM.
//
////////////////////////////////////////////////////////////////////////////

void ReflectAMPM(
    HWND hDlg,
    int nNum)
{
    HWND hCtl = GetDlgItem(hDlg, DATETIME_AMPM);

    ListBox_SetTopIndex(hCtl, g_bPM);
    ListBox_SetCurSel(hCtl, (GetFocus() == hCtl) ? g_bPM : -1);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetTextExtent
//
////////////////////////////////////////////////////////////////////////////

#ifdef WIN32
DWORD GetTextExtent(
    HDC hdc,
    LPCTSTR lpsz,
    int cb)
{
    SIZE sz;
    BOOL bSuccess = GetTextExtentPoint(hdc, lpsz, cb, &sz);
    
    if ( !bSuccess )
    {
        ZeroMemory( &sz, sizeof(sz) );
    }

    return ( MAKELONG((WORD)sz.cx, (WORD)sz.cy) );
}
#endif


////////////////////////////////////////////////////////////////////////////
//
//  DateTimeInit
//
//  Determine the widest digit (safety against variable pitch fonts).
//
////////////////////////////////////////////////////////////////////////////

void DateTimeInit(
    HWND hDlg,
    WORD nBaseID,
    WORD nSepID,
    LPTSTR pszSep,
    int nMaxDigitWidth,
    BOOL bDate)
{
    HWND hAMPMList;
    HWND hDay, hMonth, hYear;     // also used as hHour, hMinute, & hSecond
    HWND hOrder[5];
    HDC hDC;
    int nWidth, nHeight, X;
    DWORD dwSepExt;
    RECT Rect;
    int i;
    int nAMPMlength;

    hMonth    = GetDlgItem(hDlg, nBaseID);
    hDay      = GetDlgItem(hDlg, nBaseID + 1);
    hYear     = GetDlgItem(hDlg, nBaseID + 2);
    hOrder[1] = GetDlgItem(hDlg, nSepID);
    hOrder[3] = GetDlgItem(hDlg, nSepID + 1);

    if (bDate)
    {
        i = GetProfileInt(szIntl, TEXT("iDate"), 0);
    }
    else
    {
        if (g_b24HR = ( 0 != GetProfileInt(szIntl, TEXT("iTime"), 0) ))
        {
            g_sDateInfo[HOUR].nMin = 0;
            g_sDateInfo[HOUR].nMax = 23;
        }
        else
        {
            g_sDateInfo[HOUR].nMin = 1;
            g_sDateInfo[HOUR].nMax = 12;

            GetProfileString(szIntl, TEXT("s1159"), IntlDef.s1159, sz1159, ARRAYSIZE(sz1159));
            GetProfileString(szIntl, TEXT("s2359"), IntlDef.s2359, sz2359, ARRAYSIZE(sz2359));
        }
        i = 0;
    }

    switch (i)
    {
        case ( 1 ) :
        {
            hOrder[0] = hDay;
            hOrder[2] = hMonth;
            hOrder[4] = hYear;
            break;
        }
        case ( 2 ) :
        {
            hOrder[0] = hYear;
            hOrder[2] = hMonth;
            hOrder[4] = hDay;
            break;
        }
        case ( 0 ) :
        default :
        {
            hOrder[0] = hMonth;
            hOrder[2] = hDay;
            hOrder[4] = hYear;
            break;
        }
    }

    hDC = GetDC(hDlg);

    if (!bDate)
    {
        dwSepExt = GetTextExtent(hDC, sz1159, lstrlen(sz1159));
        nAMPMlength = LOWORD(GetTextExtent(hDC, sz2359, lstrlen(sz2359)));
        if (nAMPMlength < (int)LOWORD(dwSepExt))
        {
            nAMPMlength = (int)LOWORD(dwSepExt);
        }
    }

    dwSepExt = GetTextExtent(hDC, pszSep, lstrlen(pszSep));
    ReleaseDC(hDlg, hDC);

    GetWindowRect(hYear, (LPRECT)&Rect);
    ScreenToClient(hDlg, (LPPOINT)&Rect.left);
    ScreenToClient(hDlg, (LPPOINT)&Rect.right);

    nHeight = Rect.bottom - Rect.top;
    nWidth = Rect.top;

    GetWindowRect( GetDlgItem( hDlg,
                               bDate ? DATETIME_CALENDAR : DATETIME_CLOCK ),
                   (LPRECT)&Rect );
    ScreenToClient(hDlg, (LPPOINT)&Rect.left);
    ScreenToClient(hDlg, (LPPOINT)&Rect.right);

    Rect.top = nWidth;
    X = (Rect.left + Rect.right - (6 * nMaxDigitWidth) - (2 * LOWORD(dwSepExt))) / 2;

    if (bDate)
    {
        if (g_bLZero[YEAR])
        {
            X -= nMaxDigitWidth;
        }
    }
    else if (!g_b24HR)
    {
        X -= nAMPMlength / 2;
    }

    for (i = 0; i < 5; i++)
    {
        nWidth = (i % 2) ? LOWORD(dwSepExt) : 2 * nMaxDigitWidth;

        if ((hOrder[i] == hYear) && bDate && g_bLZero[YEAR])
        {
            nWidth *= 2;
        }

        //
        //  Allow for centering in edit control.
        //
        nWidth += 2;

    //  MoveWindow(hOrder[i], X, Rect.top, nWidth, nHeight, FALSE);
        X += nWidth;
    }

    hAMPMList = GetDlgItem(hDlg, DATETIME_AMPM);
    ListBox_ResetContent(hAMPMList);

    if (!bDate && !g_b24HR)
    {
        ListBox_InsertString(hAMPMList, 0, sz1159);
        ListBox_InsertString(hAMPMList, 1, sz2359);
    }

    EnableWindow(hAMPMList, !g_b24HR);

    Edit_LimitText(hYear, (bDate && g_bLZero[YEAR]) ? 4 : 2);
    Edit_LimitText(hMonth, 2);
    Edit_LimitText(hDay, 2);

    SetDlgItemText(hDlg, nSepID, pszSep);
    SetDlgItemText(hDlg, nSepID + 1, pszSep);
}


////////////////////////////////////////////////////////////////////////////
//
//  myitoa
//
////////////////////////////////////////////////////////////////////////////

void myitoa(
    int intValue,
    LPTSTR lpStr)
{
    LPTSTR lpString;
    TCHAR c;

    //
    //  lpString points to 1st char.
    //
    lpString = lpStr;

    do
    {
        *lpStr++ = (TCHAR)(intValue % 10 + TEXT('0'));
    } while ((intValue /= 10) > 0);

    //
    //  lpStr points to last char.
    //
    *lpStr-- = TEXT('\0');

    //
    //  Now reverse the string.
    //
    while (lpString < lpStr)
    {
      c = *lpString;
      *(lpString++) = *lpStr;
      *(lpStr--) = c;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  UpdateItem
//
//  This displays the information in the control from the array
//  of global values. Also selects the control. Also adds leading 0's
//  as well as rounding years to 2 digits and 24 or AM/PM hours.
//
////////////////////////////////////////////////////////////////////////////

void UpdateItem(
    HWND hDlg,
    int i)
{
    TCHAR szNum[5];
    int nNum = g_Modified ? wPrevDateTime[i] : wDateTime[i];

    //
    //  Use internal time.
    //
    if (i <= SECOND && i >= HOUR)
    {
        nNum = g_Time[i];

        //
        //  Do not paint un-necessarily.
        //
        if ((nNum == g_LastTime[i]) && (nNum >= 10))
        {
            return;
        }

        g_LastTime[i] = nNum;

        if (i == HOUR)
        {
            if (IsAMPM(nNum))
            {
                g_bPM = TRUE;
            }
            ReflectAMPM(hDlg, nNum);
        }
    }

    if (i == YEAR)
    {
        //
        //  Round the years to last 2 digits.
        //
        if (!g_bLZero[i])
        {
            nNum %= 100;
        }
    }
    else if ((i == HOUR) && !g_b24HR)
    {
        //
        //  nNum came from our internal date time.
        //  Remove 12 hours if not 24hour.
        //
        if (g_bPM)
        {
            nNum %= 12;
        }

        //
        //  00 hours is actually 12AM.
        //
        if (!nNum)
        {
            nNum = 12;
        }
    }

    //
    //  See if we need leading zeros.
    //  We only deal with 2 character numbers MAX.
    //
    if ((nNum < 10) && (g_bLZero[i] || (i == YEAR)))
    {
        szNum[0] = TEXT('0');
        szNum[1] = (TCHAR)(TEXT('0') + nNum);
        szNum[2] = TEXT('\0');
    }
    else
    {
        myitoa(nNum, szNum);
    }

    //
    //  Reflect the value in the appropriate control.
    //
    SetDlgItemText(hDlg, DATETIME_HOUR + i, szNum);

    //
    //  Select the field too.
    //
    SendDlgItemMessage(hDlg, DATETIME_HOUR + i, EM_SETSEL, 0, MAKELONG(0, 32767));

    //
    //  If we changed year or month, then we may have altered the leap year
    //  state.
    //
    if (i == MONTH || i == YEAR)
    {
        g_sDateInfo[DAY].nMax = MonthUpperBound( wDateTime[MONTH],
                                                 wDateTime[YEAR] );
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  _ShowTZ
//
////////////////////////////////////////////////////////////////////////////

TCHAR c_szFirstBootTZ[] = TEXT("!!!First Boot!!!");

void _ShowTZ(
    HWND hDlg)
{
    HWND ctl = GetDlgItem(hDlg, DATETIME_CURTZ);
    TIME_ZONE_INFORMATION info;
    TCHAR final[64 + TZNAME_SIZE];
    TCHAR name[TZNAME_SIZE];
    DWORD TimeZoneId;

    if (g_bFirstBoot)
    {
        ShowWindow(ctl, SW_HIDE);
    }
    else
    {
        TimeZoneId = GetTimeZoneInformation(&info);
        if ( TimeZoneId == TIME_ZONE_ID_STANDARD )
        {
            StringCchCopy( name, ARRAYSIZE(name), info.StandardName );
        }
        else
        {
            StringCchCopy( name, ARRAYSIZE(name), info.DaylightName );
        }

        //
        //  Display nothing if it is our special 1st boot marker.
        //
        if (*name && (lstrcmpi(name, c_szFirstBootTZ) != 0))
        {
            static TCHAR format[128] = TEXT("");

            if (!*format)
            {
                GetWindowText( ctl, format, ARRAYSIZE(format) );
            }

            StringCchPrintf( final, ARRAYSIZE(final), format, name );
        }
        else
        {
            *final = 0;
        }

        SetWindowText(ctl, final);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  UnhookTime
//
//  To stop the clock calling us back all the time (around exit).
//
////////////////////////////////////////////////////////////////////////////

void UnhookTimer(
    HWND hDlg)
{
    SendDlgItemMessage(hDlg, DATETIME_CLOCK, CLM_TIMEHWND, CLF_SETHWND, 0);
}


////////////////////////////////////////////////////////////////////////////
//
//  TimeProvider
//
//  Called by the clock to find out what time it is.
//
////////////////////////////////////////////////////////////////////////////

void TimeProvider(
    LPSYSTEMTIME lpSystemTime,
    HWND hDlg)
{
    short wTemp[7];

    //
    //  If the user has modified the time, the clock should
    //  display the edit controls, otherwise its just the SystemTime.
    //
    if (g_Modified)
    {
        lpSystemTime->wHour   = (WORD)g_Time[HOUR];
        lpSystemTime->wMinute = (WORD)g_Time[MINUTE];
        lpSystemTime->wSecond = (WORD)g_Time[SECOND];
    }
    else
    {
#ifdef WIN32
        GetLocalTime(lpSystemTime);
#else
        GetTime();
        if (wDateTime[HOUR] >= 0 && wDateTime[HOUR] <= 24)
        {
            lpSystemTime->wHour = wDateTime[HOUR];
        }
        lpSystemTime->wMinute = wDateTime[MINUTE];
        lpSystemTime->wSecond = wDateTime[SECOND];

#endif
        //
        //  Copy the time and display it for us too.
        //
        g_bPM = IsAMPM(lpSystemTime->wHour);
        g_Time[HOUR]   = lpSystemTime->wHour;
        g_Time[MINUTE] = lpSystemTime->wMinute;
        g_Time[SECOND] = lpSystemTime->wSecond;

        //
        //  Check for date rollover.
        //
        if (!fDateDirty)
        {
            wTemp[DAY]   = wDateTime[DAY];
            wTemp[MONTH] = wDateTime[MONTH];
            wTemp[YEAR]  = wDateTime[YEAR];

            GetDate();

            if ((wDateTime[DAY]   != wTemp[DAY])   ||
                (wDateTime[MONTH] != wTemp[MONTH]) ||
                (wDateTime[YEAR]  != wTemp[YEAR]))
            {
                InvalidateRect(GetDlgItem(hDlg, DATETIME_CALENDAR), NULL, TRUE);

                if (wDateTime[MONTH] != wTemp[MONTH])
                {
                    ComboBox_SetCurSel( GetDlgItem(hDlg, DATETIME_MONTHNAME),
                                        wDateTime[MONTH] - 1 );
                }

                if (wDateTime[YEAR] != wTemp[YEAR])
                {
                    UpdateItem(hDlg, YEAR);
                }

                _ShowTZ(hDlg);
            }
        }
        
        UpdateItem(hDlg, HOUR);
        UpdateItem(hDlg, MINUTE);
        UpdateItem(hDlg, SECOND);
        ReflectAMPM(hDlg, g_Time[HOUR]);
    }
}

////////////////////////////////////////////////////////////////////////////
//
//  bSupportedCalendar
//
//  Returns True if the current calendar is not Hijri nor Hebrew
//
//  Otherwise it returns FALSE.
//
////////////////////////////////////////////////////////////////////////////

BOOL bSupportedCalendar()
{
    TCHAR tchCalendar[32];
    CALTYPE defCalendar = CAL_GREGORIAN;

    if (GetLocaleInfo(LOCALE_USER_DEFAULT,
                      LOCALE_ICALENDARTYPE,
                      tchCalendar,
                      ARRAYSIZE(tchCalendar)))
    {
        defCalendar = StrToInt(tchCalendar);
    }

    return (!(defCalendar == CAL_HIJRI || defCalendar == CAL_HEBREW));
}

////////////////////////////////////////////////////////////////////////////
//
//  InitDateTimeDlg
//
//  Called to init the dialog.
//
////////////////////////////////////////////////////////////////////////////

void InitDateTimeDlg(
    HWND hDlg,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    int nMaxDigitWidth;
    int i;
    TCHAR szNum[5];
    TCHAR szMonth[64];
    TCHAR szShortDate[12];
    HDC hDC;
    HFONT hFont;
    HWND hwndCB;
    CALID calId;
    static int nInc[] = { 1, 5, 5, 1, 1, 5 };

    HWND hwndScroll;
    UDACCEL udAccel[2];
    HWND hwndTBorder;

    HCURSOR oldcursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

    LCID lcid = LOCALE_USER_DEFAULT;

    InitCommonControls();

    //
    //  Sets the Leading zero status of the 6 controls.
    //
    g_bLZero[HOUR]   = g_bLZero[MONTH]  = g_bLZero[DAY]  = FALSE;
    g_bLZero[MINUTE] = g_bLZero[SECOND] = g_bLZero[YEAR] = TRUE;

    hDC = GetDC(hDlg);

    if (hFont = (HFONT)SendMessage(hDlg, WM_GETFONT, 0, 0L))
    {
        hFont = SelectObject( hDC, hFont );
    }

    if (hFont)
    {
        SelectObject(hDC, hFont);
    }

    AdjustAMPMPosition(hDlg);

    nMaxDigitWidth = GetMaxCharWidth(hDC);
    ReleaseDC(hDlg, hDC);

    g_bLZero[HOUR] = GetProfileInt(szIntl, TEXT("iTLZero"), 0);
    //
    // Initialize szShortDate in case GetProfileString fails.
    //
    StringCchCopy( szShortDate, ARRAYSIZE(szShortDate), IntlDef.sShortDate );
    GetProfileString(szIntl, TEXT("sShortDate"), IntlDef.sShortDate, szShortDate, ARRAYSIZE(szShortDate));
    ReadShortDate(szShortDate, g_bLZero + MONTH, g_bLZero + DAY, g_bLZero + YEAR);

    g_bLZero[YEAR] = TRUE;      //we always want the year to be 4 digits (this will be bad in late 9999)
    
    //
    //  Setup the TIME stuff.
    //
    GetTime();

    g_Time[HOUR]   = wDateTime[HOUR];
    g_Time[MINUTE] = wDateTime[MINUTE];
    g_Time[SECOND] = wDateTime[SECOND];

    GetProfileString(szIntl, TEXT("sTime"), IntlDef.sTime, szNum, 3);
    DateTimeInit(hDlg, DATETIME_HOUR, DATETIME_TSEP1, szNum, nMaxDigitWidth, FALSE);

    //
    //  Force all entries to be re-drawn,
    //
    g_LastTime[HOUR] = g_LastTime[MINUTE] = g_LastTime[SECOND] = -1;
    UpdateItem(hDlg, HOUR);
    UpdateItem(hDlg, MINUTE);
    UpdateItem(hDlg, SECOND);
    ReflectAMPM(hDlg, wDateTime[HOUR]);

    //
    //  Setup the Date stuff.
    //
    GetDate();

    g_sDateInfo[DAY].nMax = MonthUpperBound(wDateTime[MONTH], wDateTime[YEAR]);

    if (!g_bLZero[YEAR])
    {
        wDateTime[YEAR] %= 100;
        g_sDateInfo[YEAR].nMax = 99;
        g_sDateInfo[YEAR].nMin = 0;
    }
    else
    {
        g_sDateInfo[YEAR].nMax = 2099;
        g_sDateInfo[YEAR].nMin = 1980;
    }

    for (i = MONTH; i <= YEAR; i++)
    {
        wPrevDateTime[i] = -1;
    }

    //
    //  Get the month names. And select this month.
    //
    hwndCB = GetDlgItem(hDlg, DATETIME_MONTHNAME);
    ComboBox_ResetContent(hwndCB);
    //
    // If the current calendar is Hijri or Hebrew then use the Gregorian one.
    //
    if (!bSupportedCalendar())
        lcid = MAKELCID(MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US), SORT_DEFAULT);

    GetLocaleInfo(lcid, LOCALE_ICALENDARTYPE, szMonth, ARRAYSIZE(szMonth));
    calId = (CALID)StrToInt(szMonth);

    for (i = 0; i < 12; i++)
    {
        GetCalendarInfo(lcid, calId, CAL_SMONTHNAME1 + i, szMonth, ARRAYSIZE(szMonth), NULL);
        ComboBox_AddString(hwndCB, szMonth);
    }

    ComboBox_SetCurSel(hwndCB, wDateTime[MONTH] - 1);

    //
    //  Set the default modifier for the Year Updown arrows.
    //
    wParam -= DATETIME_HOUR;
    hwndScroll = GetDlgItem(hDlg, DATETIME_YARROW);
    SendMessage( hwndScroll,
                 UDM_SETRANGE,
                 0,
                 MAKELPARAM(g_sDateInfo[YEAR].nMax, g_sDateInfo[YEAR].nMin) );

    udAccel[0].nSec = 0;
    udAccel[0].nInc = 1;
    udAccel[1].nSec = 2;
    udAccel[1].nInc = nInc[YEAR];

    SendMessage(hwndScroll, UDM_SETACCEL, 2, (LPARAM)(LPUDACCEL)udAccel);
    SendMessage(hwndScroll, UDM_SETBUDDY, (WPARAM)GetDlgItem(hDlg, DATETIME_YEAR), 0L);

    //
    //  Set the default modifier for the time arrows.
    //  It should control the HOURS by default as per joelgros
    //
    hwndScroll = GetDlgItem(hDlg, DATETIME_TARROW);
    SendMessage( hwndScroll,
                 UDM_SETRANGE,
                 0,
                 MAKELPARAM( g_sDateInfo[HOUR].nMax,
                             g_sDateInfo[HOUR].nMin) );
    udAccel[0].nSec = 0;
    udAccel[0].nInc = 1;
    udAccel[1].nSec = 2;
    udAccel[1].nInc = nInc[HOUR];
    
    SendMessage( hwndScroll, UDM_SETACCEL, 2, (LPARAM)(LPUDACCEL)udAccel );
    SendMessage( hwndScroll, UDM_SETBUDDY, (WPARAM)GetDlgItem(hDlg, DATETIME_HOUR), 0L );

    //
    //  Make the 'well' for the digits appear.
    //
    hwndTBorder = GetDlgItem(hDlg, DATETIME_TBORDER);
    SetWindowLong( hwndTBorder,
                   GWL_EXSTYLE,
                   GetWindowLong(hwndTBorder, GWL_EXSTYLE) | WS_EX_CLIENTEDGE );

    //
    //  Display the border right now.
    //
    SetWindowPos( hwndTBorder,
                  NULL,
                  0, 0, 0, 0,
                  SWP_NOMOVE | SWP_NOSIZE | SWP_DRAWFRAME | SWP_SHOWWINDOW );

    //
    //  Display month->year.
    //
    for (i = MONTH; i <= YEAR; i++)
    {
        if ((wDateTime[i] != wPrevDateTime[i]) &&
            (GetFocus() != GetDlgItem(hDlg, DATETIME_HOUR + i)))
        {
            //
            //  Update previous date-time.
            //
            wPrevDateTime[i] = wDateTime[i];

            if (i == YEAR)
            {
                UpdateItem(hDlg, i);
            }
        }
    }

    g_Modified = FALSE;

    //
    //  Tell the clock that we have a time provider - must be done last.
    //
    SendDlgItemMessage( hDlg,
                        DATETIME_CLOCK,
                        CLM_TIMEHWND,
                        CLF_SETHWND,
                        (LPARAM)(LPINT)hDlg );

    SetCursor(oldcursor);
}


////////////////////////////////////////////////////////////////////////////
//
//  CheckNum
//
////////////////////////////////////////////////////////////////////////////

LRESULT CheckNum(
    HWND hDlg,
    UINT nScrollID,
    HWND hCtl)
{
    static int cReenter = 0;

    LRESULT lRet;

    //
    //  If this is an illegal value, (but not blank), then kill the last char
    //  that was entered.
    //
    lRet = SendDlgItemMessage(hDlg, nScrollID, UDM_GETPOS, 0, 0L);

    //
    //  Guard against re-entrance.
    //
    ++cReenter;

    if (cReenter <= 4)
    {
        SendMessage( hCtl,
                     HIWORD(lRet) && GetWindowTextLength(hCtl)
                         ? EM_UNDO
                         : EM_EMPTYUNDOBUFFER,
                     0,
                     0L );
    }

    --cReenter;

    return (lRet);
}


////////////////////////////////////////////////////////////////////////////
//
//  DateTimeDlgProc
//
//  Main dialog proc.
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK DateTimeDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    int i;

    switch (uMsg)
    {
        case (WM_INITDIALOG):
        {
            AddInternetPageAsync(GetParent(hDlg), hDlg);

            InitDateTimeDlg(hDlg, uMsg, wParam, lParam);
            g_PrevIMCForDateField = ImmAssociateContext(GetDlgItem(hDlg, DATETIME_YEAR), 0);
            break;
        }
        case ( WM_DESTROY ) :
        {
            if (g_PrevIMCForDateField)
            {
                ImmAssociateContext( GetDlgItem(hDlg, DATETIME_YEAR),
                                     g_PrevIMCForDateField );
            }
            UnhookTimer(hDlg);
            break;
        }
#ifdef WIN32
        case ( WM_CTLCOLORSTATIC ) :
#endif
        case ( WM_CTLCOLOR ) :
        {
            //
            //  Set the background color of the time controls to the the
            //  color of the edit controls.
            //
            if ((GET_WM_CTLCOLOR_HWND(wParam, lParam, uMsg) ==
                 GetDlgItem(hDlg, DATETIME_TSEP1)) ||
                (GET_WM_CTLCOLOR_HWND(wParam, lParam, uMsg) ==
                 GetDlgItem(hDlg, DATETIME_TSEP2)) ||
                (GET_WM_CTLCOLOR_HWND(wParam, lParam, uMsg) ==
                 GetDlgItem(hDlg, DATETIME_TBORDER)))
            {
#ifndef WIN32
                //
                //  Make the statics the color of the edits.
                //
                lParam = GET_WM_CTLCOLOR_MPS(
                            GET_WM_CTLCOLOR_HDC(wParam, lParam, uMsg),
                            GET_WM_CTLCOLOR_HWND(wParam, lParam, uMsg),
                            CTLCOLOR_EDIT );

                return ((INT_PTR)DefWindowProc(hDlg, uMsg, wParam, lParam));
#else
                return ((INT_PTR)DefWindowProc(hDlg, WM_CTLCOLOREDIT, wParam, lParam));
#endif
            }
            return (0);
            break;
        }
        case ( WM_NOTIFY ) :
        {
            //
            //  Property sheet handler stuff.
            //
            switch (((NMHDR *)lParam)->code)
            {
                case ( PSN_SETACTIVE ) :
                {
                    _ShowTZ(hDlg);
                    break;
                }
                case ( PSN_RESET ) :
                {
                    UnhookTimer(hDlg);

                    SetFocus(GetDlgItem(hDlg, (int)wParam));

                    GetDate();
                    GetTime();
                    break;
                }
                case ( PSN_APPLY ) :
                {
                    wDateTime[MINUTE] = (WORD)g_Time[MINUTE];
                    wDateTime[SECOND] = (WORD)g_Time[SECOND];

                    if (g_b24HR)
                    {
                        wDateTime[HOUR] = (WORD)g_Time[HOUR];
                    }
                    else
                    {
                        wDateTime[HOUR] = g_Time[HOUR] % 12;

                        if (g_bPM)
                        {
                            wDateTime[HOUR] += 12;
                        }
                    }
                    
                    g_WasModified = g_Modified;
                    SetTime();

                    g_LastTime[HOUR] = g_LastTime[MINUTE] = g_LastTime[SECOND] = -1;

                    for (i = MONTH; i <= YEAR; i++)
                    {
                        wPrevDateTime[i] = -1;
                    }

                    g_Modified = FALSE;

                    wPrevDateTime[HOUR]    = wDateTime[HOUR];
                    wPrevDateTime[MINUTE]  = wDateTime[MINUTE];
                    wPrevDateTime[SECOND]  = wDateTime[SECOND];
                    wPrevDateTime[MONTH]   = wDateTime[MONTH];
                    wPrevDateTime[DAY]     = wDateTime[DAY];
                    wPrevDateTime[YEAR]    = wDateTime[YEAR];
                    wPrevDateTime[WEEKDAY] = wDateTime[WEEKDAY];

                    //
                    //  We handled it - no repaint.
                    //
                    return (TRUE);
                }
            }
            break;
        }
        case ( WM_VSCROLL ) :
        {
            switch (GET_WM_VSCROLL_CODE(wParam, lParam))
            {
                case ( SB_THUMBPOSITION ) :
                {
                    SYSTEMTIME SystemTime;
                    HWND hBuddy = (HWND)SendMessage(
                                           GET_WM_VSCROLL_HWND(wParam, lParam),
                                           UDM_GETBUDDY,
                                           0,
                                           0L );

                    if (hBuddy == GetDlgItem(hDlg, DATETIME_HOUR))
                    {
                        g_Time[HOUR] = GET_WM_VSCROLL_POS(wParam, lParam);
                    }
                    else if (hBuddy == GetDlgItem(hDlg, DATETIME_MINUTE))
                    {
                        g_Time[MINUTE] = GET_WM_VSCROLL_POS(wParam, lParam);
                    }
                    else if (hBuddy == GetDlgItem(hDlg, DATETIME_SECOND))
                    {
                        g_Time[SECOND] = GET_WM_VSCROLL_POS(wParam, lParam);
                    }
                //  else if (hBuddy == GetDlgItem(hDlg, DATETIME_AMPM))

                    if (hBuddy != GetDlgItem(hDlg, DATETIME_YEAR))  
                        g_Modified = TRUE;

                    //
                    //  Light the apply now button.
                    //
                    PropSheet_Changed(GetParent(hDlg), hDlg);

                    //
                    //  Force the clock to reflect this setting.
                    //
                    TimeProvider(&SystemTime, hDlg);

                    SendDlgItemMessage( hDlg,
                                        DATETIME_CLOCK,
                                        CLM_UPDATETIME,
                                        CLF_SETTIME,
                                        (LPARAM)(LPSYSTEMTIME)&SystemTime );

                    //
                    //  Fall thru to update the year...
                    //
                }
                case ( SB_ENDSCROLL ) :
                {
                    //
                    //  If this is the year, have the calendar repaint.
                    //
                    if ((HWND)SendMessage( GET_WM_VSCROLL_HWND(wParam, lParam),
                                           UDM_GETBUDDY,
                                           0,
                                           0L ) == GetDlgItem(hDlg, DATETIME_YEAR))
                    {
                        //
                        //  Have it update the information.
                        //
                        GetTime();
                        AdjustDelta(hDlg, YEAR);
                        UpdateItem(hDlg, YEAR);

                        InvalidateRect( GetDlgItem(hDlg, DATETIME_CALENDAR),
                                        NULL,
                                        TRUE );
                    }

                    break;
                }
            }
            break;
        }
        case ( CLM_UPDATETIME ) :
        {
            //
            //  The clock updating/reflecting the time.
            //
            switch (wParam)
            {
                case ( CLF_SETTIME ) :
                {
                    //
                    //  Clock telling us what the time is.
                    //
                    g_Modified = TRUE;
                    g_Time[HOUR] = ((LPSYSTEMTIME)lParam)->wHour;
                    g_Time[MINUTE] = ((LPSYSTEMTIME)lParam)->wMinute;
                    g_Time[SECOND] = ((LPSYSTEMTIME)lParam)->wSecond;
                    g_bPM = IsAMPM(g_Time[HOUR]);
                    break;
                }
                case ( CLF_GETTIME ) :
                {
                    //
                    //  We tell the clock what time it is.
                    //
                    TimeProvider((LPSYSTEMTIME)lParam, hDlg);
                    break;
                }
            }
            break;
        }
        case ( WM_COMMAND ) :
        {
            //
            //  Command processing.
            //
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case ( DATETIME_AMPM ) :
                {
                    //
                    //  Deals with the AMPM control.
                    //
                    UDACCEL udAccel;
                    HWND hwndScroll = GetDlgItem(hDlg, DATETIME_TARROW);
                    HWND hwndThisCtl = GET_WM_COMMAND_HWND(wParam, lParam);

                    //
                    //  We only care if we get/loose the focus.
                    //
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case ( LBN_SETFOCUS ) :
                        {
                            //
                            //  If we get the focus, then the UD control
                            //  should deal with the AMPM.
                            //
                            //  Select the visible entry.
                            //
                            ReflectAMPM(hDlg, wDateTime[HOUR]);

                            // if it has a buddy, remove it...
                            if ((HWND)SendMessage( hwndScroll,
                                               UDM_GETBUDDY,
                                               0,
                                               0 ) != NULL)
                            {
                                SendMessage(hwndScroll, UDM_SETBUDDY, 0, 0);
                            } 
                            
                            //
                            //  Tell the UD control how to manipulate AM/PM.
                            //
                            SendMessage( hwndScroll,
                                         UDM_SETRANGE,
                                         0,
                                         MAKELPARAM(1, 0) );
                            udAccel.nSec = 0;
                            udAccel.nInc = 1;
                            SendMessage( hwndScroll,
                                         UDM_SETACCEL,
                                         1,
                                         (LPARAM)(LPUDACCEL)&udAccel );
                            SendMessage( hwndScroll,
                                         UDM_SETBUDDY,
                                         (WPARAM)hwndThisCtl,
                                         0 );
                            break;
                        }
                        case ( LBN_KILLFOCUS ) :
                        {
                            //
                            //  When we loose focus, the g_bPM flag is updated.
                            //
                            //  Remove selection from the AM/PM.
                            //
                            ListBox_SetCurSel(hwndThisCtl, -1);

                            if ((HWND)SendMessage( hwndScroll,
                                                   UDM_GETBUDDY,
                                                   0,
                                                   0 ) == hwndThisCtl)
                            {
                                SendMessage(hwndScroll, UDM_SETBUDDY, 0, 0);
                            }

                            break;
                        }
                        case ( LBN_SELCHANGE ) :
                        {
                            if ((g_Modified == FALSE) &&
                                (g_bPM == (BOOL)ListBox_GetTopIndex(hwndThisCtl)))
                            {
                                break;
                            }

                            //
                            //  Find the visible entry.
                            //
                            g_Modified = TRUE;

                            //
                            //  Light the apply now button.
                            //
                            PropSheet_Changed(GetParent(hDlg), hDlg);
                            g_bPM = (BOOL)ListBox_GetTopIndex(hwndThisCtl);
                            break;
                        }
                    }
                    break;
                }
                case ( DATETIME_HOUR ) :
                case ( DATETIME_MINUTE ) :
                case ( DATETIME_SECOND ) :
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case ( EN_CHANGE ) :
                        {
                            SYSTEMTIME SystemTime;

                            g_Modified = TRUE;

                            //
                            //  Light the apply now button.
                            //
                            PropSheet_Changed(GetParent(hDlg), hDlg);

                            //
                            //  Work out what the change was too.
                            //
                            g_Time[GET_WM_COMMAND_ID(wParam, lParam) -
                                   DATETIME_HOUR] =
                              (int)SendDlgItemMessage( hDlg,
                                                       DATETIME_TARROW,
                                                       UDM_GETPOS,
                                                       0,
                                                       0 );

                            //
                            //  Force the clock to reflect this setting.
                            //
                            TimeProvider(&SystemTime, hDlg);
                            SendDlgItemMessage( hDlg,
                                                DATETIME_CLOCK,
                                                CLM_UPDATETIME,
                                                0,
                                                (LPARAM)(LPSYSTEMTIME)&SystemTime );
                            break;
                        }
                    }

                    //  fall thru...
                }
                case ( DATETIME_MONTH ) :
                case ( DATETIME_YEAR ) :
                case ( DATETIME_DAY ) :
                {
                    switch (GET_WM_COMMAND_CMD(wParam, lParam))
                    {
                        case ( EN_CHANGE ) :
                        {
                            CheckNum( hDlg,
                                      GET_WM_COMMAND_ID(wParam, lParam) <= DATETIME_SECOND
                                          ? DATETIME_TARROW
                                          : DATETIME_YARROW,
                                      GET_WM_COMMAND_HWND(wParam, lParam) );

                            // Changing the year may alter the number of days in February.
                            // Yes this is a hack, but this entire applet is a giant
                            // broken hack and I want to change it as little as possible.
                            if (GET_WM_COMMAND_ID(wParam, lParam) == DATETIME_YEAR && wDateTime[MONTH] == 2)
                            {
                                g_sDateInfo[DAY].nMax = MonthUpperBound( wDateTime[MONTH],
                                                                         wDateTime[YEAR] );
                                if (wDateTime[DAY] > g_sDateInfo[DAY].nMax)
                                {
                                    wDateTime[DAY] = (WORD)g_sDateInfo[DAY].nMax;
                                    fDateDirty = TRUE;
                                }
                                InvalidateRect( GetDlgItem(hDlg, DATETIME_CALENDAR),
                                                NULL,
                                                TRUE );
                            }
                            break;
                        }
                        case ( EN_SETFOCUS ) :
                        {
                            UINT id = GET_WM_COMMAND_ID(wParam, lParam) - DATETIME_HOUR;

                            if (id <= SECOND)
                            {
                                UDACCEL udAccel[2];
                                static int nInc[] = { 1, 5, 5, 1, 1, 5 };
                                HWND hwndScroll = GetDlgItem(hDlg, DATETIME_TARROW);

                                // if it has a buddy, remove it...
                                if ((HWND)SendMessage( hwndScroll,
                                                   UDM_GETBUDDY,
                                                   0,
                                                   0 ) != NULL)
                                {
                                    SendMessage(hwndScroll, UDM_SETBUDDY, 0, 0);
                                }    

                                //
                                // now set the new one
                                //
                                SendMessage( hwndScroll,
                                             UDM_SETRANGE,
                                             0,
                                             MAKELPARAM( g_sDateInfo[id].nMax,
                                                         g_sDateInfo[id].nMin) );
                                udAccel[0].nSec = 0;
                                udAccel[0].nInc = 1;
                                udAccel[1].nSec = 2;
                                udAccel[1].nInc = nInc[id];
                                SendMessage( hwndScroll,
                                             UDM_SETACCEL,
                                             2,
                                             (LPARAM)(LPUDACCEL)udAccel );

                                //
                                //  Set the UD to update this control.
                                //
                                SendMessage( hwndScroll,
                                             UDM_SETBUDDY,
                                             (WPARAM)GET_WM_COMMAND_HWND(wParam,
                                                                         lParam),
                                             0 );
                            }
                            break;
                        }
                        case ( EN_KILLFOCUS ) :
                        {
                            //
                            //  Gets in range HMS MDY.
                            //
                            UINT id = GET_WM_COMMAND_ID(wParam, lParam) - DATETIME_HOUR;

                            AdjustDelta(hDlg, id);
                            UpdateItem(hDlg, id);                           

                            //
                            //  If control is YEAR.
                            //
                            if (id == (DATETIME_YEAR - DATETIME_HOUR))
                            {
                                InvalidateRect( GetDlgItem(hDlg, DATETIME_CALENDAR),
                                                NULL,
                                                TRUE );
                            }

                            break;
                        }
                        default :
                        {
                            break;
                        }
                    }
                    break;
                }
                case ( DATETIME_MONTHNAME ) :
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE)
                    {
                        int nIndex = 1 + (int)ComboBox_GetCurSel(
                                              GetDlgItem( hDlg,
                                                          DATETIME_MONTHNAME ));

                        if (wDateTime[MONTH] != nIndex)
                        {
                            AdjustDeltaMonth(nIndex);
                            InvalidateRect( GetDlgItem(hDlg, DATETIME_CALENDAR),
                                            NULL,
                                            TRUE );
                            PropSheet_Changed(GetParent(hDlg), hDlg);
                        }
                    }
                    break;
                }
                case ( DATETIME_CALENDAR ) :
                {
                    //
                    //  If the calendar sent us a change, we will assume
                    //  that it is to allow the apply now to work.
                    //
                    PropSheet_Changed(GetParent(hDlg), hDlg);
                    break;
                }
            }
            break;
        }
        case ( WM_WININICHANGE ) :
        {
            //
            //  Reinitialize if there is a time format change.
            //
            InitDateTimeDlg(hDlg, uMsg, wParam, lParam);
            InvalidateRect(GetDlgItem(hDlg, DATETIME_CALENDAR), NULL, TRUE);
            break;
        }
        case ( WM_TIMECHANGE ) :
        {
            //
            //  Forward time change messages to the clock control.
            //
            SendDlgItemMessage( hDlg,
                                DATETIME_CLOCK,
                                WM_TIMECHANGE,
                                wParam,
                                lParam );

            break;
        }

        case ( WMUSER_ADDINTERNETTAB ) :
        {
            AddInternetTab(hDlg);
            break;
        }

        case ( WM_HELP ) :             // F1
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     NULL,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aDateTimeHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     NULL,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aDateTimeHelpIds );
            break;
        }
        default :
        {
            return (FALSE);
        }
    }
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetZoneState
//
//  Sets the display state of a time zone in the map control.
//
////////////////////////////////////////////////////////////////////////////

void SetZoneState(
    HWND map,
    PTZINFO zone,
    BOOL highlight)
{
    if (zone)
    {
        if (zone->SeaIndex >= 0)
        {
            MapControlSetSeaRegionHighlight( map,
                                             zone->SeaIndex,
                                             highlight,
                                             zone->MapLeft,
                                             zone->MapWidth );
        }

        if (zone->LandIndex >= 0)
        {
            MapControlSetLandRegionHighlight( map,
                                              zone->LandIndex,
                                              highlight,
                                              zone->MapLeft,
                                              zone->MapWidth );
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  SetZoneFamilyState
//
//  Sets the display state of a time zone family in the map control.
//
////////////////////////////////////////////////////////////////////////////

void SetZoneFamilyState(
    HWND map,
    PTZINFO family,
    BOOL highlight)
{
    if (family)
    {
        PTZINFO zone = family;

        do
        {
            SetZoneState(map, zone, highlight);
            zone = zone->next;
        }
        while(zone && (zone != family));
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ParseMapInfo
//
//  Parses the color table information about the world bitmap we display.
//
//  Expected format: "sea,land"
//    where sea and land are color table indices or -1.
//
////////////////////////////////////////////////////////////////////////////

void ParseMapInfo(
    PTZINFO zone,
    const TCHAR *text)
{
    const TCHAR *p = text;

    zone->SeaIndex = zone->LandIndex = -1;

    if (*p)
    {
        if (*p != TEXT('-'))
        {
            zone->SeaIndex = 0;

            while (*p && (*p != TEXT(',')))
            {
                zone->SeaIndex = (10 * zone->SeaIndex) + (*p - TEXT('0'));
                p++;
            }
        }
        else
        {
            do
            {
                p++;
            } while (*p && (*p != TEXT(',')));
        }

        if (*p == TEXT(','))
        {
            p++;
        }

        if (*p)
        {
            if (*p != TEXT('-'))
            {
                zone->LandIndex = 0;

                while (*p)
                {
                    zone->LandIndex = (10 * zone->LandIndex) + (*p - TEXT('0'));
                    p++;
                }
            }
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ReadZoneData
//
//  Reads the data for a time zone from the registry.
//
////////////////////////////////////////////////////////////////////////////

BOOL ReadZoneData(
    PTZINFO zone,
    HKEY key,
    LPCTSTR keyname)
{
    TCHAR mapinfo[16];
    DWORD len;
    DWORD lenRet;

    lenRet = sizeof(zone->szDisplayName);

    if (RegQueryValueEx( key,
                         c_szTZDisplayName,
                         0,
                         NULL,
                         (LPBYTE)zone->szDisplayName,
                         &lenRet ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }
    else
    {
        zone->szDisplayName[ ARRAYSIZE(zone->szDisplayName) - 1 ] = L'\0';  //  make sure it is terminated
    }

    //
    //  Under NT, the keyname is the "Standard" name.  Values stored
    //  under the keyname contain the other strings and binary info
    //  related to the time zone.  Every time zone must have a standard
    //  name, therefore, we save registry space by using the Standard
    //  name as the subkey name under the "Time Zones" key.
    //
    lenRet = sizeof(zone->szStandardName);

    if (RegQueryValueEx( key,
                         c_szTZStandardName,
                         0,
                         NULL,
                         (LPBYTE)zone->szStandardName,
                         &lenRet ) != ERROR_SUCCESS)
    {
        //
        //  Use keyname if can't get StandardName value.
        //
        StringCchCopy( zone->szStandardName, ARRAYSIZE(zone->szStandardName), keyname );
    }
    else
    {
        zone->szStandardName[ ARRAYSIZE(zone->szStandardName) - 1 ] = L'\0';    // make sure it is terminated
    }

    lenRet = sizeof(zone->szDaylightName);

    if (RegQueryValueEx( key,
                         c_szTZDaylightName,
                         0,
                         NULL,
                         (LPBYTE)zone->szDaylightName,
                         &lenRet ) != ERROR_SUCCESS)
    {
        return (FALSE);
    }
    else
    {
        zone->szDaylightName[ ARRAYSIZE(zone->szDaylightName) - 1 ] = L'\0';    // make sure it is terminated
    }

    lenRet = len = sizeof(zone->Bias) 
                 + sizeof(zone->StandardBias) 
                 + sizeof(zone->DaylightBias) 
                 + sizeof(zone->StandardDate) 
                 + sizeof(zone->DaylightDate);

    if (RegQueryValueEx( key,
                         c_szTZI,
                         0,
                         NULL,
                         (LPBYTE)&zone->Bias,
                         &lenRet ) != ERROR_SUCCESS
      || lenRet != len )
    {
        return (FALSE);
    }

    len = sizeof(mapinfo);

    if (RegQueryValueEx( key,
                         c_szTZMapInfo,
                         0,
                         NULL,
                         (LPBYTE)mapinfo,
                         &len ) != ERROR_SUCCESS)
    {
        mapinfo[0] = TEXT('\0');
    }
    else
    {
        mapinfo[ARRAYSIZE(mapinfo) - 1 ] = L'\0';
    }

    ParseMapInfo(zone, mapinfo);

    //
    //  Generate phony MapLeft and MapRight until they show up in the
    //  registry.
    //
    zone->MapLeft = ((zone->Bias * ZONE_IMAGE_SCALE) / ZONE_BIAS_SCALE) +
                    ZONE_IMAGE_LEFT;

    zone->MapWidth = ZONE_IMAGE_WIDTH;

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  AddZoneToList
//
//  Inserts a new time zone into a list, sorted by bias and then name.
//
////////////////////////////////////////////////////////////////////////////

void AddZoneToList(
    PTZINFO *list,
    PTZINFO zone)
{
    if (*list)
    {
        PTZINFO curr = NULL;
        PTZINFO next = *list;

        while (next && zone->Bias <= next->Bias)
        {
            if (zone->Bias == next->Bias)
            {
                if (CompareString( GetUserDefaultLCID(),
                                   0,
                                   zone->szDisplayName,
                                   -1,
                                   next->szDisplayName,
                                   -1 ) == CSTR_LESS_THAN)
                {
                    break;
                }
            }
            curr = next;
            next = curr->next;
        }

        zone->next = next;

        if (curr)
        {
            curr->next = zone;
        }
        else
        {
            *list = zone;
        }
    }
    else
    {
        *list = zone;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  FreeTimezoneList
//
//  Frees all time zones in the passed list, setting the head to NULL.
//
////////////////////////////////////////////////////////////////////////////

void FreeTimezoneList(
    PTZINFO *list)
{
    while (*list)
    {
        PTZINFO next = (*list)->next;

        LocalFree((HANDLE)*list);

        *list = next;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ReadTimezones
//
//  Reads the time zone information from the registry.
//  Returns num read, -1 on failure.
//
////////////////////////////////////////////////////////////////////////////

int ReadTimezones(
    PTZINFO *list)
{
    HKEY key = NULL;
    int count = -1;

    *list = NULL;

    if (RegOpenKey( HKEY_LOCAL_MACHINE,
                    c_szTimeZones,
                    &key ) == ERROR_SUCCESS)
    {
        TCHAR name[TZNAME_SIZE];
        PTZINFO zone = NULL;
        int i;

        count = 0;

        for (i = 0;
             RegEnumKey(key, i, name, TZNAME_SIZE) == ERROR_SUCCESS;
             i++)
        {
            HKEY subkey = NULL;

            if (!zone &&
                ((zone = (PTZINFO)LocalAlloc(LPTR, sizeof(TZINFO))) == NULL))
            {
                zone = *list;
                *list = NULL;
                count = -1;
                break;
            }

            zone->next = NULL;

            if (RegOpenKey(key, name, &subkey) == ERROR_SUCCESS)
            {
                //
                //  Each sub key name under the Time Zones key is the
                //  "Standard" name for the Time Zone.
                //
                StringCchCopy( zone->szStandardName, ARRAYSIZE(zone->szStandardName), name );

                if (ReadZoneData(zone, subkey, name))
                {
                    AddZoneToList(list, zone);
                    zone = NULL;
                    count++;
                }

                RegCloseKey(subkey);
            }
        }

        FreeTimezoneList(&zone);
        RegCloseKey(key);
    }

    return (count);
}


////////////////////////////////////////////////////////////////////////////
//
//  InitZoneMapping
//
//  Initializes map and map lookup for a specific time zone.
//
////////////////////////////////////////////////////////////////////////////

void InitZoneMapping(
    PTZINFO *lookup,
    PTZINFO list,
    HWND map)
{
    PTZINFO zone = list;    // not needed but more readable

    while (zone)
    {
        if (zone->SeaIndex >= 0)
        {
            lookup[zone->SeaIndex] = zone;
        }

        if (zone->LandIndex >= 0)
        {
            lookup[zone->LandIndex] = zone;
        }

        SetZoneState(map, zone, FALSE);
        zone = zone->next;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  BreakZonesIntoFamilies
//
//  Breaks the passed list into many circular lists.
//  Each list consists of all time zones with a particular bias.
//  Assumes the passed list is sorted by bias.
//
////////////////////////////////////////////////////////////////////////////

void BreakZonesIntoFamilies(
    PTZINFO head)
{
    PTZINFO subhead = NULL;
    PTZINFO last = NULL;
    PTZINFO zone = head;

    while (zone)
    {
        subhead = zone;

        do
        {
            last = zone;
            zone = zone->next;
        }
        while (zone && (zone->Bias == subhead->Bias));

        last->next = subhead;
    }

    //
    //  Merge -12 and +12 zones into a single group.
    //  Assumes populated registry and depends on sort order.
    //
    if ((subhead) &&
        (subhead->Bias == BIAS_PLUS_12) &&
        (head->Bias == BIAS_MINUS_12))
    {
        PTZINFO next = head;

        do
        {
            zone = next;
            next = zone->next;
        }
        while (next != head);

        zone->next = subhead;
        last->next = head;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  InitTimezones
//
//  Initializes time zone stuff, UI and otherwise.
//
////////////////////////////////////////////////////////////////////////////

BOOL InitTimezones(
    HWND page,
    PTZINFO *lookup)
{
    PTZINFO list = NULL;

    if ((g_nTimeZones = ReadTimezones(&list)) >= 0)
    {
        HWND combo = GetDlgItem(page, IDD_TIMEZONES);
        PTZINFO zone = list;

        SetWindowRedraw(combo, FALSE);

        while (zone)
        {
            int index = ComboBox_AddString(combo, zone->szDisplayName);

            if (index < 0)
            {
                break;
            }
            zone->ComboIndex = index;
            ComboBox_SetItemData(combo, index, (LPARAM)zone);
            zone = zone->next;
        }

        SetWindowRedraw(combo, TRUE);

        if (!zone)
        {
            InitZoneMapping(lookup, list, GetDlgItem(page, IDD_TIMEMAP));
            BreakZonesIntoFamilies(list);
            return (TRUE);
        }

        FreeTimezoneList(&list);
        ComboBox_ResetContent(combo);
    }

    return (FALSE);
}


////////////////////////////////////////////////////////////////////////////
//
//  ChangeZone
//
//  Updates the current zone, making sure new zone's family is highlighted.
//
////////////////////////////////////////////////////////////////////////////

void ChangeZone(
    HWND page,
    TZPAGE_STATE *state,
    PTZINFO zone)
{
    if (zone || state->zone)
    {
        BOOL newfamily = (!zone || !state->zone ||
                          (zone->Bias != state->zone->Bias));
        HWND map = GetDlgItem(page, IDD_TIMEMAP);
        BOOL dayval = (zone && (zone->StandardDate.wMonth != 0));

        if (newfamily && state->zone)
        {
            SetZoneFamilyState(map, state->zone, FALSE);
        }

        state->zone = zone;

        if (newfamily && state->zone)
        {
            SetZoneFamilyState(map, state->zone, TRUE);
        }

        if (newfamily)
        {
            MapControlInvalidateDirtyRegions(map);
        }

        ShowWindow(GetDlgItem(page, IDD_AUTOMAGIC), (dayval != 0 ? SW_SHOW : SW_HIDE));

        if (!state->initializing)
        {
            PropSheet_Changed(GetParent(page), page);
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  HotTrackZone
//
//  Updates the map highlighting and combo selection for a given map index.
//  Expects to be called with dups.
//
////////////////////////////////////////////////////////////////////////////

void HotTrackZone(
    HWND page,
    TZPAGE_STATE *state,
    int index)
{
    PTZINFO zone = state->lookup[index];

    if (zone && (zone != state->zone))
    {
        ComboBox_SetCurSel( GetDlgItem(page, IDD_TIMEZONES),
                            (zone ? zone->ComboIndex : -1) );
        ChangeZone(page, state, zone);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CenterZone
//
//  Updates the map highlighting and combo selection for a given map index.
//  Expects to be called with dups.
//
////////////////////////////////////////////////////////////////////////////

void CenterZone(
    HWND page,
    TZPAGE_STATE *state,
    BOOL animate)
{
    PTZINFO zone = state->zone;

    if (zone)
    {
        HWND map = GetDlgItem(page, IDD_TIMEMAP);

        MapControlRotateTo(map, zone->MapLeft + zone->MapWidth / 2, animate);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  GetPTZ
//
//  Returns the pointer for the iItem time zone.
//  If iItem is -1 on entry, use the currently selected time zone.
//
////////////////////////////////////////////////////////////////////////////

PTZINFO GetPTZ(
    HWND hDlg,
    int iItem)
{
    HWND hCtl = GetDlgItem(hDlg, IDD_TIMEZONES);

    if (iItem == -1)
    {
        iItem = (int)ComboBox_GetCurSel(hCtl);
    }

    if (iItem < 0)
    {
        return (NULL);
    }

    return ((PTZINFO)ComboBox_GetItemData(hCtl, iItem));
}


////////////////////////////////////////////////////////////////////////////
//
//  GetAllowLocalTimeChange
//
////////////////////////////////////////////////////////////////////////////

TCHAR c_szRegPathTZControl[] = REGSTR_PATH_TIMEZONE;
TCHAR c_szRegValDisableTZUpdate[] = REGSTR_VAL_TZNOAUTOTIME;

BOOL GetAllowLocalTimeChange()
{
    //
    //  Assume allowed until we see a disallow flag.
    //
    BOOL result = TRUE;
    HKEY key;

    if (RegOpenKey( HKEY_LOCAL_MACHINE,
                    c_szRegPathTZControl,
                    &key ) == ERROR_SUCCESS)
    {
        //
        //  Assume no disallow flag until we see one.
        //
        DWORD value = 0;
        long len = sizeof(value);
        DWORD type;

        if ((RegQueryValueEx( key,
                              c_szRegValDisableTZUpdate,
                              NULL,
                              &type,
                              (LPBYTE)&value,
                              &len ) == ERROR_SUCCESS) &&
            ((type == REG_DWORD) || (type == REG_BINARY)) &&
            (len == sizeof(value)) && value)
        {
            //
            //  Okay, we have a nonzero value, it is either:
            //
            //  1) 0xFFFFFFFF
            //      this is set in an inf file for first boot to prevent
            //      the base from performing any cutovers during setup.
            //
            //  2) some other value
            //      this signifies that the user actualy disabled cutovers
            //     *return that local time changes are disabled
            //
            if (value != 0xFFFFFFFF)
            {
                result = FALSE;
            }
        }

        RegCloseKey(key);
    }

    return (result);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetAllowLocalTimeChange
//
////////////////////////////////////////////////////////////////////////////

void SetAllowLocalTimeChange(
    BOOL fAllow)
{
    HKEY key = NULL;

    if (fAllow)
    {
        //
        //  Remove the disallow flag from the registry if it exists.
        //
        if (RegOpenKey( HKEY_LOCAL_MACHINE,
                        c_szRegPathTZControl,
                        &key ) == ERROR_SUCCESS)
        {
            RegDeleteValue(key, c_szRegValDisableTZUpdate);
        }
    }
    else
    {
        //
        //  Add/set the nonzero disallow flag.
        //
        if (RegCreateKey( HKEY_LOCAL_MACHINE,
                          c_szRegPathTZControl,
                          &key ) == ERROR_SUCCESS)
        {
            DWORD value = 1;

            RegSetValueEx( key,
                           (LPCTSTR)c_szRegValDisableTZUpdate,
                           0UL,
                           REG_DWORD,
                           (LPBYTE)&value,
                           sizeof(value) );
        }
    }

    if (key)
    {
        RegCloseKey(key);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  InitTimeZonePage
//
//  This function initializes everything to do with the Time Zones.
//
////////////////////////////////////////////////////////////////////////////

BOOL InitTimeZonePage(
    HWND hDlg,
    TZPAGE_STATE *state)
{
    TIME_ZONE_INFORMATION tziCurrent;
    DWORD dwTZID;
    PTZINFO ptzi;
    int j ,iCurrentTZ;
    BOOL fForceSelection = FALSE;
    TCHAR temp[TZNAME_SIZE];
    TCHAR oldTzMapName[TZNAME_SIZE], newTzMapName[TZNAME_SIZE];


    //
    //  Get the current time zone information.
    //
    dwTZID = GetTimeZoneInformation(&tziCurrent);

    LoadString(g_hInst, IDS_ISRAELTIMEZONE, oldTzMapName, TZNAME_SIZE);
    LoadString(g_hInst, IDS_JERUSALEMTIMEZONE, newTzMapName, TZNAME_SIZE);
    
    // this is a hack for Win95 or WinNT 4 to Win98/Win2k migration. "Israel" became "Jerusalem"
    if (!lstrcmpi(oldTzMapName, tziCurrent.StandardName))
    {
        StringCchCopy( tziCurrent.StandardName, ARRAYSIZE(tziCurrent.StandardName), newTzMapName );
        fForceSelection = TRUE;
    }

    //
    //  Check for bogus time zone info.
    //
    if (dwTZID != TIME_ZONE_ID_INVALID)
    {
        //
        //  Copy the name out so we can check for first boot.
        //
        StringCchCopy( temp, ARRAYSIZE(temp), tziCurrent.StandardName );
    }
    else
    {
        //
        //  Treat bogus time zones like first boot.
        //
        StringCchCopy( temp, ARRAYSIZE(temp), c_szFirstBootTZ );
    }

    if (lstrcmpi(temp, c_szFirstBootTZ) == 0)
    {
        //
        //  The 'default' value of the time zone key specifies the
        //  default zone.
        //
        TCHAR szDefaultName[TZNAME_SIZE];
        LONG len = sizeof(szDefaultName);

        if (RegQueryValue( HKEY_LOCAL_MACHINE,
                           c_szTimeZones,
                           szDefaultName,
                           &len ) == ERROR_SUCCESS)
        {
            StringCchCopy( tziCurrent.StandardName, ARRAYSIZE(tziCurrent.StandardName), szDefaultName );
        }
        else
        {
            tziCurrent.StandardName[0] = L'\0';
        }

        //
        //  If we can't find it by name, use GMT.
        //
        tziCurrent.StandardBias = tziCurrent.DaylightBias = tziCurrent.Bias = 0;

        //
        //  Force the user to make a valid choice before quitting.
        //
        fForceSelection = TRUE;
    }

    //
    //  Get the Time Zones from the registry.
    //
    InitTimezones(hDlg, state->lookup);

    //
    //  Try to select the 'current' one or some equivalent.
    //

    //
    //  Start with an invalid index.
    //
    iCurrentTZ = g_nTimeZones;

    //
    //  Try to find by name.
    //
    for (j = 0; j < g_nTimeZones; j++)
    {
        ptzi = GetPTZ(hDlg, j);

        if (!lstrcmpi(ptzi->szStandardName, tziCurrent.StandardName))
        {
            iCurrentTZ = j;
            break;
        }
    }

    //
    //  If it hasn't been found yet, try to find a nearby zone using biases.
    //
    if (iCurrentTZ == g_nTimeZones)
    {
        int nBestHitCount = TZ_HIT_NONE;

        for (j = 0; j < g_nTimeZones; j++)
        {
            ptzi = GetPTZ(hDlg, j);

            if (ptzi->Bias == tziCurrent.Bias)
            {
                int nHitCount = TZ_HIT_BASE +
                            ((ptzi->StandardBias == tziCurrent.StandardBias) +
                             (ptzi->DaylightBias == tziCurrent.DaylightBias));

                if (nHitCount > nBestHitCount)
                {
                    nBestHitCount = nHitCount;
                    iCurrentTZ = j;

                    if (nHitCount >= TZ_HIT_EXACT)
                    {
                        break;
                    }
                }
            }
        }
    }

    //
    //  Still didn't find it?
    //
    if (iCurrentTZ == g_nTimeZones)
    {
        //
        //  Punt.
        //
        iCurrentTZ = 0;

        fForceSelection = TRUE;
    }

    //
    //  Set up the dialog using this time zone's info.
    //

    //
    //  If wMonth is 0, then this Time Zone does not support DST.
    //
    if ((tziCurrent.StandardDate.wMonth == 0) ||
        (tziCurrent.DaylightDate.wMonth == 0))
    {
        ShowWindow(GetDlgItem(hDlg, IDD_AUTOMAGIC), SW_HIDE);
    }

    //
    //  Always get "allow DLT" flag even if this zone is disabled.
    //
    CheckDlgButton(hDlg, IDD_AUTOMAGIC, GetAllowLocalTimeChange());

    ComboBox_SetCurSel(GetDlgItem(hDlg, IDD_TIMEZONES), iCurrentTZ);

    ChangeZone(hDlg, state, GetPTZ(hDlg, -1));
    CenterZone(hDlg, state, FALSE);

    if (fForceSelection || g_bFirstBoot)
    {
        PropSheet_Changed(GetParent(hDlg), hDlg);
        PropSheet_CancelToClose(GetParent(hDlg));
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  SetTheTimezone
//
//  Apply the User's time zone selection.
//
////////////////////////////////////////////////////////////////////////////

void SetTheTimezone(
    BOOL bAutoMagicTimeChange,
    BOOL bAutoMagicEnabled,
    PTZINFO ptzi)
{
    TIME_ZONE_INFORMATION tzi;
    HCURSOR hCurOld;

    if (!ptzi)
    {
        return;
    }

    tzi.Bias = ptzi->Bias;

    if ((bAutoMagicTimeChange == 0) ||
        (ptzi->StandardDate.wMonth == 0))
    {
        //
        //  Standard Only.
        //
        tzi.StandardBias = ptzi->StandardBias;
        tzi.DaylightBias = ptzi->StandardBias;
        tzi.StandardDate = ptzi->StandardDate;
        tzi.DaylightDate = ptzi->StandardDate;

        StringCchCopy( tzi.StandardName, ARRAYSIZE(tzi.StandardName), ptzi->szStandardName );
        StringCchCopy( tzi.DaylightName, ARRAYSIZE(tzi.DaylightName), ptzi->szStandardName );
    }
    else
    {
        //
        //  Automatically adjust for Daylight Saving Time.
        //
        tzi.StandardBias = ptzi->StandardBias;
        tzi.DaylightBias = ptzi->DaylightBias;
        tzi.StandardDate = ptzi->StandardDate;
        tzi.DaylightDate = ptzi->DaylightDate;

        StringCchCopy( tzi.StandardName, ARRAYSIZE(tzi.StandardName), ptzi->szStandardName );
        StringCchCopy( tzi.DaylightName, ARRAYSIZE(tzi.DaylightName), ptzi->szDaylightName );
    }

    SetAllowLocalTimeChange(bAutoMagicTimeChange);

    SetTimeZoneInformation(&tzi);
    
    hCurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));

    SetCursor(hCurOld);
}


////////////////////////////////////////////////////////////////////////////
//
//  TimeZoneDlgProc
//
////////////////////////////////////////////////////////////////////////////

INT_PTR CALLBACK TimeZoneDlgProc(
    HWND hDlg,
    UINT uMsg,
    WPARAM wParam,
    LPARAM lParam)
{
    TZPAGE_STATE *state = (TZPAGE_STATE *)GetWindowLongPtr(hDlg, DWLP_USER);

    int  i;

    switch (uMsg)
    {
        case ( WM_INITDIALOG ) :
        {
            state = (TZPAGE_STATE *)LocalAlloc(LPTR, sizeof(TZPAGE_STATE));

            SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)state);

            if (!state)
            {
                EndDialog(hDlg, -1);
                break;
            }

            state->initializing = TRUE;
            InitTimeZonePage(hDlg, state);
            state->initializing = FALSE;

            break;
        }
        case ( WM_DESTROY ) :
        {
            for (i = 0; i < g_nTimeZones; i++)
            {
                LocalFree((HLOCAL)GetPTZ(hDlg, i));
            }

            if (state)
            {
                LocalFree((HANDLE)state);
                SetWindowLongPtr(hDlg, DWLP_USER, 0L);
            }
            break;
        }
        case ( WM_NOTIFY ) :
        {
            switch (((NMHDR *)lParam)->idFrom)
            {
                case ( 0 ) :
                {
                    switch (((NMHDR *)lParam)->code)
                    {
                        case ( PSN_APPLY ) :
                        {
                            g_ptziCurrent = NULL;

                            //
                            //  Find out which listbox item was selected.
                            //
                            SetTheTimezone(
                                IsDlgButtonChecked(hDlg, IDD_AUTOMAGIC),
                                IsWindowVisible(GetDlgItem(hDlg, IDD_AUTOMAGIC)),
                                GetPTZ(hDlg, -1) );

                            //
                            // if the user had modified the time as well as the timezone,
                            // then we should honor the time that they gave us since they
                            // explicitly said this was the time.  If we don't then the
                            // time they entered will be offset by the timezone change
                            //
                       
                            if (g_WasModified)
                            {
                                g_WasModified = FALSE;
                                SetTime();
                            }
                            break;
                        }
                    }
                    break;
                }
                case ( IDD_TIMEMAP ) :
                {
                    NFYMAPEVENT *event = (NFYMAPEVENT *)lParam;

                    switch (event->hdr.code)
                    {
                        case ( MAPN_TOUCH ) :
                        {
                            HotTrackZone(hDlg, state, event->index);
                            break;
                        }
                        case ( MAPN_SELECT ) :
                        {
                            CenterZone(hDlg, state, TRUE);
                            break;
                        }
                    }
                    break;
                }
            }
            break;
        }
        case ( WM_COMMAND ) :
        {
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
                case ( IDD_TIMEZONES ) :    // combo box
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == CBN_SELCHANGE)
                    {
                        ChangeZone(hDlg, state, GetPTZ(hDlg, -1));
                        CenterZone(hDlg, state, TRUE);
                    }
                    break;
                }
                case ( IDD_AUTOMAGIC ) :    // check box
                {
                    if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
                    {
                        PropSheet_Changed(GetParent(hDlg), hDlg);
                    }
                    break;
                }
            }
            break;
        }
        case ( WM_HELP ) :             // F1
        {
            WinHelp( (HWND)((LPHELPINFO)lParam)->hItemHandle,
                     NULL,
                     HELP_WM_HELP,
                     (DWORD_PTR)(LPTSTR)aDateTimeHelpIds );
            break;
        }
        case ( WM_CONTEXTMENU ) :      // right mouse click
        {
            WinHelp( (HWND)wParam,
                     NULL,
                     HELP_CONTEXTMENU,
                     (DWORD_PTR)(LPTSTR)aDateTimeHelpIds );
            break;
        }
        default :
        {
            return (FALSE);
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetClInt
//
//  Steal an int from the command line.
//
////////////////////////////////////////////////////////////////////////////

static int GetClInt(
    const TCHAR *p)
{
    BOOL neg = FALSE;
    int v = 0;

    //
    //  Skip spaces.
    //
    while (*p == TEXT(' '))
    {
        p++;
    }

    //
    //  See if it's negative.
    //
    if (*p == TEXT('-'))
    {
        //
        //  It's negative.  Remember that it's negative and skip the
        //  '-' char.
        //
        neg = TRUE;
        p++;
    }

    //
    //  Parse the absolute portion.  Digits only.
    //
    while ((*p >= TEXT('0')) && (*p <= TEXT('9')))
    {
        //
        //  Accumulate the value.
        //
        v = v * 10 + *p++ - TEXT('0');
    }

    //
    //  Return the result.
    //
    return (neg ? -v : v);
}


////////////////////////////////////////////////////////////////////////////
//
//  SelectZoneByName
//
////////////////////////////////////////////////////////////////////////////

BOOL SelectZoneByName(
    LPCTSTR cmdline)
{
    BOOL result = FALSE;
    HKEY key = NULL;

    while (*cmdline == TEXT(' '))
    {
        cmdline++;
    }

    if (!*cmdline)
    {
        return (FALSE);
    }

    if (RegOpenKey( HKEY_LOCAL_MACHINE,
                    c_szTimeZones,
                    &key ) == ERROR_SUCCESS)
    {
        TCHAR name[TZNAME_SIZE];
        HKEY subkey = NULL;
        TZINFO zone;

        //
        //  User can pass key name.
        //
        if (RegOpenKey(key, cmdline, &subkey) == ERROR_SUCCESS)
        {
            if (ReadZoneData(&zone, subkey, cmdline))
            {
                result = TRUE;
            }
        }
        else
        {
            //
            //  User can also pass display name.
            //
            int i;
            int CmdLen = lstrlen(cmdline);

            for (i = 0;
                 RegEnumKey(key, i, name, TZNAME_SIZE) == ERROR_SUCCESS;
                 i++)
            {
                if (RegOpenKey(key, name, &subkey) == ERROR_SUCCESS)
                {
                    LONG len = sizeof(zone.szDisplayName);

                    LRESULT lr = RegQueryValueEx( subkey
                                                , c_szTZDisplayName
                                                , 0
                                                , NULL
                                                , (LPBYTE) &zone.szDisplayName
                                                , &len 
                                                );
                    if ( ERROR_SUCCESS == lr )
                    {
                        zone.szDisplayName[ ARRAYSIZE(zone.szDisplayName) - 1 ] = L'\0'; // make sure it is terminated.

                        if ( CompareString( GetUserDefaultLCID()
                                          , NORM_IGNORECASE  | NORM_IGNOREKANATYPE 
                                          | NORM_IGNOREWIDTH | NORM_IGNORENONSPACE
                                          , zone.szDisplayName
                                          , (CmdLen < 15) ? -1 : min(lstrlen(zone.szDisplayName), CmdLen)
                                          , cmdline
                                          , -1 
                                          ) == CSTR_EQUAL)
                        {
                            if (ReadZoneData(&zone, subkey, name))
                            {
                                result = TRUE;
                            }
                        }
                    }

                    RegCloseKey(subkey);
                }

                if (result)
                {
                    break;
                }
            }
        }

        RegCloseKey(key);

        if (result)
        {
            SetTheTimezone(1, 1, &zone);
        }
    }

    return (result);
}


////////////////////////////////////////////////////////////////////////////
//
//  OpenDateTimePropertySheet
//
//  Opens a DateTime property sheet.
//  Set the page for the property sheet.
//
////////////////////////////////////////////////////////////////////////////

BOOL OpenDateTimePropertySheet(
    HWND hwnd,
    LPCTSTR cmdline)
{
    //  Make this an array for multiple pages.
    PROPSHEETPAGE apsp[3];
    PROPSHEETHEADER psh;
    HDC hDC;
    HFONT   hFont;
    int wMaxDigitWidth;
    BOOL fReturn;
    HRESULT hrOle;

    hDC = GetDC(hwnd);

    wMaxDigitWidth = GetMaxSubstitutedCharWidth(hDC);
    ReleaseDC(hwnd, hDC);

    psh.nStartPage = (UINT)-1;

    if (cmdline && *cmdline)
    {
        if (*cmdline == TEXT('/'))
        {
            BOOL fAutoSet = FALSE;

            //
            //  Legend:
            //    zZ: first boot batch mode setup "/z pacific" etc
            //    fF: regular first boot
            //    mM: time zone change forced local time change message
            //
            switch (*++cmdline)
            {
                case ( TEXT('z') ) :
                case ( TEXT('Z') ) :
                {
                    fAutoSet = TRUE;

                    //
                    //  Fall thru...
                    //
                }
                case ( TEXT('f') ) :
                case ( TEXT('F') ) :
                {
                    g_bFirstBoot = TRUE;

                    if (fAutoSet && SelectZoneByName(cmdline + 1))
                    {
                        return (TRUE);
                    }

                    //
                    //  Start on time zone page.
                    //
                    psh.nStartPage = 1;
                    break;
                }
                case ( TEXT('m') ) :
                case ( TEXT('M') ) :
                {
                    MSGBOXPARAMS params =
                                  {
                                    sizeof(params),
                                    hwnd,
                                    g_hInst,
                                    MAKEINTRESOURCE(IDS_WARNAUTOTIMECHANGE),
                                    MAKEINTRESOURCE(IDS_WATC_CAPTION),
                                    MB_OK | MB_USERICON,
                                    MAKEINTRESOURCE(IDI_TIMEDATE),
                                    0,
                                    NULL,
                                    0
                                  };

                    MessageBoxIndirect(&params);

                    //
                    //  Show time/date page for user to verify.
                    //
                    psh.nStartPage = 0;

                    break;
                }
                default :
                {
                    //
                    //  Fall out, maybe it's a number...
                    //
                    break;
                }
            }
        }
    }

    if (psh.nStartPage == (UINT)-1)
    {
        if (cmdline && (*cmdline >= TEXT('0')) && (*cmdline <= TEXT('9')))
        {
            psh.nStartPage = GetClInt(cmdline);
        }
        else
        {
            psh.nStartPage = 0;
        }
    }

    //
    //  Register our classes.
    //
    ClockInit(g_hInst);
    CalendarInit(g_hInst);
    RegisterMapControlStuff(g_hInst);

    psh.dwSize = sizeof(psh);
    if (g_bFirstBoot)
    {
        //
        //  Disable Apply button for first boot.
        //
        psh.dwFlags = PSH_PROPTITLE | PSH_PROPSHEETPAGE | PSH_NOAPPLYNOW;
    }
    else
    {
        psh.dwFlags = PSH_PROPTITLE | PSH_PROPSHEETPAGE;
    }
    psh.hwndParent = hwnd;
    psh.hInstance = g_hInst;
    psh.pszIcon = NULL;

    //
    //  psh.nStartPage is set above.
    //
    if(g_bShowOnlyTimeZone)
    {
        psh.pszCaption = MAKEINTRESOURCE(IDS_TIMEDATE);
        psh.nPages = 1;
        psh.ppsp = apsp;

        apsp[0].dwSize = sizeof(PROPSHEETPAGE);
        apsp[0].dwFlags = PSP_DEFAULT;
        apsp[0].hInstance = g_hInst;
        apsp[0].pszTemplate = MAKEINTRESOURCE(DLG_TIMEZONE);
        apsp[0].pfnDlgProc = TimeZoneDlgProc;
        apsp[0].lParam = 0;
    }
    else
    {
        psh.pszCaption = MAKEINTRESOURCE(IDS_TIMEDATE);
        psh.nPages = 2;
        psh.ppsp = apsp;

        apsp[0].dwSize = sizeof(PROPSHEETPAGE);
        apsp[0].dwFlags = PSP_DEFAULT;
        apsp[0].hInstance = g_hInst;
        apsp[0].pszTemplate = wMaxDigitWidth > 8 ? MAKEINTRESOURCE(DLG_DATETIMEWIDE) : MAKEINTRESOURCE(DLG_DATETIME);
        apsp[0].pfnDlgProc = DateTimeDlgProc;
        apsp[0].lParam = 0;

        apsp[1].dwSize = sizeof(PROPSHEETPAGE);
        apsp[1].dwFlags = PSP_DEFAULT;
        apsp[1].hInstance = g_hInst;
        apsp[1].pszTemplate = MAKEINTRESOURCE(DLG_TIMEZONE);
        apsp[1].pfnDlgProc = TimeZoneDlgProc;
        apsp[1].lParam = 0;
    }

    if (psh.nStartPage >= psh.nPages)
    {
        psh.nStartPage = 0;
    }

    // We use the HyperLink control and that requires OLE (for IAccessible)
    hrOle = CoInitialize(0);

    fReturn = (BOOL)PropertySheet(&psh);
    if (SUCCEEDED(hrOle))
    {
        CoUninitialize();
    }

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\utc\main.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    worldmap.c

Abstract:

    This module implements the world map for the Date/Time applet.

Revision History:

--*/



//  Include Files.
#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>

#include "timedate.h"
#include "rc.h"
#include <cpl.h>




//
//  Global Variables.
//

HINSTANCE g_hInst = NULL;
CRITICAL_SECTION g_csDll;    /* The shared critical section */

//
//for TS time zone redirection
//
BOOL g_bShowOnlyTimeZone = FALSE;

//
//from kernel32p.lib
//
extern BOOL IsTimeZoneRedirectionEnabled();

//
//  Function Prototypes.
//

extern BOOL OpenDateTimePropertySheet(HWND hwnd, LPCTSTR cmdline);

BOOL
EnableTimePrivilege(
    PTOKEN_PRIVILEGES *pPreviousState,
    ULONG *pPreviousStateLength);

BOOL
ResetTimePrivilege(
    PTOKEN_PRIVILEGES PreviousState,
    ULONG PreviousStateLength);

int DoMessageBox(
    HWND hWnd,
    DWORD wText,
    DWORD wCaption,
    DWORD wType);





////////////////////////////////////////////////////////////////////////////
//
//  LibMain
//
////////////////////////////////////////////////////////////////////////////

BOOL WINAPI LibMain(
    HANDLE hDll,
    DWORD dwReason,
    LPVOID lpReserved)
{
    switch (dwReason)
    {
        case ( DLL_PROCESS_ATTACH ) :
        {
            g_hInst = hDll;
            DisableThreadLibraryCalls(hDll);
            InitializeCriticalSection(&g_csDll);
            break;
        }
        case ( DLL_PROCESS_DETACH ) :
        {
            DeleteCriticalSection(&g_csDll);
            break;
        }
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  CplApplet
//
//  The main applet information manager.
//
////////////////////////////////////////////////////////////////////////////

LONG WINAPI CPlApplet(
    HWND hwnd,
    UINT uMsg,
    LPARAM lParam1,
    LPARAM lParam2)
{
    static BOOL fReEntered = FALSE;

    switch (uMsg)
    {
        case ( CPL_INIT ) :
        {
            return (TRUE);
        }
        case ( CPL_GETCOUNT ) :
        {
            //
            //  How many applets are in this DLL?
            //
            return (1);
        }
        case ( CPL_INQUIRE ) :
        {
            //
            //  Fill the CPLINFO with the pertinent information.
            //
            #define lpOldCPlInfo ((LPCPLINFO)lParam2)

            switch (lParam1)
            {
                case ( 0 ) :
                {
                    lpOldCPlInfo->idIcon = IDI_TIMEDATE;
                    lpOldCPlInfo->idName = IDS_TIMEDATE;
                    lpOldCPlInfo->idInfo = IDS_TIMEDATEINFO;
                    break;
                }
            }

            lpOldCPlInfo->lData = 0L;
            return (TRUE);
        }
        case ( CPL_NEWINQUIRE ) :
        {
            #define lpCPlInfo ((LPNEWCPLINFO)lParam2)

            switch (lParam1)
            {
                case ( 0 ) :
                {
                    lpCPlInfo->hIcon = LoadIcon( g_hInst,
                                                 MAKEINTRESOURCE(IDI_TIMEDATE) );
                    LoadString( g_hInst,
                                IDS_TIMEDATE,
                                lpCPlInfo->szName,
                                ARRAYSIZE(lpCPlInfo->szName) );
                    LoadString( g_hInst,
                                IDS_TIMEDATEINFO,
                                lpCPlInfo->szInfo,
                                ARRAYSIZE(lpCPlInfo->szInfo) );
                    lpCPlInfo->dwHelpContext = 0;
                    break;
                }
            }

            lpCPlInfo->dwSize = sizeof(NEWCPLINFO);
            lpCPlInfo->lData = 0L;
            lpCPlInfo->szHelpFile[0] = 0;
            return (TRUE);
        }
        case ( CPL_DBLCLK ) :
        {
            lParam2 = (LPARAM)0;

            // fall thru...
        }
        case ( CPL_STARTWPARMS ) :
        {
            //
            //  Do the applet thing.
            //
            switch (lParam1)
            {
                case ( 0 ) :
                {
                    PTOKEN_PRIVILEGES PreviousState;
                    ULONG PreviousStateLength;

                    if (EnableTimePrivilege(&PreviousState, &PreviousStateLength))
                    {
                        OpenDateTimePropertySheet(hwnd, (LPCTSTR)lParam2);
                        ResetTimePrivilege(PreviousState, PreviousStateLength);
                    }
                    else
                    {
                        //
                        //If TZ redirection is enabled, regular users can change time zone
                        //it will only be changed for current TS session.
                        //
                        if(IsTimeZoneRedirectionEnabled())
                        {
                            g_bShowOnlyTimeZone = TRUE;
                            OpenDateTimePropertySheet(hwnd, (LPCTSTR)lParam2);
                            g_bShowOnlyTimeZone = FALSE;
                        }
                        else
                        {
                            DoMessageBox( hwnd,
                                          IDS_NOTIMEERROR,
                                          IDS_CAPTION,
                                          MB_OK | MB_ICONINFORMATION );
                        }
                    }
                    break;
                }
            }
            break;
        }
        case ( CPL_EXIT ) :
        {
            fReEntered = FALSE;

            //
            //  Free up any allocations of resources made.
            //

            break;
        }
        default :
        {
            return (0L);
        }
    }

    return (1L);
}


////////////////////////////////////////////////////////////////////////////
//
//  EnableTimePrivilege
//
////////////////////////////////////////////////////////////////////////////

BOOL EnableTimePrivilege(
    PTOKEN_PRIVILEGES *pPreviousState,
    ULONG *pPreviousStateLength)
{
    NTSTATUS NtStatus;
    HANDLE Token;
    LUID SystemTimePrivilege;
    PTOKEN_PRIVILEGES NewState;

    //
    //  Open our own token.
    //
    NtStatus = NtOpenProcessToken( NtCurrentProcess(),
                                   TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                   &Token );
    if (!NT_SUCCESS(NtStatus))
    {
        return (FALSE);
    }

    //
    //  Initialize the adjustment structure.
    //
    SystemTimePrivilege = RtlConvertLongToLuid(SE_SYSTEMTIME_PRIVILEGE);

    NewState = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, 100);
    if (NewState == NULL)
    {
        return (FALSE);
    }

    NewState->PrivilegeCount = 1;
    NewState->Privileges[0].Luid = SystemTimePrivilege;
    NewState->Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;

    *pPreviousState = (PTOKEN_PRIVILEGES)LocalAlloc(LPTR, 100);
    if (*pPreviousState == NULL)
    {
        LocalFree(NewState);
        return (FALSE);
    }

    //  Set the state of the privilege to ENABLED.
    NtStatus = NtAdjustPrivilegesToken( Token,                  // TokenHandle
                                        FALSE,                  // DisableAllPrivileges
                                        NewState,               // NewState
                                        100,                    // BufferLength
                                        *pPreviousState,        // PreviousState (OPTIONAL)
                                        pPreviousStateLength ); // ReturnLength

    //
    //  Clean up some stuff before returning.
    //
    LocalFree(NewState);

    if (NtStatus == STATUS_SUCCESS)
    {
        NtClose(Token);
        return (TRUE);
    }
    else
    {
        LocalFree(*pPreviousState);
        NtClose(Token);
        return (FALSE);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  ResetTimePrivilege
//
//  Restore previous privilege state for setting system time.
//
////////////////////////////////////////////////////////////////////////////

BOOL ResetTimePrivilege(
    PTOKEN_PRIVILEGES PreviousState,
    ULONG PreviousStateLength)
{
    NTSTATUS NtStatus;
    HANDLE Token;
    LUID SystemTimePrivilege;
    ULONG ReturnLength;

    if (PreviousState == NULL)
    {
        return (FALSE);
    }

    //  Open our own token.
    NtStatus = NtOpenProcessToken( NtCurrentProcess(),
                                   TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,
                                   &Token);
    if (!NT_SUCCESS(NtStatus))
    {
        return (FALSE);
    }

    //  Initialize the adjustment structure.
    SystemTimePrivilege = RtlConvertLongToLuid(SE_SYSTEMTIME_PRIVILEGE);

    //  Restore previous state of the privilege.
    NtStatus = NtAdjustPrivilegesToken( Token,               // TokenHandle
                                        FALSE,               // DisableAllPrivileges
                                        PreviousState,       // NewState
                                        PreviousStateLength, // BufferLength
                                        NULL,                // PreviousState (OPTIONAL)
                                        &ReturnLength );     // ReturnLength

    //  Clean up some stuff before returning.
    LocalFree(PreviousState);
    NtClose(Token);

    return (NT_SUCCESS(NtStatus));
}


////////////////////////////////////////////////////////////////////////////
//
//  DoMessageBox
//
////////////////////////////////////////////////////////////////////////////

int DoMessageBox(
    HWND hWnd,
    DWORD wText,
    DWORD wCaption,
    DWORD wType)
{
    TCHAR szText[2 * MAX_PATH];
    TCHAR szCaption[MAX_PATH];

    if (!LoadString(g_hInst, wText, szText, CharSizeOf(szText)))
    {
        return (0);
    }

    if (!LoadString(g_hInst, wCaption, szCaption, CharSizeOf(szCaption)))
    {
        return (0);
    }

    return ( MessageBox(hWnd, szText, szCaption, wType) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\utc\inettime.h ===
/*****************************************************************************\
    FILE: inettime.h

    DESCRIPTION:
        This file contains the code used to display UI allowing the user to
    control the feature that updates the computer's clock from an internet
    NTP time server.

    BryanSt 3/22/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#ifndef _INETTIME_H
#define _INETTIME_H


#define WMUSER_ADDINTERNETTAB (WM_USER + 10)

#define SZ_COMPUTER_LOCAL                   NULL
#define SZ_NTPCLIENT                        L"NtpClient"


EXTERN_C HRESULT AddInternetPageAsync(HWND hDlg, HWND hwndDate);
EXTERN_C HRESULT AddInternetTab(HWND hDlg);


#endif // _INETTIME_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\utc\inettime.cpp ===
/*****************************************************************************\
    FILE: inettime.cpp

    DESCRIPTION:
        This file contains the code used to display UI allowing the user to
    control the feature that updates the computer's clock from an internet
    NTP time server.

    BryanSt 3/22/2000
    Copyright (C) Microsoft Corp 2000-2000. All rights reserved.
\*****************************************************************************/

#include "timedate.h"
#include "inettime.h"
#include "rc.h"

#include <wininet.h>
#include <DSGetDC.h>            // For DsGetDcName
#include <help.h>               // For IDH_DATETIME_*
#include <Lm.h>                 // For NetGetJoinInformation() and NETSETUP_JOIN_STATUS
#include <Lmjoin.h>             // For NetGetJoinInformation() and NETSETUP_JOIN_STATUS
#include <shlobj.h>            
#include <shlobjp.h>
#include <w32timep.h>            // For Time APIs

#include <shellp.h>
#include <ccstock.h>
#include <shpriv.h>

#define DECL_CRTFREE
#include <crtfree.h>

#define DISALLOW_Assert             // Force to use ASSERT instead of Assert
#define DISALLOW_DebugMsg           // Force to use TraceMsg instead of DebugMsg
#include <debug.h>



// Reg Keys and Values
#define SZ_REGKEY_DATETIME                      TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\DateTime")
#define SZ_REGKEY_DATETIME_SERVERS              TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\DateTime\\Servers")
#define SZ_REGKEY_W32TIME_SERVICE               TEXT("System\\CurrentControlSet\\Services\\W32Time")
#define SZ_REGKEY_W32TIME_SERVICE_NTPCLIENT     SZ_REGKEY_W32TIME_SERVICE TEXT("\\TimeProviders\\NtpClient")
#define SZ_REGKEY_W32TIME_SERVICE_PARAMETERS    SZ_REGKEY_W32TIME_SERVICE TEXT("\\Parameters")

#define SZ_REGVALUE_INTERNET_FEATURE_AVAILABLE  TEXT("Support Internet Time")
#define SZ_REGVALUE_TEST_SIMULATENODC           TEXT("TestSimulateNoDC")        // Used to simulate home scenarios while we have a domain controller
#define SZ_REGVALUE_W32TIME_SYNCFROMFLAGS       TEXT("Type")
#define SZ_REGVALUE_W32TIME_STARTSERVICE        TEXT("Start")
#define SZ_REGVALUE_NTPSERVERLIST               TEXT("NtpServer")          // Was "ManualPeerList" in Whistler for a little while.

#define SZ_DEFAULT_NTP_SERVER                   TEXT("time.windows.gov")
#define SZ_INDEXTO_CUSTOMHOST                   TEXT("0")
#define SZ_SERVICE_W32TIME                      TEXT("w32time")
#define SZ_DIFFERENT_SYNCFREQUENCY              TEXT(",0x1")

#define SZ_SYNC_BOTH            TEXT("AllSync")
#define SZ_SYNC_DS              TEXT("NT5DS")
#define SZ_SYNC_NTP             TEXT("NTP")
#define SZ_SYNC_NONE            TEXT("NoSync")

#define SYNC_ONCE_PER_WEEK          0x93A80             // This is once a week.  (Sync every this many seconds)

// Flags for "System\CurrentControlSet\Services\W32Time\TimeProviders\NtpClient","SyncFromFlags"
#define NCSF_ManualPeerList     0x01            // This means use internet SNTP servers.
#define NCSF_DomainHierarchy    0x02            // This means get the time 

// this feature is turned off temporarily until we can get the perf hit reduced.
// The problem is that the call to DsGetDcName() can take up to 15 seconds if
// a domain controller can not be found.
#define FEATURE_INTERNET_TIME                   TRUE

#define MAX_URL_STRING      INTERNET_MAX_URL_LENGTH

#define WMUSER_UPDATED_STATUS_TEXT (WM_USER + 11)


// If we aren't using the new w32timep.h, then define it our selves.
// TODO: Nuke this after \nt\ds\ RIs into main.
#ifndef TimeSyncFlag_SoftResync

#define TimeSyncFlag_ReturnResult       0x02
#define TimeSyncFlag_Rediscover         0x04

#define ResyncResult_Success            0x00
#define ResyncResult_ChangeTooBig       0x04

typedef struct _W32TIME_NTP_PEER_INFO { 
    unsigned __int32    ulSize; 
    unsigned __int32    ulResolveAttempts;
    unsigned __int64    u64TimeRemaining;
    unsigned __int64    u64LastSuccessfulSync; 
    unsigned __int32    ulLastSyncError; 
    unsigned __int32    ulLastSyncErrorMsgId; 
    unsigned __int32    ulValidDataCounter;
    unsigned __int32    ulAuthTypeMsgId; 
#ifdef MIDL_PASS
    [string, unique]
    wchar_t            *wszUniqueName; 
#else // MIDL_PASS
    LPWSTR              wszUniqueName;
#endif // MIDL_PASS
    unsigned   char     ulMode;
    unsigned   char     ulStratum; 
    unsigned   char     ulReachability;
    unsigned   char     ulPeerPollInterval;
    unsigned   char     ulHostPollInterval;
}  W32TIME_NTP_PEER_INFO, *PW32TIME_NTP_PEER_INFO; 

typedef struct _W32TIME_NTP_PROVIDER_DATA { 
    unsigned __int32        ulSize; 
    unsigned __int32        ulError; 
    unsigned __int32        ulErrorMsgId; 
    unsigned __int32        cPeerInfo; 
#ifdef MIDL_PASS
    [size_is(cPeerInfo)]
#endif // MIDL_PASS
    W32TIME_NTP_PEER_INFO  *pPeerInfo; 
} W32TIME_NTP_PROVIDER_DATA, *PW32TIME_NTP_PROVIDER_DATA;

#endif // TimeSyncFlag_SoftResync

//============================================================================================================
// *** Globals ***
//============================================================================================================
const static DWORD aInternetTimeHelpIds[] = {
    DATETIME_AUTOSETFROMINTERNET,           IDH_DATETIME_AUTOSETFROMINTERNET,
    DATETIME_INTERNET_SERVER_LABLE,         IDH_DATETIME_SERVER_EDIT,
    DATETIME_INTERNET_SERVER_EDIT,          IDH_DATETIME_SERVER_EDIT,
    DATETIME_INFOTEXTTOP,                   IDH_DATETIME_INFOTEXT,
    DATETIME_INFOTEXTPROXY,                 IDH_DATETIME_INFOTEXT,

    DATETIME_INTERNET_ERRORTEXT,            IDH_DATETIME_INFOTEXT,
    DATETIME_INTERNET_UPDATENOW,            IDH_DATETIME_UPDATEFROMINTERNET,

    0, 0
};

#define SZ_HELPFILE_INTERNETTIME           TEXT("windows.hlp")

#define HINST_THISDLL           g_hInst

BOOL g_fCustomServer;
BOOL g_fWriteAccess = FALSE;                    // Does the user have the ACLs set correctly to change the HKLM setting to turn the service on/off or change the server hostname?

HRESULT StrReplaceToken(IN LPCTSTR pszToken, IN LPCTSTR pszReplaceValue, IN LPTSTR pszString, IN DWORD cchSize)
{
    HRESULT hr = S_OK;
    LPTSTR pszTempLastHalf = NULL;
    LPTSTR pszNextToken = pszString;

    while (0 != (pszNextToken = StrStrI(pszNextToken, pszToken)))
    {
        // We found one.
        LPTSTR pszPastToken = pszNextToken + lstrlen(pszToken);

        Str_SetPtr(&pszTempLastHalf, pszPastToken);      // Keep a copy because we will overwrite it.

        pszNextToken[0] = 0;    // Remove the rest of the string.
        StringCchCat(pszString, cchSize, pszReplaceValue );
        StringCchCat(pszString, cchSize, pszTempLastHalf );

        pszNextToken += lstrlen(pszReplaceValue);
    }

    Str_SetPtr(&pszTempLastHalf, NULL);

    return hr;
}

HRESULT GetW32TimeServer(BOOL fRemoveJunk, LPWSTR pszServer, DWORD cchSize)
{
    DWORD dwType = REG_SZ;
    DWORD cbSize = (sizeof(pszServer[0]) * cchSize);
    HRESULT hr = W32TimeQueryConfig(W32TIME_CONFIG_MANUAL_PEER_LIST, &dwType, (BYTE *) pszServer, &cbSize);

    if (ResultFromWin32(ERROR_PROC_NOT_FOUND) == hr)
    {
        DWORD dwError = SHGetValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_W32TIME_SERVICE_PARAMETERS, SZ_REGVALUE_NTPSERVERLIST, NULL, (BYTE *)pszServer, &cbSize);

        hr = ResultFromWin32(dwError);
    }

    if (SUCCEEDED(hr) && fRemoveJunk)
    {
        LPWSTR pszJunk = StrStr(pszServer, L",0x");

        if (pszJunk)
        {
            pszJunk[0] = 0;
        }

        pszJunk = StrStr(pszServer, L" ");
        if (pszJunk)
        {
            pszJunk[0] = 0;
        }
    }

    return hr;
}


HRESULT RemoveDuplicateServers(LPWSTR pszServer, DWORD cchSize)
{
    TCHAR szResults[MAX_URL_STRING];

    StringCchCopy( szResults, ARRAYSIZE(szResults), pszServer );

    LPTSTR pszBeginning = szResults;
    LPTSTR pszEnd;
    while (NULL != (pszEnd = StrChr(pszBeginning, TEXT(' '))))
    {
        TCHAR szSearchStr[MAX_PATH];

        StringCchCopy( szSearchStr, (DWORD)min(ARRAYSIZE(szSearchStr), (pszEnd - pszBeginning + 1)), pszBeginning );

        pszEnd++;    // Skip past the space

        StringCchCat( szSearchStr, ARRAYSIZE(szSearchStr), L" " );
        StrReplaceToken(szSearchStr, TEXT(""), pszEnd, (ARRAYSIZE(szResults) - (DWORD)(pszEnd - &szResults[0])));
        szSearchStr[ lstrlen(szSearchStr) - 1 ] = 0;
        StrReplaceToken(szSearchStr, TEXT(""), pszEnd, (ARRAYSIZE(szResults) - (DWORD)(pszEnd - &szResults[0])));

        pszBeginning = pszEnd;
    }

    PathRemoveBlanks(szResults);

    StringCchCopy( pszServer, cchSize, szResults );
    return S_OK;
}

BOOL ComparePeers(LPTSTR szPeer1, LPTSTR szPeer2) { 
    BOOL   fResult; 
    LPTSTR szFlags1;
    LPTSTR szFlags2;
    TCHAR  szSave1; 
    TCHAR  szSave2; 

    szFlags1 = StrChr(szPeer1, TEXT(',')); 
    if (NULL == szFlags1) 
    {
    szFlags1 = StrChr(szPeer1, TEXT(' ')); 
    }
    szFlags2 = StrChr(szPeer2, TEXT(','));
    if (NULL == szFlags2)
    {
    szFlags2 = StrChr(szPeer2, TEXT(' '));
    }

    if (NULL != szFlags1) { 
    szSave1 = szFlags1[0]; 
    szFlags1[0] = TEXT('\0'); 
    }
    if (NULL != szFlags2) { 
    szSave2 = szFlags2[0]; 
    szFlags2[0] = TEXT('\0'); 
    }

    fResult = 0 == StrCmpI(szPeer1, szPeer2); 

    if (NULL != szFlags1) { 
    szFlags1[0] = szSave1; 
    }
    if (NULL != szFlags2) { 
    szFlags2[0] = szSave2; 
    }

    return fResult; 
}

BOOL ContainsServer(LPWSTR pwszServerList, LPWSTR pwszServer) 
{
    DWORD dwNextServerOffset = 0; 
    LPWSTR pwszNext = pwszServerList; 

    while (NULL != pwszNext) 
    { 
    pwszNext += dwNextServerOffset; 
    if (ComparePeers(pwszNext, pwszServer)) 
    { 
        return TRUE; 
    }

    pwszNext = StrChr(pwszNext, TEXT(' ')); 
    dwNextServerOffset = 1; 
    }

    return FALSE; 
}


HRESULT AddTerminators(LPWSTR pszServer, DWORD cchSize)
{
    TCHAR szServer[MAX_URL_STRING];
    TCHAR szTemp[MAX_URL_STRING];

    szTemp[0] = 0;
    StringCchCopy(szServer, ARRAYSIZE(szServer), pszServer );

    LPTSTR pszBeginning = szServer;
    LPTSTR pszEnd;
    while (NULL != (pszEnd = StrChr(pszBeginning, TEXT(' '))))
    {
        TCHAR szTemp2[MAX_PATH];

        pszEnd[0] = 0;

        if (!StrStrI(pszBeginning, L",0x"))
        {
            StringCchPrintf( szTemp2, ARRAYSIZE(szTemp2), L"%s,0x1 ", pszBeginning );
            StringCchCat( szTemp, ARRAYSIZE(szTemp), szTemp2 );
        }
        else
        {
            StringCchCat( szTemp, ARRAYSIZE(szTemp), pszBeginning );
            StringCchCat( szTemp, ARRAYSIZE(szTemp), L" " );
        }

        pszBeginning = &pszEnd[1];
    }

    StringCchCat( szTemp, ARRAYSIZE(szTemp), pszBeginning );
    if ( 0 != pszBeginning[0] && 0 != szTemp[0] && NULL == StrStrI(pszBeginning, L",0x") )
    {
        // We need to indicate which kind of sync method
        StringCchCat( szTemp, ARRAYSIZE(szTemp), L",0x1" );
    }

    StringCchCopy( pszServer, cchSize, szTemp );
    return S_OK;
}


HRESULT SetW32TimeServer(LPCWSTR pszServer)
{
    TCHAR szServer[MAX_PATH];

    StringCchCopy( szServer, ARRAYSIZE(szServer), pszServer );
    AddTerminators(szServer, ARRAYSIZE(szServer));
    RemoveDuplicateServers(szServer, ARRAYSIZE(szServer));

    DWORD cbSize = ((lstrlen(szServer) + 1) * sizeof(szServer[0]));

    HRESULT hr = W32TimeSetConfig(W32TIME_CONFIG_MANUAL_PEER_LIST, REG_SZ, (BYTE *) szServer, cbSize);
    if (ResultFromWin32(ERROR_PROC_NOT_FOUND) == hr)
    {
        DWORD dwError = SHSetValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_W32TIME_SERVICE_PARAMETERS, SZ_REGVALUE_NTPSERVERLIST, REG_SZ, (BYTE *)szServer, cbSize);

        hr = ResultFromWin32(dwError);
    }

    return hr;
}


HRESULT SetW32TimeSyncFreq(DWORD dwSyncFreq)
{
    return S_OK;
    // return W32TimeSetConfig(W32TIME_CONFIG_SPECIAL_POLL_INTERVAL, REG_DWORD, (BYTE *) dwSyncFreq, sizeof(dwSyncFreq));
}



enum eBackgroundThreadAction
{
    eBKAWait        = 0,            // The bkthread should wait for a command
    eBKAGetInfo,                    // The bkthread should get the info on the last sync
    eBKAUpdate,                     // The bkthread should start synching
    eBKAUpdating,                   // The bkthread is synching now
    eBKAQuit,                       // The bkthread should shut down
};

class CInternetTime
{
public:
    // Forground methods
    BOOL IsInternetTimeAvailable(void);
    HRESULT AddInternetPage(void);

    INT_PTR _AdvancedDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

    CInternetTime(HWND hDlg, HWND hwndDate);
    virtual ~CInternetTime(void);


    // Background methods
    void AsyncCheck(void);

private:

    // Private Member Variables
    HWND m_hDlg;                               // hwnd of parent (property sheet).
    HWND m_hwndDate;                           // Date tab hwnd
    HWND m_hwndInternet;                       // InternetTime tab hwnd
    HCURSOR m_hCurOld;                         // The old cursor while we display the wait cursor
    LPTSTR m_pszStatusString;                  // CROSS-THREAD: This is used to pass between threads.
    LPTSTR m_pszNextSyncTime;                  // CROSS-THREAD: This is used to pass between threads.
    eBackgroundThreadAction m_eAction;         // CROSS-THREAD: This is used to pass between threads.

    // Private Member Functions
    // Forground methods
    HRESULT _InitAdvancedPage(HWND hDlg);
    HRESULT _OnUpdateButton(void);
    HRESULT _OnUpdateStatusString(void);
    HRESULT _OnSetFeature(HWND hDlg, BOOL fOn);
    HRESULT _OnToggleFeature(HWND hDlg);
    HRESULT _GoGetHelp(void);
    HRESULT _ResetServer(void);
    HRESULT _PersistInternetTimeSettings(HWND hDlg);
    HRESULT _StartServiceAndRefresh(BOOL fStartIfOff);

    INT_PTR _OnCommandAdvancedPage(HWND hDlg, WPARAM wParam, LPARAM lParam);
    INT_PTR _OnNotifyAdvancedPage(HWND hDlg, NMHDR * pNMHdr, int idControl);

    // Background methods
    HRESULT _ProcessBkThreadActions(void);
    HRESULT _SyncNow(BOOL fOnlyUpdateInfo);
    HRESULT _CreateW32TimeSuccessErrorString(DWORD dwError, LPTSTR pszString, DWORD cchSize, LPTSTR pszNextSync, DWORD cchNextSyncSize, LPTSTR pszServerToQuery);
    HRESULT _GetDateTimeString(FILETIME * pftTimeDate, BOOL fDate, LPTSTR pszString, DWORD cchSize);
};


CInternetTime * g_pInternetTime = NULL;



// This function is called on the forground thread.
CInternetTime::CInternetTime(HWND hDlg, HWND hwndDate)
{
    m_hDlg = hDlg;
    m_hwndDate = hwndDate;
    m_eAction = eBKAGetInfo;
    m_pszStatusString = NULL;
    m_hwndInternet = NULL;
    m_hCurOld = NULL;

    m_pszStatusString = NULL;
    m_pszNextSyncTime = NULL;
}


CInternetTime::~CInternetTime()
{
ENTERCRITICAL;
    if (m_pszStatusString)
    {
        LocalFree(m_pszStatusString);
        m_pszStatusString = NULL;
    }

    if (m_pszNextSyncTime)
    {
        LocalFree(m_pszNextSyncTime);
        m_pszNextSyncTime = NULL;
    }

    if (m_hCurOld)
    {
        SetCursor(m_hCurOld);
        m_hCurOld = NULL;
    }
LEAVECRITICAL;
}



HRESULT FormatMessageWedge(LPCWSTR pwzTemplate, LPWSTR pwzStrOut, DWORD cchSize, ...)
{
    va_list vaParamList;
    HRESULT hr = S_OK;

    va_start(vaParamList, cchSize);
    if (0 == FormatMessageW(FORMAT_MESSAGE_FROM_STRING, pwzTemplate, 0, 0, pwzStrOut, cchSize, &vaParamList))
    {
        hr = ResultFromLastError();
    }

    va_end(vaParamList);
    return hr;
}



/////////////////////////////////////////////////////////////////////
// Private Internal Helpers
/////////////////////////////////////////////////////////////////////
// This function is called on the forground thread.
HRESULT CInternetTime::_OnSetFeature(HWND hDlg, BOOL fOn)
{
    HWND hwndOnOffCheckbox = GetDlgItem(m_hwndInternet, DATETIME_AUTOSETFROMINTERNET);
    HWND hwndServerLable = GetDlgItem(m_hwndInternet, DATETIME_INTERNET_SERVER_LABLE);
    HWND hwndServerEdit = GetDlgItem(m_hwndInternet, DATETIME_INTERNET_SERVER_EDIT);

    CheckDlgButton(hDlg, DATETIME_AUTOSETFROMINTERNET, (fOn ? BST_CHECKED : BST_UNCHECKED));
    EnableWindow(hwndOnOffCheckbox, g_fWriteAccess);
    EnableWindow(hwndServerLable, (g_fWriteAccess ? fOn : FALSE));
    EnableWindow(hwndServerEdit, (g_fWriteAccess ? fOn : FALSE));
    EnableWindow(GetDlgItem(m_hwndInternet, DATETIME_INTERNET_ERRORTEXT), (g_fWriteAccess ? fOn : FALSE));
    EnableWindow(GetDlgItem(m_hwndInternet, DATETIME_INTERNET_UPDATENOW), (g_fWriteAccess ? fOn : FALSE));
    EnableWindow(GetDlgItem(m_hwndInternet, DATETIME_INFOTEXTTOP), (g_fWriteAccess ? fOn : FALSE));

    if (fOn)
    {
        // If the user just turned on the feature and the editbox is empty,
        // replace the text with the default server name.
        TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];

        if (!GetWindowText(hwndServerEdit, szServer, ARRAYSIZE(szServer)) ||
            !szServer[0])
        {
            SetWindowText(hwndServerEdit, SZ_DEFAULT_NTP_SERVER);
        }
    }

    return S_OK;
}


// This function is called on the forground thread.
HRESULT CInternetTime::_OnToggleFeature(HWND hDlg)
{
    BOOL fIsFeatureOn = ((BST_CHECKED == IsDlgButtonChecked(hDlg, DATETIME_AUTOSETFROMINTERNET)) ? TRUE : FALSE);
    PropSheet_Changed(GetParent(hDlg), hDlg);   // Say we need to enable the apply button

    return _OnSetFeature(hDlg, fIsFeatureOn);
}


// This function is called on the forground thread.
HRESULT AddServerList(HWND hwndCombo, HKEY hkey, int nIndex)
{
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];
    DWORD cbSizeServer = sizeof(szServer);
    TCHAR szIndex[MAX_PATH];
    DWORD dwType;

    StringCchPrintf( szIndex, ARRAYSIZE(szIndex), TEXT("%d"), nIndex );

    DWORD dwError = SHGetValue(hkey, NULL, szIndex, &dwType, (void *)szServer, &cbSizeServer);
    HRESULT hr = ResultFromWin32(dwError);
    if (SUCCEEDED(hr))
    {
        LPTSTR pszFlags = StrStr(szServer, SZ_DIFFERENT_SYNCFREQUENCY);

        if (pszFlags)
        {
            pszFlags[0] = 0;        // Remove the flags.
        }

        dwError = ComboBox_AddString(hwndCombo, szServer);
        if ((dwError == CB_ERR) || (dwError == CB_ERRSPACE))
        {
            hr = E_FAIL;
        }
    }

    return hr;
}


// This function is called on the forground thread.
HRESULT PopulateComboBox(IN HWND hwndCombo, IN BOOL * pfCustomServer)
{
    HRESULT hr;
    HKEY hkey;

    *pfCustomServer = FALSE;

    DWORD dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_REGKEY_DATETIME_SERVERS, 0, KEY_READ, &hkey);
    hr = ResultFromWin32(dwError);
    if (SUCCEEDED(hr))
    {
        // Try to add the custom slot.
        if (SUCCEEDED(AddServerList(hwndCombo, hkey, 0)))
        {
            // We do have an existing custom server, so let the caller know so
            // they know to increase the index by 1.
            *pfCustomServer = TRUE;
        }

        for (int nIndex = 1; SUCCEEDED(hr); nIndex++)
        {
            hr = AddServerList(hwndCombo, hkey, nIndex);
        }
    
        RegCloseKey(hkey);
    }

    return hr;
}


// This function is called on the forground thread.
HRESULT CInternetTime::_OnUpdateButton(void)
{
    HRESULT hr = S_OK;

ENTERCRITICAL;
    // We don't need to do anything if it's already working on another task.
    if (eBKAWait == m_eAction)
    {
        TCHAR szMessage[2 * MAX_PATH];
        TCHAR szTemplate[MAX_PATH];
        TCHAR szServer[MAX_PATH];

        if (!m_hCurOld)
        {
            m_hCurOld = SetCursor(LoadCursor(NULL, IDC_WAIT));
        }

        LoadString(HINST_THISDLL, IDS_IT_WAITFORSYNC, szTemplate, ARRAYSIZE(szTemplate));
        GetWindowText(GetDlgItem(m_hwndInternet, DATETIME_INTERNET_SERVER_EDIT), szServer, ARRAYSIZE(szServer));
        FormatMessageWedge(szTemplate, szMessage, ARRAYSIZE(szMessage), szServer);

        SetWindowText(GetDlgItem(m_hwndInternet, DATETIME_INTERNET_ERRORTEXT), szMessage);

        m_eAction = eBKAUpdate;
    }
LEAVECRITICAL;

    return hr;
}


// This function is called on the forground thread.
BOOL IsManualPeerListOn(void)
{
    BOOL fIsManualPeerListOn = TRUE;
    TCHAR szSyncType[MAX_PATH];
    DWORD cbSize = sizeof(szSyncType);
    DWORD dwType;

    if (ERROR_SUCCESS == SHGetValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_W32TIME_SERVICE_PARAMETERS, SZ_REGVALUE_W32TIME_SYNCFROMFLAGS, &dwType, (LPBYTE)szSyncType, &cbSize))
    {
        if (!StrCmpI(szSyncType, SZ_SYNC_DS) || !StrCmpI(szSyncType, SZ_SYNC_NONE))
        {
            fIsManualPeerListOn = FALSE;
        }
    }

    return fIsManualPeerListOn;
}


// This function is called on the forground thread.
HRESULT CInternetTime::_InitAdvancedPage(HWND hDlg)
{
    DWORD dwType;
    TCHAR szIndex[MAX_PATH];
    HWND hwndServerEdit = GetDlgItem(hDlg, DATETIME_INTERNET_SERVER_EDIT);
    HWND hwndOnOffCheckbox = GetDlgItem(hDlg, DATETIME_AUTOSETFROMINTERNET);
    DWORD cbSize = sizeof(szIndex);
    BOOL fIsFeatureOn = IsManualPeerListOn();

    m_hwndInternet = hDlg;
    HRESULT hr = PopulateComboBox(hwndServerEdit, &g_fCustomServer);

    // Does the user have access to change the setting in the registry?
    HKEY hKeyTemp;
    g_fWriteAccess = FALSE;
    DWORD dwError = RegOpenKeyEx(HKEY_LOCAL_MACHINE, SZ_REGKEY_W32TIME_SERVICE_PARAMETERS, 0, KEY_WRITE, &hKeyTemp);
    if (ERROR_SUCCESS == dwError)
    {
        // We have access to read & write so we can enable the UI.
        RegCloseKey(hKeyTemp);
        dwError = RegCreateKeyEx(HKEY_LOCAL_MACHINE, SZ_REGKEY_DATETIME, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKeyTemp, NULL);
        if (ERROR_SUCCESS == dwError)
        {
            RegCloseKey(hKeyTemp);
            dwError = RegCreateKeyEx(HKEY_LOCAL_MACHINE, SZ_REGKEY_DATETIME_SERVERS, 0, NULL, REG_OPTION_NON_VOLATILE, KEY_WRITE, NULL, &hKeyTemp, NULL);
            if (ERROR_SUCCESS == dwError)
            {
                g_fWriteAccess = TRUE;
                RegCloseKey(hKeyTemp);
            }
        }
    }

    dwError = SHGetValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_DATETIME_SERVERS, NULL, &dwType, (void *) szIndex, &cbSize);
    hr = ResultFromWin32(dwError);
    if (SUCCEEDED(hr))
    {
        int nIndex = StrToInt(szIndex);

        if (!g_fCustomServer)
        {
            nIndex -= 1;        // We don't have slot zero (the custom server), so reduce the index.
        }

        ComboBox_SetCurSel(hwndServerEdit, nIndex);
    }

    _OnSetFeature(hDlg, fIsFeatureOn);

    if (fIsFeatureOn)
    {
        // The feature is on, so select the text and set focus
        // to the combobox.
        ComboBox_SetEditSel(hwndServerEdit, 0, (LPARAM)-1);     // Select all the Text
        SetFocus(hwndServerEdit); 
    }
    else
    {
        // The feature is off so set focus to the checkbox.
        SetFocus(hwndOnOffCheckbox); 
    }

ENTERCRITICAL;
    if (m_pszStatusString)
    {
        SetWindowText(GetDlgItem(m_hwndInternet, DATETIME_INTERNET_ERRORTEXT), m_pszStatusString);
    }

    if (m_pszNextSyncTime)
    {
        SetWindowText(GetDlgItem(m_hwndInternet, DATETIME_INFOTEXTTOP), m_pszNextSyncTime);
    }
LEAVECRITICAL;

    return S_OK;
}


// This function is called on the background thread.
HRESULT SetSyncFlags(DWORD dwSyncFromFlags)
{
    LPCTSTR pszFlags = SZ_SYNC_BOTH;

    switch (dwSyncFromFlags)
    {
    case NCSF_DomainHierarchy:
        pszFlags = SZ_SYNC_DS;
        break;
    case NCSF_ManualPeerList:
        pszFlags = SZ_SYNC_NTP;
        break;
    case 0x00000000:
        pszFlags = SZ_SYNC_NONE;
        break;
    };

    DWORD cbSize = ((lstrlen(pszFlags) + 1) * sizeof(pszFlags[0]));
    DWORD dwError = SHSetValue(HKEY_LOCAL_MACHINE, SZ_REGKEY_W32TIME_SERVICE_PARAMETERS, SZ_REGVALUE_W32TIME_SYNCFROMFLAGS, REG_SZ, (LPBYTE)pszFlags, cbSize);
    HRESULT hr = ResultFromWin32(dwError);

    return hr;
}


/*****************************************************************************\
    DESCRIPTION:

    The following reg keys determine if the W32Time service is on or off:
    HKLM,"System\CurrentControlSet\Services\W32Time\"
          "Start", 0x00000002 (Manual?) 0x0000003 (Automatic?)
          "Type", 0x00000020 (Nt5Ds?) 0x0000120 (NTP?)
    HKLM,"System\CurrentControlSet\Services\W32Time\Parameters"
          "LocalNTP", 0x00000000 (Off) 0x0000001 (On)
          "Type", "Nt5Ds" (NTP off) "NTP" (NTP?)
    HKLM,"System\CurrentControlSet\Services\W32Time\TimeProviders\NTPClient"
          "SyncFromFlags", 0x00000001 (???) 0x0000002 (???)
  
    The following reg keys determine which NTP server to use:
    HKLM,"System\CurrentControlSet\Services\W32Time\TimeProviders\NTPClient"
          "ManualPeerList", REG_SZ_EXPAND "time.nist.gov"
\*****************************************************************************/
// This function is called on the forground thread.
HRESULT CInternetTime::_PersistInternetTimeSettings(HWND hDlg)
{
    BOOL fIsFeatureOn = ((BST_CHECKED == IsDlgButtonChecked(hDlg, DATETIME_AUTOSETFROMINTERNET)) ? TRUE : FALSE);
    DWORD dwSyncFromFlags = (fIsFeatureOn ? NCSF_ManualPeerList : 0 /*none*/ );
    DWORD dwError;
    DWORD cbSize;

    HRESULT hr = SetSyncFlags(dwSyncFromFlags);

    HWND hwndServerEdit = GetDlgItem(hDlg, DATETIME_INTERNET_SERVER_EDIT);

    // No, so the editbox has a customer server.  We need to store the custom server.
    TCHAR szServer[INTERNET_MAX_HOST_NAME_LENGTH];
    TCHAR szServerReg[INTERNET_MAX_HOST_NAME_LENGTH];

    szServer[0] = 0;
    GetWindowText(hwndServerEdit, szServer, ARRAYSIZE(szServer));         

    // Here, we want to detect the case where someone typed in the same name as
    // in the drop down list.  So if "time.nist.gov" is in the list, we want to
    // select it instead of saving another "time.nist.gov" in the custom slot.
    int nDup = ComboBox_FindString(hwndServerEdit, 0, szServer);
    if (CB_ERR != nDup)
    {
        ComboBox_SetCurSel(hwndServerEdit, nDup);
    }

    // The ",0x1" denotes that we want to sync less frequently and not use the NTP RFC's
    // sync frequency.
    StringCchCopy( szServerReg, ARRAYSIZE(szServerReg), szServer );
    StringCchCat( szServerReg, ARRAYSIZE(szServerReg), SZ_DIFFERENT_SYNCFREQUENCY );

    // Write the default server name into "ManualPeerList", which is where the
    // service reads it from.
    SetW32TimeServer(szServerReg);
    if (!StrCmpI(szServerReg, L"time.windows.com"))
    {
        // We need time.windows.com to scale to a large number of users, so don't let it sync more frequently
        // than once a week.
        SetW32TimeSyncFreq(SYNC_ONCE_PER_WEEK);
    }

    int nIndex = ComboBox_GetCurSel(hwndServerEdit);
    if (CB_ERR == nIndex)                // Is anything selected?
    {
        cbSize = ((lstrlenW(szServer) + 1) * sizeof(szServer[0]));
        dwError = SHSetValueW(HKEY_LOCAL_MACHINE, SZ_REGKEY_DATETIME_SERVERS, SZ_INDEXTO_CUSTOMHOST, REG_SZ, (void *)szServer, cbSize);

        nIndex = 0;
    }
    else
    {
        if (!g_fCustomServer)
        {
            nIndex += 1;        // Push the index down by one because the listbox doesn't have a custom server
        }
    }

    TCHAR szIndex[MAX_PATH];
    StringCchPrintf( szIndex, ARRAYSIZE(szIndex), L"%d", nIndex );

    cbSize = ((lstrlenW(szIndex) + 1) * sizeof(szIndex[0]));
    dwError = SHSetValueW(HKEY_LOCAL_MACHINE, SZ_REGKEY_DATETIME_SERVERS, NULL, REG_SZ, (void *)szIndex, cbSize);

    _StartServiceAndRefresh(fIsFeatureOn);      // Make sure the service is on and make it update it's settings.

    return S_OK;
}


// This function is called on either the forground or background thread.
HRESULT CInternetTime::_StartServiceAndRefresh(BOOL fStartIfOff)
{
    HRESULT hr = S_OK;

    // We need to let the service know that settings may have changed.  If the user
    // wanted this feature on, then we should make sure the service starts.
    SC_HANDLE hServiceMgr = OpenSCManager(NULL, NULL, (SC_MANAGER_CONNECT | SC_MANAGER_ENUMERATE_SERVICE | SC_MANAGER_QUERY_LOCK_STATUS));
    if (hServiceMgr)
    {
        SC_HANDLE hService = OpenService(hServiceMgr, SZ_SERVICE_W32TIME, (/*SERVICE_START |*/ SERVICE_PAUSE_CONTINUE));
        DWORD dwServiceStartMode = 0x00000002;         // This will cause the service to start Automatically on reboot.

        DWORD dwError = SHSetValueW(HKEY_LOCAL_MACHINE, SZ_REGKEY_W32TIME_SERVICE, SZ_REGVALUE_W32TIME_STARTSERVICE, REG_DWORD, &dwServiceStartMode, sizeof(dwServiceStartMode));
        if (hService)
        {
            SERVICE_STATUS serviceStatus = {0};
            BOOL fSucceeded;

            if (fStartIfOff)
            {
                // We should start up the service in case it's not turned on.
                fSucceeded = StartService(hService, 0, NULL);
                hr = (fSucceeded ? S_OK : ResultFromLastError());
                if (ResultFromWin32(ERROR_SERVICE_ALREADY_RUNNING) == hr)
                {
                    hr = S_OK;  // We can ignore this err value because it's benign.
                }
            }

            // Tell the service to re-read the registry entry settings.
            fSucceeded = ControlService(hService, SERVICE_CONTROL_PARAMCHANGE, &serviceStatus);

            CloseServiceHandle(hService);
        }
        else
        {
            hr = ResultFromLastError();
        }

        CloseServiceHandle(hServiceMgr);
    }
    else
    {
        hr = ResultFromLastError();
    }

    return hr;
}


HRESULT CInternetTime::_OnUpdateStatusString(void)
{
    HRESULT hr = S_OK;

ENTERCRITICAL;       // Be safe while using m_pszStatusString
    SetWindowText(GetDlgItem(m_hwndInternet, DATETIME_INTERNET_ERRORTEXT), (m_pszStatusString ? m_pszStatusString : TEXT("")));
    SetWindowText(GetDlgItem(m_hwndInternet, DATETIME_INFOTEXTTOP), (m_pszNextSyncTime ? m_pszNextSyncTime : TEXT("")));

    if (m_hCurOld)
    {
        SetCursor(m_hCurOld);
        m_hCurOld = NULL;
    }
LEAVECRITICAL;

    return S_OK;
}

// This function is called on the forground thread.
HRESULT CInternetTime::_GoGetHelp(void)
{
    HRESULT hr = S_OK;
    TCHAR szCommand[MAX_PATH];

    LoadString(HINST_THISDLL, IDS_TROUBLESHOOT_INTERNETIME, szCommand, ARRAYSIZE(szCommand));
    ShellExecute(m_hwndDate, NULL, szCommand, NULL, NULL, SW_NORMAL);

    return S_OK;
}


// This function is called on the forground thread.
INT_PTR CInternetTime::_OnCommandAdvancedPage(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)
    WORD wMsg = GET_WM_COMMAND_CMD(wParam, lParam);
    WORD idCtrl = GET_WM_COMMAND_ID(wParam, lParam);

    switch (idCtrl)
    {
    case DATETIME_AUTOSETFROMINTERNET:
        switch (wMsg)
        {
            case BN_CLICKED:
                _OnToggleFeature(hDlg);
                break;
        }
        break;

    case DATETIME_INTERNET_SERVER_EDIT:
        switch (wMsg)
        {
            case EN_CHANGE:
            case CBN_EDITCHANGE:
            case CBN_SELCHANGE:
                PropSheet_Changed(GetParent(hDlg), hDlg);
                break;
        }
        break;

    case DATETIME_INTERNET_UPDATENOW:
        switch (wMsg)
        {
            case BN_CLICKED:
                _OnUpdateButton();
                break;
        }
        break;
    }

    return fHandled;
}


// This function is called on the forground thread.
INT_PTR CInternetTime::_OnNotifyAdvancedPage(HWND hDlg, NMHDR * pNMHdr, int idControl)
{
    BOOL fHandled = 1;   // Not handled (WM_COMMAND seems to be different)

    if (pNMHdr)
    {
        switch (pNMHdr->idFrom)
        {
        case 0:
        {
            switch (pNMHdr->code)
            {
            case PSN_APPLY:
                _PersistInternetTimeSettings(hDlg);
                break;
            }
            break;
        }
        default:
            switch (pNMHdr->code)
            {
            case NM_RETURN:
            case NM_CLICK:
            {
                PNMLINK pNMLink = (PNMLINK) pNMHdr;

                if (!StrCmpW(pNMLink->item.szID, L"HelpMe"))
                {
                    _GoGetHelp();
                }
                break;
            }
            }
            break;
        }
    }

    return fHandled;
}


// This function is called on the forground thread.
EXTERN_C INT_PTR CALLBACK AdvancedDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    if (g_pInternetTime)
    {
        return g_pInternetTime->_AdvancedDlgProc(hDlg, uMsg, wParam, lParam);
    }

    return (TRUE);
}


// This function is called on the forground thread.
INT_PTR CInternetTime::_AdvancedDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
            _InitAdvancedPage(hDlg);
            break;

        case WM_DESTROY:
            break;

        case WM_NOTIFY:
            _OnNotifyAdvancedPage(hDlg, (NMHDR *)lParam, (int) wParam);
            break;

        case WM_COMMAND:
            _OnCommandAdvancedPage(hDlg, wParam, lParam);
            break;

        case WMUSER_UPDATED_STATUS_TEXT:
            _OnUpdateStatusString();
            break;

        case WM_HELP:
            WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, SZ_HELPFILE_INTERNETTIME, HELP_WM_HELP, (DWORD_PTR)  aInternetTimeHelpIds);
            break;

        case WM_CONTEXTMENU:      // right mouse click
            WinHelp((HWND) wParam, SZ_HELPFILE_INTERNETTIME, HELP_CONTEXTMENU, (DWORD_PTR)  aInternetTimeHelpIds);
            break;

        default:
            return FALSE;
    }

    return (TRUE);
}



// This function is called on the forground thread.
HRESULT CInternetTime::AddInternetPage(void)
{
    HRESULT hr = S_OK;
    PROPSHEETPAGE pspAdvanced;
    INITCOMMONCONTROLSEX initComctl32;

    initComctl32.dwSize = sizeof(initComctl32); 
    initComctl32.dwICC = (ICC_STANDARD_CLASSES | ICC_LINK_CLASS); 

    InitCommonControlsEx(&initComctl32);     // Register the comctl32 LinkWindow

    pspAdvanced.dwSize = sizeof(PROPSHEETPAGE);
    pspAdvanced.dwFlags = PSP_DEFAULT;
    pspAdvanced.hInstance = HINST_THISDLL;
    pspAdvanced.pszTemplate = MAKEINTRESOURCE(DLG_ADVANCED);
    pspAdvanced.pfnDlgProc = AdvancedDlgProc;
    pspAdvanced.lParam = (LPARAM) this;

    if (IsWindow(m_hDlg))
    {
        HPROPSHEETPAGE hPropSheet = CreatePropertySheetPage(&pspAdvanced);
        if (hPropSheet)
        {
            PropSheet_AddPage(m_hDlg, hPropSheet);
        }
    }

    return hr;
}





/////////////////////////////////////////////////////////////////////
// Background Thread Functions
/////////////////////////////////////////////////////////////////////


///////////
// These functions will cause the background thread to sync
///////////

#define SECONDS_FROM_100NS            10000000


//     ulResolveAttempts      --  the number of times the NTP provider has attempted to 
//                                resolve this peer unsuccessfully.  Setting this 
//                                value to 0 indicates that the peer has been successfully
//                                resolved. 
//     u64TimeRemaining       --  the number of 100ns intervals until the provider will
//                                poll this peer again
//     u64LastSuccessfulSync  --  the number of 100ns intervals since (0h 1-Jan 1601)
//     ulLastSyncError        --  S_OK if the last sync with this peer was successful, otherwise, 
//                                the error that occurred attempting to sync
//     ulLastSyncErrorMsgId   --  the resource identifier of a string representing the last
//                                error that occurred syncing from this peer.  0 if there is no
//                                string associated with this error. 
// This function is called on the background thread.
HRESULT W32TimeGetErrorInfoWrap(UINT * pulResolveAttempts, ULONG * pulValidDataCounter, UINT64 * pu64TimeRemaining, UINT64 * pu64LastSuccessfulSync, HRESULT * phrLastSyncError,
                                UINT * pulLastSyncErrorMsgId, LPTSTR pszServer, DWORD cchSize, LPTSTR pszServerToQuery)
{
    HRESULT hr = S_OK;

    *pulResolveAttempts = 0;
    *pulValidDataCounter = 0;
    *pu64TimeRemaining = 0;
    *pu64LastSuccessfulSync = 0;
    *phrLastSyncError = E_FAIL;
    *pulLastSyncErrorMsgId = 0;
    pszServer[0] = 0;

    // NOTE: Server should return ERROR_TIME_SKEW if time is too far out of date to sync.
    W32TIME_NTP_PROVIDER_DATA * pProviderInfo = NULL; 
    
    DWORD dwError = W32TimeQueryNTPProviderStatus(SZ_COMPUTER_LOCAL, 0, SZ_NTPCLIENT, &pProviderInfo);
    if ((ERROR_SUCCESS == dwError) && pProviderInfo)
    {
        *phrLastSyncError = pProviderInfo->ulError;
        *pulLastSyncErrorMsgId = pProviderInfo->ulErrorMsgId;

    DWORD dwMostRecentlySyncdPeerIndex = 0xFFFFFFFF; 
    UINT64 u64LastSuccessfulSync = 0; 
        for (DWORD dwIndex = 0; dwIndex < pProviderInfo->cPeerInfo; dwIndex++)
    { 
        // Only want to query those peers which we explictly sync'd from.  
        // If we haven't explicitly requested a sync, we'll just take the most recently sync'd peer. 
        if (NULL == pszServerToQuery || ComparePeers(pszServerToQuery, pProviderInfo->pPeerInfo[dwIndex].wszUniqueName))
        {
        if (u64LastSuccessfulSync <= pProviderInfo->pPeerInfo[dwIndex].u64LastSuccessfulSync)
        {
            dwMostRecentlySyncdPeerIndex = dwIndex; 
            u64LastSuccessfulSync = pProviderInfo->pPeerInfo[dwIndex].u64LastSuccessfulSync; 
        }
        }
    }

    if (dwMostRecentlySyncdPeerIndex < pProviderInfo->cPeerInfo && pProviderInfo->pPeerInfo)
        {
            *pulResolveAttempts = pProviderInfo->pPeerInfo[dwMostRecentlySyncdPeerIndex].ulResolveAttempts;
            *pulValidDataCounter = pProviderInfo->pPeerInfo[dwMostRecentlySyncdPeerIndex].ulValidDataCounter;
            *pu64TimeRemaining = pProviderInfo->pPeerInfo[dwMostRecentlySyncdPeerIndex].u64TimeRemaining;
            *pu64LastSuccessfulSync = pProviderInfo->pPeerInfo[dwMostRecentlySyncdPeerIndex].u64LastSuccessfulSync;
            *phrLastSyncError = pProviderInfo->pPeerInfo[dwMostRecentlySyncdPeerIndex].ulLastSyncError;
            *pulLastSyncErrorMsgId = pProviderInfo->pPeerInfo[dwMostRecentlySyncdPeerIndex].ulLastSyncErrorMsgId;

            if (pProviderInfo->pPeerInfo[dwMostRecentlySyncdPeerIndex].wszUniqueName)
            {
                StringCchCopy( pszServer, cchSize, pProviderInfo->pPeerInfo[dwMostRecentlySyncdPeerIndex].wszUniqueName );
                
                // Strip off non-user friendly information which may have been tacked on to the peer name:
                LPTSTR pszJunk = StrStrW(pszServer, L" (");
                if (pszJunk)
                {
                    pszJunk[0] = 0;
                }

                pszJunk = StrStrW(pszServer, L","); 
                if (pszJunk)
                {
                    pszJunk[0] = 0;
                }
            }
        }
    else
    {
        *phrLastSyncError = HRESULT_FROM_WIN32(ERROR_TIMEOUT); 
        if (NULL != pszServerToQuery) 
        {
            StringCchCopy( pszServer, cchSize, pszServerToQuery );
        }
        
    }

        W32TimeBufferFree(pProviderInfo);
    }
    else
    {
        hr = ResultFromWin32(dwError);
    }

    return hr;
}


// pftTimeRemaining will be returned with the time/date of the next sync, not time from now.
HRESULT W32TimeGetErrorInfoWrapHelper(UINT * pulResolveAttempts, ULONG * pulValidDataCounter, FILETIME * pftTimeRemaining, FILETIME * pftLastSuccessfulSync, HRESULT * phrLastSyncError,
                                UINT * pulLastSyncErrorMsgId, LPTSTR pszServer, DWORD cchSize, LPTSTR pszServerToQuery)
{
    UINT64 * pu64LastSuccessfulSync = (UINT64 *) pftLastSuccessfulSync;
    UINT64 u64TimeRemaining;
    HRESULT hr = W32TimeGetErrorInfoWrap(pulResolveAttempts, pulValidDataCounter, &u64TimeRemaining, pu64LastSuccessfulSync, phrLastSyncError, pulLastSyncErrorMsgId, pszServer, cchSize, pszServerToQuery);

    if (SUCCEEDED(hr))
    {
        SYSTEMTIME stCurrent;
        FILETIME ftCurrent;

        GetSystemTime(&stCurrent);
        SystemTimeToFileTime(&stCurrent, &ftCurrent);

        ULONGLONG * pNextSync = (ULONGLONG *) pftTimeRemaining;
        ULONGLONG * pCurrent = (ULONGLONG *) &ftCurrent;
        *pNextSync = (*pCurrent + u64TimeRemaining);
    }

    return hr;
}


// This function is called on the background thread.
HRESULT CInternetTime::_GetDateTimeString(FILETIME * pftTimeDate, BOOL fDate, LPTSTR pszString, DWORD cchSize)
{
    HRESULT hr = S_OK;
    TCHAR szFormat[MAX_PATH];

    pszString[0] = 0;
    if (GetLocaleInfo(LOCALE_USER_DEFAULT, (fDate ? LOCALE_SSHORTDATE : LOCALE_STIMEFORMAT), szFormat, ARRAYSIZE(szFormat)))
    {
        SYSTEMTIME stTimeDate;

        if (FileTimeToSystemTime(pftTimeDate, &stTimeDate))
        {
            if (fDate)
            {
                if (!GetDateFormat(LOCALE_USER_DEFAULT, 0, &stTimeDate, szFormat, pszString, cchSize))
                {
                    hr = ResultFromLastError();
                }
            }
            else
            {
                if (!GetTimeFormat(LOCALE_USER_DEFAULT, TIME_NOSECONDS, &stTimeDate, szFormat, pszString, cchSize))
                {
                    hr = ResultFromLastError();
                }
            }
        }
        else
        {
            hr = ResultFromLastError();
        }
    }
    else
    {
        hr = ResultFromLastError();
    }

    return hr;
}


HRESULT _CleanUpErrorString(LPWSTR pszTemp4, DWORD cchSize)
{
    PathRemoveBlanks(pszTemp4);
    while (TRUE)
    {
        DWORD cchSizeTemp = lstrlen(pszTemp4);
        if (cchSizeTemp && ((TEXT('\n') == pszTemp4[cchSizeTemp-1]) ||
            (13 == pszTemp4[cchSizeTemp-1])))
        {
            pszTemp4[cchSizeTemp-1] = 0;
        }
        else
        {
            break;
        }
    }

    return S_OK;
}


// This function is called on the background thread.
HRESULT CInternetTime::_CreateW32TimeSuccessErrorString(DWORD dwError, LPTSTR pszString, DWORD cchSize, LPTSTR pszNextSync, DWORD cchNextSyncSize, LPTSTR pszServerToQuery)
{
    HRESULT hr = S_OK;
    UINT ulResolveAttempts = 0;
    FILETIME ftTimeRemainingUTC = {0};
    FILETIME ftLastSuccessfulSyncUTC = {0};
    FILETIME ftTimeRemaining = {0};
    FILETIME ftLastSuccessfulSync = {0};
    UINT ulLastSyncErrorMsgId = 0;
    TCHAR szServer[MAX_PATH];
    HRESULT hrLastSyncError = 0;
    ULONG ulValidDataCounter = 0;
    TCHAR szTemplate[MAX_PATH];
    TCHAR szTemp1[MAX_PATH];
    TCHAR szTemp2[MAX_PATH];
    TCHAR szTemp3[MAX_URL_STRING];
    TCHAR szTemp4[MAX_URL_STRING];

    pszString[0] = 0;
    pszNextSync[0] = 0;

    hr = W32TimeGetErrorInfoWrapHelper(&ulResolveAttempts, &ulValidDataCounter, &ftTimeRemainingUTC, &ftLastSuccessfulSyncUTC, &hrLastSyncError, &ulLastSyncErrorMsgId, szServer, ARRAYSIZE(szServer), pszServerToQuery);
    if (SUCCEEDED(hr))
    {
        // ftTimeRemaining and ftLastSuccessfulSync are stored in UTC, so translate to our time zone.
        FileTimeToLocalFileTime(&ftTimeRemainingUTC, &ftTimeRemaining);
        FileTimeToLocalFileTime(&ftLastSuccessfulSyncUTC, &ftLastSuccessfulSync);

        // Create the string showing the next time we plan on syncing.
        LoadString(HINST_THISDLL, IDS_IT_NEXTSYNC, szTemplate, ARRAYSIZE(szTemplate));
        if (SUCCEEDED(_GetDateTimeString(&ftTimeRemaining, TRUE, szTemp1, ARRAYSIZE(szTemp1))) &&           // Get the date
            SUCCEEDED(_GetDateTimeString(&ftTimeRemaining, FALSE, szTemp2, ARRAYSIZE(szTemp2))) &&          // Get the time
            FAILED(FormatMessageWedge(szTemplate, pszNextSync, cchNextSyncSize, szTemp1, szTemp2)))
        {
            pszNextSync[0] = 0;
        }

        if (ResyncResult_ChangeTooBig == dwError)
        {
            hrLastSyncError = E_FAIL;
        }

    if ((ResyncResult_NoData == dwError || ResyncResult_StaleData == dwError) && SUCCEEDED(hrLastSyncError))
    {
        // We've synchronized from our peer, but it didn't provide good enough samples to update our clock. 
        hrLastSyncError = HRESULT_FROM_WIN32(ERROR_TIMEOUT);  // approximately the right error
    }

    // We should never hit the following case.  But if the operation failed (NOT ResyncResult_Success)
        // then we need hrLastSyncError to be a failure value.
        if ((ResyncResult_Success != dwError) && SUCCEEDED(hrLastSyncError))
        {
            hrLastSyncError = E_FAIL;
        }

        switch (hrLastSyncError)
        {
        case S_OK:
            if (!ftLastSuccessfulSyncUTC.dwLowDateTime && !ftLastSuccessfulSyncUTC.dwHighDateTime)
            {
                // We have never sync from the server.
                LoadString(HINST_THISDLL, IDS_NEVER_TRIED_TOSYNC, pszString, cchSize);
            }
            else
            {
                if (szServer[0])
                {
                    // Format: "Successfully synchronized the clock on 12/23/2001 at 11:03:32am from time.windows.com."
                    LoadString(HINST_THISDLL, IDS_IT_SUCCESS, szTemplate, ARRAYSIZE(szTemplate));

                    if (SUCCEEDED(_GetDateTimeString(&ftLastSuccessfulSync, TRUE, szTemp1, ARRAYSIZE(szTemp1))) &&      // Get the date
                        SUCCEEDED(_GetDateTimeString(&ftLastSuccessfulSync, FALSE, szTemp2, ARRAYSIZE(szTemp2))) &&     // Get the time
                        FAILED(FormatMessageWedge(szTemplate, pszString, cchSize, szTemp1, szTemp2, szServer)))
                    {
                        pszString[0] = 0;
                    }
                }
                else
                {
                    // Format: "Successfully synchronized the clock on 12/23/2001 at 11:03:32am."
                    LoadString(HINST_THISDLL, IDS_IT_SUCCESS2, szTemplate, ARRAYSIZE(szTemplate));

                    if (SUCCEEDED(_GetDateTimeString(&ftLastSuccessfulSync, TRUE, szTemp1, ARRAYSIZE(szTemp1))) &&      // Get the date
                        SUCCEEDED(_GetDateTimeString(&ftLastSuccessfulSync, FALSE, szTemp2, ARRAYSIZE(szTemp2))) &&     // Get the time
                        FAILED(FormatMessageWedge(szTemplate, pszString, cchSize, szTemp1, szTemp2)))
                    {
                        pszString[0] = 0;
                    }
                }
            }
            break;

        case S_FALSE:
            pszString[0] = 0;
            break;

        default:
            if (ulValidDataCounter &&
                ((0 != ftLastSuccessfulSyncUTC.dwLowDateTime) || (0 != ftLastSuccessfulSyncUTC.dwHighDateTime)))
            {
                // Getting this far means we may have failed this last sync attempt, but we have succeeded
                // previously

                hr = E_FAIL;
                szTemp4[0] = 0; // This will be the error message.
                szTemp3[0] = 0;

                if (ResyncResult_ChangeTooBig == dwError)
                {
                    // If the date is too far off, we fail the sync for security reasons.  That happened
                    // here.
                    LoadString(HINST_THISDLL, IDS_ERR_DATETOOWRONG, szTemp4, ARRAYSIZE(szTemp4));
                }
                else if (ulLastSyncErrorMsgId)           // We have a bonus error string.
                {
                    HMODULE hW32Time = LoadLibrary( L"w32time.dll" );   // should have been loaded by linker already.
                    if (hW32Time)
                    {
                        // Load the specific reason the sync failed.
                        if (0 == FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, (LPCVOID) hW32Time, ulLastSyncErrorMsgId, 0, szTemp4, ARRAYSIZE(szTemp4), NULL))
                        {
                            szTemp4[0] = 0;     // We will get the value below
                            hr = S_OK;
                        }
                        else
                        {
                            _CleanUpErrorString(szTemp4, ARRAYSIZE(szTemp4));
                        }

                        FreeLibrary( hW32Time );
                    }
                }

                if ( 0 == szTemp4[0])
                {
                    if (0 != FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, HRESULT_CODE(hrLastSyncError), 0, szTemp4, ARRAYSIZE(szTemp4), NULL))
                    {
                        _CleanUpErrorString(szTemp4, ARRAYSIZE(szTemp4));
                    }
                    else
                    {
                        szTemp4[0] = 0;
                    }
                }

                if (szTemp4[0])
                {
                    LoadString(HINST_THISDLL, IDS_IT_FAIL1, szTemplate, ARRAYSIZE(szTemplate));
                    if (FAILED(FormatMessageWedge(szTemplate, szTemp3, ARRAYSIZE(szTemp3), szServer, szTemp4)))
                    {
                        szTemp3[0] = 0;
                    }
                }
                else
                {
                    //  <------------------------------------------------------------->
                    // Format:
                    // "An error occurred synchronizing the clock from time.windows.com
                    //  on 2/3/2001 at 11:03:32am.  Unable to connect to the server."
                    LoadString(HINST_THISDLL, IDS_IT_FAIL2, szTemplate, ARRAYSIZE(szTemplate));
                    if (FAILED(FormatMessageWedge(szTemplate, szTemp3, ARRAYSIZE(szTemp3), szServer)))
                    {
                        szTemp3[0] = 0;
                    }

                    hr = S_OK;
                }

                LoadString(HINST_THISDLL, IDS_IT_FAILLAST, szTemplate, ARRAYSIZE(szTemplate));

                if (SUCCEEDED(_GetDateTimeString(&ftLastSuccessfulSync, TRUE, szTemp1, ARRAYSIZE(szTemp1))) &&      // Get the date
                    SUCCEEDED(_GetDateTimeString(&ftLastSuccessfulSync, FALSE, szTemp2, ARRAYSIZE(szTemp2))) &&     // Get the time
                    FAILED(FormatMessageWedge(szTemplate, szTemp4, ARRAYSIZE(szTemp4), szTemp1, szTemp2)))
                {
                    szTemp4[0] = 0;
                }

                StringCchPrintf( pszString, cchSize, L"%s\n\n%s", szTemp3, szTemp4 );
            }
            else
            {
                // Getting this far means we may have failed to sync this time and we have never succeeded before.

                if (ulLastSyncErrorMsgId)           // We have a bonus error string.
                {
                    szTemp3[0] = 0;

                    HMODULE hW32Time = LoadLibrary( L"w32time.dll" );
                    if (hW32Time)
                    {
                        //  <------------------------------------------------------------->
                        // Format:
                        // "An error occurred synchronizing the clock from time.windows.com
                        //  on 2/3/2001 at 11:03:32am.  Unable to connect to the server."
                        if (0 == FormatMessage(FORMAT_MESSAGE_FROM_HMODULE, (LPCVOID) hW32Time, ulLastSyncErrorMsgId, 0, szTemp4, ARRAYSIZE(szTemp4), NULL))
                        {
                            szTemp4[0] = 0;
                        }
                        else
                        {
                            _CleanUpErrorString(szTemp4, ARRAYSIZE(szTemp4));
                        }

                        if (szServer[0])
                        {
                            LoadString(HINST_THISDLL, IDS_IT_FAIL1, szTemplate, ARRAYSIZE(szTemplate));
                            if (FAILED(FormatMessageWedge(szTemplate, pszString, cchSize, szServer, szTemp4)))
                            {
                                pszString[0] = 0;
                            }
                        }
                        else
                        {
                            LoadString(HINST_THISDLL, IDS_IT_FAIL3, szTemplate, ARRAYSIZE(szTemplate));
                            if (FAILED(FormatMessageWedge(szTemplate, pszString, cchSize, szTemp4)))
                            {
                                pszString[0] = 0;
                            }
                        }

                        FreeLibrary( hW32Time );
                    }
                }
                else
                {
                    //  <------------------------------------------------------------->
                    // Format:
                    // "An error occurred synchronizing the clock from time.windows.com
                    //  on 2/3/2001 at 11:03:32am.  Unable to connect to the server."
                    LoadString(HINST_THISDLL, IDS_IT_FAIL2, szTemplate, ARRAYSIZE(szTemplate));
                    if (FAILED(FormatMessageWedge(szTemplate, pszString, cchSize, szServer)))
                    {
                        pszString[0] = 0;
                    }
                }
            }
            break;
        };
    }
    else
    {
        LoadString(HINST_THISDLL, IDS_ERR_GETINFO_FAIL, szTemplate, ARRAYSIZE(szTemplate));
        if (0 == FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, HRESULT_CODE(hr), 0, szTemp1, ARRAYSIZE(szTemp1), NULL))
        {
            szTemp1[0] = 0;
        }
        else
        {
            _CleanUpErrorString(szTemp1, ARRAYSIZE(szTemp1));
        }

        StringCchPrintf( pszString, cchSize, szTemplate, szTemp1 );
    }

    return hr;
}


///////////
// These functions will cause the background thread to check if we should add the "Internet Time" tab.
///////////

// This function is called on the background thread.
DWORD CALLBACK _AsyncCheckDCThread(void * pv)
{
    if (g_pInternetTime)
    {
        g_pInternetTime->AsyncCheck();
    }

    return 0;
}

// This function is called on the background thread.
BOOL CInternetTime::IsInternetTimeAvailable(void)
{
    return SHRegGetBoolUSValue(SZ_REGKEY_DATETIME, SZ_REGVALUE_INTERNET_FEATURE_AVAILABLE, FALSE, FEATURE_INTERNET_TIME);
}


// This function is called on the background thread.
EXTERN_C BOOL DoesTimeComeFromDC(void)
{
    BOOL fTimeFromDomain = FALSE;
    LPWSTR pszDomain = NULL;
    NETSETUP_JOIN_STATUS joinStatus = NetSetupUnknownStatus;
    DWORD dwError = NetGetJoinInformation(NULL, &pszDomain, &joinStatus);

    // We will act like there isn't a DC if we have the test registry set.
    if (NERR_Success == dwError)
    {
        // If we are connected to a domain, we need to do the expensive net search
        // to see that is where we will get the time from.
        if (NetSetupDomainName == joinStatus)
        {
            PDOMAIN_CONTROLLER_INFO pdomainInfo = {0};

            dwError = DsGetDcName(NULL, NULL, NULL, NULL, DS_TIMESERV_REQUIRED, &pdomainInfo);
            // We will act like there isn't a DC if we have the test registry set.
            if (ERROR_SUCCESS == dwError)
            {
                if (FALSE == SHRegGetBoolUSValue(SZ_REGKEY_DATETIME, SZ_REGVALUE_TEST_SIMULATENODC, FALSE, FALSE))
                {
                    fTimeFromDomain = TRUE;
                }

                NetApiBufferFree(pdomainInfo);
            }
        }

        if (pszDomain)
        {
            NetApiBufferFree(pszDomain);
        }
    }

    return fTimeFromDomain;
}


// This function is called on the background thread.
HRESULT CInternetTime::_SyncNow(BOOL fOnlyUpdateInfo)
{
    HRESULT hr = S_OK;

ENTERCRITICAL;
    BOOL fContinue = ((eBKAUpdate == m_eAction) || (eBKAGetInfo == m_eAction));
    if (fContinue)
    {
        m_eAction = eBKAUpdating;
    }
LEAVECRITICAL;

    if (fContinue)
    {
        hr = E_OUTOFMEMORY;
        DWORD cchSize = 4024;
        LPTSTR pszString = (LPTSTR) LocalAlloc(LPTR, sizeof(pszString[0]) * cchSize);

        if (pszString)
        {
            WCHAR szExistingServer[MAX_URL_STRING];
            HRESULT hrServer = E_FAIL;

            TCHAR szNewServer[MAX_PATH]; 
            TCHAR szNextSync[MAX_PATH];
            DWORD dwError = 0;
            DWORD dwSyncFlags;

            if (!fOnlyUpdateInfo)
            {
                hrServer = GetW32TimeServer(FALSE, szExistingServer, ARRAYSIZE(szExistingServer));

                GetWindowText(GetDlgItem(m_hwndInternet, DATETIME_INTERNET_SERVER_EDIT), szNextSync, ARRAYSIZE(szNextSync));

                // save the new server away for future processing
                StringCchCopy( szNewServer, ARRAYSIZE(szNewServer), szNextSync ); 

                if (!ContainsServer(szExistingServer, szNextSync))
                {
                    // The servers don't match.  We want to add the new server to the beginning of the list.  This
                    // will work around a problem in W32time.  If we don't do this, then:
                    // 1. It will cause a second sync with the original server (which is bad for perf and affects statistics)
                    // 2. The Last Updated sync time will then be from the wrong peer.  This is really bad because it's result is basic
                    //    on the user's previously bad time
                    // 3. It will do an extra DNS resolution causing slowness on our side, increasing server traffic, and dragging down
                    //    the intranet.
                    TCHAR szTemp[MAX_URL_STRING];

                    StringCchCopy( szTemp, ARRAYSIZE(szTemp), szNextSync );
                    StringCchPrintf( szNextSync, ARRAYSIZE(szNextSync), L"%s %s", szTemp, szExistingServer );

                    dwSyncFlags = TimeSyncFlag_ReturnResult | TimeSyncFlag_UpdateAndResync; 
                } 
                else
                {
                    // We've already got this server in our list of servers.  Just cause our peers to resync. 
                    dwSyncFlags = TimeSyncFlag_ReturnResult | TimeSyncFlag_HardResync; 
                }

                SetW32TimeServer(szNextSync);

                // I will ignore the error value because I will get the error info in _CreateW32TimeSuccessErrorString.
                dwError = W32TimeSyncNow(SZ_COMPUTER_LOCAL, TRUE /* Synchronous */, dwSyncFlags); 
                if ((ResyncResult_StaleData == dwError) && (0 == (TimeSyncFlag_HardResync & dwSyncFlags)))
                {
                    // We've got stale data preventing us from resyncing.  Try again with a full resync. 
                    dwSyncFlags = TimeSyncFlag_ReturnResult | TimeSyncFlag_HardResync; 
                    dwError = W32TimeSyncNow(SZ_COMPUTER_LOCAL, TRUE /* Synchronous */, dwSyncFlags); 
                }
            }

            pszString[0] = 0;
            szNextSync[0] = 0;
        
            hr = _CreateW32TimeSuccessErrorString(dwError, pszString, cchSize, szNextSync, ARRAYSIZE(szNextSync), (SUCCEEDED(hrServer) ? szNewServer : NULL));

            if (SUCCEEDED(hrServer))
            {
                SetW32TimeServer(szExistingServer);
                _StartServiceAndRefresh(TRUE);      // Make sure the service is on and make it update it's settings.
            }

ENTERCRITICAL;
            Str_SetPtr(&m_pszNextSyncTime, szNextSync);

            if (m_pszStatusString)
            {
                LocalFree(m_pszStatusString);
            }
            m_pszStatusString = pszString;

            PostMessage(m_hwndInternet, WMUSER_UPDATED_STATUS_TEXT, 0, 0);      // Tell the forground thread to pick up the new string.
            m_eAction = eBKAWait;
LEAVECRITICAL;
        }
    }

    return hr;
}


// This function is called on the background thread.
void CInternetTime::AsyncCheck(void)
{
    HRESULT hr = S_OK;

    if (m_hDlg && !DoesTimeComeFromDC())
    {
        // Tell the forground thread to add us.
        PostMessage(m_hwndDate, WMUSER_ADDINTERNETTAB, 0, 0);
        _ProcessBkThreadActions();
    }
}


// This function is called on the background thread.
HRESULT CInternetTime::_ProcessBkThreadActions(void)
{
    HRESULT hr = S_OK;

    while (eBKAQuit != m_eAction)           // Okay since we are only reading
    {
        switch (m_eAction)
        {
        case eBKAGetInfo:
            _SyncNow(TRUE);
            break;

        case eBKAUpdate:
            _SyncNow(FALSE);
            break;

        case eBKAUpdating:
        case eBKAWait:
        default:
            Sleep(300);     // We don't care if there is up to 100ms latency between button press and action starting.
            break;
        }
    }

    return hr;
}



/////////////////////////////////////////////////////////////////////
// Public Functions
/////////////////////////////////////////////////////////////////////
// This function is called on the forground thread.
EXTERN_C HRESULT AddInternetPageAsync(HWND hDlg, HWND hwndDate)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (!g_pInternetTime)
    {
        g_pInternetTime = new CInternetTime(hDlg, hwndDate);
    }

    if (g_pInternetTime)
    {
        // We only want to add the page that allows the user to get the time from the internet if:
        // 1. The feature is turned on, and
        // 2. The user doesn't get the time from an intranet Domain Control.
        if (g_pInternetTime->IsInternetTimeAvailable())
        {
            // Start the thread to find out if we are in a domain and need the advanced page.  We need
            // to do this on a background thread because the DsGetDcName() API may take 10-20 seconds.
            hr = (SHCreateThread(_AsyncCheckDCThread, hDlg, (CTF_INSIST | CTF_FREELIBANDEXIT), NULL) ? S_OK : E_FAIL);
        }
    }

    return hr;
}


// This function is called on the forground thread.
EXTERN_C HRESULT AddInternetTab(HWND hDlg)
{
    HRESULT hr = E_OUTOFMEMORY;

    if (g_pInternetTime)
    {
        hr = g_pInternetTime->AddInternetPage();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\utc\mapctl.c ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mapctl.c

Abstract:

    This module implements the map control for the Date/Time applet.

Revision History:

--*/



//
//  Include Files.
//

#include "timedate.h"
#include <commctrl.h>
#include "worldmap.h"
#include "mapctl.h"
#include "rc.h"




//
//  Constant Declarations.
//

#define MAPCTL_BITMAP_NAME          MAKEINTRESOURCE(IDB_TIMEZONE)

#define MAPCTL_ANIMATION_TIMER      1
#define MAPCTL_ANIMATION_INTERVAL   30
#define MAPCTL_ANIMATION_FACTOR     3

#define MAPCTL_DATA                 0


static const RGBQUAD c_SeaNormalColor       =  { 127,   0,   0,   0 };
static const RGBQUAD c_SeaHiliteColor       =  { 255,   0,   0,   0 };
static const RGBQUAD c_LandNormalColor      =  {   0, 127,   0,   0 };
static const RGBQUAD c_LandHiliteColor      =  {   0, 255,   0,   0 };

static const RGBQUAD c_MonoSeaNormalColor   =  { 255, 255, 255,   0 };
static const RGBQUAD c_MonoSeaHiliteColor   =  {   0,   0,   0,   0 };
static const RGBQUAD c_MonoLandNormalColor  =  {   0,   0,   0,   0 };
static const RGBQUAD c_MonoLandHiliteColor  =  { 255, 255, 255,   0 };




//
//  Typedef Declarations.
//

typedef struct tagMAPCTLDATA
{
    HWND        window;         // window handle for this control
    UINT_PTR    timer;          // timer id for this map control
    int         totaldelta;     // total delta we must cover to center stuff
    BOOL        slowdevice;
    BOOL        captured;
    WORLDMAP    map;            // world map object, at end of struct (>1k)

} MAPCTLDATA, *PMAPCTLDATA;




//
//  Function Prototypes.
//

PMAPCTLDATA
CreateMapControlData(
    HWND window);

void
DestroyMapControlData(
    PMAPCTLDATA ctldata);

LRESULT CALLBACK
MapControlWndProc(
    HWND window,
    UINT message,
    WPARAM wParam,
    LPARAM lParam);

BOOL
MapControlNCCreate(
    PMAPCTLDATA ctldata,
    LPCREATESTRUCT cs);

BOOL
MapControlCreate(
    PMAPCTLDATA ctldata,
    LPCREATESTRUCT cs);

void
MapControlNCDestroy(
    PMAPCTLDATA ctldata);

BOOL
MapControlErase(
    PMAPCTLDATA ctldata,
    HDC dc);

void
MapControlPaint(
    PMAPCTLDATA ctldata);

void
MapControlMouseMove(
    PMAPCTLDATA ctldata,
    int x,
    int y,
    UINT flags);

void
MapControlMouseDown(
    PMAPCTLDATA ctldata,
    BOOL dblclk,
    int x,
    int y,
    UINT flags);

void
MapControlMouseUp(
    PMAPCTLDATA ctldata,
    int x,
    int y,
    UINT flags);

void
MapControlTimerProc(
    PMAPCTLDATA ctldata,
    UINT timer);

void
MapControlRotate(
    PMAPCTLDATA ctldata,
    int delta);

void
MapControlAnimateOneStep(
    PMAPCTLDATA ctldata);





////////////////////////////////////////////////////////////////////////////
//
//  SetMapControlData
//
////////////////////////////////////////////////////////////////////////////

__inline
void SetMapControlData(
    HWND window,
    PMAPCTLDATA ctldata)
{
    SetWindowLongPtr(window, MAPCTL_DATA, (LONG_PTR)ctldata);
}


////////////////////////////////////////////////////////////////////////////
//
//  GetMapControlData
//
////////////////////////////////////////////////////////////////////////////

__inline
PMAPCTLDATA GetMapControlData(
    HWND window)
{
    return ( (PMAPCTLDATA)GetWindowLongPtr(window, MAPCTL_DATA) );
}


////////////////////////////////////////////////////////////////////////////
//
//  RegisterMapControlStuff
//
////////////////////////////////////////////////////////////////////////////

BOOL RegisterMapControlStuff(
    HINSTANCE instance)
{
    WNDCLASS wc;

    wc.style = 0;
    wc.lpfnWndProc = MapControlWndProc;
    wc.cbClsExtra = 0;
    wc.cbWndExtra = sizeof(PMAPCTLDATA);
    wc.hInstance = instance;
    wc.hIcon = NULL;
    wc.hCursor = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName = NULL;
    wc.lpszClassName = MAPCTL_CLASSNAME;

    return ( RegisterClass(&wc) );
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlSetSeaRegionHighlight
//
////////////////////////////////////////////////////////////////////////////

void MapControlSetSeaRegionHighlight(
    HWND window,
    int index,
    BOOL highlighted,
    int x,
    int cx)
{
    ChangeWorldMapColor( &GetMapControlData(window)->map,
                         index,
#ifdef ENABLE_MAP
                         highlighted ? &c_SeaHiliteColor : &c_SeaNormalColor,
#else
                         &c_SeaNormalColor,
#endif
                         x,
                         cx );
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlSetLandRegionHighlight
//
////////////////////////////////////////////////////////////////////////////

void MapControlSetLandRegionHighlight(
    HWND window,
    int index,
    BOOL highlighted,
    int x,
    int cx)
{
    ChangeWorldMapColor( &GetMapControlData(window)->map,
                         index,
#ifdef ENABLE_MAP
                         highlighted ? &c_LandHiliteColor : &c_LandNormalColor,
#else
                         &c_LandNormalColor,
#endif
                         x,
                         cx );
}


////////////////////////////////////////////////////////////////////////////
//
//  _InvalidateProc
//
////////////////////////////////////////////////////////////////////////////

void _InvalidateProc(
    LPARAM data,
    int left,
    int right)
{
#define ctldata ((PMAPCTLDATA)data)
    RECT ri = { left, 0, right, ctldata->map.size.cy };

    InvalidateRect(ctldata->window, &ri, TRUE);
#undef ctldata
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlInvalidateDirtyRegions
//
////////////////////////////////////////////////////////////////////////////

void MapControlInvalidateDirtyRegions(
    HWND window)
{
    PMAPCTLDATA ctldata = GetMapControlData(window);

    EnumWorldMapDirtySpans( &ctldata->map,
                            _InvalidateProc,
                            (LPARAM)ctldata,
                            TRUE );
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlRotateTo
//
////////////////////////////////////////////////////////////////////////////

void MapControlRotateTo(
    HWND window,
    int x,
    BOOL animate)
{
    PMAPCTLDATA ctldata = GetMapControlData(window);

    if (ctldata->timer)
    {
        KillTimer(ctldata->window, ctldata->timer);
        ctldata->timer = 0;
    }

    ctldata->totaldelta = (ctldata->map.size.cx / 2) -
                          WorldMapGetDisplayedLocation(&ctldata->map, x);

    if (ctldata->totaldelta)
    {
        UpdateWindow(ctldata->window);

        if (animate)
        {
            ctldata->timer = SetTimer( ctldata->window,
                                       MAPCTL_ANIMATION_TIMER,
                                       MAPCTL_ANIMATION_INTERVAL,
                                       NULL );

            if (ctldata->timer)
            {
                MapControlAnimateOneStep(ctldata);
                return;
            }
        }

        MapControlRotate(ctldata, ctldata->totaldelta);
        ctldata->totaldelta = 0;
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  CreateMapControlData
//
////////////////////////////////////////////////////////////////////////////

PMAPCTLDATA CreateMapControlData(
    HWND window)
{
    PMAPCTLDATA ctldata = (PMAPCTLDATA)LocalAlloc(LPTR, sizeof(MAPCTLDATA));

    if (ctldata)
    {
        ctldata->window = window;
        SetMapControlData(window, ctldata);
    }

    return (ctldata);
}


////////////////////////////////////////////////////////////////////////////
//
//  DestroyMapControlData
//
////////////////////////////////////////////////////////////////////////////

void DestroyMapControlData(
    PMAPCTLDATA ctldata)
{
    if (ctldata)
    {
        SetMapControlData(ctldata->window, 0);
        LocalFree(ctldata);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlWndProc
//
////////////////////////////////////////////////////////////////////////////

LRESULT CALLBACK MapControlWndProc(
    HWND window,
    UINT message,
    WPARAM wParam,
    LPARAM lParam)
{
    PMAPCTLDATA ctldata = (message == WM_NCCREATE)
                              ? CreateMapControlData(window)
                              : GetMapControlData(window);

    switch (message)
    {
        HANDLE_MSG(ctldata, WM_NCCREATE,    MapControlNCCreate);
        HANDLE_MSG(ctldata, WM_CREATE,      MapControlCreate);
        HANDLE_MSG(ctldata, WM_NCDESTROY,   MapControlNCDestroy);

        HANDLE_MSG(ctldata, WM_ERASEBKGND,  MapControlErase);
        HANDLE_MSG(ctldata, WM_PAINT,       MapControlPaint);

#ifdef ENABLE_MAP
        HANDLE_MSG(ctldata, WM_MOUSEMOVE,   MapControlMouseMove);
        HANDLE_MSG(ctldata, WM_LBUTTONDOWN, MapControlMouseDown);
        HANDLE_MSG(ctldata, WM_LBUTTONUP,   MapControlMouseUp);
#endif
        HANDLE_MSG(ctldata, WM_TIMER,       MapControlTimerProc);
    }

    return ( DefWindowProc(window, message, wParam, lParam) );
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlNCCreate
//
////////////////////////////////////////////////////////////////////////////

BOOL MapControlNCCreate(
    PMAPCTLDATA ctldata,
    LPCREATESTRUCT cs)
{
    if (!ctldata)
    {
        return (FALSE);
    }

    //
    //  NCDESTROY tries to nuke this if it's nonzero.
    //
    ctldata->timer = 0;

    if (!LoadWorldMap(&ctldata->map, g_hInst, MAPCTL_BITMAP_NAME))
    {
        return (FALSE);
    }

    ctldata->slowdevice = (ctldata->map.prepared.dc != NULL);
    ctldata->totaldelta = 0;
    ctldata->captured = FALSE;
    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlCreate
//
////////////////////////////////////////////////////////////////////////////

BOOL MapControlCreate(
    PMAPCTLDATA ctldata,
    LPCREATESTRUCT cs)
{
    RECT rc = { 0, 0, ctldata->map.size.cx, ctldata->map.size.cy };

    if (AdjustWindowRectEx( &rc,
                            GetWindowLong(ctldata->window, GWL_STYLE),
                            FALSE,
                            GetWindowLong(ctldata->window, GWL_EXSTYLE)))
    {
        SIZE sz = { rc.right - rc.left, rc.bottom - rc.top };

        MoveWindow( ctldata->window,
                    cs->x + ((cs->cx - sz.cx) / 2),
                    cs->y + ((cs->cy - sz.cy) / 2 ),
                    sz.cx,
                    sz.cy,
                    FALSE );
    }

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlNCDestroy
//
////////////////////////////////////////////////////////////////////////////

void MapControlNCDestroy(
    PMAPCTLDATA ctldata)
{
    if (ctldata)
    {
        if (ctldata->timer)
        {
            KillTimer(ctldata->window, ctldata->timer);
        }

        FreeWorldMap(&ctldata->map);
        DestroyMapControlData(ctldata);
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlErase
//
////////////////////////////////////////////////////////////////////////////

BOOL MapControlErase(
    PMAPCTLDATA ctldata,
    HDC dc)
{
    RECT rce;

    GetClipBox(dc, &rce);

    DrawWorldMap( dc,
                  rce.left,
                  rce.top,
                  rce.right - rce.left,
                  rce.bottom - rce.top,
                  &ctldata->map,
                  rce.left,
                  rce.top,
                  SRCCOPY );

    return (TRUE);
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlPaint
//
////////////////////////////////////////////////////////////////////////////

void MapControlPaint(
    PMAPCTLDATA ctldata)
{
    PAINTSTRUCT ps;

    BeginPaint(ctldata->window, &ps);
    EndPaint(ctldata->window, &ps);
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlMouseMove
//
////////////////////////////////////////////////////////////////////////////

void MapControlMouseMove(
    PMAPCTLDATA ctldata,
    int x,
    int y,
    UINT flags)
{
    if (ctldata->captured)
    {
        if (flags & MK_LBUTTON)
        {
            NFYMAPEVENT event;

            event.index = GetWorldMapColorIndex(&ctldata->map, x, y);

            SendNotify( GetParent(ctldata->window),
                        ctldata->window,
                        MAPN_TOUCH,
                        (NMHDR *)&event );
        }
        else
        {
            //
            //  No time to handle WM_CAPTURECHANGED.
            //
            ctldata->captured = FALSE;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlMouseDown
//
////////////////////////////////////////////////////////////////////////////

void MapControlMouseDown(
    PMAPCTLDATA ctldata,
    BOOL dblclk,
    int x,
    int y,
    UINT flags)
{
    NFYMAPEVENT event;

    SetCapture(ctldata->window);
    ctldata->captured = TRUE;

    if (ctldata->timer)
    {
        KillTimer(ctldata->window, ctldata->timer);
        ctldata->timer = 0;
    }

    event.index = GetWorldMapColorIndex(&ctldata->map, x, y);

    SendNotify( GetParent(ctldata->window),
                ctldata->window,
                MAPN_TOUCH,
                (NMHDR *)&event );
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlMouseUp
//
////////////////////////////////////////////////////////////////////////////

void MapControlMouseUp(
    PMAPCTLDATA ctldata,
    int x,
    int y,
    UINT flags)
{
    if (ctldata->captured)
    {
        NFYMAPEVENT event;
        int index = GetWorldMapColorIndex(&ctldata->map, x, y);

        ReleaseCapture();

        event.index = index;
        SendNotify( GetParent(ctldata->window),
                    ctldata->window,
                    MAPN_TOUCH,
                    (NMHDR *)&event );

        event.index = index;
        SendNotify( GetParent(ctldata->window),
                    ctldata->window,
                    MAPN_SELECT,
                    (NMHDR *)&event );
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlTimerProc
//
////////////////////////////////////////////////////////////////////////////

void MapControlTimerProc(
    PMAPCTLDATA ctldata,
    UINT timer)
{
    if (timer == MAPCTL_ANIMATION_TIMER)
    {
        if (ctldata->totaldelta)
        {
            MapControlAnimateOneStep(ctldata);
        }

        if (!ctldata->totaldelta && ctldata->timer)
        {
            KillTimer(ctldata->window, ctldata->timer);
            ctldata->timer = 0;
        }
    }
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlRotate
//
////////////////////////////////////////////////////////////////////////////

void MapControlRotate(
    PMAPCTLDATA ctldata,
    int delta)
{
    RotateWorldMap(&ctldata->map, delta);
    ScrollWindow(ctldata->window, delta, 0, NULL, NULL);
}


////////////////////////////////////////////////////////////////////////////
//
//  MapControlAnimateOneStep
//
////////////////////////////////////////////////////////////////////////////

void MapControlAnimateOneStep(
    PMAPCTLDATA ctldata)
{
    //
    //  Check that we really need to do something.
    //
    if (ctldata->totaldelta)
    {
        //
        //  Try to create a deceleration effect...
        //
        int delta = ctldata->totaldelta / MAPCTL_ANIMATION_FACTOR;
        BOOL negative = (ctldata->totaldelta < 0);

        if (!delta)
        {
            delta = negative ? -1 : 1;
        }

        if (ctldata->slowdevice)
        {
            //
            //  Multiples of 8 will help on planar devices.
            //
            int preferred = ((delta + (negative ? 0 : 7)) & ~7);

            if (preferred)
            {
                delta = preferred;
            }
        }

        //
        //  Don't go too far.
        //
        if ((negative && (delta < ctldata->totaldelta)) ||
            (!negative && (delta > ctldata->totaldelta)))
        {
            delta = ctldata->totaldelta;
        }

        //
        //  Rotate the map and update the total delta left to go.
        //
        ctldata->totaldelta -= delta;
        MapControlRotate(ctldata, delta);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\utc\mapctl.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    mapctl.h

Abstract:

    This module contains the information for the map control of the
    Date/Time applet.

Revision History:

--*/



#ifndef _MAPCTL_H
#define _MAPCTL_H



//
//  Constant Declarations.
//

#define MAPN_TOUCH           0
#define MAPN_SELECT          1




//
//  Typedef Declarations.
//

typedef struct
{
    NMHDR hdr;
    int index;

} NFYMAPEVENT;

#define MAPCTL_MAX_INDICES  256




//
//  Function Prototypes.
//

BOOL
RegisterMapControlStuff(
    HINSTANCE instance);

void
MapControlSetSeaRegionHighlight(
    HWND window,
    int index,
    int value,
    int x,
    int cx);

void
MapControlSetLandRegionHighlight(
    HWND window,
    int index,
    BOOL highlighted,
    int x,
    int cx);

void
MapControlInvalidateDirtyRegions(
    HWND window);

void
MapControlRotateTo(
    HWND window,
    int x,
    BOOL animate);


#endif // _MAPCTL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\shell\cpls\utc\rc.h ===
/*++

Copyright (c) 1994-1998,  Microsoft Corporation  All rights reserved.

Module Name:

    rc.h

Abstract:

    This module contains the resource ids for the Date/Time applet.

Revision History:

--*/



#ifdef RC_INVOKED
  #define MAPCTL_CLASSNAME        "CplWorldMapClass"
  #define CALENDAR_CLASS          "CalWndMain"
  #define CLOCK_CLASS             "ClockWndMain"
#else
  #define MAPCTL_CLASSNAME        TEXT("CplWorldMapClass")
  #define CALENDAR_CLASS          TEXT("CalWndMain")
  #define CLOCK_CLASS             TEXT("ClockWndMain")
#endif

#define DLG_DATETIME              1
#define DLG_TIMEZONE              2
#define DLG_ADVANCED              3
#define DLG_DATETIMEWIDE          10

#define IDB_TIMEZONE              50

#define IDD_AUTOMAGIC             100
#define IDD_TIMEZONES             101
#define IDD_TIMEMAP               102
#define IDD_GROUPBOX1             103
#define IDD_GROUPBOX2             104

#define IDI_TIMEDATE              200

#define IDS_TIMEDATE              300
#define IDS_TIMEDATEINFO          301

#define IDS_WARNAUTOTIMECHANGE    302
#define IDS_WATC_CAPTION          303

#define IDS_CAPTION               304
#define IDS_NOTIMEERROR           305

#define IDS_ISRAELTIMEZONE        306
#define IDS_JERUSALEMTIMEZONE     307


// Internet Time Success/Error strings
#define IDS_IT_WAITFORSYNC        500
#define IDS_IT_NEXTSYNC           501
#define IDS_IT_SUCCESS            502
#define IDS_IT_SUCCESS2           503
#define IDS_IT_FAIL1              504
#define IDS_IT_FAIL2              505
#define IDS_IT_FAILLAST           506

#define IDS_TROUBLESHOOT_INTERNETIME 507
#define IDS_ERR_DATETOOWRONG      508
#define IDS_ERR_GETINFO_FAIL      509
#define IDS_NEVER_TRIED_TOSYNC    510
#define IDS_IT_FAIL3              511



//
//  The Order of