public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.Dispose2"]/*' />
        void Dispose(bool disposing) {
            if (nativeFormat != IntPtr.Zero) {
                Debug.Assert(nativeFormat != IntPtr.Zero, "NativeFormat is null!");
                int status = SafeNativeMethods.GdipDeleteStringFormat(new HandleRef(this, nativeFormat));

                nativeFormat = IntPtr.Zero;

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

            }
        }

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.Clone"]/*' />
        /// <devdoc>
        ///    Creates an exact copy of this <see cref='System.Drawing.StringFormat'/>.
        /// </devdoc>
        public object Clone() {
            IntPtr cloneFormat = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCloneStringFormat(new HandleRef(this, nativeFormat), out cloneFormat);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            StringFormat newCloneStringFormat = new StringFormat(cloneFormat);

            return newCloneStringFormat;
        }


        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.FormatFlags"]/*' />
        /// <devdoc>
        ///    Gets or sets a <see cref='System.Drawing.StringFormatFlags'/> that contains formatting information.
        /// </devdoc>
        public StringFormatFlags FormatFlags {
            get {
                StringFormatFlags format;

                int status = SafeNativeMethods.GdipGetStringFormatFlags(new HandleRef(this, nativeFormat), out format);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return format;
            }
            set {
                Debug.Assert(nativeFormat != IntPtr.Zero, "NativeFormat is null!");
                int status = SafeNativeMethods.GdipSetStringFormatFlags(new HandleRef(this, nativeFormat), value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.SetMeasurableCharacterRanges"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the measure of characters to the specified
        ///       range.
        ///    </para>
        /// </devdoc>
        public void SetMeasurableCharacterRanges(CharacterRange[] ranges) {

            int status = SafeNativeMethods.GdipSetStringFormatMeasurableCharacterRanges(new HandleRef(this, nativeFormat), ranges.Length, ranges);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

        }
        
        // For English, this is horizontal alignment
        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.Alignment"]/*' />
        /// <devdoc>
        ///    Specifies text alignment information.
        /// </devdoc>
        public StringAlignment Alignment {
            get {
                StringAlignment alignment = 0;
                Debug.Assert(nativeFormat != IntPtr.Zero, "NativeFormat is null!");
                int status = SafeNativeMethods.GdipGetStringFormatAlign(new HandleRef(this, nativeFormat), out alignment);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return alignment;
            }
            set {
                if (!Enum.IsDefined(typeof(StringAlignment), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(StringAlignment));
                }

                Debug.Assert(nativeFormat != IntPtr.Zero, "NativeFormat is null!");
                int status = SafeNativeMethods.GdipSetStringFormatAlign(new HandleRef(this, nativeFormat), value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        // For English, this is vertical alignment
        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.LineAlignment"]/*' />
        /// <devdoc>
        ///    Gets or sets the line alignment.
        /// </devdoc>
        public StringAlignment LineAlignment {
            get {
                StringAlignment alignment = 0;
                Debug.Assert(nativeFormat != IntPtr.Zero, "NativeFormat is null!");
                int status = SafeNativeMethods.GdipGetStringFormatLineAlign(new HandleRef(this, nativeFormat), out alignment);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return alignment;
            }
            set {
                if (!Enum.IsDefined(typeof(StringAlignment), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(StringAlignment));
                }

                Debug.Assert(nativeFormat != IntPtr.Zero, "NativeFormat is null!");
                int status = SafeNativeMethods.GdipSetStringFormatLineAlign(new HandleRef(this, nativeFormat), value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.HotkeyPrefix"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the <see cref='System.Drawing.StringFormat.HotkeyPrefix'/> for this <see cref='System.Drawing.StringFormat'/> .
        ///    </para>
        /// </devdoc>
        public HotkeyPrefix HotkeyPrefix {
            get {
                HotkeyPrefix hotkeyPrefix;
                Debug.Assert(nativeFormat != IntPtr.Zero, "NativeFormat is null!");
                int status = SafeNativeMethods.GdipGetStringFormatHotkeyPrefix(new HandleRef(this, nativeFormat), out hotkeyPrefix);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return hotkeyPrefix;
            }
            set {
                if (!Enum.IsDefined(typeof(HotkeyPrefix), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(HotkeyPrefix));
                }

                Debug.Assert(nativeFormat != IntPtr.Zero, "NativeFormat is null!");
                int status = SafeNativeMethods.GdipSetStringFormatHotkeyPrefix(new HandleRef(this, nativeFormat), value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.SetTabStops"]/*' />
        /// <devdoc>
        ///    Sets tab stops for this <see cref='System.Drawing.StringFormat'/>.
        /// </devdoc>
        public void SetTabStops(float firstTabOffset, float[] tabStops) {
            if (firstTabOffset < 0)
                throw new ArgumentException(SR.GetString(SR.InvalidArgument, "firstTabOffset", firstTabOffset));

            int status = SafeNativeMethods.GdipSetStringFormatTabStops(new HandleRef(this, nativeFormat), firstTabOffset, tabStops.Length, tabStops);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.GetTabStops"]/*' />
        /// <devdoc>
        ///    Gets the tab stops for this <see cref='System.Drawing.StringFormat'/>.
        /// </devdoc>
        public float [] GetTabStops(out float firstTabOffset) {

            int count = 0;
            int status = SafeNativeMethods.GdipGetStringFormatTabStopCount(new HandleRef(this, nativeFormat), out count);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            float[] tabStops = new float[count];
            status = SafeNativeMethods.GdipGetStringFormatTabStops(new HandleRef(this, nativeFormat), count, out firstTabOffset, tabStops);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return tabStops;
        }


        // String trimming. How to handle more text than can be displayed
        // in the limits available.

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.Trimming"]/*' />
        /// <devdoc>
        ///    Gets or sets the <see cref='System.Drawing.StringTrimming'/>
        ///    for this <see cref='System.Drawing.StringFormat'/>.
        /// </devdoc>
        public StringTrimming Trimming {
            get {
                StringTrimming trimming;
                int status = SafeNativeMethods.GdipGetStringFormatTrimming(new HandleRef(this, nativeFormat), out trimming);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
                return trimming;
            }

            set {
                if (!Enum.IsDefined(typeof(StringTrimming), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(StringTrimming));
                }

                int status = SafeNativeMethods.GdipSetStringFormatTrimming(new HandleRef(this, nativeFormat), value);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);
            }
        }

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.GenericDefault"]/*' />
        /// <devdoc>
        ///    Gets a generic default <see cref='System.Drawing.StringFormat'/>.
        /// </devdoc>
        public static StringFormat GenericDefault {
            get {
                IntPtr format;
                int status = SafeNativeMethods.GdipStringFormatGetGenericDefault(out format);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return new StringFormat(format);
            }
        }

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.GenericTypographic"]/*' />
        /// <devdoc>
        ///    Gets a generic typographic <see cref='System.Drawing.StringFormat'/>.
        /// </devdoc>
        public static StringFormat GenericTypographic {
            get {
                IntPtr format;
                int status = SafeNativeMethods.GdipStringFormatGetGenericTypographic(out format);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return new StringFormat(format);
            }
        }

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.SetDigitSubstitution"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void SetDigitSubstitution(int language, StringDigitSubstitute substitute)
        {
            int status = SafeNativeMethods.GdipSetStringFormatDigitSubstitution(new HandleRef(this, nativeFormat), language, substitute);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.DigitSubstitutionMethod"]/*' />
        /// <devdoc>
        ///    Gets the <see cref='System.Drawing.StringDigitSubstitute'/>
        ///    for this <see cref='System.Drawing.StringFormat'/>.
        /// </devdoc>
        public StringDigitSubstitute DigitSubstitutionMethod {
            get {
                StringDigitSubstitute digitSubstitute;
                int lang = 0;

                int status = SafeNativeMethods.GdipGetStringFormatDigitSubstitution(new HandleRef(this, nativeFormat), out lang, out digitSubstitute);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return digitSubstitute;
            }
        }

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.DigitSubstitutionLanguage"]/*' />
        /// <devdoc>
        ///    Gets the language of <see cref='System.Drawing.StringDigitSubstitute'/>
        ///    for this <see cref='System.Drawing.StringFormat'/>.
        /// </devdoc>
        public int DigitSubstitutionLanguage {
            get {
                StringDigitSubstitute digitSubstitute;
                int language = 0;
                int status = SafeNativeMethods.GdipGetStringFormatDigitSubstitution(new HandleRef(this, nativeFormat), out language, out digitSubstitute);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return language;
            }
        }

        /**
          * Object cleanup
          */
        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.Finalize"]/*' />
        /// <devdoc>
        ///    Cleans up Windows resources for this
        /// <see cref='System.Drawing.StringFormat'/>.
        /// </devdoc>
        ~StringFormat() {
            Dispose(false);
        }

        /// <include file='doc\StringFormat.uex' path='docs/doc[@for="StringFormat.ToString"]/*' />
        /// <devdoc>
        ///    Converts this <see cref='System.Drawing.StringFormat'/> to
        ///    a human-readable string.
        /// </devdoc>
        public override string ToString() {
            return "[StringFormat, FormatFlags=" + FormatFlags.ToString() + "]";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\stringformatflags.cs ===
//------------------------------------------------------------------------------
// <copyright file="StringFormatFlags.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Abstract:
*
*   String format specification for DrawString and text in a wrapper
*
* Revision History:
*
*   1/24/2000 nkramer
*       Created it.
*
\**************************************************************************/

namespace System.Drawing {
    using System;
    
    /// <include file='doc\StringFormatFlags.uex' path='docs/doc[@for="StringFormatFlags"]/*' />
    /// <devdoc>
    ///    Specifies the display and layout
    ///    information for text strings.
    /// </devdoc>
    [Flags()]
    public enum StringFormatFlags {

        /// <include file='doc\StringFormatFlags.uex' path='docs/doc[@for="StringFormatFlags.DirectionRightToLeft"]/*' />
        /// <devdoc>
        ///    Specifies that text is right to left.
        /// </devdoc>
        DirectionRightToLeft        = 0x00000001,
        /// <include file='doc\StringFormatFlags.uex' path='docs/doc[@for="StringFormatFlags.DirectionVertical"]/*' />
        /// <devdoc>
        ///    Specifies that text is vertical.
        /// </devdoc>
        DirectionVertical           = 0x00000002,
        /// <include file='doc\StringFormatFlags.uex' path='docs/doc[@for="StringFormatFlags.FitBlackBox"]/*' />
        /// <devdoc>
        ///    Specifies that no part of any glyph
        ///    overhangs the bounding rectangle. By default some glyphs overhang the rectangle
        ///    slightly where necessary to appear at the edge visually. For example when an
        ///    italic lower case letter f in a font such as Garamond is aligned at the far left
        ///    of a rectangle, the lower part of the f will reach slightly further left than
        ///    the left edge of the rectangle. Setting this flag will ensure no painting
        ///    outside the rectangle but will cause the aligned edges of adjacent lines of text
        ///    to appear uneven.
        /// </devdoc>
        FitBlackBox                 = 0x00000004,
        /// <include file='doc\StringFormatFlags.uex' path='docs/doc[@for="StringFormatFlags.DisplayFormatControl"]/*' />
        /// <devdoc>
        ///    Causes control characters such as the
        ///    left-to-right mark to be shown in the output with a representative glyph.
        /// </devdoc>
        DisplayFormatControl        = 0x00000020,
        /// <include file='doc\StringFormatFlags.uex' path='docs/doc[@for="StringFormatFlags.NoFontFallback"]/*' />
        /// <devdoc>
        ///    Disables fallback to alternate fonts for
        ///    characters not supported in the requested font. Any missing characters are
        ///    displayed with the fonts missing glyph, usually an open square.
        /// </devdoc>
        NoFontFallback              = 0x00000400,
        /// <include file='doc\StringFormatFlags.uex' path='docs/doc[@for="StringFormatFlags.MeasureTrailingSpaces"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MeasureTrailingSpaces       = 0x00000800,
        /// <include file='doc\StringFormatFlags.uex' path='docs/doc[@for="StringFormatFlags.NoWrap"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NoWrap                      = 0x00001000,
        /// <include file='doc\StringFormatFlags.uex' path='docs/doc[@for="StringFormatFlags.LineLimit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        LineLimit                   = 0x00002000,
        /// <include file='doc\StringFormatFlags.uex' path='docs/doc[@for="StringFormatFlags.NoClip"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        NoClip                      = 0x00004000

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\stringtrimming.cs ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   StringTrimming.cs
*
* Abstract:
*
*   StringTrimming constants
*
* Revision History:
*
*  4/10/2000 YungT
*       Created it.
*
\**************************************************************************/

namespace System.Drawing {

    using System.Drawing;
    using System;

    /// <include file='doc\StringTrimming.uex' path='docs/doc[@for="StringTrimming"]/*' />
    /// <devdoc>
    ///    Specifies how to trim characters from a
    ///    string that does not completely fit into a layout shape.
    /// </devdoc>
    public enum StringTrimming
    {
        /// <include file='doc\StringTrimming.uex' path='docs/doc[@for="StringTrimming.None"]/*' />
        /// <devdoc>
        ///    Specifies no trimming.
        /// </devdoc>
        None              = 0,
        /// <include file='doc\StringTrimming.uex' path='docs/doc[@for="StringTrimming.Character"]/*' />
        /// <devdoc>
        ///    Specifies that the text is trimmed to the
        ///    nearest character.
        /// </devdoc>
        Character         = 1,
        /// <include file='doc\StringTrimming.uex' path='docs/doc[@for="StringTrimming.Word"]/*' />
        /// <devdoc>
        ///    Specifies that text is trimmed to the
        ///    nearest word.
        /// </devdoc>
        Word              = 2,
        /// <include file='doc\StringTrimming.uex' path='docs/doc[@for="StringTrimming.EllipsisCharacter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EllipsisCharacter = 3,
        /// <include file='doc\StringTrimming.uex' path='docs/doc[@for="StringTrimming.EllipsisWord"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EllipsisWord      = 4,
        /// <include file='doc\StringTrimming.uex' path='docs/doc[@for="StringTrimming.EllipsisPath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EllipsisPath      = 5
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\systemcolortracker.cs ===
//------------------------------------------------------------------------------
// <copyright file="SystemColorTracker.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Internal {

    using System.Diagnostics;
    using System;
    using System.Drawing;
    using Microsoft.Win32;
    using System.Runtime.InteropServices;
    using System.ComponentModel;

    // Keeps track of objects that need to be notified of system color change events.
    // Mostly this means maintaining a list of weak references.
    internal class SystemColorTracker {
        // when I tried the self host, it went over 500 but never over 1000.
        private static int INITIAL_SIZE = 200;
        // If it gets this big, I seriously miscalculated the performance of this sucker.
        private static int WARNING_SIZE = 100000;
        private static float EXPAND_THRESHOLD = 0.75f;
        private static int EXPAND_FACTOR = 2;

        private static WeakReference[] list = new WeakReference[INITIAL_SIZE];
        private static int count = 0;
        private static bool addedTracker;

        // There's no such thing as a delegate to a static method,
        // so we need to create an instance of something.
        private SystemColorTracker() {
        }

        internal static void Add(ISystemColorTracker obj) {
            lock (typeof(SystemColorTracker)) {
                Debug.Assert(list != null, "List is null");
                Debug.Assert(list.Length > 0, "INITIAL_SIZE was initialized after list");
                
                if (list.Length == count) {
                    GarbageCollectList();
                }
                
                if (!addedTracker) {
                    addedTracker = true;
                    SystemEvents.UserPreferenceChanged += new UserPreferenceChangedEventHandler(OnUserPreferenceChanged);
                }
    
                // Strictly speaking, we should grab a lock on this class.  But since the chances
                // of a problem are so low, the consequences so minimal (something will get accidentally dropped
                // from the list), and the performance of locking so lousy, we'll risk it.
                int index = count;
                count++;
    
                // COM+ takes forever to Finalize() weak references, so it pays to reuse them.
                if (list[index] == null)
                    list[index] = new WeakReference(obj);
                else {
                    Debug.Assert(list[index].Target == null, "Trying to reuse a weak reference that isn't broken yet: list[" + index + "], length =" + list.Length);
                    list[index].Target = obj;
                }
            }
        }

        private static void CleanOutBrokenLinks() {
            // Partition the list -- valid references in the low indices, broken references in the high indices.
            // This is taken straight out of Sedgewick (p. 118 on quicksort).

            // Basic idea is to find a broken reference on the left side of the list, and swap it with
            // a valid reference on the right
            int right = list.Length - 1;
            int left = 0;

            int length = list.Length;

            // Loop invariant: everything to the left of "left" is a valid reference,
            // and anything to the right of "right" is broken.
            for (;;) {
                while (left < length && list[left].Target != null)
                    left++;
                while (right >= 0 && list[right].Target == null)
                    right--;

                if (left >= right) {
                    count = left;
                    break;
                }

                WeakReference temp = list[left];
                list[left] = list[right];
                list[right] = temp;

                left++;
                right--;
            }

            Debug.Assert(count >= 0 && count <= list.Length, "count not a legal index into list");

#if DEBUG
            // Check loop invariant.
            
            // We'd like to assert that any index < count contains a valid pointer,
            // but since garbage collection can happen at any time, it may have been broken
            // after we partitioned it.
            //
            // for (int i = 0; i < count; i++) {
            //     Debug.Assert(list[i].Target != null, "Null found on the left side of the list");
            // }

            for (int i = count; i < list.Length; i++) {
                Debug.Assert(list[i].Target == null, "Partitioning didn't work");
            }
#endif
        }
        
        private static void GarbageCollectList() {
            CleanOutBrokenLinks();

            if (count / (float) list.Length > EXPAND_THRESHOLD) {
                WeakReference[] newList = new WeakReference[list.Length * EXPAND_FACTOR];
                list.CopyTo(newList, 0);
                list = newList;

                if (list.Length >= WARNING_SIZE) {
                    Debug.Fail("SystemColorTracker is using way more memory than expected.");
                }
            }
        }            

        private static void OnUserPreferenceChanged(object sender, UserPreferenceChangedEventArgs e) {

            // Update pens and brushes
            if (e.Category == UserPreferenceCategory.Color) {
                for (int i = 0; i < count; i++) {
                    Debug.Assert(list[i] != null, "null value in active part of list");
                    ISystemColorTracker tracker = (ISystemColorTracker) list[i].Target;
                    if (tracker != null) {
                        // If object still around
                        tracker.OnSystemColorChanged();
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\texturebrush.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextureBrush.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   TextureBrush.cs
*
* Abstract:
*
*   COM+ wrapper for GDI+ TextureBrush Brush objects
*
* Revision History:
*
*   12/15/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.Drawing;    
    using Microsoft.Win32;
    using System.ComponentModel;
    using System.Drawing.Drawing2D;
    using System.Drawing.Internal;
    using System.Drawing.Imaging;
    
    /**
     * Represent a Texture brush object
     */
    /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush"]/*' />
    /// <devdoc>
    ///    Encapsulates a <see cref='System.Drawing.Brush'/> that uses an fills the
    ///    interior of a shape with an image.
    /// </devdoc>
    public sealed class TextureBrush : Brush {
        /**
         * Create a new texture brush object
         *
         * @notes Should the rectangle parameter be Rectangle or RectF?
         *  We'll use Rectangle to specify pixel unit source image
         *  rectangle for now. Eventually, we'll need a mechanism
         *  to specify areas of an image in a resolution-independent way.
         *
         * @notes We'll make a copy of the bitmap object passed in.
         */
         
        internal TextureBrush() { nativeBrush = IntPtr.Zero; }
 
        // When creating a texture brush from a metafile image, the dstRect
        // is used to specify the size that the metafile image should be
        // rendered at in the device units of the destination graphics.
        // It is NOT used to crop the metafile image, so only the width 
        // and height values matter for metafiles.
        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.TextureBrush"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the <see cref='System.Drawing.TextureBrush'/>
        ///    class with the specified image.
        /// </devdoc>
        public TextureBrush(Image bitmap)  
            : this(bitmap, System.Drawing.Drawing2D.WrapMode.Tile) {
        }

        // When creating a texture brush from a metafile image, the dstRect
        // is used to specify the size that the metafile image should be
        // rendered at in the device units of the destination graphics.
        // It is NOT used to crop the metafile image, so only the width 
        // and height values matter for metafiles.
        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.TextureBrush1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.TextureBrush'/>
        ///       class with the specified image and wrap mode.
        ///    </para>
        /// </devdoc>
        public TextureBrush(Image image, WrapMode wrapMode) {
            if (image == null)
                throw new ArgumentNullException("image");
                
            //validate the WrapMode enum
            if (!Enum.IsDefined(typeof(WrapMode), wrapMode)) {
                throw new InvalidEnumArgumentException("wrapMode", (int)wrapMode, typeof(WrapMode));
            }

            IntPtr brush = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateTexture(new HandleRef(image, image.nativeImage),
                                                   (int) wrapMode,
                                                   out brush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeBrush(brush);
        }

        // When creating a texture brush from a metafile image, the dstRect
        // is used to specify the size that the metafile image should be
        // rendered at in the device units of the destination graphics.
        // It is NOT used to crop the metafile image, so only the width 
        // and height values matter for metafiles.
        // float version
        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.TextureBrush2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.TextureBrush'/>
        ///       class with the specified image, wrap mode, and bounding rectangle.
        ///    </para>
        /// </devdoc>
        public TextureBrush(Image image, WrapMode wrapMode, RectangleF dstRect) {
            if (image == null)
                throw new ArgumentNullException("image");
            
            //validate the WrapMode enum
            if (!Enum.IsDefined(typeof(WrapMode), wrapMode)) {
                throw new InvalidEnumArgumentException("wrapMode", (int)wrapMode, typeof(WrapMode));
            }
            
            IntPtr brush = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateTexture2(new HandleRef(image, image.nativeImage),
                                                    (int) wrapMode,
                                                    dstRect.X,
                                                    dstRect.Y,
                                                    dstRect.Width,
                                                    dstRect.Height,
                                                    out brush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeBrush(brush);
        }

        // int version
        // When creating a texture brush from a metafile image, the dstRect
        // is used to specify the size that the metafile image should be
        // rendered at in the device units of the destination graphics.
        // It is NOT used to crop the metafile image, so only the width 
        // and height values matter for metafiles.
        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.TextureBrush3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.TextureBrush'/>
        ///       class with the specified image, wrap mode, and bounding rectangle.
        ///    </para>
        /// </devdoc>
        public TextureBrush(Image image, WrapMode wrapMode, Rectangle dstRect) {
            if (image == null)
                throw new ArgumentNullException("image");
            
            //validate the WrapMode enum
            if (!Enum.IsDefined(typeof(WrapMode), wrapMode)) {
                throw new InvalidEnumArgumentException("wrapMode", (int)wrapMode, typeof(WrapMode));
            }
            
            IntPtr brush = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateTexture2I(new HandleRef(image, image.nativeImage),
                                                     (int) wrapMode,
                                                     dstRect.X,
                                                     dstRect.Y,
                                                     dstRect.Width,
                                                     dstRect.Height,
                                                     out brush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeBrush(brush);
        }


        // When creating a texture brush from a metafile image, the dstRect
        // is used to specify the size that the metafile image should be
        // rendered at in the device units of the destination graphics.
        // It is NOT used to crop the metafile image, so only the width 
        // and height values matter for metafiles.
        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.TextureBrush4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.TextureBrush'/> class with the specified image
        ///       and bounding rectangle.
        ///    </para>
        /// </devdoc>
        public TextureBrush(Image image, RectangleF dstRect)
        : this(image, dstRect, (ImageAttributes)null) {}
         
        // When creating a texture brush from a metafile image, the dstRect
        // is used to specify the size that the metafile image should be
        // rendered at in the device units of the destination graphics.
        // It is NOT used to crop the metafile image, so only the width 
        // and height values matter for metafiles.
        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.TextureBrush5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.TextureBrush'/> class with the specified
        ///       image, bounding rectangle, and image attributes.
        ///    </para>
        /// </devdoc>
        public TextureBrush(Image image, RectangleF dstRect,
                            ImageAttributes imageAttr)
        {
            if (image == null)
                throw new ArgumentNullException("image");
            
            IntPtr brush = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateTextureIA(new HandleRef(image, image.nativeImage),
                                                     new HandleRef(imageAttr, (imageAttr == null) ? 
                                                       IntPtr.Zero : imageAttr.nativeImageAttributes),
                                                     dstRect.X,
                                                     dstRect.Y,
                                                     dstRect.Width,
                                                     dstRect.Height,
                                                     out brush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeBrush(brush);
        }

        // When creating a texture brush from a metafile image, the dstRect
        // is used to specify the size that the metafile image should be
        // rendered at in the device units of the destination graphics.
        // It is NOT used to crop the metafile image, so only the width 
        // and height values matter for metafiles.
        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.TextureBrush6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.TextureBrush'/> class with the specified image
        ///       and bounding rectangle.
        ///    </para>
        /// </devdoc>
        public TextureBrush(Image image, Rectangle dstRect)
        : this(image, dstRect, (ImageAttributes)null) {}
         
        // When creating a texture brush from a metafile image, the dstRect
        // is used to specify the size that the metafile image should be
        // rendered at in the device units of the destination graphics.
        // It is NOT used to crop the metafile image, so only the width 
        // and height values matter for metafiles.
        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.TextureBrush7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.TextureBrush'/> class with the specified
        ///       image, bounding rectangle, and image attributes.
        ///    </para>
        /// </devdoc>
        public TextureBrush(Image image, Rectangle dstRect,
                            ImageAttributes imageAttr)
        {
            if (image == null)
                throw new ArgumentNullException("image");
            
            IntPtr brush = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCreateTextureIAI(new HandleRef(image, image.nativeImage),
                                                     new HandleRef(imageAttr, (imageAttr == null) ? 
                                                       IntPtr.Zero : imageAttr.nativeImageAttributes),
                                                     dstRect.X,
                                                     dstRect.Y,
                                                     dstRect.Width,
                                                     dstRect.Height,
                                                     out brush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            SetNativeBrush(brush);
        }
        
        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.Clone"]/*' />
        /// <devdoc>
        ///    Creates an exact copy of this <see cref='System.Drawing.TextureBrush'/>.
        /// </devdoc>
        public override Object Clone() {
            IntPtr cloneBrush = IntPtr.Zero;

            int status = SafeNativeMethods.GdipCloneBrush(new HandleRef(this, nativeBrush), out cloneBrush);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return new TextureBrush(cloneBrush);
        }

        private TextureBrush(IntPtr nativeBrush) {
            SetNativeBrush(nativeBrush);
        }

        /**
         * Set/get brush transform
         */
        private void _SetTransform(Matrix matrix) {
            int status = SafeNativeMethods.GdipSetTextureTransform(new HandleRef(this, nativeBrush), new HandleRef(matrix, matrix.nativeMatrix));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        private Matrix _GetTransform() {
            Matrix matrix = new Matrix();
                        
            int status = SafeNativeMethods.GdipGetTextureTransform(new HandleRef(this, nativeBrush), new HandleRef(matrix, matrix.nativeMatrix));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return matrix;
        }

        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.Transform"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a <see cref='System.Drawing.Drawing2D.Matrix'/> that defines a local geometrical
        ///       transform for this <see cref='System.Drawing.TextureBrush'/>.
        ///    </para>
        /// </devdoc>
        public Matrix Transform
        {
            get { return _GetTransform();}
            set {
                if (value == null) {
                    throw new ArgumentNullException("value");
                }

                _SetTransform(value);
            }
        }

        /**
         * Set/get brush wrapping mode
         */
        private void _SetWrapMode(WrapMode wrapMode) {
            int status = SafeNativeMethods.GdipSetTextureWrapMode(new HandleRef(this, nativeBrush), (int) wrapMode);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        private WrapMode _GetWrapMode() {
            int mode = 0;

            int status = SafeNativeMethods.GdipGetTextureWrapMode(new HandleRef(this, nativeBrush), out mode);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);

            return(WrapMode) mode;
        }

        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.WrapMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a <see cref='System.Drawing.Drawing2D.WrapMode'/> that indicates the wrap mode for this
        ///    <see cref='System.Drawing.TextureBrush'/>. 
        ///    </para>
        /// </devdoc>
        public WrapMode WrapMode
        {
            get {
                return _GetWrapMode();
            }
            set {
                //validate the WrapMode enum
                if (!Enum.IsDefined(typeof(WrapMode), value)) {
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(WrapMode));
                }

                _SetWrapMode(value);
            }
        }

        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.Image"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the <see cref='System.Drawing.Image'/> associated with this <see cref='System.Drawing.TextureBrush'/>.
        ///    </para>
        /// </devdoc>
        public Image Image {
            get {
                IntPtr image;
                
                int status = SafeNativeMethods.GdipGetTextureImage(new HandleRef(this, nativeBrush), out image);

                if (status != SafeNativeMethods.Ok)
                    throw SafeNativeMethods.StatusException(status);

                return Image.CreateImageObject(image);
            }
        }
        
        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.ResetTransform"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Resets the <see cref='System.Drawing.Drawing2D.LinearGradientBrush.Transform'/> property to
        ///       identity.
        ///    </para>
        /// </devdoc>
        public void ResetTransform()
        {
            int status = SafeNativeMethods.GdipResetTextureTransform(new HandleRef(this, nativeBrush));

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
        
        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.MultiplyTransform"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Multiplies the <see cref='System.Drawing.Drawing2D.Matrix'/> that represents the local geometrical
        ///       transform of this <see cref='System.Drawing.TextureBrush'/> by the specified <see cref='System.Drawing.Drawing2D.Matrix'/> by prepending the specified <see cref='System.Drawing.Drawing2D.Matrix'/>.
        ///    </para>
        /// </devdoc>
        public void MultiplyTransform(Matrix matrix)
        { MultiplyTransform(matrix, MatrixOrder.Prepend); }
        
        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.MultiplyTransform1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Multiplies the <see cref='System.Drawing.Drawing2D.Matrix'/> that represents the local geometrical
        ///       transform of this <see cref='System.Drawing.TextureBrush'/> by the specified <see cref='System.Drawing.Drawing2D.Matrix'/> in the specified order.
        ///    </para>
        /// </devdoc>
        public void MultiplyTransform(Matrix matrix, MatrixOrder order)
        {
            if (matrix == null) {
                throw new ArgumentNullException("matrix");
            }

            int status = SafeNativeMethods.GdipMultiplyTextureTransform(new HandleRef(this, nativeBrush),
                                                              new HandleRef(matrix, matrix.nativeMatrix),
                                                              order);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.TranslateTransform"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Translates the local geometrical transform by the specified dimmensions. This
        ///       method prepends the translation to the transform.
        ///    </para>
        /// </devdoc>
        public void TranslateTransform(float dx, float dy)
        { TranslateTransform(dx, dy, MatrixOrder.Prepend); }
                
        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.TranslateTransform1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Translates the local geometrical transform by the specified dimmensions in
        ///       the specified order.
        ///    </para>
        /// </devdoc>
        public void TranslateTransform(float dx, float dy, MatrixOrder order)
        {
            int status = SafeNativeMethods.GdipTranslateTextureTransform(new HandleRef(this, nativeBrush),
                                                               dx, 
                                                               dy,
                                                               order);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
        
        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.ScaleTransform"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Scales the local geometric transform by the specified amounts. This method
        ///       prepends the scaling matrix to the transform.
        ///    </para>
        /// </devdoc>
        public void ScaleTransform(float sx, float sy)
        { ScaleTransform(sx, sy, MatrixOrder.Prepend); }
                
        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.ScaleTransform1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Scales the local geometric transform by the specified amounts in the
        ///       specified order.
        ///    </para>
        /// </devdoc>
        public void ScaleTransform(float sx, float sy, MatrixOrder order)
        {
            int status = SafeNativeMethods.GdipScaleTextureTransform(new HandleRef(this, nativeBrush),
                                                           sx, 
                                                           sy,
                                                           order);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }

        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.RotateTransform"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Rotates the local geometric transform by the specified amount. This method
        ///       prepends the rotation to the transform.
        ///    </para>
        /// </devdoc>
        public void RotateTransform(float angle)
        { RotateTransform(angle, MatrixOrder.Prepend); }
                
        /// <include file='doc\TextureBrush.uex' path='docs/doc[@for="TextureBrush.RotateTransform1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Rotates the local geometric transform by the specified amount in the
        ///       specified order.
        ///    </para>
        /// </devdoc>
        public void RotateTransform(float angle, MatrixOrder order)
        {
            int status = SafeNativeMethods.GdipRotateTextureTransform(new HandleRef(this, nativeBrush),
                                                            angle,
                                                            order);

            if (status != SafeNativeMethods.Ok)
                throw SafeNativeMethods.StatusException(status);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\textrenderinghint.cs ===
//------------------------------------------------------------------------------
// <copyright file="TextRenderingHint.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   TextRenderingMode.cs
*
* Abstract:
*
*   Text Rendering mode constants
*
* Revision History:
*
*   3/1/2000 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Text {

    using System.Drawing;
    using System;

    /// <include file='doc\TextRenderingHint.uex' path='docs/doc[@for="TextRenderingHint"]/*' />
    /// <devdoc>
    ///    Specifies the quality of text rendering.
    /// </devdoc>
    public enum TextRenderingHint
    {
            /// <include file='doc\TextRenderingHint.uex' path='docs/doc[@for="TextRenderingHint.SystemDefault"]/*' />
            /// <devdoc>
            ///    <para>[To be supplied.]</para>
            /// </devdoc>
            SystemDefault = 0,        // Glyph with system default rendering hint
        /// <include file='doc\TextRenderingHint.uex' path='docs/doc[@for="TextRenderingHint.SingleBitPerPixelGridFit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SingleBitPerPixelGridFit, // Glyph bitmap with hinting
        /// <include file='doc\TextRenderingHint.uex' path='docs/doc[@for="TextRenderingHint.SingleBitPerPixel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        SingleBitPerPixel,        // Glyph bitmap without hinting
        /// <include file='doc\TextRenderingHint.uex' path='docs/doc[@for="TextRenderingHint.AntiAliasGridFit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        AntiAliasGridFit,         //Anti-aliasing with hinting
        /// <include file='doc\TextRenderingHint.uex' path='docs/doc[@for="TextRenderingHint.AntiAlias"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        AntiAlias,                // Glyph anti-alias bitmap without hinting
        // Glyph anti-alias bitmap without hinting  
        /// <include file='doc\TextRenderingHint.uex' path='docs/doc[@for="TextRenderingHint.ClearTypeGridFit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ClearTypeGridFit          // Glyph CT bitmap with hinting
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\stringunit.cs ===
/**************************************************************************\
*
* Copyright (c) 1998-2000, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   StringUnit.cs
*
* Abstract:
*
*   StringUnit constants
*
* Revision History:
*
*  4/10/2000 YungT
*       Created it.
*
\**************************************************************************/

namespace System.Drawing {

    using System.Drawing;
    using System;

    /**
     * used for both vertical and horizontal alignment.
     */
    /// <include file='doc\StringUnit.uex' path='docs/doc[@for="StringUnit"]/*' />
    /// <devdoc>
    ///    Specifies the units of measure for a text
    ///    string.
    /// </devdoc>
    public enum StringUnit
    {
        /// <include file='doc\StringUnit.uex' path='docs/doc[@for="StringUnit.World"]/*' />
        /// <devdoc>
        ///    Specifies world units as the unit of
        ///    measure.
        /// </devdoc>
        World        = GraphicsUnit.World,
        /// <include file='doc\StringUnit.uex' path='docs/doc[@for="StringUnit.Display"]/*' />
        /// <devdoc>
        ///    Specifies the device unit as the unit of
        ///    measure.
        /// </devdoc>
        Display      = GraphicsUnit.Display,
        /// <include file='doc\StringUnit.uex' path='docs/doc[@for="StringUnit.Pixel"]/*' />
        /// <devdoc>
        ///    Specifies a pixel as the unit of measure.
        /// </devdoc>
        Pixel        = GraphicsUnit.Pixel,
        /// <include file='doc\StringUnit.uex' path='docs/doc[@for="StringUnit.Point"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies a printer's point as the unit of measure.
        ///    </para>
        /// </devdoc>
        Point        = GraphicsUnit.Point,
        /// <include file='doc\StringUnit.uex' path='docs/doc[@for="StringUnit.Inch"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies an inch as the unit of measure.
        ///    </para>
        /// </devdoc>
        Inch         = GraphicsUnit.Inch,
        /// <include file='doc\StringUnit.uex' path='docs/doc[@for="StringUnit.Document"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies 1/300 of an inch as the unit of measure.
        ///    </para>
        /// </devdoc>
        Document     = GraphicsUnit.Document,
        /// <include file='doc\StringUnit.uex' path='docs/doc[@for="StringUnit.Millimeter"]/*' />
        /// <devdoc>
        ///    Specifies a millimeter as the unit of
        ///    measure
        /// </devdoc>
        Millimeter   = GraphicsUnit.Millimeter,
        /// <include file='doc\StringUnit.uex' path='docs/doc[@for="StringUnit.Em"]/*' />
        /// <devdoc>
        ///    Specifies a printer's em size of 32 as the
        ///    unit of measure.
        /// </devdoc>
        Em           = 32
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\unit.cs ===
//------------------------------------------------------------------------------
// <copyright file="Unit.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   Unit.cs
*
* Abstract:
*
*   Unit constant types
*
* Revision History:
*
*   12/14/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /// <include file='doc\Unit.uex' path='docs/doc[@for="GraphicsUnit"]/*' />
    /// <devdoc>
    ///    Specifies the unit of measure for the given
    ///    data.
    /// </devdoc>
    public enum GraphicsUnit
    {
        /// <include file='doc\Unit.uex' path='docs/doc[@for="GraphicsUnit.World"]/*' />
        /// <devdoc>
        ///    Specifies the world unit as the unit of
        ///    measure.
        /// </devdoc>
        World = 0 ,     // 0 -- World coordinate (non-physical unit)
        /// <include file='doc\Unit.uex' path='docs/doc[@for="GraphicsUnit.Display"]/*' />
        /// <devdoc>
        ///    Specifies 1/75 inch as the unit of measure.
        /// </devdoc>
        Display = 1,    // 1 -- Variable - for PageTransform only
        /// <include file='doc\Unit.uex' path='docs/doc[@for="GraphicsUnit.Pixel"]/*' />
        /// <devdoc>
        ///    Specifies a device pixel as the unit of
        ///    measure.
        /// </devdoc>
        Pixel = 2,      // 2 -- Each unit is one device pixel.
        /// <include file='doc\Unit.uex' path='docs/doc[@for="GraphicsUnit.Point"]/*' />
        /// <devdoc>
        ///    Specifies a printer's point (1/72 inch) as
        ///    the unit of measure.
        /// </devdoc>
        Point = 3,      // 3 -- Each unit is a printer's point, or 1/72 inch.
        /// <include file='doc\Unit.uex' path='docs/doc[@for="GraphicsUnit.Inch"]/*' />
        /// <devdoc>
        ///    Specifies the inch as the unit of measure.
        /// </devdoc>
        Inch = 4,       // 4 -- Each unit is 1 inch.
        /// <include file='doc\Unit.uex' path='docs/doc[@for="GraphicsUnit.Document"]/*' />
        /// <devdoc>
        ///    Specifes the document unit (1/300 inch) as
        ///    the unit of measure.
        /// </devdoc>
        Document = 5,   // 5 -- Each unit is 1/300 inch.
        /// <include file='doc\Unit.uex' path='docs/doc[@for="GraphicsUnit.Millimeter"]/*' />
        /// <devdoc>
        ///    Specifies the millimeter as the unit of
        ///    measure.
        /// </devdoc>
        Millimeter = 6  // 6 -- Each unit is 1 millimeter.
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\warpmode.cs ===
//------------------------------------------------------------------------------
// <copyright file="WarpMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   WarpMode.cs
*
* Abstract:
*
*   Warpping modes
*
* Revision History:
*
*   12/16/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /**
     * Various wrap modes for brushes
     */
    /// <include file='doc\WarpMode.uex' path='docs/doc[@for="WarpMode"]/*' />
    /// <devdoc>
    ///    Specifies the warp style.
    /// </devdoc>
    public enum WarpMode
    {
        /// <include file='doc\WarpMode.uex' path='docs/doc[@for="WarpMode.Perspective"]/*' />
        /// <devdoc>
        ///    Specifies a perspective warp.
        /// </devdoc>
        Perspective = 0,
        /// <include file='doc\WarpMode.uex' path='docs/doc[@for="WarpMode.Bilinear"]/*' />
        /// <devdoc>
        ///    Specifies a bilinear warp.
        /// </devdoc>
        Bilinear = 1
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\wmfplaceablefileheader.cs ===
//------------------------------------------------------------------------------
// <copyright file="WmfPlaceableFileHeader.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   WmfPlaceableFileHeader.cs
*
* Abstract:
*
*   Native GDI+ WmfPlaceableFileHeader structure.
*
* Revision History:
*
*   10/21/1999 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Imaging {

    using System.Diagnostics;

    using System;
    using System.Drawing;
    using System.Runtime.InteropServices;

    /// <include file='doc\WmfPlaceableFileHeader.uex' path='docs/doc[@for="WmfPlaceableFileHeader"]/*' />
    /// <devdoc>
    ///    Defines an Placeable Metafile.
    /// </devdoc>
    [StructLayout(LayoutKind.Sequential)]
    public sealed class WmfPlaceableFileHeader {
        int key = unchecked((int)0x9aC6CDD7);
        short hmf;
        short bboxLeft;
        short bboxTop;
        short bboxRight;
        short bboxBottom;
        short inch;
        int reserved = 0;
        short checksum;
         
        /// <include file='doc\WmfPlaceableFileHeader.uex' path='docs/doc[@for="WmfPlaceableFileHeader.Key"]/*' />
        /// <devdoc>
        ///    Indicates the presence of a placeable
        ///    metafile header.
        /// </devdoc>
        public int Key {
            get { return key; }
            set { key = value; }
        }

        /// <include file='doc\WmfPlaceableFileHeader.uex' path='docs/doc[@for="WmfPlaceableFileHeader.Hmf"]/*' />
        /// <devdoc>
        ///    Stores the handle of the metafile in
        ///    memory.
        /// </devdoc>
        public short Hmf {
            get { return hmf; }
            set { hmf = value; }
        }

        /// <include file='doc\WmfPlaceableFileHeader.uex' path='docs/doc[@for="WmfPlaceableFileHeader.BboxLeft"]/*' />
        /// <devdoc>
        ///    The x-coordinate of the upper-left corner
        ///    of the bounding rectangle of the metafile image on the output device.
        /// </devdoc>
        public short BboxLeft {
            get { return bboxLeft; }
            set { bboxLeft = value; }
        }

        /// <include file='doc\WmfPlaceableFileHeader.uex' path='docs/doc[@for="WmfPlaceableFileHeader.BboxTop"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The y-coordinate of the upper-left corner of the bounding rectangle of the
        ///       metafile image on the output device.
        ///    </para>
        /// </devdoc>
        public short BboxTop {
            get { return bboxTop; }
            set { bboxTop = value; }
        }

        /// <include file='doc\WmfPlaceableFileHeader.uex' path='docs/doc[@for="WmfPlaceableFileHeader.BboxRight"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The x-coordinate of the lower-right corner of the bounding rectangle of the
        ///       metafile image on the output device.
        ///    </para>
        /// </devdoc>
        public short BboxRight {
            get { return bboxRight; }
            set { bboxRight = value; }
        }
        
        /// <include file='doc\WmfPlaceableFileHeader.uex' path='docs/doc[@for="WmfPlaceableFileHeader.BboxBottom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The y-coordinate of the lower-right corner of the bounding rectangle of the
        ///       metafile image on the output device.
        ///    </para>
        /// </devdoc>
        public short BboxBottom {
            get { return bboxBottom; }
            set { bboxBottom = value; }
        }

        /// <include file='doc\WmfPlaceableFileHeader.uex' path='docs/doc[@for="WmfPlaceableFileHeader.Inch"]/*' />
        /// <devdoc>
        ///    Indicates the number of twips per inch.
        /// </devdoc>
        public short Inch {
            get { return inch; }
            set { inch = value; }
        }

        /// <include file='doc\WmfPlaceableFileHeader.uex' path='docs/doc[@for="WmfPlaceableFileHeader.Reserved"]/*' />
        /// <devdoc>
        ///    Reserved. Do not use.
        /// </devdoc>
        public int Reserved {
            get { return reserved; }
            set { reserved = value; }
        }

        /// <include file='doc\WmfPlaceableFileHeader.uex' path='docs/doc[@for="WmfPlaceableFileHeader.Checksum"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates the checksum value for the
        ///       previous ten WORDs in the header.
        ///    </para>
        /// </devdoc>
        public short Checksum {
            get { return checksum; }
            set { checksum = value; }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\design\itoolboxuser.cs ===
//------------------------------------------------------------------------------
// <copyright file="IToolboxUser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing.Design {

    using System.Diagnostics;

    /// <include file='doc\IToolboxUser.uex' path='docs/doc[@for="IToolboxUser"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides notifications of toolbox actions
    ///       to designers which implement this interface.
    ///    </para>
    /// </devdoc>
    public interface IToolboxUser {
        /// <include file='doc\IToolboxUser.uex' path='docs/doc[@for="IToolboxUser.GetToolSupported"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the specified tool is supported by the current
        ///       designer.</para>
        /// </devdoc>

 
        //
        bool GetToolSupported(ToolboxItem tool);

        /// <include file='doc\IToolboxUser.uex' path='docs/doc[@for="IToolboxUser.ToolPicked"]/*' />
        /// <devdoc>
        ///    <para>Selects the specified tool.</para>
        /// </devdoc>
        void ToolPicked(ToolboxItem tool);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\design\ipropertyvalueuiservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IPropertyValueUIService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing.Design {

    using System.Diagnostics;

    using Microsoft.Win32;
    using System.Drawing.Design;
    using System.Collections;
    using System.ComponentModel;

    /// <include file='doc\IPropertyValueUIService.uex' path='docs/doc[@for="IPropertyValueUIService"]/*' />
    /// <devdoc>
    ///    <para>Provides an interface to manage the property list of 
    ///       the properties window. <see cref='System.Drawing.Design.IPropertyValueUIService'/> provides
    ///       methods that may
    ///       be used to add and remove UI components from the properties window, and to retrieve the UI components for a specific property listed in the property
    ///       browser.</para>
    /// </devdoc>
    public interface IPropertyValueUIService {
    
         /// <include file='doc\IPropertyValueUIService.uex' path='docs/doc[@for="IPropertyValueUIService.PropertyUIValueItemsChanged"]/*' />
         /// <devdoc>
         /// <para>
         ///  Adds or removes an <see cref='System.EventHandler'/> that will be invoked
         ///  when the global list of PropertyValueUIItems is modified.
         ///  </para>
         ///  </devdoc>
         event EventHandler PropertyUIValueItemsChanged;
    
         /// <include file='doc\IPropertyValueUIService.uex' path='docs/doc[@for="IPropertyValueUIService.AddPropertyValueUIHandler"]/*' />
         /// <devdoc>
         ///    <para>
         ///       Adds a <see cref='System.Drawing.Design.PropertyValueUIHandler'/>
         ///       to this service.
         ///    </para>
         /// </devdoc>
         void AddPropertyValueUIHandler(PropertyValueUIHandler newHandler);
    
         /// <include file='doc\IPropertyValueUIService.uex' path='docs/doc[@for="IPropertyValueUIService.GetPropertyUIValueItems"]/*' />
         /// <devdoc>
         /// <para>Gets all the <see cref='System.Drawing.Design.PropertyValueUIItem'/>
         /// objects that should be displayed on the specified property.</para>
         /// </devdoc>
         PropertyValueUIItem[] GetPropertyUIValueItems(ITypeDescriptorContext context, PropertyDescriptor propDesc);
         
         /// <include file='doc\IPropertyValueUIService.uex' path='docs/doc[@for="IPropertyValueUIService.NotifyPropertyValueUIItemsChanged"]/*' />
         /// <devdoc>
         /// <para>
         ///  Tell the IPropertyValueUIService implementation that the global list of PropertyValueUIItems has been modified.
         ///  </para>
         ///  </devdoc>
         void NotifyPropertyValueUIItemsChanged();
         
         /// <include file='doc\IPropertyValueUIService.uex' path='docs/doc[@for="IPropertyValueUIService.RemovePropertyValueUIHandler"]/*' />
         /// <devdoc>
         /// <para>Removes a <see cref='System.Drawing.Design.PropertyValueUIHandler'/>
         /// from this service.</para>
         /// </devdoc>
         void RemovePropertyValueUIHandler(PropertyValueUIHandler newHandler);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\advanced\wrapmode.cs ===
//------------------------------------------------------------------------------
// <copyright file="WrapMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/**************************************************************************\
*
* Copyright (c) 1998-1999, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   WrapMode.cs
*
* Abstract:
*
*   Wrapping modes for brushes
*
* Revision History:
*
*   12/16/1998 ericvan
*       Created it.
*
\**************************************************************************/

namespace System.Drawing.Drawing2D {

    using System.Diagnostics;

    using System.Drawing;
    using System;

    /**
     * Various wrap modes for brushes
     */
    /// <include file='doc\WrapMode.uex' path='docs/doc[@for="WrapMode"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies how a texture or gradient is tiled when it is
    ///       larger than the area being filled.
    ///    </para>
    /// </devdoc>
    public enum WrapMode
    {
        /// <include file='doc\WrapMode.uex' path='docs/doc[@for="WrapMode.Tile"]/*' />
        /// <devdoc>
        ///    Tiles the gradient or texture.
        /// </devdoc>
        Tile = 0,
        /// <include file='doc\WrapMode.uex' path='docs/doc[@for="WrapMode.TileFlipX"]/*' />
        /// <devdoc>
        ///    Reverses the texture or gradient
        ///    horizontally and then tiles the texture or gradient.
        /// </devdoc>
        TileFlipX = 1,
        /// <include file='doc\WrapMode.uex' path='docs/doc[@for="WrapMode.TileFlipY"]/*' />
        /// <devdoc>
        ///    Reverses the texture or
        ///    gradient vertically and then tiles the texture or gradient.
        /// </devdoc>
        TileFlipY = 2,
        /// <include file='doc\WrapMode.uex' path='docs/doc[@for="WrapMode.TileFlipXY"]/*' />
        /// <devdoc>
        ///    Reverses the texture or gradient
        ///    horizontally and vertically and then tiles the texture or gradient.
        /// </devdoc>
        TileFlipXY = 3,
        /// <include file='doc\WrapMode.uex' path='docs/doc[@for="WrapMode.Clamp"]/*' />
        /// <devdoc>
        ///    Clamps the texture or gradient to the
        ///    object boundary.
        /// </devdoc>
        Clamp = 4
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\design\itoolboxservice.cs ===
//------------------------------------------------------------------------------
// <copyright file="IToolboxService.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing.Design {

    using System;
    using System.Collections;
    using System.ComponentModel.Design;
    using System.Runtime.InteropServices;

    /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Provides access to the toolbox in the development environment.</para>
    /// </devdoc>
    [ComImport(), Guid("4BACD258-DE64-4048-BC4E-FEDBEF9ACB76"), InterfaceTypeAttribute(ComInterfaceType.InterfaceIsIUnknown)]
    public interface IToolboxService {
    
        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.CategoryNames"]/*' />
        /// <devdoc>
        ///    <para>Gets the names of all the tool categories currently on the toolbox.</para>
        /// </devdoc>
        CategoryNameCollection CategoryNames { get; }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.SelectedCategory"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of the currently selected tool category from the toolbox.</para>
        /// </devdoc>
        string SelectedCategory { get; set; }

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.AddCreator"]/*' />
        /// <devdoc>
        ///    <para>Adds a new toolbox item creator.</para>
        /// </devdoc>
        void AddCreator(ToolboxItemCreatorCallback creator, string format);

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.AddCreator1"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Adds a new toolbox
        ///       item creator.</para>
        /// </devdoc>
        void AddCreator(ToolboxItemCreatorCallback creator, string format, IDesignerHost host);

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.AddLinkedToolboxItem"]/*' />
        /// <devdoc>
        ///    <para>Adds a new tool to the toolbox under the default category.</para>
        /// </devdoc>
        void AddLinkedToolboxItem(ToolboxItem toolboxItem, IDesignerHost host);

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.AddLinkedToolboxItem1"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Adds a
        ///       new tool to the toolbox under the specified category.</para>
        /// </devdoc>
        void AddLinkedToolboxItem(ToolboxItem toolboxItem, string category, IDesignerHost host);

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.AddToolboxItem"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Adds a new tool
        ///       to the toolbox under the default category.</para>
        /// </devdoc>
        void AddToolboxItem(ToolboxItem toolboxItem);

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.AddToolboxItem1"]/*' />
        /// <devdoc>
        ///    <para>Adds a new tool to the toolbox under the specified category.</para>
        /// </devdoc>
        void AddToolboxItem(ToolboxItem toolboxItem, string category);

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.DeserializeToolboxItem"]/*' />
        /// <devdoc>
        ///    <para>Gets a toolbox item from a previously serialized object.</para>
        /// </devdoc>
        ToolboxItem DeserializeToolboxItem(object serializedObject);

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.DeserializeToolboxItem1"]/*' />
        /// <devdoc>
        ///    <para>Gets a toolbox item from a previously serialized object.</para>
        /// </devdoc>
        ToolboxItem DeserializeToolboxItem(object serializedObject, IDesignerHost host);

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.GetSelectedToolboxItem"]/*' />
        /// <devdoc>
        ///    <para>Gets the currently selected tool.</para>
        /// </devdoc>
        ToolboxItem GetSelectedToolboxItem();

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.GetSelectedToolboxItem1"]/*' />
        /// <devdoc>
        ///    <para>Gets the currently selected tool.</para>
        /// </devdoc>
        ToolboxItem GetSelectedToolboxItem(IDesignerHost host);

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.GetToolboxItems"]/*' />
        /// <devdoc>
        ///    <para>Gets all .NET Framework tools on the toolbox.</para>
        /// </devdoc>
        ToolboxItemCollection GetToolboxItems();

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.GetToolboxItems1"]/*' />
        /// <devdoc>
        ///    <para>Gets all .NET Framework tools on the toolbox.</para>
        /// </devdoc>
        ToolboxItemCollection GetToolboxItems(IDesignerHost host);

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.GetToolboxItems2"]/*' />
        /// <devdoc>
        ///    <para>Gets all .NET Framework tools on the specified toolbox category.</para>
        /// </devdoc>
        ToolboxItemCollection GetToolboxItems(String category);

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.GetToolboxItems3"]/*' />
        /// <devdoc>
        ///    <para>Gets all .NET Framework tools on the specified toolbox category.</para>
        /// </devdoc>
        ToolboxItemCollection GetToolboxItems(String category, IDesignerHost host);
        
        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.IsSupported"]/*' />
        /// <devdoc>
        ///     Determines if the given designer host contains a designer that supports the serialized
        ///     toolbox item.  This will return false if the designer doesn't support the item, or if the
        ///     serializedObject parameter does not contain a toolbox item.
        /// </devdoc>
        bool IsSupported(object serializedObject, IDesignerHost host);
        
        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.IsSupported1"]/*' />
        /// <devdoc>
        ///     Determines if the serialized toolbox item contains a matching collection of filter attributes.
        ///     This will return false if the serializedObject parameter doesn't contain a toolbox item,
        ///     or if the collection of filter attributes does not match.
        /// </devdoc>
        bool IsSupported(object serializedObject, ICollection filterAttributes);

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.IsToolboxItem"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the specified object contains a serialized toolbox item.</para>
        /// </devdoc>
        bool IsToolboxItem(object serializedObject);

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.IsToolboxItem1"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the specified object contains a serialized toolbox item.</para>
        /// </devdoc>
        bool IsToolboxItem(object serializedObject, IDesignerHost host);

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.Refresh"]/*' />
        /// <devdoc>
        ///    <para> Refreshes the state of the toolbox items.</para>
        /// </devdoc>
        void Refresh();

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.RemoveCreator"]/*' />
        /// <devdoc>
        ///    <para>Removes a previously added toolbox creator.</para>
        /// </devdoc>
        void RemoveCreator(string format);
        
        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.RemoveCreator1"]/*' />
        /// <devdoc>
        ///      Removes a previously added toolbox creator.
        /// </devdoc>
        void RemoveCreator(string format, IDesignerHost host);
        
        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.RemoveToolboxItem"]/*' />
        /// <devdoc>
        ///    <para>Removes the specified tool from the toolbox.</para>
        /// </devdoc>
        void RemoveToolboxItem(ToolboxItem toolboxItem);

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.RemoveToolboxItem1"]/*' />
        /// <devdoc>
        ///    <para>Removes the specified tool from the toolbox.</para>
        /// </devdoc>
        void RemoveToolboxItem(ToolboxItem toolboxItem, string category);

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.SelectedToolboxItemUsed"]/*' />
        /// <devdoc>
        ///    <para>Notifies the toolbox that the selected tool has been used.</para>
        /// </devdoc>
        void SelectedToolboxItemUsed();

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.SerializeToolboxItem"]/*' />
        /// <devdoc>
        ///     Takes the given toolbox item and serializes it to a persistent object.  This object can then
        ///     be stored in a stream or passed around in a drag and drop or clipboard operation.
        /// </devdoc>
        object SerializeToolboxItem(ToolboxItem toolboxItem);

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.SetCursor"]/*' />
        /// <devdoc>
        ///    <para>Sets the current application's cursor to a cursor that represents the 
        ///       currently selected tool.</para>
        /// </devdoc>
        bool SetCursor();

        /// <include file='doc\IToolboxService.uex' path='docs/doc[@for="IToolboxService.SetSelectedToolboxItem"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Sets the currently selected tool in the toolbox.</para>
        /// </devdoc>
        void SetSelectedToolboxItem(ToolboxItem toolboxItem);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\design\propertyvalueuihandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyValueUIHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing.Design {

    using System.Diagnostics;

    using Microsoft.Win32;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Collections;
       
    /// <include file='doc\PropertyValueUIHandler.uex' path='docs/doc[@for="PropertyValueUIHandler"]/*' />
    /// <devdoc>
    /// <para>Represents a delegate to be added to <see cref='System.Drawing.Design.IPropertyValueUIService'/>.</para>
    /// </devdoc>
    public delegate void PropertyValueUIHandler(ITypeDescriptorContext context, PropertyDescriptor propDesc, ArrayList valueUIItemList);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\design\paintvalueeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="PaintValueEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing.Design {

    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;

    /// <include file='doc\PaintValueEventArgs.uex' path='docs/doc[@for="PaintValueEventArgs"]/*' />
    /// <devdoc>
    ///     This object is passed to UITypeEditor.PaintValue.
    ///      It contains all the information needed for the editor to
    ///     paint the given value, including the Rectangle in which
    ///     the drawing should be done, and the Graphics object with which the drawing
    ///     should be done.
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class PaintValueEventArgs : EventArgs {
        private readonly ITypeDescriptorContext context;

        private readonly object valueToPaint;

        /// <include file='doc\PaintValueEventArgs.uex' path='docs/doc[@for="PaintValueEventArgs.graphics"]/*' />
        /// <devdoc>
        ///     The graphics object with which the drawing should be done.
        /// </devdoc>
        private readonly Graphics graphics;

        /// <include file='doc\PaintValueEventArgs.uex' path='docs/doc[@for="PaintValueEventArgs.bounds"]/*' />
        /// <devdoc>
        ///     The rectangle outlining the area in which the painting should be
        ///     done.
        /// </devdoc>
        private readonly Rectangle bounds;

        /// <include file='doc\PaintValueEventArgs.uex' path='docs/doc[@for="PaintValueEventArgs.PaintValueEventArgs"]/*' />
        /// <devdoc>
        ///     Creates a new PaintValueEventArgs with the given parameters.
        /// </devdoc>
        public PaintValueEventArgs(ITypeDescriptorContext context, object value, Graphics graphics, Rectangle bounds) {
            this.context = context;
            this.valueToPaint = value;
            
            this.graphics = graphics;
            if (graphics == null)
                throw new ArgumentNullException("graphics");
            
            this.bounds = bounds;
        }

        /// <include file='doc\PaintValueEventArgs.uex' path='docs/doc[@for="PaintValueEventArgs.Bounds"]/*' />
        /// <devdoc>
        ///     The rectangle outlining the area in which the painting should be
        ///     done.
        /// </devdoc>
        public Rectangle Bounds {
            get {
                return bounds;
            }
        }

        /// <include file='doc\PaintValueEventArgs.uex' path='docs/doc[@for="PaintValueEventArgs.Context"]/*' />
        /// <devdoc>
        ///     ITypeDescriptorContext object for additional information about the context this value appears in.
        /// </devdoc>
        public ITypeDescriptorContext Context {
            get {
                return context;
            }
        }

        /// <include file='doc\PaintValueEventArgs.uex' path='docs/doc[@for="PaintValueEventArgs.Graphics"]/*' />
        /// <devdoc>
        ///     Graphics object with which painting should be done.
        /// </devdoc>
        public Graphics Graphics {
            get {
                return graphics;
            }
        }

        /// <include file='doc\PaintValueEventArgs.uex' path='docs/doc[@for="PaintValueEventArgs.Value"]/*' />
        /// <devdoc>
        ///     The value to paint.
        /// </devdoc>
        public object Value {
            get {
                return valueToPaint;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\design\categorynamecollection.cs ===
// ------------------------------------------------------------------------------
// <copyright file="CategoryNameCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright> 
// ------------------------------------------------------------------------------
// 
namespace System.Drawing.Design {
    using System;
    using System.Collections;
    
    /// <include file='doc\CategoryNameCollection.uex' path='docs/doc[@for="CategoryNameCollection"]/*' />
    /// <devdoc>
    ///     <para>
    ///       A collection that stores <see cref='System.String'/> objects.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public sealed class CategoryNameCollection : ReadOnlyCollectionBase {
        
        /// <include file='doc\CategoryNameCollection.uex' path='docs/doc[@for="CategoryNameCollection.CategoryNameCollection"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.Drawing.Design.CategoryNameCollection'/> based on another <see cref='System.Drawing.Design.CategoryNameCollection'/>.
        ///    </para>
        /// </devdoc>
        public CategoryNameCollection(CategoryNameCollection value) {
            InnerList.AddRange(value);
        }
        
        /// <include file='doc\CategoryNameCollection.uex' path='docs/doc[@for="CategoryNameCollection.CategoryNameCollection1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.Drawing.Design.CategoryNameCollection'/> containing any array of <see cref='System.String'/> objects.
        ///    </para>
        /// </devdoc>
        public CategoryNameCollection(String[] value) {
            InnerList.AddRange(value);
        }
        
        /// <include file='doc\CategoryNameCollection.uex' path='docs/doc[@for="CategoryNameCollection.this"]/*' />
        /// <devdoc>
        /// <para>Represents the entry at the specified index of the <see cref='System.String'/>.</para>
        /// </devdoc>
        public string this[int index] {
            get {
                return ((string)(InnerList[index]));
            }
        }
        
        /// <include file='doc\CategoryNameCollection.uex' path='docs/doc[@for="CategoryNameCollection.Contains"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the 
        ///    <see cref='System.Drawing.Design.CategoryNameCollection'/> contains the specified <see cref='System.String'/>.</para>
        /// </devdoc>
        public bool Contains(string value) {
            return InnerList.Contains(value);
        }
        
        /// <include file='doc\CategoryNameCollection.uex' path='docs/doc[@for="CategoryNameCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the <see cref='System.Drawing.Design.CategoryNameCollection'/> values to a one-dimensional <see cref='System.Array'/> instance at the 
        ///    specified index.</para>
        /// </devdoc>
        public void CopyTo(String[] array, int index) {
            InnerList.CopyTo(array, index);
        }
        
        /// <include file='doc\CategoryNameCollection.uex' path='docs/doc[@for="CategoryNameCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>Returns the index of a <see cref='System.String'/> in 
        ///       the <see cref='System.Drawing.Design.CategoryNameCollection'/> .</para>
        /// </devdoc>
        public int IndexOf(string value) {
            return InnerList.IndexOf(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\design\propertyvalueuiitem.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyValueUIItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing.Design {

    using System.Diagnostics;

    using Microsoft.Win32;
    using System.Collections;
    using System.Drawing;
    
    /// <include file='doc\PropertyValueUIItem.uex' path='docs/doc[@for="PropertyValueUIItem"]/*' />
    /// <devdoc>
    ///    <para>Provides information about the property value UI including the invoke 
    ///       handler, tool tip, and the glyph icon to be displayed on the property
    ///       browser.</para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class PropertyValueUIItem {
    
      /// <include file='doc\PropertyValueUIItem.uex' path='docs/doc[@for="PropertyValueUIItem.itemImage"]/*' />
      /// <devdoc>
      /// The image to display for this.  Must be 8x8
      /// </devdoc>
      private Image itemImage;
      
      /// <include file='doc\PropertyValueUIItem.uex' path='docs/doc[@for="PropertyValueUIItem.handler"]/*' />
      /// <devdoc>
      /// The handler to fire if this item is double clicked.
      /// </devdoc>
      private PropertyValueUIItemInvokeHandler handler;
      
      /// <include file='doc\PropertyValueUIItem.uex' path='docs/doc[@for="PropertyValueUIItem.tooltip"]/*' />
      /// <devdoc>
      /// The tooltip for this item.
      /// </devdoc>
      private string tooltip;
      
      /// <include file='doc\PropertyValueUIItem.uex' path='docs/doc[@for="PropertyValueUIItem.PropertyValueUIItem"]/*' />
      /// <devdoc>
      /// <para>Initiailzes a new instance of the <see cref='System.Drawing.Design.PropertyValueUIItem'/> class.</para>
      /// </devdoc>
      public PropertyValueUIItem(Image uiItemImage, PropertyValueUIItemInvokeHandler handler, string tooltip){
            this.itemImage = uiItemImage;
            this.handler = handler;
            if (itemImage == null) {
               throw new ArgumentNullException("uiItemImage");
            }
            if (handler == null) {
               throw new ArgumentNullException("handler");
            }
            this.tooltip = tooltip;
      }
      
      /// <include file='doc\PropertyValueUIItem.uex' path='docs/doc[@for="PropertyValueUIItem.Image"]/*' />
      /// <devdoc>
      ///    <para>Gets or sets
      ///       the 8x8 pixel image that will be drawn on the properties window.</para>
      /// </devdoc>
      public virtual Image Image {
          get {
            return itemImage;
          }
      }
      
      
      /// <include file='doc\PropertyValueUIItem.uex' path='docs/doc[@for="PropertyValueUIItem.InvokeHandler"]/*' />
      /// <devdoc>
      ///    <para>Gets or sets the handler that will be raised when this item is double clicked.</para>
      /// </devdoc>
      public virtual PropertyValueUIItemInvokeHandler InvokeHandler {
          get {
             return handler;
          }
      }
      
      /// <include file='doc\PropertyValueUIItem.uex' path='docs/doc[@for="PropertyValueUIItem.ToolTip"]/*' />
      /// <devdoc>
      ///    <para>Gets or sets the
      ///       tool tip to display for this item.</para>
      /// </devdoc>
      public virtual string ToolTip {
          get {
            return tooltip;
          }
      }
      
      /// <include file='doc\PropertyValueUIItem.uex' path='docs/doc[@for="PropertyValueUIItem.Reset"]/*' />
      /// <devdoc>
      ///    <para>Resets the UI item.</para>
      /// </devdoc>
      public virtual void Reset(){
      } 
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\design\propertyvalueuiiteminvokehandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyValueUIItemInvokeHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing.Design {

    using System.Diagnostics;

    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel.Design;
    using System.ComponentModel;
   
    /// <include file='doc\PropertyValueUIItemInvokeHandler.uex' path='docs/doc[@for="PropertyValueUIItemInvokeHandler"]/*' />
    /// <devdoc>
    ///    <para>Represents the method that will handle the event 
    ///       raised when an icon in the properties window associated with
    ///       a <see cref='System.Drawing.Design.PropertyValueUIItem'/> is
    ///       double-clicked.</para>
    /// </devdoc>
    public delegate void PropertyValueUIItemInvokeHandler(ITypeDescriptorContext context, PropertyDescriptor descriptor, PropertyValueUIItem invokedItem);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\design\toolboxcomponentscreatedeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolboxComponentsCreatedEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Design {
    using System;
    using System.ComponentModel;

    
    /// <include file='doc\ToolboxComponentsCreatedEventArgs.uex' path='docs/doc[@for="ToolboxComponentsCreatedEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the 'ToolboxComponentsCreatedEventArgs' event that occurs
    ///    when components are added to the toolbox.</para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class ToolboxComponentsCreatedEventArgs : EventArgs {
        private readonly IComponent[] comps;
        
        /// <include file='doc\ToolboxComponentsCreatedEventArgs.uex' path='docs/doc[@for="ToolboxComponentsCreatedEventArgs.ToolboxComponentsCreatedEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Design.ToolboxComponentsCreatedEventArgs'/> object.
        ///    </para>
        /// </devdoc>
        public ToolboxComponentsCreatedEventArgs(IComponent[] components) {
            this.comps = components;
        }
        
        /// <include file='doc\ToolboxComponentsCreatedEventArgs.uex' path='docs/doc[@for="ToolboxComponentsCreatedEventArgs.Components"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An array storing the toolbox components.
        ///    </para>
        /// </devdoc>
        public IComponent[] Components {
            get {
                return (IComponent[])comps.Clone();
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\design\toolboxcomponentscreatedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolboxComponentsCreatedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Design {
    using System;
    using System.ComponentModel;

    /// <include file='doc\ToolboxComponentsCreatedEventHandler.uex' path='docs/doc[@for="ToolboxComponentsCreatedEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see cref='System.Drawing.Design.ToolboxItem.ComponentsCreated'/> event.</para>
    /// </devdoc>
    public delegate void ToolboxComponentsCreatedEventHandler(object sender, ToolboxComponentsCreatedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\design\toolboxcomponentscreatingeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolboxComponentsCreatingEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Design {
    using System;
    using System.ComponentModel;

    /// <include file='doc\ToolboxComponentsCreatingEventHandler.uex' path='docs/doc[@for="ToolboxComponentsCreatingEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see cref='System.Drawing.Design.ToolboxItem.ComponentsCreating'/> event.</para>
    /// </devdoc>
    public delegate void ToolboxComponentsCreatingEventHandler(object sender, ToolboxComponentsCreatingEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\design\toolboxitemcreatorcallback.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolboxItemCreatorCallback.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing.Design {

    /// <include file='doc\ToolboxItemCreatorCallback.uex' path='docs/doc[@for="ToolboxItemCreatorCallback"]/*' />
    /// <devdoc>
    ///    <para> Represents the
    ///       method that will handle the ToolboxItemCreatorCallback event.</para>
    /// </devdoc>
    public delegate ToolboxItem ToolboxItemCreatorCallback(object serializedObject, string format);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\design\toolboxitemcollection.cs ===
// ------------------------------------------------------------------------------
// <copyright file="ToolboxItemCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright> 
// ------------------------------------------------------------------------------
// 
namespace System.Drawing.Design {

    using System;
    using System.Collections;
    
    /// <include file='doc\ToolboxItemCollection.uex' path='docs/doc[@for="ToolboxItemCollection"]/*' />
    /// <devdoc>
    ///     <para>
    ///       A collection that stores <see cref='System.Drawing.Design.ToolboxItem'/> objects.
    ///    </para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public sealed class ToolboxItemCollection : ReadOnlyCollectionBase {
        
        /// <include file='doc\ToolboxItemCollection.uex' path='docs/doc[@for="ToolboxItemCollection.ToolboxItemCollection"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.Drawing.Design.ToolboxItemCollection'/> based on another <see cref='System.Drawing.Design.ToolboxItemCollection'/>.
        ///    </para>
        /// </devdoc>
        public ToolboxItemCollection(ToolboxItemCollection value) {
            InnerList.AddRange(value);
        }
        
        /// <include file='doc\ToolboxItemCollection.uex' path='docs/doc[@for="ToolboxItemCollection.ToolboxItemCollection1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.Drawing.Design.ToolboxItemCollection'/> containing any array of <see cref='System.Drawing.Design.ToolboxItem'/> objects.
        ///    </para>
        /// </devdoc>
        public ToolboxItemCollection(ToolboxItem[] value) {
            InnerList.AddRange(value);
        }
        
        /// <include file='doc\ToolboxItemCollection.uex' path='docs/doc[@for="ToolboxItemCollection.this"]/*' />
        /// <devdoc>
        /// <para>Represents the entry at the specified index of the <see cref='System.Drawing.Design.ToolboxItem'/>.</para>
        /// </devdoc>
        public ToolboxItem this[int index] {
            get {
                return ((ToolboxItem)(InnerList[index]));
            }
        }
        
        /// <include file='doc\ToolboxItemCollection.uex' path='docs/doc[@for="ToolboxItemCollection.Contains"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the 
        ///    <see cref='System.Drawing.Design.ToolboxItemCollection'/> contains the specified <see cref='System.Drawing.Design.ToolboxItem'/>.</para>
        /// </devdoc>
        public bool Contains(ToolboxItem value) {
            return InnerList.Contains(value);
        }
        
        /// <include file='doc\ToolboxItemCollection.uex' path='docs/doc[@for="ToolboxItemCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the <see cref='System.Drawing.Design.ToolboxItemCollection'/> values to a one-dimensional <see cref='System.Array'/> instance at the 
        ///    specified index.</para>
        /// </devdoc>
        public void CopyTo(ToolboxItem[] array, int index) {
            InnerList.CopyTo(array, index);
        }
        
        /// <include file='doc\ToolboxItemCollection.uex' path='docs/doc[@for="ToolboxItemCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>Returns the index of a <see cref='System.Drawing.Design.ToolboxItem'/> in 
        ///       the <see cref='System.Drawing.Design.ToolboxItemCollection'/> .</para>
        /// </devdoc>
        public int IndexOf(ToolboxItem value) {
            return InnerList.IndexOf(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\design\toolboxcomponentscreatingeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolboxComponentsCreatingEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Design {
    using System;
    using System.ComponentModel.Design;

    
    /// <include file='doc\ToolboxComponentsCreatingEventArgs.uex' path='docs/doc[@for="ToolboxComponentsCreatingEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the 'ToolboxComponentsCreatingEventArgs' event that occurs
    ///    when components are added to the toolbox.</para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class ToolboxComponentsCreatingEventArgs : EventArgs {
        private readonly IDesignerHost host;
        
        /// <include file='doc\ToolboxComponentsCreatingEventArgs.uex' path='docs/doc[@for="ToolboxComponentsCreatingEventArgs.ToolboxComponentsCreatingEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Design.ToolboxComponentsCreatingEventArgs'/> object.
        ///    </para>
        /// </devdoc>
        public ToolboxComponentsCreatingEventArgs(IDesignerHost host) {
            this.host = host;
        }
        
        /// <include file='doc\ToolboxComponentsCreatingEventArgs.uex' path='docs/doc[@for="ToolboxComponentsCreatingEventArgs.DesignerHost"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An instance of IDesignerHost that has made the creat request.  This can be null if no designer host
        ///       was provided to the toolbox item.
        ///    </para>
        /// </devdoc>
        public IDesignerHost DesignerHost {
            get {
                return host;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\design\uitypeeditoreditstyle.cs ===
//------------------------------------------------------------------------------
// <copyright file="UITypeEditorEditStyle.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing.Design {

    using System.Diagnostics;
    
    /// <include file='doc\UITypeEditorEditStyle.uex' path='docs/doc[@for="UITypeEditorEditStyle"]/*' />
    /// <devdoc>
    ///    <para>Specifies identifiers to indicate the style of
    ///       a <see cref='System.Drawing.Design.UITypeEditor'/>.</para>
    /// </devdoc>
    public enum UITypeEditorEditStyle {
        /// <include file='doc\UITypeEditorEditStyle.uex' path='docs/doc[@for="UITypeEditorEditStyle.None"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates no editor style.
        ///    </para>
        /// </devdoc>
        None = 1,
        /// <include file='doc\UITypeEditorEditStyle.uex' path='docs/doc[@for="UITypeEditorEditStyle.Modal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indicates a modal editor style.
        ///    </para>
        /// </devdoc>
        Modal = 2,
        /// <include file='doc\UITypeEditorEditStyle.uex' path='docs/doc[@for="UITypeEditorEditStyle.DropDown"]/*' />
        /// <devdoc>
        ///    <para> Indicates a drop-down editor style.</para>
        /// </devdoc>
        DropDown = 3
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\design\uitypeeditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="UITypeEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing.Design {
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Collections;
    using Microsoft.Win32;    
    using System.ComponentModel.Design;
    using System.Drawing;

    /// <include file='doc\UITypeEditor.uex' path='docs/doc[@for="UITypeEditor"]/*' />
    /// <devdoc>
    ///    <para>Provides a base class for editors 
    ///       that may provide users with a user interface to visually edit
    ///       the values of the supported type or types.</para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class UITypeEditor {
    
        /// <include file='doc\UITypeEditor.uex' path='docs/doc[@for="UITypeEditor.UITypeEditor"]/*' />
        /// <devdoc>
        ///      In this static constructor we provide default UITypeEditors to
        ///      the TypeDescriptor.
        /// </devdoc>
        static UITypeEditor() {
            Hashtable intrinsicEditors = new Hashtable();
            
            // Our set of intrinsic editors.
            intrinsicEditors[typeof(DateTime)] = "System.ComponentModel.Design.DateTimeEditor, " + AssemblyRef.SystemDesign;
            intrinsicEditors[typeof(Array)] = "System.ComponentModel.Design.ArrayEditor, " + AssemblyRef.SystemDesign;
            intrinsicEditors[typeof(IList)] = "System.ComponentModel.Design.CollectionEditor, " + AssemblyRef.SystemDesign;
            intrinsicEditors[typeof(ICollection)] = "System.ComponentModel.Design.CollectionEditor, " + AssemblyRef.SystemDesign;
            intrinsicEditors[typeof(byte[])] = "System.ComponentModel.Design.BinaryEditor, " + AssemblyRef.SystemDesign;
            intrinsicEditors[typeof(System.IO.Stream)] = "System.ComponentModel.Design.BinaryEditor, " + AssemblyRef.SystemDesign;
            intrinsicEditors[typeof(string[])] = "System.Windows.Forms.Design.StringArrayEditor, " + AssemblyRef.SystemDesign;
            
            // Add our intrinsic editors to TypeDescriptor.
            //
            TypeDescriptor.AddEditorTable(typeof(UITypeEditor), intrinsicEditors);
        }
        
        /// <include file='doc\UITypeEditor.uex' path='docs/doc[@for="UITypeEditor.UITypeEditor1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes
        ///       a new instance of the <see cref='System.Drawing.Design.UITypeEditor'/> class.
        ///    </para>
        /// </devdoc>
        public UITypeEditor() {
        }
        
        /// <include file='doc\UITypeEditor.uex' path='docs/doc[@for="UITypeEditor.EditValue"]/*' />
        /// <devdoc>
        ///    <para>Edits the specified value using the editor style
        ///       provided by <see cref='System.Drawing.Design.UITypeEditor.GetEditStyle'/>.</para>
        /// </devdoc>
        public object EditValue(IServiceProvider provider, object value) {
            return EditValue(null, provider, value);
        }

        /// <include file='doc\UITypeEditor.uex' path='docs/doc[@for="UITypeEditor.EditValue1"]/*' />
        /// <devdoc>
        ///    <para>Edits the specified object's value using the editor style
        ///       provided by <see cref='System.Drawing.Design.UITypeEditor.GetEditStyle'/>.</para>
        /// </devdoc>
        public virtual object EditValue(ITypeDescriptorContext context, IServiceProvider provider, object value) {
            return value;
        }

        /// <include file='doc\UITypeEditor.uex' path='docs/doc[@for="UITypeEditor.GetEditStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the <see cref='System.Drawing.Design.UITypeEditorEditStyle'/>
        ///       of the Edit method.
        ///    </para>
        /// </devdoc>
        public UITypeEditorEditStyle GetEditStyle() {
            return GetEditStyle(null);
        }

        /// <include file='doc\UITypeEditor.uex' path='docs/doc[@for="UITypeEditor.GetPaintValueSupported"]/*' />
        /// <devdoc>
        ///    <para> Gets a value indicating whether this editor supports painting a representation
        ///       of an object's value.</para>
        /// </devdoc>
        public bool GetPaintValueSupported() {
            return GetPaintValueSupported(null);
        }

        /// <include file='doc\UITypeEditor.uex' path='docs/doc[@for="UITypeEditor.GetPaintValueSupported1"]/*' />
        /// <devdoc>
        ///    <para> Gets a value indicating whether the specified context supports painting a representation
        ///       of an object's value.</para>
        /// </devdoc>
        public virtual bool GetPaintValueSupported(ITypeDescriptorContext context) {
            return false;
        }

        /// <include file='doc\UITypeEditor.uex' path='docs/doc[@for="UITypeEditor.GetEditStyle1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the editing style of the Edit method.
        ///    </para>
        /// </devdoc>
        public virtual UITypeEditorEditStyle GetEditStyle(ITypeDescriptorContext context) {
            return UITypeEditorEditStyle.None;
        }

        /// <include file='doc\UITypeEditor.uex' path='docs/doc[@for="UITypeEditor.PaintValue"]/*' />
        /// <devdoc>
        ///    <para>Paints a representative value of the specified object to the
        ///       specified canvas.</para>
        /// </devdoc>
        public void PaintValue(object value, Graphics canvas, Rectangle rectangle) {
            PaintValue(new PaintValueEventArgs(null, value, canvas, rectangle));
        }

        /// <include file='doc\UITypeEditor.uex' path='docs/doc[@for="UITypeEditor.PaintValue1"]/*' />
        /// <devdoc>
        ///    <para>Paints a representative value of the specified object to the
        ///       provided canvas.</para>
        /// </devdoc>
        public virtual void PaintValue(PaintValueEventArgs e) {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\design\toolboxitem.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolboxItem.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing.Design {
    using System.Configuration.Assemblies;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization;
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.Reflection;
    using System.Collections;    
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using System.Drawing;
    using System.IO;

    /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem"]/*' />
    /// <devdoc>
    ///    <para> Provides a base implementation of a toolbox item.</para>
    /// </devdoc>
    [Serializable]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class ToolboxItem : ISerializable {
    
        private static TraceSwitch ToolboxItemPersist = new TraceSwitch("ToolboxPersisting", "ToolboxItem: write data");
        
        private static object EventComponentsCreated = new object();
        private static object EventComponentsCreating = new object();
        
        private string                                typeName;
        private AssemblyName                          assemblyName;
        private string                                displayName;
        private Bitmap                                itemBitmap;
        private bool                                  locked;
        private ToolboxItemFilterAttribute[]          filter;
        private ToolboxComponentsCreatedEventHandler  componentsCreatedEvent;
        private ToolboxComponentsCreatingEventHandler componentsCreatingEvent;

        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.ToolboxItem"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the ToolboxItem class.
        /// </devdoc>
        public ToolboxItem() {
            typeName = string.Empty;
            displayName = string.Empty;
            filter = new ToolboxItemFilterAttribute[0];
        }
        
        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.ToolboxItem1"]/*' />
        /// <devdoc>
        ///    Initializes a new instance of the ToolboxItem class using the specified type.
        /// </devdoc>
        public ToolboxItem(Type toolType) {
            Initialize(toolType);
        }
        
        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.ToolboxItem2"]/*' />
        /// <devdoc>
        ///     Initializes a new instance of the <see cref='System.Drawing.Design.ToolboxItem'/>
        ///     class using the specified serialization information.
        /// </devdoc>
        private ToolboxItem(SerializationInfo info, StreamingContext context) {
            Deserialize(info, context);
        }

        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.AssemblyName"]/*' />
        /// <devdoc>
        ///     The assembly name for this toolbox item. The assembly name describes the assembly
        ///     information needed to load the toolbox item's type.
        /// </devdoc>
        public AssemblyName AssemblyName {
            get {
                if (assemblyName != null) {
                    return (AssemblyName)assemblyName.Clone();
                }
                return null;
            }
            set {
                CheckUnlocked();
                if (value != null) {
                    value = (AssemblyName)value.Clone();
                }
                assemblyName = value;
            }
        }
        
        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.Bitmap"]/*' />
        /// <devdoc>
        ///     Gets or sets the bitmap that will be used on the toolbox for this item.
        /// </devdoc>
        public Bitmap Bitmap {
            get {
                return itemBitmap;
            }
            set {
                CheckUnlocked();
                itemBitmap = value;
            }
        }
        
        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.DisplayName"]/*' />
        /// <devdoc>
        ///     Gets or sets the display name for this <see cref='System.Drawing.Design.ToolboxItem'/>.
        /// </devdoc>
        public string DisplayName {
            get {
                return displayName;
            }
            set {
                CheckUnlocked();
                
                if (value == null) {
                    value = string.Empty;
                }
                displayName = value;
            }
        }
        
        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.Filter"]/*' />
        /// <devdoc>
        ///     Gets or sets the filter for this toolbox item.  The filter is a collection of
        ///     ToolboxItemFilterAttribute objects.
        /// </devdoc>
        public ICollection Filter {
            get {
                return filter;
            }
            set {
                CheckUnlocked();
                int filterCount = 0;
                foreach(object f in value) {
                    if (f is ToolboxItemFilterAttribute) {
                        filterCount++;
                    }
                }
                
                filter = new ToolboxItemFilterAttribute[filterCount];
                filterCount = 0;

                foreach(object f in value) {
                    if (f is ToolboxItemFilterAttribute) {
                        filter[filterCount++] = (ToolboxItemFilterAttribute)f;
                    }
                }
            }
        }
        
        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.Locked"]/*' />
        /// <devdoc>
        ///     Determines if this toolbox item is locked.  Once locked, a toolbox item will
        ///     not accept any changes to its properties.
        /// </devdoc>
        protected bool Locked {
            get {
                return locked;
            }
        }
        
        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.TypeName"]/*' />
        /// <devdoc>
        ///     Gets or sets the fully qualified name of the type this toolbox item will create.
        /// </devdoc>
        public string TypeName {
            get {
                return typeName;
            }
            set {
                CheckUnlocked();
                if (value == null) {
                    value = string.Empty;
                }
                typeName = value;
            }
        }
        
        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.ComponentsCreated"]/*' />
        /// <devdoc>
        ///    <para>Occurs when components are created.</para>
        /// </devdoc>
        public event ToolboxComponentsCreatedEventHandler ComponentsCreated {
            add {
                componentsCreatedEvent += value;
            }
            remove {
                componentsCreatedEvent -= value;
            }
        }
        
        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.ComponentsCreating"]/*' />
        /// <devdoc>
        ///    <para>Occurs before components are created.</para>
        /// </devdoc>
        public event ToolboxComponentsCreatingEventHandler ComponentsCreating {
            add {
                componentsCreatingEvent += value;
            }
            remove {
                componentsCreatingEvent -= value;
            }
        }
        
        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.CheckUnlocked"]/*' />
        /// <devdoc>
        ///     This method checks that the toolbox item is currently unlocked (read-write) and
        ///     throws an appropriate exception if it isn't.
        /// </devdoc>
        protected void CheckUnlocked() {
            if (locked) throw new InvalidOperationException(SR.GetString(SR.ToolboxItemLocked));
        }
        
        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.CreateComponents"]/*' />
        /// <devdoc>
        ///     Creates objects from the type contained in this toolbox item.
        /// </devdoc>
        public IComponent[] CreateComponents() {
            return CreateComponents(null);
        }

        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.CreateComponents1"]/*' />
        /// <devdoc>
        ///     Creates objects from the type contained in this toolbox item.  If designerHost is non-null
        ///     this will also add them to the designer.
        /// </devdoc>
        public IComponent[] CreateComponents(IDesignerHost host) {
            OnComponentsCreating(new ToolboxComponentsCreatingEventArgs(host));
            IComponent[] comps = CreateComponentsCore(host);
            if (comps != null && comps.Length > 0) {
                OnComponentsCreated(new ToolboxComponentsCreatedEventArgs(comps));
            }
            return comps;
        }

        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.CreateComponentsCore"]/*' />
        /// <devdoc>
        ///     Creates objects from the type contained in this toolbox item.  If designerHost is non-null
        ///     this will also add them to the designer.
        /// </devdoc>
        protected virtual IComponent[] CreateComponentsCore(IDesignerHost host) {
            ArrayList comps = new ArrayList();
            
            Type createType = GetType(host, AssemblyName, TypeName, true);
            if (createType != null) {
                if (host != null) {
                    comps.Add(host.CreateComponent(createType));
                }
                else if (typeof(IComponent).IsAssignableFrom(createType)) {
                    comps.Add(Activator.CreateInstance(createType));
                }
            }
            
            IComponent[] temp = new IComponent[comps.Count];
            comps.CopyTo(temp, 0);
            return temp;
        }
        
        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.Deserialize"]/*' />
        /// <devdoc>
        /// <para>Loads the state of this <see cref='System.Drawing.Design.ToolboxItem'/>
        /// from the stream.</para>
        /// </devdoc>
        protected virtual void Deserialize(SerializationInfo info, StreamingContext context) {
            typeName = info.GetString("TypeName");
            assemblyName = (AssemblyName)info.GetValue("AssemblyName", typeof(AssemblyName));
            itemBitmap = (Bitmap)info.GetValue("Bitmap", typeof(Bitmap));
            locked = info.GetBoolean("Locked");
            displayName = info.GetString("DisplayName");
            filter = (ToolboxItemFilterAttribute[])info.GetValue("Filter", typeof(ToolboxItemFilterAttribute[]));
        }
        
        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.Equals"]/*' />
        /// <internalonly/>
        public override bool Equals(object obj) {
            if (this == obj) {
                return true;
            }

            if (obj == null) {
                return false;
            }

            if (!(obj.GetType() == this.GetType())) {
                return false;
            }

            ToolboxItem otherItem = (ToolboxItem)obj;
            
            if (typeName != otherItem.typeName) {
                if (typeName == null || otherItem.typeName == null) {
                    return false;
                }
                
                if (!typeName.Equals(otherItem.typeName)) {
                    return false;
                }
            }
            
            if (assemblyName != otherItem.assemblyName) {
                if (assemblyName == null || otherItem.assemblyName == null) {
                    return false;
                }
                
                if (!assemblyName.FullName.Equals(otherItem.assemblyName.FullName)) {
                    return false;
                }
            }
            
            if (displayName != otherItem.displayName) {
                if (displayName == null ||otherItem.displayName == null) {
                    return false;
                }
                
                if (!displayName.Equals(otherItem.displayName)) {
                    return false;
                }
            }
            
            return true;
        }

        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.GetHashCode"]/*' />
        /// <internalonly/>
        public override int GetHashCode() {
            int hash = 0;
            
            if (typeName != null) {
                hash ^= typeName.GetHashCode();
            }
            
            return hash ^ displayName.GetHashCode();
        }

        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.GetType"]/*' />
        /// <devdoc>
        ///     This utility function can be used to load a type given a name.  AssemblyName and
        ///     designer host can be null, but if they are present they will be used to help
        ///     locate the type.  If reference is true, the given assembly name will be added
        ///     to the designer host's set of references.
        /// </devdoc>
        protected virtual Type GetType(IDesignerHost host, AssemblyName assemblyName, string typeName, bool reference) {
            ITypeResolutionService ts = null;
            Type type = null;
            
            if (typeName == null) {
                throw new ArgumentNullException("typeName");
            }
            
            if (host != null) {
                ts = (ITypeResolutionService)host.GetService(typeof(ITypeResolutionService));
            }
            
            if (ts != null) {
                
                if (reference) {
                    if (assemblyName != null) {
                        ts.ReferenceAssembly(assemblyName);
                        type = ts.GetType(typeName);
                    }
                    else {
                        // Just try loading the type.  If we succeed, then use this as the
                        // reference.
                        type = ts.GetType(typeName);
                        if (type == null) {
                            type = Type.GetType(typeName);
                        }
                        if (type != null) {
                            ts.ReferenceAssembly(type.Assembly.GetName());
                        }
                    }
                }
                else {
                    if (assemblyName != null) {
                        Assembly a = ts.GetAssembly(assemblyName);
                        if (a != null) {
                            type = a.GetType(typeName);
                        }
                    }
                    
                    if (type == null) {
                        type = ts.GetType(typeName);
                    }
                }
            }
            else {
                if (assemblyName != null) {
                    Assembly a = null;
                    try {
                        a = Assembly.Load(assemblyName);
                    }
                    catch {
                    }
                    
                    if (a == null && assemblyName.CodeBase != null && assemblyName.CodeBase.Length > 0) {
                        a = Assembly.LoadFrom(assemblyName.CodeBase);
                    }
                    
                    if (a != null) {
                        type = a.GetType(typeName);
                    }
                }
                
                if (type == null) {
                    type = Type.GetType(typeName);
                }
            }
            
            return type;
        }
        
        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.Initialize"]/*' />
        /// <devdoc>
        ///     Initializes a toolbox item with a given type.  A locked toolbox item cannot be initialized.
        /// </devdoc>
        public virtual void Initialize(Type type) {
            CheckUnlocked();
            
            if (type != null) {
                typeName = type.FullName;
                assemblyName = type.Assembly.GetName(true);
                if (type.Assembly.GlobalAssemblyCache) {
                    assemblyName.CodeBase = null;
                }
                displayName = type.Name;
                
                ToolboxBitmapAttribute attr = (ToolboxBitmapAttribute)TypeDescriptor.GetAttributes(type)[typeof(ToolboxBitmapAttribute)];
                if (attr != null) {
                    itemBitmap = attr.GetImage(type, false) as Bitmap;
                    // make sure this thing is 16x16
                    if (itemBitmap != null && (itemBitmap.Width != 16 || itemBitmap.Height != 16)) {
                        itemBitmap = new Bitmap(itemBitmap, new Size(16,16));
                    }
                }
                
                ArrayList array = new ArrayList();
                foreach(Attribute a in TypeDescriptor.GetAttributes(type)) {
                    if (a is ToolboxItemFilterAttribute) {
                        array.Add(a);
                    }
                }
                filter = new ToolboxItemFilterAttribute[array.Count];
                array.CopyTo(filter);
            }
        }
        
        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.Lock"]/*' />
        /// <devdoc>
        ///     Locks this toolbox item.  Locking a toolbox item makes it read-only and 
        ///     prevents any changes to its properties.  
        /// </devdoc>
        public void Lock() {
            locked = true;
        }
        
        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.OnComponentsCreated"]/*' />
        /// <devdoc>
        ///    <para>Raises the OnComponentsCreated event. This
        ///       will be called when this <see cref='System.Drawing.Design.ToolboxItem'/> creates a component.</para>
        /// </devdoc>
        protected virtual void OnComponentsCreated(ToolboxComponentsCreatedEventArgs args) {
            if (componentsCreatedEvent != null) {
                componentsCreatedEvent(this, args);
            }
        }

        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.OnComponentsCreating"]/*' />
        /// <devdoc>
        ///    <para>Raises the OnCreateComponentsInvoked event. This
        ///       will be called before this <see cref='System.Drawing.Design.ToolboxItem'/> creates a component.</para>
        /// </devdoc>
        protected virtual void OnComponentsCreating(ToolboxComponentsCreatingEventArgs args) {
            if (componentsCreatingEvent != null) {
                componentsCreatingEvent(this, args);
            }
        }

        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.Serialize"]/*' />
        /// <devdoc>
        /// <para>Saves the state of this <see cref='System.Drawing.Design.ToolboxItem'/> to
        ///    the specified serialization info.</para>
        /// </devdoc>
        protected virtual void Serialize(SerializationInfo info, StreamingContext context) {
            
            if (ToolboxItemPersist.TraceVerbose) {
                Debug.WriteLine("Persisting: " + GetType().Name);
                Debug.WriteLine("\tDisplay Name: " + displayName);
            }
        
            info.AddValue("TypeName" , typeName);
            info.AddValue("AssemblyName", assemblyName);
            info.AddValue("DisplayName", displayName);
            info.AddValue("Bitmap", itemBitmap);
            info.AddValue("Locked", locked);
            info.AddValue("Filter", filter);
        }

        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.ToString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override string ToString() {
            return this.DisplayName;            
        }
        
        /// <include file='doc\ToolboxItem.uex' path='docs/doc[@for="ToolboxItem.ISerializable.GetObjectData"]/*' />
        /// <internalonly/>
        void ISerializable.GetObjectData(SerializationInfo info, StreamingContext context) {
            IntSecurity.UnmanagedCode.Demand();
            Serialize(info, context);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\modefield.cs ===
//------------------------------------------------------------------------------
// <copyright file="ModeField.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {

    using System.Diagnostics;
    using System;
    using System.Runtime.InteropServices;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    // Some of the fields in DEVMODE
    internal enum ModeField {
        Orientation,
        PaperSize,
        PaperLength,
        PaperWidth,
        Copies,
        DefaultSource,
        PrintQuality,
        Color,
        Duplex,
        YResolution,
        TTOption,
        Collate,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\defaultprintcontroller.cs ===
//------------------------------------------------------------------------------
// <copyright file="DefaultPrintController.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {

    using Microsoft.Win32;
    using System.ComponentModel;
    using System;
    using System.Diagnostics;
    using System.Drawing;
    using System.Runtime.InteropServices;

    using CodeAccessPermission = System.Security.CodeAccessPermission;

    /// <include file='doc\DefaultPrintController.uex' path='docs/doc[@for="StandardPrintController"]/*' />
    /// <devdoc>
    ///    <para>Specifies a print controller that sends information to a printer.
    ///       </para>
    /// </devdoc>
    public class StandardPrintController : PrintController {
        private IntPtr dc;
        private Graphics graphics;

        private void CheckSecurity(PrintDocument document) {
            if (document.PrinterSettings.PrintDialogDisplayed) {
                IntSecurity.SafePrinting.Demand();
            }
            else if (document.PrinterSettings.IsDefaultPrinter) {
                IntSecurity.DefaultPrinting.Demand();
            }
            else {
                IntSecurity.AllPrinting.Demand();
            }
        }

        /// <include file='doc\DefaultPrintController.uex' path='docs/doc[@for="StandardPrintController.OnStartPrint"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Implements StartPrint for printing to a physical printer.
        ///    </para>
        /// </devdoc>
        public override void OnStartPrint(PrintDocument document, PrintEventArgs e) {
            Debug.Assert(dc == IntPtr.Zero && graphics == null, "PrintController methods called in the wrong order?");

            // For security purposes, don't assume our public methods methods are called in any particular order
            CheckSecurity(document);

            base.OnStartPrint(document, e);

            IntSecurity.AllPrintingAndUnmanagedCode.Assert();

            if (!document.PrinterSettings.IsValid)
                throw new InvalidPrinterException(document.PrinterSettings);

            dc = document.PrinterSettings.CreateHdc(modeHandle);
            SafeNativeMethods.DOCINFO info = new SafeNativeMethods.DOCINFO();
            info.lpszDocName = document.DocumentName;
            if (document.PrinterSettings.PrintToFile)
                info.lpszOutput = document.PrinterSettings.OutputPort; //This will be "FILE:"
            else
                info.lpszOutput = null;
            info.lpszDatatype = null;
            info.fwType = 0;

            int result = SafeNativeMethods.StartDoc(new HandleRef(this, dc), info);
            if (result <= 0)
                throw new Win32Exception();
        }

        /// <include file='doc\DefaultPrintController.uex' path='docs/doc[@for="StandardPrintController.OnStartPage"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Implements StartPage for printing to a physical printer.
        ///    </para>
        /// </devdoc>
        public override Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e) {
            Debug.Assert(dc != IntPtr.Zero && graphics == null, "PrintController methods called in the wrong order?");

            // For security purposes, don't assume our public methods methods are called in any particular order
            CheckSecurity(document);

            base.OnStartPage(document, e);

            IntSecurity.AllPrintingAndUnmanagedCode.Assert();

            e.PageSettings.CopyToHdevmode(modeHandle);
            IntPtr modePointer = SafeNativeMethods.GlobalLock(new HandleRef(this, modeHandle));
            try {
                IntPtr result = SafeNativeMethods.ResetDC(new HandleRef(this, dc), new HandleRef(null, modePointer));
                if (result == IntPtr.Zero)
                    throw new Win32Exception();
                Debug.Assert(result == dc, "ResetDC didn't return the same handle I gave it");
            }
            finally {
                SafeNativeMethods.GlobalUnlock(new HandleRef(this, modeHandle));
            }

            // int horizontalResolution = Windows.GetDeviceCaps(dc, SafeNativeMethods.HORZRES);
            // int verticalResolution = Windows.GetDeviceCaps(dc, SafeNativeMethods.VERTRES);

            graphics = Graphics.FromHdcInternal(dc);

            if (graphics != null && document.OriginAtMargins) {

                // Adjust the origin of the graphics object to be at the
                // user-specified margin location
                //
                int dpiX = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, dc), SafeNativeMethods.LOGPIXELSX);
                int dpiY = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, dc), SafeNativeMethods.LOGPIXELSY);
                int hardMarginX_DU = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, dc), SafeNativeMethods.PHYSICALOFFSETX);
                int hardMarginY_DU = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, dc), SafeNativeMethods.PHYSICALOFFSETY);                
                float hardMarginX = hardMarginX_DU * 100 / dpiX;
                float hardMarginY = hardMarginY_DU * 100 / dpiY;
    
                graphics.TranslateTransform(-hardMarginX, -hardMarginY);
                graphics.TranslateTransform(e.MarginBounds.X, e.MarginBounds.Y);
            }
            

            int result2 = SafeNativeMethods.StartPage(new HandleRef(this, dc));
            if (result2 <= 0)
                throw new Win32Exception();
            return graphics;
        }

        /// <include file='doc\DefaultPrintController.uex' path='docs/doc[@for="StandardPrintController.OnEndPage"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Implements EndPage for printing to a physical printer.
        ///    </para>
        /// </devdoc>
        public override void OnEndPage(PrintDocument document, PrintPageEventArgs e) {
            Debug.Assert(dc != IntPtr.Zero && graphics != null, "PrintController methods called in the wrong order?");

            // For security purposes, don't assume our public methods methods are called in any particular order
            CheckSecurity(document);

            IntSecurity.UnmanagedCode.Assert();

            int result = SafeNativeMethods.EndPage(new HandleRef(this, dc));
            if (result <= 0)
                throw new Win32Exception();
            graphics.Dispose(); // Dispose of GDI+ Graphics; keep the DC
            graphics = null;

            CodeAccessPermission.RevertAssert();

            base.OnEndPage(document, e);
        }

        /// <include file='doc\DefaultPrintController.uex' path='docs/doc[@for="StandardPrintController.OnEndPrint"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Implements EndPrint for printing to a physical printer.
        ///    </para>
        /// </devdoc>
        public override void OnEndPrint(PrintDocument document, PrintEventArgs e) {
            Debug.Assert(dc != IntPtr.Zero && graphics == null, "PrintController methods called in the wrong order?");

            // For security purposes, don't assume our public methods methods are called in any particular order
            CheckSecurity(document);

            IntSecurity.UnmanagedCode.Assert();

            if (dc != IntPtr.Zero) {
                int result = (e.Cancel) ? SafeNativeMethods.AbortDoc(new HandleRef(this, dc)) : SafeNativeMethods.EndDoc(new HandleRef(this, dc));
                if (result <= 0)
                    throw new Win32Exception();
                bool success = SafeNativeMethods.DeleteDC(new HandleRef(this, dc));
                if (!success)
                    throw new Win32Exception();

                dc = IntPtr.Zero;
            }

            CodeAccessPermission.RevertAssert();

            base.OnEndPrint(document, e);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\marginsconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="MarginsConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing.Printing {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;

    using System.Diagnostics;

    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design.Serialization;
    using System.Globalization;
    using System.Reflection;

    /// <include file='doc\MarginsConverter.uex' path='docs/doc[@for="MarginsConverter"]/*' />
    /// <devdoc>
    ///    <para>Provides a
    ///       type converter to convert <see cref='System.Drawing.Printing.Margins'/> to and from various other representations, such as a string.</para>
    /// </devdoc>
    public class MarginsConverter : ExpandableObjectConverter {

        /// <include file='doc\MarginsConverter.uex' path='docs/doc[@for="MarginsConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>Determines if a converter can convert an object of the given source
        ///       type to the native type of the converter.</para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\MarginsConverter.uex' path='docs/doc[@for="MarginsConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\MarginsConverter.uex' path='docs/doc[@for="MarginsConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///      Converts the given object to the converter's native type.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {

            if (value is string) {

                string text = ((string)value).Trim();

                if (text.Length == 0) {
                    return null;
                }
                else {

                    // Parse 4 integer values.
                    //
                    if (culture == null) {
                        culture = CultureInfo.CurrentCulture;
                    }
                    char sep = culture.TextInfo.ListSeparator[0];
                    string[] tokens = text.Split(new char[] {sep});
                    int[] values = new int[tokens.Length];
                    TypeConverter intConverter = TypeDescriptor.GetConverter(typeof(int));
                    for (int i = 0; i < values.Length; i++) {
                        values[i] = (int)intConverter.ConvertFromString(context, culture, tokens[i]);
                    }

                    if (values.Length != 4) {
                        throw new ArgumentException(SR.GetString(SR.TextParseFailedFormat,
                                                                  text,
                                                                  "left, right, top, bottom"));
                    }
                    return new Margins(values[0], values[1], values[2], values[3]);
                }
            }

            return base.ConvertFrom(context, culture, value);
        }

        /// <include file='doc\MarginsConverter.uex' path='docs/doc[@for="MarginsConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string) && value is Margins) {
                Margins margins = (Margins)value;

                if (culture == null) {
                    culture = CultureInfo.CurrentCulture;
                }
                string sep = culture.TextInfo.ListSeparator + " ";
                TypeConverter intConverter = TypeDescriptor.GetConverter(typeof(int));
                string[] args = new string[4];
                int nArg = 0;

                args[nArg++] = intConverter.ConvertToString(context, culture, margins.Left);
                args[nArg++] = intConverter.ConvertToString(context, culture, margins.Right);
                args[nArg++] = intConverter.ConvertToString(context, culture, margins.Top);
                args[nArg++] = intConverter.ConvertToString(context, culture, margins.Bottom);

                return string.Join(sep, args);
            }
            if (destinationType == typeof(InstanceDescriptor) && value is Margins) {
                Margins margins = (Margins)value;
                
                ConstructorInfo ctor = typeof(Margins).GetConstructor(new Type[] {
                    typeof(int), typeof(int), typeof(int), typeof(int)});
                    
                if (ctor != null) {
                    return new InstanceDescriptor(ctor, new object[] {
                        margins.Left, margins.Right, margins.Top, margins.Bottom});
                }
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\MarginsConverter.uex' path='docs/doc[@for="MarginsConverter.CreateInstance"]/*' />
        /// <devdoc>
        ///      Creates an instance of this type given a set of property values
        ///      for the object.  This is useful for objects that are immutable, but still
        ///      want to provide changable properties.
        /// </devdoc>
        public override object CreateInstance(ITypeDescriptorContext context, IDictionary propertyValues) {
            return new Margins((int)propertyValues["Left"],
                               (int)propertyValues["Right"],
                               (int)propertyValues["Top"],
                               (int)propertyValues["Bottom"]);
        }

        /// <include file='doc\MarginsConverter.uex' path='docs/doc[@for="MarginsConverter.GetCreateInstanceSupported"]/*' />
        /// <devdoc>
        ///      Determines if changing a value on this object should require a call to
        ///      CreateInstance to create a new value.
        /// </devdoc>
        public override bool GetCreateInstanceSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\invalidprinterexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="InvalidPrinterException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Drawing.Printing {

    using System.Diagnostics;
    using System;
    using System.Security;
    using System.Runtime.Serialization;
    using System.ComponentModel;
    using System.Runtime.InteropServices;
    using Microsoft.Win32;

    /// <include file='doc\InvalidPrinterException.uex' path='docs/doc[@for="InvalidPrinterException"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents
    ///       the
    ///       exception that is thrown when trying to access a printer using invalid printer settings.
    ///    </para>
    /// </devdoc>
    public class InvalidPrinterException : SystemException {
        private PrinterSettings settings;

        /// <include file='doc\InvalidPrinterException.uex' path='docs/doc[@for="InvalidPrinterException.InvalidPrinterException"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Printing.InvalidPrinterException'/> class.
        ///    </para>
        /// </devdoc>
        public InvalidPrinterException(PrinterSettings settings) 
        : base(GenerateMessage(settings)) 
        {
            this.settings = settings;
        }

        /// <include file='doc\InvalidPrinterException.uex' path='docs/doc[@for="InvalidPrinterException.InvalidPrinterException1"]/*' />
        protected InvalidPrinterException(SerializationInfo info, StreamingContext context) : base (info, context) {
            settings = (PrinterSettings)info.GetValue("settings", typeof(PrinterSettings));
        }

        /// <include file='doc\InvalidPrinterException.uex' path='docs/doc[@for="InvalidPrinterException.GetObjectData"]/*' />
        public override void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info==null) {
                throw new ArgumentNullException("info");
            }
            IntSecurity.AllPrinting.Demand();
            info.AddValue("settings", settings);
            base.GetObjectData(info, context);
        }

        static string GenerateMessage(PrinterSettings settings) {
            if (settings.IsDefaultPrinter) {
                return SR.GetString(SR.InvalidPrinterException_NoDefaultPrinter);
            }
            else {
                try {
                    return SR.GetString(SR.InvalidPrinterException_InvalidPrinter, settings.PrinterName);
                }
                catch (SecurityException) {
                    return SR.GetString(SR.InvalidPrinterException_InvalidPrinter, SR.GetString(SR.CantTellPrinterName));
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\duplex.cs ===
//------------------------------------------------------------------------------
// <copyright file="Duplex.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {

    using System.Diagnostics;
    using System;
    using System.Runtime.InteropServices;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\Duplex.uex' path='docs/doc[@for="Duplex"]/*' />
    /// <devdoc>
    ///    <para>Specifies the printer's duplex setting.</para>
    /// </devdoc>
    public enum Duplex {
        /// <include file='doc\Duplex.uex' path='docs/doc[@for="Duplex.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The printer's default duplex setting.
        ///    </para>
        /// </devdoc>
        Default = -1,

        /// <include file='doc\Duplex.uex' path='docs/doc[@for="Duplex.Simplex"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Single-sided printing.
        ///    </para>
        /// </devdoc>
        Simplex = SafeNativeMethods.DMDUP_SIMPLEX,

        /// <include file='doc\Duplex.uex' path='docs/doc[@for="Duplex.Horizontal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Double-sided, horizontal printing.
        ///       
        ///    </para>
        /// </devdoc>
        Horizontal = SafeNativeMethods.DMDUP_HORIZONTAL,

        /// <include file='doc\Duplex.uex' path='docs/doc[@for="Duplex.Vertical"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Double-sided, vertical printing.
        ///       
        ///    </para>
        /// </devdoc>
        Vertical = SafeNativeMethods.DMDUP_VERTICAL,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\margins.cs ===
//------------------------------------------------------------------------------
// <copyright file="Margins.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {
    using System.Runtime.Serialization.Formatters;

    using System.Diagnostics;
    using System;
    using System.Runtime.InteropServices;
    using System.Drawing;
    using Microsoft.Win32;
    using System.ComponentModel;

    /// <include file='doc\Margins.uex' path='docs/doc[@for="Margins"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the margins of a printed page.
    ///    </para>
    /// </devdoc>
    [TypeConverterAttribute(typeof(MarginsConverter))]
    public class Margins : ICloneable {
        private int left;
        private int right;
        private int top;
        private int bottom;

        /// <include file='doc\Margins.uex' path='docs/doc[@for="Margins.Margins"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of a the <see cref='System.Drawing.Printing.Margins'/> class with one-inch margins.
        ///    </para>
        /// </devdoc>
        public Margins() : this(100, 100, 100, 100) {
        }

        /// <include file='doc\Margins.uex' path='docs/doc[@for="Margins.Margins1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of a the <see cref='System.Drawing.Printing.Margins'/> class with the specified left, right, top, and bottom
        ///       margins.
        ///    </para>
        /// </devdoc>
        public Margins(int left, int right, int top, int bottom) {
            CheckMargin(left, "left");
            CheckMargin(right, "right");
            CheckMargin(top, "top");
            CheckMargin(bottom, "bottom");

            this.left = left;
            this.right = right;
            this.top = top;
            this.bottom = bottom;
        }

        /// <include file='doc\Margins.uex' path='docs/doc[@for="Margins.Left"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the left margin, in hundredths of an inch.
        ///    </para>
        /// </devdoc>
        public int Left {
            get { return left;}
            set { 
                CheckMargin(value, "Left");
                left = value;
            }
        }

        /// <include file='doc\Margins.uex' path='docs/doc[@for="Margins.Right"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the right margin, in hundredths of an inch.
        ///    </para>
        /// </devdoc>
        public int Right {
            get { return right;}
            set { 
                CheckMargin(value, "Right");
                right = value;
            }
        }

        /// <include file='doc\Margins.uex' path='docs/doc[@for="Margins.Top"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the top margin, in hundredths of an inch.
        ///    </para>
        /// </devdoc>
        public int Top {
            get { return top;}
            set { 
                CheckMargin(value, "Top");
                top = value;
            }
        }

        /// <include file='doc\Margins.uex' path='docs/doc[@for="Margins.Bottom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the bottom margin, in hundredths of an inch.
        ///    </para>
        /// </devdoc>
        public int Bottom {
            get { return bottom;}
            set { 
                CheckMargin(value, "Bottom");
                bottom = value;
            }
        }

        private void CheckMargin(int margin, string name) {
            if (margin < 0)
                throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx, name, margin, "0"));
        }

        /// <include file='doc\Margins.uex' path='docs/doc[@for="Margins.Clone"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Retrieves a duplicate of this object, member by member.
        ///    </para>
        /// </devdoc>
        public object Clone() {
            return MemberwiseClone();
        }

        /// <include file='doc\Margins.uex' path='docs/doc[@for="Margins.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compares this <see cref='System.Drawing.Printing.Margins'/> to a specified <see cref='System.Drawing.Printing.Margins'/> to see whether they
        ///       are equal.
        ///    </para>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (obj == this) return true;
            if (!(obj is Margins)) return false;
            Margins margins = (Margins)obj;
            return margins.left == this.left
            && margins.right == this.right
            && margins.top == this.top
            && margins.bottom == this.bottom;
        }

        /// <include file='doc\Margins.uex' path='docs/doc[@for="Margins.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Calculates and retrieves a hash code based on the left, right, top, and bottom
        ///       margins.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            // return HashCodes.Combine(left, right, top, bottom);
            uint left = (uint) this.left;
            uint right = (uint) this.right;
            uint top = (uint) this.top;
            uint bottom = (uint) this.bottom;

            uint result =  left ^
                           ((right << 13) | (right >> 19)) ^
                           ((top << 26) | (top >>  6)) ^
                           ((bottom <<  7) | (bottom >> 25));

            return(int) result;
        }

        /// <include file='doc\Margins.uex' path='docs/doc[@for="Margins.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Provides some interesting information for the Margins in
        ///       String form.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            return "[Margins"
            + " Left=" + Left.ToString()
            + " Right=" + Right.ToString()
            + " Top=" + Top.ToString()
            + " Bottom=" + Bottom.ToString()
            + "]";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\pagesettings.cs ===
//------------------------------------------------------------------------------
// <copyright file="PageSettings.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;    
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\PageSettings.uex' path='docs/doc[@for="PageSettings"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies
    ///       settings that apply to a single page.
    ///    </para>
    /// </devdoc>
#if !CPB        // cpb 50004
    [ComVisible(false)]
#endif
    public class PageSettings : ICloneable {
        internal PrinterSettings printerSettings;

        private TriState color = TriState.Default;
        private PaperSize paperSize;
        private PaperSource paperSource;
        private PrinterResolution printerResolution;
        private TriState landscape = TriState.Default;
        private Margins margins = new Margins();

        /// <include file='doc\PageSettings.uex' path='docs/doc[@for="PageSettings.PageSettings"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Printing.PageSettings'/> class using
        ///       the default printer.
        ///    </para>
        /// </devdoc>
        public PageSettings() : this(new PrinterSettings()) {
        }

        /// <include file='doc\PageSettings.uex' path='docs/doc[@for="PageSettings.PageSettings1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Drawing.Printing.PageSettings'/> class using
        ///    the specified printer.</para>
        /// </devdoc>
        public PageSettings(PrinterSettings printerSettings) {
            Debug.Assert(printerSettings != null, "printerSettings == null");
            this.printerSettings = printerSettings;
        }

        /// <include file='doc\PageSettings.uex' path='docs/doc[@for="PageSettings.Bounds"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the bounds of the page, taking into account the Landscape property.
        ///    </para>
        /// </devdoc>
        public Rectangle Bounds {
            get {
                IntSecurity.AllPrintingAndUnmanagedCode.Assert();

                IntPtr modeHandle = printerSettings.GetHdevmode();

                Rectangle pageBounds = GetBounds(modeHandle);

                SafeNativeMethods.GlobalFree(new HandleRef(this, modeHandle));
                return pageBounds;
            }
        }

        /// <include file='doc\PageSettings.uex' path='docs/doc[@for="PageSettings.Color"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the page is printed in color.
        ///    </para>
        /// </devdoc>
        public bool Color {
            get {
                if (color.IsDefault)
                    return printerSettings.GetModeField(ModeField.Color, SafeNativeMethods.DMCOLOR_MONOCHROME) == SafeNativeMethods.DMCOLOR_COLOR;
                else
                    return(bool) color;
            }
            set { color = value;}
        }

        /// <include file='doc\PageSettings.uex' path='docs/doc[@for="PageSettings.Landscape"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the page should be printed in landscape or portrait orientation.
        ///    </para>
        /// </devdoc>
        public bool Landscape {
            get {
                if (landscape.IsDefault)
                    return printerSettings.GetModeField(ModeField.Orientation, SafeNativeMethods.DMORIENT_PORTRAIT) == SafeNativeMethods.DMORIENT_LANDSCAPE;
                else
                    return(bool) landscape;
            }
            set { landscape = value;}
        }

        /// <include file='doc\PageSettings.uex' path='docs/doc[@for="PageSettings.Margins"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating the margins for this page.
        ///       
        ///    </para>
        /// </devdoc>
        public Margins Margins {
            get { return margins;}
            set { margins = value;}
        }

        /// <include file='doc\PageSettings.uex' path='docs/doc[@for="PageSettings.PaperSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the paper size.
        ///    </para>
        /// </devdoc>
        public PaperSize PaperSize {
            get {
                IntSecurity.AllPrintingAndUnmanagedCode.Assert();
                return GetPaperSize(IntPtr.Zero);
            }
            set { paperSize = value;}
        }

        /// <include file='doc\PageSettings.uex' path='docs/doc[@for="PageSettings.PaperSource"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating the paper source (i.e. upper bin).
        ///       
        ///    </para>
        /// </devdoc>
        public PaperSource PaperSource {
            get {
                if (paperSource == null) {
                    IntSecurity.AllPrintingAndUnmanagedCode.Assert();

                    IntPtr modeHandle = printerSettings.GetHdevmode();
                    IntPtr modePointer = SafeNativeMethods.GlobalLock(new HandleRef(this, modeHandle));
                    SafeNativeMethods.DEVMODE mode = (SafeNativeMethods.DEVMODE) UnsafeNativeMethods.PtrToStructure(modePointer, typeof(SafeNativeMethods.DEVMODE));

                    PaperSource result = PaperSourceFromMode(mode);

                    SafeNativeMethods.GlobalUnlock(new HandleRef(this, modeHandle));
                    SafeNativeMethods.GlobalFree(new HandleRef(this, modeHandle));

                    return result;
                }
                else
                    return paperSource;
            }
            set { paperSource = value;}
        }

        /// <include file='doc\PageSettings.uex' path='docs/doc[@for="PageSettings.PrinterResolution"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the printer resolution for the page.
        ///    </para>
        /// </devdoc>
        public PrinterResolution PrinterResolution {
            get {
                if (printerResolution == null) {
                    IntSecurity.AllPrintingAndUnmanagedCode.Assert();

                    IntPtr modeHandle = printerSettings.GetHdevmode();
                    IntPtr modePointer = SafeNativeMethods.GlobalLock(new HandleRef(this, modeHandle));
                    SafeNativeMethods.DEVMODE mode = (SafeNativeMethods.DEVMODE) UnsafeNativeMethods.PtrToStructure(modePointer, typeof(SafeNativeMethods.DEVMODE));

                    PrinterResolution result = PrinterResolutionFromMode(mode);

                    SafeNativeMethods.GlobalUnlock(new HandleRef(this, modeHandle));
                    SafeNativeMethods.GlobalFree(new HandleRef(this, modeHandle));

                    return result;
                }
                else
                    return printerResolution;
            }
            set {
                printerResolution = value;
            }
        }

        /// <include file='doc\PageSettings.uex' path='docs/doc[@for="PageSettings.PrinterSettings"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the
        ///       associated printer settings.
        ///    </para>
        /// </devdoc>
        public PrinterSettings PrinterSettings {
            get { return printerSettings;}
            set { 
                if (value == null)
                    value = new PrinterSettings();
                printerSettings = value;
            }
        }

        /// <include file='doc\PageSettings.uex' path='docs/doc[@for="PageSettings.Clone"]/*' />
        /// <devdoc>
        ///     Copies the settings and margins.
        /// </devdoc>
        public object Clone() {
            PageSettings result = (PageSettings) MemberwiseClone();
            result.margins = (Margins) margins.Clone();
            return result;
        }

        /// <include file='doc\PageSettings.uex' path='docs/doc[@for="PageSettings.CopyToHdevmode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Copies the relevant information out of the PageSettings and into the handle.
        ///    </para>
        /// </devdoc>
        public void CopyToHdevmode(IntPtr hdevmode) {
            IntSecurity.AllPrinting.Demand();

            IntPtr modePointer = SafeNativeMethods.GlobalLock(new HandleRef(null, hdevmode));
            SafeNativeMethods.DEVMODE mode = (SafeNativeMethods.DEVMODE) UnsafeNativeMethods.PtrToStructure(modePointer, typeof(SafeNativeMethods.DEVMODE));

            if (color.IsNotDefault)
                mode.dmColor = (short) (((bool) color) ? SafeNativeMethods.DMCOLOR_COLOR : SafeNativeMethods.DMCOLOR_MONOCHROME);
            if (landscape.IsNotDefault)
                mode.dmOrientation = (short) (((bool) landscape) ? SafeNativeMethods.DMORIENT_LANDSCAPE : SafeNativeMethods.DMORIENT_PORTRAIT);

            if (paperSize != null) {
                mode.dmPaperSize = (short) paperSize.RawKind;
                mode.dmPaperLength = (short) paperSize.Height;
                mode.dmPaperWidth = (short) paperSize.Width;
            }

            if (paperSource != null) {
                mode.dmDefaultSource = (short) paperSource.RawKind;
            }

            if (printerResolution != null) {
                if (printerResolution.Kind == PrinterResolutionKind.Custom) {
                    mode.dmPrintQuality = (short) printerResolution.X;
                    mode.dmYResolution = (short) printerResolution.Y;
                }
                else {
                    mode.dmPrintQuality = (short) printerResolution.Kind;
                }
            }

            Marshal.StructureToPtr(mode, modePointer, false);
            SafeNativeMethods.GlobalUnlock(new HandleRef(null, hdevmode));
        }

        // This function shows up big on profiles, so we need to make it fast
        internal Rectangle GetBounds(IntPtr modeHandle) {
            Rectangle pageBounds;
            PaperSize size = GetPaperSize(modeHandle);
            if (GetLandscape(modeHandle))
                pageBounds = new Rectangle(0, 0, size.Height, size.Width);
            else
                pageBounds = new Rectangle(0, 0, size.Width, size.Height);

            return pageBounds;
        }

        private bool GetLandscape(IntPtr modeHandle) {
            if (landscape.IsDefault)
                return printerSettings.GetModeField(ModeField.Orientation, SafeNativeMethods.DMORIENT_PORTRAIT, modeHandle) == SafeNativeMethods.DMORIENT_LANDSCAPE;
            else
                return(bool) landscape;
        }

        private PaperSize GetPaperSize(IntPtr modeHandle) {
            if (paperSize == null) {
                bool ownHandle = false;
                if (modeHandle == IntPtr.Zero) {
                    modeHandle = printerSettings.GetHdevmode();
                    ownHandle = true;
                }

                IntPtr modePointer = SafeNativeMethods.GlobalLock(new HandleRef(null, modeHandle));
                SafeNativeMethods.DEVMODE mode = (SafeNativeMethods.DEVMODE) UnsafeNativeMethods.PtrToStructure(modePointer, typeof(SafeNativeMethods.DEVMODE));

                PaperSize result = PaperSizeFromMode(mode);

                SafeNativeMethods.GlobalUnlock(new HandleRef(null, modeHandle));

                if (ownHandle)
                    SafeNativeMethods.GlobalFree(new HandleRef(null, modeHandle));

                return result;
            }
            else
                return paperSize;
        }

        private PaperSize PaperSizeFromMode(SafeNativeMethods.DEVMODE mode) {
            PaperSize[] sizes = printerSettings.Get_PaperSizes();
            for (int i = 0; i < sizes.Length; i++) {
                if ((int)sizes[i].RawKind == mode.dmPaperSize)
                    return sizes[i];
            }
            return new PaperSize((PaperKind) mode.dmPaperSize, "custom",
                                 mode.dmPaperWidth, mode.dmPaperLength);
        }

        private PaperSource PaperSourceFromMode(SafeNativeMethods.DEVMODE mode) {
            PaperSource[] sources = printerSettings.Get_PaperSources();
            for (int i = 0; i < sources.Length; i++) {
                
                // the dmDefaultSource == to the RawKind in the Papersource.. and Not the Kind...
                // if the PaperSource is populated with CUSTOM values...

                if ((short)sources[i].RawKind == mode.dmDefaultSource)
                    return sources[i];
            }
            return new PaperSource((PaperSourceKind) mode.dmDefaultSource, "unknown");
        }

        private PrinterResolution PrinterResolutionFromMode(SafeNativeMethods.DEVMODE mode) {
            PrinterResolution[] resolutions = printerSettings.Get_PrinterResolutions();
            for (int i = 0; i < resolutions.Length; i++) {
                if (mode.dmPrintQuality >= 0) {
                    if (resolutions[i].X == (int)(PrinterResolutionKind) mode.dmPrintQuality
                        && resolutions[i].Y == (int)(PrinterResolutionKind) mode.dmYResolution)
                        return resolutions[i];
                }
                else {
                    if (resolutions[i].Kind == (PrinterResolutionKind) mode.dmPrintQuality)
                        return resolutions[i];
                }
            }
            return new PrinterResolution(PrinterResolutionKind.Custom,
                                         mode.dmPrintQuality, mode.dmYResolution);
        }

        /// <include file='doc\PageSettings.uex' path='docs/doc[@for="PageSettings.SetHdevmode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Copies the relevant information out of the handle and into the PageSettings.
        ///    </para>
        /// </devdoc>
        public void SetHdevmode(IntPtr hdevmode) {
            IntSecurity.AllPrinting.Demand();

            if (hdevmode == IntPtr.Zero)
                throw new ArgumentException(SR.GetString(SR.InvalidPrinterHandle, hdevmode));

            IntPtr pointer = SafeNativeMethods.GlobalLock(new HandleRef(null, hdevmode));
            SafeNativeMethods.DEVMODE mode = (SafeNativeMethods.DEVMODE) UnsafeNativeMethods.PtrToStructure(pointer, typeof(SafeNativeMethods.DEVMODE));

            color = (mode.dmColor == SafeNativeMethods.DMCOLOR_COLOR);
            landscape = (mode.dmOrientation == SafeNativeMethods.DMORIENT_LANDSCAPE);
            paperSize = PaperSizeFromMode(mode);
            paperSource = PaperSourceFromMode(mode);
            printerResolution = PrinterResolutionFromMode(mode);

            SafeNativeMethods.GlobalUnlock(new HandleRef(null, hdevmode));
        }

        /// <include file='doc\PageSettings.uex' path='docs/doc[@for="PageSettings.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Provides some interesting information about the PageSettings in
        ///       String form.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            return "[PageSettings:"
            + " Color=" + Color.ToString()
            + ", Landscape=" + Landscape.ToString()
            + ", Margins=" + Margins.ToString()
            + ", PaperSize=" + PaperSize.ToString()
            + ", PaperSource=" + PaperSource.ToString()
            + ", PrinterResolution=" + PrinterResolution.ToString()
            + "]";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\papersource.cs ===
//------------------------------------------------------------------------------
// <copyright file="PaperSource.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;    
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\PaperSource.uex' path='docs/doc[@for="PaperSource"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the paper tray from which the printer gets paper.
    ///    </para>
    /// </devdoc>
    public class PaperSource {
        private string name;
        private PaperSourceKind kind;

        internal PaperSource(PaperSourceKind kind, string name) {
            this.kind = kind;
            this.name = name;
        }

        /// <include file='doc\PaperSource.uex' path='docs/doc[@for="PaperSource.Kind"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       a value indicating the type of paper source.
        ///       
        ///    </para>
        /// </devdoc>
        public PaperSourceKind Kind {
            get {
                if (((int) kind) >= SafeNativeMethods.DMBIN_USER)
                    return PaperSourceKind.Custom;
                else
                    return kind;
            }
        }

        internal PaperSourceKind RawKind {
            get { return kind;}
        }

        /// <include file='doc\PaperSource.uex' path='docs/doc[@for="PaperSource.SourceName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the paper source.
        ///    </para>
        /// </devdoc>
        public string SourceName {
            get { return name;}
        }

        /// <include file='doc\PaperSource.uex' path='docs/doc[@for="PaperSource.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Provides some interesting information about the PaperSource in
        ///       String form.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            return "[PaperSource " + SourceName
            + " Kind=" + TypeDescriptor.GetConverter(typeof(PaperSourceKind)).ConvertToString(Kind)
            + "]";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\previewpageinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="PreviewPageInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {

    using System.Diagnostics;
    using System;
    using System.Drawing;

    /// <include file='doc\PreviewPageInfo.uex' path='docs/doc[@for="PreviewPageInfo"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies print preview information for
    ///       a single page. This class cannot be inherited.
    ///    </para>
    /// </devdoc>
    public sealed class PreviewPageInfo {
        private Image image;

        // Physical measures in hundredths of an inch
        private Size physicalSize = Size.Empty;

        /// <include file='doc\PreviewPageInfo.uex' path='docs/doc[@for="PreviewPageInfo.PreviewPageInfo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Printing.PreviewPageInfo'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public PreviewPageInfo(Image image, Size physicalSize) {
            this.image = image;
            this.physicalSize = physicalSize;
        }

        /// <include file='doc\PreviewPageInfo.uex' path='docs/doc[@for="PreviewPageInfo.Image"]/*' />
        /// <devdoc>
        ///    <para>Gets the image of the printed page.</para>
        /// </devdoc>
        public Image Image {
            get { return image;}
        }

        // Physical measures in hundredths of an inch
        /// <include file='doc\PreviewPageInfo.uex' path='docs/doc[@for="PreviewPageInfo.PhysicalSize"]/*' />
        /// <devdoc>
        ///    <para> Gets the size of the printed page, in hundredths of an inch.</para>
        /// </devdoc>
        public Size PhysicalSize {
            get { return physicalSize;}
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\papersourcekind.cs ===
//------------------------------------------------------------------------------
// <copyright file="PaperSourceKind.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {

    using System.Diagnostics;
    using System;
    using System.Runtime.InteropServices;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\PaperSourceKind.uex' path='docs/doc[@for="PaperSourceKind"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Standard paper sources.
    ///    </para>
    /// </devdoc>
    public enum PaperSourceKind {
        // Please keep these in SafeNativeMethods.cs order
        
        /// <include file='doc\PaperSourceKind.uex' path='docs/doc[@for="PaperSourceKind.Upper"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The upper bin of a printer (or, if the printer only has one bin, the only bin).
        ///    </para>
        /// </devdoc>
        Upper = SafeNativeMethods.DMBIN_UPPER,
        
        /// <include file='doc\PaperSourceKind.uex' path='docs/doc[@for="PaperSourceKind.Lower"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The lower bin of a printer.
        ///    </para>
        /// </devdoc>
        Lower = SafeNativeMethods.DMBIN_LOWER,
        
        /// <include file='doc\PaperSourceKind.uex' path='docs/doc[@for="PaperSourceKind.Middle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The middle bin of a printer.
        ///    </para>
        /// </devdoc>
        Middle = SafeNativeMethods.DMBIN_MIDDLE,
        
        /// <include file='doc\PaperSourceKind.uex' path='docs/doc[@for="PaperSourceKind.Manual"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Manually-fed paper.
        ///    </para>
        /// </devdoc>
        Manual = SafeNativeMethods.DMBIN_MANUAL,
        
        /// <include file='doc\PaperSourceKind.uex' path='docs/doc[@for="PaperSourceKind.Envelope"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An envelope.
        ///       
        ///    </para>
        /// </devdoc>
        Envelope = SafeNativeMethods.DMBIN_ENVELOPE,
        
        /// <include file='doc\PaperSourceKind.uex' path='docs/doc[@for="PaperSourceKind.ManualFeed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A manually-fed envelope.
        ///    </para>
        /// </devdoc>
        ManualFeed = SafeNativeMethods.DMBIN_ENVMANUAL,
        
        /// <include file='doc\PaperSourceKind.uex' path='docs/doc[@for="PaperSourceKind.AutomaticFeed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Automatic-fed paper.
        ///       
        ///    </para>
        /// </devdoc>
        AutomaticFeed = SafeNativeMethods.DMBIN_AUTO,
        
        /// <include file='doc\PaperSourceKind.uex' path='docs/doc[@for="PaperSourceKind.TractorFeed"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A tractor feed.
        ///    </para>
        /// </devdoc>
        TractorFeed = SafeNativeMethods.DMBIN_TRACTOR,
        
        /// <include file='doc\PaperSourceKind.uex' path='docs/doc[@for="PaperSourceKind.SmallFormat"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Small-format paper.
        ///    </para>
        /// </devdoc>
        SmallFormat = SafeNativeMethods.DMBIN_SMALLFMT,
        
        /// <include file='doc\PaperSourceKind.uex' path='docs/doc[@for="PaperSourceKind.LargeFormat"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Large-format paper.
        ///    </para>
        /// </devdoc>
        LargeFormat = SafeNativeMethods.DMBIN_LARGEFMT,
        
        /// <include file='doc\PaperSourceKind.uex' path='docs/doc[@for="PaperSourceKind.LargeCapacity"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A large-capacity
        ///       bin a printer.
        ///       
        ///    </para>
        /// </devdoc>
        LargeCapacity = SafeNativeMethods.DMBIN_LARGECAPACITY,
        
        /// <include file='doc\PaperSourceKind.uex' path='docs/doc[@for="PaperSourceKind.Cassette"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A paper cassette.
        ///    </para>
        /// </devdoc>
        Cassette = SafeNativeMethods.DMBIN_CASSETTE,
        
        /// <include file='doc\PaperSourceKind.uex' path='docs/doc[@for="PaperSourceKind.FormSource"]/*' />
        /// <devdoc>
        /// </devdoc>
        FormSource = SafeNativeMethods.DMBIN_FORMSOURCE,

        /// <include file='doc\PaperSourceKind.uex' path='docs/doc[@for="PaperSourceKind.Custom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A printer-specific paper source.
        ///    </para>
        /// </devdoc>
        Custom = SafeNativeMethods.DMBIN_USER + 1,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\printcontroller.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrintController.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {

    using Microsoft.Win32;
    using System;
    using System.Diagnostics;
    using System.Drawing;
    using System.Runtime.InteropServices;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\PrintController.uex' path='docs/doc[@for="PrintController"]/*' />
    /// <devdoc>
    ///    <para>Controls how a document is printed.</para>
    /// </devdoc>
    public abstract class PrintController {
        // DEVMODEs are pretty expensive, so we cache one here and share it with the 
        // Standard and Preview print controllers.  If it weren't for all the rules about API changes,
        // I'd consider making this protected.
        internal IntPtr modeHandle = IntPtr.Zero; // initialized in StartPrint

        /// <include file='doc\PrintController.uex' path='docs/doc[@for="PrintController.PrintController"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Printing.PrintController'/> class.
        ///    </para>
        /// </devdoc>
        public PrintController() {
            IntSecurity.SafePrinting.Demand();
        }

        // WARNING: if you have nested PrintControllers, this method won't get called on the inner one.
        // Add initialization code to StartPrint or StartPage instead.
        internal void Print(PrintDocument document) {
            IntSecurity.SafePrinting.Demand();
            // Most of the printing security is left to the individual print controller

            // Check that user has permission to print to this particular printer
            PrintEventArgs printEvent = new PrintEventArgs();
            document._OnBeginPrint(printEvent);
            if (printEvent.Cancel) return;

            OnStartPrint(document, printEvent);
            bool canceled = true;

            try {
                canceled = PrintLoop(document);
            }
            finally {
                try {
                    try {
                        document._OnEndPrint(printEvent);
                        printEvent.Cancel = canceled | printEvent.Cancel;
                    }
                    finally {
                        OnEndPrint(document, printEvent);
                    }
                }
                finally {
                    if (!IntSecurity.HasPermission(IntSecurity.AllPrinting)) {
                        // Ensure programs with SafePrinting only get to print once for each time they
                        // throw up the PrintDialog.
                        IntSecurity.AllPrinting.Assert();
                        document.PrinterSettings.PrintDialogDisplayed = false;
                    }
                }
            }
        }

        // Returns true if print was aborted.
        // WARNING: if you have nested PrintControllers, this method won't get called on the inner one
        // Add initialization code to StartPrint or StartPage instead.
        private bool PrintLoop(PrintDocument document) {
            QueryPageSettingsEventArgs queryEvent = new QueryPageSettingsEventArgs((PageSettings) document.DefaultPageSettings.Clone());
            for (;;) {
                document._OnQueryPageSettings(queryEvent);
                if (queryEvent.Cancel) {
                    return true;
                }

                PrintPageEventArgs pageEvent = CreatePrintPageEvent(queryEvent.PageSettings);
                Graphics graphics = OnStartPage(document, pageEvent);
                pageEvent.SetGraphics(graphics);

                try {
                    document._OnPrintPage(pageEvent);
                    OnEndPage(document, pageEvent);
                }
                finally {
                    pageEvent.Dispose();
                }

                if (pageEvent.Cancel) {
                    return true;
                }
                else if (!pageEvent.HasMorePages) {
                    return false;
                }
                else {
                    // loop
                }
            }
        }

        private PrintPageEventArgs CreatePrintPageEvent(PageSettings pageSettings) {
            IntSecurity.AllPrintingAndUnmanagedCode.Assert();

            Debug.Assert(modeHandle != IntPtr.Zero, "modeHandle is null.  Someone must have forgot to call base.StartPrint");
            Rectangle pageBounds = pageSettings.GetBounds(modeHandle);

            Rectangle marginBounds = new Rectangle(pageSettings.Margins.Left, 
                                                   pageSettings.Margins.Top, 
                                                   pageBounds.Width - (pageSettings.Margins.Left + pageSettings.Margins.Right), 
                                                   pageBounds.Height - (pageSettings.Margins.Top + pageSettings.Margins.Bottom));

            PrintPageEventArgs pageEvent = new PrintPageEventArgs(null, marginBounds, pageBounds, pageSettings);
            return pageEvent;
        }


        /// <include file='doc\PrintController.uex' path='docs/doc[@for="PrintController.OnStartPrint"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, begins the control sequence of when and how to print a document.</para>
        /// </devdoc>
        public virtual void OnStartPrint(PrintDocument document, PrintEventArgs e) {
            IntSecurity.AllPrintingAndUnmanagedCode.Assert();
            modeHandle = document.PrinterSettings.GetHdevmode(document.DefaultPageSettings);
        }

        /// <include file='doc\PrintController.uex' path='docs/doc[@for="PrintController.OnStartPage"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, begins the control 
        ///       sequence of when and how to print a page in a document.</para>
        /// </devdoc>
        public virtual Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e) {
            return null;
        }

        /// <include file='doc\PrintController.uex' path='docs/doc[@for="PrintController.OnEndPage"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, completes the control sequence of when and how 
        ///       to print a page in a document.</para>
        /// </devdoc>
        public virtual void OnEndPage(PrintDocument document, PrintPageEventArgs e) {
        }

        /// <include file='doc\PrintController.uex' path='docs/doc[@for="PrintController.OnEndPrint"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, completes the 
        ///       control sequence of when and how to print a document.</para>
        /// </devdoc>
        public virtual void OnEndPrint(PrintDocument document, PrintEventArgs e) {
            IntSecurity.UnmanagedCode.Assert();

            Debug.Assert(modeHandle != IntPtr.Zero, "modeHandle is null.  Someone must have forgot to call base.StartPrint");
            SafeNativeMethods.GlobalFree(new HandleRef(this, modeHandle));
            modeHandle = IntPtr.Zero;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\paperkinds.cs ===
//------------------------------------------------------------------------------
// <copyright file="PaperKinds.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {

    using System.Diagnostics;
    using System;
    using System.Runtime.InteropServices;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the standard paper sizes.
    ///    </para>
    /// </devdoc>
    public enum PaperKind {
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Custom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The paper size is defined by the user.
        ///    </para>
        /// </devdoc>
        Custom = 0,

        // I got this information from two places: MSDN's writeup of DEVMODE 
        // (http://msdn.microsoft.com/library/psdk/gdi/prntspol_8nle.htm), 
        // and the raw C++ header file (wingdi.h).  Beyond that, your guess
        // is as good as mine as to what these members mean.


        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Letter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Letter paper (8.5 in.
        ///       by 11 in.).
        ///    </para>
        /// </devdoc>
        Letter = SafeNativeMethods.DMPAPER_LETTER,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Legal"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Legal paper (8.5 in.
        ///       by 14
        ///       in.).
        ///    </para>
        /// </devdoc>
        Legal = SafeNativeMethods.DMPAPER_LEGAL,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.A4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A4 paper (210
        ///       mm by 297
        ///       mm).
        ///    </para>
        /// </devdoc>
        A4 = SafeNativeMethods.DMPAPER_A4,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.CSheet"]/*' />
        /// <devdoc>
        ///    C paper (17 in. by 22 in.).
        /// </devdoc>
        CSheet = SafeNativeMethods.DMPAPER_CSHEET,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.DSheet"]/*' />
        /// <devdoc>
        ///    <para>
        ///       D paper (22
        ///       in. by 34 in.).
        ///    </para>
        /// </devdoc>
        DSheet = SafeNativeMethods.DMPAPER_DSHEET,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.ESheet"]/*' />
        /// <devdoc>
        ///    <para>
        ///       E paper (34
        ///       in. by 44 in.).
        ///    </para>
        /// </devdoc>
        ESheet = SafeNativeMethods.DMPAPER_ESHEET,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.LetterSmall"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Letter small paper (8.5 in. by 11 in.).
        ///    </para>
        /// </devdoc>
        LetterSmall = SafeNativeMethods.DMPAPER_LETTERSMALL,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Tabloid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tabloid paper (11
        ///       in. by 17 in.).
        ///    </para>
        /// </devdoc>
        Tabloid = SafeNativeMethods.DMPAPER_TABLOID,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Ledger"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Ledger paper (17
        ///       in. by 11 in.).
        ///    </para>
        /// </devdoc>
        Ledger = SafeNativeMethods.DMPAPER_LEDGER,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Statement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Statement paper (5.5
        ///       in. by 8.5 in.).
        ///    </para>
        /// </devdoc>
        Statement = SafeNativeMethods.DMPAPER_STATEMENT,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Executive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Executive paper (7.25
        ///       in. by 10.5
        ///       in.).
        ///    </para>
        /// </devdoc>
        Executive = SafeNativeMethods.DMPAPER_EXECUTIVE,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.A3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A3 paper
        ///       (297 mm by 420 mm).
        ///    </para>
        /// </devdoc>
        A3 = SafeNativeMethods.DMPAPER_A3,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.A4Small"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A4 small paper
        ///       (210 mm by 297 mm).
        ///    </para>
        /// </devdoc>
        A4Small = SafeNativeMethods.DMPAPER_A4SMALL,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.A5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A5 paper (148
        ///       mm by 210
        ///       mm).
        ///    </para>
        /// </devdoc>
        A5 = SafeNativeMethods.DMPAPER_A5,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.B4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       B4 paper (250 mm by 353 mm).
        ///    </para>
        /// </devdoc>
        B4 = SafeNativeMethods.DMPAPER_B4,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.B5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       B5 paper (176
        ///       mm by 250 mm).
        ///    </para>
        /// </devdoc>
        B5 = SafeNativeMethods.DMPAPER_B5,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Folio"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Folio paper (8.5
        ///       in. by 13 in.).
        ///    </para>
        /// </devdoc>
        Folio = SafeNativeMethods.DMPAPER_FOLIO,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Quarto"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Quarto paper (215
        ///       mm by 275 mm).
        ///    </para>
        /// </devdoc>
        Quarto = SafeNativeMethods.DMPAPER_QUARTO,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Standard10x14"]/*' />
        /// <devdoc>
        ///    <para>
        ///       10-by-14-inch paper.
        ///       
        ///    </para>
        /// </devdoc>
        Standard10x14 = SafeNativeMethods.DMPAPER_10X14,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Standard11x17"]/*' />
        /// <devdoc>
        ///    <para>
        ///       11-by-17-inch paper.
        ///       
        ///    </para>
        /// </devdoc>
        Standard11x17 = SafeNativeMethods.DMPAPER_11X17,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Note"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Note paper (8.5 in.
        ///       by 11 in.).
        ///    </para>
        /// </devdoc>
        Note = SafeNativeMethods.DMPAPER_NOTE,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Number9Envelope"]/*' />
        /// <devdoc>
        ///    <para>
        ///       #9 envelope (3.875
        ///       in. by 8.875 in.).
        ///    </para>
        /// </devdoc>
        Number9Envelope = SafeNativeMethods.DMPAPER_ENV_9,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Number10Envelope"]/*' />
        /// <devdoc>
        ///    <para>
        ///       #10 envelope
        ///       (4.125 in. by 9.5 in.).
        ///    </para>
        /// </devdoc>
        Number10Envelope = SafeNativeMethods.DMPAPER_ENV_10,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Number11Envelope"]/*' />
        /// <devdoc>
        ///    <para>
        ///       #11 envelope (4.5
        ///       in. by 10.375 in.).
        ///    </para>
        /// </devdoc>
        Number11Envelope = SafeNativeMethods.DMPAPER_ENV_11,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Number12Envelope"]/*' />
        /// <devdoc>
        ///    <para>
        ///       #12 envelope (4.75
        ///       in. by 11 in.).
        ///    </para>
        /// </devdoc>
        Number12Envelope = SafeNativeMethods.DMPAPER_ENV_12,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Number14Envelope"]/*' />
        /// <devdoc>
        ///    <para>
        ///       #14 envelope (5 in. by 11.5 in.).
        ///    </para>
        /// </devdoc>
        Number14Envelope = SafeNativeMethods.DMPAPER_ENV_14,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.DLEnvelope"]/*' />
        /// <devdoc>
        ///    <para>
        ///       DL envelope
        ///       (110 mm by 220 mm).
        ///    </para>
        /// </devdoc>
        DLEnvelope = SafeNativeMethods.DMPAPER_ENV_DL,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.C5Envelope"]/*' />
        /// <devdoc>
        ///    <para>
        ///       C5 envelope
        ///       (162 mm by 229 mm).
        ///    </para>
        /// </devdoc>
        C5Envelope = SafeNativeMethods.DMPAPER_ENV_C5,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.C3Envelope"]/*' />
        /// <devdoc>
        ///    C3 envelope (324 mm by 458 mm).
        /// </devdoc>
        C3Envelope = SafeNativeMethods.DMPAPER_ENV_C3,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.C4Envelope"]/*' />
        /// <devdoc>
        ///    <para>
        ///       C4 envelope (229
        ///       mm by 324 mm).
        ///    </para>
        /// </devdoc>
        C4Envelope = SafeNativeMethods.DMPAPER_ENV_C4,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.C6Envelope"]/*' />
        /// <devdoc>
        ///    C6 envelope (114 mm by 162 mm).
        /// </devdoc>
        C6Envelope = SafeNativeMethods.DMPAPER_ENV_C6,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.C65Envelope"]/*' />
        /// <devdoc>
        ///    <para>
        ///       C65 envelope (114
        ///       mm by 229 mm).
        ///    </para>
        /// </devdoc>
        C65Envelope = SafeNativeMethods.DMPAPER_ENV_C65,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.B4Envelope"]/*' />
        /// <devdoc>
        ///    <para>
        ///       B4 envelope (250 mm by 353 mm).
        ///    </para>
        /// </devdoc>
        B4Envelope = SafeNativeMethods.DMPAPER_ENV_B4,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.B5Envelope"]/*' />
        /// <devdoc>
        ///    <para>
        ///       B5 envelope (176
        ///       mm by 250 mm).
        ///    </para>
        /// </devdoc>
        B5Envelope = SafeNativeMethods.DMPAPER_ENV_B5,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.B6Envelope"]/*' />
        /// <devdoc>
        ///    <para>
        ///       B6 envelope (176
        ///       mm by 125 mm).
        ///    </para>
        /// </devdoc>
        B6Envelope = SafeNativeMethods.DMPAPER_ENV_B6,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.ItalyEnvelope"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Italy envelope (110 mm by 230 mm).
        ///    </para>
        /// </devdoc>
        ItalyEnvelope = SafeNativeMethods.DMPAPER_ENV_ITALY,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.MonarchEnvelope"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Monarch envelope (3.875
        ///       in. by 7.5 in.).
        ///    </para>
        /// </devdoc>
        MonarchEnvelope = SafeNativeMethods.DMPAPER_ENV_MONARCH,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PersonalEnvelope"]/*' />
        /// <devdoc>
        ///    <para>
        ///       6 3/4 envelope
        ///       (3.625 in. by 6.5 in.).
        ///    </para>
        /// </devdoc>
        PersonalEnvelope = SafeNativeMethods.DMPAPER_ENV_PERSONAL,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.USStandardFanfold"]/*' />
        /// <devdoc>
        ///    <para>
        ///       US standard
        ///       fanfold (14.875 in. by 11 in.).
        ///    </para>
        /// </devdoc>
        USStandardFanfold = SafeNativeMethods.DMPAPER_FANFOLD_US,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.GermanStandardFanfold"]/*' />
        /// <devdoc>
        ///    <para>
        ///       German standard fanfold
        ///       (8.5 in. by 12 in.).
        ///    </para>
        /// </devdoc>
        GermanStandardFanfold = SafeNativeMethods.DMPAPER_FANFOLD_STD_GERMAN,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.GermanLegalFanfold"]/*' />
        /// <devdoc>
        ///    <para>
        ///       German legal fanfold
        ///       (8.5 in. by 13 in.).
        ///    </para>
        /// </devdoc>
        GermanLegalFanfold = SafeNativeMethods.DMPAPER_FANFOLD_LGL_GERMAN,

        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.IsoB4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       ISO B4 (250 mm by 353 mm).
        ///    </para>
        /// </devdoc>
        IsoB4 = SafeNativeMethods.DMPAPER_ISO_B4,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.JapanesePostcard"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Japanese postcard (100 mm by 148 mm).
        ///    </para>
        /// </devdoc>
        JapanesePostcard = SafeNativeMethods.DMPAPER_JAPANESE_POSTCARD,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Standard9x11"]/*' />
        /// <devdoc>
        ///    <para>
        ///       9-by-11-inch
        ///       paper.
        ///       
        ///    </para>
        /// </devdoc>
        Standard9x11 = SafeNativeMethods.DMPAPER_9X11,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Standard10x11"]/*' />
        /// <devdoc>
        ///    <para>
        ///       10-by-11-inch paper.
        ///       
        ///    </para>
        /// </devdoc>
        Standard10x11 = SafeNativeMethods.DMPAPER_10X11,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Standard15x11"]/*' />
        /// <devdoc>
        ///    <para>
        ///       15-by-11-inch paper.
        ///       
        ///    </para>
        /// </devdoc>
        Standard15x11 = SafeNativeMethods.DMPAPER_15X11,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.InviteEnvelope"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Invite envelope (220
        ///       mm by 220 mm).
        ///    </para>
        /// </devdoc>
        InviteEnvelope= SafeNativeMethods.DMPAPER_ENV_INVITE,
        //= SafeNativeMethods.DMPAPER_RESERVED_48,
        //= SafeNativeMethods.DMPAPER_RESERVED_49,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.LetterExtra"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Letter extra paper
        ///       (9.275 in. by
        ///       12 in.). This value is specific to the PostScript driver and is used only
        ///       by Linotronic printers in order to conserve paper.
        ///    </para>
        /// </devdoc>
        LetterExtra = SafeNativeMethods.DMPAPER_LETTER_EXTRA,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.LegalExtra"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Legal extra
        ///       paper (9.275 in.
        ///       by 15 in.). This value is specific to the PostScript driver, and is used
        ///       only by Linotronic printers in order to conserve paper.
        ///    </para>
        /// </devdoc>
        LegalExtra = SafeNativeMethods.DMPAPER_LEGAL_EXTRA,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.TabloidExtra"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Tabloid extra paper
        ///       (11.69 in. by 18 in.). This
        ///       value is specific to the PostScript driver and is used only by Linotronic printers in order to conserve paper.
        ///    </para>
        /// </devdoc>
        TabloidExtra = SafeNativeMethods.DMPAPER_TABLOID_EXTRA,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.A4Extra"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A4 extra
        ///       paper
        ///       (236 mm by 322 mm). This value is specific to the PostScript driver and is used only
        ///       by Linotronic printers to help save paper.
        ///    </para>
        /// </devdoc>
        A4Extra = SafeNativeMethods.DMPAPER_A4_EXTRA,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.LetterTransverse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Letter transverse paper
        ///       (8.275 in. by 11 in.).
        ///    </para>
        /// </devdoc>
        LetterTransverse = SafeNativeMethods.DMPAPER_LETTER_TRANSVERSE,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.A4Transverse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A4 transverse paper
        ///       (210 mm by 297 mm).
        ///    </para>
        /// </devdoc>
        A4Transverse = SafeNativeMethods.DMPAPER_A4_TRANSVERSE,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.LetterExtraTransverse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Letter extra transverse
        ///       paper (9.275 in. by 12
        ///       in.).
        ///    </para>
        /// </devdoc>
        LetterExtraTransverse = SafeNativeMethods.DMPAPER_LETTER_EXTRA_TRANSVERSE,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.APlus"]/*' />
        /// <devdoc>
        ///    <para>
        ///       SuperA/SuperA/A4 paper (227
        ///       mm by 356 mm).
        ///    </para>
        /// </devdoc>
        APlus = SafeNativeMethods.DMPAPER_A_PLUS,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.BPlus"]/*' />
        /// <devdoc>
        ///    <para>
        ///       SuperB/SuperB/A3 paper (305
        ///       mm by 487 mm).
        ///    </para>
        /// </devdoc>
        BPlus = SafeNativeMethods.DMPAPER_B_PLUS,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.LetterPlus"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Letter plus paper
        ///       (8.5 in. by 12.69 in.).
        ///    </para>
        /// </devdoc>
        LetterPlus = SafeNativeMethods.DMPAPER_LETTER_PLUS,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.A4Plus"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A4 plus paper
        ///       (210 mm by 330 mm).
        ///    </para>
        /// </devdoc>
        A4Plus = SafeNativeMethods.DMPAPER_A4_PLUS,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.A5Transverse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A5 transverse paper
        ///       (148 mm by 210
        ///       mm).
        ///    </para>
        /// </devdoc>
        A5Transverse = SafeNativeMethods.DMPAPER_A5_TRANSVERSE,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.B5Transverse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       JIS B5 transverse
        ///       paper (182 mm by 257 mm).
        ///    </para>
        /// </devdoc>
        B5Transverse = SafeNativeMethods.DMPAPER_B5_TRANSVERSE,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.A3Extra"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A3 extra paper
        ///       (322 mm by 445 mm).
        ///    </para>
        /// </devdoc>
        A3Extra = SafeNativeMethods.DMPAPER_A3_EXTRA,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.A5Extra"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A5 extra paper
        ///       (174 mm by 235 mm).
        ///    </para>
        /// </devdoc>
        A5Extra = SafeNativeMethods.DMPAPER_A5_EXTRA,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.B5Extra"]/*' />
        /// <devdoc>
        ///    <para>
        ///       ISO B5 extra
        ///       paper (201 mm by 276 mm).
        ///    </para>
        /// </devdoc>
        B5Extra = SafeNativeMethods.DMPAPER_B5_EXTRA,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.A2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A2 paper
        ///       (420
        ///       mm by 594 mm).
        ///    </para>
        /// </devdoc>
        A2 = SafeNativeMethods.DMPAPER_A2,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.A3Transverse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A3 transverse paper
        ///       (297 mm by 420 mm).
        ///    </para>
        /// </devdoc>
        A3Transverse = SafeNativeMethods.DMPAPER_A3_TRANSVERSE,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.A3ExtraTransverse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A3 extra transverse
        ///       paper (322 mm by 445 mm).
        ///    </para>
        /// </devdoc>
        A3ExtraTransverse = SafeNativeMethods.DMPAPER_A3_EXTRA_TRANSVERSE,
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.JapaneseDoublePostcard"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Japanese double postcard
        ///       (200 mm by 148
        ///       mm). Requires Windows
        ///       98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        JapaneseDoublePostcard = SafeNativeMethods.DMPAPER_DBL_JAPANESE_POSTCARD, /* Japanese Double Postcard 200 x 148 mm */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.A6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A6 paper (105
        ///       mm by 148 mm). Requires
        ///       Windows 98,
        ///       Windows
        ///       NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        A6 = SafeNativeMethods.DMPAPER_A6,  /* A6 105 x 148 mm                 */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.JapaneseEnvelopeKakuNumber2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Japanese Kaku #2 envelope. Requires Windows
        ///       98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        JapaneseEnvelopeKakuNumber2 = SafeNativeMethods.DMPAPER_JENV_KAKU2,  /* Japanese Envelope Kaku #2       */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.JapaneseEnvelopeKakuNumber3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Japanese Kaku #3 envelope. Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        JapaneseEnvelopeKakuNumber3 = SafeNativeMethods.DMPAPER_JENV_KAKU3,  /* Japanese Envelope Kaku #3       */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.JapaneseEnvelopeChouNumber3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Japanese Chou #3 envelope. Requires Windows
        ///       98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        JapaneseEnvelopeChouNumber3= SafeNativeMethods.DMPAPER_JENV_CHOU3,  /* Japanese Envelope Chou #3       */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.JapaneseEnvelopeChouNumber4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Japanese Chou #4 envelope. Requires Windows
        ///       98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        JapaneseEnvelopeChouNumber4 = SafeNativeMethods.DMPAPER_JENV_CHOU4,  /* Japanese Envelope Chou #4       */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.LetterRotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Letter rotated paper (11
        ///       in. by
        ///       8.5 in.).
        ///    </para>
        /// </devdoc>
        LetterRotated = SafeNativeMethods.DMPAPER_LETTER_ROTATED,  /* Letter Rotated 11 x 8 1/2 11 in */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.A3Rotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A3
        ///       rotated paper (420mm by 297 mm).
        ///    </para>
        /// </devdoc>
        A3Rotated = SafeNativeMethods.DMPAPER_A3_ROTATED,  /* A3 Rotated 420 x 297 mm         */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.A4Rotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A4 rotated paper
        ///       (297 mm by 210 mm).
        ///       Requires Windows
        ///       98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        A4Rotated = SafeNativeMethods.DMPAPER_A4_ROTATED,  /* A4 Rotated 297 x 210 mm         */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.A5Rotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A5 rotated paper
        ///       (210 mm by 148 mm).
        ///       Requires Windows
        ///       98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        A5Rotated = SafeNativeMethods.DMPAPER_A5_ROTATED,  /* A5 Rotated 210 x 148 mm         */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.B4JisRotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       JIS B4 rotated
        ///       paper (364 mm by 257
        ///       mm). Requires Windows
        ///       98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        B4JisRotated = SafeNativeMethods.DMPAPER_B4_JIS_ROTATED,  /* B4 (JIS) Rotated 364 x 257 mm   */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.B5JisRotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       JIS B5 rotated
        ///       paper (257 mm by 182
        ///       mm). Requires Windows
        ///       98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        B5JisRotated = SafeNativeMethods.DMPAPER_B5_JIS_ROTATED,  /* B5 (JIS) Rotated 257 x 182 mm   */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.JapanesePostcardRotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Japanese rotated postcard
        ///       (148 mm by 100
        ///       mm). Requires Windows
        ///       98,
        ///       Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        JapanesePostcardRotated = SafeNativeMethods.DMPAPER_JAPANESE_POSTCARD_ROTATED, /* Japanese Postcard Rotated 148 x 100 mm */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.JapaneseDoublePostcardRotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Japanese rotated double
        ///       postcard (148 mm by
        ///       200 mm). Requires
        ///       Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        JapaneseDoublePostcardRotated = SafeNativeMethods.DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED, /* Double Japanese Postcard Rotated 148 x 200 mm */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.A6Rotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       A6
        ///       rotated paper
        ///       (148 mm by 105 mm).
        ///       Requires Windows
        ///       98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        A6Rotated = SafeNativeMethods.DMPAPER_A6_ROTATED,  /* A6 Rotated 148 x 105 mm         */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.JapaneseEnvelopeKakuNumber2Rotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Japanese rotated Kaku #2 envelope. Requires
        ///       Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        JapaneseEnvelopeKakuNumber2Rotated = SafeNativeMethods.DMPAPER_JENV_KAKU2_ROTATED,  /* Japanese Envelope Kaku #2 Rotated */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.JapaneseEnvelopeKakuNumber3Rotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Japanese rotated Kaku #3 envelope. Requires
        ///       Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        JapaneseEnvelopeKakuNumber3Rotated = SafeNativeMethods.DMPAPER_JENV_KAKU3_ROTATED,  /* Japanese Envelope Kaku #3 Rotated */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.JapaneseEnvelopeChouNumber3Rotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Japanese rotated Chou #3 envelope. Requires
        ///       Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        JapaneseEnvelopeChouNumber3Rotated = SafeNativeMethods.DMPAPER_JENV_CHOU3_ROTATED,  /* Japanese Envelope Chou #3 Rotated */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.JapaneseEnvelopeChouNumber4Rotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Japanese rotated Chou #4 envelope. Requires
        ///       Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        JapaneseEnvelopeChouNumber4Rotated = SafeNativeMethods.DMPAPER_JENV_CHOU4_ROTATED,  /* Japanese Envelope Chou #4 Rotated */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.B6Jis"]/*' />
        /// <devdoc>
        ///    <para>
        ///       JIS B6 paper
        ///       (128 mm by 182 mm).
        ///       Requires Windows 98,
        ///       Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        B6Jis = SafeNativeMethods.DMPAPER_B6_JIS,  /* B6 (JIS) 128 x 182 mm           */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.B6JisRotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       JIS B6
        ///       rotated paper (182 mm by 128
        ///       mm). Requires Windows
        ///       98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        B6JisRotated = SafeNativeMethods.DMPAPER_B6_JIS_ROTATED,  /* B6 (JIS) Rotated 182 x 128 mm   */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Standard12x11"]/*' />
        /// <devdoc>
        ///    <para>
        ///       12-by-11-inch paper. Requires Windows 98,
        ///       Windows
        ///       NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        Standard12x11 = SafeNativeMethods.DMPAPER_12X11,  /* 12 x 11 in                      */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.JapaneseEnvelopeYouNumber4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Japanese You #4 envelope. Requires Windows
        ///       98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        JapaneseEnvelopeYouNumber4 = SafeNativeMethods.DMPAPER_JENV_YOU4,  /* Japanese Envelope You #4        */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.JapaneseEnvelopeYouNumber4Rotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Japanese You #4 rotated envelope. Requires
        ///       Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        JapaneseEnvelopeYouNumber4Rotated = SafeNativeMethods.DMPAPER_JENV_YOU4_ROTATED,  /* Japanese Envelope You #4 Rotated*/
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Prc16K"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC 16K paper (146 mm
        ///       by 215
        ///       mm). Requires Windows
        ///       98, Windows NT 4.0,
        ///       or later.
        ///    </para>
        /// </devdoc>
        Prc16K = SafeNativeMethods.DMPAPER_P16K,  /* PRC 16K 146 x 215 mm            */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Prc32K"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC 32K paper (97 mm
        ///       by 151
        ///       mm). Requires Windows 98, Windows
        ///       NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        Prc32K = SafeNativeMethods.DMPAPER_P32K,  /* PRC 32K 97 x 151 mm             */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Prc32KBig"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC 32K big paper (97
        ///       mm by
        ///       151 mm). Requires Windows 98, Windows
        ///       NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        Prc32KBig = SafeNativeMethods.DMPAPER_P32KBIG,  /* PRC 32K(Big) 97 x 151 mm        */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #1 envelope (102 mm
        ///       by 165
        ///       mm). Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber1 = SafeNativeMethods.DMPAPER_PENV_1,  /* PRC Envelope #1 102 x 165 mm    */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #2 envelope (102 mm
        ///       by 176
        ///       mm). Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber2 = SafeNativeMethods.DMPAPER_PENV_2,  /* PRC Envelope #2 102 x 176 mm    */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #3 envelope (125 mm
        ///       by 176
        ///       mm). Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber3 = SafeNativeMethods.DMPAPER_PENV_3,  /* PRC Envelope #3 125 x 176 mm    */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #4 envelope (110 mm
        ///       by 208
        ///       mm). Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber4 = SafeNativeMethods.DMPAPER_PENV_4,  /* PRC Envelope #4 110 x 208 mm    */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #5 envelope (110 mm by 220 mm). Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber5 = SafeNativeMethods.DMPAPER_PENV_5, /* PRC Envelope #5 110 x 220 mm    */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #6 envelope (120 mm by 230 mm). Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber6 = SafeNativeMethods.DMPAPER_PENV_6, /* PRC Envelope #6 120 x 230 mm    */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #7 envelope (160 mm
        ///       by 230
        ///       mm). Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber7 = SafeNativeMethods.DMPAPER_PENV_7, /* PRC Envelope #7 160 x 230 mm    */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #8 envelope (120 mm
        ///       by 309
        ///       mm). Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber8 = SafeNativeMethods.DMPAPER_PENV_8, /* PRC Envelope #8 120 x 309 mm    */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber9"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #9 envelope (229 mm by 324 mm). Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber9 = SafeNativeMethods.DMPAPER_PENV_9, /* PRC Envelope #9 229 x 324 mm    */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber10"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #10 envelope (324 mm
        ///       by 458
        ///       mm). Requires Windows 98, Windows NT 4.0, or
        ///       later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber10 = SafeNativeMethods.DMPAPER_PENV_10, /* PRC Envelope #10 324 x 458 mm   */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Prc16KRotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC 16K rotated paper (146 mm by 215 mm). Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        Prc16KRotated = SafeNativeMethods.DMPAPER_P16K_ROTATED, /* PRC 16K Rotated                 */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Prc32KRotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC 32K rotated paper (97 mm by 151
        ///       mm). Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        Prc32KRotated = SafeNativeMethods.DMPAPER_P32K_ROTATED, /* PRC 32K Rotated                 */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.Prc32KBigRotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC 32K big rotated paper (97 mm by 151 mm). Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        Prc32KBigRotated = SafeNativeMethods.DMPAPER_P32KBIG_ROTATED, /* PRC 32K(Big) Rotated            */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber1Rotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #1 rotated envelope (165 mm by 102 mm). Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber1Rotated = SafeNativeMethods.DMPAPER_PENV_1_ROTATED, /* PRC Envelope #1 Rotated 165 x 102 mm */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber2Rotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #2 rotated envelope
        ///       (176 mm by
        ///       102 mm). Requires Windows 98, Windows NT 4.0, or
        ///       later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber2Rotated = SafeNativeMethods.DMPAPER_PENV_2_ROTATED, /* PRC Envelope #2 Rotated 176 x 102 mm */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber3Rotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #3 rotated envelope
        ///       (176 mm by
        ///       125 mm). Requires Windows 98, Windows NT 4.0, or
        ///       later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber3Rotated = SafeNativeMethods.DMPAPER_PENV_3_ROTATED, /* PRC Envelope #3 Rotated 176 x 125 mm */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber4Rotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #4 rotated envelope (208 mm by 110 mm). Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber4Rotated = SafeNativeMethods.DMPAPER_PENV_4_ROTATED, /* PRC Envelope #4 Rotated 208 x 110 mm */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber5Rotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #5 rotated envelope (220 mm by 110 mm). Requires Windows 98, Windows NT 4.0, or
        ///       later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber5Rotated = SafeNativeMethods.DMPAPER_PENV_5_ROTATED, /* PRC Envelope #5 Rotated 220 x 110 mm */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber6Rotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #6 rotated envelope (230 mm by 120 mm). Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber6Rotated = SafeNativeMethods.DMPAPER_PENV_6_ROTATED, /* PRC Envelope #6 Rotated 230 x 120 mm */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber7Rotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #7 rotated envelope (230 mm by 160 mm). Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber7Rotated = SafeNativeMethods.DMPAPER_PENV_7_ROTATED, /* PRC Envelope #7 Rotated 230 x 160 mm */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber8Rotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #8 rotated
        ///       envelope (309 mm
        ///       by 120
        ///       mm). Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber8Rotated = SafeNativeMethods.DMPAPER_PENV_8_ROTATED, /* PRC Envelope #8 Rotated 309 x 120 mm */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber9Rotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #9 rotated envelope (324 mm by 229 mm). Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber9Rotated = SafeNativeMethods.DMPAPER_PENV_9_ROTATED, /* PRC Envelope #9 Rotated 324 x 229 mm */
        /// <include file='doc\PaperKinds.uex' path='docs/doc[@for="PaperKind.PrcEnvelopeNumber10Rotated"]/*' />
        /// <devdoc>
        ///    <para>
        ///       PRC #10 rotated envelope (458 mm by 324 mm). Requires Windows 98, Windows NT 4.0, or later.
        ///    </para>
        /// </devdoc>
        PrcEnvelopeNumber10Rotated = SafeNativeMethods.DMPAPER_PENV_10_ROTATED, /* PRC Envelope #10 Rotated 458 x 324 mm */

        // Other useful values: SafeNativeMethods.DMPAPER_LAST, SafeNativeMethods.DMPAPER_USER
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\papersize.cs ===
//------------------------------------------------------------------------------
// <copyright file="PaperSize.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;    
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\PaperSize.uex' path='docs/doc[@for="PaperSize"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies
    ///       the size of a piece of paper.
    ///    </para>
    /// </devdoc>
    public class PaperSize {
        private PaperKind kind;
        private string name;

        // standard hundredths of an inch units
        private int width;
        private int height;

        internal PaperSize(PaperKind kind, string name, int width, int height) {
            this.kind = kind;
            this.name = name;
            this.width = width;
            this.height = height;
        }

        /// <include file='doc\PaperSize.uex' path='docs/doc[@for="PaperSize.PaperSize"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Printing.PaperSize'/> class.
        ///    </para>
        /// </devdoc>
        public PaperSize(string name, int width, int height) {
            this.kind = PaperKind.Custom;
            this.name = name;
            this.width = width;
            this.height = height;
        }

        /// <include file='doc\PaperSize.uex' path='docs/doc[@for="PaperSize.Height"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets
        ///       the height of the paper, in hundredths of an inch.</para>
        /// </devdoc>
        public int Height {
            get {
                return height;
            }

            set {
                if (kind != PaperKind.Custom) throw new ArgumentException(SR.GetString(SR.PSizeNotCustom));
                height = value;
            }
        }

        /// <include file='doc\PaperSize.uex' path='docs/doc[@for="PaperSize.Kind"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type of paper.
        ///       
        ///    </para>
        /// </devdoc>
        public PaperKind Kind {
            get {
                if (kind <= (PaperKind)SafeNativeMethods.DMPAPER_LAST)
                    return kind;
                else
                    return PaperKind.Custom;
            }
        }

        /// <include file='doc\PaperSize.uex' path='docs/doc[@for="PaperSize.PaperName"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       or sets the name of the type of paper.</para>
        /// </devdoc>
        public string PaperName {
            get { return name;}

            set {
                if (kind != PaperKind.Custom) throw new ArgumentException(SR.GetString(SR.PSizeNotCustom));
                name = value;
            }
        }

        internal PaperKind RawKind {
            get { return kind;}
        }

        /// <include file='doc\PaperSize.uex' path='docs/doc[@for="PaperSize.Width"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets
        ///       the width of the paper, in hundredths of an inch.</para>
        /// </devdoc>
        public int Width {
            get {
                return width;
            }

            set {
                if (kind != PaperKind.Custom) throw new ArgumentException(SR.GetString(SR.PSizeNotCustom));
                width = value;
            }
        }

// I don't think we need this anymore, but I'll be damned if I'm going to type is in again
#if false
        private Point Dimensions {
            get {
                Point result;

                // Most of these numbers came straight from the header files.
                // The Japanese envelope ones came from kazuyko.
                switch (Kind) {
                    case PaperKind.Custom: result = new Point(width, height); break;

                    case PaperKind.Letter: result = Inches(8.5, 11); break;
                    case PaperKind.Legal: result = Inches(8.5, 14); break;
                    case PaperKind.A4: result = Millimeters(210, 297); break;
                    case PaperKind.CSheet: result = Inches(17, 22); break;
                    case PaperKind.DSheet: result = Inches(22, 34); break;
                    case PaperKind.ESheet: result = Inches(34, 44); break;
                    case PaperKind.LetterSmall: result = Inches(8.5, 11); break;
                    case PaperKind.Tabloid: result = Inches(11, 17); break;
                    case PaperKind.Ledger: result = Inches(17, 11); break;
                    case PaperKind.Statement: result = Inches(5.5, 8.5); break;
                    case PaperKind.Executive: result = Inches(7.25, 10.5); break;
                    case PaperKind.A3: result = Millimeters(297, 420); break;
                    case PaperKind.A4Small: result = Millimeters(210, 297); break;
                    case PaperKind.A5: result = Millimeters(148, 210); break;
                    case PaperKind.B4: result = Millimeters(250, 354); break;
                    case PaperKind.B5: result = Millimeters(182, 257); break;
                    case PaperKind.Folio: result = Inches(8.5, 13); break;
                    case PaperKind.Quarto: result = Millimeters(215, 275); break;
                    case PaperKind.Standard10x14: result = Inches(10, 14); break;
                    case PaperKind.Standard11x17: result = Inches(11, 17); break;
                    case PaperKind.Note: result = Inches(8.5, 11); break;
                    case PaperKind.Number9Envelope: result = Inches(3.875, 8.875); break;
                    case PaperKind.Number10Envelope: result = Inches(4.125, 9.5); break;
                    case PaperKind.Number11Envelope: result = Inches(4.5, 10.375); break;
                    case PaperKind.Number12Envelope: result = Inches(4.75, 11); break;
                    case PaperKind.Number14Envelope: result = Inches(5, 11.5); break;
                    case PaperKind.DLEnvelope: result = Millimeters(110, 220); break;
                    case PaperKind.C5Envelope: result = Millimeters(162, 229); break;
                    case PaperKind.C3Envelope: result = Millimeters(324, 458); break;
                    case PaperKind.C4Envelope: result = Millimeters(229, 324); break;
                    case PaperKind.C6Envelope: result = Millimeters(114, 162); break;
                    case PaperKind.C65Envelope: result = Millimeters(114, 229); break;
                    case PaperKind.B4Envelope: result = Millimeters(250, 353); break;
                    case PaperKind.B5Envelope: result = Millimeters(176, 250); break;
                    case PaperKind.B6Envelope: result = Millimeters(176, 125); break;
                    case PaperKind.ItalyEnvelope: result = Millimeters(110, 230); break;
                    case PaperKind.MonarchEnvelope: result = Inches(3.875, 7.5); break;
                    case PaperKind.PersonalEnvelope: result = Inches(3.625, 6.5); break;
                    case PaperKind.USStandardFanfold: result = Inches(14.875, 11); break;
                    case PaperKind.GermanStandardFanfold: result = Inches(8.5, 12); break;
                    case PaperKind.GermanLegalFanfold: result = Inches(8.5, 13); break;

                    case PaperKind.ISOB4: result = Millimeters(250, 353); break;
                    case PaperKind.JapanesePostcard: result = Millimeters(100, 148); break;
                    case PaperKind.Standard9x11: result = Inches(9, 11); break;
                    case PaperKind.Standard10x11: result = Inches(10, 11); break;
                    case PaperKind.Standard15x11: result = Inches(15, 11); break;
                    case PaperKind.InviteEnvelope: result = Millimeters(220, 220); break;
                        //= SafeNativeMethods.DMPAPER_RESERVED_48,
                        //= SafeNativeMethods.DMPAPER_RESERVED_49,
                    case PaperKind.LetterExtra: result = Inches(9.275, 12); break;
                    case PaperKind.LegalExtra: result = Inches(9.275, 15); break;
                    case PaperKind.TabloidExtra: result = Inches(11.69, 18); break;
                    case PaperKind.A4Extra: result = Inches(9.27, 12.69); break;
                    case PaperKind.LetterTransverse: result = Inches(8.275, 11); break;
                    case PaperKind.A4Transverse: result = Millimeters(210, 297); break;
                    case PaperKind.LetterExtraTransverse: result = Inches(9.275, 12); break;
                    case PaperKind.APlus: result = Millimeters(227, 356); break;
                    case PaperKind.BPlus: result = Millimeters(305, 487); break;
                    case PaperKind.LetterPlus: result = Inches(8.5, 12.69); break;
                    case PaperKind.A4Plus: result = Millimeters(210, 330); break;
                    case PaperKind.A5Transverse: result = Millimeters(148, 210); break;
                    case PaperKind.B5Transverse: result = Millimeters(182, 257); break;
                    case PaperKind.A3Extra: result = Millimeters(322, 445); break;
                    case PaperKind.A5Extra: result = Millimeters(174, 235); break;
                    case PaperKind.B5Extra: result = Millimeters(201, 276); break;
                    case PaperKind.A2: result = Millimeters(420, 594); break;
                    case PaperKind.A3Transverse: result = Millimeters(297, 420); break;
                    case PaperKind.A3ExtraTransverse: result = Millimeters(322, 445); break;

                    case PaperKind.JapaneseDoublePostcard: result = Millimeters(200, 148); break;
                    case PaperKind.A6: result = Millimeters(105, 148); break;
                    case PaperKind.JapaneseEnvelopeKakuNumber2: result = Millimeters(240, 332); break;
                    case PaperKind.JapaneseEnvelopeKakuNumber3: result = Millimeters(216, 277); break;
                    case PaperKind.JapaneseEnvelopeChouNumber3: result = Millimeters(120, 235); break;
                    case PaperKind.JapaneseEnvelopeChouNumber4: result = Millimeters(90, 205); break;
                    case PaperKind.LetterRotated: result = Inches(11, 8.5); break;
                    case PaperKind.A3Rotated: result = Millimeters(420, 297); break;
                    case PaperKind.A4Rotated: result = Millimeters(297, 210); break;
                    case PaperKind.A5Rotated: result = Millimeters(210, 148); break;
                    case PaperKind.B4JISRotated: result = Millimeters(364, 257); break;
                    case PaperKind.B5JISRotated: result = Millimeters(257, 182); break;
                    case PaperKind.JapanesePostcardRotated: result = Millimeters(148, 100); break;
                    case PaperKind.JapaneseDoublePostcardRotated: result = Millimeters(148, 200); break;
                    case PaperKind.A6Rotated: result = Millimeters(148, 105); break;
                    case PaperKind.JapaneseEnvelopeKakuNumber2Rotated: result = Millimeters(332, 240); break;
                    case PaperKind.JapaneseEnvelopeKakuNumber3Rotated: result = Millimeters(277, 216); break;
                    case PaperKind.JapaneseEnvelopeChouNumber3Rotated: result = Millimeters(235, 120); break;
                    case PaperKind.JapaneseEnvelopeChouNumber4Rotated: result = Millimeters(205, 90); break;
                    case PaperKind.B6JIS: result = Millimeters(128, 182); break;
                    case PaperKind.B6JISRotated: result = Millimeters(182, 128); break;
                    case PaperKind.Standard12x11: result = Inches(12, 11); break;
                    case PaperKind.JapaneseEnvelopeYouNumber4: result = Millimeters(105, 235); break;
                    case PaperKind.JapaneseEnvelopeYouNumber4Rotated: result = Millimeters(235, 105); break;
                    case PaperKind.PRC16K: result = Millimeters(146, 215); break;
                    case PaperKind.PRC32K: result = Millimeters(97, 151); break;
                    case PaperKind.PRC32KBig: result = Millimeters(97, 151); break;
                    case PaperKind.PRCEnvelopeNumber1: result = Millimeters(102, 165); break;
                    case PaperKind.PRCEnvelopeNumber2: result = Millimeters(102, 176); break;
                    case PaperKind.PRCEnvelopeNumber3: result = Millimeters(125, 176); break;
                    case PaperKind.PRCEnvelopeNumber4: result = Millimeters(110, 208); break;
                    case PaperKind.PRCEnvelopeNumber5: result = Millimeters(110, 220); break;
                    case PaperKind.PRCEnvelopeNumber6: result = Millimeters(120, 230); break;
                    case PaperKind.PRCEnvelopeNumber7: result = Millimeters(160, 230); break;
                    case PaperKind.PRCEnvelopeNumber8: result = Millimeters(120, 309); break;
                    case PaperKind.PRCEnvelopeNumber9: result = Millimeters(229, 324); break;
                    case PaperKind.PRCEnvelopeNumber10: result = Millimeters(324, 458); break;
                    case PaperKind.PRC16KRotated: result = Millimeters(215, 146); break;
                    case PaperKind.PRC32KRotated: result = Millimeters(151, 97); break;
                    case PaperKind.PRC32KBigRotated: result = Millimeters(151, 97); break;
                    case PaperKind.PRCEnvelopeNumber1Rotated: result = Millimeters(165, 102); break;
                    case PaperKind.PRCEnvelopeNumber2Rotated: result = Millimeters(176, 102); break;
                    case PaperKind.PRCEnvelopeNumber3Rotated: result = Millimeters(176, 125); break;
                    case PaperKind.PRCEnvelopeNumber4Rotated: result = Millimeters(208, 110); break;
                    case PaperKind.PRCEnvelopeNumber5Rotated: result = Millimeters(220, 110); break;
                    case PaperKind.PRCEnvelopeNumber6Rotated: result = Millimeters(230, 120); break;
                    case PaperKind.PRCEnvelopeNumber7Rotated: result = Millimeters(230, 160); break;
                    case PaperKind.PRCEnvelopeNumber8Rotated: result = Millimeters(309, 120); break;
                    case PaperKind.PRCEnvelopeNumber9Rotated: result = Millimeters(324, 229); break;
                    case PaperKind.PRCEnvelopeNumber10Rotated: result = Millimeters(458, 324); break;

                    default:
                        Debug.Fail("Unknown paper kind " + ((int) kind));
                        result = new Point(0, 0);
                        break;
                }
                return result;
            }
        }

        private static Point Inches(double width, double height) {
            Debug.Assert(width < 20 && height < 20, "You said inches, but you probably meant millimeters (" + width + ", " + height + ")");
            float conversion = 254;
            return new Point((int) (width * conversion), (int) (height * conversion));
        }

        private static Point Millimeters(double width, double height) {
            Debug.Assert(width > 20 && height > 20, "You said millimeters, but you probably meant inches (" + width + ", " + height + ")");
            float conversion = 10;
            return new Point((int) (width * conversion), (int) (height * conversion));
        }
#endif

        /// <include file='doc\PaperSize.uex' path='docs/doc[@for="PaperSize.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Provides some interesting information about the PaperSize in
        ///       String form.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            return "[PaperSize " + PaperName
            + " Kind=" + TypeDescriptor.GetConverter(typeof(PaperKind)).ConvertToString((int) Kind)
            + " Height=" + Height.ToString()
            + " Width=" + Width.ToString()
            + "]";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\previewprintcontroller.cs ===
//------------------------------------------------------------------------------
// <copyright file="PreviewPrintController.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {

    using Microsoft.Win32;
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Drawing;
    using System.Drawing.Drawing2D;
    using System.Drawing.Imaging;
    using System.Drawing.Text;
    using System.Runtime.InteropServices;

    using CodeAccessPermission = System.Security.CodeAccessPermission;

    /// <include file='doc\PreviewPrintController.uex' path='docs/doc[@for="PreviewPrintController"]/*' />
    /// <devdoc>
    ///     A PrintController which "prints" to a series of images.
    /// </devdoc>
    public class PreviewPrintController : PrintController {
        private IList list = new ArrayList(); // list of PreviewPageInfo
        private System.Drawing.Graphics graphics;
        private IntPtr dc;
        private bool antiAlias = false;

        private void CheckSecurity() {
            IntSecurity.SafePrinting.Demand();
        }

        /// <include file='doc\PreviewPrintController.uex' path='docs/doc[@for="PreviewPrintController.OnStartPrint"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Implements StartPrint for generating print preview information.
        ///    </para>
        /// </devdoc>
        public override void OnStartPrint(PrintDocument document, PrintEventArgs e) {
            Debug.Assert(dc == IntPtr.Zero && graphics == null, "PrintController methods called in the wrong order?");

            // For security purposes, don't assume our public methods methods are called in any particular order
            CheckSecurity();

            base.OnStartPrint(document, e);

            IntSecurity.AllPrintingAndUnmanagedCode.Assert();

            if (!document.PrinterSettings.IsValid)
                throw new InvalidPrinterException(document.PrinterSettings);

            // We need a DC as a reference; we don't actually draw on it.
            // We make sure to reuse the same one to improve performance.
            dc = document.PrinterSettings.CreateIC(modeHandle);
        }

        /// <include file='doc\PreviewPrintController.uex' path='docs/doc[@for="PreviewPrintController.OnStartPage"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Implements StartEnd for generating print preview information.
        ///    </para>
        /// </devdoc>
        public override Graphics OnStartPage(PrintDocument document, PrintPageEventArgs e) {
            Debug.Assert(dc != IntPtr.Zero && graphics == null, "PrintController methods called in the wrong order?");

            // For security purposes, don't assume our public methods methods are called in any particular order
            CheckSecurity();

            base.OnStartPage(document, e);

            IntSecurity.AllPrintingAndUnmanagedCode.Assert();

            e.PageSettings.CopyToHdevmode(modeHandle);
            Size size = e.PageBounds.Size;

            // Metafile framing rectangles apparently use hundredths of mm as their unit of measurement,
            // instead of the GDI+ standard hundredth of an inch.
            Size metafileSize = PrinterUnitConvert.Convert(size, PrinterUnit.Display, PrinterUnit.HundredthsOfAMillimeter);
            Metafile metafile = new Metafile(dc, new Rectangle(0,0, metafileSize.Width, metafileSize.Height));

            PreviewPageInfo info = new PreviewPageInfo(metafile, size);
            list.Add(info);
            graphics = Graphics.FromImage(metafile);

            if (antiAlias) {
                graphics.TextRenderingHint = TextRenderingHint.AntiAlias;
                graphics.SmoothingMode = SmoothingMode.AntiAlias;
            }
            
            return graphics;
        }

        /// <include file='doc\PreviewPrintController.uex' path='docs/doc[@for="PreviewPrintController.OnEndPage"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Implements EndPage for generating print preview information.
        ///    </para>
        /// </devdoc>
        public override void OnEndPage(PrintDocument document, PrintPageEventArgs e) {
            Debug.Assert(dc != IntPtr.Zero && graphics != null, "PrintController methods called in the wrong order?");

            // For security purposes, don't assume our public methods methods are called in any particular order
            CheckSecurity();

            graphics.Dispose();
            graphics = null;

            base.OnEndPage(document, e);
        }

        /// <include file='doc\PreviewPrintController.uex' path='docs/doc[@for="PreviewPrintController.OnEndPrint"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Implements EndPrint for generating print preview information.
        ///    </para>
        /// </devdoc>
        public override void OnEndPrint(PrintDocument document, PrintEventArgs e) {
            Debug.Assert(dc != IntPtr.Zero && graphics == null, "PrintController methods called in the wrong order?");

            // For security purposes, don't assume our public methods methods are called in any particular order
            CheckSecurity();

            IntSecurity.UnmanagedCode.Assert();

            SafeNativeMethods.DeleteDC(new HandleRef(this, dc));
            dc = IntPtr.Zero;

            CodeAccessPermission.RevertAssert();

            base.OnEndPrint(document, e);
        }

        /// <include file='doc\PreviewPrintController.uex' path='docs/doc[@for="PreviewPrintController.GetPreviewPageInfo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The "printout".
        ///    </para>
        /// </devdoc>
        public PreviewPageInfo[] GetPreviewPageInfo() {
            // For security purposes, don't assume our public methods methods are called in any particular order
            CheckSecurity();

            PreviewPageInfo[] temp = new PreviewPageInfo[list.Count];
            list.CopyTo(temp, 0);
            return temp;
        }

        /// <include file='doc\PreviewPrintController.uex' path='docs/doc[@for="PreviewPrintController.UseAntiAlias"]/*' />
        public virtual bool UseAntiAlias {
            get {
                return antiAlias;
            }
            set {
                antiAlias = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\printerresolutionkind.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrinterResolutionKind.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {

    using System.Diagnostics;
    using System;
    using System.Runtime.InteropServices;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\PrinterResolutionKind.uex' path='docs/doc[@for="PrinterResolutionKind"]/*' />
    /// <devdoc>
    ///    <para>Specifies a printer resolution.</para>
    /// </devdoc>
    public enum PrinterResolutionKind {
        /// <include file='doc\PrinterResolutionKind.uex' path='docs/doc[@for="PrinterResolutionKind.High"]/*' />
        /// <devdoc>
        ///    <para>
        ///       High resolution.
        ///       
        ///    </para>
        /// </devdoc>
        High = SafeNativeMethods.DMRES_HIGH,
        /// <include file='doc\PrinterResolutionKind.uex' path='docs/doc[@for="PrinterResolutionKind.Medium"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Medium resolution.
        ///       
        ///    </para>
        /// </devdoc>
        Medium = SafeNativeMethods.DMRES_MEDIUM,
        /// <include file='doc\PrinterResolutionKind.uex' path='docs/doc[@for="PrinterResolutionKind.Low"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Low resolution.
        ///       
        ///    </para>
        /// </devdoc>
        Low = SafeNativeMethods.DMRES_LOW,
        /// <include file='doc\PrinterResolutionKind.uex' path='docs/doc[@for="PrinterResolutionKind.Draft"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Draft-quality resolution.
        ///       
        ///    </para>
        /// </devdoc>
        Draft = SafeNativeMethods.DMRES_DRAFT,
        /// <include file='doc\PrinterResolutionKind.uex' path='docs/doc[@for="PrinterResolutionKind.Custom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Custom resolution.
        ///       
        ///    </para>
        /// </devdoc>
        Custom = 0,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\printerresolution.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrinterResolution.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;    
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\PrinterResolution.uex' path='docs/doc[@for="PrinterResolution"]/*' />
    /// <devdoc>
    ///    <para> Retrieves
    ///       the resolution supported by a printer.</para>
    /// </devdoc>
    public class PrinterResolution {
        private int x;
        private int y;
        private PrinterResolutionKind kind;

        internal PrinterResolution(PrinterResolutionKind kind, int x, int y) {
            this.kind = kind;
            this.x = x;
            this.y = y;
        }

        /// <include file='doc\PrinterResolution.uex' path='docs/doc[@for="PrinterResolution.Kind"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       a value indicating the kind of printer resolution.
        ///    </para>
        /// </devdoc>
        public PrinterResolutionKind Kind {
            get { return kind;}
        }

        /// <include file='doc\PrinterResolution.uex' path='docs/doc[@for="PrinterResolution.X"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the printer resolution in the horizontal direction,
        ///       in dots per inch.
        ///    </para>
        /// </devdoc>
        public int X {
            get {
                return x;
            }
        }

        /// <include file='doc\PrinterResolution.uex' path='docs/doc[@for="PrinterResolution.Y"]/*' />
        /// <devdoc>
        ///    <para> Gets the printer resolution in the vertical direction,
        ///       in dots per inch.</para>
        /// </devdoc>
        public int Y {
            get {
                return y;
            }
        }

        /// <include file='doc\PrinterResolution.uex' path='docs/doc[@for="PrinterResolution.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Provides some interesting information about the PrinterResolution in
        ///       String form.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            if (kind != PrinterResolutionKind.Custom)
                return "[PrinterResolution " + TypeDescriptor.GetConverter(typeof(PrinterResolutionKind)).ConvertToString((int) Kind)
                + "]";
            else
                return "[PrinterResolution"
                + " X=" + X.ToString()
                + " Y=" + Y.ToString()
                + "]";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\printdocument.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrintDocument.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {

    using Microsoft.Win32;
    using System;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System.Drawing;    
    using System.Drawing.Design;
    using System.Reflection;
    using System.Security;
    using System.Security.Permissions;

    /// <include file='doc\PrintDocument.uex' path='docs/doc[@for="PrintDocument"]/*' />
    /// <devdoc>
    ///    <para>Defines a reusable object that sends output to the
    ///       printer.</para>
    /// </devdoc>
    [
    ToolboxItemFilter("System.Drawing.Printing"),
    DefaultProperty("DocumentName"),
    DefaultEvent("PrintPage")
    ]
    public class PrintDocument : Component {
        private string documentName = "document";

        private PrintEventHandler beginPrintHandler;
        private PrintEventHandler endPrintHandler;
        private PrintPageEventHandler printPageHandler;
        private QueryPageSettingsEventHandler queryHandler;

        private PrinterSettings printerSettings = new PrinterSettings();
        private PageSettings defaultPageSettings;

        private PrintController printController = null;

        private bool originAtMargins = false;

        /// <include file='doc\PrintDocument.uex' path='docs/doc[@for="PrintDocument.PrintDocument"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Drawing.Printing.PrintDocument'/>
        /// class.</para>
        /// </devdoc>
        public PrintDocument() {
            defaultPageSettings = new PageSettings(printerSettings);
        }
        
        /// <include file='doc\PrintDocument.uex' path='docs/doc[@for="PrintDocument.DefaultPageSettings"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the
        ///       default
        ///       page settings for the document being printed.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.PDOCdocumentPageSettingsDescr)
        ]
        public PageSettings DefaultPageSettings {
            get { return defaultPageSettings;}
            set { 
                if (value == null)
                    value = new PageSettings();
                defaultPageSettings = value;
            }
        }

        /// <include file='doc\PrintDocument.uex' path='docs/doc[@for="PrintDocument.DocumentName"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the name to display to the user while printing the document;
        ///       for example, in a print status dialog or a printer
        ///       queue.</para>
        /// </devdoc>
        [
        DefaultValue("document"),
        SRDescription(SR.PDOCdocumentNameDescr)
        ]
        public string DocumentName {
            get { return documentName;}

            set {
                if (value == null)
                    value = "";
                documentName = value;
            }
        }

        /// <include file='doc\PrintDocument.uex' path='docs/doc[@for="PrintDocument.OriginAtMargins"]/*' />
        // If true, positions the origin of the graphics object 
        // associated with the page at the point just inside
        // the user-specified margins of the page.
        // If false, the graphics origin is at the top-left
        // corner of the printable area of the page.
        //
        [
        DefaultValue(false),
        SRDescription(SR.PDOCoriginAtMarginsDescr)
        ]
        public bool OriginAtMargins {
            get
            {
                return originAtMargins;
            }
            set
            {
                originAtMargins = value;
            }
        }

        /// <include file='doc\PrintDocument.uex' path='docs/doc[@for="PrintDocument.PrintController"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the <see cref='System.Drawing.Printing.PrintController'/> 
        /// that guides the printing process.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.PDOCprintControllerDescr)
        ]
        public PrintController PrintController {
            get { 
                IntSecurity.SafePrinting.Demand();

                if (printController == null) {
                    printController = new StandardPrintController();
                    new ReflectionPermission(PermissionState.Unrestricted).Assert();
                    try {
                        try {
                            Type type = Type.GetType("System.Windows.Forms.PrintControllerWithStatusDialog, " + AssemblyRef.SystemWindowsForms);
                            printController = (PrintController) Activator.CreateInstance(type, 
                                BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.CreateInstance, 
                                null, new object[] { printController}, null);
                        }
                        catch (Exception) {
                            Debug.Fail("Can't find System.Windows.Forms.PrintControllerWithStatusDialog, proceeding with StandardPrintController");
                        }
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }
                return printController;
            }
            set {
                IntSecurity.SafePrinting.Demand();

                printController = value;
            }
        }

        /// <include file='doc\PrintDocument.uex' path='docs/doc[@for="PrintDocument.PrinterSettings"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets the printer on which the
        ///       document is printed.</para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden),
        SRDescription(SR.PDOCprinterSettingsDescr)
        ]
        public PrinterSettings PrinterSettings {
            get { return printerSettings;}
            set { 
                if (value == null)
                    value = new PrinterSettings();
                printerSettings = value;
            }
        }

        /// <include file='doc\PrintDocument.uex' path='docs/doc[@for="PrintDocument.BeginPrint"]/*' />
        /// <devdoc>
        /// <para>Occurs when the <see cref='System.Drawing.Printing.PrintDocument.Print'/> method is called, before 
        ///    the
        ///    first page prints.</para>
        /// </devdoc>
        [SRDescription(SR.PDOCbeginPrintDescr)]
        public event PrintEventHandler BeginPrint {
            add {
                beginPrintHandler += value;
            }
            remove {
                beginPrintHandler -= value;
            }
        }

        /// <include file='doc\PrintDocument.uex' path='docs/doc[@for="PrintDocument.EndPrint"]/*' />
        /// <devdoc>
        /// <para>Occurs when <see cref='System.Drawing.Printing.PrintDocument.Print'/> is
        ///    called, after the last page is printed.</para>
        /// </devdoc>
        [SRDescription(SR.PDOCendPrintDescr)]
        public event PrintEventHandler EndPrint {
            add {
                endPrintHandler += value;
            }
            remove {
                endPrintHandler -= value;
            }
        }

        /// <include file='doc\PrintDocument.uex' path='docs/doc[@for="PrintDocument.PrintPage"]/*' />
        /// <devdoc>
        ///    <para>Occurs when a page is printed. </para>
        /// </devdoc>
        [SRDescription(SR.PDOCprintPageDescr)]
        public event PrintPageEventHandler PrintPage {
            add {
                printPageHandler += value;
            }
            remove {
                printPageHandler -= value;
            }
        }

        /// <include file='doc\PrintDocument.uex' path='docs/doc[@for="PrintDocument.QueryPageSettings"]/*' />
        /// <devdoc>
        ///    <para>Occurs</para>
        /// </devdoc>
        [SRDescription(SR.PDOCqueryPageSettingsDescr)]
        public event QueryPageSettingsEventHandler QueryPageSettings {
            add {
                queryHandler += value;
            }
            remove {
                queryHandler -= value;
            }
        }

        internal void _OnBeginPrint(PrintEventArgs e) {
            OnBeginPrint(e);
        }

        /// <include file='doc\PrintDocument.uex' path='docs/doc[@for="PrintDocument.OnBeginPrint"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='E:System.Drawing.Printing.PrintDocument.BeginPrint'/>
        /// event.</para>
        /// </devdoc>
        protected virtual void OnBeginPrint(PrintEventArgs e) {
            if (beginPrintHandler != null)
                beginPrintHandler(this, e);
        }

        internal void _OnEndPrint(PrintEventArgs e) {
            OnEndPrint(e);
        }

        /// <include file='doc\PrintDocument.uex' path='docs/doc[@for="PrintDocument.OnEndPrint"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='E:System.Drawing.Printing.PrintDocument.EndPrint'/>
        /// event.</para>
        /// </devdoc>
        protected virtual void OnEndPrint(PrintEventArgs e) {
            if (endPrintHandler != null)
                endPrintHandler(this, e);
        }

        internal void _OnPrintPage(PrintPageEventArgs e) {
            OnPrintPage(e);
        }

        /// <include file='doc\PrintDocument.uex' path='docs/doc[@for="PrintDocument.OnPrintPage"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='E:System.Drawing.Printing.PrintDocument.PrintPage'/>
        /// event.</para>
        /// </devdoc>
        // CONSIDER: print page or page print?
        protected virtual void OnPrintPage(PrintPageEventArgs e) {
            if (printPageHandler != null)
                printPageHandler(this, e);
        }

        internal void _OnQueryPageSettings(QueryPageSettingsEventArgs e) {
            OnQueryPageSettings(e);
        }

        /// <include file='doc\PrintDocument.uex' path='docs/doc[@for="PrintDocument.OnQueryPageSettings"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='E:System.Drawing.Printing.PrintDocument.QueryPageSettings'/> event.</para>
        /// </devdoc>
        protected virtual void OnQueryPageSettings(QueryPageSettingsEventArgs e) {
            if (queryHandler != null)
                queryHandler(this, e);
        }

        /// <include file='doc\PrintDocument.uex' path='docs/doc[@for="PrintDocument.Print"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Prints the document.
        ///    </para>
        /// </devdoc>
        public void Print() {
            PrintController controller = PrintController;
            controller.Print(this);
        }

        /// <include file='doc\PrintDocument.uex' path='docs/doc[@for="PrintDocument.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Provides some interesting information about the PrintDocument in
        ///       String form.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            return "[PrintDocument " + DocumentName + "]";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\printerunitconvert.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrinterUnitConvert.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;    
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\PrinterUnitConvert.uex' path='docs/doc[@for="PrinterUnitConvert"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies a series of conversion methods that are
    ///       useful when interoperating with the raw Win32 printing API.
    ///       This class cannot be inherited.
    ///    </para>
    /// </devdoc>
    public sealed class PrinterUnitConvert {
        private PrinterUnitConvert() {
        }

        /// <include file='doc\PrinterUnitConvert.uex' path='docs/doc[@for="PrinterUnitConvert.Convert"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the value, in fromUnit units, to toUnit units.
        ///    </para>
        /// </devdoc>
        public static double Convert(double value, PrinterUnit fromUnit, PrinterUnit toUnit) {
            double fromUnitsPerDisplay = UnitsPerDisplay(fromUnit);
            double toUnitsPerDisplay = UnitsPerDisplay(toUnit);
            return value * toUnitsPerDisplay / fromUnitsPerDisplay;
        }

        /// <include file='doc\PrinterUnitConvert.uex' path='docs/doc[@for="PrinterUnitConvert.Convert1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the value, in fromUnit units, to toUnit units.
        ///    </para>
        /// </devdoc>
        public static int Convert(int value, PrinterUnit fromUnit, PrinterUnit toUnit) {
            return(int) Math.Round(Convert((double)value, fromUnit, toUnit));
        }

        /// <include file='doc\PrinterUnitConvert.uex' path='docs/doc[@for="PrinterUnitConvert.Convert2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the value, in fromUnit units, to toUnit units.
        ///    </para>
        /// </devdoc>
        public static Point Convert(Point value, PrinterUnit fromUnit, PrinterUnit toUnit) {
            return new Point(
                            Convert(value.X, fromUnit, toUnit),
                            Convert(value.Y, fromUnit, toUnit)
                            );
        }

        /// <include file='doc\PrinterUnitConvert.uex' path='docs/doc[@for="PrinterUnitConvert.Convert3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the value, in fromUnit units, to toUnit units.
        ///    </para>
        /// </devdoc>
        public static Size Convert(Size value, PrinterUnit fromUnit, PrinterUnit toUnit) {
            return new Size(
                           Convert(value.Width, fromUnit, toUnit),
                           Convert(value.Height, fromUnit, toUnit)
                           );
        }

        /// <include file='doc\PrinterUnitConvert.uex' path='docs/doc[@for="PrinterUnitConvert.Convert4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the value, in fromUnit units, to toUnit units.
        ///    </para>
        /// </devdoc>
        public static Rectangle Convert(Rectangle value, PrinterUnit fromUnit, PrinterUnit toUnit) {
            return new Rectangle(
                                Convert(value.X, fromUnit, toUnit),
                                Convert(value.Y, fromUnit, toUnit),
                                Convert(value.Width, fromUnit, toUnit),
                                Convert(value.Height, fromUnit, toUnit)
                                );
        }

        /// <include file='doc\PrinterUnitConvert.uex' path='docs/doc[@for="PrinterUnitConvert.Convert5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the value, in fromUnit units, to toUnit units.
        ///    </para>
        /// </devdoc>
        public static Margins Convert(Margins value, PrinterUnit fromUnit, PrinterUnit toUnit) {
            Margins result = new Margins();

            result.Left = Convert(value.Left, fromUnit, toUnit);
            result.Right = Convert(value.Right, fromUnit, toUnit);
            result.Top = Convert(value.Top, fromUnit, toUnit);
            result.Bottom = Convert(value.Bottom, fromUnit, toUnit);

            return result;
        }

        private static double UnitsPerDisplay(PrinterUnit unit) {
            double result;
            switch (unit) {
                case PrinterUnit.Display:
                    result = 1.0;
                    break;
                case PrinterUnit.ThousandthsOfAnInch:
                    result = 10.0;
                    break;
                case PrinterUnit.HundredthsOfAMillimeter:
                    result = 25.4;
                    break;
                case PrinterUnit.TenthsOfAMillimeter:
                    result = 2.54;
                    break;
                default:
                    Debug.Fail("Unknown PrinterUnit " + unit);
                    result = 1.0;
                    break; 
            }

            return result;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\printerunit.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrinterUnit.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;    
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\PrinterUnit.uex' path='docs/doc[@for="PrinterUnit"]/*' />
    /// <devdoc>
    ///    <para>Specifies several of
    ///       the units of measure Microsoft Win32 uses for printing.</para>
    /// </devdoc>
    public enum PrinterUnit {
        /// <include file='doc\PrinterUnit.uex' path='docs/doc[@for="PrinterUnit.Display"]/*' />
        /// <devdoc>
        ///    <para>The default unit (0.01 in.).</para>
        /// </devdoc>
        // Our default units, as well as GDI+'s
        Display = 0,

        /// <include file='doc\PrinterUnit.uex' path='docs/doc[@for="PrinterUnit.ThousandthsOfAnInch"]/*' />
        /// <devdoc>
        ///    <para>One
        ///       thousandth of an inch
        ///       (0.001 in.).</para>
        /// </devdoc>
        // Used by PAGESETUPDLG.rtMargin and rtMinMargin
        ThousandthsOfAnInch = 1,

        /// <include file='doc\PrinterUnit.uex' path='docs/doc[@for="PrinterUnit.HundredthsOfAMillimeter"]/*' />
        /// <devdoc>
        ///    <para>One hundredth of a millimeter
        ///       (0.01 mm).</para>
        /// </devdoc>
        // Used by PAGESETUPDLG.rtMargin and rtMinMargin
        HundredthsOfAMillimeter = 2,

        /// <include file='doc\PrinterUnit.uex' path='docs/doc[@for="PrinterUnit.TenthsOfAMillimeter"]/*' />
        /// <devdoc>
        ///    <para>One tenth of a millimeter
        ///       (0.1 mm).</para>
        /// </devdoc>
        // DeviceCapabilities(DC_PAPERSIZE)
        TenthsOfAMillimeter = 3,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\printeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrintEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {

    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\PrintEventHandler.uex' path='docs/doc[@for="PrintEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='E:System.Drawing.Printing.PrintDocument.BeginPrint'/>,
    ///    <see cref='E:System.Drawing.Printing.PrintDocument.EndPrint'/>, or <see cref='E:System.Drawing.Printing.PrintDocument.QueryPageSettings'/> event of a <see cref='System.Drawing.Printing.PrintDocument'/>.
    ///    </para>
    /// </devdoc>
    public delegate void PrintEventHandler(object sender, PrintEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\printingpermissionattribute.cs ===
/*
 * Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
 * Microsoft Confidential.
 */

namespace System.Drawing.Printing {
    using System;
    using System.Security;
    using System.Security.Util;
    using System.Security.Permissions;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Reflection;
    using System.Collections;

    /// <include file='doc\PrintingPermissionAttribute.uex' path='docs/doc[@for="PrintingPermissionAttribute"]/*' />
    [AttributeUsage(AttributeTargets.All, AllowMultiple = true)]
    public sealed class PrintingPermissionAttribute : CodeAccessSecurityAttribute {
        PrintingPermissionLevel level;

        /// <include file='doc\PrintingPermissionAttribute.uex' path='docs/doc[@for="PrintingPermissionAttribute.PrintingPermissionAttribute"]/*' />        
        public PrintingPermissionAttribute(SecurityAction action) : base(action) {
        }


        /// <include file='doc\PrintingPermissionAttribute.uex' path='docs/doc[@for="PrintingPermissionAttribute.Level"]/*' />
        public PrintingPermissionLevel Level {
            get {
                return level;
            }
            
            set {
                if (value < PrintingPermissionLevel.NoPrinting || value > PrintingPermissionLevel.AllPrinting) {
                    throw new ArgumentException("value");
                }
                level = value;
            }
        }

        /// <include file='doc\PrintingPermissionAttribute.uex' path='docs/doc[@for="PrintingPermissionAttribute.CreatePermission"]/*' />
        public override IPermission CreatePermission() {
            if (Unrestricted) {
                return new PrintingPermission(PermissionState.Unrestricted);
            }
            else {
                return new PrintingPermission(level);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\printevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrintEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {

    using System.Diagnostics;
    using System;
    using System.Drawing;
    using Microsoft.Win32;
    using System.ComponentModel;

    /// <include file='doc\PrintEvent.uex' path='docs/doc[@for="PrintEventArgs"]/*' />    
    /// <devdoc>
    /// <para>Provides data for the <see cref='E:System.Drawing.Printing.PrintDocument.BeginPrint'/> and
    /// <see cref='E:System.Drawing.Printing.PrintDocument.EndPrint'/> events.</para>
    /// </devdoc>
    public class PrintEventArgs : CancelEventArgs {
        /// <include file='doc\PrintEvent.uex' path='docs/doc[@for="PrintEventArgs.PrintEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Printing.PrintEventArgs'/> class.
        ///    </para>
        /// </devdoc>
        public PrintEventArgs() {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\printingpermissionlevel.cs ===
/*
 * PrintingPermission.cool
 *
 * Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
 * Microsoft Confidential.
 */

namespace System.Drawing.Printing {
    using System;

    /// <include file='doc\PrintingPermissionLevel.uex' path='docs/doc[@for="PrintingPermissionLevel"]/*' />
    /// <devdoc>
    ///    <para>Specifies the type of printing that code is allowed to do.</para>
    /// </devdoc>
    public enum PrintingPermissionLevel {
        /**
         * No printing use allowed at all.
         */
        /// <include file='doc\PrintingPermissionLevel.uex' path='docs/doc[@for="PrintingPermissionLevel.NoPrinting"]/*' />
        /// <devdoc>
        ///    <para>Users have no ability to use any printers.</para>
        /// </devdoc>
        NoPrinting = 0x0,

        /**
         * Only allow safe printing use.
         */
        /// <include file='doc\PrintingPermissionLevel.uex' path='docs/doc[@for="PrintingPermissionLevel.SafePrinting"]/*' />
        /// <devdoc>
        ///    <para>Users can only use safe printing to print from a restricted dialog box.</para>
        /// </devdoc>
        SafePrinting = 0x01,

        /**
         * Use of the default printer allowed.
         */
        /// <include file='doc\PrintingPermissionLevel.uex' path='docs/doc[@for="PrintingPermissionLevel.DefaultPrinting"]/*' />
        /// <devdoc>
        ///    <para>Users can print programmically to the default printer along with safe printing through
        ///          a less restricted dialog box.</para>
        /// </devdoc>
        DefaultPrinting = 0x02,

        /**
         * All windows and all event may be used.
         */
        /// <include file='doc\PrintingPermissionLevel.uex' path='docs/doc[@for="PrintingPermissionLevel.AllPrinting"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Users have full access to all printers on the network.
        ///    </para>
        /// </devdoc>
        AllPrinting = 0x03,

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\printersettings.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrinterSettings.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {
    using System.Runtime.Serialization.Formatters;
    using System.Configuration.Assemblies;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;    
    using System.Security;
    using System.Security.Permissions;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings"]/*' />
    /// <devdoc>
    ///    Information about how a document should be printed, including which printer
    ///    to print it on.
    /// </devdoc>
#if !CPB        // cpb 50004
    [ComVisible(false)]
#endif
    [Serializable]
    public class PrinterSettings : ICloneable {
        // All read/write data is stored in managed code, and whenever we need to call Win32,
        // we create new DEVMODE and DEVNAMES structures.  We don't store device capabilities,
        // though.
        //
        // Also, all properties have hidden tri-state logic -- yes/no/default

        private string printerName = null; // default printer.
        private string driverName = "";
        private string outputPort = "";
        private bool printToFile = false;

        // Whether the PrintDialog has been shown (not whether it's currently shown).  This is how we enforce SafePrinting.
        private bool printDialogDisplayed = false;

        private short extrabytes = 0;
        private byte[] extrainfo;

        private short copies = -1;
        private Duplex duplex = System.Drawing.Printing.Duplex.Default;
        private TriState collate = TriState.Default;
        private PageSettings defaultPageSettings;
        private int fromPage = 0;
        private int toPage = 0;
        private int maxPage = 9999;
        private int minPage = 0;
        private PrintRange printRange;

        private short  devmodebytes = 0;
        private byte[] cachedDevmode;

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PrinterSettings"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Printing.PrinterSettings'/> class.
        ///    </para>
        /// </devdoc>
        public PrinterSettings() {
            defaultPageSettings = new PageSettings(this);
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.CanDuplex"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the printer supports duplex (double-sided) printing.
        ///    </para>
        /// </devdoc>
        public bool CanDuplex {
            get { return DeviceCapabilities(SafeNativeMethods.DC_DUPLEX, IntPtr.Zero, 0) == 1;}
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.Copies"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the number of copies to print.
        ///    </para>
        /// </devdoc>
        public short Copies {
            get {
                if (copies != -1)
                    return copies;
                else
                    return GetModeField(ModeField.Copies, 1);
            }
            set {
                if (value < 0)
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx,
                                                             "value", value.ToString(), "0"));
                copies = value;
            }
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.Collate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       a value indicating whether the print out is collated.
        ///    </para>
        /// </devdoc>
        public bool Collate {
            get {
                if (!collate.IsDefault)
                    return(bool) collate;
                else
                    return GetModeField(ModeField.Collate, SafeNativeMethods.DMCOLLATE_FALSE) == SafeNativeMethods.DMCOLLATE_TRUE;
            }
            set { collate = value;}
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.DefaultPageSettings"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the default page settings for this printer.
        ///    </para>
        /// </devdoc>
        public PageSettings DefaultPageSettings {
            get { return defaultPageSettings;}
        }

        // As far as I can tell, Windows no longer pays attention to driver names and output ports.
        // But I'm leaving this code in place in case I'm wrong.
        internal string DriverName {
            get { return driverName;}
            set { driverName = value;}
        }

        /* // No point in having a driver version if you can't get the driver name
        /// <summary>
        ///    <para>
        ///       Gets the printer driver version number.
        ///    </para>
        /// </summary>
        /// <value>
        ///    <para>
        ///       The printer driver version number.
        ///    </para>
        /// </value>
        public int DriverVersion {
            get { return DeviceCapabilities(SafeNativeMethods.DC_DRIVER, 0, -1);}
        }
        */

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.Duplex"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the printer's duplex setting.
        ///    </para>
        /// </devdoc>
        public Duplex Duplex {
            get {
                if (duplex != Duplex.Default)
                    return duplex;
                else
                    return(Duplex) GetModeField(ModeField.Duplex, SafeNativeMethods.DMDUP_SIMPLEX);
            }
            set { 
                if (!Enum.IsDefined(typeof(Duplex), value))
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(Duplex));

                duplex = value;
            }
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.FromPage"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the first page to print.</para>
        /// </devdoc>
        public int FromPage {
            get { return fromPage;}
            set {
                if (value < 0)
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx,
                                                             "value", value.ToString(), "0"));
                fromPage = value;
            }
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.InstalledPrinters"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the names of all printers installed on the machine.
        ///    </para>
        /// </devdoc>
        public static StringCollection InstalledPrinters {
            get {
                IntSecurity.AllPrinting.Demand();

                int returnCode;
                int bufferSize;
                int count;
                int level, sizeofstruct;
                
                new EnvironmentPermission(PermissionState.Unrestricted).Assert();
                try {
                    // Note: Level 5 doesn't seem to work properly on NT platforms
                    // (atleast the call to get the size of the buffer reqd.),
                    // and Level 4 doesn't work on Win9x.
                    //
                    if (Environment.OSVersion.Platform == System.PlatformID.Win32NT) {
                        level = 4;
                        // PRINTER_INFO_4 are 12 bytes in size
                        sizeofstruct = 12;
                    }
                    else {
                        level = 5;
                        // PRINTER_INFO_5 are 20 bytes in size
                        sizeofstruct = 20;
                    }
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }
                
                
                string[] array;

                IntSecurity.UnmanagedCode.Assert();
                try {
                    SafeNativeMethods.EnumPrinters(SafeNativeMethods.PRINTER_ENUM_LOCAL | SafeNativeMethods.PRINTER_ENUM_CONNECTIONS, null, level, IntPtr.Zero, 0, out bufferSize, out count);

                    IntPtr buffer = Marshal.AllocCoTaskMem(bufferSize);
                    returnCode = SafeNativeMethods.EnumPrinters(SafeNativeMethods.PRINTER_ENUM_LOCAL | SafeNativeMethods.PRINTER_ENUM_CONNECTIONS,
                                                            null, level, buffer,
                                                            bufferSize, out bufferSize, out count);
                    array = new string[count];

                    if (returnCode == 0) {
                        Marshal.FreeCoTaskMem(buffer);
                        throw new Win32Exception();
                    }

                    for (int i = 0; i < count; i++) {
                        // The printer name is at offset 0
                        //
                        IntPtr namePointer = (IntPtr) Marshal.ReadInt32((IntPtr)((long)buffer + i * sizeofstruct));
                        array[i] = Marshal.PtrToStringAuto(namePointer);
                    }

                    Marshal.FreeCoTaskMem(buffer);
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }

                return new StringCollection(array);
            }
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.IsDefaultPrinter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the <see cref='System.Drawing.Printing.PrinterSettings.PrinterName'/>
        ///       property designates the default printer.
        ///    </para>
        /// </devdoc>
        public bool IsDefaultPrinter {
            get {
                return printerName == null;
            }
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.IsPlotter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the printer is a plotter, as opposed to a raster printer.
        ///    </para>
        /// </devdoc>
        public bool IsPlotter {
            get {
                return GetDeviceCaps(SafeNativeMethods.TECHNOLOGY, SafeNativeMethods.DT_RASPRINTER) == SafeNativeMethods.DT_PLOTTER;
            }
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.IsValid"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the <see cref='System.Drawing.Printing.PrinterSettings.PrinterName'/>
        ///       property designates a valid printer.
        ///    </para>
        /// </devdoc>
        public bool IsValid {
            get {
                return DeviceCapabilities(SafeNativeMethods.DC_COPIES, IntPtr.Zero, -1) != -1;
            }
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.LandscapeAngle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the angle, in degrees, which the portrait orientation is rotated
        ///       to produce the landscape orientation.
        ///    </para>
        /// </devdoc>
        public int LandscapeAngle {
            get { return DeviceCapabilities(SafeNativeMethods.DC_ORIENTATION, IntPtr.Zero, 0);}
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.MaximumCopies"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the maximum number of copies allowed by the printer.
        ///    </para>
        /// </devdoc>
        public int MaximumCopies {
            get { return DeviceCapabilities(SafeNativeMethods.DC_COPIES, IntPtr.Zero, 1);}
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.MaximumPage"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the highest <see cref='System.Drawing.Printing.PrinterSettings.FromPage'/> or <see cref='System.Drawing.Printing.PrinterSettings.ToPage'/>
        ///       which may be selected in a print dialog box.
        ///    </para>
        /// </devdoc>
        public int MaximumPage {
            get { return maxPage;}
            set {
                if (value < 0)
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx,
                                                             "value", value.ToString(), "0"));
                maxPage = value;
            }

        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.MinimumPage"]/*' />
        /// <devdoc>
        /// <para>Gets or sets the lowest <see cref='System.Drawing.Printing.PrinterSettings.FromPage'/> or <see cref='System.Drawing.Printing.PrinterSettings.ToPage'/>
        /// which may be selected in a print dialog box.</para>
        /// </devdoc>
        public int MinimumPage {
            get { return minPage;}
            set {
                if (value < 0)
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx,
                                                             "value", value.ToString(), "0"));
                minPage = value;
            }
        }

        internal string OutputPort {
            get { return outputPort;}
            set { outputPort = value;}
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSizes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the paper sizes supported by this printer.
        ///    </para>
        /// </devdoc>
        public PaperSizeCollection PaperSizes {
            get { return new PaperSizeCollection(Get_PaperSizes());}
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSources"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the paper sources available on this printer.
        ///    </para>
        /// </devdoc>
        public PaperSourceCollection PaperSources {
            get { return new PaperSourceCollection(Get_PaperSources());}
        }

        /// <devdoc>
        ///    <para>
        ///        Whether the print dialog has been displayed.  In SafePrinting mode,
        ///        a print dialog is required to print.  After printing,
        ///        this property is set to false if the program does not have AllPrinting;
        ///        this guarantees a document is only printed once each time the print dialog is shown.
        ///    </para>
        /// </devdoc>
        internal bool PrintDialogDisplayed {
            // CONSIDER: currently internal, but could be made public.
            // If you do that in v1, it would probably be best if set_PrinterName did not set this property.

            get {
                // no security check

                return printDialogDisplayed;
            }

            set {
                IntSecurity.AllPrinting.Demand();
                printDialogDisplayed = value;
            }
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PrintRange"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Gets or sets the pages the user has asked to print.</para>
        /// </devdoc>
        public PrintRange PrintRange {
            get { return printRange;}
            set { 
                if (!Enum.IsDefined(typeof(PrintRange), value))
                    throw new InvalidEnumArgumentException("value", (int)value, typeof(PrintRange));

                printRange = value;
            }
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PrintToFile"]/*' />
        /// <devdoc>
        ///       Indicates whether to print to a file instead of a port.
        /// </devdoc>
        public bool PrintToFile {
            get {
                return printToFile;
            }
            set {
                printToFile = value;
            }
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PrinterName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the name of the printer.
        ///    </para>
        /// </devdoc>
        public string PrinterName {
            get { 
                IntSecurity.AllPrinting.Demand();
                return PrinterNameInternal;
            }

            set {
                IntSecurity.AllPrinting.Demand();
                PrinterNameInternal = value;
            }
        }

        private string PrinterNameInternal {
            get {
                if (printerName == null)
                    return GetDefaultPrinterName();
                else
                    return printerName;
            }
            set {
                // Reset the DevMode and Extrabytes...
                cachedDevmode = null;
                extrainfo = null;
                printerName = value;
                PrintDialogDisplayed = true;
            }
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PrinterResolutions"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the resolutions supported by this printer.
        ///    </para>
        /// </devdoc>
        public PrinterResolutionCollection PrinterResolutions {
            get { return new PrinterResolutionCollection(Get_PrinterResolutions());}
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.SupportsColor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a
        ///       value indicating whether the printer supports color printing.
        ///    </para>
        /// </devdoc>
        public bool SupportsColor {
            get {
                // CONSIDER: DeviceCaps has nothing as simple as "supports color" -- hopefully
                // this does the right thing
                return GetDeviceCaps(SafeNativeMethods.BITSPIXEL, 1) > 1;
            }
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.ToPage"]/*' />
        /// <devdoc>
        ///    Gets or sets the last page to print.
        /// </devdoc>
        public int ToPage {
            get { return toPage;}
            set {
                if (value < 0)
                    throw new ArgumentException(SR.GetString(SR.InvalidLowBoundArgumentEx,
                                                             "value", value.ToString(), "0"));
                toPage = value;
            }
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.Clone"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an identical copy of this object.
        ///    </para>
        /// </devdoc>
        public object Clone() {
            PrinterSettings clone = (PrinterSettings) MemberwiseClone();
            clone.printDialogDisplayed = false;
            return clone;
        }

        private IntPtr CreateHdc() {
            IntPtr modeHandle = GetHdevmodeInternal();

            //Copy the PageSettings to the DEVMODE...
            //Assert permission as CopyToHdevmode() demands...
            
            IntSecurity.AllPrinting.Assert();
            try 
            {
                defaultPageSettings.CopyToHdevmode(modeHandle);
            }
            finally
            {
                CodeAccessPermission.RevertAssert();
            }
            
            IntPtr result = CreateHdc(modeHandle);
            SafeNativeMethods.GlobalFree(new HandleRef(null, modeHandle));
            return result;
        }

        internal IntPtr CreateHdc(IntPtr hdevmode) {
            IntPtr modePointer = SafeNativeMethods.GlobalLock(new HandleRef(null, hdevmode));
            IntPtr dc = UnsafeNativeMethods.CreateDC(DriverName, PrinterNameInternal, (string) null, new HandleRef(null, modePointer));
            SafeNativeMethods.GlobalUnlock(new HandleRef(null, hdevmode));
            if (dc == IntPtr.Zero)
                throw new InvalidPrinterException(this);
            return dc;
        }

        // A read-only DC, which is faster than CreateHdc
        private IntPtr CreateIC() {
            IntPtr modeHandle = GetHdevmodeInternal();
            IntPtr result = CreateIC(modeHandle);
            SafeNativeMethods.GlobalFree(new HandleRef(null, modeHandle));
            return result;
        }

        // A read-only DC, which is faster than CreateHdc
        internal IntPtr CreateIC(IntPtr hdevmode) {
            IntPtr modePointer = SafeNativeMethods.GlobalLock(new HandleRef(null, hdevmode));
            IntPtr dc = UnsafeNativeMethods.CreateIC(DriverName, PrinterNameInternal, (string) null, new HandleRef(null, modePointer));
            SafeNativeMethods.GlobalUnlock(new HandleRef(null, hdevmode));
            if (dc == IntPtr.Zero)
                throw new InvalidPrinterException(this);
            return dc;
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.CreateMeasurementGraphics"]/*' />
        public Graphics CreateMeasurementGraphics() {
            // returns the Graphics object for the printer
            IntPtr hDC = CreateHdc();
            if (hDC != IntPtr.Zero)
                return Graphics.FromHdcInternal(hDC);
            return null;
        }
                        
        // Create a PRINTDLG with a few useful defaults.
        // Try to keep this consistent with PrintDialog.CreatePRINTDLG.
        private static SafeNativeMethods.PRINTDLG CreatePRINTDLG() {
            SafeNativeMethods.PRINTDLG data = new SafeNativeMethods.PRINTDLG();
            data.lStructSize = 66;
            data.hwndOwner = IntPtr.Zero;
            data.hDevMode = IntPtr.Zero;
            data.hDevNames = IntPtr.Zero;
            data.Flags = 0;
            data.hwndOwner = IntPtr.Zero;
            data.hDC = IntPtr.Zero;
            data.nFromPage = 1;
            data.nToPage = 1;
            data.nMinPage = 0;
            data.nMaxPage = 9999;
            data.nCopies = 1;
            data.hInstance = IntPtr.Zero;
            data.lCustData = IntPtr.Zero;
            data.lpfnPrintHook = null;
            data.lpfnSetupHook = null;
            data.lpPrintTemplateName = null;
            data.lpSetupTemplateName = null;
            data.hPrintTemplate = IntPtr.Zero;
            data.hSetupTemplate = IntPtr.Zero;
            return data;
        }

        //  Use FastDeviceCapabilities where possible -- computing PrinterName is quite slow
        private int DeviceCapabilities(short capability, IntPtr pointerToBuffer, int defaultValue) {
            IntSecurity.AllPrinting.Assert();
            string printerName = PrinterName;
            CodeAccessPermission.RevertAssert();

            IntSecurity.UnmanagedCode.Assert();

            return FastDeviceCapabilities(capability, pointerToBuffer, defaultValue, printerName);
        }

        // We pass PrinterName in as a parameter rather than computing it ourselves because it's expensive to compute.
        private int FastDeviceCapabilities(short capability, IntPtr pointerToBuffer, int defaultValue, string printerName) {
            int result = SafeNativeMethods.DeviceCapabilities(printerName, OutputPort,
                                                          capability, pointerToBuffer, IntPtr.Zero);
            if (result == -1)
                return defaultValue;
            return result;
        }

        // Called by get_PrinterName
        private static string GetDefaultPrinterName() {
            IntSecurity.UnmanagedCode.Assert();

            SafeNativeMethods.PRINTDLG data = CreatePRINTDLG();
            data.Flags = SafeNativeMethods.PD_RETURNDEFAULT;

            bool status = SafeNativeMethods.PrintDlg(data);
            if (!status)
                return SR.GetString(SR.NoDefaultPrinter);

            IntPtr handle = data.hDevNames;
            IntPtr names = SafeNativeMethods.GlobalLock(new HandleRef(data, handle));
            if (names == IntPtr.Zero)
                throw new Win32Exception();

            string name = ReadOneDEVNAME(names, 1);
            SafeNativeMethods.GlobalUnlock(new HandleRef(data, handle));
            names = IntPtr.Zero;

            // Windows allocates them, but we have to free them
            SafeNativeMethods.GlobalFree(new HandleRef(data, data.hDevNames));
            SafeNativeMethods.GlobalFree(new HandleRef(data, data.hDevMode));

            return name;
        }

        private int GetDeviceCaps(int capability, int defaultValue) {
            try {
                IntPtr dc = CreateIC();
                int result = UnsafeNativeMethods.GetDeviceCaps(new HandleRef(null, dc), capability);
                SafeNativeMethods.DeleteDC(new HandleRef(null, dc));
                return result;
            }
            catch (InvalidPrinterException) {
                return defaultValue;
            }
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.GetHdevmode"]/*' />
        /// <devdoc>
        ///    <para>Creates a handle to a DEVMODE structure which correspond too the printer settings.
        ///       When you are done with the handle, you must deallocate it yourself:
        ///       Windows.GlobalFree(handle);
        ///       Where "handle" is the return value from this method.</para>
        /// </devdoc>
        public IntPtr GetHdevmode() {
            IntSecurity.AllPrinting.Demand();
            // Don't assert unmanaged code -- anyone using handles should have unmanaged code permission
            return GetHdevmodeInternal();
        }

        internal IntPtr GetHdevmodeInternal() {
            // getting the printer name is quite expensive if PrinterName is left default,
            // because it needs to figure out what the default printer is
            string printerName = PrinterNameInternal;

            // Create DEVMODE
            int modeSize = SafeNativeMethods.DocumentProperties(NativeMethods.NullHandleRef, NativeMethods.NullHandleRef, printerName, IntPtr.Zero, NativeMethods.NullHandleRef, 0);
            if (modeSize < 1)
                throw new InvalidPrinterException(this);

            IntPtr handle = SafeNativeMethods.GlobalAlloc(SafeNativeMethods.GMEM_MOVEABLE, modeSize);
            IntPtr pointer = SafeNativeMethods.GlobalLock(new HandleRef(null, handle));

            //Get the DevMode only if its not cached....
            if (cachedDevmode != null) {
                Marshal.Copy(cachedDevmode, 0, pointer, devmodebytes);
            }
            else {
                int returnCode = SafeNativeMethods.DocumentProperties(NativeMethods.NullHandleRef, NativeMethods.NullHandleRef, printerName, pointer, NativeMethods.NullHandleRef, SafeNativeMethods.DM_OUT_BUFFER);
                if (returnCode < 0)
                    throw new Win32Exception();
            }

            SafeNativeMethods.DEVMODE mode = (SafeNativeMethods.DEVMODE) UnsafeNativeMethods.PtrToStructure(pointer, typeof(SafeNativeMethods.DEVMODE));
            
            IntPtr pointeroffset = (IntPtr)((long)pointer + (long)mode.dmSize); 
            if (extrainfo != null)  
                Marshal.Copy(extrainfo,0, pointeroffset, extrabytes);
            
            if (copies != -1) mode.dmCopies = copies;
            if ((int)duplex != -1) mode.dmDuplex = (short) duplex;
            if (collate.IsNotDefault)
                mode.dmCollate = (short) (((bool) collate) ? SafeNativeMethods.DMCOLLATE_TRUE : SafeNativeMethods.DMCOLLATE_FALSE);
            
            Marshal.StructureToPtr(mode, pointer, false);
            SafeNativeMethods.GlobalUnlock(new HandleRef(null, handle));

            return handle;
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.GetHdevmode1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a handle to a DEVMODE structure which correspond to the printer
        ///       and page settings.
        ///       When you are done with the handle, you must deallocate it yourself:
        ///       Windows.GlobalFree(handle);
        ///       Where "handle" is the return value from this method.
        ///    </para>
        /// </devdoc>
        public IntPtr GetHdevmode(PageSettings pageSettings) {
            IntSecurity.AllPrinting.Demand();
            // Don't assert unmanaged code -- anyone using handles should have unmanaged code permission

            IntPtr handle = GetHdevmodeInternal();
            pageSettings.CopyToHdevmode(handle);
            return handle;
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.GetHdevnames"]/*' />
        /// <devdoc>
        ///    Creates a handle to a DEVNAMES structure which correspond to the printer settings.
        ///    When you are done with the handle, you must deallocate it yourself:
        ///    Windows.GlobalFree(handle);
        ///    Where "handle" is the return value from this method.
        /// </devdoc>
        public IntPtr GetHdevnames() {
            IntSecurity.AllPrinting.Demand();
            // Don't assert unmanaged code -- anyone using handles should have unmanaged code permission

            string printerName = PrinterName; // the PrinterName property is slow when using the default printer

            // Create DEVNAMES structure
            // +4 for null terminator
            int namesCharacters = 4 + printerName.Length + DriverName.Length + OutputPort.Length;

            // 8 = size of fixed portion of DEVNAMES
            short offset = (short) (8 / Marshal.SystemDefaultCharSize); // Offsets are in characters, not bytes
            int namesSize = Marshal.SystemDefaultCharSize * (offset + namesCharacters);
            IntPtr handle = SafeNativeMethods.GlobalAlloc(SafeNativeMethods.GMEM_MOVEABLE, namesSize);
            IntPtr namesPointer = SafeNativeMethods.GlobalLock(new HandleRef(null, handle));

            Marshal.WriteInt16(namesPointer, offset); // wDriverOffset
            offset += WriteOneDEVNAME(DriverName, namesPointer, offset);
            Marshal.WriteInt16((IntPtr)((long)namesPointer + 2), offset); // wDeviceOffset
            offset += WriteOneDEVNAME(printerName, namesPointer, offset);
            Marshal.WriteInt16((IntPtr)((long)namesPointer + 4), offset); // wOutputOffset
            offset += WriteOneDEVNAME(OutputPort, namesPointer, offset);
            Marshal.WriteInt16((IntPtr)((long)namesPointer + 6), offset); // wDefault

            SafeNativeMethods.GlobalUnlock(new HandleRef(null, handle));
            return handle;
        }

        // Handles creating then disposing a default DEVMODE
        internal short GetModeField(ModeField field, short defaultValue) {
            return GetModeField(field, defaultValue, IntPtr.Zero);
        }

        internal short GetModeField(ModeField field, short defaultValue, IntPtr modeHandle) {
            bool ownHandle = false;
            if (modeHandle == IntPtr.Zero) {
                try {
                    modeHandle = GetHdevmodeInternal();
                }
                catch (InvalidPrinterException) {
                    return defaultValue;
                }
            }

            IntPtr modePointer = SafeNativeMethods.GlobalLock(new HandleRef(this, modeHandle));
            SafeNativeMethods.DEVMODE mode = (SafeNativeMethods.DEVMODE) UnsafeNativeMethods.PtrToStructure(modePointer, typeof(SafeNativeMethods.DEVMODE));

            short result;
            switch (field) {
                case ModeField.Orientation: result = mode.dmOrientation; break;
                case ModeField.PaperSize: result = mode.dmPaperSize; break;
                case ModeField.PaperLength: result = mode.dmPaperLength; break;
                case ModeField.PaperWidth: result = mode.dmPaperWidth; break;
                case ModeField.Copies: result = mode.dmCopies; break;
                case ModeField.DefaultSource: result = mode.dmDefaultSource; break;
                case ModeField.PrintQuality: result = mode.dmPrintQuality; break;
                case ModeField.Color: result = mode.dmColor; break;
                case ModeField.Duplex: result = mode.dmDuplex; break;
                case ModeField.YResolution: result = mode.dmYResolution; break;
                case ModeField.TTOption: result = mode.dmTTOption; break;
                case ModeField.Collate: result = mode.dmCollate; break;
                default:
                    Debug.Fail("Invalid field in GetModeField");
                    result = defaultValue;
                    break;
            }

            SafeNativeMethods.GlobalUnlock(new HandleRef(this, modeHandle));

            if (ownHandle)
                SafeNativeMethods.GlobalFree(new HandleRef(this, modeHandle));

            return result;
        }

        internal PaperSize[] Get_PaperSizes() {
            IntSecurity.AllPrintingAndUnmanagedCode.Assert();

            string printerName = PrinterName; //  this is quite expensive if PrinterName is left default

            int count = FastDeviceCapabilities(SafeNativeMethods.DC_PAPERNAMES, IntPtr.Zero, -1, printerName);
            if (count == -1)
                return new PaperSize[0];
            int stringSize = Marshal.SystemDefaultCharSize * 64;
            IntPtr namesBuffer = Marshal.AllocCoTaskMem(stringSize * count);
            FastDeviceCapabilities(SafeNativeMethods.DC_PAPERNAMES, namesBuffer, -1, printerName);

            Debug.Assert(FastDeviceCapabilities(SafeNativeMethods.DC_PAPERS, IntPtr.Zero, -1, printerName) == count,
                         "Not the same number of paper kinds as paper names?");
            IntPtr kindsBuffer = Marshal.AllocCoTaskMem(2 * count);
            FastDeviceCapabilities(SafeNativeMethods.DC_PAPERS, kindsBuffer, -1, printerName);

            Debug.Assert(FastDeviceCapabilities(SafeNativeMethods.DC_PAPERSIZE, IntPtr.Zero, -1, printerName) == count,
                         "Not the same number of paper kinds as paper names?");
            IntPtr dimensionsBuffer = Marshal.AllocCoTaskMem(8 * count);
            FastDeviceCapabilities(SafeNativeMethods.DC_PAPERSIZE, dimensionsBuffer, -1, printerName);

            PaperSize[] result = new PaperSize[count];
            for (int i = 0; i < count; i++) {
                string name = Marshal.PtrToStringAuto((IntPtr)((long)namesBuffer + stringSize * i), 64);
                int index = name.IndexOf('\0');
                if (index > -1) {
                    name = name.Substring(0, index);
                }
                short kind = Marshal.ReadInt16((IntPtr)((long)kindsBuffer + i*2));
                int width = Marshal.ReadInt32((IntPtr)((long)dimensionsBuffer + i * 8));
                int height = Marshal.ReadInt32((IntPtr)((long)dimensionsBuffer + i * 8 + 4));
                result[i] = new PaperSize((PaperKind) kind, name, 
                                          PrinterUnitConvert.Convert(width, PrinterUnit.TenthsOfAMillimeter, PrinterUnit.Display),
                                          PrinterUnitConvert.Convert(height, PrinterUnit.TenthsOfAMillimeter, PrinterUnit.Display));
            }

            Marshal.FreeCoTaskMem(namesBuffer);
            Marshal.FreeCoTaskMem(kindsBuffer);
            Marshal.FreeCoTaskMem(dimensionsBuffer);
            return result;
        }

        internal PaperSource[] Get_PaperSources() {
            IntSecurity.AllPrintingAndUnmanagedCode.Assert();

            string printerName = PrinterName; //  this is quite expensive if PrinterName is left default

            int count = FastDeviceCapabilities(SafeNativeMethods.DC_BINNAMES, IntPtr.Zero, -1, printerName);
            if (count == -1)
                return new PaperSource[0];

            // Contrary to documentation, DeviceCapabilities returns char[count, 24],
            // not char[count][24]
            int stringSize = Marshal.SystemDefaultCharSize * 24;
            IntPtr namesBuffer = Marshal.AllocCoTaskMem(stringSize * count);
            FastDeviceCapabilities(SafeNativeMethods.DC_BINNAMES, namesBuffer, -1, printerName);

            Debug.Assert(FastDeviceCapabilities(SafeNativeMethods.DC_BINS, IntPtr.Zero, -1, printerName) == count,
                         "Not the same number of bin kinds as bin names?");
            IntPtr kindsBuffer = Marshal.AllocCoTaskMem(2 * count);
            FastDeviceCapabilities(SafeNativeMethods.DC_BINS, kindsBuffer, -1, printerName);

            PaperSource[] result = new PaperSource[count];
            for (int i = 0; i < count; i++) {
                string name = Marshal.PtrToStringAuto((IntPtr)((long)namesBuffer + stringSize * i));
                short kind = Marshal.ReadInt16((IntPtr)((long)kindsBuffer + 2*i));
                result[i] = new PaperSource((PaperSourceKind) kind, name);
            }

            Marshal.FreeCoTaskMem(namesBuffer);
            Marshal.FreeCoTaskMem(kindsBuffer);
            return result;
        }

        internal PrinterResolution[] Get_PrinterResolutions() {
            IntSecurity.AllPrintingAndUnmanagedCode.Assert();

            string printerName = PrinterName; //  this is quite expensive if PrinterName is left default
            PrinterResolution[] result;

            int count = FastDeviceCapabilities(SafeNativeMethods.DC_ENUMRESOLUTIONS, IntPtr.Zero, -1, printerName);
            if (count == -1) {
                //Just return the standrard values if custom resolutions absemt ....
                result = new PrinterResolution[4];
                result[0] = new PrinterResolution(PrinterResolutionKind.High, -4, -1);
                result[1] = new PrinterResolution(PrinterResolutionKind.Medium, -3, -1);
                result[2] = new PrinterResolution(PrinterResolutionKind.Low, -2, -1);
                result[3] = new PrinterResolution(PrinterResolutionKind.Draft, -1, -1);
                
                return result;
            }
            
            result = new PrinterResolution[count + 4];
            result[0] = new PrinterResolution(PrinterResolutionKind.High, -4, -1);
            result[1] = new PrinterResolution(PrinterResolutionKind.Medium, -3, -1);
            result[2] = new PrinterResolution(PrinterResolutionKind.Low, -2, -1);
            result[3] = new PrinterResolution(PrinterResolutionKind.Draft, -1, -1);

            IntPtr buffer = Marshal.AllocCoTaskMem(8 * count);
            FastDeviceCapabilities(SafeNativeMethods.DC_ENUMRESOLUTIONS, buffer, -1, printerName);
            
            for (int i = 0; i < count; i++) {
                int x = Marshal.ReadInt32((IntPtr)((long)buffer + i*8));
                int y = Marshal.ReadInt32((IntPtr)((long)buffer + i*8 + 4));
                result[i + 4] = new PrinterResolution(PrinterResolutionKind.Custom, x, y);
            }

            Marshal.FreeCoTaskMem(buffer);
            return result;
        }

        // names is pointer to DEVNAMES
        private static String ReadOneDEVNAME(IntPtr pDevnames, int slot) {
            int offset = Marshal.SystemDefaultCharSize * Marshal.ReadInt16((IntPtr)((long)pDevnames + slot * 2));
            string result = Marshal.PtrToStringAuto((IntPtr)((long)pDevnames + offset));
            return result;
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.SetHdevmode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Copies the relevant information out of the handle and into the PrinterSettings.
        ///    </para>
        /// </devdoc>
        public void SetHdevmode(IntPtr hdevmode) {
            IntSecurity.AllPrinting.Demand();
            // Don't assert unmanaged code -- anyone using handles should have unmanaged code permission

            if (hdevmode == IntPtr.Zero)
                throw new ArgumentException(SR.GetString(SR.InvalidPrinterHandle, hdevmode));

            IntPtr pointer = SafeNativeMethods.GlobalLock(new HandleRef(null, hdevmode));
            SafeNativeMethods.DEVMODE mode = (SafeNativeMethods.DEVMODE) UnsafeNativeMethods.PtrToStructure(pointer, typeof(SafeNativeMethods.DEVMODE));

            //Copy entire public devmode as a byte array...
            devmodebytes = mode.dmSize;
            if (devmodebytes > 0)  {
                cachedDevmode = new byte[devmodebytes];
                Marshal.Copy(pointer, cachedDevmode, 0, devmodebytes);
            }

            //Copy private devmode as a byte array..
            extrabytes = mode.dmDriverExtra;
            if (extrabytes > 0)  {
                extrainfo = new byte[extrabytes];
                Marshal.Copy((IntPtr)((long)pointer + (long)mode.dmSize), extrainfo, 0, extrabytes);
            }
            copies = mode.dmCopies;
            collate = (mode.dmCollate == SafeNativeMethods.DMCOLLATE_TRUE);
            duplex = (Duplex) mode.dmDuplex;
            
            SafeNativeMethods.GlobalUnlock(new HandleRef(null, hdevmode));
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.SetHdevnames"]/*' />
        /// <devdoc>
        ///    <para>Copies the relevant information out of the handle and into the PrinterSettings.</para>
        /// </devdoc>
        public void SetHdevnames(IntPtr hdevnames) {
            IntSecurity.AllPrinting.Demand();

            if (hdevnames == IntPtr.Zero)
                throw new ArgumentException(SR.GetString(SR.InvalidPrinterHandle, hdevnames));

            IntPtr namesPointer = SafeNativeMethods.GlobalLock(new HandleRef(null, hdevnames));

            driverName = ReadOneDEVNAME(namesPointer, 0);
            printerName = ReadOneDEVNAME(namesPointer, 1);
            outputPort = ReadOneDEVNAME(namesPointer, 2);

            PrintDialogDisplayed = true;
            
            SafeNativeMethods.GlobalUnlock(new HandleRef(null, hdevnames));
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Provides some interesting information about the PrinterSettings in
        ///       String form.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            string printerName = (IntSecurity.HasPermission(IntSecurity.AllPrinting)) ? PrinterName : "<printer name unavailable>";
            return "[PrinterSettings " 
            + printerName
            + " Copies=" + Copies.ToString()
            + " Collate=" + Collate.ToString()
            //            + " DriverName=" + DriverName.ToString()
            //            + " DriverVersion=" + DriverVersion.ToString()
            + " Duplex=" + TypeDescriptor.GetConverter(typeof(Duplex)).ConvertToString((int) Duplex)
            + " FromPage=" + FromPage.ToString()
            + " LandscapeAngle=" + LandscapeAngle.ToString()
            + " MaximumCopies=" + MaximumCopies.ToString()
            + " OutputPort=" + OutputPort.ToString()
            + " ToPage=" + ToPage.ToString()
            + "]";
        }

        // Write null terminated string, return length of string in characters (including null)
        private short WriteOneDEVNAME(string str, IntPtr bufferStart, int index) {
            if (str == null) str = "";
            IntPtr address = (IntPtr)((long)bufferStart + index * Marshal.SystemDefaultCharSize);
            
            if (Marshal.SystemDefaultCharSize == 1) {
                byte[] bytes = System.Text.Encoding.Default.GetBytes(str);
                Marshal.Copy(bytes, 0, address, bytes.Length);
                Marshal.WriteByte((IntPtr)((long)address + bytes.Length), 0);
            }
            else {
                char[] data = str.ToCharArray();
                Marshal.Copy(data, 0, address, data.Length);
                Marshal.WriteInt16((IntPtr)((long)address + data.Length*2), 0);
            }
            
            return(short) (str.Length + 1);
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSizeCollection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Collection of PaperSize's...
        ///    </para>
        /// </devdoc>
        public class PaperSizeCollection : ICollection {
            private PaperSize[] array;

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSizeCollection.PaperSizeCollection"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Initializes a new instance of the <see cref='System.Drawing.Printing.PrinterSettings.PaperSizeCollection'/> class.
            ///    </para>
            /// </devdoc>
            public PaperSizeCollection(PaperSize[] array) {
                this.array = array;
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSizeCollection.Count"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Gets a value indicating the number of paper sizes.
            ///    </para>
            /// </devdoc>
            public int Count {
                get {
                    return array.Length;
                }
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSizeCollection.this"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Retrieves the PaperSize with the specified index.
            ///    </para>
            /// </devdoc>
            public virtual PaperSize this[int index] {
                get {
                    return array[index];
                }
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSizeCollection.GetEnumerator"]/*' />
            /// <devdoc>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                return new ArrayEnumerator(array, 0, Count);
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSizeCollection.ICollection.Count"]/*' />
            /// <devdoc>        
            ///    ICollection private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            int ICollection.Count {
                get {
                    return this.Count;
                }
            }


            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSizeCollection.ICollection.IsSynchronized"]/*' />
            /// <devdoc>        
            ///    ICollection private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSizeCollection.ICollection.SyncRoot"]/*' />
            /// <devdoc>        
            ///    ICollection private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PaperSizeCollection.ICollection.CopyTo"]/*' />
            /// <devdoc>        
            /// ICollection private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            void ICollection.CopyTo(Array array, int index) {
                Array.Copy(this.array, 0, array, 0, this.array.Length);
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSizeCollection.IEnumerable.GetEnumerator"]/*' />
            /// <devdoc>        
            ///    IEnumerable private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            IEnumerator IEnumerable.GetEnumerator() {
                return GetEnumerator();
            }         

        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSourceCollection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Collection of PaperSource's...
        ///    </para>
        /// </devdoc>
        public class PaperSourceCollection : ICollection {
            private PaperSource[] array;

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSourceCollection.PaperSourceCollection"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Initializes a new instance of the <see cref='System.Drawing.Printing.PrinterSettings.PaperSourceCollection'/> class.
            ///    </para>
            /// </devdoc>
            public PaperSourceCollection(PaperSource[] array) {
                this.array = array;
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSourceCollection.Count"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Gets a value indicating the number of paper sources.
            ///    </para>
            /// </devdoc>
            public int Count {
                get {
                    return array.Length;
                }
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSourceCollection.this"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Gets the PaperSource with the specified index.
            ///    </para>
            /// </devdoc>
            public virtual PaperSource this[int index] {
                get {
                    return array[index];
                }
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSourceCollection.GetEnumerator"]/*' />
            /// <devdoc>
            /// </devdoc>
            /// <devdoc>
            /// </devdoc>
            /// <devdoc>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                return new ArrayEnumerator(array, 0, Count);
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSourceCollection.ICollection.Count"]/*' />
            /// <devdoc>        
            ///    ICollection private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            int ICollection.Count {
                get {
                    return this.Count;
                }
            }


            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSourceCollection.ICollection.IsSynchronized"]/*' />
            /// <devdoc>        
            ///    ICollection private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSourceCollection.ICollection.SyncRoot"]/*' />
            /// <devdoc>        
            ///    ICollection private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PaperSourceCollection.ICollection.CopyTo"]/*' />
            /// <devdoc>        
            /// ICollection private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            void ICollection.CopyTo(Array array, int index) {
                Array.Copy(this.array, 0, array, 0, this.array.Length);
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PaperSourceCollection.IEnumerable.GetEnumerator"]/*' />
            /// <devdoc>        
            ///    IEnumerable private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            IEnumerator IEnumerable.GetEnumerator() {
                return GetEnumerator();
            }
        }

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PrinterResolutionCollection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Collection of PrinterResolution's...
        ///    </para>
        /// </devdoc>
        public class PrinterResolutionCollection : ICollection {
            private PrinterResolution[] array;

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PrinterResolutionCollection.PrinterResolutionCollection"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Initializes a new instance of the <see cref='System.Drawing.Printing.PrinterSettings.PrinterResolutionCollection'/> class.
            ///    </para>
            /// </devdoc>
            public PrinterResolutionCollection(PrinterResolution[] array) {
                this.array = array;
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PrinterResolutionCollection.Count"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Gets a
            ///       value indicating the number of available printer resolutions.
            ///    </para>
            /// </devdoc>
            public int Count {
                get {
                    return array.Length;
                }
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PrinterResolutionCollection.this"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Retrieves the PrinterResolution with the specified index.
            ///    </para>
            /// </devdoc>
            public virtual PrinterResolution this[int index] {
                get {
                    return array[index];
                }
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PrinterResolutionCollection.GetEnumerator"]/*' />
            /// <devdoc>
            /// </devdoc>
            /// <devdoc>
            /// </devdoc>
            /// <devdoc>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                return new ArrayEnumerator(array, 0, Count);
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PrinterResolutionCollection.ICollection.Count"]/*' />
            /// <devdoc>        
            ///    ICollection private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            int ICollection.Count {
                get {
                    return this.Count;
                }
            }


            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PrinterResolutionCollection.ICollection.IsSynchronized"]/*' />
            /// <devdoc>        
            ///    ICollection private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PrinterResolutionCollection.ICollection.SyncRoot"]/*' />
            /// <devdoc>        
            ///    ICollection private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterResolutionCollection.ICollection.CopyTo"]/*' />
            /// <devdoc>        
            /// ICollection private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            void ICollection.CopyTo(Array array, int index) {
                Array.Copy(this.array, 0, array, 0, this.array.Length);
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.PrinterResolutionCollection.IEnumerable.GetEnumerator"]/*' />
            /// <devdoc>        
            ///    IEnumerable private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            IEnumerator IEnumerable.GetEnumerator() {
                return GetEnumerator();
            }
        }        

        /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.StringCollection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Collection of String's...
        ///    </para>
        /// </devdoc>
        /// <internalonly/>
        public class StringCollection : ICollection {
            private String[] array;

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.StringCollection.StringCollection"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Initializes a new instance of the <see cref='System.Drawing.Printing.PrinterSettings.StringCollection'/> class.
            ///    </para>
            /// </devdoc>
            public StringCollection(String[] array) {
                this.array = array;
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.StringCollection.Count"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Gets a value indicating the number of strings.
            ///    </para>
            /// </devdoc>
            public int Count {
                get {
                    return array.Length;
                }
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.StringCollection.this"]/*' />
            /// <devdoc>
            ///    <para>
            ///       Gets the string with the specified index.
            ///    </para>
            /// </devdoc>
            public virtual String this[int index] {
                get {
                    return array[index];
                }
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.StringCollection.GetEnumerator"]/*' />
            /// <devdoc>
            /// </devdoc>
            /// <devdoc>
            /// </devdoc>
            /// <devdoc>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                return new ArrayEnumerator(array, 0, Count);
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.StringCollection.ICollection.Count"]/*' />
            /// <devdoc>        
            ///    ICollection private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            int ICollection.Count {
                get {
                    return this.Count;
                }
            }


            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.StringCollection.ICollection.IsSynchronized"]/*' />
            /// <devdoc>        
            ///    ICollection private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="PrinterSettings.StringCollection.ICollection.SyncRoot"]/*' />
            /// <devdoc>        
            ///    ICollection private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="StringCollection.ICollection.CopyTo"]/*' />
            /// <devdoc>        
            /// ICollection private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            void ICollection.CopyTo(Array array, int index) {
                Array.Copy(this.array, 0, array, 0, this.array.Length);
            }

            /// <include file='doc\PrinterSettings.uex' path='docs/doc[@for="StringCollection.IEnumerable.GetEnumerator"]/*' />
            /// <devdoc>        
            /// IEnumerable private interface implementation.        
            /// </devdoc>
            /// <internalonly/>
            IEnumerator IEnumerable.GetEnumerator() {
                return GetEnumerator();
            }
        }

        private class ArrayEnumerator : IEnumerator {
            private object[] array;
            private object item;
            private int index;
            private int startIndex;
            private int endIndex;

            public ArrayEnumerator(object[] array, int startIndex, int count) {
                this.array = array;
                this.startIndex = startIndex;
                endIndex = index + count;

                index = this.startIndex;
            }

            public object Current {
                get {
                    return item;
                }                    
            }


            public bool MoveNext() {
                if (index >= endIndex) return false;
                item = array[index++];
                return true;
            }

            public void Reset() {

                // Position enumerator before first item 

                index = startIndex;
                item = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\printpageeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrintPageEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {

    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\PrintPageEventHandler.uex' path='docs/doc[@for="PrintPageEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='E:System.Drawing.Printing.PrintDocument.PrintPage'/> event of a <see cref='System.Drawing.Printing.PrintDocument'/>.
    ///    </para>
    /// </devdoc>
    public delegate void PrintPageEventHandler(object sender, PrintPageEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\printrange.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrintRange.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {

    using System.Diagnostics;
    using System;
    using System.Runtime.InteropServices;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\PrintRange.uex' path='docs/doc[@for="PrintRange"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies the option buttons in the print dialog box that
    ///       designate the part of the document to print.
    ///    </para>
    /// </devdoc>
    public enum PrintRange {
        /// <include file='doc\PrintRange.uex' path='docs/doc[@for="PrintRange.AllPages"]/*' />
        /// <devdoc>
        ///    <para>
        ///       All pages are printed.
        ///       
        ///    </para>
        /// </devdoc>
        AllPages = SafeNativeMethods.PD_ALLPAGES,

        /// <include file='doc\PrintRange.uex' path='docs/doc[@for="PrintRange.SomePages"]/*' />
        /// <devdoc>
        /// <para> The pages between <see cref='System.Drawing.Printing.PrinterSettings.FromPage'/> and
        /// <see cref='System.Drawing.Printing.PrinterSettings.ToPage'/>
        /// are
        /// printed.</para>
        /// </devdoc>
        SomePages = SafeNativeMethods.PD_PAGENUMS,

        /// <include file='doc\PrintRange.uex' path='docs/doc[@for="PrintRange.Selection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The selected pages are printed.
        ///       
        ///    </para>
        /// </devdoc>
        Selection = SafeNativeMethods.PD_SELECTION,
        
        /*
        /// <internalonly/>
        /// <summary>
        ///    <para>
        ///       The
        ///       current page is printed. The print dialog box requires Windows 2000 or
        ///       later for this setting; if used with an earlier operating system, all pages will be printed.
        ///       
        ///    </para>
        /// </summary>
        CurrentPage = SafeNativeMethods.PD_CURRENTPAGE,
        */
        
        // When adding new members, be sure to update PrintDialog.printRangeMask.
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\printingpermission.cs ===
/*
 * Copyright (c) 2000 Microsoft Corporation.  All Rights Reserved.
 * Microsoft Confidential.
 */

namespace System.Drawing.Printing {
    using System;
    using System.Security;
    using System.Security.Util;
    using System.Security.Permissions;
    using System.IO;
    using System.Runtime.Serialization;
    using System.Reflection;
    using System.Collections;
    using System.Globalization;
    
    /// <include file='doc\PrintingPermission.uex' path='docs/doc[@for="PrintingPermission"]/*' />
    /// <devdoc>
    ///    <para> Controls the ability to use the printer. This class cannot be inherited.</para>
    /// </devdoc>
    [Serializable] 
    public sealed class PrintingPermission : CodeAccessPermission, IUnrestrictedPermission {
        private PrintingPermissionLevel printingLevel;

        /// <include file='doc\PrintingPermission.uex' path='docs/doc[@for="PrintingPermission.PrintingPermission"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the PrintingPermission class with either fully restricted
        ///    or unrestricted access, as specified.</para>
        /// </devdoc>
        public PrintingPermission(PermissionState state) {
            if (state == PermissionState.Unrestricted) {
                printingLevel = PrintingPermissionLevel.AllPrinting;
            }
            else if (state == PermissionState.None) {
                printingLevel = PrintingPermissionLevel.NoPrinting;
            }
            else {
                throw new ArgumentException(SR.GetString(SR.InvalidPermissionState));
            }
        }    

        /// <include file='doc\PrintingPermission.uex' path='docs/doc[@for="PrintingPermission.PrintingPermission1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PrintingPermission(PrintingPermissionLevel printingLevel) {
            VerifyPrintingLevel(printingLevel);

            this.printingLevel = printingLevel;
        }

        /// <include file='doc\PrintingPermission.uex' path='docs/doc[@for="PrintingPermission.Level"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PrintingPermissionLevel Level {
            get {
                return printingLevel;
            }
            
            set {
                VerifyPrintingLevel(value);
                printingLevel = value;
            }
        }

        private static void VerifyPrintingLevel(PrintingPermissionLevel level) {
            if (level < PrintingPermissionLevel.NoPrinting || level > PrintingPermissionLevel.AllPrinting) {
                throw new ArgumentException(SR.GetString(SR.InvalidPermissionLevel));
            }
        }


        //------------------------------------------------------
        //
        // CODEACCESSPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------

        /// <include file='doc\PrintingPermission.uex' path='docs/doc[@for="PrintingPermission.IsUnrestricted"]/*' />
        /// <devdoc>
        ///    <para> Gets a
        ///       value indicating whether permission is unrestricted.</para>
        /// </devdoc>
        public bool IsUnrestricted() {
            return printingLevel == PrintingPermissionLevel.AllPrinting;
        }

        //------------------------------------------------------
        //
        // IPERMISSION IMPLEMENTATION
        //
        //------------------------------------------------------

        /// <include file='doc\PrintingPermission.uex' path='docs/doc[@for="PrintingPermission.IsSubsetOf"]/*' />
        /// <devdoc>
        ///    <para>Determines whether the current permission object is a subset of
        ///       the specified permission.</para>
        /// </devdoc>
        public override bool IsSubsetOf(IPermission target) {
            if (target == null) {
                return printingLevel == PrintingPermissionLevel.NoPrinting;
            }

            try {
                PrintingPermission operand = (PrintingPermission)target;
                return this.printingLevel <= operand.printingLevel;
            }
            catch (InvalidCastException) {
                throw new ArgumentException(SR.GetString(SR.TargetNotPrintingPermission));
            }

        }

        /// <include file='doc\PrintingPermission.uex' path='docs/doc[@for="PrintingPermission.Intersect"]/*' />
        /// <devdoc>
        ///    <para>Creates and returns a permission that is the intersection of the current 
        ///       permission object and a target permission object.</para>
        /// </devdoc>
        public override IPermission Intersect(IPermission target) {
            if (target == null) {
                return null;
            }

            try {
                PrintingPermission operand = (PrintingPermission)target;
                PrintingPermissionLevel isectLevels = printingLevel < operand.printingLevel ? printingLevel : operand.printingLevel;
                if (isectLevels == PrintingPermissionLevel.NoPrinting)
                    return null;
                else
                    return new PrintingPermission(isectLevels);
            }
            catch (InvalidCastException) {
                throw new ArgumentException(SR.GetString(SR.TargetNotPrintingPermission));
            }

        }

        /// <include file='doc\PrintingPermission.uex' path='docs/doc[@for="PrintingPermission.Union"]/*' />
        /// <devdoc>
        ///    <para>Creates a permission that is the union of the permission object
        ///       and the target parameter permission object.</para>
        /// </devdoc>
        public override IPermission Union(IPermission target) {
            if (target == null) {
                return this.Copy();
            }

            try {
                PrintingPermission operand = (PrintingPermission)target;
                PrintingPermissionLevel isectLevels = printingLevel > operand.printingLevel ? printingLevel : operand.printingLevel;
                if (isectLevels == PrintingPermissionLevel.NoPrinting)
                    return null;
                else
                    return new PrintingPermission(isectLevels);
            }
            catch (InvalidCastException) {
                throw new ArgumentException(SR.GetString(SR.TargetNotPrintingPermission));
            }

        }        

        /// <include file='doc\PrintingPermission.uex' path='docs/doc[@for="PrintingPermission.Copy"]/*' />
        /// <devdoc>
        ///    <para>Creates and returns an identical copy of the current permission
        ///       object.</para>
        /// </devdoc>
        public override IPermission Copy() {
            return new PrintingPermission(this.printingLevel);
        }


        /// <include file='doc\PrintingPermission.uex' path='docs/doc[@for="PrintingPermission.ToXml"]/*' />
        /// <devdoc>
        ///    <para>Creates an XML encoding of the security object and its current
        ///       state.</para>
        /// </devdoc>
        public override SecurityElement ToXml() {
            SecurityElement securityElement = new SecurityElement("IPermission");

            securityElement.AddAttribute("class", this.GetType().FullName + ", " + this.GetType().Module.Assembly.FullName.Replace('\"', '\''));
            securityElement.AddAttribute("version", "1");
            if (!IsUnrestricted()) {
                securityElement.AddAttribute("Level", Enum.GetName(typeof(PrintingPermissionLevel), printingLevel));
            }
            else {
                securityElement.AddAttribute("Unrestricted", "true");
            }
            return securityElement;
        }

        /// <include file='doc\PrintingPermission.uex' path='docs/doc[@for="PrintingPermission.FromXml"]/*' />
        /// <devdoc>
        ///    <para>Reconstructs a security object with a specified state from an XML
        ///       encoding.</para>
        /// </devdoc>
        public override void FromXml(SecurityElement esd) {
            if (esd == null) {
                throw new ArgumentNullException("esd");
            }

            String className = esd.Attribute("class");

            if (className == null || className.IndexOf(this.GetType().FullName) == -1) {
                throw new ArgumentException(SR.GetString(SR.InvalidClassName));
            }

            String unrestricted = esd.Attribute("Unrestricted");

            if (unrestricted != null && String.Compare(unrestricted, "true", true, CultureInfo.InvariantCulture) == 0) {
                printingLevel = PrintingPermissionLevel.AllPrinting;
                return;
            }

            printingLevel = PrintingPermissionLevel.NoPrinting;

            String printing = esd.Attribute("Level");
            if (printing != null)
                printingLevel = (PrintingPermissionLevel)Enum.Parse(typeof(PrintingPermissionLevel), printing);
            else
                throw new ArgumentException("esd");     // bad XML
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\printpageevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="PrintPageEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {

    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\PrintPageEvent.uex' path='docs/doc[@for="PrintPageEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see cref='E:System.Drawing.Printing.PrintDocument.PrintPage'/>
    /// event.</para>
    /// </devdoc>
    // NOTE: Please keep this class consistent with PaintEventArgs.
    public class PrintPageEventArgs : EventArgs {
        private bool hasMorePages = false;
        private bool cancel = false;

        private Graphics graphics;
        private readonly Rectangle marginBounds;
        private readonly Rectangle pageBounds;
        private readonly PageSettings pageSettings;


        /// <include file='doc\PrintPageEvent.uex' path='docs/doc[@for="PrintPageEventArgs.PrintPageEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.Drawing.Printing.PrintPageEventArgs'/> class.</para>
        /// </devdoc>
        public PrintPageEventArgs(Graphics graphics, Rectangle marginBounds, Rectangle pageBounds, PageSettings pageSettings) {
            this.graphics = graphics; // may be null, see PrintController
            this.marginBounds = marginBounds;
            this.pageBounds = pageBounds;
            this.pageSettings = pageSettings;
        }

        /// <include file='doc\PrintPageEvent.uex' path='docs/doc[@for="PrintPageEventArgs.Cancel"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether the print job should be canceled.</para>
        /// </devdoc>
        public bool Cancel {
            get { return cancel;}
            set { cancel = value;}
        }

        /// <include file='doc\PrintPageEvent.uex' path='docs/doc[@for="PrintPageEventArgs.Graphics"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the <see cref='System.Drawing.Graphics'/>
        ///       used to paint the
        ///       item.
        ///    </para>
        /// </devdoc>
        public Graphics Graphics {
            get {
                return graphics;
            }
        }

        /// <include file='doc\PrintPageEvent.uex' path='docs/doc[@for="PrintPageEventArgs.HasMorePages"]/*' />
        /// <devdoc>
        ///    <para> Gets or sets a value indicating whether an additional page should
        ///       be printed.</para>
        /// </devdoc>
        public bool HasMorePages {
            get { return hasMorePages;}
            set { hasMorePages = value;}
        }

        /// <include file='doc\PrintPageEvent.uex' path='docs/doc[@for="PrintPageEventArgs.MarginBounds"]/*' />
        /// <devdoc>
        ///    <para>Gets the rectangular area that represents the portion of the page between the margins.</para>
        /// </devdoc>
        public Rectangle MarginBounds {
            get {
                return marginBounds;
            }
        }

        /// <include file='doc\PrintPageEvent.uex' path='docs/doc[@for="PrintPageEventArgs.PageBounds"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the rectangular area that represents the total area of the page.
        ///    </para>
        /// </devdoc>
        public Rectangle PageBounds {
            get {
                return pageBounds;
            }
        }

        /// <include file='doc\PrintPageEvent.uex' path='docs/doc[@for="PrintPageEventArgs.PageSettings"]/*' />
        /// <devdoc>
        ///    <para>Gets
        ///       the page settings for the current page.</para>
        /// </devdoc>
        public PageSettings PageSettings {
            get {
                return pageSettings;
            }
        }

        /// <include file='doc\PrintPageEvent.uex' path='docs/doc[@for="PrintPageEventArgs.Dispose"]/*' />
        /// <devdoc>
        ///    <para>Disposes
        ///       of the resources (other than memory) used by
        ///       the <see cref='System.Drawing.Printing.PrintPageEventArgs'/>.</para>
        /// </devdoc>
        // We want a way to dispose the GDI+ Graphics, but we don't want to create one
        // simply to dispose it
        internal void Dispose() {
            graphics.Dispose();
        }

        internal void SetGraphics(Graphics value) {
            this.graphics = value;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\querypagesettingseventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="QueryPageSettingsEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {

    using System.Diagnostics;
    using System;
    using System.Drawing;
    using Microsoft.Win32;
    using System.ComponentModel;

    /// <include file='doc\QueryPageSettingsEventArgs.uex' path='docs/doc[@for="QueryPageSettingsEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='E:System.Drawing.Printing.PrintDocument.QueryPageSettings'/> event.
    ///    </para>
    /// </devdoc>
    public class QueryPageSettingsEventArgs : PrintEventArgs {
        private PageSettings pageSettings;

        /// <include file='doc\QueryPageSettingsEventArgs.uex' path='docs/doc[@for="QueryPageSettingsEventArgs.QueryPageSettingsEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.Drawing.Printing.QueryPageSettingsEventArgs'/> class.
        ///    </para>
        /// </devdoc>
        public QueryPageSettingsEventArgs(PageSettings pageSettings) : base() {
            this.pageSettings = pageSettings;
        }

        /// <include file='doc\QueryPageSettingsEventArgs.uex' path='docs/doc[@for="QueryPageSettingsEventArgs.PageSettings"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the page settings for the page to be printed.
        ///    </para>
        /// </devdoc>
        public PageSettings PageSettings {
            get { return pageSettings;}
            set {
                if (value == null)
                    value = new PageSettings();
                pageSettings = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\tristate.cs ===
//------------------------------------------------------------------------------
// <copyright file="TriState.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {

    using System.ComponentModel;
    using System.Diagnostics;
    using System;

    internal struct TriState {
        private byte value; // 0 is "default", not false

        public static readonly TriState Default = new TriState(0);
        public static readonly TriState False = new TriState(1);
        public static readonly TriState True = new TriState(2);

        private TriState(byte value) {
            this.value = value;
        }

        public bool IsDefault {
            get { return this == Default;}
        }

        public bool IsFalse {
            get { return this == False;}
        }

        public bool IsNotDefault {
            get { return this != Default;}
        }

        public bool IsTrue {
            get { return this == True;}
        }

        public static bool operator ==(TriState left, TriState right) {
            return left.value == right.value;
        }
        
        public static bool operator !=(TriState left, TriState right) {
            return !(left == right);
        }

        public override bool Equals( object o ) {
            TriState state = (TriState)o;
            return this.value == state.value;
        }
        
        public override int GetHashCode() {
            return value;
        }

        public static implicit operator TriState(bool value) {
            return(value) ? True : False;
        }

        public static explicit operator bool(TriState value) {
            if (value.IsDefault)
                throw new InvalidCastException(SR.GetString(SR.TriStateCompareError));
            else
                return(value == TriState.True);
        }

        /// <include file='doc\TriState.uex' path='docs/doc[@for="TriState.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Provides some interesting information about the TriState in
        ///       String form.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            if (this == Default) return "Default";
            else if (this == False) return "False";
            else return "True";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\commonui\system\drawing\printing\querypagesettingseventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="QueryPageSettingsEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Drawing.Printing {

    using System.Diagnostics;
    using System;
    using System.Drawing;
    using System.ComponentModel;
    using Microsoft.Win32;

    /// <include file='doc\QueryPageSettingsEventHandler.uex' path='docs/doc[@for="QueryPageSettingsEventHandler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the method that will handle the <see cref='E:System.Drawing.Printing.PrintDocument.QueryPageSettings'/> event of a <see cref='System.Drawing.Printing.PrintDocument'/>.
    ///    </para>
    /// </devdoc>
    public delegate void QueryPageSettingsEventHandler(object sender, QueryPageSettingsEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\win32\powermodechangedeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="PowerModeChangedEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.Win32 {
    using System.Diagnostics;
    
    using System;
    
    /// <include file='doc\PowerModeChangedEventArgs.uex' path='docs/doc[@for="PowerModeChangedEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see cref='Microsoft.Win32.SystemEvents.PowerModeChanged'/> event.</para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class PowerModeChangedEventArgs : EventArgs {
        private readonly PowerModes mode;
    
        /// <include file='doc\PowerModeChangedEventArgs.uex' path='docs/doc[@for="PowerModeChangedEventArgs.PowerModeChangedEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='Microsoft.Win32.PowerModeChangedEventArgs'/> class.</para>
        /// </devdoc>
        public PowerModeChangedEventArgs(PowerModes mode) {
            this.mode = mode;
        }
        
        /// <include file='doc\PowerModeChangedEventArgs.uex' path='docs/doc[@for="PowerModeChangedEventArgs.Mode"]/*' />
        /// <devdoc>
        ///    <para>Gets the power mode.</para>
        /// </devdoc>
        public PowerModes Mode {
            get {
                return mode;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\win32\nativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="NativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.Win32 {
    using System;
    using System.Text;
    using System.Threading;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System.ComponentModel;

    // not public!
    internal sealed class NativeMethods {

        public static IntPtr InvalidIntPtr = ((IntPtr)((int)(-1)));

        public static HandleRef NullHandleRef = new HandleRef(null, IntPtr.Zero);
        
        private NativeMethods() {
            // C# doesn't like to never assign to a field, so we 
            // will create this, and assign to make it be quiet.
            //
            MSG m = new MSG();
            m.hwnd = IntPtr.Zero;
            m.message = 0;
            m.wParam = IntPtr.Zero;
            m.lParam = IntPtr.Zero;
            m.time = 0;
            m.pt_x = 0;
            m.pt_y = 0;
        }

        public const int UIS_SET = 1,
        WSF_VISIBLE = 0x0001,
        UIS_CLEAR = 2,
        UISF_HIDEFOCUS = 0x1,
        UISF_HIDEACCEL = 0x2,
        USERCLASSTYPE_FULL = 1,
        UOI_FLAGS = 1;
        
        public const int DEFAULT_GUI_FONT = 17;
        public const int SM_CYSCREEN = 1;
        public const int COLOR_WINDOW = 5;
        public const int WS_POPUP = unchecked((int)0x80000000);
        public const int WS_VISIBLE = 0x10000000;
        public const int WM_SETTINGCHANGE = 0x001A;
        public const int WM_SYSCOLORCHANGE = 0x0015;
        public const int WM_QUERYENDSESSION = 0x0011;
        public const int WM_QUIT = 0x0012;
        public const int WM_ENDSESSION = 0x0016;
        public const int WM_POWERBROADCAST = 0x0218;
        public const int WM_COMPACTING = 0x0041;
        public const int WM_DISPLAYCHANGE = 0x007E;
        public const int WM_FONTCHANGE = 0x001D;
        public const int WM_PALETTECHANGED = 0x0311;
        public const int WM_TIMECHANGE = 0x001E;
        public const int WM_THEMECHANGED = 0x031A;

        public const int ENDSESSION_LOGOFF = unchecked((int)0x80000000);
        public const int WM_TIMER = 0x0113;
        public const int WM_USER = 0x0400;
        public const int WM_CREATETIMER = WM_USER + 1;
        public const int WM_KILLTIMER = WM_USER + 2;
        public const int WM_REFLECT = WM_USER + 0x1C00;
        
        public const int CTRL_C_EVENT        = 0;
        public const int CTRL_BREAK_EVENT    = 1;
        public const int CTRL_CLOSE_EVENT    = 2;
        public const int CTRL_LOGOFF_EVENT   = 5;
        public const int CTRL_SHUTDOWN_EVENT = 6;
        
        public const int SPI_GETBEEP                          =   1;
        public const int SPI_SETBEEP                          =   2;
        public const int SPI_GETMOUSE                         =   3;
        public const int SPI_SETMOUSE                         =   4;
        public const int SPI_GETBORDER                        =   5;
        public const int SPI_SETBORDER                        =   6;
        public const int SPI_GETKEYBOARDSPEED                 =  10;
        public const int SPI_SETKEYBOARDSPEED                 =  11;
        public const int SPI_LANGDRIVER                       =  12;
        public const int SPI_ICONHORIZONTALSPACING            =  13;
        public const int SPI_GETSCREENSAVETIMEOUT             =  14;
        public const int SPI_SETSCREENSAVETIMEOUT             =  15;
        public const int SPI_GETSCREENSAVEACTIVE              =  16;
        public const int SPI_SETSCREENSAVEACTIVE              =  17;
        public const int SPI_GETGRIDGRANULARITY               =  18;
        public const int SPI_SETGRIDGRANULARITY               =  19;
        public const int SPI_SETDESKWALLPAPER                 =  20;
        public const int SPI_SETDESKPATTERN                   =  21;
        public const int SPI_GETKEYBOARDDELAY                 =  22;
        public const int SPI_SETKEYBOARDDELAY                 =  23;
        public const int SPI_ICONVERTICALSPACING              =  24;
        public const int SPI_GETICONTITLEWRAP                 =  25;
        public const int SPI_SETICONTITLEWRAP                 =  26;
        public const int SPI_GETMENUDROPALIGNMENT             =  27;
        public const int SPI_SETMENUDROPALIGNMENT             =  28;
        public const int SPI_SETDOUBLECLKWIDTH                =  29;
        public const int SPI_SETDOUBLECLKHEIGHT               =  30;
        public const int SPI_GETICONTITLELOGFONT              =  31;
        public const int SPI_SETDOUBLECLICKTIME               =  32;
        public const int SPI_SETMOUSEBUTTONSWAP               =  33;
        public const int SPI_SETICONTITLELOGFONT              =  34;
        public const int SPI_GETFASTTASKSWITCH                =  35;
        public const int SPI_SETFASTTASKSWITCH                =  36;
        public const int SPI_SETDRAGFULLWINDOWS               =  37;
        public const int SPI_GETDRAGFULLWINDOWS               =  38;
        public const int SPI_GETNONCLIENTMETRICS              =  41;
        public const int SPI_SETNONCLIENTMETRICS              =  42;
        public const int SPI_GETMINIMIZEDMETRICS              =  43;
        public const int SPI_SETMINIMIZEDMETRICS              =  44;
        public const int SPI_GETICONMETRICS                   =  45;
        public const int SPI_SETICONMETRICS                   =  46;
        public const int SPI_SETWORKAREA                      =  47;
        public const int SPI_GETWORKAREA                      =  48;
        public const int SPI_SETPENWINDOWS                    =  49;
        public const int SPI_GETHIGHCONTRAST                  =  66;
        public const int SPI_SETHIGHCONTRAST                  =  67;
        public const int SPI_GETKEYBOARDPREF                  =  68;
        public const int SPI_SETKEYBOARDPREF                  =  69;
        public const int SPI_GETSCREENREADER                  =  70;
        public const int SPI_SETSCREENREADER                  =  71;
        public const int SPI_GETANIMATION                     =  72;
        public const int SPI_SETANIMATION                     =  73;
        public const int SPI_GETFONTSMOOTHING                 =  74;
        public const int SPI_SETFONTSMOOTHING                 =  75;
        public const int SPI_SETDRAGWIDTH                     =  76;
        public const int SPI_SETDRAGHEIGHT                    =  77;
        public const int SPI_SETHANDHELD                      =  78;
        public const int SPI_GETLOWPOWERTIMEOUT               =  79;
        public const int SPI_GETPOWEROFFTIMEOUT               =  80;
        public const int SPI_SETLOWPOWERTIMEOUT               =  81;
        public const int SPI_SETPOWEROFFTIMEOUT               =  82;
        public const int SPI_GETLOWPOWERACTIVE                =  83;
        public const int SPI_GETPOWEROFFACTIVE                =  84;
        public const int SPI_SETLOWPOWERACTIVE                =  85;
        public const int SPI_SETPOWEROFFACTIVE                =  86;
        public const int SPI_SETCURSORS                       =  87;
        public const int SPI_SETICONS                         =  88;
        public const int SPI_GETDEFAULTINPUTLANG              =  89;
        public const int SPI_SETDEFAULTINPUTLANG              =  90;
        public const int SPI_SETLANGTOGGLE                    =  91;
        public const int SPI_GETWINDOWSEXTENSION              =  92;
        public const int SPI_SETMOUSETRAILS                   =  93;
        public const int SPI_GETMOUSETRAILS                   =  94;
        public const int SPI_SETSCREENSAVERRUNNING            =  97;
        public const int SPI_SCREENSAVERRUNNING               =  SPI_SETSCREENSAVERRUNNING;
        public const int SPI_GETFILTERKEYS                    =  50;
        public const int SPI_SETFILTERKEYS                    =  51;
        public const int SPI_GETTOGGLEKEYS                    =  52;
        public const int SPI_SETTOGGLEKEYS                    =  53;
        public const int SPI_GETMOUSEKEYS                     =  54;
        public const int SPI_SETMOUSEKEYS                     =  55;
        public const int SPI_GETSHOWSOUNDS                    =  56;
        public const int SPI_SETSHOWSOUNDS                    =  57;
        public const int SPI_GETSTICKYKEYS                    =  58;
        public const int SPI_SETSTICKYKEYS                    =  59;
        public const int SPI_GETACCESSTIMEOUT                 =  60;
        public const int SPI_SETACCESSTIMEOUT                 =  61;
        public const int SPI_GETSERIALKEYS                    =  62;
        public const int SPI_SETSERIALKEYS                    =  63;
        public const int SPI_GETSOUNDSENTRY                   =  64;
        public const int SPI_SETSOUNDSENTRY                   =  65;
        public const int SPI_GETSNAPTODEFBUTTON               =  95;
        public const int SPI_SETSNAPTODEFBUTTON               =  96;
        public const int SPI_GETMOUSEHOVERWIDTH               =  98;
        public const int SPI_SETMOUSEHOVERWIDTH               =  99;
        public const int SPI_GETMOUSEHOVERHEIGHT              = 100;
        public const int SPI_SETMOUSEHOVERHEIGHT              = 101;
        public const int SPI_GETMOUSEHOVERTIME                = 102;
        public const int SPI_SETMOUSEHOVERTIME                = 103;
        public const int SPI_GETWHEELSCROLLLINES              = 104;
        public const int SPI_SETWHEELSCROLLLINES              = 105;
        public const int SPI_GETMENUSHOWDELAY                 = 106;
        public const int SPI_SETMENUSHOWDELAY                 = 107;
        public const int SPI_GETSHOWIMEUI                     = 110;
        public const int SPI_SETSHOWIMEUI                     = 111;
        public const int SPI_GETMOUSESPEED                    = 112;
        public const int SPI_SETMOUSESPEED                    = 113;
        public const int SPI_GETSCREENSAVERRUNNING            = 114;
        public const int SPI_GETDESKWALLPAPER                 = 115;
        public const int SPI_GETACTIVEWINDOWTRACKING          = 0x1000;
        public const int SPI_SETACTIVEWINDOWTRACKING          = 0x1001;
        public const int SPI_GETMENUANIMATION                 = 0x1002;
        public const int SPI_SETMENUANIMATION                 = 0x1003;
        public const int SPI_GETCOMBOBOXANIMATION             = 0x1004;
        public const int SPI_SETCOMBOBOXANIMATION             = 0x1005;
        public const int SPI_GETLISTBOXSMOOTHSCROLLING        = 0x1006;
        public const int SPI_SETLISTBOXSMOOTHSCROLLING        = 0x1007;
        public const int SPI_GETGRADIENTCAPTIONS              = 0x1008;
        public const int SPI_SETGRADIENTCAPTIONS              = 0x1009;
        public const int SPI_GETKEYBOARDCUES                  = 0x100A;
        public const int SPI_SETKEYBOARDCUES                  = 0x100B;
        public const int SPI_GETMENUUNDERLINES                = SPI_GETKEYBOARDCUES;
        public const int SPI_SETMENUUNDERLINES                = SPI_SETKEYBOARDCUES;
        public const int SPI_GETACTIVEWNDTRKZORDER            = 0x100C;
        public const int SPI_SETACTIVEWNDTRKZORDER            = 0x100D;
        public const int SPI_GETHOTTRACKING                   = 0x100E;
        public const int SPI_SETHOTTRACKING                   = 0x100F;
        public const int SPI_GETMENUFADE                      = 0x1012;
        public const int SPI_SETMENUFADE                      = 0x1013;
        public const int SPI_GETSELECTIONFADE                 = 0x1014;
        public const int SPI_SETSELECTIONFADE                 = 0x1015;
        public const int SPI_GETTOOLTIPANIMATION              = 0x1016;
        public const int SPI_SETTOOLTIPANIMATION              = 0x1017;
        public const int SPI_GETTOOLTIPFADE                   = 0x1018;
        public const int SPI_SETTOOLTIPFADE                   = 0x1019;
        public const int SPI_GETCURSORSHADOW                  = 0x101A;
        public const int SPI_SETCURSORSHADOW                  = 0x101B;
        public const int SPI_GETUIEFFECTS                     = 0x103E;
        public const int SPI_SETUIEFFECTS                     = 0x103F;
        public const int SPI_GETFOREGROUNDLOCKTIMEOUT         = 0x2000;
        public const int SPI_SETFOREGROUNDLOCKTIMEOUT         = 0x2001;
        public const int SPI_GETACTIVEWNDTRKTIMEOUT           = 0x2002;
        public const int SPI_SETACTIVEWNDTRKTIMEOUT           = 0x2003;
        public const int SPI_GETFOREGROUNDFLASHCOUNT          = 0x2004;
        public const int SPI_SETFOREGROUNDFLASHCOUNT          = 0x2005;
        public const int SPI_GETCARETWIDTH                    = 0x2006;
        public const int SPI_SETCARETWIDTH                    = 0x2007;
        
        public const int PBT_APMQUERYSUSPEND           = 0x0000;
        public const int PBT_APMQUERYSTANDBY           = 0x0001;
        public const int PBT_APMQUERYSUSPENDFAILED     = 0x0002;
        public const int PBT_APMQUERYSTANDBYFAILED     = 0x0003;
        public const int PBT_APMSUSPEND                = 0x0004;
        public const int PBT_APMSTANDBY                = 0x0005;
        public const int PBT_APMRESUMECRITICAL         = 0x0006;
        public const int PBT_APMRESUMESUSPEND          = 0x0007;
        public const int PBT_APMRESUMESTANDBY          = 0x0008;
        public const int PBT_APMBATTERYLOW             = 0x0009;
        public const int PBT_APMPOWERSTATUSCHANGE      = 0x000A;
        public const int PBT_APMOEMEVENT               = 0x000B;

        public const int STD_INPUT_HANDLE = -10;
        public const int STD_OUTPUT_HANDLE = -11;
        public const int STD_ERROR_HANDLE = -12;
        public const int STILL_ACTIVE = 0x00000103;
        public const int STARTF_USESTDHANDLES = 0x00000100;
        public const int STARTF_USESHOWWINDOW = 0x00000001;
        public const int SW_HIDE = 0;
        public const int FILE_SHARE_READ = 0x00000001;
        public const int FILE_SHARE_WRITE = 0x00000002;
        public const int FILE_SHARE_DELETE = 0x00000004;
        public const int FILE_MAP_WRITE = 0x00000002;
        public const int FILE_MAP_READ = 0x00000004;
        public const int PAGE_READWRITE = 0x00000004;
        public const int CREATE_ALWAYS = 2;
        public const int FILE_ATTRIBUTE_NORMAL = 0x00000080;
        public const int GENERIC_READ = unchecked(((int)0x80000000));
        public const int GENERIC_WRITE = (0x40000000);
        public const int GENERIC_EXECUTE = (0x20000000);
        public const int GENERIC_ALL = (0x10000000);
        public const int WAIT_OBJECT_0    = 0x00000000;
        public const int WAIT_FAILED      = unchecked((int)0xFFFFFFFF);
        public const int WAIT_TIMEOUT     = 0x00000102;
        public const int WAIT_ABANDONED   = 0x00000080;
        public const int WAIT_ABANDONED_0 = WAIT_ABANDONED;
        public const int ERROR_NOT_READY  = 21;
        public const int ERROR_LOCK_FAILED = 167;

        public const int IMPERSONATION_LEVEL_SecurityAnonymous = 0;
        public const int IMPERSONATION_LEVEL_SecurityIdentification = 1; 
        public const int IMPERSONATION_LEVEL_SecurityImpersonation = 2;
        public const int IMPERSONATION_LEVEL_SecurityDelegation = 3;

        public const int TOKEN_TYPE_TokenPrimary = 1;
        public const int TOKEN_TYPE_TokenImpersonation = 2;

        public const int TOKEN_ALL_ACCESS   = 0x000f01ff;
        public const int TOKEN_EXECUTE      = 0x00020000;
        public const int TOKEN_READ         = 0x00020008;
        public const int TOKEN_IMPERSONATE  = 0x00000004;

        public const int PIPE_ACCESS_INBOUND = 0x00000001;
        public const int PIPE_ACCESS_OUTBOUND = 0x00000002;
        public const int PIPE_ACCESS_DUPLEX = 0x00000003;
                                                                     
        public const int PIPE_WAIT = 0x00000000;
        public const int PIPE_NOWAIT = 0x00000001;
        public const int PIPE_READMODE_BYTE = 0x00000000;
        public const int PIPE_READMODE_MESSAGE = 0x00000002;
        public const int PIPE_TYPE_BYTE = 0x00000000;
        public const int PIPE_TYPE_MESSAGE = 0x00000004;
        
        public const int PIPE_UNLIMITED_INSTANCES = 255;
        
        public const int FILE_FLAG_OVERLAPPED = 0x40000000;

                                                                                                                                                                                        
        public const int PM_REMOVE = 0x0001;
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        internal class WNDCLASS_I {
            public int      style;
            public IntPtr   lpfnWndProc;
            public int      cbClsExtra = 0;
            public int      cbWndExtra = 0;
            public IntPtr   hInstance = IntPtr.Zero;
            public IntPtr   hIcon = IntPtr.Zero;
            public IntPtr   hCursor = IntPtr.Zero;
            public IntPtr   hbrBackground = IntPtr.Zero;
            public IntPtr   lpszMenuName = IntPtr.Zero;
            public IntPtr   lpszClassName = IntPtr.Zero;
        }
        
        [StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        internal class WNDCLASS {
            public int      style;
            public WndProc  lpfnWndProc;
            public int      cbClsExtra = 0;
            public int      cbWndExtra = 0;
            public IntPtr   hInstance = IntPtr.Zero;
            public IntPtr   hIcon = IntPtr.Zero;
            public IntPtr   hCursor = IntPtr.Zero;
            public IntPtr   hbrBackground = IntPtr.Zero;
            public string   lpszMenuName = null;
            public string   lpszClassName = null;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        public struct MSG {
            public IntPtr   hwnd;
            public int      message;
            public IntPtr   wParam;
            public IntPtr   lParam;
            public int      time;
            public int      pt_x;
            public int      pt_y;
        }
        
        public enum StructFormatEnum {
            Ansi = 1,
            Unicode = 2,
            Auto = 3,
        }

        [StructLayout(LayoutKind.Sequential)]
        internal class PROCESS_INFORMATION {
            public IntPtr   hProcess = IntPtr.Zero;
            public IntPtr   hThread = IntPtr.Zero;
            public int      dwProcessId = 0;
            public int      dwThreadId = 0;
        }


        //
        // DACL related stuff
        //
        [StructLayout(LayoutKind.Sequential)]
        internal class SECURITY_ATTRIBUTES {
                public int nLength = 12;
                public IntPtr lpSecurityDescriptor = IntPtr.Zero;
                public bool bInheritHandle = false;
        }

        internal const int SDDL_REVISION_1 = 1;

        [StructLayout(LayoutKind.Sequential)]
        internal class STARTUPINFO {
                public int cb;
                public IntPtr lpReserved = IntPtr.Zero;
                public IntPtr lpDesktop = IntPtr.Zero;
                public IntPtr lpTitle = IntPtr.Zero;
                public int dwX = 0;
                public int dwY = 0;
                public int dwXSize = 0;
                public int dwYSize = 0;
                public int dwXCountChars = 0;
                public int dwYCountChars = 0;
                public int dwFillAttribute = 0;
                public int dwFlags = 0;
                public short wShowWindow = 0;
                public short cbReserved2 = 0;
                public IntPtr lpReserved2 = IntPtr.Zero;
                public IntPtr hStdInput = IntPtr.Zero;
                public IntPtr hStdOutput = IntPtr.Zero;
                public IntPtr hStdError = IntPtr.Zero;
        }

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential, CharSet=CharSet.Auto)]
        internal class TEXTMETRIC {
                public int tmHeight = 0;
                public int tmAscent = 0;
                public int tmDescent = 0;
                public int tmInternalLeading = 0;
                public int tmExternalLeading = 0;
                public int tmAveCharWidth = 0;
                public int tmMaxCharWidth = 0;
                public int tmWeight = 0;
                public int tmOverhang = 0;
                public int tmDigitizedAspectX = 0;
                public int tmDigitizedAspectY = 0;
                public char tmFirstChar = '\0';
                public char tmLastChar = '\0';
                public char tmDefaultChar = '\0';
                public char tmBreakChar = '\0';
                public byte tmItalic = 0;
                public byte tmUnderlined = 0;
                public byte tmStruckOut = 0;
                public byte tmPitchAndFamily = 0;
                public byte tmCharSet = 0;
        }

        [System.Runtime.InteropServices.ComVisible(false)]
        public enum StructFormat {
            Ansi = 1,
            Unicode = 2,
            Auto = 3,
        }
        
        public delegate IntPtr WndProc(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
        
        public delegate int ConHndlr(int signalType);

        // file src\services\monitoring\system\diagnosticts\nativemethods.cs
        public const int SECURITY_DESCRIPTOR_REVISION = 1;                                                                           
        public const int HKEY_PERFORMANCE_DATA = unchecked((int)0x80000004);        
        public const int DWORD_SIZE = 4;
        public const int LARGE_INTEGER_SIZE = 8;

        public const int PERF_NO_INSTANCES     =      -1;  // no instances (see NumInstances above)

        public const int PERF_SIZE_DWORD        = 0x00000000;
        public const int PERF_SIZE_LARGE        = 0x00000100;
        public const int PERF_SIZE_ZERO         = 0x00000200;  // for Zero Length fields
        public const int PERF_SIZE_VARIABLE_LEN = 0x00000300;  // length is In CounterLength field

        public const int PERF_NO_UNIQUE_ID = -1;
                
        //
        //  select one of the following values to indicate the counter field usage
        //
        public const int PERF_TYPE_NUMBER       = 0x00000000;  // a number (not a counter)
        public const int PERF_TYPE_COUNTER      = 0x00000400;  // an increasing numeric value
        public const int PERF_TYPE_TEXT         = 0x00000800;  // a text field
        public const int PERF_TYPE_ZERO         = 0x00000C00;  // displays a zero
        
        //
        //  If the PERF_TYPE_NUMBER field was selected, then select one of the
        //  following to describe the Number
        //
        public const int PERF_NUMBER_HEX        = 0x00000000;  // display as HEX value
        public const int PERF_NUMBER_DECIMAL    = 0x00010000;  // display as a decimal integer
        public const int PERF_NUMBER_DEC_1000   = 0x00020000;  // display as a decimal/1000
        
        //
        //  If the PERF_TYPE_COUNTER value was selected then select one of the
        //  following to indicate the type of counter
        //
        public const int PERF_COUNTER_VALUE     = 0x00000000;  // display counter value
        public const int PERF_COUNTER_RATE      = 0x00010000;  // divide ctr / delta time
        public const int PERF_COUNTER_FRACTION  = 0x00020000;  // divide ctr / base
        public const int PERF_COUNTER_BASE      = 0x00030000;  // base value used In fractions
        public const int PERF_COUNTER_ELAPSED   = 0x00040000;  // subtract counter from current time
        public const int PERF_COUNTER_QUEUELEN  = 0x00050000;  // Use Queuelen processing func.
        public const int PERF_COUNTER_HISTOGRAM = 0x00060000;  // Counter begins or ends a histogram
        
        //
        //  If the PERF_TYPE_TEXT value was selected, then select one of the
        //  following to indicate the type of TEXT data.
        //
        public const int PERF_TEXT_UNICODE      = 0x00000000;  // type of text In text field
        public const int PERF_TEXT_ASCII        = 0x00010000;  // ASCII using the CodePage field
        
        //
        //  Timer SubTypes
        //
        public const int PERF_TIMER_TICK        = 0x00000000;  // use system perf. freq for base
        public const int PERF_TIMER_100NS       = 0x00100000;  // use 100 NS timer time base units
        public const int PERF_OBJECT_TIMER      = 0x00200000;  // use the object timer freq
        
        //
        //  Any types that have calculations performed can use one or more of
        //  the following calculation modification flags listed here
        //
        public const int PERF_DELTA_COUNTER     = 0x00400000;  // compute difference first
        public const int PERF_DELTA_BASE        = 0x00800000;  // compute base diff as well
        public const int PERF_INVERSE_COUNTER   = 0x01000000;  // show as 1.00-value (assumes:
        public const int PERF_MULTI_COUNTER     = 0x02000000;  // sum of multiple instances
        
        //
        //  Select one of the following values to indicate the display suffix (if any)
        //
        public const int PERF_DISPLAY_NO_SUFFIX = 0x00000000;  // no suffix
        public const int PERF_DISPLAY_PER_SEC   = 0x10000000;  // "/sec"
        public const int PERF_DISPLAY_PERCENT   = 0x20000000;  // "%"
        public const int PERF_DISPLAY_SECONDS   = 0x30000000;  // "secs"
        public const int PERF_DISPLAY_NOSHOW    = 0x40000000;  // value is not displayed
        
        //
        //  Predefined counter types
        //

        // 32-bit Counter.  Divide delta by delta time.  Display suffix: "/sec"
        public const int PERF_COUNTER_COUNTER  =
                (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |
                 PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PER_SEC);


        // 64-bit Timer.  Divide delta by delta time.  Display suffix: "%"
        public const int PERF_COUNTER_TIMER =
                (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |
                PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PERCENT);

        // Queue Length Space-Time Product. Divide delta by delta time. No Display Suffix.
        public const int PERF_COUNTER_QUEUELEN_TYPE =
                (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_QUEUELEN |
                PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX);

        // Queue Length Space-Time Product. Divide delta by delta time. No Display Suffix.
        public const int PERF_COUNTER_LARGE_QUEUELEN_TYPE =
                (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_QUEUELEN |
                PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX);

        // 64-bit Counter.  Divide delta by delta time. Display Suffix: "/sec"
        public const int PERF_COUNTER_BULK_COUNT =
                (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |
                PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_PER_SEC);

        // Indicates the counter is not a  counter but rather Unicode text Display as text.
        public const int PERF_COUNTER_TEXT =
                (PERF_SIZE_VARIABLE_LEN | PERF_TYPE_TEXT | PERF_TEXT_UNICODE |
                PERF_DISPLAY_NO_SUFFIX);

        // Indicates the data is a counter  which should not be
        // time averaged on display (such as an error counter on a serial line)
        // Display as is.  No Display Suffix.
        public const int PERF_COUNTER_RAWCOUNT =
                (PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL |
                PERF_DISPLAY_NO_SUFFIX);

        // Same as PERF_COUNTER_RAWCOUNT except its size is a large integer
        public const int PERF_COUNTER_LARGE_RAWCOUNT =
                (PERF_SIZE_LARGE | PERF_TYPE_NUMBER | PERF_NUMBER_DECIMAL |
                PERF_DISPLAY_NO_SUFFIX);

        // Special case for RAWCOUNT that want to be displayed In hex
        // Indicates the data is a counter  which should not be
        // time averaged on display (such as an error counter on a serial line)
        // Display as is.  No Display Suffix.
        public const int PERF_COUNTER_RAWCOUNT_HEX =
                (PERF_SIZE_DWORD | PERF_TYPE_NUMBER | PERF_NUMBER_HEX |
                PERF_DISPLAY_NO_SUFFIX);

        // Same as PERF_COUNTER_RAWCOUNT_HEX except its size is a large integer
        public const int PERF_COUNTER_LARGE_RAWCOUNT_HEX =
                (PERF_SIZE_LARGE | PERF_TYPE_NUMBER | PERF_NUMBER_HEX |
                PERF_DISPLAY_NO_SUFFIX);

        // A count which is either 1 or 0 on each sampling interrupt (% busy)
        // Divide delta by delta base. Display Suffix: "%"
        public const int PERF_SAMPLE_FRACTION =
                (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |
                PERF_DELTA_COUNTER | PERF_DELTA_BASE | PERF_DISPLAY_PERCENT);

        // A count which is sampled on each sampling interrupt (queue length)
        // Divide delta by delta time. No Display Suffix.
        public const int PERF_SAMPLE_COUNTER =
                (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |
                PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX);

        // A label: no data is associated with this counter (it has 0 length)
        // Do not display.
        public const int PERF_COUNTER_NODATA =
                (PERF_SIZE_ZERO | PERF_DISPLAY_NOSHOW);

        // 64-bit Timer inverse (e.g., idle is measured, but display busy %)
        // Display 100 - delta divided by delta time.  Display suffix: "%"
        public const int PERF_COUNTER_TIMER_INV =
                (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |
                PERF_TIMER_TICK | PERF_DELTA_COUNTER | PERF_INVERSE_COUNTER |
                PERF_DISPLAY_PERCENT);

        // The divisor for a sample, used with the previous counter to form a
        // sampled %.  You must check for >0 before dividing by this!  This
        // counter will directly follow the  numerator counter.  It should not
        // be displayed to the user.
        public const int PERF_SAMPLE_BASE =
                (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |
                PERF_DISPLAY_NOSHOW |
                0x00000001);  // for compatibility with pre-beta versions

        // A timer which, when divided by an average base, produces a time
        // In seconds which is the average time of some operation.  This
        // timer times total operations, and  the base is the number of opera-
        // tions.  Display Suffix: "sec"
        public const int PERF_AVERAGE_TIMER =
                (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |
                PERF_DISPLAY_SECONDS);

        // Used as the denominator In the computation of time or count
        // averages.  Must directly follow the numerator counter.  Not dis-
        // played to the user.
        public const int PERF_AVERAGE_BASE =
                (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |
                PERF_DISPLAY_NOSHOW |
                0x00000002);  // for compatibility with pre-beta versions


        // A bulk count which, when divided (typically) by the number of
        // operations, gives (typically) the number of bytes per operation.
        // No Display Suffix.
        public const int PERF_AVERAGE_BULK =
                (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION  |
                PERF_DISPLAY_NOSHOW);

        // 64-bit Timer In 100 nsec units. Display delta divided by
        // delta time.  Display suffix: "%"
        public const int PERF_100NSEC_TIMER =
                (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |
                PERF_TIMER_100NS | PERF_DELTA_COUNTER | PERF_DISPLAY_PERCENT);

        // 64-bit Timer inverse (e.g., idle is measured, but display busy %)
        // Display 100 - delta divided by delta time.  Display suffix: "%"
        public const int PERF_100NSEC_TIMER_INV =
                (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |
                PERF_TIMER_100NS | PERF_DELTA_COUNTER | PERF_INVERSE_COUNTER  |
                PERF_DISPLAY_PERCENT);

        // 64-bit Timer.  Divide delta by delta time.  Display suffix: "%"
        // Timer for multiple instances, so result can exceed 100%.
        public const int PERF_COUNTER_MULTI_TIMER =
                (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |
                PERF_DELTA_COUNTER | PERF_TIMER_TICK | PERF_MULTI_COUNTER |
                PERF_DISPLAY_PERCENT);

        // 64-bit Timer inverse (e.g., idle is measured, but display busy %)
        // Display 100 * _MULTI_BASE - delta divided by delta time.
        // Display suffix: "%" Timer for multiple instances, so result
        // can exceed 100%.  Followed by a counter of type _MULTI_BASE.
        public const int PERF_COUNTER_MULTI_TIMER_INV =
                (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_RATE |
                PERF_DELTA_COUNTER | PERF_MULTI_COUNTER | PERF_TIMER_TICK |
                PERF_INVERSE_COUNTER | PERF_DISPLAY_PERCENT);

        // Number of instances to which the preceding _MULTI_..._INV counter
        // applies.  Used as a factor to get the percentage.
        public const int PERF_COUNTER_MULTI_BASE =
                (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |
                PERF_MULTI_COUNTER | PERF_DISPLAY_NOSHOW);

        // 64-bit Timer In 100 nsec units. Display delta divided by delta time.
        // Display suffix: "%" Timer for multiple instances, so result can exceed 100%.
        public const int PERF_100NSEC_MULTI_TIMER =
                (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_DELTA_COUNTER  |
                PERF_COUNTER_RATE | PERF_TIMER_100NS | PERF_MULTI_COUNTER |
                PERF_DISPLAY_PERCENT);

        // 64-bit Timer inverse (e.g., idle is measured, but display busy %)
        // Display 100 * _MULTI_BASE - delta divided by delta time.
        // Display suffix: "%" Timer for multiple instances, so result
        // can exceed 100%.  Followed by a counter of type _MULTI_BASE.
        public const int PERF_100NSEC_MULTI_TIMER_INV =
                (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_DELTA_COUNTER  |
                PERF_COUNTER_RATE | PERF_TIMER_100NS | PERF_MULTI_COUNTER |
                PERF_INVERSE_COUNTER | PERF_DISPLAY_PERCENT);

        // Indicates the data is a fraction of the following counter  which
        // should not be time averaged on display (such as free space over
        // total space.) Display as is.  Display the quotient as "%".
        public const int PERF_RAW_FRACTION =
                (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_FRACTION |
                PERF_DISPLAY_PERCENT);

        // Indicates the data is a base for the preceding counter which should
        // not be time averaged on display (such as free space over total space.)
        public const int PERF_RAW_BASE =
                (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_BASE |
                PERF_DISPLAY_NOSHOW |
                0x00000003);  // for compatibility with pre-beta versions

        // The data collected In this counter is actually the start time of the
        // item being measured. For display, this data is subtracted from the
        // sample time to yield the elapsed time as the difference between the two.
        // In the definition below, the PerfTime field of the Object contains
        // the sample time as indicated by the PERF_OBJECT_TIMER bit and the
        // difference is scaled by the PerfFreq of the Object to convert the time
        // units into seconds.
        public const int PERF_ELAPSED_TIME =
                (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_ELAPSED |
                PERF_OBJECT_TIMER | PERF_DISPLAY_SECONDS);
        
        //
        //  The following counter type can be used with the preceding types to
        //  define a range of values to be displayed In a histogram.
        //

        //
        //  This counter is used to display the difference from one sample
        //  to the next. The counter value is a constantly increasing number
        //  and the value displayed is the difference between the current
        //  value and the previous value. Negative numbers are not allowed
        //  which shouldn't be a problem as long as the counter value is
        //  increasing or unchanged.
        //
        public const int PERF_COUNTER_DELTA =
                (PERF_SIZE_DWORD | PERF_TYPE_COUNTER | PERF_COUNTER_VALUE |
                PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX);

        public const int PERF_COUNTER_LARGE_DELTA =
                (PERF_SIZE_LARGE | PERF_TYPE_COUNTER | PERF_COUNTER_VALUE |
                PERF_DELTA_COUNTER | PERF_DISPLAY_NO_SUFFIX);
        
        //
        //  The following are used to determine the level of detail associated
        //  with the counter.  The user will be setting the level of detail
        //  that should be displayed at any given time.
        //
        public const int PERF_DETAIL_NOVICE      =    100; // The uninformed can understand it
        public const int PERF_DETAIL_ADVANCED    =    200; // For the advanced user
        public const int PERF_DETAIL_EXPERT      =    300; // For the expert user
        public const int PERF_DETAIL_WIZARD      =    400; // For the system designer

        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        internal class SECURITY_DESCRIPTOR {
            public byte Revision = 0;
            public byte Sbz1 = 0;
            public short Control = 0;
            public int Owner = 0;  // void*
            public int Group = 0;  // void*
            public int Sacl = 0;   // ACL*
            public int Dacl = 0;   // ACL*
        }
                                                                                            
        [StructLayout(LayoutKind.Sequential)]
        internal class PERF_COUNTER_BLOCK {
            public int ByteLength;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal class PERF_COUNTER_DEFINITION {
            public int ByteLength;
            public int CounterNameTitleIndex;
            public int CounterNameTitlePtr;
            public int CounterHelpTitleIndex;
            public int CounterHelpTitlePtr;
            public int DefaultScale;
            public int DetailLevel;
            public int CounterType;
            public int CounterSize;
            public int CounterOffset;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal class PERF_DATA_BLOCK {
            public int Signature1 = 0;
            public int Signature2 = 0;    
            public int LittleEndian = 0; 
            public int Version = 0;
            public int Revision = 0; 
            public int TotalByteLength = 0;
            public int HeaderLength = 0; 
            public int NumObjectTypes = 0;
            public int DefaultObject = 0;         
            public SYSTEMTIME SystemTime = null;
            public int pad1 = 0;  // Need to pad the struct to get quadword alignment for the 'long' after SystemTime
            public long PerfTime = 0;
            public long PerfFreq = 0;
            public long PerfTime100nSec = 0;   
            public int SystemNameLength = 0;
            public int SystemNameOffset = 0; 
        }  
            
        [StructLayout(LayoutKind.Sequential)]
        internal class PERF_INSTANCE_DEFINITION {
            public int ByteLength;
            public int ParentObjectTitleIndex;
            public int ParentObjectInstance;
            public int UniqueID;
            public int NameOffset;
            public int NameLength;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal class PERF_OBJECT_TYPE {
            public int TotalByteLength = 0;
            public int DefinitionLength = 0;
            public int HeaderLength = 0;
            public int ObjectNameTitleIndex = 0;
            public int ObjectNameTitlePtr = 0;
            public int ObjectHelpTitleIndex = 0;
            public int ObjectHelpTitlePtr = 0;
            public int DetailLevel = 0;
            public int NumCounters = 0;
            public int DefaultCounter = 0;
            public int NumInstances = 0;
            public int CodePage = 0;
            public long PerfTime = 0;
            public long PerfFreq = 0;
        }
        
        // copied from winbase.h
        public const int FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x00000100;
        public const int FORMAT_MESSAGE_IGNORE_INSERTS  = 0x00000200;
        public const int FORMAT_MESSAGE_FROM_STRING     = 0x00000400;
        public const int FORMAT_MESSAGE_FROM_HMODULE    = 0x00000800;
        public const int FORMAT_MESSAGE_FROM_SYSTEM     = 0x00001000;
        public const int FORMAT_MESSAGE_ARGUMENT_ARRAY  = 0x00002000;
        public const int FORMAT_MESSAGE_MAX_WIDTH_MASK  = 0x000000FF;
        public const int LOAD_WITH_ALTERED_SEARCH_PATH  = 0x00000008;
        public const int LOAD_LIBRARY_AS_DATAFILE       = 0x00000002;

        // copied from winerror.h
        public const int ERROR_NONE_MAPPED              = 1332;
        public const int ERROR_INSUFFICIENT_BUFFER      = 122;
        public const int ERROR_PROC_NOT_FOUND           = 127;
                                                                                                       
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int WaitForInputIdle(HandleRef handle, int milliseconds);        
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern IntPtr OpenProcess(int access, bool inherit, int processId);
        [DllImport(ExternDll.Psapi, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool EnumProcessModules(HandleRef handle, IntPtr modules, int size, ref int needed);
        [DllImport(ExternDll.Psapi, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool EnumProcesses(int[] processIds, int size, out int needed);
        [DllImport(ExternDll.Psapi, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool GetModuleInformation(HandleRef processHandle, HandleRef moduleHandle, NtModuleInfo ntModuleInfo, int size);
        [DllImport(ExternDll.Psapi, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int GetModuleBaseName(HandleRef processHandle, HandleRef moduleHandle, StringBuilder baseName, int size);
        [DllImport(ExternDll.Psapi, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int GetModuleFileNameEx(HandleRef processHandle, HandleRef moduleHandle, StringBuilder baseName, int size);                
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool SetProcessWorkingSetSize(HandleRef handle, IntPtr min, IntPtr max);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool GetProcessWorkingSetSize(HandleRef handle, out IntPtr min, out IntPtr max);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool SetProcessAffinityMask(HandleRef handle, IntPtr mask);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool GetProcessAffinityMask(HandleRef handle, out IntPtr processMask, out IntPtr systemMask);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool GetThreadPriorityBoost(HandleRef handle, out bool disabled);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool SetThreadPriorityBoost(HandleRef handle, bool disabled);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool GetProcessPriorityBoost(HandleRef handle, out bool disabled);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool SetProcessPriorityBoost(HandleRef handle, bool disabled);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern IntPtr OpenThread(int access, bool inherit, int threadId);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool SetThreadPriority(HandleRef handle, int priority);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int GetThreadPriority(HandleRef handle);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool SetThreadAffinityMask(HandleRef handle, HandleRef mask);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int SetThreadIdealProcessor(HandleRef handle, int processor);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern IntPtr CreateToolhelp32Snapshot(int flags, int processId);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool Process32First(HandleRef handle, IntPtr entry);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool Process32Next(HandleRef handle, IntPtr entry);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool Thread32First(HandleRef handle, WinThreadEntry entry);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool Thread32Next(HandleRef handle, WinThreadEntry entry);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool Module32First(HandleRef handle, IntPtr entry);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool Module32Next(HandleRef handle, IntPtr entry);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool SetPriorityClass(HandleRef handle, int priorityClass);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int GetPriorityClass(HandleRef handle);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool GetProcessTimes(HandleRef handle, long[] creation, long[] exit, long[] kernel, long[] user);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool EnumWindows(EnumThreadWindowsCallback callback, IntPtr extraData);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int GetWindowThreadProcessId(HandleRef handle, out int processId);
        [DllImport(ExternDll.Shell32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool ShellExecuteEx(ShellExecuteInfo info);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetCurrentProcessId();
        [DllImport(ExternDll.Ntdll, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int NtQueryInformationProcess(HandleRef processHandle, int query, NtProcessBasicInfo info, int size, int[] returnedSize);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool TerminateProcess(HandleRef processHandle, int exitCode);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool GetExitCodeProcess(HandleRef processHandle, out int exitCode);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Ansi, SetLastError=true)]
        public static extern IntPtr GetCurrentProcess();
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int GetConsoleCP();
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int GetConsoleOutputCP();
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true, BestFitMapping=false)]
        public static extern bool CreateProcess(
            [MarshalAs(UnmanagedType.LPTStr)]
            string lpApplicationName,                   // LPCTSTR
            StringBuilder lpCommandLine,                // LPTSTR - note: CreateProcess might insert a null somewhere in this string
            SecurityAttributes lpProcessAttributes,    // LPSECURITY_ATTRIBUTES
            SecurityAttributes lpThreadAttributes,     // LPSECURITY_ATTRIBUTES
            bool bInheritHandles,                        // BOOL
            int dwCreationFlags,                        // DWORD
            IntPtr lpEnvironment,                       // LPVOID
            [MarshalAs(UnmanagedType.LPTStr)]           
            string lpCurrentDirectory,                  // LPCTSTR
            CreateProcessStartupInfo lpStartupInfo,                  // LPSTARTUPINFO
            CreateProcessProcessInformation lpProcessInformation    // LPPROCESS_INFORMATION
        );
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern bool CreateProcessAsUserW(
            IntPtr token,
            [MarshalAs(UnmanagedType.LPTStr)]
            string lpApplicationName,                   // LPCTSTR
            [MarshalAs(UnmanagedType.LPTStr)]           
            string lpCommandLine,                       // LPCTSTR
            SecurityAttributes lpProcessAttributes,    // LPSECURITY_ATTRIBUTES
            SecurityAttributes lpThreadAttributes,     // LPSECURITY_ATTRIBUTES
            bool bInheritHandles,                        // BOOL
            int dwCreationFlags,                        // DWORD
            IntPtr lpEnvironment,                       // LPVOID
            [MarshalAs(UnmanagedType.LPTStr)]           
            string lpCurrentDirectory,                  // LPCTSTR
            CreateProcessStartupInfo lpStartupInfo,                  // LPSTARTUPINFO
            CreateProcessProcessInformation lpProcessInformation    // LPPROCESS_INFORMATION
        );

        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern IntPtr CreateNamedPipe(string name, int openMode, int pipeMode, int maxInstances, int outBufSize, int inBufSize, int timeout, SecurityAttributes lpPipeAttributes);

        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool CreatePipe(out IntPtr hReadPipe, out IntPtr hWritePipe, SecurityAttributes lpPipeAttributes, int nSize);
        public static void IntCreatePipe(out IntPtr hReadPipe, out IntPtr hWritePipe, SecurityAttributes lpPipeAttributes, int nSize) {
            bool ret = CreatePipe(out hReadPipe, out hWritePipe, lpPipeAttributes, nSize);
            if (!ret || hReadPipe == INVALID_HANDLE_VALUE || hWritePipe == INVALID_HANDLE_VALUE) 
                throw new Win32Exception();
        }
        
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr CreateFile(string lpFileName,int dwDesiredAccess,int dwShareMode, SecurityAttributes lpSecurityAttributes, int dwCreationDisposition,int dwFlagsAndAttributes,HandleRef hTemplateFile);
                
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool ReadFile(HandleRef hFile, IntPtr lpBuffer, int nNumberOfBytesToRead, out int lpNumberOfBytesRead, HandleRef lpOverLapped);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool WriteFile(HandleRef hFile, IntPtr lpBuffer, int nNumberOfBytesToWrite, out int lpNumberOfBytesWritten, HandleRef lpOverLapped);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Ansi, SetLastError=true)]
        public static extern IntPtr GetStdHandle(int whichHandle);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Ansi, SetLastError=true)]    
        public static extern bool DuplicateHandle(
            HandleRef hSourceProcessHandle,
            HandleRef hSourceHandle,
            HandleRef hTargetProcess,
            out IntPtr lpTargetHandle,
            int dwDesiredAccess,
            bool bInheritHandle,
            int dwOptions
        );
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool LogonUser(
            [MarshalAs(UnmanagedType.LPTStr)]
            string lpszUsername,
            [MarshalAs(UnmanagedType.LPTStr)]
            string lpszDomain,     
            [MarshalAs(UnmanagedType.LPTStr)]
            string lpszPassword,    
            int dwLogonType,        
            int dwLogonProvider,    
            out IntPtr phToken          
        );
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool OpenProcessToken(HandleRef ProcessHandle, int DesiredAccess, out IntPtr TokenHandle);
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool LookupPrivilegeValue([MarshalAs(UnmanagedType.LPTStr)] string lpSystemName, [MarshalAs(UnmanagedType.LPTStr)] string lpName, out LUID lpLuid);
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool AdjustTokenPrivileges(
            HandleRef TokenHandle,
            bool DisableAllPrivileges,
            TokenPrivileges NewState,
            int BufferLength,
            IntPtr PreviousState,
            IntPtr ReturnLength
        );
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetWindowText(HandleRef hWnd, StringBuilder lpString, int nMaxCount);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetWindowTextLength(HandleRef hWnd);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool IsWindowVisible(HandleRef hWnd);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr SendMessageTimeout(HandleRef hWnd, int msg, IntPtr wParam, IntPtr lParam, int flags, int timeout, out IntPtr pdwResult);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetWindowLong(HandleRef hWnd, int nIndex);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int PostMessage(HandleRef hwnd, int msg, IntPtr wparam, IntPtr lparam);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, SetLastError=true)]
        public static extern int WaitForSingleObject(HandleRef handle, int timeout);
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GetWindow(HandleRef hWnd, int uCmd);
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]        
        public static extern int RegConnectRegistry(string machineName, HandleRef key, out IntPtr result);        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int RegOpenKeyEx(HandleRef hKey, string lpSubKey, IntPtr ulOptions, int samDesired, out IntPtr phkResult);        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int RegQueryValueEx(HandleRef hKey, string name, int[] reserved, out int type, byte[] data, ref int size);        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int RegQueryValueEx(HandleRef hKey, string name, int[] reserved, out int type, char[] data, ref int size);       

        [StructLayout(LayoutKind.Sequential)]
        internal class NtModuleInfo {
            public IntPtr BaseOfDll = (IntPtr)0;
            public int SizeOfImage = 0;
            public IntPtr EntryPoint = (IntPtr)0;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        internal class WinProcessEntry {
            public int dwSize = 0;
            public int cntUsage = 0;
            public int th32ProcessID = 0;
            public IntPtr th32DefaultHeapID = (IntPtr)0;
            public int th32ModuleID = 0;
            public int cntThreads = 0;
            public int th32ParentProcessID = 0;
            public int pcPriClassBase = 0;
            public int dwFlags = 0;
            //[MarshalAs(UnmanagedType.ByValTStr, SizeConst=260)]
            //public string fileName;
            //byte fileName[260];
            public const int sizeofFileName = 260;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal class WinThreadEntry {
            public int dwSize = 0;
            public int cntUsage = 0;
            public int th32ThreadID = 0;
            public int th32OwnerProcessID = 0;
            public int tpBasePri = 0;
            public int tpDeltaPri = 0;
            public int dwFlags = 0;
        }
    
        [StructLayout(LayoutKind.Sequential)]
        internal class WinModuleEntry {  // MODULEENTRY32
            public int dwSize = 0;
            public int th32ModuleID = 0;
            public int th32ProcessID = 0;
            public int GlblcntUsage = 0;
            public int ProccntUsage = 0;
            public IntPtr modBaseAddr = (IntPtr)0;
            public int modBaseSize = 0;
            public IntPtr hModule = (IntPtr)0;
            //byte moduleName[256];
            //[MarshalAs(UnmanagedType.ByValTStr, SizeConst=256)]
            //public string moduleName;
            //[MarshalAs(UnmanagedType.ByValTStr, SizeConst=260)]
            //public string fileName; 
            //byte fileName[260];
            public const int sizeofModuleName = 256;
            public const int sizeofFileName = 260;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal class ShellExecuteInfo {
            public int cbSize = 0;
            public int fMask = 0;
            public IntPtr hwnd = (IntPtr)0;
            public IntPtr lpVerb = (IntPtr)0;
            public IntPtr lpFile = (IntPtr)0;
            public IntPtr lpParameters = (IntPtr)0;
            public IntPtr lpDirectory = (IntPtr)0;
            public int nShow = 0;
            public IntPtr hInstApp = (IntPtr)0;
            public IntPtr lpIDList = (IntPtr)0;
            public IntPtr lpClass = (IntPtr)0;
            public IntPtr hkeyClass = (IntPtr)0;
            public int dwHotKey = 0;
            public IntPtr hIcon = (IntPtr)0;
            public IntPtr hProcess = (IntPtr)0;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal class SecurityAttributes {
            public int nLength = Marshal.SizeOf(typeof(SecurityAttributes));
            public IntPtr lpSecurityDescriptor;
            public bool bInheritHandle;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        internal class CreateProcessStartupInfo {
            public int cb = Marshal.SizeOf(typeof(CreateProcessStartupInfo));
            public string lpReserved = null;
            public string lpDesktop = null;
            public string lpTitle = null;
            public int dwX = 0;
            public int dwY = 0;
            public int dwXSize = 0;
            public int dwYSize = 0;
            public int dwXCountChars = 0;
            public int dwYCountChars = 0;
            public int dwFillAttribute = 0;
            public int dwFlags = 0;
            public short wShowWindow = 0;
            public short cbReserved2 = 0;
            public IntPtr lpReserved2 = (IntPtr)0;
            public IntPtr hStdInput = (IntPtr)0;
            public IntPtr hStdOutput = (IntPtr)0;
            public IntPtr hStdError = (IntPtr)0;
        }
        
        [StructLayout(LayoutKind.Sequential)]
        internal class CreateProcessProcessInformation {
            public IntPtr hProcess = (IntPtr)0;
            public IntPtr hThread = (IntPtr)0;
            public int dwProcessId = 0;
            public int dwThreadId = 0;
        }


        [StructLayout(LayoutKind.Sequential)]
        internal class NtProcessBasicInfo {
            public int ExitStatus = 0;
            public int PebBaseAddress = 0;
            public int AffinityMask = 0;
            public int BasePriority = 0;
            public int UniqueProcessId = 0;
            public int InheritedFromUniqueProcessId = 0;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct LUID {
            public int LowPart;
            public int HighPart;
        }

        [StructLayout(LayoutKind.Sequential)]
        internal class TokenPrivileges {
            public int PrivilegeCount = 1;
            public LUID Luid;
            public int Attributes = 0;
        }
                                       
        public delegate bool EnumThreadWindowsCallback(IntPtr hWnd, IntPtr lParam);
        
        [System.Runtime.InteropServices.ComVisible(false), StructLayout(LayoutKind.Sequential)]
        internal class SYSTEMTIME {
            public short wYear;
            public short wMonth;
            public short wDayOfWeek;
            public short wDay;
            public short wHour;
            public short wMinute;
            public short wSecond;
            public short wMilliseconds;

            public override string ToString() {
                return "[SYSTEMTIME: " 
                + wDay.ToString() +"/" + wMonth.ToString() + "/" + wYear.ToString() 
                + " " + wHour.ToString() + ":" + wMinute.ToString() + ":" + wSecond.ToString()
                + "]";
            }
        }

        
        public static readonly IntPtr INVALID_HANDLE_VALUE = (IntPtr)(-1);                       
        public const int NtPerfCounterSizeDword = 0x00000000;
        public const int NtPerfCounterSizeLarge = 0x00000100;
        
        public const int SHGFI_USEFILEATTRIBUTES = 0x000000010;  // use passed dwFileAttribute
        public const int SHGFI_TYPENAME = 0x000000400;

        public const int NtQueryProcessBasicInfo = 0;
        
        public const int STILL_ALIVE = 0x00000103;

        public const int SEE_MASK_CLASSNAME = 0x00000001;    // Note CLASSKEY overrides CLASSNAME
        public const int SEE_MASK_CLASSKEY = 0x00000003;
        public const int SEE_MASK_IDLIST = 0x00000004;    // Note INVOKEIDLIST overrides IDLIST
        public const int SEE_MASK_INVOKEIDLIST = 0x0000000c;
        public const int SEE_MASK_ICON = 0x00000010;
        public const int SEE_MASK_HOTKEY = 0x00000020;
        public const int SEE_MASK_NOCLOSEPROCESS = 0x00000040;
        public const int SEE_MASK_CONNECTNETDRV = 0x00000080;
        public const int SEE_MASK_FLAG_DDEWAIT = 0x00000100;
        public const int SEE_MASK_DOENVSUBST = 0x00000200;
        public const int SEE_MASK_FLAG_NO_UI = 0x00000400;
        public const int SEE_MASK_UNICODE = 0x00004000;
        public const int SEE_MASK_NO_CONSOLE = 0x00008000;
        public const int SEE_MASK_ASYNCOK = 0x00100000;
        
        public const int TH32CS_SNAPHEAPLIST = 0x00000001;
        public const int TH32CS_SNAPPROCESS = 0x00000002;
        public const int TH32CS_SNAPTHREAD = 0x00000004;
        public const int TH32CS_SNAPMODULE = 0x00000008;
        public const int TH32CS_INHERIT = unchecked((int)0x80000000);

        public const int PROCESS_TERMINATE = 0x0001;
        public const int PROCESS_CREATE_THREAD = 0x0002;
        public const int PROCESS_SET_SESSIONID = 0x0004;
        public const int PROCESS_VM_OPERATION = 0x0008;
        public const int PROCESS_VM_READ = 0x0010;
        public const int PROCESS_VM_WRITE = 0x0020;
        public const int PROCESS_DUP_HANDLE = 0x0040;
        public const int PROCESS_CREATE_PROCESS = 0x0080;
        public const int PROCESS_SET_QUOTA = 0x0100;
        public const int PROCESS_SET_INFORMATION = 0x0200;
        public const int PROCESS_QUERY_INFORMATION = 0x0400;
        public const int STANDARD_RIGHTS_REQUIRED = 0x000F0000;
        public const int SYNCHRONIZE = 0x00100000;
        public const int PROCESS_ALL_ACCESS = STANDARD_RIGHTS_REQUIRED | SYNCHRONIZE | 0xFFF;

        public const int THREAD_TERMINATE = 0x0001;
        public const int THREAD_SUSPEND_RESUME = 0x0002;
        public const int THREAD_GET_CONTEXT = 0x0008;
        public const int THREAD_SET_CONTEXT = 0x0010;
        public const int THREAD_SET_INFORMATION = 0x0020;
        public const int THREAD_QUERY_INFORMATION = 0x0040;
        public const int THREAD_SET_THREAD_TOKEN = 0x0080;
        public const int THREAD_IMPERSONATE = 0x0100;
        public const int THREAD_DIRECT_IMPERSONATION = 0x0200;
        
        public static readonly IntPtr HKEY_LOCAL_MACHINE = unchecked((IntPtr)(int)0x80000002);        
        public const int REG_BINARY = 3;
        public const int REG_MULTI_SZ = 7;

        public const int READ_CONTROL                    = 0x00020000;
        public const int STANDARD_RIGHTS_READ            = READ_CONTROL;

        public const int KEY_QUERY_VALUE        = 0x0001;
        public const int KEY_ENUMERATE_SUB_KEYS = 0x0008;
        public const int KEY_NOTIFY             = 0x0010;

        public const int KEY_READ               =((STANDARD_RIGHTS_READ |
                                                           KEY_QUERY_VALUE |
                                                           KEY_ENUMERATE_SUB_KEYS |
                                                           KEY_NOTIFY)
                                                          &
                                                          (~SYNCHRONIZE));
        
        public const int ERROR_MORE_DATA = 234;
        public const int ERROR_CANCELLED = 1223;
        public const int ERROR_FILE_NOT_FOUND = 2;
        public const int ERROR_PATH_NOT_FOUND = 3;
        public const int ERROR_ACCESS_DENIED = 5;
        public const int ERROR_INVALID_HANDLE = 6;
        public const int ERROR_NOT_ENOUGH_MEMORY = 8;
        public const int ERROR_SHARING_VIOLATION = 32;
        public const int ERROR_NO_ASSOCIATION = 1155;
        public const int ERROR_DLL_NOT_FOUND = 1157;
        public const int ERROR_DDE_FAIL = 1156;
        public const int ERROR_INVALID_PARAMETER = 87;
        public const int ERROR_PARTIAL_COPY = 299;
        public const int ERROR_SUCCESS = 0;
        public const int ERROR_ALREADY_EXISTS = 183;
        public const int RPC_S_SERVER_UNAVAILABLE = 1722;
        public const int RPC_S_CALL_FAILED = 1726;
        
        public const int SE_ERR_FNF = 2;
        public const int SE_ERR_PNF = 3;
        public const int SE_ERR_ACCESSDENIED = 5;
        public const int SE_ERR_OOM = 8;
        public const int SE_ERR_DLLNOTFOUND = 32;
        public const int SE_ERR_SHARE = 26;
        public const int SE_ERR_ASSOCINCOMPLETE = 27;
        public const int SE_ERR_DDETIMEOUT = 28;
        public const int SE_ERR_DDEFAIL = 29;
        public const int SE_ERR_DDEBUSY = 30;
        public const int SE_ERR_NOASSOC = 31;

        public const int SE_PRIVILEGE_ENABLED = 2;

        public const int DUPLICATE_CLOSE_SOURCE = 1;
        public const int DUPLICATE_SAME_ACCESS  = 2;        
        public const int LOGON32_LOGON_BATCH = 4;
        public const int LOGON32_PROVIDER_DEFAULT = 0;
        public const int LOGON32_LOGON_INTERACTIVE = 2;

        public const int TOKEN_ADJUST_PRIVILEGES = 0x20;
        public const int TOKEN_QUERY = 0x08;

        public const int CREATE_NO_WINDOW = 0x08000000;
        public const int CREATE_SUSPENDED = 0x00000004;
        public const int CREATE_UNICODE_ENVIRONMENT = 0x00000400;
        
        public const int SMTO_ABORTIFHUNG = 0x0002;
        public const int GWL_STYLE = (-16);
        public const int GWL_WNDPROC = (-4);
        public const int WS_DISABLED = 0x08000000;
        public const int WM_NULL = 0x0000;
        public const int WM_CLOSE = 0x0010;
        public const int SW_SHOWNORMAL = 1;
        public const int SW_NORMAL = 1;
        public const int SW_SHOWMINIMIZED = 2;
        public const int SW_SHOWMAXIMIZED = 3;
        public const int SW_MAXIMIZE = 3;
        public const int SW_SHOWNOACTIVATE = 4;
        public const int SW_SHOW = 5;
        public const int SW_MINIMIZE = 6;
        public const int SW_SHOWMINNOACTIVE = 7;
        public const int SW_SHOWNA = 8;
        public const int SW_RESTORE = 9;
        public const int SW_SHOWDEFAULT = 10;
        public const int SW_MAX = 10;
        public const int GW_OWNER = 4;
        public const int WHITENESS = 0x00FF0062;

        public const int 
        VS_FILE_INFO = 16,
        VS_VERSION_INFO = 1,
        VS_USER_DEFINED = 100,
        VS_FFI_SIGNATURE = unchecked((int)0xFEEF04BD),
        VS_FFI_STRUCVERSION = 0x00010000,
        VS_FFI_FILEFLAGSMASK = 0x0000003F,
        VS_FF_DEBUG = 0x00000001,
        VS_FF_PRERELEASE = 0x00000002,
        VS_FF_PATCHED = 0x00000004,
        VS_FF_PRIVATEBUILD = 0x00000008,
        VS_FF_INFOINFERRED = 0x00000010,
        VS_FF_SPECIALBUILD = 0x00000020,
        VFT_UNKNOWN = 0x00000000,
        VFT_APP = 0x00000001,
        VFT_DLL = 0x00000002,
        VFT_DRV = 0x00000003,
        VFT_FONT = 0x00000004,
        VFT_VXD = 0x00000005,
        VFT_STATIC_LIB = 0x00000007,
        VFT2_UNKNOWN = 0x00000000,
        VFT2_DRV_PRINTER = 0x00000001,
        VFT2_DRV_KEYBOARD = 0x00000002,
        VFT2_DRV_LANGUAGE = 0x00000003,
        VFT2_DRV_DISPLAY = 0x00000004,
        VFT2_DRV_MOUSE = 0x00000005,
        VFT2_DRV_NETWORK = 0x00000006,
        VFT2_DRV_SYSTEM = 0x00000007,
        VFT2_DRV_INSTALLABLE = 0x00000008,
        VFT2_DRV_SOUND = 0x00000009,
        VFT2_DRV_COMM = 0x0000000A,
        VFT2_DRV_INPUTMETHOD = 0x0000000B,
        VFT2_FONT_RASTER = 0x00000001,
        VFT2_FONT_VECTOR = 0x00000002,
        VFT2_FONT_TRUETYPE = 0x00000003;

        // from Windows Forms nativemethods.cs
        [StructLayout(LayoutKind.Sequential)]
        internal class VS_FIXEDFILEINFO {
            public int dwSignature = 0;
            public int dwStructVersion = 0;
            public int dwFileVersionMS = 0;
            public int dwFileVersionLS = 0;
            public int dwProductVersionMS = 0;
            public int dwProductVersionLS = 0;
            public int dwFileFlagsMask = 0;
            public int dwFileFlags = 0;
            public int dwFileOS = 0;
            public int dwFileType = 0;
            public int dwFileSubtype = 0;
            public int dwFileDateMS = 0;
            public int dwFileDateLS = 0;
        }

        public const int
        GMEM_FIXED = 0x0000,
        GMEM_MOVEABLE = 0x0002,
        GMEM_NOCOMPACT = 0x0010,
        GMEM_NODISCARD = 0x0020,
        GMEM_ZEROINIT = 0x0040,
        GMEM_MODIFY = 0x0080,
        GMEM_DISCARDABLE = 0x0100,
        GMEM_NOT_BANKED = 0x1000,
        GMEM_SHARE = 0x2000,
        GMEM_DDESHARE = 0x2000,
        GMEM_NOTIFY = 0x4000,
        GMEM_LOWER = 0x1000,
        GMEM_VALID_FLAGS = 0x7F72,
        GMEM_INVALID_HANDLE = unchecked((int)0x8000),
        GHND = (0x0002|0x0040),
        GPTR = (0x0000|0x0040),
        GMEM_DISCARDED = 0x4000,
        GMEM_LOCKCOUNT = 0x00FF;

        [DllImport(ExternDll.User32)]
        public static extern IntPtr GetProcessWindowStation();
        [DllImport(ExternDll.User32)]
        public static extern int GetUserObjectInformation(HandleRef hObj, int nIndex, [MarshalAs(UnmanagedType.LPStruct)] USEROBJECTFLAGS pvBuffer, int nLength, ref int lpnLengthNeeded);
       
        public const int UOI_NAME      = 2;
        public const int UOI_TYPE      = 3;
        public const int UOI_USER_SID  = 4;

        [StructLayout(LayoutKind.Sequential)]
        internal class USEROBJECTFLAGS {
            public int fInherit = 0;
            public int fReserved = 0;
            public int dwFlags = 0;
        }

        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetVersionEx([In, Out] OSVERSIONINFO ver);

        public const int VER_PLATFORM_WIN32_NT = 2;

        [StructLayout(LayoutKind.Sequential)]
        internal class OSVERSIONINFO {
            public int dwOSVersionInfoSize;
            public int dwMajorVersion = 0;
            public int dwMinorVersion = 0;
            public int dwBuildNumber = 0;
            public int dwPlatformId = 0;
            [MarshalAs(System.Runtime.InteropServices.UnmanagedType.ByValTStr, SizeConst=128)]
            public string   szCSDVersion = null;
        }
     
    internal class Util {
        public static int MAKELONG(int low, int high) {
            return (high << 16) | (low & 0xffff);
        }

        public static IntPtr MAKELPARAM(int low, int high) {
            return (IntPtr) ((high << 16) | (low & 0xffff));
        }

        public static int HIWORD(int n) {
            return (n >> 16) & 0xffff;
        }

        public static int HIWORD(IntPtr n) {
            return HIWORD( (int) n );
        }

        public static int LOWORD(int n) {
            return n & 0xffff;
        }

        public static int LOWORD(IntPtr n) {
            return LOWORD( (int) n );
        }

        public static int SignedHIWORD(IntPtr n) {
            return SignedHIWORD( (int) n );
        }
        public static int SignedLOWORD(IntPtr n) {
            return SignedLOWORD( (int) n );
        }
        
        public static int SignedHIWORD(int n) {
            int i = (int)(short)((n >> 16) & 0xffff);

            return i;
        }

        public static int SignedLOWORD(int n) {
            int i = (int)(short)(n & 0xFFFF);

            return i;
        }

        /// <include file='doc\NativeMethods.uex' path='docs/doc[@for="NativeMethods.Util.GetPInvokeStringLength"]/*' />
        /// <devdoc>
        ///     Computes the string size that should be passed to a typical Win32 call.
        ///     This will be the character count under NT, and the ubyte count for Windows 9X.
        /// </devdoc>
        public static int GetPInvokeStringLength(String s) {
            if (s == null) {
                return 0;
            }

            if (System.Runtime.InteropServices.Marshal.SystemDefaultCharSize == 2) {
                return s.Length;
            }
            else {
                if (s.Length == 0) {
                    return 0;
                }
                if (s.IndexOf('\0') > -1) {
                    return GetEmbededNullStringLengthAnsi(s);
                }
                else {
                    return lstrlen(s);
                }
            }
        }

        private static int GetEmbededNullStringLengthAnsi(String s) {
            int n = s.IndexOf('\0');
            if (n > -1) {
                String left = s.Substring(0, n);
                String right = s.Substring(n+1);
                return GetPInvokeStringLength(left) + GetEmbededNullStringLengthAnsi(right) + 1;
            }
            else {
                return GetPInvokeStringLength(s);
            }
        }

        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        private static extern int lstrlen(String s);

        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        internal static extern int RegisterWindowMessage(string msg);
    }
              
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\win32\powermodechangedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="PowerModeChangedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.Win32 {
    using System.Diagnostics;

    using System;

    /// <include file='doc\PowerModeChangedEventHandler.uex' path='docs/doc[@for="PowerModeChangedEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see cref='Microsoft.Win32.SystemEvents.PowerModeChanged'/> event.</para>
    /// </devdoc>
    public delegate void PowerModeChangedEventHandler(object sender, PowerModeChangedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\win32\safenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="SafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.Win32 {
    using System.Runtime.InteropServices;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [
    System.Runtime.InteropServices.ComVisible(false), 
    System.Security.SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class SafeNativeMethods {

        public const int
            FORMAT_MESSAGE_ALLOCATE_BUFFER = 0x00000100,
            FORMAT_MESSAGE_IGNORE_INSERTS = 0x00000200,
            FORMAT_MESSAGE_FROM_STRING = 0x00000400,
            FORMAT_MESSAGE_FROM_HMODULE = 0x00000800,
            FORMAT_MESSAGE_FROM_SYSTEM = 0x00001000,
            FORMAT_MESSAGE_ARGUMENT_ARRAY = 0x00002000,
            FORMAT_MESSAGE_MAX_WIDTH_MASK = 0x000000FF;

        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern void OutputDebugString(String message);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int MessageBox(HandleRef hWnd, string text, string caption, int type);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetTickCount();
        [DllImport(ExternDll.Kernel32, SetLastError=true)]
        public static extern int WaitForSingleObject(HandleRef handle, int timeout);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetCurrentProcessId();
        [DllImport(ExternDll.Kernel32)]
        public static extern int GetOEMCP();

        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetWindowThreadProcessId(HandleRef hWnd, out int lpdwProcessId);
        
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int RegisterWindowMessage(string msg);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetCurrentThreadId();


        [DllImport(ExternDll.Gdi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetTextMetrics(HandleRef hDC, [In, Out] NativeMethods.TEXTMETRIC tm);

        
        [DllImport(ExternDll.Gdi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GetStockObject(int nIndex);

        // From file src\services\timers\system\timers\safenativemethods.cs
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool SetWaitableTimer(HandleRef handle, long[] dueTime, int period, TimerAPCProc completionRoutine, HandleRef argToCompletionRoutine, bool resume);
        
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetSystemTimeAsFileTime(ref long time);
        
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr CreateWaitableTimer(NativeMethods.SECURITY_ATTRIBUTES timerAttributes, bool manualReset, String timerName);
        
         [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool CancelWaitableTimer(HandleRef handle);
        
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool CloseHandle(HandleRef handle);
        
        public delegate void TimerAPCProc(IntPtr argToCompletionRoutine, int timerLowValue, int timerHighValue);

        // file src\Services\Monitoring\system\Diagnosticts\SafeNativeMethods.cs
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int RegCloseKey(HandleRef hKey);
        
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int FormatMessage(int dwFlags, HandleRef lpSource, int dwMessageId,
                                               int dwLanguageId, StringBuilder lpBuffer, int nSize, IntPtr[] arguments);                                               
        
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern int FormatMessage(int dwFlags, HandleRef lpSource, int dwMessageId,
                                               int dwLanguageId, StringBuilder lpBuffer, int nSize, IntPtr arguments);                                               

        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern int FormatMessage(int dwFlags, HandleRef source, int dwMessageId,
                                                int dwLanguageId, char[] msgBuffer, int nSize, int[] insertStringAddrs);                                              
                                                
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern bool FreeLibrary(HandleRef hModule);     
        
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern IntPtr LoadLibrary(string libFilename);
        
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern IntPtr LoadLibraryEx(string libFilename, int reserved, int flags);        
                
        [DllImport(ExternDll.Kernel32, CharSet=CharSet.Auto)]
        public static extern bool GetComputerName(StringBuilder lpBuffer, int[] nSize);                                           
        
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern IntPtr GetModuleHandle(string moduleName);
        
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern int GetModuleFileName(HandleRef hModule, StringBuilder filename, int length);            
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern bool CloseEventLog(HandleRef hEventLog);            
        
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Unicode)]
        public static extern IntPtr CreateEvent(HandleRef lpEventAttributes, bool bManualReset,
                                               bool bInitialState, string name);                        
                                                                                              
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int InterlockedExchangeAdd(IntPtr pDestination, int increment);   
        
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int InterlockedCompareExchange(IntPtr pDestination, int exchange, int compare); 

        [DllImport(ExternDll.Kernel32)]
        public static extern bool QueryPerformanceCounter(out long value);
        
        [DllImport(ExternDll.Kernel32)]
        public static extern bool QueryPerformanceFrequency(out long value);

        [DllImport(ExternDll.Kernel32)]
        public static extern IntPtr LocalFree(IntPtr hMem);
                                                                                             
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\win32\powermodes.cs ===
//------------------------------------------------------------------------------
// <copyright file="PowerModes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.Win32 {
    using System.Diagnostics;
    using System;

    /// <include file='doc\PowerModes.uex' path='docs/doc[@for="PowerModes"]/*' />
    /// <devdoc>
    ///    <para> Specifies how the system
    ///       power mode changes.</para>
    /// </devdoc>
    public enum PowerModes {
    
        /// <include file='doc\PowerModes.uex' path='docs/doc[@for="PowerModes.Resume"]/*' />
        /// <devdoc>
        ///    <para> The system is about to resume.</para>
        /// </devdoc>
        Resume = 1,
        
        /// <include file='doc\PowerModes.uex' path='docs/doc[@for="PowerModes.StatusChange"]/*' />
        /// <devdoc>
        ///      The power mode status has changed.  This may
        ///      indicate a weak or charging battery, a transition
        ///      from AC power from battery, or other change in the
        ///      status of the system power supply.
        /// </devdoc>
        StatusChange = 2,
        
        /// <include file='doc\PowerModes.uex' path='docs/doc[@for="PowerModes.Suspend"]/*' />
        /// <devdoc>
        ///      The system is about to be suspended.
        /// </devdoc>
        Suspend = 3,
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\win32\sessionendedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="SessionEndedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.Win32 {
    using System.Diagnostics;

    using System;

    /// <include file='doc\SessionEndedEventHandler.uex' path='docs/doc[@for="SessionEndedEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see cref='Microsoft.Win32.SystemEvents.SessionEnded'/> event.</para>
    /// </devdoc>
    public delegate void SessionEndedEventHandler(object sender, SessionEndedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\win32\sessionendingeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="SessionEndingEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.Win32 {
    using System.Diagnostics;
    
    using System;
    
    /// <include file='doc\SessionEndingEventArgs.uex' path='docs/doc[@for="SessionEndingEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see cref='Microsoft.Win32.SystemEvents.SessionEnding'/> event.</para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class SessionEndingEventArgs : EventArgs {
    
        private bool cancel;
        private readonly SessionEndReasons reason;
    
        /// <include file='doc\SessionEndingEventArgs.uex' path='docs/doc[@for="SessionEndingEventArgs.SessionEndingEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='Microsoft.Win32.SessionEndingEventArgs'/> class.</para>
        /// </devdoc>
        public SessionEndingEventArgs(SessionEndReasons reason) {
            this.reason = reason;
        }
    
        /// <include file='doc\SessionEndingEventArgs.uex' path='docs/doc[@for="SessionEndingEventArgs.Cancel"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether to cancel the user request to end the session.</para>
        /// </devdoc>
        public bool Cancel {
            get {
                return cancel;
            }
            set {
                cancel = value;
            }
        }
    
        /// <include file='doc\SessionEndingEventArgs.uex' path='docs/doc[@for="SessionEndingEventArgs.Reason"]/*' />
        /// <devdoc>
        ///    <para>Gets how the session is ending.</para>
        /// </devdoc>
        public SessionEndReasons Reason {
            get {
                return reason;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\win32\sessionendingeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="SessionEndingEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.Win32 {
    using System.Diagnostics;

    using System;

    /// <include file='doc\SessionEndingEventHandler.uex' path='docs/doc[@for="SessionEndingEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see cref='Microsoft.Win32.SystemEvents.SessionEnding'/> event.</para>
    /// </devdoc>
    public delegate void SessionEndingEventHandler(object sender, SessionEndingEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\win32\sessionendedeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="SessionEndedEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.Win32 {
    using System.Diagnostics;
    
    using System;
    
    /// <include file='doc\SessionEndedEventArgs.uex' path='docs/doc[@for="SessionEndedEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see cref='Microsoft.Win32.SystemEvents.SessionEnded'/> event.</para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class SessionEndedEventArgs : EventArgs {
    
        private readonly SessionEndReasons reason;
    
        /// <include file='doc\SessionEndedEventArgs.uex' path='docs/doc[@for="SessionEndedEventArgs.SessionEndedEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='Microsoft.Win32.SessionEndedEventArgs'/> class.</para>
        /// </devdoc>
        public SessionEndedEventArgs(SessionEndReasons reason) {
            this.reason = reason;
        }
    
        /// <include file='doc\SessionEndedEventArgs.uex' path='docs/doc[@for="SessionEndedEventArgs.Reason"]/*' />
        /// <devdoc>
        ///    <para>Gets how the session ended.</para>
        /// </devdoc>
        public SessionEndReasons Reason {
            get {
                return reason;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\win32\timerelapsedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="TimerElapsedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.Win32 {
    using System.Diagnostics;

    using System;

    /// <include file='doc\TimerElapsedEventHandler.uex' path='docs/doc[@for="TimerElapsedEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see cref='Microsoft.Win32.SystemEvents.TimerElapsed'/> event.</para>
    /// </devdoc>
    public delegate void TimerElapsedEventHandler(object sender, TimerElapsedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\csharp\csharpcodeprovider.cs ===
//------------------------------------------------------------------------------
// <copyright file="CSharpCodeProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.CSharp {

    using System.Diagnostics;
    using System;
    using System.IO;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.Reflection;
    using System.CodeDom;
    using System.CodeDom.Compiler;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Globalization;
    using System.Security.Permissions;

    /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeProvider"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public class CSharpCodeProvider: CodeDomProvider {
        private CSharpCodeGenerator generator = new CSharpCodeGenerator();

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeProvider.FileExtension"]/*' />
        /// <devdoc>
        ///    <para>Retrieves the default extension to use when saving files using this code dom provider.</para>
        /// </devdoc>
        public override string FileExtension {
            get {
                return "cs";
            }
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeProvider.CreateGenerator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override ICodeGenerator CreateGenerator() {
            return (ICodeGenerator)generator;
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeProvider.CreateCompiler"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override ICodeCompiler CreateCompiler() {
            return (ICodeCompiler)generator;
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeProvider.GetConverter"]/*' />
        /// <devdoc>
        ///     This method allows a code dom provider implementation to provide a different type converter
        ///     for a given data type.  At design time, a designer may pass data types through this
        ///     method to see if the code dom provider wants to provide an additional converter.  
        ///     A typical way this would be used is if the language this code dom provider implements
        ///     does not support all of the values of the MemberAttributes enumeration, or if the language
        ///     uses different names (Protected instead of Family, for example).  The default 
        ///     implementation just calls TypeDescriptor.GetConverter for the given type.
        /// </devdoc>
        public override TypeConverter GetConverter(Type type) {
            if (type == typeof(MemberAttributes)) {
                return CSharpMemberAttributeConverter.Default;
            }
            
            return base.GetConverter(type);
        }
    }

    /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator"]/*' />
    /// <devdoc>
    ///    <para>
    ///       C# (C Sharp) Code Generator.
    ///    </para>
    /// </devdoc>
    internal class CSharpCodeGenerator : CodeCompiler {
        private const int MaxLineLength = 80;
        private const GeneratorSupport LanguageSupport = GeneratorSupport.ArraysOfArrays |
                                                         GeneratorSupport.EntryPointMethod |
                                                         GeneratorSupport.GotoStatements |
                                                         GeneratorSupport.MultidimensionalArrays |
                                                         GeneratorSupport.StaticConstructors |
                                                         GeneratorSupport.TryCatchStatements |
                                                         GeneratorSupport.ReturnTypeAttributes |
                                                         GeneratorSupport.AssemblyAttributes |
                                                         GeneratorSupport.DeclareValueTypes |
                                                         GeneratorSupport.DeclareEnums | 
                                                         GeneratorSupport.DeclareEvents | 
                                                         GeneratorSupport.DeclareDelegates |
                                                         GeneratorSupport.DeclareInterfaces |
                                                         GeneratorSupport.ParameterAttributes |
                                                         GeneratorSupport.ReferenceParameters |
                                                         GeneratorSupport.ChainedConstructorArguments |
                                                         GeneratorSupport.NestedTypes |
                                                         GeneratorSupport.MultipleInterfaceMembers |
                                                         GeneratorSupport.PublicStaticMembers |
                                                         GeneratorSupport.ComplexExpressions |
                                                         GeneratorSupport.Win32Resources;
        private static Regex outputReg;

        private static readonly string[][] keywords = new string[][] {
            null,           // 1 character
            new string[] {  // 2 characters
                "as",
                "do",
                "if",
                "in",
                "is",
            },
            new string[] {  // 3 characters
                "for",
                "int",
                "new",
                "out",
                "ref",
                "try",
            },
            new string[] {  // 4 characters
                "base",
                "bool",
                "byte",
                "case",
                "char",
                "else",
                "enum",
                "goto",
                "lock",
                "long",
                "null",
                "this",
                "true",
                "uint",
                "void",
            },
            new string[] {  // 5 characters
                "break",
                "catch",
                "class",
                "const",
                "event",
                "false",
                "fixed",
                "float",
                "sbyte",
                "short",
                "throw",
                "ulong",
                "using",
                "while",
            },
            new string[] {  // 6 characters
                "double",
                "extern",
                "object",
                "params",
                "public",
                "return",
                "sealed",
                "sizeof",
                "static",
                "string",
                "struct",
                "switch",
                "typeof",
                "unsafe",
                "ushort",
            },
            new string[] {  // 7 characters
                "checked",
                "decimal",
                "default",
                "finally",
                "foreach",
                "private",
                "virtual",
            },
            new string[] {  // 8 characters
                "abstract",
                "continue",
                "delegate",
                "explicit",
                "implicit",
                "internal",
                "operator",
                "override",
                "readonly",
                "volatile",
            },
            new string[] {  // 9 characters
                "__arglist",
                "__makeref",
                "__reftype",
                "interface",
                "namespace",
                "protected",
                "unchecked",
            },
            new string[] {  // 10 characters
                "__refvalue",
                "stackalloc",
            },
        };

#if DEBUG
        static CSharpCodeGenerator() {
            FixedStringLookup.VerifyLookupTable(keywords, false);

            // Sanity check: try some values;
            Debug.Assert(IsKeyword("for"));
            Debug.Assert(!IsKeyword("foR"));
            Debug.Assert(IsKeyword("operator"));
            Debug.Assert(!IsKeyword("blah"));
        }
#endif

        private bool forLoopHack = false;

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.FileExtension"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the file extension to use for source files.
        ///    </para>
        /// </devdoc>
        protected override string FileExtension { get { return ".cs"; } }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.CompilerName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or
        ///       sets the name of the compiler executable.
        ///    </para>
        /// </devdoc>
        protected override string CompilerName { get { return "csc.exe"; } }
        
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.NullToken"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the token used to represent <see langword='null'/>.
        ///    </para>
        /// </devdoc>
        protected override string NullToken {
            get {
                return "null";
            }
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.QuoteSnippetStringCStyle"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides conversion to C-style formatting with escape codes.
        ///    </para>
        /// </devdoc>
        protected string QuoteSnippetStringCStyle(string value) {
            StringBuilder b = new StringBuilder(value.Length+5);

            b.Append("\"");

            for (int i=0; i<value.Length; i++) {
                switch (value[i]) {
                    case '\r':
                        b.Append("\\r");
                        break;
                    case '\t':
                        b.Append("\\t");
                        break;
                    case '\"':
                        b.Append("\\\"");
                        break;
                    case '\'':
                        b.Append("\\\'");
                        break;
                    case '\\':
                        b.Append("\\\\");
                        break;
                    case '\0':
                        b.Append("\\0");
                        break;
                    case '\n':
                        b.Append("\\n");
                        break;
                    case '\u2028':
                    case '\u2029':
                        AppendEscapedChar(b,value[i]);
	                    break;

                    default:
                        b.Append(value[i]);
                        break;
                }

                if (i > 0 && i % MaxLineLength == 0) {
                    b.Append("\" +\r\n\"");
                }
            }

            b.Append("\"");

            return b.ToString();
        }

        private string QuoteSnippetStringVerbatimStyle(string value) {
            StringBuilder b = new StringBuilder(value.Length+5);

            b.Append("@\"");

            for (int i=0; i<value.Length; i++) {
                if (value[i] == '\"')
                    b.Append("\"\"");
                else
                    b.Append(value[i]);
            }

            b.Append("\"");

            return b.ToString();
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.QuoteSnippetString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides conversion to formatting with escape codes.
        ///    </para>
        /// </devdoc>
        protected override string QuoteSnippetString(string value) {
            // If the string is short, use C style quoting (e.g "\r\n")
            // Also do it if it is too long to fit in one line
            if (value.Length < 256 || value.Length > 1500)
                return QuoteSnippetStringCStyle(value);

            // Otherwise, use 'verbatim' style quoting (e.g. @"foo")
            return QuoteSnippetStringVerbatimStyle(value);
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.ProcessCompilerOutputLine"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Processes the <see cref='System.CodeDom.Compiler.CompilerResults'/> returned from compilation.
        ///    </para>
        /// </devdoc>
        protected override void ProcessCompilerOutputLine(CompilerResults results, string line) {
            if (outputReg == null)
                 outputReg = new Regex(@"(^([^(]+)(\(([0-9]+),([0-9]+)\))?: )?(error|warning) ([A-Z]+[0-9]+): (.*)");
            
            Match m = outputReg.Match(line);
            if (m.Success) {
                CompilerError ce = new CompilerError();
                // The second element is the optional section if the error can be traced to a file.
                // Without it, the file name is meaningless.
                if (m.Groups[3].Success) {
                    ce.FileName = m.Groups[2].Value;
                    ce.Line = int.Parse(m.Groups[4].Value);
                    ce.Column = int.Parse(m.Groups[5].Value);
                }
                if (string.Compare(m.Groups[6].Value, "warning", true, CultureInfo.InvariantCulture) == 0) {
                    ce.IsWarning = true;
                }
                ce.ErrorNumber = m.Groups[7].Value;
                ce.ErrorText = m.Groups[8].Value;

                results.Errors.Add(ce);
            }
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.CmdArgsFromParameters"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the command arguments from the specified <see cref='System.CodeDom.Compiler.CompilerParameters'/>.
        ///    </para>
        /// </devdoc>
        protected override string CmdArgsFromParameters(CompilerParameters options) {
            StringBuilder sb = new StringBuilder(128);
            if (options.GenerateExecutable) {
                sb.Append("/t:exe ");
                if (options.MainClass != null && options.MainClass.Length > 0) {
                    sb.Append("/main:");
                    sb.Append(options.MainClass);
                    sb.Append(" ");
                }
            }
            else {
                sb.Append("/t:library ");
            }

            // Get UTF8 output from the compiler (bug 54925)
            sb.Append("/utf8output ");

            foreach (string s in options.ReferencedAssemblies) {
				sb.Append("/R:");
				sb.Append("\"");
				sb.Append(s);
				sb.Append("\"");
				sb.Append(" ");
            }

            sb.Append("/out:");
            sb.Append("\"");
            sb.Append(options.OutputAssembly);
            sb.Append("\"");
            sb.Append(" ");

            if (options.IncludeDebugInformation) {
                sb.Append("/D:DEBUG ");
                sb.Append("/debug+ ");
                sb.Append("/optimize- ");
            }
            else {
                sb.Append("/debug- ");
                sb.Append("/optimize+ ");
            }

            if (options.Win32Resource != null) {
                sb.Append("/win32res:\"" + options.Win32Resource + "\" ");
            }

            if (options.TreatWarningsAsErrors) {
                sb.Append("/warnaserror ");
            }

            if (options.WarningLevel >= 0) {
                sb.Append("/w:" + options.WarningLevel + " ");
            }

            if (options.CompilerOptions != null) {
                sb.Append(options.CompilerOptions + " ");
            }

            return sb.ToString();
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GetResponseFileCmdArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected override string GetResponseFileCmdArgs(CompilerParameters options, string cmdArgs) {

            // Always specify the /noconfig flag (outside of the response file) (bug 65992)
            return "/noconfig " + base.GetResponseFileCmdArgs(options, cmdArgs);
        }

        protected override void OutputIdentifier(string ident) {
            Output.Write(CreateEscapedIdentifier(ident));
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.OutputType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sets the output type.
        ///    </para>
        /// </devdoc>
        protected override void OutputType(CodeTypeReference typeRef) {
            Output.Write(GetTypeOutput(typeRef));
        }



        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateArrayCreateExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for
        ///       the specified CodeDom based array creation expression representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateArrayCreateExpression(CodeArrayCreateExpression e) {
            Output.Write("new ");

            CodeExpressionCollection init = e.Initializers;
            if (init.Count > 0) {
                OutputType(e.CreateType);
                if (e.CreateType.ArrayRank == 0) {
                    // HACK: unfortunately, many clients are already calling this without array
                    // types. This will allow new clients to correctly use the array type and
                    // not break existing clients. For VNext, stop doing this.
                    Output.Write("[]");
                }
                Output.WriteLine(" {");
                Indent++;
                // Use fNewlineBetweenItems to fix bug 33100
                OutputExpressionList(init, true /*fNewlineBetweenItems*/);
                Indent--;
                Output.Write("}");
            }
            else {
                Output.Write(GetBaseTypeOutput(e.CreateType.BaseType));
                Output.Write("[");
                if (e.SizeExpression != null) {
                    GenerateExpression(e.SizeExpression);
                }
                else {
                    Output.Write(e.Size);
                }
                Output.Write("]");
            }
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateBaseReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates
        ///       code for the specified CodeDom based base reference expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateBaseReferenceExpression(CodeBaseReferenceExpression e) {
            Output.Write("base");
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateCastExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based cast expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateCastExpression(CodeCastExpression e) {
            Output.Write("((");
            OutputType(e.TargetType);
            Output.Write(")(");
            GenerateExpression(e.Expression);
            Output.Write("))");
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateDelegateCreateExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based delegate creation
        ///       expression representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateDelegateCreateExpression(CodeDelegateCreateExpression e) {
            Output.Write("new ");
            OutputType(e.DelegateType);
            Output.Write("(");
            GenerateExpression(e.TargetObject);
            Output.Write(".");
            OutputIdentifier(e.MethodName);
            Output.Write(")");
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateFieldReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based field reference expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateFieldReferenceExpression(CodeFieldReferenceExpression e) {
            if (e.TargetObject != null) {
                GenerateExpression(e.TargetObject);
                Output.Write(".");
            }
            OutputIdentifier(e.FieldName);
        }

        protected override void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression e) {
            OutputIdentifier(e.ParameterName);
        }

        protected override void GenerateVariableReferenceExpression(CodeVariableReferenceExpression e) {
            OutputIdentifier(e.VariableName);
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateIndexerExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based indexer expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateIndexerExpression(CodeIndexerExpression e) {
            GenerateExpression(e.TargetObject);
            Output.Write("[");
            bool first = true;
            foreach(CodeExpression exp in e.Indices) {            
                if (first) {
                    first = false;
                }
                else {
                    Output.Write(", ");
                }
                GenerateExpression(exp);
            }
            Output.Write("]");

        }

        protected override void GenerateArrayIndexerExpression(CodeArrayIndexerExpression e) {
            GenerateExpression(e.TargetObject);
            Output.Write("[");
            bool first = true;
            foreach(CodeExpression exp in e.Indices) {            
                if (first) {
                    first = false;
                }
                else {
                    Output.Write(", ");
                }
                GenerateExpression(exp);
            }
            Output.Write("]");

        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateSnippetExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based snippet expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateSnippetExpression(CodeSnippetExpression e) {
            Output.Write(e.Value);
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateMethodInvokeExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based method invoke expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateMethodInvokeExpression(CodeMethodInvokeExpression e) {
            GenerateMethodReferenceExpression(e.Method);
            Output.Write("(");
            OutputExpressionList(e.Parameters);
            Output.Write(")");
        }

        protected override void GenerateMethodReferenceExpression(CodeMethodReferenceExpression e) {
            if (e.TargetObject != null) {
                if (e.TargetObject is CodeBinaryOperatorExpression) {
                    Output.Write("(");
                    GenerateExpression(e.TargetObject);
                    Output.Write(")");
                }
                else {
                    GenerateExpression(e.TargetObject);
                }
                Output.Write(".");
            }
            OutputIdentifier(e.MethodName);
        }

        protected override void GenerateEventReferenceExpression(CodeEventReferenceExpression e) {
            if (e.TargetObject != null) {
                GenerateExpression(e.TargetObject);
                Output.Write(".");
            }
            OutputIdentifier(e.EventName);
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateDelegateInvokeExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based delegate invoke
        ///       expression representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression e) {
            if (e.TargetObject != null) {
                GenerateExpression(e.TargetObject);
            }
            Output.Write("(");
            OutputExpressionList(e.Parameters);
            Output.Write(")");
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateObjectCreateExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based object creation expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateObjectCreateExpression(CodeObjectCreateExpression e) {
            Output.Write("new ");
            OutputType(e.CreateType);
            Output.Write("(");
            OutputExpressionList(e.Parameters);
            Output.Write(")");
        }
        
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GeneratePrimitiveExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based primitive expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GeneratePrimitiveExpression(CodePrimitiveExpression e) {
            if (e.Value is char) {
                GeneratePrimitiveChar((char)e.Value);
            }
            else {
                base.GeneratePrimitiveExpression(e);
            }
        }

        private void GeneratePrimitiveChar(char c) {
            Output.Write('\'');
            switch (c) {
                case '\r':
                    Output.Write("\\r");
                    break;
                case '\t':
                    Output.Write("\\t");
                    break;
                case '\"':
                    Output.Write("\\\"");
                    break;
                case '\'':
                    Output.Write("\\\'");
                    break;
                case '\\':
                    Output.Write("\\\\");
                    break;
                case '\0':
                    Output.Write("\\0");
                    break;
                case '\n':
                    Output.Write("\\n");
                    break;
                case '\u2028':
                case '\u2029':
	                AppendEscapedChar(null,c);
	                break;
                
                default:
	                Output.Write(c);
                    break;
            }
            Output.Write('\'');
         }

        private void AppendEscapedChar(StringBuilder b,char value) {
            if (b == null) {
                Output.Write("\\u");
                Output.Write(((int)value).ToString(CultureInfo.InvariantCulture));
            } else {
                b.Append("\\u");
                b.Append(((int)value).ToString(CultureInfo.InvariantCulture));
            }
        }
       
        protected override void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e) {
            Output.Write("value");
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateThisReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based this reference expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateThisReferenceExpression(CodeThisReferenceExpression e) {
            Output.Write("this");
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateExpressionStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based method invoke statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateExpressionStatement(CodeExpressionStatement e) {
            GenerateExpression(e.Expression);
            if (!forLoopHack) {
                Output.WriteLine(";");
            }
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateIterationStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based for loop statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateIterationStatement(CodeIterationStatement e) {
            forLoopHack = true;
            Output.Write("for (");
            GenerateStatement(e.InitStatement);
            Output.Write("; ");
            GenerateExpression(e.TestExpression);
            Output.Write("; ");
            GenerateStatement(e.IncrementStatement);
            Output.Write(")");
            OutputStartingBrace();
            forLoopHack = false;
            Indent++;
            GenerateStatements(e.Statements);
            Indent--;
            Output.WriteLine("}");
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateThrowExceptionStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based throw exception statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateThrowExceptionStatement(CodeThrowExceptionStatement e) {
            Output.Write("throw");
            if (e.ToThrow != null) {
                Output.Write(" ");
                GenerateExpression(e.ToThrow);
            }
            Output.WriteLine(";");
        }

        protected override void GenerateComment(CodeComment e) {
            String text = ConvertToCommentEscapeCodes(e.Text);
            if (e.DocComment) {
                Output.Write("/// ");
            } else {
                Output.Write("// ");
            }
            Output.WriteLine(text);
        }

        private static string ConvertToCommentEscapeCodes(string value) {
            StringBuilder b = new StringBuilder(value.Length);

            for (int i=0; i<value.Length; i++) {
                switch (value[i]) {
                    case '\r':
                        if (i < value.Length - 1 && value[i+1] == '\n') {
                            b.Append("\r\n//");
                            i++;
                        }
                        else {
                            b.Append("\r//");
                        }
                        break;
                    case '\n':
                        b.Append("\n//");
                        break;
                    case '\u2028':
                        b.Append("\u2028//");
                        break;
                    case '\u2029':
                        b.Append("\u2029//");
                        break;
                    // Suppress null from being emitted since you get a compiler error
                    case '\u0000': 
                        break;
                    default:
                        b.Append(value[i]);
                        break;
                }
            }

            return b.ToString();
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateMethodReturnStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based method return statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateMethodReturnStatement(CodeMethodReturnStatement e) {
            Output.Write("return");
            if (e.Expression != null) {
                Output.Write(" ");
                GenerateExpression(e.Expression);
            }
            Output.WriteLine(";");
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateConditionStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based if statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateConditionStatement(CodeConditionStatement e) {
            Output.Write("if (");
            GenerateExpression(e.Condition);
            Output.Write(")");
            OutputStartingBrace();            
            Indent++;
            GenerateStatements(e.TrueStatements);
            Indent--;

            CodeStatementCollection falseStatemetns = e.FalseStatements;
            if (falseStatemetns.Count > 0) {
                Output.Write("}");
                if (Options.ElseOnClosing) {
                    Output.Write(" ");
                } 
                else {
                    Output.WriteLine("");
                }
                Output.Write("else");
                OutputStartingBrace();
                Indent++;
                GenerateStatements(e.FalseStatements);
                Indent--;
            }
            Output.WriteLine("}");
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateTryCatchFinallyStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based try catch finally
        ///       statement representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e) {
            Output.Write("try");
            OutputStartingBrace();
            Indent++;
            GenerateStatements(e.TryStatements);
            Indent--;
            CodeCatchClauseCollection catches = e.CatchClauses;
            if (catches.Count > 0) {
                IEnumerator en = catches.GetEnumerator();
                while (en.MoveNext()) {
                    Output.Write("}");
                    if (Options.ElseOnClosing) {
                        Output.Write(" ");
                    } 
                    else {
                        Output.WriteLine("");
                    }
                    CodeCatchClause current = (CodeCatchClause)en.Current;
                    Output.Write("catch (");
                    OutputType(current.CatchExceptionType);
                    Output.Write(" ");
                    OutputIdentifier(current.LocalName);
                    Output.Write(")");
                    OutputStartingBrace();
                    Indent++;
                    GenerateStatements(current.Statements);
                    Indent--;
                }
            }

            CodeStatementCollection finallyStatements = e.FinallyStatements;
            if (finallyStatements.Count > 0) {
                Output.Write("}");
                if (Options.ElseOnClosing) {
                    Output.Write(" ");
                } 
                else {
                    Output.WriteLine("");
                }
                Output.Write("finally");
                OutputStartingBrace();
                Indent++;
                GenerateStatements(finallyStatements);
                Indent--;
            }
            Output.WriteLine("}");
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateAssignStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based assignment statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateAssignStatement(CodeAssignStatement e) {
            GenerateExpression(e.Left);
            Output.Write(" = ");
            GenerateExpression(e.Right);
            if (!forLoopHack) {
                Output.WriteLine(";");
            }
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateAttachEventStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based attach event statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateAttachEventStatement(CodeAttachEventStatement e) {
            GenerateEventReferenceExpression(e.Event);
            Output.Write(" += ");
            GenerateExpression(e.Listener);
            Output.WriteLine(";");
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateRemoveEventStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based detach event statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateRemoveEventStatement(CodeRemoveEventStatement e) {
            GenerateEventReferenceExpression(e.Event);
            Output.Write(" -= ");
            GenerateExpression(e.Listener);
            Output.WriteLine(";");
        }

        protected override void GenerateSnippetStatement(CodeSnippetStatement e) {
            Output.WriteLine(e.Value);
        }

        protected override void GenerateGotoStatement(CodeGotoStatement e) {
            Output.Write("goto ");
            Output.Write(e.Label);
            Output.WriteLine(";");
        }

        protected override void GenerateLabeledStatement(CodeLabeledStatement e) {
            Indent--;
            Output.Write(e.Label);
            Output.WriteLine(":");
            Indent++;
            if (e.Statement != null) {
                GenerateStatement(e.Statement);
            }
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateVariableDeclarationStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based variable declaration
        ///       statement representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement e) {
            OutputTypeNamePair(e.Type, e.Name);
            if (e.InitExpression != null) {
                Output.Write(" = ");
                GenerateExpression(e.InitExpression);
            }
            if (!forLoopHack) {
                Output.WriteLine(";");
            }
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateLinePragmaStart"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based line pragma start
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateLinePragmaStart(CodeLinePragma e) {
            Output.WriteLine("");
            Output.Write("#line ");
            Output.Write(e.LineNumber);
            Output.Write(" \"");
            Output.Write(e.FileName);
            Output.Write("\"");
            Output.WriteLine("");
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateLinePragmaEnd"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based line pragma end
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateLinePragmaEnd(CodeLinePragma e) {
            Output.WriteLine();
            Output.WriteLine("#line default");
            Output.WriteLine("#line hidden");
        }

        protected override void GenerateEvent(CodeMemberEvent e, CodeTypeDeclaration c) {
            if (IsCurrentDelegate || IsCurrentEnum) return;

            if (e.CustomAttributes.Count > 0) {
                GenerateAttributes(e.CustomAttributes);
            }

            if (e.PrivateImplementationType == null) {
                OutputMemberAccessModifier(e.Attributes);
            }
            Output.Write("event ");
            string name = e.Name;
            if (e.PrivateImplementationType != null) {
                name = e.PrivateImplementationType.BaseType + "." + name;
            }
            OutputTypeNamePair(e.Type, name);
            Output.WriteLine(";");
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateField"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom
        ///       based field representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateField(CodeMemberField e) {
            if (IsCurrentDelegate || IsCurrentInterface) return;

            if (IsCurrentEnum) {
                if (e.CustomAttributes.Count > 0) {
                    GenerateAttributes(e.CustomAttributes);
                }
                OutputIdentifier(e.Name);
                if (e.InitExpression != null) {
                    Output.Write(" = ");
                    GenerateExpression(e.InitExpression);
                }
                Output.WriteLine(",");
            }
            else {
                if (e.CustomAttributes.Count > 0) {
                    GenerateAttributes(e.CustomAttributes);
                }

                OutputMemberAccessModifier(e.Attributes);
                OutputVTableModifier(e.Attributes);
                OutputFieldScopeModifier(e.Attributes);
                OutputTypeNamePair(e.Type, e.Name);
                if (e.InitExpression != null) {
                    Output.Write(" = ");
                    GenerateExpression(e.InitExpression);
                }
                Output.WriteLine(";");
            }
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateSnippetMember"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based snippet class member
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateSnippetMember(CodeSnippetTypeMember e) {
            Output.Write(e.Text);
        }

        protected override void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e) {
            if (e.CustomAttributes.Count > 0) {
                // Parameter attributes should be in-line for readability
                GenerateAttributes(e.CustomAttributes, null, true);
            }

            OutputDirection(e.Direction);
            OutputTypeNamePair(e.Type, e.Name);
        }

        protected override void GenerateEntryPointMethod(CodeEntryPointMethod e, CodeTypeDeclaration c) {

            Output.Write("public static void Main()");
            OutputStartingBrace();
            Indent++;

            GenerateStatements(e.Statements);

            Indent--;
            Output.WriteLine("}");
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateMethod"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based member method
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateMethod(CodeMemberMethod e, CodeTypeDeclaration c) {
            if (!(IsCurrentClass || IsCurrentStruct || IsCurrentInterface)) return;

            if (e.CustomAttributes.Count > 0) {
                GenerateAttributes(e.CustomAttributes);
            }
            if (e.ReturnTypeCustomAttributes.Count > 0) {
                GenerateAttributes(e.ReturnTypeCustomAttributes, "return: ");
            }

            if (!IsCurrentInterface) {
                if (e.PrivateImplementationType == null) {
                    OutputMemberAccessModifier(e.Attributes);
                    OutputVTableModifier(e.Attributes);
                    OutputMemberScopeModifier(e.Attributes);
                }
            }
            else {
                // interfaces still need "new"
                OutputVTableModifier(e.Attributes);
            }
            OutputType(e.ReturnType);
            Output.Write(" ");
            if (e.PrivateImplementationType != null) {
                Output.Write(e.PrivateImplementationType.BaseType);
                Output.Write(".");
            }
            OutputIdentifier(e.Name);
            Output.Write("(");
            OutputParameters(e.Parameters);
            Output.Write(")");
            
            if (!IsCurrentInterface 
                && (e.Attributes & MemberAttributes.ScopeMask) != MemberAttributes.Abstract) {

                OutputStartingBrace();
                Indent++;

                GenerateStatements(e.Statements);

                Indent--;
                Output.WriteLine("}");
            }
            else {
                Output.WriteLine(";");
            }
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateProperty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based property representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateProperty(CodeMemberProperty e, CodeTypeDeclaration c) {
            if (!(IsCurrentClass || IsCurrentStruct || IsCurrentInterface)) return;

            if (e.CustomAttributes.Count > 0) {
                GenerateAttributes(e.CustomAttributes);
            }

            if (!IsCurrentInterface) {
                if (e.PrivateImplementationType == null) {
                    OutputMemberAccessModifier(e.Attributes);
                    OutputVTableModifier(e.Attributes);
                    OutputMemberScopeModifier(e.Attributes);
                }
            }
            else {
                OutputVTableModifier(e.Attributes);
            }
            OutputType(e.Type);
            Output.Write(" ");

            if (e.PrivateImplementationType != null && !IsCurrentInterface) {
                Output.Write(e.PrivateImplementationType.BaseType);
                Output.Write(".");
            }

            if (e.Parameters.Count > 0 && String.Compare(e.Name, "Item", true, CultureInfo.InvariantCulture) == 0) {
                Output.Write("this[");
                OutputParameters(e.Parameters);
                Output.Write("]");
            }
            else {
                OutputIdentifier(e.Name);
            }

            OutputStartingBrace();
            Indent++;

            if (e.HasGet) {
                if (IsCurrentInterface || (e.Attributes & MemberAttributes.ScopeMask) == MemberAttributes.Abstract) {
                    Output.WriteLine("get;");
                }
                else {
                    Output.Write("get");
                    OutputStartingBrace();
                    Indent++;
                    GenerateStatements(e.GetStatements);
                    Indent--;
                    Output.WriteLine("}");
                }
            }
            if (e.HasSet) {
                if (IsCurrentInterface || (e.Attributes & MemberAttributes.ScopeMask) == MemberAttributes.Abstract) {
                    Output.WriteLine("set;");
                }
                else {
                    Output.Write("set");
                    OutputStartingBrace();
                    Indent++;
                    GenerateStatements(e.SetStatements);
                    Indent--;
                    Output.WriteLine("}");
                }
            }

            Indent--;
            Output.WriteLine("}");
        }
        
        protected override void GenerateSingleFloatValue(Single s) {
            Output.Write(s.ToString(CultureInfo.InvariantCulture));
            Output.Write('F');
        }

        protected override void GenerateDecimalValue(Decimal d) {
            Output.Write(d.ToString(CultureInfo.InvariantCulture));
            Output.Write('m');
        }

        private void OutputVTableModifier(MemberAttributes attributes) {
            switch (attributes & MemberAttributes.VTableMask) {
                case MemberAttributes.New:
                    Output.Write("new ");
                    break;
            }
        }

        protected override void OutputMemberScopeModifier(MemberAttributes attributes) {
            switch (attributes & MemberAttributes.ScopeMask) {
                case MemberAttributes.Abstract:
                    Output.Write("abstract ");
                    break;
                case MemberAttributes.Final:
                    Output.Write("");
                    break;
                case MemberAttributes.Static:
                    Output.Write("static ");
                    break;
                case MemberAttributes.Override:
                    Output.Write("override ");
                    break;
                default:
                    switch (attributes & MemberAttributes.AccessMask) {
                        case MemberAttributes.Family:
                        case MemberAttributes.Public:
                            Output.Write("virtual ");
                            break;
                        default:
                            // nothing;
                            break;
                    }
                    break;
            }
        }

        protected override void OutputFieldScopeModifier(MemberAttributes attributes) {
            switch (attributes & MemberAttributes.ScopeMask) {
                case MemberAttributes.Final:
                    break;
                case MemberAttributes.Static:
                    Output.Write("static ");
                    break;
                case MemberAttributes.Const:
                    Output.Write("const ");
                    break;
                default:
                    break;
            }
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GeneratePropertyReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based property reference
        ///       expression representation.
        ///    </para>
        /// </devdoc>
        protected override void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression e) {

            if (e.TargetObject != null) {
                GenerateExpression(e.TargetObject);
                Output.Write(".");
            }
            OutputIdentifier(e.PropertyName);
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateConstructor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based constructor
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateConstructor(CodeConstructor e, CodeTypeDeclaration c) {
            if (!(IsCurrentClass || IsCurrentStruct)) return;

            if (e.CustomAttributes.Count > 0) {
                GenerateAttributes(e.CustomAttributes);
            }

            OutputMemberAccessModifier(e.Attributes);
            OutputIdentifier(CurrentTypeName);
            Output.Write("(");
            OutputParameters(e.Parameters);
            Output.Write(")");

            CodeExpressionCollection baseArgs = e.BaseConstructorArgs;
            CodeExpressionCollection thisArgs = e.ChainedConstructorArgs;

            if (baseArgs.Count > 0) {
                Output.WriteLine(" : ");
                Indent++;
                Indent++;
                Output.Write("base(");
                OutputExpressionList(baseArgs);
                Output.Write(")");
                Indent--;
                Indent--;
            }

            if (thisArgs.Count > 0) {
                Output.WriteLine(" : ");
                Indent++;
                Indent++;
                Output.Write("this(");
                OutputExpressionList(thisArgs);
                Output.Write(")");
                Indent--;
                Indent--;
            }

            OutputStartingBrace();
            Indent++;
            GenerateStatements(e.Statements);
            Indent--;
            Output.WriteLine("}");
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateTypeConstructor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based class constructor
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateTypeConstructor(CodeTypeConstructor e) {
            if (!(IsCurrentClass || IsCurrentStruct)) return;

            Output.Write("static ");
            Output.Write(CurrentTypeName);
            Output.Write("()");
            OutputStartingBrace();
            Indent++;
            GenerateStatements(e.Statements);
            Indent--;
            Output.WriteLine("}");
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateTypeStart"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based class start
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateTypeStart(CodeTypeDeclaration e) {
            if (e.CustomAttributes.Count > 0) {
                GenerateAttributes(e.CustomAttributes);
            }

            if (IsCurrentDelegate) {
                switch (e.TypeAttributes & TypeAttributes.VisibilityMask) {
                    case TypeAttributes.Public:
                        Output.Write("public ");
                        break;
                    case TypeAttributes.NotPublic:
                    default:
                        break;
                }

                CodeTypeDelegate del = (CodeTypeDelegate)e;
                Output.Write("delegate ");
                OutputType(del.ReturnType);
                Output.Write(" ");
                OutputIdentifier(e.Name);
                Output.Write("(");
                OutputParameters(del.Parameters);
                Output.WriteLine(");");
            } else {
                OutputTypeAttributes(e);                                
                OutputIdentifier(e.Name);             

                bool first = true;
                foreach (CodeTypeReference typeRef in e.BaseTypes) {
                    if (first) {
                        Output.Write(" : ");
                        first = false;
                    }
                    else {
                        Output.Write(", ");
                    }                 
                    OutputType(typeRef);
                }
                OutputStartingBrace();
                Indent++;                
            }
        }

        private void OutputTypeAttributes(CodeTypeDeclaration e) {
            TypeAttributes attributes = e.TypeAttributes;
            switch(attributes & TypeAttributes.VisibilityMask) {
                case TypeAttributes.Public:                  
                case TypeAttributes.NestedPublic:                    
                    Output.Write("public ");
                    break;
                case TypeAttributes.NestedPrivate:
                    Output.Write("private ");
                    break;
            }
            
            if (e.IsStruct) {
                Output.Write("struct ");
            }
            else if (e.IsEnum) {
                Output.Write("enum ");
            }     
            else {            
                switch (attributes & TypeAttributes.ClassSemanticsMask) {
                    case TypeAttributes.Class:
                        if ((attributes & TypeAttributes.Sealed) == TypeAttributes.Sealed) {
                            Output.Write("sealed ");
                        }
                        if ((attributes & TypeAttributes.Abstract) == TypeAttributes.Abstract)  {
                            Output.Write("abstract ");
                        }
                        Output.Write("class ");
                        break;                
                    case TypeAttributes.Interface:
                        Output.Write("interface ");
                        break;
                }     
            }   
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateTypeEnd"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based class end representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateTypeEnd(CodeTypeDeclaration e) {
            if (!IsCurrentDelegate) {
                Indent--;
                Output.WriteLine("}");
            }
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateNamespaceStart"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based namespace start
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateNamespaceStart(CodeNamespace e) {

            if (e.Name != null && e.Name.Length > 0) {
                Output.Write("namespace ");
                OutputIdentifier(e.Name);
                OutputStartingBrace();
                Indent++;
            }
        }
        
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateCompileUnitStart"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based compile unit start
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateCompileUnitStart(CodeCompileUnit e) {
            Output.WriteLine("//------------------------------------------------------------------------------");
            Output.WriteLine("// <autogenerated>");
            Output.WriteLine("//     This code was generated by a tool.");
            Output.WriteLine("//     Runtime Version: " + System.Environment.Version.ToString());
            Output.WriteLine("//");
            Output.WriteLine("//     Changes to this file may cause incorrect behavior and will be lost if ");
            Output.WriteLine("//     the code is regenerated.");
            Output.WriteLine("// </autogenerated>");
            Output.WriteLine("//------------------------------------------------------------------------------");
            Output.WriteLine("");

            // in C# the best place to put these is at the top level.
            if (e.AssemblyCustomAttributes.Count > 0) {
                GenerateAttributes(e.AssemblyCustomAttributes, "assembly: ");
                Output.WriteLine("");
            }
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateNamespaceEnd"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based namespace end
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateNamespaceEnd(CodeNamespace e) {
            if (e.Name != null && e.Name.Length > 0) {
                Indent--;
                Output.WriteLine("}");
            }
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateNamespaceImport"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based namespace import
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateNamespaceImport(CodeNamespaceImport e) {
            Output.Write("using ");
            OutputIdentifier(e.Namespace);
            Output.WriteLine(";");
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateAttributeDeclarationsStart"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based attribute block start
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes) {
            Output.Write("[");
        }
        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.GenerateAttributeDeclarationsEnd"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based attribute block end
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes) {
            Output.Write("]");
        }

        private void GenerateAttributes(CodeAttributeDeclarationCollection attributes) {
            GenerateAttributes(attributes, null, false);
        }

        private void GenerateAttributes(CodeAttributeDeclarationCollection attributes, string prefix) {
            GenerateAttributes(attributes, prefix, false);            
        }
    
        private void GenerateAttributes(CodeAttributeDeclarationCollection attributes, string prefix, bool inLine) {
            if (attributes.Count == 0) return;
            IEnumerator en = attributes.GetEnumerator();
            while (en.MoveNext()) {
                GenerateAttributeDeclarationsStart(attributes);
                if (prefix != null) {
                    Output.Write(prefix);
                }

                CodeAttributeDeclaration current = (CodeAttributeDeclaration)en.Current;
                Output.Write(GetBaseTypeOutput(current.Name));
                Output.Write("(");

                bool firstArg = true;
                foreach (CodeAttributeArgument arg in current.Arguments) {
                    if (firstArg) {
                        firstArg = false;
                    }
                    else {
                        Output.Write(", ");
                    }

                    OutputAttributeArgument(arg);
                }

                Output.Write(")");
                GenerateAttributeDeclarationsEnd(attributes);
                if (inLine) {
                    Output.Write(" ");
                } 
                else {
                    Output.WriteLine();
                }
            }
        }

        static bool IsKeyword(string value) {
            return FixedStringLookup.Contains(keywords, value, false);
        }
        protected override bool Supports(GeneratorSupport support) {
            return ((support & LanguageSupport) == support);
        }

        /// <include file='doc\CSharpCodeProvider.uex' path='docs/doc[@for="CSharpCodeGenerator.IsValidIdentifier"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets whether the specified value is a valid identifier.
        ///    </para>
        /// </devdoc>
        protected override bool IsValidIdentifier(string value) {

            // identifiers must be 1 char or longer
            //
            if (value == null || value.Length == 0) {
                return false;
            }

            // identifiers cannot be a keyword, unless they are escaped with an '@'
            //
            if (value[0] != '@') {
                if (IsKeyword(value))
                    return false;
            }
            else  {
                value = value.Substring(1);
            }

            return CodeGenerator.IsValidLanguageIndependentIdentifier(value);
        }

        protected override string CreateValidIdentifier(string name) {
            if (IsKeyword(name)) {
                return "_" + name;
            }
            return name;
        }

        protected override string CreateEscapedIdentifier(string name) {
            if (IsKeyword(name)) {
                return "@" + name;
            }
            return name;
        }

        private string GetBaseTypeOutput(string baseType) {
            string s = CreateEscapedIdentifier(baseType);
            if (s.Length == 0) {
                s = "void";
            }
            else if (string.Compare(s, "System.Int16", true, CultureInfo.InvariantCulture) == 0) {
                s = "short";
            }
            else if (string.Compare(s, "System.Int32", true, CultureInfo.InvariantCulture) == 0) {
                s = "int";
            }
            else if (string.Compare(s, "System.Int64", true, CultureInfo.InvariantCulture) == 0) {
                s = "long";
            }
            else if (string.Compare(s, "System.String", true, CultureInfo.InvariantCulture) == 0) {
                s = "string";
            }
            else if (string.Compare(s, "System.Object", true, CultureInfo.InvariantCulture) == 0) {
                s = "object";
            }
            else if (string.Compare(s, "System.Boolean", true, CultureInfo.InvariantCulture) == 0) {
                s= "bool";
            }
            else if (string.Compare(s, "System.Void", true, CultureInfo.InvariantCulture) == 0) {
                s = "void";
            }
            else if (string.Compare(s, "System.Char", true, CultureInfo.InvariantCulture) == 0) {
                s = "char";
            }

            else {
                // replace + with . for nested classes.
                //
                s = s.Replace('+', '.');
            }
            return s;
        }


        protected override string GetTypeOutput(CodeTypeReference typeRef) {
            string s;
            if (typeRef.ArrayElementType != null) {
                // Recurse up
                s = GetTypeOutput(typeRef.ArrayElementType);
            }
            else {

                s = GetBaseTypeOutput(typeRef.BaseType);
            }
            // Now spit out the array postfix
            if (typeRef.ArrayRank > 0) {
                char [] results = new char [typeRef.ArrayRank + 1];
                results[0] = '[';
                results[typeRef.ArrayRank] = ']';
                for (int i = 1; i < typeRef.ArrayRank; i++) {
                    results[i] = ',';
                }
                s += new string(results);
            }               
            return s;
        }

        protected virtual void OutputStartingBrace() {
            if (Options.BracingStyle == "C") {
                Output.WriteLine("");
                Output.WriteLine("{");
            }
            else {
                Output.WriteLine(" {");
            }
        }

    }

    /// <devdoc>
    ///      This type converter provides common values for MemberAttributes
    /// </devdoc>
    internal class CSharpMemberAttributeConverter : TypeConverter {
    
        private static string[] names;
        private static object[] values;
        private static CSharpMemberAttributeConverter defaultConverter;
        
        private CSharpMemberAttributeConverter() {
            // no  need to create an instance; use Default
        }
        
        public static CSharpMemberAttributeConverter Default {
            get {
                if (defaultConverter == null) {
                    defaultConverter = new CSharpMemberAttributeConverter();
                }
                return defaultConverter;
            }
        }
    
        /// <devdoc>
        ///      Retrieves an array of names for attributes.
        /// </devdoc>
        private string[] Names {
            get {
                if (names == null) {
                    names = new string[] {
                        "Public",
                        "Protected",
                        "Protected Internal",
                        "Internal",
                        "Private"
                    };
                }
                
                return names;
            }
        }
        
        /// <devdoc>
        ///      Retrieves an array of values for attributes.
        /// </devdoc>
        private object[] Values {
            get {
                if (values == null) {
                    values = new object[] {
                        (object)MemberAttributes.Public,
                        (object)MemberAttributes.Family,
                        (object)MemberAttributes.FamilyOrAssembly,
                        (object)MemberAttributes.Assembly,
                        (object)MemberAttributes.Private
                    };
                }
                
                return values;
            }
        }

        /// <devdoc>
        ///      We override this because we can convert from string types.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            
            return base.CanConvertFrom(context, sourceType);
        }

        /// <devdoc>
        ///      Converts the given object to the converter's native type.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                string name = (string)value;
                string[] names = Names;
                for (int i = 0; i < names.Length; i++) {
                    if (names[i].Equals(name)) {
                        return Values[i];
                    }
                }
            }
            
            return MemberAttributes.Private;
        }

        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }
            
            if (destinationType == typeof(string)) {
                object[] modifiers = Values;
                for (int i = 0; i < modifiers.Length; i++) {
                    if (modifiers[i].Equals(value)) {
                        return Names[i];
                    }
                }
                
                return SR.GetString(SR.toStringUnknown);
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\DesignerExtenders.uex' path='docs/doc[@for="DesignerExtenders.ModifierConverter.GetStandardValuesExclusive"]/*' />
        /// <devdoc>
        ///      Determines if the list of standard values returned from
        ///      GetStandardValues is an exclusive list.  If the list
        ///      is exclusive, then no other values are valid, such as
        ///      in an enum data type.  If the list is not exclusive,
        ///      then there are other valid values besides the list of
        ///      standard values GetStandardValues provides.
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return true;
        }
        
        /// <include file='doc\DesignerExtenders.uex' path='docs/doc[@for="DesignerExtenders.ModifierConverter.GetStandardValuesSupported"]/*' />
        /// <devdoc>
        ///      Determines if this object supports a standard set of values
        ///      that can be picked from a list.
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
        
        /// <include file='doc\DesignerExtenders.uex' path='docs/doc[@for="DesignerExtenders.ModifierConverter.GetStandardValues"]/*' />
        /// <devdoc>
        ///      Retrieves a collection containing a set of standard values
        ///      for the data type this validator is designed for.  This
        ///      will return null if the data type does not support a
        ///      standard set of values.
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) { 
            return new StandardValuesCollection(Values);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\win32\timerelapsedevenargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="TimerElapsedEvenArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
namespace Microsoft.Win32 {
    using System.Diagnostics;    
    using System;
    using System.Runtime.InteropServices;
    
    /// <include file='doc\TimerElapsedEvenArgs.uex' path='docs/doc[@for="TimerElapsedEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see cref='Microsoft.Win32.SystemEvents.TimerElapsed'/> event.</para>
    /// </devdoc>
#if !CPB        // cpb 50004
    [ComVisible(false)]
#endif
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class TimerElapsedEventArgs : EventArgs {
        private readonly IntPtr timerId;
    
        /// <include file='doc\TimerElapsedEvenArgs.uex' path='docs/doc[@for="TimerElapsedEventArgs.TimerElapsedEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='Microsoft.Win32.TimerElapsedEventArgs'/> class.</para>
        /// </devdoc>
        public TimerElapsedEventArgs(IntPtr timerId) {
            this.timerId = timerId;
        }
        
        /// <include file='doc\TimerElapsedEvenArgs.uex' path='docs/doc[@for="TimerElapsedEventArgs.TimerId"]/*' />
        /// <devdoc>
        ///    <para>Gets the ID number for the timer.</para>
        /// </devdoc>
        public IntPtr TimerId {
            get {
                return this.timerId;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\win32\unsafenativemethods.cs ===
//------------------------------------------------------------------------------
// <copyright file="UnsafeNativeMethods.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.Win32 {
    using System.Runtime.InteropServices;
    using System.Threading;
    using System;
    using System.Security.Permissions;
    using System.Collections;
    using System.IO;
    using System.Text;

    [
    System.Runtime.InteropServices.ComVisible(false), 
    System.Security.SuppressUnmanagedCodeSecurityAttribute()
    ]
    internal class UnsafeNativeMethods {
        [DllImport(ExternDll.User32, ExactSpelling=true)]
        public static extern IntPtr GetProcessWindowStation();
        [DllImport(ExternDll.User32, SetLastError=true)]
        public static extern bool GetUserObjectInformation(HandleRef hObj, int nIndex, [MarshalAs(UnmanagedType.LPStruct)] NativeMethods.USEROBJECTFLAGS pvBuffer, int nLength, ref int lpnLengthNeeded);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GetModuleHandle(string modName);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetClassInfo(HandleRef hInst, string lpszClass, [In, Out] NativeMethods.WNDCLASS_I wc);
        
        [DllImport(ExternDll.User32,
#if WIN64
         EntryPoint="SetWindowLongPtr",
#endif
         CharSet=CharSet.Auto)
        ]
        public static extern IntPtr SetWindowLong(HandleRef hWnd, int nIndex, HandleRef dwNewLong);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern short RegisterClass(NativeMethods.WNDCLASS wc);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern short UnregisterClass(string lpClassName, HandleRef hInstance);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern IntPtr CreateWindowEx(int exStyle, string lpszClassName, string lpszWindowName, int style, int x, int y, int width, 
                                              int height, HandleRef hWndParent, HandleRef hMenu, HandleRef hInst, [MarshalAs(UnmanagedType.AsAny)] object pvParam);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr SendMessage(HandleRef hWnd, int msg, IntPtr wParam, IntPtr lParam);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool SetConsoleCtrlHandler(NativeMethods.ConHndlr handler, int add);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr DefWindowProc(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam);
        
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool DestroyWindow(HandleRef hWnd);
        
        [DllImport(ExternDll.User32, ExactSpelling=true, CharSet=CharSet.Auto)]
        public static extern int MsgWaitForMultipleObjects(int nCount, int pHandles, bool fWaitAll, int dwMilliseconds, int dwWakeMask);

        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int DispatchMessage([In] ref NativeMethods.MSG msg);
        
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool PeekMessage([In, Out] ref NativeMethods.MSG msg, HandleRef hwnd, int msgMin, int msgMax, int remove);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GetMessage([In, Out] ref NativeMethods.MSG msg, HandleRef hWnd, int uMsgFilterMin, int uMsgFilterMax);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr SetTimer(HandleRef hWnd, HandleRef nIDEvent, int uElapse, HandleRef lpTimerProc);

        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool KillTimer(HandleRef hwnd, HandleRef idEvent);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetTempPath(int bufferLen, System.Text.StringBuilder buffer);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetTempFileName(string lpPathName, string lpPrefixString, int uUnique, System.Text.StringBuilder lpTempFileName);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, BestFitMapping=false)]
        public static extern IntPtr CreateFile(string lpFileName,int dwDesiredAccess,int dwShareMode, NativeMethods.SECURITY_ATTRIBUTES lpSecurityAttributes, int dwCreationDisposition,int dwFlagsAndAttributes,HandleRef hTemplateFile);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GetStdHandle(int type);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true, BestFitMapping=false)]
        public extern static bool CreateProcess(string lpApplicationName, StringBuilder lpCommandLine, NativeMethods.SECURITY_ATTRIBUTES lpProcessAttributes, NativeMethods.SECURITY_ATTRIBUTES lpThreadAttributes, bool bInheritHandles, int dwCreationFlags, HandleRef lpEnvironment, string lpCurrentDirectory, NativeMethods.STARTUPINFO lpStartupInfo, NativeMethods.PROCESS_INFORMATION lpProcessInformation);
        
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public extern static bool GetExitCodeProcess(HandleRef hProcess, ref int lpExitCode);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool CloseHandle(HandleRef handle);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool TranslateMessage([In, Out] ref NativeMethods.MSG msg);
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true, BestFitMapping=false)]
        public extern static bool CreateProcessAsUser(HandleRef hToken, string lpApplicationName, string lpCommandLine, NativeMethods.SECURITY_ATTRIBUTES lpProcessAttributes, NativeMethods.SECURITY_ATTRIBUTES lpThreadAttributes, bool bInheritHandles, int dwCreationFlags, HandleRef lpEnvironment, string lpCurrentDirectory, NativeMethods.STARTUPINFO lpStartupInfo, NativeMethods.PROCESS_INFORMATION lpProcessInformation);
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public extern static bool DuplicateTokenEx(HandleRef hToken, int access, NativeMethods.SECURITY_ATTRIBUTES tokenAttributes, int impersonationLevel, int tokenType, ref IntPtr hNewToken);
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public extern static bool RevertToSelf();
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool OpenThreadToken(HandleRef hThread, int access, bool openAsSelf, ref IntPtr hToken);
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern bool SetThreadToken(HandleRef phThread, HandleRef hToken);
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
        public static extern IntPtr GetCurrentThread();
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Ansi)]
        public static extern IntPtr GetProcAddress(HandleRef hModule, string lpProcName);
        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int ReleaseDC(HandleRef hWnd, HandleRef hDC);

        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool PostMessage(HandleRef hwnd, int msg, IntPtr wparam, IntPtr lparam);

        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GetSystemMetrics(int nIndex);

        [DllImport(ExternDll.User32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GetDC(HandleRef hWnd);

        [DllImport(ExternDll.Gdi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr SelectObject(HandleRef hDC, HandleRef hObject);

        // File src\services\system\io\unsafenativemethods.cs

        public const int FILE_READ_DATA = (0x0001),
        FILE_LIST_DIRECTORY = (0x0001),
        FILE_WRITE_DATA = (0x0002),
        FILE_ADD_FILE = (0x0002),
        FILE_APPEND_DATA = (0x0004),
        FILE_ADD_SUBDIRECTORY = (0x0004),
        FILE_CREATE_PIPE_INSTANCE = (0x0004),
        FILE_READ_EA = (0x0008),
        FILE_WRITE_EA = (0x0010),
        FILE_EXECUTE = (0x0020),
        FILE_TRAVERSE = (0x0020),
        FILE_DELETE_CHILD = (0x0040),
        FILE_READ_ATTRIBUTES = (0x0080),
        FILE_WRITE_ATTRIBUTES = (0x0100),
        FILE_SHARE_READ = 0x00000001,
        FILE_SHARE_WRITE = 0x00000002,
        FILE_SHARE_DELETE = 0x00000004,
        FILE_ATTRIBUTE_READONLY = 0x00000001,
        FILE_ATTRIBUTE_HIDDEN = 0x00000002,
        FILE_ATTRIBUTE_SYSTEM = 0x00000004,
        FILE_ATTRIBUTE_DIRECTORY = 0x00000010,
        FILE_ATTRIBUTE_ARCHIVE = 0x00000020,
        FILE_ATTRIBUTE_NORMAL = 0x00000080,
        FILE_ATTRIBUTE_TEMPORARY = 0x00000100,
        FILE_ATTRIBUTE_COMPRESSED = 0x00000800,
        FILE_ATTRIBUTE_OFFLINE = 0x00001000,
        FILE_NOTIFY_CHANGE_FILE_NAME = 0x00000001,
        FILE_NOTIFY_CHANGE_DIR_NAME = 0x00000002,
        FILE_NOTIFY_CHANGE_ATTRIBUTES = 0x00000004,
        FILE_NOTIFY_CHANGE_SIZE = 0x00000008,
        FILE_NOTIFY_CHANGE_LAST_WRITE = 0x00000010,
        FILE_NOTIFY_CHANGE_LAST_ACCESS = 0x00000020,
        FILE_NOTIFY_CHANGE_CREATION = 0x00000040,
        FILE_NOTIFY_CHANGE_SECURITY = 0x00000100,
        FILE_ACTION_ADDED = 0x00000001,
        FILE_ACTION_REMOVED = 0x00000002,
        FILE_ACTION_MODIFIED = 0x00000003,
        FILE_ACTION_RENAMED_OLD_NAME = 0x00000004,
        FILE_ACTION_RENAMED_NEW_NAME = 0x00000005,
        FILE_CASE_SENSITIVE_SEARCH = 0x00000001,
        FILE_CASE_PRESERVED_NAMES = 0x00000002,
        FILE_UNICODE_ON_DISK = 0x00000004,
        FILE_PERSISTENT_ACLS = 0x00000008,
        FILE_FILE_COMPRESSION = 0x00000010,
        OPEN_EXISTING = 3,
        FILE_FLAG_WRITE_THROUGH = unchecked((int)0x80000000),
        FILE_FLAG_OVERLAPPED = 0x40000000,
        FILE_FLAG_NO_BUFFERING = 0x20000000,
        FILE_FLAG_RANDOM_ACCESS = 0x10000000,
        FILE_FLAG_SEQUENTIAL_SCAN = 0x08000000,
        FILE_FLAG_DELETE_ON_CLOSE = 0x04000000,
        FILE_FLAG_BACKUP_SEMANTICS = 0x02000000,
        FILE_FLAG_POSIX_SEMANTICS = 0x01000000,
        FILE_TYPE_UNKNOWN = 0x0000,
        FILE_TYPE_DISK = 0x0001,
        FILE_TYPE_CHAR = 0x0002,
        FILE_TYPE_PIPE = 0x0003,
        FILE_TYPE_REMOTE = unchecked((int)0x8000),
        FILE_VOLUME_IS_COMPRESSED = 0x00008000;

        // file src\Services\Monitoring\system\Diagnosticts\unSafeNativeMethods.cs
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int RegQueryValueEx(HandleRef hKey, string lpValueName, int[] lpReserved, int[] lpType, HandleRef lpData, ref int lpcbData);        
        
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool UnmapViewOfFile(HandleRef lpBaseAddress);
        
        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]        
        public static extern IntPtr OpenFileMapping(int dwDesiredAccess, bool bInheritHandle, string lpName);
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern unsafe bool ConvertStringSecurityDescriptorToSecurityDescriptor(string StringSecurityDescriptor, int StringSDRevision, out IntPtr pSecurityDescriptor, IntPtr SecurityDescriptorSize);

        [DllImport(ExternDll.Kernel32, CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public static extern IntPtr CreateFileMapping(HandleRef hFile, NativeMethods.SECURITY_ATTRIBUTES lpFileMappingAttributes, int flProtect, int dwMaximumSizeHigh, int dwMaximumSizeLow, string lpName);
        
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr MapViewOfFile(HandleRef hFileMappingObject, int dwDesiredAccess, int dwFileOffsetHigh, int dwFileOffsetLow, int dwNumberOfBytesToMap);
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern bool LookupAccountSid(string systemName, byte[] sid,
                                                    char[] name, int[] cbName, char[] referencedDomainName, int[] cbRefDomName,
                                                    int[] sidNameUse);
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]        
        public static extern int RegConnectRegistry(string machineName, HandleRef key, out IntPtr result);
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int RegOpenKeyEx(HandleRef hKey, string lpSubKey, HandleRef ulOptions, int samDesired, out IntPtr phkResult);
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int RegQueryValueEx(HandleRef hKey, string name, int[] reserved, out int type, byte[] data, ref int size);
        
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int RegQueryValueEx(HandleRef hKey, string name, int[] reserved, out int type, char[] data, ref int size);                                           
                        
        // file Windows Forms
        [DllImport(ExternDll.Version, CharSet=CharSet.Auto, SetLastError=true, BestFitMapping=false)]
        public static extern int GetFileVersionInfoSize(string lptstrFilename, [In, Out]int [] lpdwHandle);
        [DllImport(ExternDll.Version, CharSet=CharSet.Auto, BestFitMapping=false)]
        public static extern bool GetFileVersionInfo(string lptstrFilename, int dwHandle, int dwLen, HandleRef lpData);
        [DllImport(ExternDll.Version, CharSet=CharSet.Auto)]
        public static extern bool VerQueryValue(HandleRef pBlock, string lpSubBlock, [In, Out] ref IntPtr lplpBuffer, [In, Out]int[] puLen);
        [DllImport(ExternDll.Version, CharSet=CharSet.Auto)]
        public static extern bool VerQueryValue(HandleRef pBlock, string lpSubBlock, [In, Out] int [] lplpBuffer, [In, Out]int[] puLen);
        [DllImport(ExternDll.Version, CharSet=CharSet.Auto)]
        public static extern int VerLanguageName( int langID, StringBuilder lpBuffer, int nSize);

        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GlobalAlloc(int uFlags, int dwBytes);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GlobalReAlloc(HandleRef handle, int bytes, int flags);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GlobalLock(HandleRef handle);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern bool GlobalUnlock(HandleRef handle);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern IntPtr GlobalFree(HandleRef handle);
        [DllImport(ExternDll.Kernel32, ExactSpelling=true, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int GlobalSize(HandleRef handle);

        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        internal static extern IntPtr OpenEventLog(string UNCServerName, string sourceName);
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern IntPtr RegisterEventSource(string uncServerName, string sourceName);
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern bool DeregisterEventSource(HandleRef hEventLog);
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern bool ReportEvent(HandleRef hEventLog, short type, short category,
                                                int eventID, byte[] userSID, short numStrings, int dataLen, HandleRef strings,
                                                byte[] rawData);
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern bool ClearEventLog(HandleRef hEventLog, HandleRef lpctstrBackupFileName);
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern bool GetNumberOfEventLogRecords(HandleRef hEventLog, out int count);
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern bool GetOldestEventLogRecord(HandleRef hEventLog, int[] number);
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern bool ReadEventLog(HandleRef hEventLog, int dwReadFlags,
                                                 int dwRecordOffset, byte[] buffer, int numberOfBytesToRead, int[] bytesRead,
                                                 int[] minNumOfBytesNeeded);
        [DllImport(ExternDll.Advapi32, CharSet=System.Runtime.InteropServices.CharSet.Unicode, SetLastError=true)]
        public static extern bool NotifyChangeEventLog(HandleRef hEventLog, HandleRef hEvent);

        [DllImport(ExternDll.Kernel32, EntryPoint="ReadDirectoryChangesW", CharSet=System.Runtime.InteropServices.CharSet.Auto, SetLastError=true)]
        public unsafe static extern bool ReadDirectoryChangesW(HandleRef hDirectory, HandleRef lpBuffer, 
                                                                                                            int nBufferLength, int bWatchSubtree, int dwNotifyFilter, out int lpBytesReturned,
                                                                                                            NativeOverlapped* overlappedPointer, HandleRef lpCompletionRoutine);                                                
                                                                                                            
        [DllImport(ExternDll.Loadperf, CharSet=System.Runtime.InteropServices.CharSet.Auto)]
        public static extern int LoadPerfCounterTextStrings(string commandLine, bool quietMod);
        
        [DllImport(ExternDll.Loadperf, CharSet=System.Runtime.InteropServices.CharSet.Auto)]        
        public static extern int UnloadPerfCounterTextStrings(string commandLine, bool quietMod);                                                                                                                    

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\win32\sessionendreasons.cs ===
//------------------------------------------------------------------------------
// <copyright file="SessionEndReasons.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.Win32 {
    using System.Diagnostics;
    using System;

    /// <include file='doc\SessionEndReasons.uex' path='docs/doc[@for="SessionEndReasons"]/*' />
    /// <devdoc>
    ///    <para> Specifies how the current
    ///       logon session is ending.</para>
    /// </devdoc>
    public enum SessionEndReasons {
    
        /// <include file='doc\SessionEndReasons.uex' path='docs/doc[@for="SessionEndReasons.Logoff"]/*' />
        /// <devdoc>
        ///      The user is logging off.  The system may continue
        ///      running but the user who started this application
        ///      is logging off.
        /// </devdoc>
        Logoff = 1,
    
        /// <include file='doc\SessionEndReasons.uex' path='docs/doc[@for="SessionEndReasons.SystemShutdown"]/*' />
        /// <devdoc>
        ///      The system is shutting down.
        /// </devdoc>
        SystemShutdown = 2,
    
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\win32\userpreferencecategories.cs ===
//------------------------------------------------------------------------------
// <copyright file="UserPreferenceCategories.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.Win32 {
    using System.Diagnostics;
    using System;
    
    /// <include file='doc\UserPreferenceCategories.uex' path='docs/doc[@for="UserPreferenceCategory"]/*' />
    /// <devdoc>
    ///    <para> Identifies areas of user preferences that
    ///       have changed.</para>
    /// </devdoc>
    public enum UserPreferenceCategory {
    
        /// <include file='doc\UserPreferenceCategories.uex' path='docs/doc[@for="UserPreferenceCategory.Accessibility"]/*' />
        /// <devdoc>
        ///    <para> Specifies user
        ///       preferences associated with accessibility
        ///       of the system for users with disabilities.</para>
        /// </devdoc>
        Accessibility = 1,
    
        /// <include file='doc\UserPreferenceCategories.uex' path='docs/doc[@for="UserPreferenceCategory.Color"]/*' />
        /// <devdoc>
        ///    <para> Specifies user preferences
        ///       associated with system colors, such as the
        ///       default color of windows or menus.</para>
        /// </devdoc>
        Color = 2,
    
        /// <include file='doc\UserPreferenceCategories.uex' path='docs/doc[@for="UserPreferenceCategory.Desktop"]/*' />
        /// <devdoc>
        ///    <para> Specifies user
        ///       preferences associated with the system desktop.
        ///       This may reflect a change in desktop background
        ///       images, or desktop layout.</para>
        /// </devdoc>
        Desktop = 3,
        
        /// <include file='doc\UserPreferenceCategories.uex' path='docs/doc[@for="UserPreferenceCategory.General"]/*' />
        /// <devdoc>
        ///    <para> Specifies user preferences
        ///       that are not associated with any other category.</para>
        /// </devdoc>
        General = 4,
        
        /// <include file='doc\UserPreferenceCategories.uex' path='docs/doc[@for="UserPreferenceCategory.Icon"]/*' />
        /// <devdoc>
        ///    <para> Specifies
        ///       user preferences for icon settings. This includes
        ///       icon height and spacing.</para>
        /// </devdoc>
        Icon = 5,
    
        /// <include file='doc\UserPreferenceCategories.uex' path='docs/doc[@for="UserPreferenceCategory.Keyboard"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Specifies user preferences for keyboard settings,
        ///       such as the keyboard repeat rate.</para>
        /// </devdoc>
        Keyboard = 6,
        
        /// <include file='doc\UserPreferenceCategories.uex' path='docs/doc[@for="UserPreferenceCategory.Menu"]/*' />
        /// <devdoc>
        ///    <para> Specifies user preferences
        ///       for menu settings, such as menu delays and
        ///       text alignment.</para>
        /// </devdoc>
        Menu = 7,
    
        /// <include file='doc\UserPreferenceCategories.uex' path='docs/doc[@for="UserPreferenceCategory.Mouse"]/*' />
        /// <devdoc>
        ///    <para> Specifies user preferences
        ///       for mouse settings, such as double click
        ///       time and mouse sensitivity.</para>
        /// </devdoc>
        Mouse = 8,
        
        /// <include file='doc\UserPreferenceCategories.uex' path='docs/doc[@for="UserPreferenceCategory.Policy"]/*' />
        /// <devdoc>
        ///    <para> Specifies user preferences
        ///       for policy settings, such as user rights and
        ///       access levels.</para>
        /// </devdoc>
        Policy = 9,
        
        /// <include file='doc\UserPreferenceCategories.uex' path='docs/doc[@for="UserPreferenceCategory.Power"]/*' />
        /// <devdoc>
        ///    <para> Specifies user preferences
        ///       for system power settings. An example of a
        ///       power setting is the time required for the
        ///       system to automatically enter low power mode.</para>
        /// </devdoc>
        Power = 10,
    
        /// <include file='doc\UserPreferenceCategories.uex' path='docs/doc[@for="UserPreferenceCategory.Screensaver"]/*' />
        /// <devdoc>
        ///    <para> Specifies user preferences
        ///       associated with the screensaver.</para>
        /// </devdoc>
        Screensaver = 11,
    
        /// <include file='doc\UserPreferenceCategories.uex' path='docs/doc[@for="UserPreferenceCategory.Window"]/*' />
        /// <devdoc>
        ///    <para> Specifies user preferences
        ///       associated with the dimensions and characteristics
        ///       of windows on the system.</para>
        /// </devdoc>
        Window = 12,
        
        /// <include file='doc\UserPreferenceCategories.uex' path='docs/doc[@for="UserPreferenceCategory.Locale"]/*' />
        /// <devdoc>
        ///    <para> Specifies user preferences
        ///       associated with the locale of the system.</para>
        /// </devdoc>
        Locale = 13,
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\visualbasic\vbcodeprovider.cs ===
//------------------------------------------------------------------------------
// <copyright file="VBCodeProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace Microsoft.VisualBasic {
    using System.Diagnostics;
    using System;
    using System.IO;
    using System.Collections;
    using System.Collections.Specialized;
    using System.ComponentModel;
    using System.Reflection;
    using System.CodeDom;
    using System.Text;
    using System.Text.RegularExpressions;
    using System.Globalization;
    using System.CodeDom.Compiler;
    using System.Security.Permissions;
    using Microsoft.Win32;

    /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeProvider"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public class VBCodeProvider: CodeDomProvider {
        private VBCodeGenerator generator = new VBCodeGenerator();

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeProvider.FileExtension"]/*' />
        /// <devdoc>
        ///    <para>Retrieves the default extension to use when saving files using this code dom provider.</para>
        /// </devdoc>
        public override string FileExtension {
            get {
                return "vb";
            }
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeProvider.LanguageOptions"]/*' />
        /// <devdoc>
        ///    <para>Returns flags representing language variations.</para>
        /// </devdoc>
        public override LanguageOptions LanguageOptions {
            get {
                return LanguageOptions.CaseInsensitive;
            }
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeProvider.CreateGenerator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override ICodeGenerator CreateGenerator() {
            return (ICodeGenerator)generator;
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeProvider.CreateCompiler"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override ICodeCompiler CreateCompiler() {
            return (ICodeCompiler)generator;
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeProvider.GetConverter"]/*' />
        /// <devdoc>
        ///     This method allows a code dom provider implementation to provide a different type converter
        ///     for a given data type.  At design time, a designer may pass data types through this
        ///     method to see if the code dom provider wants to provide an additional converter.  
        ///     A typical way this would be used is if the language this code dom provider implements
        ///     does not support all of the values of the MemberAttributes enumeration, or if the language
        ///     uses different names (Protected instead of Family, for example).  The default 
        ///     implementation just calls TypeDescriptor.GetConverter for the given type.
        /// </devdoc>
        public override TypeConverter GetConverter(Type type) {
            if (type == typeof(MemberAttributes)) {
                return VBMemberAttributeConverter.Default;
            }
            
            return base.GetConverter(type);
        }
    }

    /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Visual Basic 7 Code Generator.
    ///    </para>
    /// </devdoc>
    internal class VBCodeGenerator : CodeCompiler {
        private const int MaxLineLength = 80;

        private const GeneratorSupport LanguageSupport = GeneratorSupport.EntryPointMethod |
                                                         GeneratorSupport.GotoStatements |
                                                         GeneratorSupport.ArraysOfArrays |
                                                         GeneratorSupport.MultidimensionalArrays |
                                                         GeneratorSupport.StaticConstructors |
                                                         GeneratorSupport.ReturnTypeAttributes |
                                                         GeneratorSupport.AssemblyAttributes |
                                                         GeneratorSupport.TryCatchStatements |
                                                         GeneratorSupport.DeclareValueTypes |
                                                         GeneratorSupport.DeclareEnums | 
                                                         GeneratorSupport.DeclareEvents | 
                                                         GeneratorSupport.DeclareDelegates |
                                                         GeneratorSupport.DeclareInterfaces |
                                                         GeneratorSupport.ParameterAttributes |
                                                         GeneratorSupport.ReferenceParameters |
                                                         GeneratorSupport.ChainedConstructorArguments |
                                                         GeneratorSupport.NestedTypes |
                                                         GeneratorSupport.MultipleInterfaceMembers |
                                                         GeneratorSupport.PublicStaticMembers |
                                                         GeneratorSupport.ComplexExpressions |
                                                         GeneratorSupport.Win32Resources;

        private static Regex outputReg;
            
        // This is the keyword list. To minimize search time and startup time, this is stored by length
        // and then alphabetically for use by FixedStringLookup.Contains.
        private static readonly string[][] keywords = new string[][] {
            null,           // 1 character
            new string[] {  // 2 characters
                "as",
                "do",
                "if",
                "in",
                "is",
                "me",
                "on",
                "or",
                "to",
            },
            new string[] {  // 3 characters
                "and",
                "chr",
                "dim",
                "end",
                "for",
                "get",
                "let",
                "lib",
                "mod",
                "new",
                "not",
                "off",
                "rem",
                "set",
                "sub",
                "try",
                "xor",
            },
            new string[] {  // 4 characters
                "ansi",
                "auto",
                "byte",
                "call",
                "case",
                "cchr",
                "cdbl",
                "cdec",
                "char",
                "chrw",
                "cint",
                "clng",
                "cobj",
                "csng",
                "cstr",
                "date",
                "each",
                "else",
                "enum",
                "exit",
                "goto",
                "like",
                "long",
                "loop",
                "next",
                "null",
                "step",
                "stop",
                "text",
                "then",
                "true",
                "when",
                "with",
            },
            new string[] {  // 5 characters 
                "alias",
                "andif",
                "byref",
                "byval",
                "catch",
                "cbool",
                "cbyte",
                "cchar",
                "cdate",
                "class",
                "const",
                "ctype",
                "endif",
                "erase",
                "error",
                "event",
                "false",
                "gosub",
                "redim",
                "short",
                "throw",
                "until",
                "while",
            },
            new string[] {  // 6 characters
                "binary",
                "cshort",
                "double",
                "elseif",
                "friend",
                "module",
                "mybase",
                "object",
                "option",
                "orelse",
                "public",
                "region",
                "resume",
                "return",
                "select",
                "shared",
                "single",
                "static",
                "strict",
                "string",
                "typeof",
            },
            new string[] { // 7 characters
                "andalso",
                "boolean",
                "compare",
                "convert",
                "decimal",
                "declare",
                "default",
                "finally",
                "gettype",
                "handles",
                "imports",
                "integer",
                "myclass",
                "nothing",
                "private",
                "shadows",
                "unicode",
                "variant",
            },
            new string[] {  // 8 characters
                "assembly",
                "delegate",
                "explicit",
                "function",
                "inherits",
                "optional",
                "preserve",
                "property",
                "readonly",
                "synclock",
            },
            new string [] { // 9 characters
                "addressof",
                "interface",
                "namespace",
                "overloads",
                "overrides",
                "protected",
                "structure",
                "writeonly",
            },
            new string [] { // 10 characters
                "addhandler",
                "implements",
                "paramarray",
                "raiseevent",
                "withevents",
            },
            new string[] {  // 11 characters
                "endprologue",
                "mustinherit",
                "overridable",
            },
            new string[] { // 12 characters
                "mustoverride",
            },
            new string [] { // 13 characters
                "beginepilogue",
                "removehandler",
            },
            new string [] { // 14 characters
                "externalsource",
                "notinheritable",
                "notoverridable",
            },
        };

#if DEBUG
        static VBCodeGenerator() {
            FixedStringLookup.VerifyLookupTable(keywords, true);

            // Sanity check: try some values;
            Debug.Assert(IsKeyword("for"));
            Debug.Assert(IsKeyword("foR"));
            Debug.Assert(IsKeyword("cdec"));
            Debug.Assert(!IsKeyword("cdab"));
            Debug.Assert(!IsKeyword("cdum"));
        }
#endif

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.FileExtension"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or the file extension to use for source files.
        ///    </para>
        /// </devdoc>
        protected override string FileExtension { get { return ".vb"; } }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.CompilerName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the compiler exe
        ///    </para>
        /// </devdoc>
        protected override string CompilerName { get { return "vbc.exe"; } }
        
        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.NullToken"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the token that is used to represent <see langword='null'/>.
        ///    </para>
        /// </devdoc>
        protected override string NullToken {
            get {
                return "Nothing";
            }
        }

        private void EnsureInDoubleQuotes(ref bool fInDoubleQuotes, StringBuilder b) {
            if (fInDoubleQuotes) return;
            b.Append("&\"");
            fInDoubleQuotes = true;
        }

        private void EnsureNotInDoubleQuotes(ref bool fInDoubleQuotes, StringBuilder b) {
            if (!fInDoubleQuotes) return;
            b.Append("\"");
            fInDoubleQuotes = false;
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.QuoteSnippetString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides conversion to formatting with escape codes.
        ///    </para>
        /// </devdoc>
        protected override string QuoteSnippetString(string value) {
            StringBuilder b = new StringBuilder(value.Length+5);

            bool fInDoubleQuotes = true;
            b.Append("\"");

            for (int i=0; i<value.Length; i++) {
                char ch = value[i];
                switch (ch) {
                    case '\"':
                    // These are the inward sloping quotes used by default in some cultures like CHS. 
                    // VBC.EXE does a mapping ANSI that results in it treating these as syntactically equivalent to a
                    // regular double quote.
                    case '\u201C': 
                    case '\u201D':
                    case '\uFF02':
                        EnsureInDoubleQuotes(ref fInDoubleQuotes, b);
                        b.Append(ch);
                        b.Append(ch);
                        break;
                    case '\r':
                        EnsureNotInDoubleQuotes(ref fInDoubleQuotes, b);
                        if (i < value.Length - 1 && value[i+1] == '\n') {
                            b.Append("&Microsoft.VisualBasic.ChrW(13)&Microsoft.VisualBasic.ChrW(10)");
                            i++;
                        }
                        else {
                            b.Append("&Microsoft.VisualBasic.ChrW(13)");
                        }
                        break;
                    case '\t':
                        EnsureNotInDoubleQuotes(ref fInDoubleQuotes, b);
                        b.Append("&Microsoft.VisualBasic.ChrW(9)");
                        break;
                    case '\0':
                        EnsureNotInDoubleQuotes(ref fInDoubleQuotes, b);
                        b.Append("&Microsoft.VisualBasic.ChrW(0)");
                        break;
                    case '\n':
                        EnsureNotInDoubleQuotes(ref fInDoubleQuotes, b);
                        b.Append("&Microsoft.VisualBasic.ChrW(10)");
                        break;
                    case '\u2028':
                    case '\u2029':
	                    EnsureNotInDoubleQuotes(ref fInDoubleQuotes, b);
                        AppendEscapedChar(b,ch);
	                    break;
                    default:
	                    EnsureInDoubleQuotes(ref fInDoubleQuotes, b);
	                    b.Append(value[i]);
                        break;
                }

                if (i > 0 && i % MaxLineLength == 0) {
                    if (fInDoubleQuotes)
                        b.Append("\"");
                    fInDoubleQuotes = true;
                    b.Append("& _ \r\n\"");
                }
            }

            if (fInDoubleQuotes)
                b.Append("\"");

            return b.ToString();
        }

        //@TODO: Someday emit the hex version to be consistent with C#.
        private static void AppendEscapedChar(StringBuilder b, char value) {
            b.Append("&Microsoft.VisualBasic.ChrW(");
            b.Append(((int)value).ToString(CultureInfo.InvariantCulture));
            b.Append(")");
        }

        private static string ConvertToCommentEscapeCodes(string value) {
            StringBuilder b = new StringBuilder(value.Length);

            for (int i=0; i<value.Length; i++) {
                switch (value[i]) {
                    case '\r':
                        if (i < value.Length - 1 && value[i+1] == '\n') {
                            b.Append("\r\n'");
                            i++;
                        }
                        else {
                            b.Append("\r'");
                        }
                        break;
                    case '\n':
                        b.Append("\n'");
                        break;
                    case '\u2028':
                    case '\u2029':
                        b.Append(value[i]);
                        b.Append('\'');
                        break;
                    default:
                        b.Append(value[i]);
                        break;
                }
            }

            return b.ToString();
        }

        protected override void ProcessCompilerOutputLine(CompilerResults results, string line) {
            if (outputReg == null) {
                outputReg = new Regex(@"^([^(]*)\(?([0-9]*)\)? ?:? ?(error|warning) ([A-Z]+[0-9]+): (.*)");
            }
            Match m = outputReg.Match(line);
            if (m.Success) {
                CompilerError ce = new CompilerError();
                ce.FileName = m.Groups[1].Value;
                string rawLine = m.Groups[2].Value;
                if (rawLine != null && rawLine.Length > 0) {
                    ce.Line = int.Parse(rawLine);
                }
                if (string.Compare(m.Groups[3].Value, "warning", true, CultureInfo.InvariantCulture) == 0) {
                    ce.IsWarning = true;
                }
                ce.ErrorNumber = m.Groups[4].Value;
                ce.ErrorText = m.Groups[5].Value;
                results.Errors.Add(ce);
            }
        }

        protected override string CmdArgsFromParameters(CompilerParameters options) {
            StringBuilder sb = new StringBuilder(128);
            if (options.GenerateExecutable) {
                sb.Append("/t:exe ");
                if (options.MainClass != null && options.MainClass.Length > 0) {
                    sb.Append("/main:");
                    sb.Append(options.MainClass);
                    sb.Append(" ");
                }
            }
            else {
                sb.Append("/t:library ");
            }

            // Get UTF8 output from the compiler (bug 54925)
            sb.Append("/utf8output ");

            foreach (string s in options.ReferencedAssemblies) {

                // Ignore any Microsoft.VisualBasic.dll, since Visual Basic implies it (bug 72785)
                string fileName = Path.GetFileName(s);
                if (string.Compare(fileName, "Microsoft.VisualBasic.dll", true /*ignoreCase*/, CultureInfo.InvariantCulture) == 0)
                    continue;

                // Same deal for mscorlib (bug ASURT 81568)
                if (string.Compare(fileName, "mscorlib.dll", true /*ignoreCase*/, CultureInfo.InvariantCulture) == 0)
                    continue;

                sb.Append("/R:");
                sb.Append("\"");
                sb.Append(s);
                sb.Append("\"");
                sb.Append(" ");
            }

            sb.Append("/out:");
            sb.Append("\"");
            sb.Append(options.OutputAssembly);
            sb.Append("\"");
            sb.Append(" ");

            if (options.IncludeDebugInformation) {
                sb.Append("/D:DEBUG=1 ");
                sb.Append("/debug+ ");
            }
            else {
                sb.Append("/debug- ");
            }

            if (options.Win32Resource != null) {
                sb.Append("/win32resource:\"" + options.Win32Resource + "\" ");
            }

            if (options.TreatWarningsAsErrors) {
                sb.Append("/warnaserror+ ");
            }

            if (options.CompilerOptions != null) {
                sb.Append(options.CompilerOptions + " ");
            }

            return sb.ToString();
        }

        protected override void OutputAttributeArgument(CodeAttributeArgument arg) {
            if (arg.Name != null && arg.Name.Length > 0) {
                OutputIdentifier(arg.Name);
                Output.Write(":=");
            }
            ((ICodeGenerator)this).GenerateCodeFromExpression(arg.Value, ((IndentedTextWriter)Output).InnerWriter, Options);
        }

        private void OutputAttributes(CodeAttributeDeclarationCollection attributes, bool inLine) {
            OutputAttributes(attributes, inLine, null, false);
        }

        private void OutputAttributes(CodeAttributeDeclarationCollection attributes, bool inLine, string prefix, bool closingLine) {
            if (attributes.Count == 0) return;
            IEnumerator en = attributes.GetEnumerator();
            bool firstAttr = true;
            GenerateAttributeDeclarationsStart(attributes);
            while (en.MoveNext()) {

                if (firstAttr) {
                    firstAttr = false;
                }
                else {
                    Output.Write(", ");
                    if (!inLine) {
                        ContinueOnNewLine("");
                        Output.Write(" ");
                    }
                }

                if (prefix != null && prefix.Length > 0) {
                    Output.Write(prefix);
                }

                CodeAttributeDeclaration current = (CodeAttributeDeclaration)en.Current;
                Output.Write(GetBaseTypeOutput(current.Name));
                Output.Write("(");

                bool firstArg = true;
                foreach (CodeAttributeArgument arg in current.Arguments) {
                    if (firstArg) {
                        firstArg = false;
                    }
                    else {
                        Output.Write(", ");
                    }

                    OutputAttributeArgument(arg);
                }

                Output.Write(")");

            }
            GenerateAttributeDeclarationsEnd(attributes);
            Output.Write(" ");            
            if (!inLine) {
                if (closingLine) {
                    Output.WriteLine();
                }
                else {
                    ContinueOnNewLine("");
                }
            }
        }

        protected override void OutputDirection(FieldDirection dir) {
            switch (dir) {
                case FieldDirection.In:
                    Output.Write("ByVal ");
                    break;
                case FieldDirection.Out:
                case FieldDirection.Ref:
                    Output.Write("ByRef ");
                    break;
            }
        }

        protected override void GenerateDirectionExpression(CodeDirectionExpression e) {
            // Visual Basic does not need to adorn the calling point with a direction, so just output the expression.
            GenerateExpression(e.Expression);
        }

        
        protected override void OutputFieldScopeModifier(MemberAttributes attributes) {
            switch (attributes & MemberAttributes.ScopeMask) {
                case MemberAttributes.Final:
                    Output.Write("");
                    break;
                case MemberAttributes.Static:
                    Output.Write("Shared ");
                    break;
                case MemberAttributes.Const:
                    Output.Write("Const ");
                    break;
                default:
                    Output.Write("");
                    break;
            }
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.OutputMemberAccessModifier"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based member
        ///       access modifier representation.
        ///    </para>
        /// </devdoc>
        protected override void OutputMemberAccessModifier(MemberAttributes attributes) {
            switch (attributes & MemberAttributes.AccessMask) {
                case MemberAttributes.Assembly:
                    Output.Write("Friend ");
                    break;
                case MemberAttributes.FamilyAndAssembly:
                    Output.Write("Friend ");
                    break;
                case MemberAttributes.Family:
                    Output.Write("Protected ");
                    break;
                case MemberAttributes.FamilyOrAssembly:
                    Output.Write("Protected ");
                    break;
                case MemberAttributes.Private:
                    Output.Write("Private ");
                    break;
                case MemberAttributes.Public:
                    Output.Write("Public ");
                    break;
            }
        }

        private void OutputVTableModifier(MemberAttributes attributes) {
            switch (attributes & MemberAttributes.VTableMask) {
                case MemberAttributes.New:
                    Output.Write("Shadows ");
                    break;
            }
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.OutputMemberScopeModifier"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based member scope modifier
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void OutputMemberScopeModifier(MemberAttributes attributes) {

            switch (attributes & MemberAttributes.ScopeMask) {
                case MemberAttributes.Abstract:
                    Output.Write("MustOverride ");
                    break;
                case MemberAttributes.Final:
                    Output.Write("");
                    break;
                case MemberAttributes.Static:
                    Output.Write("Shared ");
                    break;
                case MemberAttributes.Override:
                    Output.Write("Overrides ");
                    break;
                case MemberAttributes.Private:
                    Output.Write("Private ");
                    break;
                default:
                    switch (attributes & MemberAttributes.AccessMask) {
                        case MemberAttributes.Family:
                        case MemberAttributes.Public:
                            Output.Write("Overridable ");
                            break;
                        default:
                            // nothing;
                            break;
                    }
                    break;
            }
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.OutputOperator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based operator
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void OutputOperator(CodeBinaryOperatorType op) {
            switch (op) {
                case CodeBinaryOperatorType.IdentityInequality:
                    Output.Write("<>");
                    break;
                case CodeBinaryOperatorType.IdentityEquality:
                    Output.Write("Is");
                    break;
                case CodeBinaryOperatorType.BooleanOr:
                    Output.Write("OrElse");
                    break;
                case CodeBinaryOperatorType.BooleanAnd:
                    Output.Write("AndAlso");
                    break;
                case CodeBinaryOperatorType.ValueEquality:
                    Output.Write("=");
                    break;
                case CodeBinaryOperatorType.Modulus:
                    Output.Write("Mod");
                    break;
                case CodeBinaryOperatorType.BitwiseOr:
                    Output.Write("Or");
                    break;
                case CodeBinaryOperatorType.BitwiseAnd:
                    Output.Write("And");
                    break;
                default:
                    base.OutputOperator(op);
                break;
            }
        }

        private void GenerateNotIsNullExpression(CodeExpression e) {
            Output.Write("(Not (");
            GenerateExpression(e);
            Output.Write(") Is ");
            Output.Write(NullToken);
            Output.Write(")");
        }

        protected override void GenerateBinaryOperatorExpression(CodeBinaryOperatorExpression e) {
            if (e.Operator != CodeBinaryOperatorType.IdentityInequality) {
                base.GenerateBinaryOperatorExpression(e);
                return;
            }

            // "o <> nothing" should be "not o is nothing"
            if (e.Right is CodePrimitiveExpression && ((CodePrimitiveExpression)e.Right).Value == null){
                GenerateNotIsNullExpression(e.Left);
                return;    
            }
            if (e.Left is CodePrimitiveExpression && ((CodePrimitiveExpression)e.Left).Value == null){
                GenerateNotIsNullExpression(e.Right);
                return;
            }

            base.GenerateBinaryOperatorExpression(e);
        }

        protected override void OutputIdentifier(string ident) {
            Output.Write(CreateEscapedIdentifier(ident));
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.OutputType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based return type
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void OutputType(CodeTypeReference typeRef) {
            Output.Write(GetBaseTypeOutput(typeRef.BaseType));
        }

        private void OutputTypeAttributes(CodeTypeDeclaration e) {
            TypeAttributes attributes = e.TypeAttributes;
            switch(attributes & TypeAttributes.VisibilityMask) {
                case TypeAttributes.Public:                  
                case TypeAttributes.NestedPublic:                    
                    Output.Write("Public ");
                    break;
                case TypeAttributes.NestedPrivate:
                    Output.Write("Private ");
                    break;
            }
            
            if (e.IsStruct) {
                Output.Write("Structure ");
            }
            else if (e.IsEnum) {
                Output.Write("Enum ");
            }     
            else {            
                switch (attributes & TypeAttributes.ClassSemanticsMask) {
                    case TypeAttributes.Class:
                        if ((attributes & TypeAttributes.Sealed) == TypeAttributes.Sealed) {
                            Output.Write("NotInheritable ");
                        }
                        if ((attributes & TypeAttributes.Abstract) == TypeAttributes.Abstract)  {
                            Output.Write("MustInherit ");
                        }
                        Output.Write("Class ");
                        break;                
                    case TypeAttributes.Interface:
                        Output.Write("Interface ");
                        break;
                }
            }
            
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.OutputTypeNamePair"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based type name pair
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void OutputTypeNamePair(CodeTypeReference typeRef, string name) {
            OutputIdentifier(name);
            OutputArrayPostfix(typeRef);
            Output.Write(" As ");
            OutputType(typeRef);
        }

        private string GetArrayPostfix(CodeTypeReference typeRef) {
            string s = "";
            if (typeRef.ArrayElementType != null) {
                // Recurse up
                s = GetArrayPostfix(typeRef.ArrayElementType);
            }

            if (typeRef.ArrayRank > 0) {            
                char [] results = new char [typeRef.ArrayRank + 1];
                results[0] = '(';
                results[typeRef.ArrayRank] = ')';
                for (int i = 1; i < typeRef.ArrayRank; i++) {
                    results[i] = ',';
                }
                s += new string(results);
            }

            return s;

        }

        private void OutputArrayPostfix(CodeTypeReference typeRef) {
            if (typeRef.ArrayRank > 0) {                        
                Output.Write(GetArrayPostfix(typeRef));
            }
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateIterationStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based for loop statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateIterationStatement(CodeIterationStatement e) {
            GenerateStatement(e.InitStatement);
            Output.Write("Do While ");
            GenerateExpression(e.TestExpression);
            Output.WriteLine("");
            Indent++;
            GenerateStatements(e.Statements);
            GenerateStatement(e.IncrementStatement);
            Indent--;
            Output.WriteLine("Loop");
        }
        
        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GeneratePrimitiveExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based primitive expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GeneratePrimitiveExpression(CodePrimitiveExpression e) {
            if (e.Value is char) {
                Output.Write("Microsoft.VisualBasic.ChrW(" + ((IConvertible)e.Value).ToInt32(null).ToString() + ")");
            }
            else {
                base.GeneratePrimitiveExpression(e);
            }
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateThrowExceptionStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based throw exception statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateThrowExceptionStatement(CodeThrowExceptionStatement e) {
            Output.Write("Throw");
            if (e.ToThrow != null) {
                Output.Write(" ");
                GenerateExpression(e.ToThrow);
            }
            Output.WriteLine("");
        }


        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateArrayCreateExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based array creation expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateArrayCreateExpression(CodeArrayCreateExpression e) {
            Output.Write("New ");
            OutputType(e.CreateType);

            CodeExpressionCollection init = e.Initializers;
            if (init.Count > 0) {
                Output.Write("() {");
                Indent++;
                OutputExpressionList(init);
                Indent--;
                Output.Write("}");
            }
            else {
                Output.Write("(");
                // The tricky thing is we need to declare the size - 1
                if (e.SizeExpression != null) {
                    Output.Write("(");
                    GenerateExpression(e.SizeExpression);
                    Output.Write(") - 1");
                }
                else {
                    Output.Write(e.Size - 1);
                }
                Output.Write(") {}");
            }
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateBaseReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based base reference expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateBaseReferenceExpression(CodeBaseReferenceExpression e) {
            Output.Write("MyBase");
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateCastExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based cast expression representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateCastExpression(CodeCastExpression e) {
            Output.Write("CType(");
            GenerateExpression(e.Expression);
            Output.Write(",");
            OutputType(e.TargetType);
            OutputArrayPostfix(e.TargetType);
            Output.Write(")");
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateDelegateCreateExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based delegate creation expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateDelegateCreateExpression(CodeDelegateCreateExpression e) {
            Output.Write("AddressOf ");
            GenerateExpression(e.TargetObject);
            Output.Write(".");
            OutputIdentifier(e.MethodName);
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateFieldReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based field reference expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateFieldReferenceExpression(CodeFieldReferenceExpression e) {

            if (e.TargetObject != null) {
                GenerateExpression(e.TargetObject);
                Output.Write(".");
                Output.Write(e.FieldName);
            }
            else {
                OutputIdentifier(e.FieldName);
            }
        }

        protected override void GenerateSingleFloatValue(Single s) {
            Output.Write(s.ToString(CultureInfo.InvariantCulture));
            Output.Write('!');
        }

        protected override void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression e) {
            OutputIdentifier(e.ParameterName);
        }

        protected override void GenerateVariableReferenceExpression(CodeVariableReferenceExpression e) {
            OutputIdentifier(e.VariableName);
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateIndexerExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based indexer expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateIndexerExpression(CodeIndexerExpression e) {
            GenerateExpression(e.TargetObject);
            Output.Write("(");
            bool first = true;
            foreach(CodeExpression exp in e.Indices) {            
                if (first) {
                    first = false;
                }
                else {
                    Output.Write(", ");
                }
                GenerateExpression(exp);
            }
            Output.Write(")");

        }

        protected override void GenerateArrayIndexerExpression(CodeArrayIndexerExpression e) {
            GenerateExpression(e.TargetObject);
            Output.Write("(");
            bool first = true;
            foreach(CodeExpression exp in e.Indices) {            
                if (first) {
                    first = false;
                }
                else {
                    Output.Write(", ");
                }
                GenerateExpression(exp);
            }
            Output.Write(")");

        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateSnippetExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based code snippet expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateSnippetExpression(CodeSnippetExpression e) {
            Output.Write(e.Value);
        }
        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateMethodInvokeExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based method invoke
        ///       expression.
        ///    </para>
        /// </devdoc>
        protected override void GenerateMethodInvokeExpression(CodeMethodInvokeExpression e) {
            GenerateMethodReferenceExpression(e.Method);
            CodeExpressionCollection parameters = e.Parameters;
            if (parameters.Count > 0) {
                Output.Write("(");
                OutputExpressionList(e.Parameters);
                Output.Write(")");
            }
        }

        protected override void GenerateMethodReferenceExpression(CodeMethodReferenceExpression e) {
            if (e.TargetObject != null) {
                GenerateExpression(e.TargetObject);
                Output.Write(".");
                Output.Write(e.MethodName);
            }
            else {
                OutputIdentifier(e.MethodName);
            }
        }

        protected override void GenerateEventReferenceExpression(CodeEventReferenceExpression e) {
            if (e.TargetObject != null) {
                bool localReference = (e.TargetObject is CodeThisReferenceExpression);
                GenerateExpression(e.TargetObject);
                Output.Write(".");
                if (localReference) {
                    Output.Write(e.EventName + "Event");
                }
                else {
                    Output.Write(e.EventName);
                }
            }
            else {
                OutputIdentifier(e.EventName + "Event");
            }
        }

        private void GenerateFormalEventReferenceExpression(CodeEventReferenceExpression e) {
            if (e.TargetObject != null) {
                // Visual Basic Compiler does not like the me reference like this.
                if (!(e.TargetObject is CodeThisReferenceExpression)) {
                    GenerateExpression(e.TargetObject);
                    Output.Write(".");
                }
            }
            OutputIdentifier(e.EventName);
        }


        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateDelegateInvokeExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based delegate invoke
        ///       expression.
        ///    </para>
        /// </devdoc>
        protected override void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression e) {
            Output.Write("RaiseEvent ");
            if (e.TargetObject != null) {
                if (e.TargetObject is CodeEventReferenceExpression) {
                    GenerateFormalEventReferenceExpression((CodeEventReferenceExpression)e.TargetObject);
                }
                else {
                    GenerateExpression(e.TargetObject);
                }
            }
            CodeExpressionCollection parameters = e.Parameters;
            if (parameters.Count > 0) {
                Output.Write("(");
                OutputExpressionList(e.Parameters);
                Output.Write(")");
            }
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateObjectCreateExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based object creation
        ///       expression.
        ///    </para>
        /// </devdoc>
        protected override void GenerateObjectCreateExpression(CodeObjectCreateExpression e) {
            Output.Write("New ");
            OutputType(e.CreateType);
            CodeExpressionCollection parameters = e.Parameters;
            if (parameters.Count > 0) {
                Output.Write("(");
                OutputExpressionList(parameters);
                Output.Write(")");
            }
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateParameterDeclarationExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom
        ///       based parameter declaration expression representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e) {
            if (e.CustomAttributes.Count > 0) {
                OutputAttributes(e.CustomAttributes, true);
            }
            OutputDirection(e.Direction);
            OutputTypeNamePair(e.Type, e.Name);
        }

        protected override void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e) {
            Output.Write("value");
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateThisReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based this reference expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateThisReferenceExpression(CodeThisReferenceExpression e) {
            Output.Write("Me");
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateExpressionStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based method invoke statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateExpressionStatement(CodeExpressionStatement e) {
            GenerateExpression(e.Expression);
            Output.WriteLine("");
        }

        protected override void GenerateComment(CodeComment e) {
            Output.Write("'");
            Output.WriteLine(ConvertToCommentEscapeCodes(e.Text));
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateMethodReturnStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based method return statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateMethodReturnStatement(CodeMethodReturnStatement e) {
            if (e.Expression != null) {
                Output.Write("Return ");
                GenerateExpression(e.Expression);
                Output.WriteLine("");
            }
            else {
                Output.WriteLine("Return");
            }
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateConditionStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based if statement representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateConditionStatement(CodeConditionStatement e) {
            Output.Write("If ");
            GenerateExpression(e.Condition);
            Output.WriteLine(" Then");
            Indent++;
            GenerateStatements(e.TrueStatements);
            Indent--;

            CodeStatementCollection falseStatemetns = e.FalseStatements;
            if (falseStatemetns.Count > 0) {
                Output.Write("Else");
                Output.WriteLine("");
                Indent++;
                GenerateStatements(e.FalseStatements);
                Indent--;
            }
            Output.WriteLine("End If");
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateTryCatchFinallyStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based try catch finally statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e) {
            Output.WriteLine("Try ");
            Indent++;
            GenerateStatements(e.TryStatements);
            Indent--;
            CodeCatchClauseCollection catches = e.CatchClauses;
            if (catches.Count > 0) {
                IEnumerator en = catches.GetEnumerator();
                while (en.MoveNext()) {
                    CodeCatchClause current = (CodeCatchClause)en.Current;
                    Output.Write("Catch ");
                    OutputTypeNamePair(current.CatchExceptionType, current.LocalName);
                    Output.WriteLine("");
                    Indent++;
                    GenerateStatements(current.Statements);
                    Indent--;
                }
            }

            CodeStatementCollection finallyStatements = e.FinallyStatements;
            if (finallyStatements.Count > 0) {
                Output.WriteLine("Finally");
                Indent++;
                GenerateStatements(finallyStatements);
                Indent--;
            }
            Output.WriteLine("End Try");
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateAssignStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based assignment statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateAssignStatement(CodeAssignStatement e) {
            GenerateExpression(e.Left);
            Output.Write(" = ");
            GenerateExpression(e.Right);
            Output.WriteLine("");
        }

        protected override void GenerateAttachEventStatement(CodeAttachEventStatement e) {
            Output.Write("AddHandler ");
            GenerateFormalEventReferenceExpression(e.Event);
            Output.Write(", ");
            GenerateExpression(e.Listener);
            Output.WriteLine("");
        }

        protected override void GenerateRemoveEventStatement(CodeRemoveEventStatement e) {
            Output.Write("RemoveHandler ");
            GenerateFormalEventReferenceExpression(e.Event);
            Output.Write(", ");
            GenerateExpression(e.Listener);
            Output.WriteLine("");
        }

        protected override void GenerateSnippetStatement(CodeSnippetStatement e) {
            Output.WriteLine(e.Value);
        }

        protected override void GenerateGotoStatement(CodeGotoStatement e) {
            Output.Write("goto ");
            Output.WriteLine(e.Label);
        }

        protected override void GenerateLabeledStatement(CodeLabeledStatement e) {
            Indent--;
            Output.Write(e.Label);
            Output.WriteLine(":");
            Indent++;
            if (e.Statement != null) {
                GenerateStatement(e.Statement);
            }
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateVariableDeclarationStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom variable declaration statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement e) {
            Output.Write("Dim ");
            OutputTypeNamePair(e.Type, e.Name);
            if (e.InitExpression != null) {
                Output.Write(" = ");
                GenerateExpression(e.InitExpression);
            }
            Output.WriteLine("");
        }
        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateLinePragmaStart"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based line pragma start
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateLinePragmaStart(CodeLinePragma e) {
            Output.WriteLine("");
            Output.Write("#ExternalSource(\"");
            Output.Write(e.FileName);
            Output.Write("\",");
            Output.Write(e.LineNumber);
            Output.WriteLine(")");
        }
        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateLinePragmaEnd"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based line pragma end
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateLinePragmaEnd(CodeLinePragma e) {
            Output.WriteLine("");
            Output.WriteLine("#End ExternalSource");
        }


        protected override void GenerateEvent(CodeMemberEvent e, CodeTypeDeclaration c) {
            if (IsCurrentDelegate || IsCurrentEnum) return;

            if (e.CustomAttributes.Count > 0) {
                OutputAttributes(e.CustomAttributes, false);
            }

            OutputMemberAccessModifier(e.Attributes);
            Output.Write("Event ");
            OutputTypeNamePair(e.Type, e.Name);
            Output.WriteLine("");
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateField"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based member
        ///       field representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateField(CodeMemberField e) {
            if (IsCurrentDelegate || IsCurrentInterface) return;

            if (IsCurrentEnum) {
                if (e.CustomAttributes.Count > 0) {
                    OutputAttributes(e.CustomAttributes, false);
                }

                OutputIdentifier(e.Name);
                if (e.InitExpression != null) {
                    Output.Write(" = ");
                    GenerateExpression(e.InitExpression);
                }
                Output.WriteLine("");
            }
            else {
                if (e.CustomAttributes.Count > 0) {
                    OutputAttributes(e.CustomAttributes, false);
                }

                OutputMemberAccessModifier(e.Attributes);
                OutputVTableModifier(e.Attributes);
                OutputFieldScopeModifier(e.Attributes);

                OutputTypeNamePair(e.Type, e.Name);
                if (e.InitExpression != null) {
                    Output.Write(" = ");
                    GenerateExpression(e.InitExpression);
                }
                Output.WriteLine("");
            }
        }

        private bool MethodIsOverloaded(CodeMemberMethod e, CodeTypeDeclaration c) {
            if ((e.Attributes & MemberAttributes.Overloaded) != 0) {
                return true;
            }
            IEnumerator en = c.Members.GetEnumerator();
            while (en.MoveNext()) {
                if (!(en.Current is CodeMemberMethod))
                    continue;
                CodeMemberMethod meth = (CodeMemberMethod) en.Current;

                if (!(en.Current is CodeTypeConstructor)
                    && !(en.Current is CodeConstructor)
                    && meth != e
                    && meth.Name.Equals(e.Name)
                    && meth.PrivateImplementationType == null)
                {
                    return true;
                }
            }

            return false;
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateSnippetMember"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for
        ///       the specified CodeDom based snippet member representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateSnippetMember(CodeSnippetTypeMember e) {
            Output.Write(e.Text);
        }

        protected override void GenerateMethod(CodeMemberMethod e, CodeTypeDeclaration c) {
            if (!(IsCurrentClass || IsCurrentStruct || IsCurrentInterface)) return;

            if (e.CustomAttributes.Count > 0) {
                OutputAttributes(e.CustomAttributes, false);
            }

            // need to change the implements name before doing overloads resolution
            //
            string methodName = e.Name;
            if (e.PrivateImplementationType != null) {
                string impl = e.PrivateImplementationType.BaseType;
                impl = impl.Replace('.', '_');
                e.Name = impl + "_" + e.Name;
            }

            if (!IsCurrentInterface) {
                if (e.PrivateImplementationType == null) {
                    OutputMemberAccessModifier(e.Attributes);
                    if (MethodIsOverloaded(e, c))
                        Output.Write("Overloads ");
                }
                OutputVTableModifier(e.Attributes);
                OutputMemberScopeModifier(e.Attributes);
            }
            else {
                // interface may still need "Shadows"
                OutputVTableModifier(e.Attributes);
            }
            bool sub = false;
            if (e.ReturnType.BaseType.Length == 0 || string.Compare(e.ReturnType.BaseType, typeof(void).FullName, true, CultureInfo.InvariantCulture) == 0) {
                sub = true;
            }

            if (sub) {
                Output.Write("Sub ");
            }
            else {
                Output.Write("Function ");
            }


            OutputIdentifier(e.Name);
            Output.Write("(");
            OutputParameters(e.Parameters);
            Output.Write(")");

            if (!sub) {
                Output.Write(" As ");
                if (e.ReturnTypeCustomAttributes.Count > 0) {
                    OutputAttributes(e.ReturnTypeCustomAttributes, true);
                }

                OutputType(e.ReturnType);
                OutputArrayPostfix(e.ReturnType);
            }
            if (e.ImplementationTypes.Count > 0) {
                Output.Write(" Implements ");
                bool first = true;
                foreach (CodeTypeReference type in e.ImplementationTypes) {
                    if (first) {
                        first = false;
                    }   
                    else {
                        Output.Write(" , ");
                    }
                    OutputType(type);
                    Output.Write(".");
                    OutputIdentifier(methodName);
                }
            }
            else if (e.PrivateImplementationType != null) {
                Output.Write(" Implements ");
                OutputType(e.PrivateImplementationType);
                Output.Write(".");
                OutputIdentifier(methodName);
            }
            Output.WriteLine("");
            if (!IsCurrentInterface
                && (e.Attributes & MemberAttributes.ScopeMask) != MemberAttributes.Abstract) {
                Indent++;

                GenerateStatements(e.Statements);

                Indent--;
                if (sub) {
                    Output.WriteLine("End Sub");
                }
                else {
                    Output.WriteLine("End Function");
                }
            }
            // reset the name that possibly got changed with the implements clause
            e.Name = methodName;
        }

        protected override void GenerateEntryPointMethod(CodeEntryPointMethod e, CodeTypeDeclaration c) {
            Output.WriteLine("Public Shared Sub Main()");
            Indent++;

            GenerateStatements(e.Statements);

            Indent--;
            Output.WriteLine("End Sub");
        }

        private bool PropertyIsOverloaded(CodeMemberProperty e, CodeTypeDeclaration c) {
            if ((e.Attributes & MemberAttributes.Overloaded) != 0) {
                return true;
            }
            IEnumerator en = c.Members.GetEnumerator();
            while (en.MoveNext()) {
                if (!(en.Current is CodeMemberProperty))
                    continue;
                CodeMemberProperty prop = (CodeMemberProperty) en.Current;
                if ( prop != e
                    && prop.Name.Equals(e.Name)
                    && prop.PrivateImplementationType == null)
                {
                    return true;
                }
            }

            return false;
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateProperty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based member property
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateProperty(CodeMemberProperty e, CodeTypeDeclaration c) {
            if (!(IsCurrentClass || IsCurrentStruct || IsCurrentInterface)) return;

            if (e.CustomAttributes.Count > 0) {
                OutputAttributes(e.CustomAttributes, false);
            }

            string propName = e.Name;
            if (e.PrivateImplementationType != null)
            {
                string impl = e.PrivateImplementationType.BaseType;
                impl = impl.Replace('.', '_');
                e.Name = impl + "_" + e.Name;
            }
            if (!IsCurrentInterface) {
                if (e.PrivateImplementationType == null) {
                    OutputMemberAccessModifier(e.Attributes);
                    if (PropertyIsOverloaded(e,c)) {
                        Output.Write("Overloads ");
                    }
                }
                OutputVTableModifier(e.Attributes);
                OutputMemberScopeModifier(e.Attributes);
            }
            else {
                // interface may still need "Shadows"
                OutputVTableModifier(e.Attributes);
            }
            if (e.Parameters.Count > 0 && String.Compare(e.Name, "Item", true, CultureInfo.InvariantCulture) == 0) {
                Output.Write("Default ");
            }
            if (e.HasGet) {
                if (!e.HasSet) {
                    Output.Write("ReadOnly ");
                }
            }
            else if (e.HasSet) {
                Output.Write("WriteOnly ");
            }
            Output.Write("Property ");
            OutputIdentifier(e.Name);
            if (e.Parameters.Count > 0) {
                Output.Write("(");
                OutputParameters(e.Parameters);
                Output.Write(")");
            }
            Output.Write(" As ");
            OutputType(e.Type);
            OutputArrayPostfix(e.Type);

            if (e.ImplementationTypes.Count > 0) {
                Output.Write(" Implements ");
                bool first = true;
                foreach (CodeTypeReference type in e.ImplementationTypes) {
                    if (first) {
                        first = false;
                    }   
                    else {
                        Output.Write(" , ");
                    }
                    OutputType(type);
                    Output.Write(".");
                    OutputIdentifier(propName);
                }
            }
            else if (e.PrivateImplementationType != null) {
                Output.Write(" Implements ");
                OutputType(e.PrivateImplementationType);
                Output.Write(".");
                OutputIdentifier(propName);
            }

            Output.WriteLine("");

            if (!c.IsInterface) {
                Indent++;

                if (e.HasGet) {

                    Output.WriteLine("Get");
                    if (!IsCurrentInterface
                        && (e.Attributes & MemberAttributes.ScopeMask) != MemberAttributes.Abstract) {
                        Indent++;

                        GenerateStatements(e.GetStatements);
                        e.Name = propName;

                        Indent--;
                        Output.WriteLine("End Get");
                    }
                }
                if (e.HasSet) {
                    Output.WriteLine("Set");
                    if (!IsCurrentInterface
                        && (e.Attributes & MemberAttributes.ScopeMask) != MemberAttributes.Abstract) {
                        Indent++;
                        GenerateStatements(e.SetStatements);
                        Indent--;
                        Output.WriteLine("End Set");
                    }
                }
                Indent--;
                Output.WriteLine("End Property");
            }

            e.Name = propName;
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GeneratePropertyReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based property reference
        ///       expression representation.
        ///    </para>
        /// </devdoc>
        protected override void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression e) {

            if (e.TargetObject != null) {
                GenerateExpression(e.TargetObject);
                Output.Write(".");
                Output.Write(e.PropertyName);
            }
            else {
                OutputIdentifier(e.PropertyName);
            }
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateConstructor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based constructor
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateConstructor(CodeConstructor e, CodeTypeDeclaration c) {
            if (!(IsCurrentClass || IsCurrentStruct)) return;

            if (e.CustomAttributes.Count > 0) {
                OutputAttributes(e.CustomAttributes, false);
            }

            OutputMemberAccessModifier(e.Attributes);
            Output.Write("Sub New(");
            OutputParameters(e.Parameters);
            Output.WriteLine(")");
            Indent++;

            CodeExpressionCollection baseArgs = e.BaseConstructorArgs;
            CodeExpressionCollection thisArgs = e.ChainedConstructorArgs;

            if (thisArgs.Count > 0) {
                Output.Write("Me.New(");
                OutputExpressionList(thisArgs);
                Output.Write(")");
                Output.WriteLine("");                
            }
            else if (baseArgs.Count > 0) {
                Output.Write("MyBase.New(");
                OutputExpressionList(baseArgs);
                Output.Write(")");
                Output.WriteLine("");
            }
            else {
                Output.WriteLine("MyBase.New");
            }

            GenerateStatements(e.Statements);
            Indent--;
            Output.WriteLine("End Sub");
        }
        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateTypeConstructor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based class constructor
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateTypeConstructor(CodeTypeConstructor e) {
            if (!(IsCurrentClass || IsCurrentStruct)) return;

            Output.WriteLine("Shared Sub New()");
            Indent++;
            GenerateStatements(e.Statements);
            Indent--;
            Output.WriteLine("End Sub");
        }

        protected override void GenerateTypeOfExpression(CodeTypeOfExpression e) {
            Output.Write("GetType(");
            
            Output.Write(e.Type.BaseType);
            // replace std array syntax with ()
            OutputArrayPostfix(e.Type);
            Output.Write(")");
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateTypeStart"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the CodeDom based class start representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateTypeStart(CodeTypeDeclaration e) {
            if (IsCurrentDelegate) {
                if (e.CustomAttributes.Count > 0) {
                    OutputAttributes(e.CustomAttributes, false);
                }

                switch (e.TypeAttributes & TypeAttributes.VisibilityMask) {
                    case TypeAttributes.Public:
                        Output.Write("Public ");
                        break;
                    case TypeAttributes.NotPublic:
                    default:
                        break;
                }

                CodeTypeDelegate del = (CodeTypeDelegate)e;
                if (del.ReturnType.BaseType.Length > 0 && string.Compare(del.ReturnType.BaseType, "System.Void", true, CultureInfo.InvariantCulture) != 0)
                    Output.Write("Delegate Function ");
                else
                    Output.Write("Delegate Sub ");
                OutputIdentifier(e.Name);
                Output.Write("(");
                OutputParameters(del.Parameters);
                Output.Write(")");
                if (del.ReturnType.BaseType.Length > 0 && string.Compare(del.ReturnType.BaseType, "System.Void", true, CultureInfo.InvariantCulture) != 0) {
                    Output.Write(" As ");
                    OutputType(del.ReturnType);
                    OutputArrayPostfix(del.ReturnType);
                }
                Output.WriteLine("");
            }
            else if (e.IsEnum) {
                if (e.CustomAttributes.Count > 0) {
                    OutputAttributes(e.CustomAttributes, false);
                }
                OutputTypeAttributes(e);                                
                                
                OutputIdentifier(e.Name);

                if (e.BaseTypes.Count > 0) {
                    Output.Write(" As ");                    
                    OutputType(e.BaseTypes[0]);
                }

                Output.WriteLine("");
                Indent++;
            }
            else {                
                if (e.CustomAttributes.Count > 0) {
                    OutputAttributes(e.CustomAttributes, false);
                }
                OutputTypeAttributes(e);                                
                                
                OutputIdentifier(e.Name);

                bool writtenInherits = false;
                bool writtenImplements = false;
                // For a structure we can't have an inherits clause
                if (e.IsStruct) {
                    writtenInherits = true;
                }
                // For an interface we can't have an implements clause
                if (e.IsInterface) {
                    writtenImplements = true;
                }
                Indent++;
                foreach (CodeTypeReference typeRef in e.BaseTypes) {
                    if (!writtenInherits) {
                        Output.WriteLine("");
                        Output.Write("Inherits ");
                        writtenInherits = true;
                    }
                    else if (!writtenImplements) {
                        Output.WriteLine("");
                        Output.Write("Implements ");
                        writtenImplements = true;
                    }
                    else {
                        Output.Write(", ");
                    }                 
                    OutputType(typeRef);
                }

                Output.WriteLine("");
            }
        }
        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateTypeEnd"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based class end
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateTypeEnd(CodeTypeDeclaration e) {
            if (!IsCurrentDelegate) {
                Indent--;
                string ending;
                if (e.IsEnum) {
                    ending = "End Enum";
                }
                else if (e.IsInterface) {
                    ending = "End Interface";
                }
                else if (e.IsStruct) {
                    ending = "End Structure";
                } else {
                    ending = "End Class";
                }
                Output.WriteLine(ending);
            }
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateNamespace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the CodeDom based namespace representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateNamespace(CodeNamespace e) {

            if (GetUserData(e, "GenerateImports", true)) {
                GenerateNamespaceImports(e);
            }
            Output.WriteLine();
            GenerateCommentStatements(e.Comments);
            GenerateNamespaceStart(e);
            GenerateTypes(e);
            GenerateNamespaceEnd(e);
        }

        protected bool AllowLateBound(CodeCompileUnit e) {
            object o = e.UserData["AllowLateBound"];
            if (o != null && o is bool) {
                return (bool)o;
            }
            // We have Option Strict Off by default because it can fail on simple things like dividing
            // two integers.
            return true;
        }

        protected bool RequireVariableDeclaration(CodeCompileUnit e) {
            object o = e.UserData["RequireVariableDeclaration"];
            if (o != null && o is bool) {
                return (bool)o;
            }
            return true;
        }

        private bool GetUserData(CodeObject e, string property, bool defaultValue) {
            object o = e.UserData[property];
            if (o != null && o is bool) {
                return (bool)o;
            }
            return defaultValue;
        }

        protected override void GenerateCompileUnitStart(CodeCompileUnit e) {
            Output.WriteLine("'------------------------------------------------------------------------------");
            Output.WriteLine("' <autogenerated>");
            Output.WriteLine("'     This code was generated by a tool.");
            Output.WriteLine("'     Runtime Version: " + System.Environment.Version.ToString());
            Output.WriteLine("'");
            Output.WriteLine("'     Changes to this file may cause incorrect behavior and will be lost if ");
            Output.WriteLine("'     the code is regenerated.");
            Output.WriteLine("' </autogenerated>");
            Output.WriteLine("'------------------------------------------------------------------------------");
            Output.WriteLine("");

            if (AllowLateBound(e))
                Output.WriteLine("Option Strict Off");
            else
                Output.WriteLine("Option Strict On");

            if (!RequireVariableDeclaration(e))
                Output.WriteLine("Option Explicit Off");
            else
                Output.WriteLine("Option Explicit On");

            Output.WriteLine();

        }

        protected override void GenerateCompileUnit(CodeCompileUnit e) {
           
            GenerateCompileUnitStart(e);

            SortedList importList;            
            // Visual Basic needs all the imports together at the top of the compile unit.
            // If generating multiple namespaces, gather all the imports together
            importList = new SortedList(new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
            foreach (CodeNamespace nspace in e.Namespaces) {
                // mark the namespace to stop it generating its own import list
                nspace.UserData["GenerateImports"] = false;

                // Collect the unique list of imports
                foreach (CodeNamespaceImport import in nspace.Imports) {
                    if (!importList.Contains(import.Namespace)) {
                        importList.Add(import.Namespace, import.Namespace);
                    }
                }
            }
            // now output the imports
            foreach(string import in importList.Keys) {
                Output.Write("Imports ");
                OutputIdentifier(import);
                Output.WriteLine("");
            }

            if (e.AssemblyCustomAttributes.Count > 0) {
                OutputAttributes(e.AssemblyCustomAttributes, false, "Assembly: ", true);
            }


            GenerateNamespaces(e);
            GenerateCompileUnitEnd(e);
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateNamespaceStart"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based namespace representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateNamespaceStart(CodeNamespace e) {
            if (e.Name != null && e.Name.Length > 0) {
                Output.Write("Namespace ");
                OutputIdentifier(e.Name);
                Output.WriteLine();
                Indent++;
            }
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateNamespaceEnd"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based namespace representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateNamespaceEnd(CodeNamespace e) {
            if (e.Name != null && e.Name.Length > 0) {
                Indent--;
                Output.WriteLine("End Namespace");
            }
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateNamespaceImport"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based namespace import
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateNamespaceImport(CodeNamespaceImport e) {
            Output.Write("Imports ");
            OutputIdentifier(e.Namespace);
            Output.WriteLine("");
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateAttributeDeclarationsStart"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based attribute block start
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes) {
            Output.Write("<");
        }
        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.GenerateAttributeDeclarationsEnd"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based attribute block end
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected override void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes) {
            Output.Write(">");
        }

        public static bool IsKeyword(string value) {
            return FixedStringLookup.Contains(keywords, value, true);
        }

        protected override bool Supports(GeneratorSupport support) {
            return ((support & LanguageSupport) == support);
        }

        /// <include file='doc\VBCodeProvider.uex' path='docs/doc[@for="VBCodeGenerator.IsValidIdentifier"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets whether the specified identifier is valid.
        ///    </para>
        /// </devdoc>
        protected override bool IsValidIdentifier(string value) {

            // identifiers must be 1 char or longer
            //
            if (value == null || value.Length == 0) {
                return false;
            }

            // identifiers cannot be a keyword unless surrounded by []'s
            //
            if (value[0] != '[' || value[value.Length - 1] != ']') {
                if (IsKeyword(value)) {
                    return false;
                }
            } else {
                value = value.Substring(1, value.Length - 2);
            }
            return CodeGenerator.IsValidLanguageIndependentIdentifier(value);
        }

        protected override string CreateValidIdentifier(string name) {
            if (IsKeyword(name)) {
                return "_" + name;
            }
            return name;
        }

        protected override string CreateEscapedIdentifier(string name) {
            if (IsKeyword(name)) {
                return "[" + name + "]";
            }
            return name;
        }

        private string GetBaseTypeOutput(string baseType) {
            if (baseType.Length == 0) {
                return "Void";
            } 
            else if (string.Compare(baseType, "System.Byte", true, CultureInfo.InvariantCulture) == 0) {
                return "Byte";
            }
            else if (string.Compare(baseType, "System.Int16", true, CultureInfo.InvariantCulture) == 0) {
                return "Short";
            }
            else if (string.Compare(baseType, "System.Int32", true, CultureInfo.InvariantCulture) == 0) {
                return "Integer";
            }
            else if (string.Compare(baseType, "System.Int64", true, CultureInfo.InvariantCulture) == 0) {
                return "Long";
            }
            else if (string.Compare(baseType, "System.String", true, CultureInfo.InvariantCulture) == 0) {
                return "String";
            }
            else if (string.Compare(baseType, "System.DateTime", true, CultureInfo.InvariantCulture) == 0) {
                return "Date";
            }
            else if (string.Compare(baseType, "System.Decimal", true, CultureInfo.InvariantCulture) == 0) {
                return "Decimal";
            }
            else if (string.Compare(baseType, "System.Single", true, CultureInfo.InvariantCulture) == 0) {
                return "Single";
            }
            else if (string.Compare(baseType, "System.Double", true, CultureInfo.InvariantCulture) == 0) {
                return "Double";
            }
            else if (string.Compare(baseType, "System.Boolean", true, CultureInfo.InvariantCulture) == 0) {
                return "Boolean";
            }
            else if (string.Compare(baseType, "System.Char", true, CultureInfo.InvariantCulture) == 0) {
                return "Char";
            }
            else if (string.Compare(baseType, "System.Object", true, CultureInfo.InvariantCulture) == 0) {
                return "Object";
            }
            else {
                // replace + with . for nested classes.
                //
                baseType = baseType.Replace('+', '.');
                baseType = CreateEscapedIdentifier(baseType);
                return baseType;
            }
        }

        protected override string GetTypeOutput(CodeTypeReference typeRef) {
            string s = GetBaseTypeOutput(typeRef.BaseType);
            if (typeRef.ArrayRank > 0) {
                s += GetArrayPostfix(typeRef);
            }
            return s;
        }

        protected override void ContinueOnNewLine(string st) {
            Output.Write(st);
            Output.WriteLine(" _");
        }
    }

    /// <devdoc>
    ///      This type converter provides common values for MemberAttributes
    /// </devdoc>
    internal class VBMemberAttributeConverter : TypeConverter {
    
        private static string[] names;
        private static object[] values;
        private static VBMemberAttributeConverter defaultConverter;
        
        private VBMemberAttributeConverter() {
            // no  need to create an instance; use Default
        }
        
        public static VBMemberAttributeConverter Default {
            get {
                if (defaultConverter == null) {
                    defaultConverter = new VBMemberAttributeConverter();
                }
                return defaultConverter;
            }
        }
    
        /// <devdoc>
        ///      Retrieves an array of names for attributes.
        /// </devdoc>
        private string[] Names {
            get {
                if (names == null) {
                    names = new string[] {
                        "Public",
                        "Protected",
                        "Protected Friend",
                        "Friend",
                        "Private"
                    };
                }
                
                return names;
            }
        }
        
        /// <devdoc>
        ///      Retrieves an array of values for attributes.
        /// </devdoc>
        private object[] Values {
            get {
                if (values == null) {
                    values = new object[] {
                        (object)MemberAttributes.Public,
                        (object)MemberAttributes.Family,
                        (object)MemberAttributes.FamilyOrAssembly,
                        (object)MemberAttributes.Assembly,
                        (object)MemberAttributes.Private
                    };
                }
                
                return values;
            }
        }

        /// <devdoc>
        ///      We override this because we can convert from string types.
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            
            return base.CanConvertFrom(context, sourceType);
        }

        /// <devdoc>
        ///      Converts the given object to the converter's native type.
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                string name = (string)value;
                string[] names = Names;
                for (int i = 0; i < names.Length; i++) {
                    if (names[i].Equals(name)) {
                        return Values[i];
                    }
                }
            }
            
            return MemberAttributes.Private;
        }

        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }
            
            if (destinationType == typeof(string)) {
                object[] modifiers = Values;
                for (int i = 0; i < modifiers.Length; i++) {
                    if (modifiers[i].Equals(value)) {
                        return Names[i];
                    }
                }
                
                return SR.GetString(SR.toStringUnknown);
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\DesignerExtenders.uex' path='docs/doc[@for="DesignerExtenders.ModifierConverter.GetStandardValuesExclusive"]/*' />
        /// <devdoc>
        ///      Determines if the list of standard values returned from
        ///      GetStandardValues is an exclusive list.  If the list
        ///      is exclusive, then no other values are valid, such as
        ///      in an enum data type.  If the list is not exclusive,
        ///      then there are other valid values besides the list of
        ///      standard values GetStandardValues provides.
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return true;
        }
        
        /// <include file='doc\DesignerExtenders.uex' path='docs/doc[@for="DesignerExtenders.ModifierConverter.GetStandardValuesSupported"]/*' />
        /// <devdoc>
        ///      Determines if this object supports a standard set of values
        ///      that can be picked from a list.
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
        
        /// <include file='doc\DesignerExtenders.uex' path='docs/doc[@for="DesignerExtenders.ModifierConverter.GetStandardValues"]/*' />
        /// <devdoc>
        ///      Retrieves a collection containing a set of standard values
        ///      for the data type this validator is designed for.  This
        ///      will return null if the data type does not support a
        ///      standard set of values.
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) { 
            return new StandardValuesCollection(Values);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\win32\systemevents.cs ===
//------------------------------------------------------------------------------
// <copyright file="SystemEvents.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.Win32 {
    using System.Threading;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.Security;
    using System.Security.Permissions;
    using System.Collections;
    using System.ComponentModel;
    using System.Reflection;

    /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Provides a
    ///       set of global system events to callers. This
    ///       class cannot be inherited.</para>
    /// </devdoc>
    [
    // Disabling partial trust scenarios
    PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")
    ]
    public sealed class SystemEvents {

        // Almost all of our data is static.  We keep a single instance of
        // SystemEvents around so we can bind delegates to it.
        // Non-static methods in this class will only be called through
        // one of the delegates.
        //
        private static SystemEvents     systemEvents;
        private static Delegate[]       eventHandlers;
        private static Thread           windowThread;
        private static ManualResetEvent eventWindowReady;
        private static Random           randomTimerId = new Random();
        private static bool             startupRecreates;

        static string className = null;

        // cross-thread marshaling
        private static Queue            threadCallbackList; // list of Delegates
        private static int threadCallbackMessage = 0;
        private static ManualResetEvent eventThreadTerminated;

        // Per-instance data that is isolated to the window thread.
        //
        private IntPtr                  windowHandle;
        private NativeMethods.WndProc   windowProc;
        private NativeMethods.ConHndlr  consoleHandler;
        private IntPtr                  newStringPtr;
        
        // The set of events we respond to.  NOTE:  We use these
        // values as indexes into the eventHandlers array, so
        // be sure to update EventCount if you add or remove an
        // event.
        //
        private const int       OnUserPreferenceChangingEvent   = 0;
        private const int       OnUserPreferenceChangedEvent    = 1;
        private const int       OnSessionEndingEvent            = 2;
        private const int       OnSessionEndedEvent             = 3;
        private const int       OnPowerModeChangedEvent         = 4;
        private const int       OnLowMemoryEvent                = 5;
        private const int       OnDisplaySettingsChangedEvent   = 6;
        private const int       OnInstalledFontsChangedEvent    = 7;
        private const int       OnTimeChangedEvent              = 8;
        private const int       OnTimerElapsedEvent             = 9;
        private const int       OnPaletteChangedEvent           = 10;
        private const int       OnEventsThreadShutdownEvent     = 11;
        private const int       EventCount                      = 12;

        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.SystemEvents"]/*' />
        /// <devdoc>
        ///     This class is static, there is no need to ever create it.
        /// </devdoc>
        private SystemEvents() {
        }


        // stole from SystemInformation... if we get SystemInformation moved
        // to somewhere that we can use it... rip this!
        //
        private static IntPtr processWinStation = IntPtr.Zero;
        private static bool isUserInteractive = false;
        private static bool UserInteractive {
            get {

                // SECREVIEW : The Environment.OSVersion property getter Demands the 
                //           : EnvironmentPermission(PermissionState.Unrestricted) however,
                //           : we aren't exposing any of the OSVersion information to the 
                //           : user, so we can safely Assert the permission.
                //           :
                //           : Be careful not to expose any information from this property
                //           : to the user.
                //
                new EnvironmentPermission(PermissionState.Unrestricted).Assert();

                try {
                    if (Environment.OSVersion.Platform == System.PlatformID.Win32NT) {
                        IntPtr hwinsta = IntPtr.Zero;

                        hwinsta = UnsafeNativeMethods.GetProcessWindowStation();
                        if (hwinsta != IntPtr.Zero && processWinStation != hwinsta) {
                            isUserInteractive = true;

                            int lengthNeeded = 0;
                            NativeMethods.USEROBJECTFLAGS flags = new NativeMethods.USEROBJECTFLAGS();

                            if (UnsafeNativeMethods.GetUserObjectInformation(new HandleRef(null, hwinsta), NativeMethods.UOI_FLAGS, flags, Marshal.SizeOf(flags), ref lengthNeeded)) {
                                if ((flags.dwFlags & NativeMethods.WSF_VISIBLE) == 0) {
                                    isUserInteractive = false;
                                }
                            }
                            processWinStation = hwinsta;
                        }
                    }
                    else {
                        isUserInteractive = true;
                    }
                }
                finally {
                    System.Security.CodeAccessPermission.RevertAssert();
                }

                return isUserInteractive;
            }
        }


        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.DisplaySettingsChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the user changes the display settings.</para>
        /// </devdoc>
        public static event EventHandler DisplaySettingsChanged {
            add {
                AddEventHandler(OnDisplaySettingsChangedEvent, value);
            }
            remove {
                RemoveEventHandler(OnDisplaySettingsChangedEvent, value);
            }
        }


        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.EventsThreadShutdown"]/*' />
        /// <devdoc>
        ///    <para>Occurs before the thread that listens for system events is terminated.
        ///           Delegates will be invoked on the events thread.</para>
        /// </devdoc>
        public static event EventHandler EventsThreadShutdown {
            // Really only here for GDI+ initialization and shut down
            add {
                AddEventHandler(OnEventsThreadShutdownEvent, value);
            }
            remove {
                RemoveEventHandler(OnEventsThreadShutdownEvent, value);
            }
        }


        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.InstalledFontsChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the user adds fonts to or removes fonts from the system.</para>
        /// </devdoc>
        public static event EventHandler InstalledFontsChanged {
            add {
                AddEventHandler(OnInstalledFontsChangedEvent, value);
            }
            remove {
                RemoveEventHandler(OnInstalledFontsChangedEvent, value);
            }
        }


        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.LowMemory"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the system is running out of available RAM.</para>
        /// </devdoc>
        public static event EventHandler LowMemory {
            add {
                EnsureSystemEvents(true, true);
                AddEventHandler(OnLowMemoryEvent, value);
            }
            remove {
                RemoveEventHandler(OnLowMemoryEvent, value);
            }
        }


        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.PaletteChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the user switches to an application that uses a different 
        ///       palette.</para>
        /// </devdoc>
        public static event EventHandler PaletteChanged {
            add {
                AddEventHandler(OnPaletteChangedEvent, value);
            }
            remove {
                RemoveEventHandler(OnPaletteChangedEvent, value);
            }
        }


        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.PowerModeChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the user suspends or resumes the system.</para>
        /// </devdoc>
        public static event PowerModeChangedEventHandler PowerModeChanged {
            add {
                EnsureSystemEvents(true, true);
                AddEventHandler(OnPowerModeChangedEvent, value);
            }
            remove {
                RemoveEventHandler(OnPowerModeChangedEvent, value);
            }
        }


        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.SessionEnded"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the user is logging off or shutting down the system.</para>
        /// </devdoc>
        public static event SessionEndedEventHandler SessionEnded {
            add {
                EnsureSystemEvents(true, false);
                AddEventHandler(OnSessionEndedEvent, value);
            }
            remove {
                RemoveEventHandler(OnSessionEndedEvent, value);
            }
        }


        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.SessionEnding"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the user is trying to log off or shutdown the system.</para>
        /// </devdoc>
        public static event SessionEndingEventHandler SessionEnding {
            add {
                EnsureSystemEvents(true, false);
                AddEventHandler(OnSessionEndingEvent, value);
            }
            remove {
                RemoveEventHandler(OnSessionEndingEvent, value);
            }
        }


        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.TimeChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs when the user changes the time on the system clock.</para>
        /// </devdoc>
        public static event EventHandler TimeChanged {
            add {
                EnsureSystemEvents(true, false);
                AddEventHandler(OnTimeChangedEvent, value);
            }
            remove {
                RemoveEventHandler(OnTimeChangedEvent, value);
            }
        }


        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.TimerElapsed"]/*' />
        /// <devdoc>
        ///    <para>Occurs when a windows timer interval has expired.</para>
        /// </devdoc>
        public static event TimerElapsedEventHandler TimerElapsed {
            add {
                EnsureSystemEvents(true, false);
                AddEventHandler(OnTimerElapsedEvent, value);
            }
            remove {
                RemoveEventHandler(OnTimerElapsedEvent, value);
            }
        }


        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.UserPreferenceChanged"]/*' />
        /// <devdoc>
        ///    <para>Occurs when a user preference has changed.</para>
        /// </devdoc>
        public static event UserPreferenceChangedEventHandler UserPreferenceChanged {
            add {
                AddEventHandler(OnUserPreferenceChangedEvent, value);
            }
            remove {
                RemoveEventHandler(OnUserPreferenceChangedEvent, value);
            }
        }
        
        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.UserPreferenceChanging"]/*' />
        /// <devdoc>
        ///    <para>Occurs when a user preference is changing.</para>
        /// </devdoc>
        public static event UserPreferenceChangingEventHandler UserPreferenceChanging {
            add {
                AddEventHandler(OnUserPreferenceChangingEvent, value);
            }
            remove {
                RemoveEventHandler(OnUserPreferenceChangingEvent, value);
            }
        }

        private static void AddEventHandler(int key, Delegate value) {
            lock (typeof(SystemEvents)) {
                if (eventHandlers == null) {
                    eventHandlers = new Delegate[EventCount];
                    EnsureSystemEvents(false, false);
                }
                eventHandlers[key] = Delegate.Combine(eventHandlers[key], value);
            }
        }

        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.ConsoleHandlerProc"]/*' />
        /// <devdoc>
        ///      Console handler we add in case we are a console application or a service.
        ///      Without this we will not get end session events.
        /// </devdoc>
        private int ConsoleHandlerProc(int signalType) {

            switch (signalType) {
                case NativeMethods.CTRL_LOGOFF_EVENT:
                    OnSessionEnded(NativeMethods.WM_ENDSESSION, (IntPtr) 1, (IntPtr) NativeMethods.ENDSESSION_LOGOFF);
                    break;                

                case NativeMethods.CTRL_SHUTDOWN_EVENT:
                    OnSessionEnded(NativeMethods.WM_ENDSESSION, (IntPtr) 1, (IntPtr) 0);
                    break;                
            }

            return 0;
        }

        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.CreateBroadcastWindow"]/*' />
        /// <devdoc>
        ///      Goes through the work to register and create a window.
        /// </devdoc>
        private IntPtr CreateBroadcastWindow() {
            const string classNameFormat = ".NET-BroadcastEventWindow.{0}.{1}";

            // Register the window class.
            //
            IntPtr hInstance = UnsafeNativeMethods.GetModuleHandle(null);
            NativeMethods.WNDCLASS_I wndclassi = new NativeMethods.WNDCLASS_I();

            if (className == null) {
                // just overwrite the static... no need for guarding as everyone
                // in the AppDomain will create the exact same string.
                //
                className = string.Format(classNameFormat, ThisAssembly.Version, Convert.ToString(AppDomain.CurrentDomain.GetHashCode(), 16));
            }

            if (!UnsafeNativeMethods.GetClassInfo(new HandleRef(this, hInstance), className, wndclassi)) {
                NativeMethods.WNDCLASS wndclass = new NativeMethods.WNDCLASS();
                wndclass.hbrBackground  = (IntPtr) (NativeMethods.COLOR_WINDOW + 1);
                wndclass.style = 0;

                windowProc = new NativeMethods.WndProc(this.WindowProc);
                wndclass.lpszClassName = className;
                wndclass.lpfnWndProc = windowProc;
                wndclass.hInstance = hInstance;

                if (UnsafeNativeMethods.RegisterClass(wndclass) == 0) {
                    windowProc = null;
                    Debug.Fail("Unable to register broadcast window class");
                    return IntPtr.Zero;
                }
            }

            // And create an instance of the window.
            //
            IntPtr hwnd = UnsafeNativeMethods.CreateWindowEx(
                                                            0, 
                                                            className, 
                                                            className, 
                                                            NativeMethods.WS_POPUP,
                                                            0, 0, 0, 0, NativeMethods.NullHandleRef, NativeMethods.NullHandleRef, 
                                                            new HandleRef(this, hInstance), null);

            return hwnd;
        }

        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.CreateTimer"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Creates a new window timer asociated with the
        ///       system events window.</para>
        /// </devdoc>
        public static IntPtr CreateTimer(int interval) {
            if (interval <= 0)
                throw new ArgumentException("interval");

            EnsureSystemEvents(true, true);
            IntPtr timerId = UnsafeNativeMethods.SendMessage(new HandleRef(systemEvents, systemEvents.windowHandle), 
                                                             NativeMethods.WM_CREATETIMER, (IntPtr)interval, IntPtr.Zero);

            if (timerId == IntPtr.Zero)
                throw new ExternalException(SR.GetString(SR.ErrorCreateTimer));

            return timerId;                                                            
        }

        private void Dispose() {
            if (windowHandle != IntPtr.Zero) {
                IntPtr handle = windowHandle;
                windowHandle = IntPtr.Zero;
                
                // If DestroyWindow failed, it is because we're being
                // shutdown from another thread.  In this case, locate the
                // DefWindowProc call in User32, sling the window back to it,
                // and post a nice fat WM_CLOSE
                //
                if (!UnsafeNativeMethods.DestroyWindow(new HandleRef(this, handle))) {
                    
                    IntPtr defWindowProc;
                    string defproc = (Marshal.SystemDefaultCharSize == 1? "DefWindowProcA": "DefWindowProcW");
                        
                    defWindowProc = UnsafeNativeMethods.GetProcAddress(new HandleRef(this, UnsafeNativeMethods.GetModuleHandle("user32.dll")), defproc);
                    
                    if (defWindowProc != IntPtr.Zero) {
                        UnsafeNativeMethods.SetWindowLong(new HandleRef(this, handle), NativeMethods.GWL_WNDPROC, new HandleRef(this, defWindowProc));
                    }
                    
                    UnsafeNativeMethods.PostMessage(new HandleRef(this, handle), NativeMethods.WM_CLOSE, IntPtr.Zero, IntPtr.Zero);
                }
                else {
                    IntPtr hInstance = UnsafeNativeMethods.GetModuleHandle(null);
                    UnsafeNativeMethods.UnregisterClass(className, new HandleRef(this, hInstance));
                }
            }

            if (consoleHandler != null) {
                UnsafeNativeMethods.SetConsoleCtrlHandler(consoleHandler, 0);
                consoleHandler = null;
            }
        }

        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.EnsureSystemEvents"]/*' />
        /// <devdoc>
        ///  Creates the static resources needed by 
        ///  system events.
        /// </devdoc>
        private static void EnsureSystemEvents(bool requireHandle, bool throwOnRefusal) {
        
            // The secondary check here is to detect asp.net.  Asp.net uses multiple
            // app domains to field requests and we do not want to gobble up an 
            // additional thread per domain.  So under this scenario SystemEvents
            // becomes a nop.
            //
            if (systemEvents == null) {

                if (Thread.GetDomain().GetData(".appDomain") != null) {
                    if (throwOnRefusal) {
                        throw new InvalidOperationException(SR.GetString(SR.ErrorSystemEventsNotSupported));
                    }
                    return;
                }

                // If we are creating system events on a thread declared as STA, then
                // just share the thread.
                //
                if (!UserInteractive || Thread.CurrentThread.ApartmentState == ApartmentState.STA) {
                    systemEvents = new SystemEvents();
                    systemEvents.Initialize();
                }
                else {
                    eventWindowReady = new ManualResetEvent(false);
                    systemEvents = new SystemEvents();
                    windowThread = new Thread(new ThreadStart(systemEvents.WindowThreadProc));
                    windowThread.IsBackground = true;
                    windowThread.Name = ".NET SystemEvents";
                    windowThread.Start();
                    eventWindowReady.WaitOne();
                }
                
                if (requireHandle && systemEvents.windowHandle == IntPtr.Zero) {
                    // In theory, it's not the end of the world that
                    // we don't get system events.  Unfortunately, the main reason windowHandle == 0
                    // is CreateWindowEx failed for mysterious reasons, and when that happens,
                    // subsequent (and more important) CreateWindowEx calls also fail.
                    // See ASURT #44424 for a rather lengthy discussion of this.
                    throw new ExternalException(SR.GetString(SR.ErrorCreateSystemEvents));
                }

                startupRecreates = false;
            }
        }                            

        private static Delegate GetEventHandler(int key) {
            lock (typeof(SystemEvents)) {
                if (eventHandlers == null)
                    return null;
                else
                    return(Delegate)eventHandlers[key];
            }
        }
        
        private UserPreferenceCategory GetUserPreferenceCategory(int msg, IntPtr wParam, IntPtr lParam) {
        
            UserPreferenceCategory pref = UserPreferenceCategory.General;

            if (msg == NativeMethods.WM_SETTINGCHANGE) {
            
                if (lParam != IntPtr.Zero && Marshal.PtrToStringAuto(lParam).Equals("Policy")) {
                    pref = UserPreferenceCategory.Policy;
                }
                else if (lParam != IntPtr.Zero && Marshal.PtrToStringAuto(lParam).Equals("intl")) {
                    pref = UserPreferenceCategory.Locale;
                }
                else {
                    switch ((int) wParam) {
                        case NativeMethods.SPI_SETACCESSTIMEOUT:
                        case NativeMethods.SPI_SETFILTERKEYS:
                        case NativeMethods.SPI_SETHIGHCONTRAST:
                        case NativeMethods.SPI_SETMOUSEKEYS:
                        case NativeMethods.SPI_SETSCREENREADER:
                        case NativeMethods.SPI_SETSERIALKEYS:
                        case NativeMethods.SPI_SETSHOWSOUNDS:
                        case NativeMethods.SPI_SETSOUNDSENTRY:
                        case NativeMethods.SPI_SETSTICKYKEYS:
                        case NativeMethods.SPI_SETTOGGLEKEYS:
                            pref = UserPreferenceCategory.Accessibility;
                            break;

                        case NativeMethods.SPI_SETDESKWALLPAPER:
                        case NativeMethods.SPI_SETFONTSMOOTHING:
                        case NativeMethods.SPI_SETCURSORS:
                        case NativeMethods.SPI_SETDESKPATTERN:
                        case NativeMethods.SPI_SETGRIDGRANULARITY:
                        case NativeMethods.SPI_SETWORKAREA:
                            pref = UserPreferenceCategory.Desktop;
                            break;

                        case NativeMethods.SPI_ICONHORIZONTALSPACING:
                        case NativeMethods.SPI_ICONVERTICALSPACING:
                        case NativeMethods.SPI_SETICONMETRICS:
                        case NativeMethods.SPI_SETICONS:
                        case NativeMethods.SPI_SETICONTITLELOGFONT:
                        case NativeMethods.SPI_SETICONTITLEWRAP:
                            pref = UserPreferenceCategory.Icon;
                            break;

                        case NativeMethods.SPI_SETDOUBLECLICKTIME:
                        case NativeMethods.SPI_SETDOUBLECLKHEIGHT:
                        case NativeMethods.SPI_SETDOUBLECLKWIDTH:
                        case NativeMethods.SPI_SETMOUSE:
                        case NativeMethods.SPI_SETMOUSEBUTTONSWAP:
                        case NativeMethods.SPI_SETMOUSEHOVERHEIGHT:
                        case NativeMethods.SPI_SETMOUSEHOVERTIME:
                        case NativeMethods.SPI_SETMOUSESPEED:
                        case NativeMethods.SPI_SETMOUSETRAILS:
                        case NativeMethods.SPI_SETSNAPTODEFBUTTON:
                        case NativeMethods.SPI_SETWHEELSCROLLLINES:
                        case NativeMethods.SPI_SETCURSORSHADOW:
                        case NativeMethods.SPI_SETHOTTRACKING:
                        case NativeMethods.SPI_SETTOOLTIPANIMATION:
                        case NativeMethods.SPI_SETTOOLTIPFADE:
                            pref = UserPreferenceCategory.Mouse;
                            break;

                        case NativeMethods.SPI_SETKEYBOARDDELAY:
                        case NativeMethods.SPI_SETKEYBOARDPREF:
                        case NativeMethods.SPI_SETKEYBOARDSPEED:
                        case NativeMethods.SPI_SETLANGTOGGLE:
                            pref = UserPreferenceCategory.Keyboard;
                            break;

                        case NativeMethods.SPI_SETMENUDROPALIGNMENT:
                        case NativeMethods.SPI_SETMENUFADE:
                        case NativeMethods.SPI_SETMENUSHOWDELAY:
                        case NativeMethods.SPI_SETMENUANIMATION:
                        case NativeMethods.SPI_SETSELECTIONFADE:
                            pref = UserPreferenceCategory.Menu;
                            break;

                        case NativeMethods.SPI_SETLOWPOWERACTIVE:
                        case NativeMethods.SPI_SETLOWPOWERTIMEOUT:
                        case NativeMethods.SPI_SETPOWEROFFACTIVE:
                        case NativeMethods.SPI_SETPOWEROFFTIMEOUT:
                            pref = UserPreferenceCategory.Power;
                            break;

                        case NativeMethods.SPI_SETSCREENSAVEACTIVE:
                        case NativeMethods.SPI_SETSCREENSAVERRUNNING:
                        case NativeMethods.SPI_SETSCREENSAVETIMEOUT:
                            pref = UserPreferenceCategory.Screensaver;
                            break;

                        case NativeMethods.SPI_SETKEYBOARDCUES:
                        case NativeMethods.SPI_SETCOMBOBOXANIMATION:
                        case NativeMethods.SPI_SETLISTBOXSMOOTHSCROLLING:
                        case NativeMethods.SPI_SETGRADIENTCAPTIONS:
                        case NativeMethods.SPI_SETUIEFFECTS:
                        case NativeMethods.SPI_SETACTIVEWINDOWTRACKING:
                        case NativeMethods.SPI_SETACTIVEWNDTRKZORDER:
                        case NativeMethods.SPI_SETACTIVEWNDTRKTIMEOUT:
                        case NativeMethods.SPI_SETANIMATION:
                        case NativeMethods.SPI_SETBORDER:
                        case NativeMethods.SPI_SETCARETWIDTH:
                        case NativeMethods.SPI_SETDRAGFULLWINDOWS:
                        case NativeMethods.SPI_SETDRAGHEIGHT:
                        case NativeMethods.SPI_SETDRAGWIDTH:
                        case NativeMethods.SPI_SETFOREGROUNDFLASHCOUNT:
                        case NativeMethods.SPI_SETFOREGROUNDLOCKTIMEOUT:
                        case NativeMethods.SPI_SETMINIMIZEDMETRICS:
                        case NativeMethods.SPI_SETNONCLIENTMETRICS:
                        case NativeMethods.SPI_SETSHOWIMEUI:
                            pref = UserPreferenceCategory.Window;
                            break;
                    }
                }
            }
            else if (msg == NativeMethods.WM_SYSCOLORCHANGE) {
                pref = UserPreferenceCategory.Color;
            }
            else {
                Debug.Fail("Unrecognized message passed to UserPreferenceCategory");                
            }
            
            return pref;
        }

        private void Initialize() {
            consoleHandler = new NativeMethods.ConHndlr(this.ConsoleHandlerProc);
            if (!UnsafeNativeMethods.SetConsoleCtrlHandler(consoleHandler, 1)) {
                Debug.Fail("Failed to install console handler.");
                consoleHandler = null;
            }

            if (UserInteractive) {
                windowHandle = CreateBroadcastWindow();
                Debug.Assert(windowHandle != IntPtr.Zero, "CreateBroadcastWindow failed");

                AppDomain.CurrentDomain.ProcessExit += new EventHandler(SystemEvents.Shutdown);
                AppDomain.CurrentDomain.DomainUnload += new EventHandler(SystemEvents.Shutdown);
            }
        }
        
        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.InvokeMarshaledCallbacks"]/*' />
        /// <devdoc>
        ///     Called on the control's owning thread to perform the actual callback.
        ///     This empties this control's callback queue, propagating any excpetions
        ///     back as needed.
        /// </devdoc>
        private void InvokeMarshaledCallbacks() {
            Debug.Assert(threadCallbackList != null, "Invoking marshaled callbacks before there are any");

            Delegate current = null;
            lock (threadCallbackList) {
                if (threadCallbackList.Count > 0) {
                    current = (Delegate)threadCallbackList.Dequeue();
                }
            }

            // Now invoke on all the queued items.
            //
            while (current != null) {
                try {
                    // Optimize a common case of using EventHandler. This allows us to invoke
                    // early bound, which is a bit more efficient.
                    //
                    if (current is EventHandler) {
                        ((EventHandler)current).Invoke(null, EventArgs.Empty);
                    }
                    else {
                        current.DynamicInvoke(new object[0]);
                    }
                }
                catch (Exception t) {
                    Debug.Fail("SystemEvents marshaled callback failed:" + t);
                }
                lock (threadCallbackList) {
                    if (threadCallbackList.Count > 0) {
                        current = (Delegate)threadCallbackList.Dequeue();
                    }
                    else {
                        current = null;
                    }               
                }
            }
        }

        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.InvokeOnEventsThread"]/*' />
        /// <devdoc>
        ///     Executes the given delegate on the thread that listens for system events.  Similar to Control.Invoke().
        /// </devdoc>
        public static void InvokeOnEventsThread(Delegate method) {
            // This method is really only here for GDI+ initialization/shutdown
            EnsureSystemEvents(true, true);

#if DEBUG
            int pid;
            int thread = SafeNativeMethods.GetWindowThreadProcessId(new HandleRef(systemEvents, systemEvents.windowHandle), out pid);
            Debug.Assert(windowThread == null || thread != SafeNativeMethods.GetCurrentThreadId(), "Don't call MarshaledInvoke on the system events thread");
#endif

            if (threadCallbackList == null) {
                lock (typeof(SystemEvents)) {
                    if (threadCallbackList == null) {
                        threadCallbackList = new Queue();
                        threadCallbackMessage = SafeNativeMethods.RegisterWindowMessage("SystemEventsThreadCallbackMessage");
                    }
                }
            }

            Debug.Assert(threadCallbackMessage != 0, "threadCallbackList initialized but threadCallbackMessage not?");

            lock (threadCallbackList) {
                threadCallbackList.Enqueue(method);
            }           

            UnsafeNativeMethods.PostMessage(new HandleRef(systemEvents, systemEvents.windowHandle), threadCallbackMessage, IntPtr.Zero, IntPtr.Zero);
        }

        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.KillTimer"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Kills the timer specified by the given id.</para>
        /// </devdoc>
        public static void KillTimer(IntPtr timerId) {
            EnsureSystemEvents(true, true);
            if (systemEvents.windowHandle != IntPtr.Zero) {
                int res = (int) UnsafeNativeMethods.SendMessage(new HandleRef(systemEvents, systemEvents.windowHandle),
                                                                NativeMethods.WM_KILLTIMER, timerId, IntPtr.Zero);

                if (res == 0)
                    throw new ExternalException(SR.GetString(SR.ErrorKillTimer));
            }
        }

        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.OnCreateTimer"]/*' />
        /// <devdoc>
        ///      Callback that handles the create timer
        ///      user message.
        /// </devdoc>
        private IntPtr OnCreateTimer(int msg, IntPtr wParam, IntPtr lParam) {
            IntPtr timerId = (IntPtr) randomTimerId.Next();
            IntPtr res = UnsafeNativeMethods.SetTimer(new HandleRef(this, windowHandle), new HandleRef(this, timerId), (int) wParam, NativeMethods.NullHandleRef);
            return(res == IntPtr.Zero ? IntPtr.Zero: timerId);              
        }

        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.OnGenericEvent"]/*' />
        /// <devdoc>
        ///      Handler for any event that fires a standard EventHandler delegate.
        /// </devdoc>
        private void OnGenericEvent(int eventKey, int msg, IntPtr wParam, IntPtr lParam) {
            Delegate handler = GetEventHandler(eventKey);

            if (handler != null) {
                object[] args = new object[] {null, EventArgs.Empty};
                SystemEvent evt = new SystemEvent(handler, args);
                QueueEvent(evt);
            }
        }

        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.OnKillTimer"]/*' />
        /// <devdoc>
        ///      Callback that handles the KillTimer
        ///      user message.        
        /// </devdoc>
        private bool OnKillTimer(int msg, IntPtr wParam, IntPtr lParam) {
            bool res = UnsafeNativeMethods.KillTimer(new HandleRef(this, windowHandle), new HandleRef(this, wParam));
            return res;           
        }                                                       

        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.OnPowerModeChanged"]/*' />
        /// <devdoc>
        ///      Handler for WM_POWERBROADCAST.
        /// </devdoc>
        private void OnPowerModeChanged(int msg, IntPtr wParam, IntPtr lParam) {
            Delegate handler = GetEventHandler(OnPowerModeChangedEvent);

            if (handler != null) {

                PowerModes mode;

                switch ((int) wParam) {
                    case NativeMethods.PBT_APMSUSPEND:
                    case NativeMethods.PBT_APMSTANDBY:
                        mode = PowerModes.Suspend;
                        break;

                    case NativeMethods.PBT_APMRESUMECRITICAL:
                    case NativeMethods.PBT_APMRESUMESUSPEND:
                    case NativeMethods.PBT_APMRESUMESTANDBY:
                        mode = PowerModes.Resume;
                        break;

                    case NativeMethods.PBT_APMBATTERYLOW:
                    case NativeMethods.PBT_APMPOWERSTATUSCHANGE:
                    case NativeMethods.PBT_APMOEMEVENT:
                        mode = PowerModes.StatusChange;
                        break;

                    default:
                        return;
                }

                object[] args = new object[] {null, new PowerModeChangedEventArgs(mode)};
                SystemEvent evt = new SystemEvent(handler, args);
                QueueEvent(evt);
            }
        }

        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.OnSessionEnded"]/*' />
        /// <devdoc>
        ///      Handler for WM_ENDSESSION.
        /// </devdoc>
        private void OnSessionEnded(int msg, IntPtr wParam, IntPtr lParam) {

            // wParam will be nonzero if the session is actually ending.  If
            // it was canceled then we do not want to raise the event.
            //
            if (wParam != (IntPtr) 0) {
                Delegate handler = GetEventHandler(OnSessionEndedEvent);

                if (handler != null) {

                    SessionEndReasons reason = SessionEndReasons.SystemShutdown;

                    if ((((int) lParam) & NativeMethods.ENDSESSION_LOGOFF) != 0) {
                        reason = SessionEndReasons.Logoff;
                    }

                    SessionEndedEventArgs endEvt = new SessionEndedEventArgs(reason);
                    object[] args = new object[] {null, endEvt};
                    SystemEvent evt = new SystemEvent(handler, args);
                    QueueEvent(evt);
                }
            }
        }

        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.OnSessionEnding"]/*' />
        /// <devdoc>
        ///      Handler for WM_QUERYENDSESSION.
        /// </devdoc>
        private int OnSessionEnding(int msg, IntPtr wParam, IntPtr lParam) {
            int endOk = 1;
            Delegate handler = GetEventHandler(OnSessionEndingEvent);

            if (handler != null) {

                SessionEndReasons reason = SessionEndReasons.SystemShutdown;

                if ((((int)lParam) & NativeMethods.ENDSESSION_LOGOFF) != 0) {
                    reason = SessionEndReasons.Logoff;
                }

                SessionEndingEventArgs endEvt = new SessionEndingEventArgs(reason);
                object[] args = new object[] {null, endEvt};
                SystemEvent evt = new SystemEvent(handler, args);
                QueueEvent(evt);
                endOk = (endEvt.Cancel ? 0 : 1);
            }

            return endOk;
        }

        /// <devdoc>
        ///      Handler for WM_THEMECHANGED
        /// </devdoc>
        private void OnThemeChanged(int msg, IntPtr wParam, IntPtr lParam) {
            Delegate handler = GetEventHandler(OnUserPreferenceChangedEvent);
            if (handler != null) {
                UserPreferenceCategory pref = UserPreferenceCategory.Window;
                object[] args = new object[] {null, new UserPreferenceChangedEventArgs(pref)};
            
                QueueEvent(new SystemEvent(handler, args));
            }
        }

        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.OnUserPreferenceChanged"]/*' />
        /// <devdoc>
        ///      Handler for WM_SETTINGCHANGE and WM_SYSCOLORCHANGE.
        /// </devdoc>
        private void OnUserPreferenceChanged(int msg, IntPtr wParam, IntPtr lParam) {
            Delegate handler = GetEventHandler(OnUserPreferenceChangedEvent);

            if (handler != null) {

                UserPreferenceCategory pref = GetUserPreferenceCategory(msg, wParam, lParam);

                object[] args = new object[] {null, new UserPreferenceChangedEventArgs(pref)};
                SystemEvent evt = new SystemEvent(handler, args);
                QueueEvent(evt);
            }
        }
        
        private void OnUserPreferenceChanging(int msg, IntPtr wParam, IntPtr lParam) {
            Delegate handler = GetEventHandler(OnUserPreferenceChangingEvent);

            if (handler != null) {

                UserPreferenceCategory pref = GetUserPreferenceCategory(msg, wParam, lParam);

                object[] args = new object[] {null, new UserPreferenceChangingEventArgs(pref)};
                SystemEvent evt = new SystemEvent(handler, args);
                QueueEvent(evt);
            }
        }

        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.OnTimerElapsed"]/*' />
        /// <devdoc>
        ///      Handler for WM_TIMER.
        /// </devdoc>
        private void OnTimerElapsed(int msg, IntPtr wParam, IntPtr lParam) {
            Delegate handler = GetEventHandler(OnTimerElapsedEvent);

            if (handler != null) {
                object[] args = new object[] {null, new TimerElapsedEventArgs(wParam)};
                SystemEvent evt = new SystemEvent(handler, args);
                QueueEvent(evt);
            }
        }

        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.QueueEvent"]/*' />
        /// <devdoc>
        ///      Queues the given event onto the event queue.
        /// </devdoc>
        private void QueueEvent(SystemEvent evt) {
            try {
                evt.Result = evt.Delegate.DynamicInvoke(evt.Arguments);
            }
            catch (Exception eEvent) {
                if (eEvent is TargetInvocationException) {
                    Debug.Fail("Event handler threw an exception.  This is a bug in the event handler, NOT in the SystemEvents class.", eEvent.InnerException.ToString());
                }
                else {
                    Debug.Fail("Dynamic invoke in system events dispatch thread caused an exception.", eEvent.ToString());
                }
            }
        }

        private static void RemoveEventHandler(int key, Delegate value) {
            lock (typeof(SystemEvents)) {
                if (eventHandlers != null) {
                    eventHandlers[key] = Delegate.Remove(eventHandlers[key], value);
                }
            }
        }

        /// <devdoc>
        ///     This method is invoked via reflection from windows forms.  Why?  Because when the runtime is hosted in IE,
        ///     IE doesn't tell it when to shut down.  The first notification the runtime gets is 
        ///     DLL_PROCESS_DETACH, at which point it is too late for us to run any managed code.  But,
        ///     if we don't destroy our system events window the HWND will fault if it
        ///     receives a message after the runtime shuts down.  So it is imparative that
        ///     we destroy the window, but it is also necessary to recreate the window on demand.
        ///     That's hard to do, because we originally created it in response to an event
        ///     wire-up, but that event is still bound so technically we should still have the
        ///     window around.  To work around this crashing fiasco, we have special code
        ///     in the ActiveXImpl class within Control.  This code checks to see if it is running
        ///     inside of IE, and if so, it will invoke these methods via private reflection.
        ///     It will invoke Shutdown when the last active X control is destroyed, and then
        ///     call Startup with the first activeX control is recreated.  
        /// </devdoc>
        private static void Startup() {
            if (startupRecreates) {
                EnsureSystemEvents(false, false);
            }
        }

        /// <devdoc>
        ///     This method is invoked via reflection from windows forms.  Why?  Because when the runtime is hosted in IE,
        ///     IE doesn't tell it when to shut down.  The first notification the runtime gets is 
        ///     DLL_PROCESS_DETACH, at which point it is too late for us to run any managed code.  But,
        ///     if we don't destroy our system events window the HWND will fault if it
        ///     receives a message after the runtime shuts down.  So it is imparative that
        ///     we destroy the window, but it is also necessary to recreate the window on demand.
        ///     That's hard to do, because we originally created it in response to an event
        ///     wire-up, but that event is still bound so technically we should still have the
        ///     window around.  To work around this crashing fiasco, we have special code
        ///     in the ActiveXImpl class within Control.  This code checks to see if it is running
        ///     inside of IE, and if so, it will invoke these methods via private reflection.
        ///     It will invoke Shutdown when the last active X control is destroyed, and then
        ///     call Startup with the first activeX control is recreated.  
        /// </devdoc>
        private static void Shutdown() {
            if (systemEvents != null && systemEvents.windowHandle != IntPtr.Zero) {

                startupRecreates = true;
            
                // If we are using system events from another thread, request that it terminate
                //
                if (windowThread != null) {
                    eventThreadTerminated = new ManualResetEvent(false);
    
                    int pid;
                    int thread = SafeNativeMethods.GetWindowThreadProcessId(new HandleRef(systemEvents, systemEvents.windowHandle), out pid);
                    Debug.Assert(thread != SafeNativeMethods.GetCurrentThreadId(), "Don't call Shutdown on the system events thread");
                    UnsafeNativeMethods.PostMessage(new HandleRef(systemEvents, systemEvents.windowHandle), NativeMethods.WM_QUIT, IntPtr.Zero, IntPtr.Zero);
    
                    eventThreadTerminated.WaitOne();
                }
                else {
                    systemEvents.Dispose();
                    systemEvents = null;
                }
            }
        }
        
        private static void Shutdown(object sender, EventArgs e) {
            Shutdown();
        }
        
        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.WindowProc"]/*' />
        /// <devdoc>
        ///      A standard Win32 window proc for our broadcast window.
        /// </devdoc>
        private IntPtr WindowProc(IntPtr hWnd, int msg, IntPtr wParam, IntPtr lParam) {
        
            switch (msg) {
                case NativeMethods.WM_SETTINGCHANGE:
                    string newString;
                    newStringPtr = lParam;
                    if (lParam != IntPtr.Zero) {
                        newString = Marshal.PtrToStringAuto(lParam);
                        if (newString != null) {
                            newStringPtr = Marshal.StringToHGlobalAuto(newString);
                        }
                    }
                    bool retval = UnsafeNativeMethods.PostMessage(new HandleRef(this, windowHandle), NativeMethods.WM_REFLECT + msg, wParam, newStringPtr);
                    break;
                case NativeMethods.WM_SYSCOLORCHANGE:                    
                case NativeMethods.WM_POWERBROADCAST:
                case NativeMethods.WM_COMPACTING:
                case NativeMethods.WM_DISPLAYCHANGE:
                case NativeMethods.WM_FONTCHANGE:
                case NativeMethods.WM_PALETTECHANGED:
                case NativeMethods.WM_TIMECHANGE:
                case NativeMethods.WM_TIMER:
                case NativeMethods.WM_THEMECHANGED:
                    UnsafeNativeMethods.PostMessage(new HandleRef(this, windowHandle), NativeMethods.WM_REFLECT + msg, wParam, lParam);
                    break;
            
                case NativeMethods.WM_CREATETIMER:
                    return OnCreateTimer(msg, wParam, lParam);

                case NativeMethods.WM_KILLTIMER:
                    return (IntPtr)(OnKillTimer(msg, wParam, lParam) ? 1 : 0);

                case NativeMethods.WM_REFLECT + NativeMethods.WM_SETTINGCHANGE:
                    OnUserPreferenceChanging(msg - NativeMethods.WM_REFLECT, wParam, lParam);
                    OnUserPreferenceChanged(msg - NativeMethods.WM_REFLECT, wParam, lParam);
                    try {
                        if (newStringPtr != IntPtr.Zero) {
                            Marshal.FreeHGlobal(newStringPtr);
                            newStringPtr = IntPtr.Zero;
                        }
                    }
                    catch (Exception e) {
                        Debug.Assert(false, "Exception occurred while freeing memory: " + e.ToString());
                    }
                    break;
                    
                case NativeMethods.WM_REFLECT + NativeMethods.WM_SYSCOLORCHANGE:
                    OnUserPreferenceChanging(msg - NativeMethods.WM_REFLECT, wParam, lParam);
                    OnUserPreferenceChanged(msg - NativeMethods.WM_REFLECT, wParam, lParam);
                    break;
                
                case NativeMethods.WM_REFLECT + NativeMethods.WM_THEMECHANGED:
                    OnThemeChanged(msg - NativeMethods.WM_REFLECT, wParam, lParam);
                    break;

                case NativeMethods.WM_QUERYENDSESSION:
                    return(IntPtr) OnSessionEnding(msg, wParam, lParam);

                case NativeMethods.WM_ENDSESSION:
                    OnSessionEnded(msg, wParam, lParam);
                    break;

                case NativeMethods.WM_REFLECT + NativeMethods.WM_POWERBROADCAST:
                    OnPowerModeChanged(msg - NativeMethods.WM_REFLECT, wParam, lParam);
                    break;

                    // WM_HIBERNATE on WinCE
                case NativeMethods.WM_REFLECT + NativeMethods.WM_COMPACTING:
                    OnGenericEvent(OnLowMemoryEvent, msg - NativeMethods.WM_REFLECT, wParam, lParam);
                    break;

                case NativeMethods.WM_REFLECT + NativeMethods.WM_DISPLAYCHANGE:
                    OnGenericEvent(OnDisplaySettingsChangedEvent, msg - NativeMethods.WM_REFLECT, wParam, lParam);
                    break;

                case NativeMethods.WM_REFLECT + NativeMethods.WM_FONTCHANGE:
                    OnGenericEvent(OnInstalledFontsChangedEvent, msg - NativeMethods.WM_REFLECT, wParam, lParam);
                    break;

                case NativeMethods.WM_REFLECT + NativeMethods.WM_PALETTECHANGED:
                    OnGenericEvent(OnPaletteChangedEvent, msg - NativeMethods.WM_REFLECT, wParam, lParam);
                    break;

                case NativeMethods.WM_REFLECT + NativeMethods.WM_TIMECHANGE:
                    OnGenericEvent(OnTimeChangedEvent, msg - NativeMethods.WM_REFLECT, wParam, lParam);
                    break;

                case NativeMethods.WM_REFLECT + NativeMethods.WM_TIMER:
                    OnTimerElapsed(msg - NativeMethods.WM_REFLECT, wParam, lParam); 
                    break;                    

                default:
                    // If we received a thread execute message, then execute it.
                    //
                    if (msg == threadCallbackMessage && msg != 0) {
                        InvokeMarshaledCallbacks();
                        return IntPtr.Zero;
                    }
		    break;
            }

            return UnsafeNativeMethods.DefWindowProc(hWnd, msg, wParam, lParam);
        }

        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.WindowThreadProc"]/*' />
        /// <devdoc>
        ///      This is the method that runs our window thread.  This method
        ///      creates a window and spins up a message loop.  The window
        ///      is made visible with a size of 0, 0, so that it will trap
        ///      global broadcast messages.
        /// </devdoc>
        private void WindowThreadProc() {
            try {
                Initialize();
                eventWindowReady.Set();

                if (windowHandle != IntPtr.Zero) {
                    NativeMethods.MSG msg = new NativeMethods.MSG();

                    bool keepRunning = true;
                    
                    // Blocking on a GetMessage() call prevents the EE from being able to unwind
                    // this thread properly (e.g. during AppDomainUnload). So, we use PeekMessage()
                    // and sleep so we always block in managed code instead.
                    //
                    while (keepRunning) {
                        int ret = UnsafeNativeMethods.MsgWaitForMultipleObjects(0, 0, false, 100, 0xFFFF);  // 0xFFFF == QS_ALL

                        if (ret == NativeMethods.WAIT_TIMEOUT) {
                            Thread.Sleep(1);
                        }
                        else {
                            while (UnsafeNativeMethods.PeekMessage(ref msg, NativeMethods.NullHandleRef, 0, 0, NativeMethods.PM_REMOVE)) 
                            {
                                if (msg.message == NativeMethods.WM_QUIT) {
                                    keepRunning = false;
                                    break;
                                }

                                UnsafeNativeMethods.TranslateMessage(ref msg);
                                UnsafeNativeMethods.DispatchMessage(ref msg);
                            }
                        }
                    }
                }

                OnGenericEvent(OnEventsThreadShutdownEvent, 0, IntPtr.Zero, IntPtr.Zero);
            }
            catch (Exception e) {
                // In case something very very wrong happend during the creation action.
                // This will unblock the calling thread.
                //
                eventWindowReady.Set();

                if (!((e is ThreadInterruptedException) || (e is ThreadAbortException))) {
                    Debug.Fail("Unexpected thread exception in system events window thread proc", e.ToString());
                }
            }
        
            Dispose();
            if (eventThreadTerminated != null) {
                eventThreadTerminated.Set();
            }
        }

        /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.SystemEvent"]/*' />
        /// <devdoc>
        ///      This class is a single entry on our system event
        ///      queue.
        /// </devdoc>
        private class SystemEvent {
            public readonly Delegate Delegate;
            public readonly object[] Arguments;
            public object Result;

            /// <include file='doc\SystemEvents.uex' path='docs/doc[@for="SystemEvents.SystemEvent.SystemEvent"]/*' />
            /// <devdoc>
            ///      Creates a new system event.  The arguments array
            ///      is owned by SystemEvent after this call (no copy
            ///      is made).
            /// </devdoc>
            public SystemEvent(Delegate del, object[] arguments) {
                Delegate = del;
                Arguments = arguments;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\win32\userpreferencechangedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="UserPreferenceChangedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.Win32 {
    using System.Diagnostics;

    using System;

    /// <include file='doc\UserPreferenceChangedEventHandler.uex' path='docs/doc[@for="UserPreferenceChangedEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see cref='Microsoft.Win32.SystemEvents.UserPreferenceChanged'/> event.</para>
    /// </devdoc>
    public delegate void UserPreferenceChangedEventHandler(object sender, UserPreferenceChangedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\win32\userpreferencechangingeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="UserPreferenceChangingEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.Win32 {
    using System.Diagnostics;
    
    using System;
    
    /// <include file='doc\UserPreferenceChangingEventArgs.uex' path='docs/doc[@for="UserPreferenceChangingEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see cref='Microsoft.Win32.SystemEvents.UserPreferenceChanging'/> event.</para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class UserPreferenceChangingEventArgs : EventArgs {
    
        private readonly UserPreferenceCategory category;
    
        /// <include file='doc\UserPreferenceChangingEventArgs.uex' path='docs/doc[@for="UserPreferenceChangingEventArgs.UserPreferenceChangingEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='Microsoft.Win32.UserPreferenceChangingEventArgs'/> class.</para>
        /// </devdoc>
        public UserPreferenceChangingEventArgs(UserPreferenceCategory category) {
            this.category = category;
        }
    
        /// <include file='doc\UserPreferenceChangingEventArgs.uex' path='docs/doc[@for="UserPreferenceChangingEventArgs.Category"]/*' />
        /// <devdoc>
        ///    <para>Gets the category of user preferences that has Changing.</para>
        /// </devdoc>
        public UserPreferenceCategory Category {
            get {
                return category;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeargumentreferenceexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeArgumentReferenceExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeArgumentReferenceExpression.uex' path='docs/doc[@for="CodeArgumentReferenceExpression"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeArgumentReferenceExpression : CodeExpression {
        private string parameterName;

        /// <include file='doc\CodeArgumentReferenceExpression.uex' path='docs/doc[@for="CodeArgumentReferenceExpression.CodeArgumentReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeArgumentReferenceExpression() {
        }

        /// <include file='doc\CodeArgumentReferenceExpression.uex' path='docs/doc[@for="CodeArgumentReferenceExpression.CodeArgumentReferenceExpression1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeArgumentReferenceExpression(string parameterName) {
            this.parameterName = parameterName;
        }


        /// <include file='doc\CodeArgumentReferenceExpression.uex' path='docs/doc[@for="CodeArgumentReferenceExpression.ParameterName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string ParameterName {
            get {
                return (parameterName == null) ? string.Empty : parameterName;
            }
            set {
                parameterName = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\win32\userpreferencechangedeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="UserPreferenceChangedEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.Win32 {
    using System.Diagnostics;
    
    using System;
    
    /// <include file='doc\UserPreferenceChangedEventArgs.uex' path='docs/doc[@for="UserPreferenceChangedEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see cref='Microsoft.Win32.SystemEvents.UserPreferenceChanged'/> event.</para>
    /// </devdoc>
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.InheritanceDemand, Name="FullTrust")]
    [System.Security.Permissions.PermissionSetAttribute(System.Security.Permissions.SecurityAction.LinkDemand, Name="FullTrust")]
    public class UserPreferenceChangedEventArgs : EventArgs {
    
        private readonly UserPreferenceCategory category;
    
        /// <include file='doc\UserPreferenceChangedEventArgs.uex' path='docs/doc[@for="UserPreferenceChangedEventArgs.UserPreferenceChangedEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='Microsoft.Win32.UserPreferenceChangedEventArgs'/> class.</para>
        /// </devdoc>
        public UserPreferenceChangedEventArgs(UserPreferenceCategory category) {
            this.category = category;
        }
    
        /// <include file='doc\UserPreferenceChangedEventArgs.uex' path='docs/doc[@for="UserPreferenceChangedEventArgs.Category"]/*' />
        /// <devdoc>
        ///    <para>Gets the category of user preferences that has changed.</para>
        /// </devdoc>
        public UserPreferenceCategory Category {
            get {
                return category;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codearraycreateexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeArrayCreateExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeArrayCreateExpression.uex' path='docs/doc[@for="CodeArrayCreateExpression"]/*' />
    /// <devdoc>
    ///    <para> Represents
    ///       an expression that creates an array.</para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeArrayCreateExpression : CodeExpression {
        private CodeTypeReference createType;
        private CodeExpressionCollection initializers = new CodeExpressionCollection();
        private CodeExpression sizeExpression;
        private int size = 0;

        /// <include file='doc\CodeArrayCreateExpression.uex' path='docs/doc[@for="CodeArrayCreateExpression.CodeArrayCreateExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeArrayCreateExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeArrayCreateExpression() {
        }

        /// <include file='doc\CodeArrayCreateExpression.uex' path='docs/doc[@for="CodeArrayCreateExpression.CodeArrayCreateExpression1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeArrayCreateExpression'/> with the specified
        ///       array type and initializers.
        ///    </para>
        /// </devdoc>
        public CodeArrayCreateExpression(CodeTypeReference createType, params CodeExpression[] initializers) {
            this.createType = createType;
            this.initializers.AddRange(initializers);
        }

        /// <include file='doc\CodeArrayCreateExpression.uex' path='docs/doc[@for="CodeArrayCreateExpression.CodeArrayCreateExpression2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeArrayCreateExpression(string createType, params CodeExpression[] initializers) {
            this.createType = new CodeTypeReference(createType);
            this.initializers.AddRange(initializers);
        }

        /// <include file='doc\CodeArrayCreateExpression.uex' path='docs/doc[@for="CodeArrayCreateExpression.CodeArrayCreateExpression3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeArrayCreateExpression(Type createType, params CodeExpression[] initializers) {
            this.createType = new CodeTypeReference(createType);
            this.initializers.AddRange(initializers);
        }

        /// <include file='doc\CodeArrayCreateExpression.uex' path='docs/doc[@for="CodeArrayCreateExpression.CodeArrayCreateExpression4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeArrayCreateExpression'/>. with the specified array
        ///       type and size.
        ///    </para>
        /// </devdoc>
        public CodeArrayCreateExpression(CodeTypeReference createType, int size) {
            this.createType = createType;
            this.size = size;
        }

        /// <include file='doc\CodeArrayCreateExpression.uex' path='docs/doc[@for="CodeArrayCreateExpression.CodeArrayCreateExpression5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeArrayCreateExpression(string createType, int size) {
            this.createType = new CodeTypeReference(createType);
            this.size = size;
        }

        /// <include file='doc\CodeArrayCreateExpression.uex' path='docs/doc[@for="CodeArrayCreateExpression.CodeArrayCreateExpression6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeArrayCreateExpression(Type createType, int size) {
            this.createType = new CodeTypeReference(createType);
            this.size = size;
        }

        /// <include file='doc\CodeArrayCreateExpression.uex' path='docs/doc[@for="CodeArrayCreateExpression.CodeArrayCreateExpression7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeArrayCreateExpression'/>. with the specified array
        ///       type and size.
        ///    </para>
        /// </devdoc>
        public CodeArrayCreateExpression(CodeTypeReference createType, CodeExpression size) {
            this.createType = createType;
            this.sizeExpression = size;
        }

        /// <include file='doc\CodeArrayCreateExpression.uex' path='docs/doc[@for="CodeArrayCreateExpression.CodeArrayCreateExpression8"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeArrayCreateExpression(string createType, CodeExpression size) {
            this.createType = new CodeTypeReference(createType);
            this.sizeExpression = size;
        }

        /// <include file='doc\CodeArrayCreateExpression.uex' path='docs/doc[@for="CodeArrayCreateExpression.CodeArrayCreateExpression9"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeArrayCreateExpression(Type createType, CodeExpression size) {
            this.createType = new CodeTypeReference(createType);
            this.sizeExpression = size;
        }

        /// <include file='doc\CodeArrayCreateExpression.uex' path='docs/doc[@for="CodeArrayCreateExpression.CreateType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the type of the array to create.
        ///    </para>
        /// </devdoc>
        public CodeTypeReference CreateType {
            get {
                if (createType == null) {
                    createType = new CodeTypeReference("");
                }
                return createType;
            }
            set {
                createType = value;
            }
        }

        /// <include file='doc\CodeArrayCreateExpression.uex' path='docs/doc[@for="CodeArrayCreateExpression.Initializers"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the initializers to initialize the array with.
        ///    </para>
        /// </devdoc>
        public CodeExpressionCollection Initializers {
            get {
                return initializers;
            }
        }

        /// <include file='doc\CodeArrayCreateExpression.uex' path='docs/doc[@for="CodeArrayCreateExpression.Size"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the size of the array.
        ///    </para>
        /// </devdoc>
        public int Size {
            get {
                return size;
            }
            set {
                size = value;
            }
        }

        /// <include file='doc\CodeArrayCreateExpression.uex' path='docs/doc[@for="CodeArrayCreateExpression.SizeExpression"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the size of the array.</para>
        /// </devdoc>
        public CodeExpression SizeExpression {
            get {
                return sizeExpression;
            }
            set {
                sizeExpression = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codearrayindexerexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeArrayIndexerExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeArrayIndexerExpression.uex' path='docs/doc[@for="CodeArrayIndexerExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents an array indexer expression.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeArrayIndexerExpression : CodeExpression {
        private CodeExpression targetObject;
        private CodeExpressionCollection indices;

        /// <include file='doc\CodeArrayIndexerExpression.uex' path='docs/doc[@for="CodeArrayIndexerExpression.CodeArrayIndexerExpression"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeArrayIndexerExpression() {
        }

        /// <include file='doc\CodeArrayIndexerExpression.uex' path='docs/doc[@for="CodeArrayIndexerExpression.CodeArrayIndexerExpression1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeArrayIndexerExpression(CodeExpression targetObject, params CodeExpression[] indices) {
            this.targetObject = targetObject;
            this.indices = new CodeExpressionCollection();
            this.indices.AddRange(indices);
        }

        /// <include file='doc\CodeArrayIndexerExpression.uex' path='docs/doc[@for="CodeArrayIndexerExpression.TargetObject"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeExpression TargetObject {
            get {
                return targetObject;
            }
            set {
                targetObject = value;
            }
        }

        /// <include file='doc\CodeArrayIndexerExpression.uex' path='docs/doc[@for="CodeArrayIndexerExpression.Indices"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeExpressionCollection Indices {
            get {
                if (indices == null) {
                    indices = new CodeExpressionCollection();
                }
                return indices;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\microsoft\win32\userpreferencechangingeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="UserPreferenceChangingEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace Microsoft.Win32 {
    using System.Diagnostics;

    using System;

    /// <include file='doc\UserPreferenceChangingEventHandler.uex' path='docs/doc[@for="UserPreferenceChangingEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see cref='Microsoft.Win32.SystemEvents.UserPreferenceChanging'/> event.</para>
    /// </devdoc>
    public delegate void UserPreferenceChangingEventHandler(object sender, UserPreferenceChangingEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeattributeargument.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeAttributeArgument.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeAttributeArgument.uex' path='docs/doc[@for="CodeAttributeArgument"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents an argument for use in a custom attribute declaration.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeAttributeArgument {
        private string name;
        private CodeExpression value;

        /// <include file='doc\CodeAttributeArgument.uex' path='docs/doc[@for="CodeAttributeArgument.CodeAttributeArgument"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeAttributeArgument'/>.
        ///    </para>
        /// </devdoc>
        public CodeAttributeArgument() {
        }

        /// <include file='doc\CodeAttributeArgument.uex' path='docs/doc[@for="CodeAttributeArgument.CodeAttributeArgument1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeAttributeArgument'/> using the specified value.
        ///    </para>
        /// </devdoc>
        public CodeAttributeArgument(CodeExpression value) {
            Value = value;
        }

        /// <include file='doc\CodeAttributeArgument.uex' path='docs/doc[@for="CodeAttributeArgument.CodeAttributeArgument2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeAttributeArgument'/> using the specified name and
        ///       value.
        ///    </para>
        /// </devdoc>
        public CodeAttributeArgument(string name, CodeExpression value) {
            Name = name;
            Value = value;
        }

        /// <include file='doc\CodeAttributeArgument.uex' path='docs/doc[@for="CodeAttributeArgument.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The name of the attribute.
        ///    </para>
        /// </devdoc>
        public string Name {
            get {
                return (name == null) ? string.Empty : name;
            }
            set {
                name = value;
            }
        }

        /// <include file='doc\CodeAttributeArgument.uex' path='docs/doc[@for="CodeAttributeArgument.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The argument for the attribute.
        ///    </para>
        /// </devdoc>
        public CodeExpression Value {
            get {
                return value;
            }
            set {
                this.value = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeattacheventstatement.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeAttachEventStatement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeAttachEventStatement.uex' path='docs/doc[@for="CodeAttachEventStatement"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a event attach statement.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeAttachEventStatement : CodeStatement {
        private CodeEventReferenceExpression eventRef;
        private CodeExpression listener;

        /// <include file='doc\CodeAttachEventStatement.uex' path='docs/doc[@for="CodeAttachEventStatement.CodeAttachEventStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeAttachEventStatement'/>.
        ///    </para>
        /// </devdoc>
        public CodeAttachEventStatement() {
        }

        /// <include file='doc\CodeAttachEventStatement.uex' path='docs/doc[@for="CodeAttachEventStatement.CodeAttachEventStatement1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.CodeDom.CodeAttachEventStatement'/> class using the specified arguments.
        ///    </para>
        /// </devdoc>
        public CodeAttachEventStatement(CodeEventReferenceExpression eventRef, CodeExpression listener) {
            this.eventRef = eventRef;
            this.listener = listener;
        }

        /// <include file='doc\CodeAttachEventStatement.uex' path='docs/doc[@for="CodeAttachEventStatement.CodeAttachEventStatement2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeAttachEventStatement(CodeExpression targetObject, string eventName, CodeExpression listener) {
            this.eventRef = new CodeEventReferenceExpression(targetObject, eventName);
            this.listener = listener;
        }

        /// <include file='doc\CodeAttachEventStatement.uex' path='docs/doc[@for="CodeAttachEventStatement.Event"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The event to attach a listener to.
        ///    </para>
        /// </devdoc>
        public CodeEventReferenceExpression Event {
            get {
                if (eventRef == null) {
                    return new CodeEventReferenceExpression();
                }
                return eventRef;
            }
            set {
                eventRef = value;
            }
        }

        /// <include file='doc\CodeAttachEventStatement.uex' path='docs/doc[@for="CodeAttachEventStatement.Listener"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The new listener.
        ///    </para>
        /// </devdoc>
        public CodeExpression Listener {
            get {
                return listener;
            }
            set {
                listener = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeattributeargumentcollection.cs ===
// ------------------------------------------------------------------------------
// <copyright file="CodeAttributeArgumentCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright> 
// ------------------------------------------------------------------------------
// 
namespace System.CodeDom {
    using System;
    using System.Collections;
    using System.Runtime.InteropServices;
    
    
    /// <include file='doc\CodeAttributeArgumentCollection.uex' path='docs/doc[@for="CodeAttributeArgumentCollection"]/*' />
    /// <devdoc>
    ///     <para>
    ///       A collection that stores <see cref='System.CodeDom.CodeAttributeArgument'/> objects.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeAttributeArgumentCollection : CollectionBase {
        
        /// <include file='doc\CodeAttributeArgumentCollection.uex' path='docs/doc[@for="CodeAttributeArgumentCollection.CodeAttributeArgumentCollection"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeAttributeArgumentCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeAttributeArgumentCollection() {
        }
        
        /// <include file='doc\CodeAttributeArgumentCollection.uex' path='docs/doc[@for="CodeAttributeArgumentCollection.CodeAttributeArgumentCollection1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeAttributeArgumentCollection'/> based on another <see cref='System.CodeDom.CodeAttributeArgumentCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeAttributeArgumentCollection(CodeAttributeArgumentCollection value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeAttributeArgumentCollection.uex' path='docs/doc[@for="CodeAttributeArgumentCollection.CodeAttributeArgumentCollection2"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeAttributeArgumentCollection'/> containing any array of <see cref='System.CodeDom.CodeAttributeArgument'/> objects.
        ///    </para>
        /// </devdoc>
        public CodeAttributeArgumentCollection(CodeAttributeArgument[] value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeAttributeArgumentCollection.uex' path='docs/doc[@for="CodeAttributeArgumentCollection.this"]/*' />
        /// <devdoc>
        /// <para>Represents the entry at the specified index of the <see cref='System.CodeDom.CodeAttributeArgument'/>.</para>
        /// </devdoc>
        public CodeAttributeArgument this[int index] {
            get {
                return ((CodeAttributeArgument)(List[index]));
            }
            set {
                List[index] = value;
            }
        }
        
        /// <include file='doc\CodeAttributeArgumentCollection.uex' path='docs/doc[@for="CodeAttributeArgumentCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>Adds a <see cref='System.CodeDom.CodeAttributeArgument'/> with the specified value to the 
        ///    <see cref='System.CodeDom.CodeAttributeArgumentCollection'/> .</para>
        /// </devdoc>
        public int Add(CodeAttributeArgument value) {
            return List.Add(value);
        }
        
        /// <include file='doc\CodeAttributeArgumentCollection.uex' path='docs/doc[@for="CodeAttributeArgumentCollection.AddRange"]/*' />
        /// <devdoc>
        /// <para>Copies the elements of an array to the end of the <see cref='System.CodeDom.CodeAttributeArgumentCollection'/>.</para>
        /// </devdoc>
        public void AddRange(CodeAttributeArgument[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeAttributeArgumentCollection.uex' path='docs/doc[@for="CodeAttributeArgumentCollection.AddRange1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Adds the contents of another <see cref='System.CodeDom.CodeAttributeArgumentCollection'/> to the end of the collection.
        ///    </para>
        /// </devdoc>
        public void AddRange(CodeAttributeArgumentCollection value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeAttributeArgumentCollection.uex' path='docs/doc[@for="CodeAttributeArgumentCollection.Contains"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the 
        ///    <see cref='System.CodeDom.CodeAttributeArgumentCollection'/> contains the specified <see cref='System.CodeDom.CodeAttributeArgument'/>.</para>
        /// </devdoc>
        public bool Contains(CodeAttributeArgument value) {
            return List.Contains(value);
        }
        
        /// <include file='doc\CodeAttributeArgumentCollection.uex' path='docs/doc[@for="CodeAttributeArgumentCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the <see cref='System.CodeDom.CodeAttributeArgumentCollection'/> values to a one-dimensional <see cref='System.Array'/> instance at the 
        ///    specified index.</para>
        /// </devdoc>
        public void CopyTo(CodeAttributeArgument[] array, int index) {
            List.CopyTo(array, index);
        }
        
        /// <include file='doc\CodeAttributeArgumentCollection.uex' path='docs/doc[@for="CodeAttributeArgumentCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>Returns the index of a <see cref='System.CodeDom.CodeAttributeArgument'/> in 
        ///       the <see cref='System.CodeDom.CodeAttributeArgumentCollection'/> .</para>
        /// </devdoc>
        public int IndexOf(CodeAttributeArgument value) {
            return List.IndexOf(value);
        }
        
        /// <include file='doc\CodeAttributeArgumentCollection.uex' path='docs/doc[@for="CodeAttributeArgumentCollection.Insert"]/*' />
        /// <devdoc>
        /// <para>Inserts a <see cref='System.CodeDom.CodeAttributeArgument'/> into the <see cref='System.CodeDom.CodeAttributeArgumentCollection'/> at the specified index.</para>
        /// </devdoc>
        public void Insert(int index, CodeAttributeArgument value) {
            List.Insert(index, value);
        }
        
        /// <include file='doc\CodeAttributeArgumentCollection.uex' path='docs/doc[@for="CodeAttributeArgumentCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para> Removes a specific <see cref='System.CodeDom.CodeAttributeArgument'/> from the 
        ///    <see cref='System.CodeDom.CodeAttributeArgumentCollection'/> .</para>
        /// </devdoc>
        public void Remove(CodeAttributeArgument value) {
            List.Remove(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codebasereferenceexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeBaseReferenceExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeBaseReferenceExpression.uex' path='docs/doc[@for="CodeBaseReferenceExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a reference to the base 
    ///       class.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeBaseReferenceExpression : CodeExpression {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeassignstatement.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeAssignStatement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeAssignStatement.uex' path='docs/doc[@for="CodeAssignStatement"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a simple assignment statement.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeAssignStatement : CodeStatement {
        private CodeExpression left;
        private CodeExpression right;

        /// <include file='doc\CodeAssignStatement.uex' path='docs/doc[@for="CodeAssignStatement.CodeAssignStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeAssignStatement'/>.
        ///    </para>
        /// </devdoc>
        public CodeAssignStatement() {
        }

        /// <include file='doc\CodeAssignStatement.uex' path='docs/doc[@for="CodeAssignStatement.CodeAssignStatement1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeAssignStatement'/> that represents the
        ///       specified assignment values.
        ///    </para>
        /// </devdoc>
        public CodeAssignStatement(CodeExpression left, CodeExpression right) {
            Left = left;
            Right = right;
        }

        /// <include file='doc\CodeAssignStatement.uex' path='docs/doc[@for="CodeAssignStatement.Left"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the variable to be assigned to.
        ///    </para>
        /// </devdoc>
        public CodeExpression Left {
            get {
                return left;
            }
            set {
                left = value;
            }
        }

        /// <include file='doc\CodeAssignStatement.uex' path='docs/doc[@for="CodeAssignStatement.Right"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the value to assign.
        ///    </para>
        /// </devdoc>
        public CodeExpression Right {
            get {
                return right;
            }
            set {
                right = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeattributedeclarationcollection.cs ===
// ------------------------------------------------------------------------------
// <copyright file="CodeAttributeDeclarationCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright> 
// ------------------------------------------------------------------------------
// 
namespace System.CodeDom {
    using System;
    using System.Collections;
    using System.Runtime.InteropServices;
    
    
    /// <include file='doc\CodeAttributeDeclarationCollection.uex' path='docs/doc[@for="CodeAttributeDeclarationCollection"]/*' />
    /// <devdoc>
    ///     <para>
    ///       A collection that stores <see cref='System.CodeDom.CodeAttributeDeclaration'/> objects.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeAttributeDeclarationCollection : CollectionBase {
        
        /// <include file='doc\CodeAttributeDeclarationCollection.uex' path='docs/doc[@for="CodeAttributeDeclarationCollection.CodeAttributeDeclarationCollection"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeAttributeDeclarationCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeAttributeDeclarationCollection() {
        }
        
        /// <include file='doc\CodeAttributeDeclarationCollection.uex' path='docs/doc[@for="CodeAttributeDeclarationCollection.CodeAttributeDeclarationCollection1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeAttributeDeclarationCollection'/> based on another <see cref='System.CodeDom.CodeAttributeDeclarationCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeAttributeDeclarationCollection(CodeAttributeDeclarationCollection value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeAttributeDeclarationCollection.uex' path='docs/doc[@for="CodeAttributeDeclarationCollection.CodeAttributeDeclarationCollection2"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeAttributeDeclarationCollection'/> containing any array of <see cref='System.CodeDom.CodeAttributeDeclaration'/> objects.
        ///    </para>
        /// </devdoc>
        public CodeAttributeDeclarationCollection(CodeAttributeDeclaration[] value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeAttributeDeclarationCollection.uex' path='docs/doc[@for="CodeAttributeDeclarationCollection.this"]/*' />
        /// <devdoc>
        /// <para>Represents the entry at the specified index of the <see cref='System.CodeDom.CodeAttributeDeclaration'/>.</para>
        /// </devdoc>
        public CodeAttributeDeclaration this[int index] {
            get {
                return ((CodeAttributeDeclaration)(List[index]));
            }
            set {
                List[index] = value;
            }
        }
        
        /// <include file='doc\CodeAttributeDeclarationCollection.uex' path='docs/doc[@for="CodeAttributeDeclarationCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>Adds a <see cref='System.CodeDom.CodeAttributeDeclaration'/> with the specified value to the 
        ///    <see cref='System.CodeDom.CodeAttributeDeclarationCollection'/> .</para>
        /// </devdoc>
        public int Add(CodeAttributeDeclaration value) {
            return List.Add(value);
        }
        
        /// <include file='doc\CodeAttributeDeclarationCollection.uex' path='docs/doc[@for="CodeAttributeDeclarationCollection.AddRange"]/*' />
        /// <devdoc>
        /// <para>Copies the elements of an array to the end of the <see cref='System.CodeDom.CodeAttributeDeclarationCollection'/>.</para>
        /// </devdoc>
        public void AddRange(CodeAttributeDeclaration[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeAttributeDeclarationCollection.uex' path='docs/doc[@for="CodeAttributeDeclarationCollection.AddRange1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Adds the contents of another <see cref='System.CodeDom.CodeAttributeDeclarationCollection'/> to the end of the collection.
        ///    </para>
        /// </devdoc>
        public void AddRange(CodeAttributeDeclarationCollection value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeAttributeDeclarationCollection.uex' path='docs/doc[@for="CodeAttributeDeclarationCollection.Contains"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the 
        ///    <see cref='System.CodeDom.CodeAttributeDeclarationCollection'/> contains the specified <see cref='System.CodeDom.CodeAttributeDeclaration'/>.</para>
        /// </devdoc>
        public bool Contains(CodeAttributeDeclaration value) {
            return List.Contains(value);
        }
        
        /// <include file='doc\CodeAttributeDeclarationCollection.uex' path='docs/doc[@for="CodeAttributeDeclarationCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the <see cref='System.CodeDom.CodeAttributeDeclarationCollection'/> values to a one-dimensional <see cref='System.Array'/> instance at the 
        ///    specified index.</para>
        /// </devdoc>
        public void CopyTo(CodeAttributeDeclaration[] array, int index) {
            List.CopyTo(array, index);
        }
        
        /// <include file='doc\CodeAttributeDeclarationCollection.uex' path='docs/doc[@for="CodeAttributeDeclarationCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>Returns the index of a <see cref='System.CodeDom.CodeAttributeDeclaration'/> in 
        ///       the <see cref='System.CodeDom.CodeAttributeDeclarationCollection'/> .</para>
        /// </devdoc>
        public int IndexOf(CodeAttributeDeclaration value) {
            return List.IndexOf(value);
        }
        
        /// <include file='doc\CodeAttributeDeclarationCollection.uex' path='docs/doc[@for="CodeAttributeDeclarationCollection.Insert"]/*' />
        /// <devdoc>
        /// <para>Inserts a <see cref='System.CodeDom.CodeAttributeDeclaration'/> into the <see cref='System.CodeDom.CodeAttributeDeclarationCollection'/> at the specified index.</para>
        /// </devdoc>
        public void Insert(int index, CodeAttributeDeclaration value) {
            List.Insert(index, value);
        }
        
        /// <include file='doc\CodeAttributeDeclarationCollection.uex' path='docs/doc[@for="CodeAttributeDeclarationCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para> Removes a specific <see cref='System.CodeDom.CodeAttributeDeclaration'/> from the 
        ///    <see cref='System.CodeDom.CodeAttributeDeclarationCollection'/> .</para>
        /// </devdoc>
        public void Remove(CodeAttributeDeclaration value) {
            List.Remove(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codebinaryoperatorexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeBinaryOperatorExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeBinaryOperatorExpression.uex' path='docs/doc[@for="CodeBinaryOperatorExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a binary operator expression.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeBinaryOperatorExpression : CodeExpression {
        private CodeBinaryOperatorType op;
        private CodeExpression left;
        private CodeExpression right;

        /// <include file='doc\CodeBinaryOperatorExpression.uex' path='docs/doc[@for="CodeBinaryOperatorExpression.CodeBinaryOperatorExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeBinaryOperatorExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeBinaryOperatorExpression() {
        }

        /// <include file='doc\CodeBinaryOperatorExpression.uex' path='docs/doc[@for="CodeBinaryOperatorExpression.CodeBinaryOperatorExpression1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeBinaryOperatorExpression'/>
        ///       using the specified
        ///       parameters.
        ///    </para>
        /// </devdoc>
        public CodeBinaryOperatorExpression(CodeExpression left, CodeBinaryOperatorType op, CodeExpression right) {
            Right = right;
            Operator = op;
            Left = left;
        }

        /// <include file='doc\CodeBinaryOperatorExpression.uex' path='docs/doc[@for="CodeBinaryOperatorExpression.Right"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the code expression on the right of the operator.
        ///    </para>
        /// </devdoc>
        public CodeExpression Right {
            get {
                return right;
            }
            set {
                right = value;
            }
        }

        /// <include file='doc\CodeBinaryOperatorExpression.uex' path='docs/doc[@for="CodeBinaryOperatorExpression.Left"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the code expression on the left of the operator.
        ///    </para>
        /// </devdoc>
        public CodeExpression Left {
            get {
                return left;
            }
            set {
                left = value;
            }
        }

        /// <include file='doc\CodeBinaryOperatorExpression.uex' path='docs/doc[@for="CodeBinaryOperatorExpression.Operator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the operator in the binary operator expression.
        ///    </para>
        /// </devdoc>
        public CodeBinaryOperatorType Operator {
            get {
                return op;
            }
            set {
                op = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeattributedeclaration.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeAttributeDeclaration.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeAttributeDeclaration.uex' path='docs/doc[@for="CodeAttributeDeclaration"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a single custom attribute.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeAttributeDeclaration {
        private string name;
        private CodeAttributeArgumentCollection arguments = new CodeAttributeArgumentCollection();

        /// <include file='doc\CodeAttributeDeclaration.uex' path='docs/doc[@for="CodeAttributeDeclaration.CodeAttributeDeclaration"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeAttributeDeclaration'/>.
        ///    </para>
        /// </devdoc>
        public CodeAttributeDeclaration() {
        }

        /// <include file='doc\CodeAttributeDeclaration.uex' path='docs/doc[@for="CodeAttributeDeclaration.CodeAttributeDeclaration1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeAttributeDeclaration'/> using the specified name.
        ///    </para>
        /// </devdoc>
        public CodeAttributeDeclaration(string name) {
            Name = name;
        }

        /// <include file='doc\CodeAttributeDeclaration.uex' path='docs/doc[@for="CodeAttributeDeclaration.CodeAttributeDeclaration2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeAttributeDeclaration'/> using the specified
        ///       arguments.
        ///    </para>
        /// </devdoc>
        public CodeAttributeDeclaration(string name, params CodeAttributeArgument[] arguments) {
            Name = name;
            Arguments.AddRange(arguments);
        }

        /// <include file='doc\CodeAttributeDeclaration.uex' path='docs/doc[@for="CodeAttributeDeclaration.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The name of the attribute being declared.
        ///    </para>
        /// </devdoc>
        public string Name {
            get {
                return (name == null) ? string.Empty : name;
            }
            set {
                name = value;
            }
        }

        /// <include file='doc\CodeAttributeDeclaration.uex' path='docs/doc[@for="CodeAttributeDeclaration.Arguments"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The arguments for the attribute.
        ///    </para>
        /// </devdoc>
        public CodeAttributeArgumentCollection Arguments {
            get {
                return arguments;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codecomment.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeComment.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeComment.uex' path='docs/doc[@for="CodeComment"]/*' />
    /// <devdoc>
    ///    <para> Represents a comment.</para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeComment : CodeObject {
        private string text;
        private bool docComment = false;

        /// <include file='doc\CodeComment.uex' path='docs/doc[@for="CodeComment.CodeComment"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeComment'/>.
        ///    </para>
        /// </devdoc>
        public CodeComment() {
        }

        /// <include file='doc\CodeComment.uex' path='docs/doc[@for="CodeComment.CodeComment1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeComment'/> with the specified text as
        ///       contents.
        ///    </para>
        /// </devdoc>
        public CodeComment(string text) {
            Text = text;
        }

        /// <include file='doc\CodeComment.uex' path='docs/doc[@for="CodeComment.CodeComment2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeComment(string text, bool docComment) {
            Text = text;
            this.docComment = docComment;
        }

        /// <include file='doc\CodeComment.uex' path='docs/doc[@for="CodeComment.DocComment"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool DocComment {
            get {
                return docComment;
            }
            set {
                docComment = value;
            }
        }

        /// <include file='doc\CodeComment.uex' path='docs/doc[@for="CodeComment.Text"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or setes
        ///       the text of the comment.
        ///    </para>
        /// </devdoc>
        public string Text {
            get {
                return (text == null) ? string.Empty : text;
            }
            set {
                text = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codecatchclausecollection.cs ===
// ------------------------------------------------------------------------------
// <copyright file="CodeCatchClauseCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright> 
// ------------------------------------------------------------------------------
// 
namespace System.CodeDom {
    using System;
    using System.Collections;
    using System.Runtime.InteropServices;
    
    
    /// <include file='doc\CodeCatchClauseCollection.uex' path='docs/doc[@for="CodeCatchClauseCollection"]/*' />
    /// <devdoc>
    ///     <para>
    ///       A collection that stores <see cref='System.CodeDom.CodeCatchClause'/> objects.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeCatchClauseCollection : CollectionBase {
        
        /// <include file='doc\CodeCatchClauseCollection.uex' path='docs/doc[@for="CodeCatchClauseCollection.CodeCatchClauseCollection"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeCatchClauseCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeCatchClauseCollection() {
        }
        
        /// <include file='doc\CodeCatchClauseCollection.uex' path='docs/doc[@for="CodeCatchClauseCollection.CodeCatchClauseCollection1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeCatchClauseCollection'/> based on another <see cref='System.CodeDom.CodeCatchClauseCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeCatchClauseCollection(CodeCatchClauseCollection value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeCatchClauseCollection.uex' path='docs/doc[@for="CodeCatchClauseCollection.CodeCatchClauseCollection2"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeCatchClauseCollection'/> containing any array of <see cref='System.CodeDom.CodeCatchClause'/> objects.
        ///    </para>
        /// </devdoc>
        public CodeCatchClauseCollection(CodeCatchClause[] value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeCatchClauseCollection.uex' path='docs/doc[@for="CodeCatchClauseCollection.this"]/*' />
        /// <devdoc>
        /// <para>Represents the entry at the specified index of the <see cref='System.CodeDom.CodeCatchClause'/>.</para>
        /// </devdoc>
        public CodeCatchClause this[int index] {
            get {
                return ((CodeCatchClause)(List[index]));
            }
            set {
                List[index] = value;
            }
        }
        
        /// <include file='doc\CodeCatchClauseCollection.uex' path='docs/doc[@for="CodeCatchClauseCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>Adds a <see cref='System.CodeDom.CodeCatchClause'/> with the specified value to the 
        ///    <see cref='System.CodeDom.CodeCatchClauseCollection'/> .</para>
        /// </devdoc>
        public int Add(CodeCatchClause value) {
            return List.Add(value);
        }
        
        /// <include file='doc\CodeCatchClauseCollection.uex' path='docs/doc[@for="CodeCatchClauseCollection.AddRange"]/*' />
        /// <devdoc>
        /// <para>Copies the elements of an array to the end of the <see cref='System.CodeDom.CodeCatchClauseCollection'/>.</para>
        /// </devdoc>
        public void AddRange(CodeCatchClause[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeCatchClauseCollection.uex' path='docs/doc[@for="CodeCatchClauseCollection.AddRange1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Adds the contents of another <see cref='System.CodeDom.CodeCatchClauseCollection'/> to the end of the collection.
        ///    </para>
        /// </devdoc>
        public void AddRange(CodeCatchClauseCollection value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeCatchClauseCollection.uex' path='docs/doc[@for="CodeCatchClauseCollection.Contains"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the 
        ///    <see cref='System.CodeDom.CodeCatchClauseCollection'/> contains the specified <see cref='System.CodeDom.CodeCatchClause'/>.</para>
        /// </devdoc>
        public bool Contains(CodeCatchClause value) {
            return List.Contains(value);
        }
        
        /// <include file='doc\CodeCatchClauseCollection.uex' path='docs/doc[@for="CodeCatchClauseCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the <see cref='System.CodeDom.CodeCatchClauseCollection'/> values to a one-dimensional <see cref='System.Array'/> instance at the 
        ///    specified index.</para>
        /// </devdoc>
        public void CopyTo(CodeCatchClause[] array, int index) {
            List.CopyTo(array, index);
        }
        
        /// <include file='doc\CodeCatchClauseCollection.uex' path='docs/doc[@for="CodeCatchClauseCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>Returns the index of a <see cref='System.CodeDom.CodeCatchClause'/> in 
        ///       the <see cref='System.CodeDom.CodeCatchClauseCollection'/> .</para>
        /// </devdoc>
        public int IndexOf(CodeCatchClause value) {
            return List.IndexOf(value);
        }
        
        /// <include file='doc\CodeCatchClauseCollection.uex' path='docs/doc[@for="CodeCatchClauseCollection.Insert"]/*' />
        /// <devdoc>
        /// <para>Inserts a <see cref='System.CodeDom.CodeCatchClause'/> into the <see cref='System.CodeDom.CodeCatchClauseCollection'/> at the specified index.</para>
        /// </devdoc>
        public void Insert(int index, CodeCatchClause value) {
            List.Insert(index, value);
        }
        
        /// <include file='doc\CodeCatchClauseCollection.uex' path='docs/doc[@for="CodeCatchClauseCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para> Removes a specific <see cref='System.CodeDom.CodeCatchClause'/> from the 
        ///    <see cref='System.CodeDom.CodeCatchClauseCollection'/> .</para>
        /// </devdoc>
        public void Remove(CodeCatchClause value) {
            List.Remove(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codecastexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeCastExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeCastExpression.uex' path='docs/doc[@for="CodeCastExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a
    ///       type cast expression.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeCastExpression : CodeExpression {
        private CodeTypeReference targetType;
        private CodeExpression expression;

        /// <include file='doc\CodeCastExpression.uex' path='docs/doc[@for="CodeCastExpression.CodeCastExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeCastExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeCastExpression() {
        }

        /// <include file='doc\CodeCastExpression.uex' path='docs/doc[@for="CodeCastExpression.CodeCastExpression1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeCastExpression'/> using the specified
        ///       parameters.
        ///    </para>
        /// </devdoc>
        public CodeCastExpression(CodeTypeReference targetType, CodeExpression expression) {
            TargetType = targetType;
            Expression = expression;
        }

        /// <include file='doc\CodeCastExpression.uex' path='docs/doc[@for="CodeCastExpression.CodeCastExpression2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeCastExpression(string targetType, CodeExpression expression) {
            TargetType = new CodeTypeReference(targetType);
            Expression = expression;
        }

        /// <include file='doc\CodeCastExpression.uex' path='docs/doc[@for="CodeCastExpression.CodeCastExpression3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeCastExpression(Type targetType, CodeExpression expression) {
            TargetType = new CodeTypeReference(targetType);
            Expression = expression;
        }

        /// <include file='doc\CodeCastExpression.uex' path='docs/doc[@for="CodeCastExpression.TargetType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The target type of the cast.
        ///    </para>
        /// </devdoc>
        public CodeTypeReference TargetType {
            get {
                if (targetType == null) {
                    targetType = new CodeTypeReference("");
                }
                return targetType;
            }
            set {
                targetType = value;
            }
        }

        /// <include file='doc\CodeCastExpression.uex' path='docs/doc[@for="CodeCastExpression.Expression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The expression to cast.
        ///    </para>
        /// </devdoc>
        public CodeExpression Expression {
            get {
                return expression;
            }
            set {
                expression = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codecommentstatementcollection.cs ===
// ------------------------------------------------------------------------------
// <copyright file="CodeCommentStatementCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright> 
// ------------------------------------------------------------------------------
// 
namespace System.CodeDom {
    using System;
    using System.Collections;
    using System.Runtime.InteropServices;
    
    
    /// <include file='doc\CodeCommentStatementCollection.uex' path='docs/doc[@for="CodeCommentStatementCollection"]/*' />
    /// <devdoc>
    ///     <para>
    ///       A collection that stores <see cref='System.CodeDom.CodeCommentStatement'/> objects.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeCommentStatementCollection : CollectionBase {
        
        /// <include file='doc\CodeCommentStatementCollection.uex' path='docs/doc[@for="CodeCommentStatementCollection.CodeCommentStatementCollection"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeCommentStatementCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeCommentStatementCollection() {
        }
        
        /// <include file='doc\CodeCommentStatementCollection.uex' path='docs/doc[@for="CodeCommentStatementCollection.CodeCommentStatementCollection1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeCommentStatementCollection'/> based on another <see cref='System.CodeDom.CodeCommentStatementCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeCommentStatementCollection(CodeCommentStatementCollection value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeCommentStatementCollection.uex' path='docs/doc[@for="CodeCommentStatementCollection.CodeCommentStatementCollection2"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeCommentStatementCollection'/> containing any array of <see cref='System.CodeDom.CodeCommentStatement'/> objects.
        ///    </para>
        /// </devdoc>
        public CodeCommentStatementCollection(CodeCommentStatement[] value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeCommentStatementCollection.uex' path='docs/doc[@for="CodeCommentStatementCollection.this"]/*' />
        /// <devdoc>
        /// <para>Represents the entry at the specified index of the <see cref='System.CodeDom.CodeCommentStatement'/>.</para>
        /// </devdoc>
        public CodeCommentStatement this[int index] {
            get {
                return ((CodeCommentStatement)(List[index]));
            }
            set {
                List[index] = value;
            }
        }
        
        /// <include file='doc\CodeCommentStatementCollection.uex' path='docs/doc[@for="CodeCommentStatementCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>Adds a <see cref='System.CodeDom.CodeCommentStatement'/> with the specified value to the 
        ///    <see cref='System.CodeDom.CodeCommentStatementCollection'/> .</para>
        /// </devdoc>
        public int Add(CodeCommentStatement value) {
            return List.Add(value);
        }
        
        /// <include file='doc\CodeCommentStatementCollection.uex' path='docs/doc[@for="CodeCommentStatementCollection.AddRange"]/*' />
        /// <devdoc>
        /// <para>Copies the elements of an array to the end of the <see cref='System.CodeDom.CodeCommentStatementCollection'/>.</para>
        /// </devdoc>
        public void AddRange(CodeCommentStatement[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeCommentStatementCollection.uex' path='docs/doc[@for="CodeCommentStatementCollection.AddRange1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Adds the contents of another <see cref='System.CodeDom.CodeCommentStatementCollection'/> to the end of the collection.
        ///    </para>
        /// </devdoc>
        public void AddRange(CodeCommentStatementCollection value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeCommentStatementCollection.uex' path='docs/doc[@for="CodeCommentStatementCollection.Contains"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the 
        ///    <see cref='System.CodeDom.CodeCommentStatementCollection'/> contains the specified <see cref='System.CodeDom.CodeCommentStatement'/>.</para>
        /// </devdoc>
        public bool Contains(CodeCommentStatement value) {
            return List.Contains(value);
        }
        
        /// <include file='doc\CodeCommentStatementCollection.uex' path='docs/doc[@for="CodeCommentStatementCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the <see cref='System.CodeDom.CodeCommentStatementCollection'/> values to a one-dimensional <see cref='System.Array'/> instance at the 
        ///    specified index.</para>
        /// </devdoc>
        public void CopyTo(CodeCommentStatement[] array, int index) {
            List.CopyTo(array, index);
        }
        
        /// <include file='doc\CodeCommentStatementCollection.uex' path='docs/doc[@for="CodeCommentStatementCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>Returns the index of a <see cref='System.CodeDom.CodeCommentStatement'/> in 
        ///       the <see cref='System.CodeDom.CodeCommentStatementCollection'/> .</para>
        /// </devdoc>
        public int IndexOf(CodeCommentStatement value) {
            return List.IndexOf(value);
        }
        
        /// <include file='doc\CodeCommentStatementCollection.uex' path='docs/doc[@for="CodeCommentStatementCollection.Insert"]/*' />
        /// <devdoc>
        /// <para>Inserts a <see cref='System.CodeDom.CodeCommentStatement'/> into the <see cref='System.CodeDom.CodeCommentStatementCollection'/> at the specified index.</para>
        /// </devdoc>
        public void Insert(int index, CodeCommentStatement value) {
            List.Insert(index, value);
        }
        
        /// <include file='doc\CodeCommentStatementCollection.uex' path='docs/doc[@for="CodeCommentStatementCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para> Removes a specific <see cref='System.CodeDom.CodeCommentStatement'/> from the 
        ///    <see cref='System.CodeDom.CodeCommentStatementCollection'/> .</para>
        /// </devdoc>
        public void Remove(CodeCommentStatement value) {
            List.Remove(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codecatchclause.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeCatchClause.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeCatchClause.uex' path='docs/doc[@for="CodeCatchClause"]/*' />
    /// <devdoc>
    ///    <para>Represents a catch exception block.</para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeCatchClause {
        private CodeStatementCollection statements;
        private CodeTypeReference catchExceptionType;
        private string localName;

        /// <include file='doc\CodeCatchClause.uex' path='docs/doc[@for="CodeCatchClause.CodeCatchClause"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes an instance of <see cref='System.CodeDom.CodeCatchClause'/>.
        ///    </para>
        /// </devdoc>
        public CodeCatchClause() {
        }

        /// <include file='doc\CodeCatchClause.uex' path='docs/doc[@for="CodeCatchClause.CodeCatchClause1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeCatchClause(string localName) {
            this.localName = localName;
        }

        /// <include file='doc\CodeCatchClause.uex' path='docs/doc[@for="CodeCatchClause.CodeCatchClause2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeCatchClause(string localName, CodeTypeReference catchExceptionType) {
            this.localName = localName;
            this.catchExceptionType = catchExceptionType;
        }

        /// <include file='doc\CodeCatchClause.uex' path='docs/doc[@for="CodeCatchClause.CodeCatchClause3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeCatchClause(string localName, CodeTypeReference catchExceptionType, params CodeStatement[] statements) {
            this.localName = localName;
            this.catchExceptionType = catchExceptionType;
            Statements.AddRange(statements);
        }

        /// <include file='doc\CodeCatchClause.uex' path='docs/doc[@for="CodeCatchClause.LocalName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string LocalName {
            get {
                return (localName == null) ? string.Empty: localName;
            }
            set {
                localName = value;
            }
        }

        /// <include file='doc\CodeCatchClause.uex' path='docs/doc[@for="CodeCatchClause.CatchExceptionType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeTypeReference CatchExceptionType {
            get {
                if (catchExceptionType == null) {
                    catchExceptionType = new CodeTypeReference(typeof(System.Exception));
                }
                return catchExceptionType;
            }
            set {
                catchExceptionType = value;
            }
        }

        /// <include file='doc\CodeCatchClause.uex' path='docs/doc[@for="CodeCatchClause.Statements"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the statements within the clause.
        ///    </para>
        /// </devdoc>
        public CodeStatementCollection Statements {
            get {
                if (statements == null) {
                    statements = new CodeStatementCollection();
                }
                return statements;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codebinaryoperatortype.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeBinaryOperatorType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {
    using System.Runtime.Remoting;

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeBinaryOperatorType.uex' path='docs/doc[@for="CodeBinaryOperatorType"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies type identifiers for supported binary operators.
    ///    </para>
    /// </devdoc>
    [
        ComVisible(true),
        Serializable,
    ]
    public enum CodeBinaryOperatorType {
        /// <include file='doc\CodeBinaryOperatorType.uex' path='docs/doc[@for="CodeBinaryOperatorType.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Addition operator.
        ///    </para>
        /// </devdoc>
        Add,
        /// <include file='doc\CodeBinaryOperatorType.uex' path='docs/doc[@for="CodeBinaryOperatorType.Subtract"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Subtraction operator.
        ///    </para>
        /// </devdoc>
        Subtract,
        /// <include file='doc\CodeBinaryOperatorType.uex' path='docs/doc[@for="CodeBinaryOperatorType.Multiply"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Multiplication operator.
        ///    </para>
        /// </devdoc>
        Multiply,
        /// <include file='doc\CodeBinaryOperatorType.uex' path='docs/doc[@for="CodeBinaryOperatorType.Divide"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Division operator.
        ///    </para>
        /// </devdoc>
        Divide,
        /// <include file='doc\CodeBinaryOperatorType.uex' path='docs/doc[@for="CodeBinaryOperatorType.Modulus"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Modulus operator.
        ///    </para>
        /// </devdoc>
        Modulus,
        /// <include file='doc\CodeBinaryOperatorType.uex' path='docs/doc[@for="CodeBinaryOperatorType.Assign"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Assignment operator.
        ///    </para>
        /// </devdoc>
        Assign,
        /// <include file='doc\CodeBinaryOperatorType.uex' path='docs/doc[@for="CodeBinaryOperatorType.IdentityInequality"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Identity not equal operator.
        ///    </para>
        /// </devdoc>
        IdentityInequality,
        /// <include file='doc\CodeBinaryOperatorType.uex' path='docs/doc[@for="CodeBinaryOperatorType.IdentityEquality"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Identity equal operator.
        ///    </para>
        /// </devdoc>
        IdentityEquality,
        /// <include file='doc\CodeBinaryOperatorType.uex' path='docs/doc[@for="CodeBinaryOperatorType.ValueEquality"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Value equal operator.
        ///    </para>
        /// </devdoc>
        ValueEquality,
        /// <include file='doc\CodeBinaryOperatorType.uex' path='docs/doc[@for="CodeBinaryOperatorType.BitwiseOr"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Bitwise or operator.
        ///    </para>
        /// </devdoc>
        BitwiseOr,
        /// <include file='doc\CodeBinaryOperatorType.uex' path='docs/doc[@for="CodeBinaryOperatorType.BitwiseAnd"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Bitwise and operator.
        ///    </para>
        /// </devdoc>
        BitwiseAnd,
        /// <include file='doc\CodeBinaryOperatorType.uex' path='docs/doc[@for="CodeBinaryOperatorType.BooleanOr"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Boolean or operator.
        ///    </para>
        /// </devdoc>
        BooleanOr,
        /// <include file='doc\CodeBinaryOperatorType.uex' path='docs/doc[@for="CodeBinaryOperatorType.BooleanAnd"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Boolean and operator.
        ///    </para>
        /// </devdoc>
        BooleanAnd,
        /// <include file='doc\CodeBinaryOperatorType.uex' path='docs/doc[@for="CodeBinaryOperatorType.LessThan"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Less than operator.
        ///    </para>
        /// </devdoc>
        LessThan,
        /// <include file='doc\CodeBinaryOperatorType.uex' path='docs/doc[@for="CodeBinaryOperatorType.LessThanOrEqual"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Less than or equal operator.
        ///    </para>
        /// </devdoc>
        LessThanOrEqual,
        /// <include file='doc\CodeBinaryOperatorType.uex' path='docs/doc[@for="CodeBinaryOperatorType.GreaterThan"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Greater than operator.
        ///    </para>
        /// </devdoc>
        GreaterThan,
        /// <include file='doc\CodeBinaryOperatorType.uex' path='docs/doc[@for="CodeBinaryOperatorType.GreaterThanOrEqual"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Greater that or operator.
        ///    </para>
        /// </devdoc>
        GreaterThanOrEqual,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codecommentstatement.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeCommentStatement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeCommentStatement.uex' path='docs/doc[@for="CodeCommentStatement"]/*' />
    /// <devdoc>
    ///    <para> Represents a comment.</para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeCommentStatement : CodeStatement {
        private CodeComment comment;

        /// <include file='doc\CodeCommentStatement.uex' path='docs/doc[@for="CodeCommentStatement.CodeCommentStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeCommentStatement'/>.
        ///    </para>
        /// </devdoc>
        public CodeCommentStatement() {
        }

        /// <include file='doc\CodeCommentStatement.uex' path='docs/doc[@for="CodeCommentStatement.CodeCommentStatement1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeCommentStatement(CodeComment comment) {
            this.comment = comment;
        }

        /// <include file='doc\CodeCommentStatement.uex' path='docs/doc[@for="CodeCommentStatement.CodeCommentStatement2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeCommentStatement'/> with the specified text as
        ///       contents.
        ///    </para>
        /// </devdoc>
        public CodeCommentStatement(string text) {
            comment = new CodeComment(text);
        }

        /// <include file='doc\CodeCommentStatement.uex' path='docs/doc[@for="CodeCommentStatement.CodeCommentStatement3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeCommentStatement(string text, bool docComment) {
            comment = new CodeComment(text, docComment);
        }

        /// <include file='doc\CodeCommentStatement.uex' path='docs/doc[@for="CodeCommentStatement.Comment"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeComment Comment {
            get {
                return comment;
            }
            set {
                comment = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codecompileunit.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeCompileUnit.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Runtime.Serialization;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeCompileUnit.uex' path='docs/doc[@for="CodeCompileUnit"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a
    ///       compilation unit declaration.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeCompileUnit: CodeObject {
        private CodeNamespaceCollection namespaces = new CodeNamespaceCollection();
        private StringCollection assemblies = null;
        private CodeAttributeDeclarationCollection attributes = null;

        /// <include file='doc\CodeCompileUnit.uex' path='docs/doc[@for="CodeCompileUnit.CodeCompileUnit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeCompileUnit'/>.
        ///    </para>
        /// </devdoc>
        public CodeCompileUnit() {
        }


        /// <include file='doc\CodeCompileUnit.uex' path='docs/doc[@for="CodeCompileUnit.Namespaces"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the collection of namespaces.
        ///    </para>
        /// </devdoc>
        public CodeNamespaceCollection Namespaces {
            get {
                return namespaces;
            }
        }

        /// <include file='doc\CodeCompileUnit.uex' path='docs/doc[@for="CodeCompileUnit.ReferencedAssemblies"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the collection of assemblies. Most code generators will not need this, but the Managed
        ///       extensions for C++ code generator and 
        ///       other very low level code generators will need to do a more complete compilation. If both this
        ///       and the compiler assemblies are specified, the compiler assemblies should win.
        ///    </para>
        /// </devdoc>
        public StringCollection ReferencedAssemblies {
            get {
                if (assemblies == null) {
                    assemblies = new StringCollection();
                }
                return assemblies;
            }
        }

        /// <include file='doc\CodeCompileUnit.uex' path='docs/doc[@for="CodeCompileUnit.AssemblyCustomAttributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the collection of assembly level attributes.
        ///    </para>
        /// </devdoc>
        public CodeAttributeDeclarationCollection AssemblyCustomAttributes {
            get {
                if (attributes == null) {
                    attributes = new CodeAttributeDeclarationCollection();
                }
                return attributes;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codedelegatecreateexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeDelegateCreateExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeDelegateCreateExpression.uex' path='docs/doc[@for="CodeDelegateCreateExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a delegate creation expression.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeDelegateCreateExpression : CodeExpression {
        private CodeTypeReference delegateType;
        private CodeExpression targetObject;
        private string methodName;

        /// <include file='doc\CodeDelegateCreateExpression.uex' path='docs/doc[@for="CodeDelegateCreateExpression.CodeDelegateCreateExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeDelegateCreateExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeDelegateCreateExpression() {
        }

        /// <include file='doc\CodeDelegateCreateExpression.uex' path='docs/doc[@for="CodeDelegateCreateExpression.CodeDelegateCreateExpression1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeDelegateCreateExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeDelegateCreateExpression(CodeTypeReference delegateType, CodeExpression targetObject, string methodName) {
            this.delegateType = delegateType;
            this.targetObject = targetObject;
            this.methodName = methodName;
        }

        /// <include file='doc\CodeDelegateCreateExpression.uex' path='docs/doc[@for="CodeDelegateCreateExpression.DelegateType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the delegate type.
        ///    </para>
        /// </devdoc>
        public CodeTypeReference DelegateType {
            get {
                if (delegateType == null) {
                    delegateType = new CodeTypeReference("");
                }
                return delegateType;
            }
            set {
                delegateType = value;
            }
        }

        /// <include file='doc\CodeDelegateCreateExpression.uex' path='docs/doc[@for="CodeDelegateCreateExpression.TargetObject"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the target object.
        ///    </para>
        /// </devdoc>
        public CodeExpression TargetObject {
            get {
                return targetObject;
            }
            set {
                targetObject = value;
            }
        }

        /// <include file='doc\CodeDelegateCreateExpression.uex' path='docs/doc[@for="CodeDelegateCreateExpression.MethodName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the method name.
        ///    </para>
        /// </devdoc>
        public string MethodName {
            get {
                return (methodName == null) ? string.Empty : methodName;
            }
            set {
                methodName = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeconstructor.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeConstructor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeConstructor.uex' path='docs/doc[@for="CodeConstructor"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a class constructor.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeConstructor : CodeMemberMethod {
        private CodeExpressionCollection baseConstructorArgs = new CodeExpressionCollection();
        private CodeExpressionCollection chainedConstructorArgs = new CodeExpressionCollection();

        /// <include file='doc\CodeConstructor.uex' path='docs/doc[@for="CodeConstructor.CodeConstructor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeConstructor'/>.
        ///    </para>
        /// </devdoc>
        public CodeConstructor() {
            Name = ".ctor";
        }

        /// <include file='doc\CodeConstructor.uex' path='docs/doc[@for="CodeConstructor.BaseConstructorArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the base constructor arguments.
        ///    </para>
        /// </devdoc>
        public CodeExpressionCollection BaseConstructorArgs {
            get {
                return baseConstructorArgs;
            }
        }

        /// <include file='doc\CodeConstructor.uex' path='docs/doc[@for="CodeConstructor.ChainedConstructorArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the chained constructor arguments.
        ///    </para>
        /// </devdoc>
        public CodeExpressionCollection ChainedConstructorArgs {
            get {
                return chainedConstructorArgs;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeentrypointmethod.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeEntryPointMethod.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeEntryPointMethod.uex' path='docs/doc[@for="CodeEntryPointMethod"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a class method that is the entry point
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeEntryPointMethod : CodeMemberMethod {

        /// <include file='doc\CodeEntryPointMethod.uex' path='docs/doc[@for="CodeEntryPointMethod.CodeEntryPointMethod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeEntryPointMethod() {
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeconditionstatement.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeConditionStatement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeConditionStatement.uex' path='docs/doc[@for="CodeConditionStatement"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a basic if statement.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeConditionStatement : CodeStatement {
        private CodeExpression condition;
        private CodeStatementCollection trueStatments = new CodeStatementCollection();
        private CodeStatementCollection falseStatments = new CodeStatementCollection();

        /// <include file='doc\CodeConditionStatement.uex' path='docs/doc[@for="CodeConditionStatement.CodeConditionStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeConditionStatement'/>.
        ///    </para>
        /// </devdoc>
        public CodeConditionStatement() {
        }

        /// <include file='doc\CodeConditionStatement.uex' path='docs/doc[@for="CodeConditionStatement.CodeConditionStatement1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeConditionStatement'/>.
        ///    </para>
        /// </devdoc>
        public CodeConditionStatement(CodeExpression condition, params CodeStatement[] trueStatements) {
            Condition = condition;
            TrueStatements.AddRange(trueStatements);
        }

        /// <include file='doc\CodeConditionStatement.uex' path='docs/doc[@for="CodeConditionStatement.CodeConditionStatement2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeConditionStatement'/> that can represent an if..
        ///       else statement.
        ///    </para>
        /// </devdoc>
        public CodeConditionStatement(CodeExpression condition, CodeStatement[] trueStatements, CodeStatement[] falseStatements) {
            Condition = condition;
            TrueStatements.AddRange(trueStatements);
            FalseStatements.AddRange(falseStatements);
        }

        /// <include file='doc\CodeConditionStatement.uex' path='docs/doc[@for="CodeConditionStatement.Condition"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the condition to test for <see langword='true'/>.
        ///    </para>
        /// </devdoc>
        public CodeExpression Condition {
            get {
                return condition;
            }
            set {
                condition = value;
            }
        }

        /// <include file='doc\CodeConditionStatement.uex' path='docs/doc[@for="CodeConditionStatement.TrueStatements"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the statements to execute if test condition is <see langword='true'/>.
        ///    </para>
        /// </devdoc>
        public CodeStatementCollection TrueStatements {
            get {
                return trueStatments;
            }
        }

        /// <include file='doc\CodeConditionStatement.uex' path='docs/doc[@for="CodeConditionStatement.FalseStatements"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the statements to
        ///       execute if test condition is <see langword='false'/> and there is an else
        ///       clause.
        ///    </para>
        /// </devdoc>
        public CodeStatementCollection FalseStatements {
            get {
                return falseStatments;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codedirectionexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeDirectionExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeDirectionExpression.uex' path='docs/doc[@for="CodeDirectionExpression"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeDirectionExpression : CodeExpression {
        private CodeExpression expression;
        private FieldDirection direction = FieldDirection.In;


        /// <include file='doc\CodeDirectionExpression.uex' path='docs/doc[@for="CodeDirectionExpression.CodeDirectionExpression"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeDirectionExpression() {
        }

        /// <include file='doc\CodeDirectionExpression.uex' path='docs/doc[@for="CodeDirectionExpression.CodeDirectionExpression1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeDirectionExpression(FieldDirection direction, CodeExpression expression) {
            this.expression = expression;
            this.direction = direction;
        }

        /// <include file='doc\CodeDirectionExpression.uex' path='docs/doc[@for="CodeDirectionExpression.Expression"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeExpression Expression {
            get {
                return expression;
            }
            set {
                expression = value;
            }
        }

        /// <include file='doc\CodeDirectionExpression.uex' path='docs/doc[@for="CodeDirectionExpression.Direction"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public FieldDirection Direction {
            get {
                return direction;
            }
            set {
                direction = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codedelegateinvokeexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeDelegateInvokeExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeDelegateInvokeExpression.uex' path='docs/doc[@for="CodeDelegateInvokeExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents an
    ///       expression that invokes a delegate.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeDelegateInvokeExpression : CodeExpression {
        private CodeExpression targetObject;
        private CodeExpressionCollection parameters = new CodeExpressionCollection();

        /// <include file='doc\CodeDelegateInvokeExpression.uex' path='docs/doc[@for="CodeDelegateInvokeExpression.CodeDelegateInvokeExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeDelegateInvokeExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeDelegateInvokeExpression() {
        }

        /// <include file='doc\CodeDelegateInvokeExpression.uex' path='docs/doc[@for="CodeDelegateInvokeExpression.CodeDelegateInvokeExpression1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeDelegateInvokeExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeDelegateInvokeExpression(CodeExpression targetObject) {
            TargetObject = targetObject;
        }

        /// <include file='doc\CodeDelegateInvokeExpression.uex' path='docs/doc[@for="CodeDelegateInvokeExpression.CodeDelegateInvokeExpression2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeDelegateInvokeExpression'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public CodeDelegateInvokeExpression(CodeExpression targetObject, params CodeExpression[] parameters) {
            TargetObject = targetObject;
            Parameters.AddRange(parameters);
        }

        /// <include file='doc\CodeDelegateInvokeExpression.uex' path='docs/doc[@for="CodeDelegateInvokeExpression.TargetObject"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The
        ///       delegate's target object.
        ///    </para>
        /// </devdoc>
        public CodeExpression TargetObject {
            get {
                return targetObject;
            }
            set {
                this.targetObject = value;
            }
        }

        /// <include file='doc\CodeDelegateInvokeExpression.uex' path='docs/doc[@for="CodeDelegateInvokeExpression.Parameters"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The
        ///       delegate parameters.
        ///    </para>
        /// </devdoc>
        public CodeExpressionCollection Parameters {
            get {
                return parameters;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeeventreferenceexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeEventReferenceExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeEventReferenceExpression.uex' path='docs/doc[@for="CodeEventReferenceExpression"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeEventReferenceExpression : CodeExpression {
        private CodeExpression targetObject;
        private string eventName;

        /// <include file='doc\CodeEventReferenceExpression.uex' path='docs/doc[@for="CodeEventReferenceExpression.CodeEventReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeEventReferenceExpression() {
        }

        /// <include file='doc\CodeEventReferenceExpression.uex' path='docs/doc[@for="CodeEventReferenceExpression.CodeEventReferenceExpression1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeEventReferenceExpression(CodeExpression targetObject, string eventName) {
            this.targetObject = targetObject;
            this.eventName = eventName;
        }

        /// <include file='doc\CodeEventReferenceExpression.uex' path='docs/doc[@for="CodeEventReferenceExpression.TargetObject"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeExpression TargetObject {
            get {
                return targetObject;
            }
            set {
                this.targetObject = value;
            }
        }

        /// <include file='doc\CodeEventReferenceExpression.uex' path='docs/doc[@for="CodeEventReferenceExpression.EventName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string EventName {
            get {
                return (eventName == null) ? string.Empty : eventName;
            }
            set {
                eventName = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeExpression.uex' path='docs/doc[@for="CodeExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a code expression.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeExpression: CodeObject {

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeexpressioncollection.cs ===
// ------------------------------------------------------------------------------
// <copyright file="CodeExpressionCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright> 
// ------------------------------------------------------------------------------
// 
namespace System.CodeDom {
    using System;
    using System.Collections;
    using System.Runtime.InteropServices;
    
    
    /// <include file='doc\CodeExpressionCollection.uex' path='docs/doc[@for="CodeExpressionCollection"]/*' />
    /// <devdoc>
    ///     <para>
    ///       A collection that stores <see cref='System.CodeDom.CodeExpression'/> objects.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable()
    ]
    public class CodeExpressionCollection : CollectionBase {
        
        /// <include file='doc\CodeExpressionCollection.uex' path='docs/doc[@for="CodeExpressionCollection.CodeExpressionCollection"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeExpressionCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeExpressionCollection() {
        }
        
        /// <include file='doc\CodeExpressionCollection.uex' path='docs/doc[@for="CodeExpressionCollection.CodeExpressionCollection1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeExpressionCollection'/> based on another <see cref='System.CodeDom.CodeExpressionCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeExpressionCollection(CodeExpressionCollection value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeExpressionCollection.uex' path='docs/doc[@for="CodeExpressionCollection.CodeExpressionCollection2"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeExpressionCollection'/> containing any array of <see cref='System.CodeDom.CodeExpression'/> objects.
        ///    </para>
        /// </devdoc>
        public CodeExpressionCollection(CodeExpression[] value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeExpressionCollection.uex' path='docs/doc[@for="CodeExpressionCollection.this"]/*' />
        /// <devdoc>
        /// <para>Represents the entry at the specified index of the <see cref='System.CodeDom.CodeExpression'/>.</para>
        /// </devdoc>
        public CodeExpression this[int index] {
            get {
                return ((CodeExpression)(List[index]));
            }
            set {
                List[index] = value;
            }
        }
        
        /// <include file='doc\CodeExpressionCollection.uex' path='docs/doc[@for="CodeExpressionCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>Adds a <see cref='System.CodeDom.CodeExpression'/> with the specified value to the 
        ///    <see cref='System.CodeDom.CodeExpressionCollection'/> .</para>
        /// </devdoc>
        public int Add(CodeExpression value) {
            return List.Add(value);
        }
        
        /// <include file='doc\CodeExpressionCollection.uex' path='docs/doc[@for="CodeExpressionCollection.AddRange"]/*' />
        /// <devdoc>
        /// <para>Copies the elements of an array to the end of the <see cref='System.CodeDom.CodeExpressionCollection'/>.</para>
        /// </devdoc>
        public void AddRange(CodeExpression[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeExpressionCollection.uex' path='docs/doc[@for="CodeExpressionCollection.AddRange1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Adds the contents of another <see cref='System.CodeDom.CodeExpressionCollection'/> to the end of the collection.
        ///    </para>
        /// </devdoc>
        public void AddRange(CodeExpressionCollection value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeExpressionCollection.uex' path='docs/doc[@for="CodeExpressionCollection.Contains"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the 
        ///    <see cref='System.CodeDom.CodeExpressionCollection'/> contains the specified <see cref='System.CodeDom.CodeExpression'/>.</para>
        /// </devdoc>
        public bool Contains(CodeExpression value) {
            return List.Contains(value);
        }
        
        /// <include file='doc\CodeExpressionCollection.uex' path='docs/doc[@for="CodeExpressionCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the <see cref='System.CodeDom.CodeExpressionCollection'/> values to a one-dimensional <see cref='System.Array'/> instance at the 
        ///    specified index.</para>
        /// </devdoc>
        public void CopyTo(CodeExpression[] array, int index) {
            List.CopyTo(array, index);
        }
        
        /// <include file='doc\CodeExpressionCollection.uex' path='docs/doc[@for="CodeExpressionCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>Returns the index of a <see cref='System.CodeDom.CodeExpression'/> in 
        ///       the <see cref='System.CodeDom.CodeExpressionCollection'/> .</para>
        /// </devdoc>
        public int IndexOf(CodeExpression value) {
            return List.IndexOf(value);
        }
        
        /// <include file='doc\CodeExpressionCollection.uex' path='docs/doc[@for="CodeExpressionCollection.Insert"]/*' />
        /// <devdoc>
        /// <para>Inserts a <see cref='System.CodeDom.CodeExpression'/> into the <see cref='System.CodeDom.CodeExpressionCollection'/> at the specified index.</para>
        /// </devdoc>
        public void Insert(int index, CodeExpression value) {
            List.Insert(index, value);
        }
        
        /// <include file='doc\CodeExpressionCollection.uex' path='docs/doc[@for="CodeExpressionCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para> Removes a specific <see cref='System.CodeDom.CodeExpression'/> from the 
        ///    <see cref='System.CodeDom.CodeExpressionCollection'/> .</para>
        /// </devdoc>
        public void Remove(CodeExpression value) {
            List.Remove(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeexpressionstatement.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeExpressionStatement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeExpressionStatement.uex' path='docs/doc[@for="CodeExpressionStatement"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents
    ///       a statement that is an expression.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeExpressionStatement : CodeStatement {
        private CodeExpression expression;

        /// <include file='doc\CodeExpressionStatement.uex' path='docs/doc[@for="CodeExpressionStatement.CodeExpressionStatement"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeExpressionStatement() {
        }
        
        /// <include file='doc\CodeExpressionStatement.uex' path='docs/doc[@for="CodeExpressionStatement.CodeExpressionStatement1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeExpressionStatement(CodeExpression expression) {
            this.expression = expression;
        }

        /// <include file='doc\CodeExpressionStatement.uex' path='docs/doc[@for="CodeExpressionStatement.Expression"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeExpression Expression {
            get {
                return expression;
            }
            set {
                expression = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codelabeledstatement.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeLabeledStatement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeLabeledStatement.uex' path='docs/doc[@for="CodeLabeledStatement"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeLabeledStatement : CodeStatement {
        private string label;
        private CodeStatement statement;

        /// <include file='doc\CodeLabeledStatement.uex' path='docs/doc[@for="CodeLabeledStatement.CodeLabeledStatement"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeLabeledStatement() {
        }

        /// <include file='doc\CodeLabeledStatement.uex' path='docs/doc[@for="CodeLabeledStatement.CodeLabeledStatement1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeLabeledStatement(string label) {
            this.label = label;
        }

        /// <include file='doc\CodeLabeledStatement.uex' path='docs/doc[@for="CodeLabeledStatement.CodeLabeledStatement2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeLabeledStatement(string label, CodeStatement statement) {
            this.label = label;
            this.statement = statement;
        }

        /// <include file='doc\CodeLabeledStatement.uex' path='docs/doc[@for="CodeLabeledStatement.Label"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Label {
            get {
                return (label == null) ? string.Empty : label;
            }
            set {
                this.label = value;
            }
        }

        /// <include file='doc\CodeLabeledStatement.uex' path='docs/doc[@for="CodeLabeledStatement.Statement"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeStatement Statement {
            get {
                return statement;
            }
            set {
                this.statement = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeiterationstatement.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeIterationStatement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeIterationStatement.uex' path='docs/doc[@for="CodeIterationStatement"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a simple for loop.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeIterationStatement : CodeStatement {
        private CodeStatement initStatement;
        private CodeExpression testExpression;
        private CodeStatement incrementStatement;
        private CodeStatementCollection statements = new CodeStatementCollection();

        /// <include file='doc\CodeIterationStatement.uex' path='docs/doc[@for="CodeIterationStatement.CodeIterationStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeIterationStatement'/>.
        ///    </para>
        /// </devdoc>
        public CodeIterationStatement() {
        }

        /// <include file='doc\CodeIterationStatement.uex' path='docs/doc[@for="CodeIterationStatement.CodeIterationStatement1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeIterationStatement'/>.
        ///    </para>
        /// </devdoc>
        public CodeIterationStatement(CodeStatement initStatement, CodeExpression testExpression, CodeStatement incrementStatement, params CodeStatement[] statements) {
            InitStatement = initStatement;
            TestExpression = testExpression;
            IncrementStatement = incrementStatement;
            Statements.AddRange(statements);
        }

        /// <include file='doc\CodeIterationStatement.uex' path='docs/doc[@for="CodeIterationStatement.InitStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the loop initialization statement.
        ///    </para>
        /// </devdoc>
        public CodeStatement InitStatement {
            get {
                return initStatement;
            }
            set {
                initStatement = value;
            }
        }

        /// <include file='doc\CodeIterationStatement.uex' path='docs/doc[@for="CodeIterationStatement.TestExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the expression to test for.
        ///    </para>
        /// </devdoc>
        public CodeExpression TestExpression {
            get {
                return testExpression;
            }
            set {
                testExpression = value;
            }
        }

        /// <include file='doc\CodeIterationStatement.uex' path='docs/doc[@for="CodeIterationStatement.IncrementStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the per loop cycle increment statement.
        ///    </para>
        /// </devdoc>
        public CodeStatement IncrementStatement {
            get {
                return incrementStatement;
            }
            set {
                incrementStatement = value;
            }
        }

        /// <include file='doc\CodeIterationStatement.uex' path='docs/doc[@for="CodeIterationStatement.Statements"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the statements to be executed within the loop.
        ///    </para>
        /// </devdoc>
        public CodeStatementCollection Statements {
            get {
                return statements;
            }
        }        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeindexerexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeIndexerExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeIndexerExpression.uex' path='docs/doc[@for="CodeIndexerExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents an array indexer expression.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeIndexerExpression : CodeExpression {
        private CodeExpression targetObject;
        private CodeExpressionCollection indices;

        /// <include file='doc\CodeIndexerExpression.uex' path='docs/doc[@for="CodeIndexerExpression.CodeIndexerExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeIndexerExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeIndexerExpression() {
        }

        /// <include file='doc\CodeIndexerExpression.uex' path='docs/doc[@for="CodeIndexerExpression.CodeIndexerExpression1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeIndexerExpression'/> using the specified target
        ///       object and index.
        ///    </para>
        /// </devdoc>
        public CodeIndexerExpression(CodeExpression targetObject, params CodeExpression[] indices) {
            this.targetObject = targetObject;
            this.indices = new CodeExpressionCollection();
            this.indices.AddRange(indices);
        }

        /// <include file='doc\CodeIndexerExpression.uex' path='docs/doc[@for="CodeIndexerExpression.TargetObject"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the target object.
        ///    </para>
        /// </devdoc>
        public CodeExpression TargetObject {
            get {
                return targetObject;
            }
            set {
                targetObject = value;
            }
        }

        /// <include file='doc\CodeIndexerExpression.uex' path='docs/doc[@for="CodeIndexerExpression.Indices"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the index.
        ///    </para>
        /// </devdoc>
        public CodeExpressionCollection Indices {
            get {
                if (indices == null) {
                    indices = new CodeExpressionCollection();
                }
                return indices;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codelinepragma.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeLinePragma.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeLinePragma.uex' path='docs/doc[@for="CodeLinePragma"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents line number information for an external file.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeLinePragma {
        private string fileName;
        private int lineNumber;

        /// <include file='doc\CodeLinePragma.uex' path='docs/doc[@for="CodeLinePragma.CodeLinePragma"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeLinePragma'/>.
        ///    </para>
        /// </devdoc>
        public CodeLinePragma(string fileName, int lineNumber) {
            FileName = fileName;
            LineNumber = lineNumber;
        }

        /// <include file='doc\CodeLinePragma.uex' path='docs/doc[@for="CodeLinePragma.FileName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the filename of
        ///       the associated file.
        ///    </para>
        /// </devdoc>
        public string FileName {
            get {
                return (fileName == null) ? string.Empty : fileName;
            }
            set {
                fileName = value;
            }
        }

        /// <include file='doc\CodeLinePragma.uex' path='docs/doc[@for="CodeLinePragma.LineNumber"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the line number of the file for
        ///       the current pragma.
        ///    </para>
        /// </devdoc>
        public int LineNumber {
            get {
                return lineNumber;
            }
            set {
                lineNumber = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codefieldreferenceexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeFieldReferenceExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeFieldReferenceExpression.uex' path='docs/doc[@for="CodeFieldReferenceExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a reference to a field.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeFieldReferenceExpression : CodeExpression {
        private CodeExpression targetObject;
        private string fieldName;

        /// <include file='doc\CodeFieldReferenceExpression.uex' path='docs/doc[@for="CodeFieldReferenceExpression.CodeFieldReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeFieldReferenceExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeFieldReferenceExpression() {
        }

        /// <include file='doc\CodeFieldReferenceExpression.uex' path='docs/doc[@for="CodeFieldReferenceExpression.CodeFieldReferenceExpression1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeFieldReferenceExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeFieldReferenceExpression(CodeExpression targetObject, string fieldName) {
            TargetObject = targetObject;
            FieldName = fieldName;
        }

        /// <include file='doc\CodeFieldReferenceExpression.uex' path='docs/doc[@for="CodeFieldReferenceExpression.TargetObject"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the target object.
        ///    </para>
        /// </devdoc>
        public CodeExpression TargetObject {
            get {
                return targetObject;
            }
            set {
                targetObject = value;
            }
        }

        /// <include file='doc\CodeFieldReferenceExpression.uex' path='docs/doc[@for="CodeFieldReferenceExpression.FieldName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the field name.
        ///    </para>
        /// </devdoc>
        public string FieldName {
            get {
                return (fieldName == null) ? string.Empty : fieldName;
            }
            set {
                fieldName = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codegotostatement.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeGotoStatement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeGotoStatement.uex' path='docs/doc[@for="CodeGotoStatement"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeGotoStatement : CodeStatement {
        private string label;

        /// <include file='doc\CodeGotoStatement.uex' path='docs/doc[@for="CodeGotoStatement.CodeGotoStatement"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeGotoStatement(string label) {
            Label = label;
        }

        /// <include file='doc\CodeGotoStatement.uex' path='docs/doc[@for="CodeGotoStatement.Label"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Label {
            get {
                return label;
            }
            set {
                this.label = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codememberevent.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeMemberEvent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeMemberEvent.uex' path='docs/doc[@for="CodeMemberEvent"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents an event member.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeMemberEvent : CodeTypeMember {
        private CodeTypeReference type;
        private CodeTypeReference privateImplements = null;
        private CodeTypeReferenceCollection implementationTypes = null;

        /// <include file='doc\CodeMemberEvent.uex' path='docs/doc[@for="CodeMemberEvent.CodeMemberEvent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeMemberEvent() {
        }

        /// <include file='doc\CodeMemberEvent.uex' path='docs/doc[@for="CodeMemberEvent.Type"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the member field type.
        ///    </para>
        /// </devdoc>
        public CodeTypeReference Type {
            get {
                if (type == null) {
                    type = new CodeTypeReference("");
                }
                return type;
            }
            set {
                type = value;
            }
        }
        
        /// <include file='doc\CodeMemberEvent.uex' path='docs/doc[@for="CodeMemberEvent.PrivateImplementationType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeTypeReference PrivateImplementationType {
            get {
                return privateImplements;
            }
            set {
                privateImplements = value;
            }
        }

        /// <include file='doc\CodeMemberEvent.uex' path='docs/doc[@for="CodeMemberEvent.ImplementationTypes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeTypeReferenceCollection ImplementationTypes {
            get {
                if (implementationTypes == null) {
                    implementationTypes = new CodeTypeReferenceCollection();
                }
                return implementationTypes;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codemembermethod.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeMemberMethod.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeMemberMethod.uex' path='docs/doc[@for="CodeMemberMethod"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a class method.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeMemberMethod : CodeTypeMember {
        private CodeParameterDeclarationExpressionCollection parameters = new CodeParameterDeclarationExpressionCollection();
        private CodeStatementCollection statements = new CodeStatementCollection();
        private CodeTypeReference returnType;
        private CodeTypeReference privateImplements = null;
        private CodeTypeReferenceCollection implementationTypes = null;
        private CodeAttributeDeclarationCollection returnAttributes = null;
        
        private int  populated = 0x0;
        private const int ParametersCollection = 0x1;
        private const int StatementsCollection = 0x2;
        private const int ImplTypesCollection = 0x4;
        
        /// <include file='doc\CodeMemberMethod.uex' path='docs/doc[@for="CodeMemberMethod.PopulateParameters"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An event that will be fired the first time the Parameters Collection is accessed.  
        ///    </para>
        /// </devdoc>
        public event EventHandler PopulateParameters;
        
        /// <include file='doc\CodeMemberMethod.uex' path='docs/doc[@for="CodeMemberMethod.PopulateStatements"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An event that will be fired the first time the Statements Collection is accessed.  
        ///    </para>
        /// </devdoc>
        public event EventHandler PopulateStatements;
        
        /// <include file='doc\CodeMemberMethod.uex' path='docs/doc[@for="CodeMemberMethod.PopulateImplementationTypes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An event that will be fired the first time the ImplementationTypes Collection is accessed.  
        ///    </para>
        /// </devdoc>
        public event EventHandler PopulateImplementationTypes;
        
        /// <include file='doc\CodeMemberMethod.uex' path='docs/doc[@for="CodeMemberMethod.ReturnType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the return type of the method.
        ///    </para>
        /// </devdoc>
        public CodeTypeReference ReturnType {
            get {
                if (returnType == null) {
                    returnType = new CodeTypeReference(typeof(void).FullName);
                }
                return returnType;
            }
            set {
                returnType = value;
            }
        }

        /// <include file='doc\CodeMemberMethod.uex' path='docs/doc[@for="CodeMemberMethod.Statements"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the statements within the method.
        ///    </para>
        /// </devdoc>
        public CodeStatementCollection Statements {
            get {
                if (0 == (populated & StatementsCollection)) {
                    populated |= StatementsCollection;
                    if (PopulateStatements != null) PopulateStatements(this, EventArgs.Empty);
                }
                return statements;
            }
        }

        /// <include file='doc\CodeMemberMethod.uex' path='docs/doc[@for="CodeMemberMethod.Parameters"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the parameter declarations for the method.
        ///    </para>
        /// </devdoc>
        public CodeParameterDeclarationExpressionCollection Parameters {
            get {
                if (0 == (populated & ParametersCollection)) {
                    populated |= ParametersCollection;
                    if (PopulateParameters != null) PopulateParameters(this, EventArgs.Empty);
                }
                return parameters;
            }
        }

        /// <include file='doc\CodeMemberMethod.uex' path='docs/doc[@for="CodeMemberMethod.PrivateImplementationType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeTypeReference PrivateImplementationType {
            get {
                return privateImplements;
            }
            set {
                privateImplements = value;
            }
        }

        /// <include file='doc\CodeMemberMethod.uex' path='docs/doc[@for="CodeMemberMethod.ImplementationTypes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeTypeReferenceCollection ImplementationTypes {
            get {
                if (implementationTypes == null) {
                    implementationTypes = new CodeTypeReferenceCollection();
                }
                
                if (0 == (populated & ImplTypesCollection)) {
                    populated |= ImplTypesCollection;
                    if (PopulateImplementationTypes != null) PopulateImplementationTypes(this, EventArgs.Empty);
                }
                return implementationTypes;
            }
        }

        /// <include file='doc\CodeMemberMethod.uex' path='docs/doc[@for="CodeMemberMethod.ReturnTypeCustomAttributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeAttributeDeclarationCollection ReturnTypeCustomAttributes {
            get {
                if (returnAttributes == null) {
                    returnAttributes = new CodeAttributeDeclarationCollection();
                }
                return returnAttributes;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codemethodinvokeexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeMethodInvokeExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeMethodInvokeExpression.uex' path='docs/doc[@for="CodeMethodInvokeExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents an
    ///       expression to invoke a method, to be called on a given target.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeMethodInvokeExpression : CodeExpression {
        private CodeMethodReferenceExpression method;
        private CodeExpressionCollection parameters = new CodeExpressionCollection();

        /// <include file='doc\CodeMethodInvokeExpression.uex' path='docs/doc[@for="CodeMethodInvokeExpression.CodeMethodInvokeExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeMethodInvokeExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeMethodInvokeExpression() {
        }

        /// <include file='doc\CodeMethodInvokeExpression.uex' path='docs/doc[@for="CodeMethodInvokeExpression.CodeMethodInvokeExpression1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeMethodInvokeExpression'/> using the specified target object, method name
        ///       and parameters.
        ///    </para>
        /// </devdoc>
        public CodeMethodInvokeExpression(CodeMethodReferenceExpression method, params CodeExpression[] parameters) {
            this.method = method;
            Parameters.AddRange(parameters);
        }

        /// <include file='doc\CodeMethodInvokeExpression.uex' path='docs/doc[@for="CodeMethodInvokeExpression.CodeMethodInvokeExpression2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeMethodInvokeExpression(CodeExpression targetObject, string methodName, params CodeExpression[] parameters) {
            this.method = new CodeMethodReferenceExpression(targetObject, methodName);
            Parameters.AddRange(parameters);
        }

        /// <include file='doc\CodeMethodInvokeExpression.uex' path='docs/doc[@for="CodeMethodInvokeExpression.Method"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the name of the method to invoke.
        ///    </para>
        /// </devdoc>
        public CodeMethodReferenceExpression Method {
            get {
                if (method == null) {
                    method = new CodeMethodReferenceExpression();
                }
                return method;
            }
            set {
                method = value;
            }
        }

        /// <include file='doc\CodeMethodInvokeExpression.uex' path='docs/doc[@for="CodeMethodInvokeExpression.Parameters"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the parameters to invoke the method with.
        ///    </para>
        /// </devdoc>
        public CodeExpressionCollection Parameters {
            get {
                return parameters;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codemethodreferenceexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="codemethodreferenceexpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\codemethodreferenceexpression.uex' path='docs/doc[@for="CodeMethodReferenceExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents an
    ///       expression to invoke a method, to be called on a given target.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeMethodReferenceExpression : CodeExpression {
        private CodeExpression targetObject;
        private string methodName;

        /// <include file='doc\codemethodreferenceexpression.uex' path='docs/doc[@for="CodeMethodReferenceExpression.CodeMethodReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeMethodReferenceExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeMethodReferenceExpression() {
        }

        /// <include file='doc\codemethodreferenceexpression.uex' path='docs/doc[@for="CodeMethodReferenceExpression.CodeMethodReferenceExpression1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeMethodReferenceExpression'/> using the specified
        ///       target object and method name.
        ///    </para>
        /// </devdoc>
        public CodeMethodReferenceExpression(CodeExpression targetObject, string methodName) {
            TargetObject = targetObject;
            MethodName = methodName;
        }

        /// <include file='doc\codemethodreferenceexpression.uex' path='docs/doc[@for="CodeMethodReferenceExpression.TargetObject"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the target object.
        ///    </para>
        /// </devdoc>
        public CodeExpression TargetObject {
            get {
                return targetObject;
            }
            set {
                this.targetObject = value;
            }
        }

        /// <include file='doc\codemethodreferenceexpression.uex' path='docs/doc[@for="CodeMethodReferenceExpression.MethodName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the name of the method to invoke.
        ///    </para>
        /// </devdoc>
        public string MethodName {
            get {
                return (methodName == null) ? string.Empty : methodName;
            }
            set {
                methodName = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codememberfield.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeMemberField.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeMemberField.uex' path='docs/doc[@for="CodeMemberField"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a class field member.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeMemberField : CodeTypeMember {
        private CodeTypeReference type;
        private CodeExpression initExpression;

        /// <include file='doc\CodeMemberField.uex' path='docs/doc[@for="CodeMemberField.CodeMemberField"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new <see cref='System.CodeDom.CodeMemberField'/>.
        ///    </para>
        /// </devdoc>
        public CodeMemberField() {
        }

        /// <include file='doc\CodeMemberField.uex' path='docs/doc[@for="CodeMemberField.CodeMemberField1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new <see cref='System.CodeDom.CodeMemberField'/> with the specified member field type and
        ///       name.
        ///    </para>
        /// </devdoc>
        public CodeMemberField(CodeTypeReference type, string name) {
            Type = type;
            Name = name;
        }

        /// <include file='doc\CodeMemberField.uex' path='docs/doc[@for="CodeMemberField.CodeMemberField2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeMemberField(string type, string name) {
            Type = new CodeTypeReference(type);
            Name = name;
        }

        /// <include file='doc\CodeMemberField.uex' path='docs/doc[@for="CodeMemberField.CodeMemberField3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeMemberField(Type type, string name) {
            Type = new CodeTypeReference(type);
            Name = name;
        }

        /// <include file='doc\CodeMemberField.uex' path='docs/doc[@for="CodeMemberField.Type"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the member field type.
        ///    </para>
        /// </devdoc>
        public CodeTypeReference Type {
            get {
                if (type == null) {
                    type = new CodeTypeReference("");
                }
                return type;
            }
            set {
                type = value;
            }
        }

        /// <include file='doc\CodeMemberField.uex' path='docs/doc[@for="CodeMemberField.InitExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the initialization expression for the member field.
        ///    </para>
        /// </devdoc>
        public CodeExpression InitExpression {
            get {
                return initExpression;
            }
            set {
                initExpression = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codememberproperty.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeMemberProperty.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeMemberProperty.uex' path='docs/doc[@for="CodeMemberProperty"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a class property.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeMemberProperty : CodeTypeMember {
        private CodeTypeReference type;
        private CodeParameterDeclarationExpressionCollection parameters = new CodeParameterDeclarationExpressionCollection();
        private bool hasGet;
        private bool hasSet;
        private CodeStatementCollection getStatements = new CodeStatementCollection();
        private CodeStatementCollection setStatements = new CodeStatementCollection();
        private CodeTypeReference privateImplements = null;
        private CodeTypeReferenceCollection implementationTypes = null;
        
        /// <include file='doc\CodeMemberProperty.uex' path='docs/doc[@for="CodeMemberProperty.PrivateImplementationType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeTypeReference PrivateImplementationType {
            get {
                return privateImplements;
            }
            set {
                privateImplements = value;
            }
        }

        /// <include file='doc\CodeMemberProperty.uex' path='docs/doc[@for="CodeMemberProperty.ImplementationTypes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeTypeReferenceCollection ImplementationTypes {
            get {
                if (implementationTypes == null) {
                    implementationTypes = new CodeTypeReferenceCollection();
                }
                return implementationTypes;
            }
        }

        /// <include file='doc\CodeMemberProperty.uex' path='docs/doc[@for="CodeMemberProperty.Type"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the data type of the property.</para>
        /// </devdoc>
        public CodeTypeReference Type {
            get {
                if (type == null) {
                    type = new CodeTypeReference("");
                }
                return type;
            }
            set {
                type = value;
            }
        }

        /// <include file='doc\CodeMemberProperty.uex' path='docs/doc[@for="CodeMemberProperty.HasGet"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value
        ///       indicating whether the property has a get method accessor.
        ///    </para>
        /// </devdoc>
        public bool HasGet {
            get {
                return hasGet || getStatements.Count > 0;
            }
            set {
                hasGet = value;
                if (!value) {
                    getStatements.Clear();
                }
            }
        }

        /// <include file='doc\CodeMemberProperty.uex' path='docs/doc[@for="CodeMemberProperty.HasSet"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value
        ///       indicating whether the property has a set method accessor.
        ///    </para>
        /// </devdoc>
        public bool HasSet {
            get {
                return hasSet || setStatements.Count > 0;
            }
            set {
                hasSet = value;
                if (!value) {
                    setStatements.Clear();
                }
            }
        }

        /// <include file='doc\CodeMemberProperty.uex' path='docs/doc[@for="CodeMemberProperty.GetStatements"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the collection of get statements for the
        ///       property.
        ///    </para>
        /// </devdoc>
        public CodeStatementCollection GetStatements {
            get {
                return getStatements;
            }
        }

        /// <include file='doc\CodeMemberProperty.uex' path='docs/doc[@for="CodeMemberProperty.SetStatements"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the collection of get statements for the property.
        ///    </para>
        /// </devdoc>
        public CodeStatementCollection SetStatements {
            get {
                return setStatements;
            }
        }

        /// <include file='doc\CodeMemberProperty.uex' path='docs/doc[@for="CodeMemberProperty.Parameters"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the collection of declaration expressions
        ///       for
        ///       the property.
        ///    </para>
        /// </devdoc>
        public CodeParameterDeclarationExpressionCollection Parameters {
            get {
                return parameters;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codemethodreturnstatement.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeMethodReturnStatement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeMethodReturnStatement.uex' path='docs/doc[@for="CodeMethodReturnStatement"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a return statement.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeMethodReturnStatement : CodeStatement {
        private CodeExpression expression;

        /// <include file='doc\CodeMethodReturnStatement.uex' path='docs/doc[@for="CodeMethodReturnStatement.CodeMethodReturnStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeMethodReturnStatement'/>.
        ///    </para>
        /// </devdoc>
        public CodeMethodReturnStatement() {
        }

        /// <include file='doc\CodeMethodReturnStatement.uex' path='docs/doc[@for="CodeMethodReturnStatement.CodeMethodReturnStatement1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeMethodReturnStatement'/> using the specified expression.
        ///    </para>
        /// </devdoc>
        public CodeMethodReturnStatement(CodeExpression expression) {
            Expression = expression;
        }

        /// <include file='doc\CodeMethodReturnStatement.uex' path='docs/doc[@for="CodeMethodReturnStatement.Expression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the expression that indicates the return statement.
        ///    </para>
        /// </devdoc>
        public CodeExpression Expression {
            get {
                return expression;
            }
            set {
                expression = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codenamespace.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeNamespace.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.Serialization;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeNamespace.uex' path='docs/doc[@for="CodeNamespace"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a
    ///       namespace declaration.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeNamespace: CodeObject {
        private string name;
        private CodeNamespaceImportCollection imports = new CodeNamespaceImportCollection();
        private CodeCommentStatementCollection comments = new CodeCommentStatementCollection();
        private CodeTypeDeclarationCollection classes = new CodeTypeDeclarationCollection();
        private CodeNamespaceCollection namespaces = new CodeNamespaceCollection();
        
        private int  populated = 0x0;
        private const int ImportsCollection = 0x1;
        private const int CommentsCollection = 0x2;
        private const int TypesCollection = 0x4;
        
#if CODEDOM_NESTED_NAMESPACES
        private const int NamespacesCollection = 0x8;
#endif
        
        
       
        /// <include file='doc\CodeNamespace.uex' path='docs/doc[@for="CodeNamespace.PopulateComments"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An event that will be fired the first time the Comments Collection is accessed.  
        ///    </para>
        /// </devdoc>
        public event EventHandler PopulateComments;
        
         /// <include file='doc\CodeNamespace.uex' path='docs/doc[@for="CodeNamespace.PopulateImports"]/*' />
         /// <devdoc>
        ///    <para>
        ///       An event that will be fired the first time the Imports Collection is accessed.  
        ///    </para>
        /// </devdoc>
        public event EventHandler PopulateImports;

#if CODEDOM_NESTED_NAMESPACES
         /// <include file='doc\CodeNamespace.uex' path='docs/doc[@for="CodeNamespace.PopulateNamespaces"]/*' />
         /// <devdoc>
        ///    <para>
        ///       An event that will be fired the first time the Namespaces Collection is accessed.  
        ///    </para>
        /// </devdoc>
        public event EventHandler PopulateNamespaces;
#endif
        
        
        /// <include file='doc\CodeNamespace.uex' path='docs/doc[@for="CodeNamespace.PopulateTypes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An event that will be fired the first time the Types Collection is accessed.  
        ///    </para>
        /// </devdoc>
        public event EventHandler PopulateTypes;

        /// <include file='doc\CodeNamespace.uex' path='docs/doc[@for="CodeNamespace.CodeNamespace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeNamespace'/>.
        ///    </para>
        /// </devdoc>
        public CodeNamespace() {
        }

        /// <include file='doc\CodeNamespace.uex' path='docs/doc[@for="CodeNamespace.CodeNamespace1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeNamespace'/> using the specified name.
        ///    </para>
        /// </devdoc>
        public CodeNamespace(string name) {
            Name = name;
        }

        private CodeNamespace(SerializationInfo info, StreamingContext context) {
        }

        /// <include file='doc\CodeNamespace.uex' path='docs/doc[@for="CodeNamespace.Types"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the collection of classes.
        ///    </para>
        /// </devdoc>
        public CodeTypeDeclarationCollection Types {
            get {
                if (0 == (populated & TypesCollection)) {
                    populated |= TypesCollection;
                    if (PopulateTypes != null) PopulateTypes(this, EventArgs.Empty);
                }
                return classes;
            }
        }

        /// <include file='doc\CodeNamespace.uex' path='docs/doc[@for="CodeNamespace.Imports"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the collection of namespace imports used by the represented
        ///       namespace.
        ///    </para>
        /// </devdoc>
        public CodeNamespaceImportCollection Imports {
            get {
                if (0 == (populated & ImportsCollection)) {
                    populated |= ImportsCollection;
                    if (PopulateImports != null) PopulateImports(this, EventArgs.Empty);
                }
                return imports;
            }
        }

        /// <include file='doc\CodeNamespace.uex' path='docs/doc[@for="CodeNamespace.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the name of the namespace.
        ///    </para>
        /// </devdoc>
        public string Name {
            get {
                return (name == null) ? string.Empty : name;
            }
            set {
                name = value;
            }
        }
        
        
#if CODEDOM_NESTED_NAMESPACES
        
        /// <include file='doc\CodeNamespace.uex' path='docs/doc[@for="CodeNamespace.Namespaces"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the collection of Namespaces.
        ///    </para>
        /// </devdoc>
        public CodeNamespaceCollection Namespaces {
            get {
                if (0 == (populated & NamespacesCollection)) {
                    populated |= NamespacesCollection;
                    if (PopulateNamespaces != null) PopulateNamespaces(this, EventArgs.Empty);
                }
                return namespaces;
            }
        }

#endif

        /// <include file='doc\CodeNamespace.uex' path='docs/doc[@for="CodeNamespace.Comments"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the member comment collection members.
        ///    </para>
        /// </devdoc>
        public CodeCommentStatementCollection Comments {
            get {
                if (0 == (populated & CommentsCollection)) {
                    populated |= CommentsCollection;
                    if (PopulateComments != null) PopulateComments(this, EventArgs.Empty);
                }
                return comments;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codenamespacecollection.cs ===
// ------------------------------------------------------------------------------
// <copyright file="CodeNamespaceCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright> 
// ------------------------------------------------------------------------------
// 
namespace System.CodeDom {
    using System;
    using System.Collections;
    using System.Runtime.InteropServices;
    
    
    /// <include file='doc\CodeNamespaceCollection.uex' path='docs/doc[@for="CodeNamespaceCollection"]/*' />
    /// <devdoc>
    ///     <para>
    ///       A collection that stores <see cref='System.CodeDom.CodeNamespace'/> objects.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeNamespaceCollection : CollectionBase {
        
        /// <include file='doc\CodeNamespaceCollection.uex' path='docs/doc[@for="CodeNamespaceCollection.CodeNamespaceCollection"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeNamespaceCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeNamespaceCollection() {
        }
        
        /// <include file='doc\CodeNamespaceCollection.uex' path='docs/doc[@for="CodeNamespaceCollection.CodeNamespaceCollection1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeNamespaceCollection'/> based on another <see cref='System.CodeDom.CodeNamespaceCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeNamespaceCollection(CodeNamespaceCollection value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeNamespaceCollection.uex' path='docs/doc[@for="CodeNamespaceCollection.CodeNamespaceCollection2"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeNamespaceCollection'/> containing any array of <see cref='System.CodeDom.CodeNamespace'/> objects.
        ///    </para>
        /// </devdoc>
        public CodeNamespaceCollection(CodeNamespace[] value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeNamespaceCollection.uex' path='docs/doc[@for="CodeNamespaceCollection.this"]/*' />
        /// <devdoc>
        /// <para>Represents the entry at the specified index of the <see cref='System.CodeDom.CodeNamespace'/>.</para>
        /// </devdoc>
        public CodeNamespace this[int index] {
            get {
                return ((CodeNamespace)(List[index]));
            }
            set {
                List[index] = value;
            }
        }
        
        /// <include file='doc\CodeNamespaceCollection.uex' path='docs/doc[@for="CodeNamespaceCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>Adds a <see cref='System.CodeDom.CodeNamespace'/> with the specified value to the 
        ///    <see cref='System.CodeDom.CodeNamespaceCollection'/> .</para>
        /// </devdoc>
        public int Add(CodeNamespace value) {
            return List.Add(value);
        }
        
        /// <include file='doc\CodeNamespaceCollection.uex' path='docs/doc[@for="CodeNamespaceCollection.AddRange"]/*' />
        /// <devdoc>
        /// <para>Copies the elements of an array to the end of the <see cref='System.CodeDom.CodeNamespaceCollection'/>.</para>
        /// </devdoc>
        public void AddRange(CodeNamespace[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeNamespaceCollection.uex' path='docs/doc[@for="CodeNamespaceCollection.AddRange1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Adds the contents of another <see cref='System.CodeDom.CodeNamespaceCollection'/> to the end of the collection.
        ///    </para>
        /// </devdoc>
        public void AddRange(CodeNamespaceCollection value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeNamespaceCollection.uex' path='docs/doc[@for="CodeNamespaceCollection.Contains"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the 
        ///    <see cref='System.CodeDom.CodeNamespaceCollection'/> contains the specified <see cref='System.CodeDom.CodeNamespace'/>.</para>
        /// </devdoc>
        public bool Contains(CodeNamespace value) {
            return List.Contains(value);
        }
        
        /// <include file='doc\CodeNamespaceCollection.uex' path='docs/doc[@for="CodeNamespaceCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the <see cref='System.CodeDom.CodeNamespaceCollection'/> values to a one-dimensional <see cref='System.Array'/> instance at the 
        ///    specified index.</para>
        /// </devdoc>
        public void CopyTo(CodeNamespace[] array, int index) {
            List.CopyTo(array, index);
        }
        
        /// <include file='doc\CodeNamespaceCollection.uex' path='docs/doc[@for="CodeNamespaceCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>Returns the index of a <see cref='System.CodeDom.CodeNamespace'/> in 
        ///       the <see cref='System.CodeDom.CodeNamespaceCollection'/> .</para>
        /// </devdoc>
        public int IndexOf(CodeNamespace value) {
            return List.IndexOf(value);
        }
        
        /// <include file='doc\CodeNamespaceCollection.uex' path='docs/doc[@for="CodeNamespaceCollection.Insert"]/*' />
        /// <devdoc>
        /// <para>Inserts a <see cref='System.CodeDom.CodeNamespace'/> into the <see cref='System.CodeDom.CodeNamespaceCollection'/> at the specified index.</para>
        /// </devdoc>
        public void Insert(int index, CodeNamespace value) {
            List.Insert(index, value);
        }
        
        /// <include file='doc\CodeNamespaceCollection.uex' path='docs/doc[@for="CodeNamespaceCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para> Removes a specific <see cref='System.CodeDom.CodeNamespace'/> from the 
        ///    <see cref='System.CodeDom.CodeNamespaceCollection'/> .</para>
        /// </devdoc>
        public void Remove(CodeNamespace value) {
            List.Remove(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeobject.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeObject.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Collections;
    using System.Collections.Specialized;
    using System.Runtime.Serialization;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeObject.uex' path='docs/doc[@for="CodeObject"]/*' />
    /// <devdoc>
    ///    <para>
    ///       The base class for CodeDom objects
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeObject {
        private IDictionary userData = null;

        /// <include file='doc\CodeObject.uex' path='docs/doc[@for="CodeObject.CodeObject"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeObject() {
        }

        /// <include file='doc\CodeObject.uex' path='docs/doc[@for="CodeObject.UserData"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IDictionary UserData {
            get {
                if (userData == null) {
                    userData = new ListDictionary();
                }
                return userData;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codenamespaceimport.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeNamespaceImport.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeNamespaceImport.uex' path='docs/doc[@for="CodeNamespaceImport"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a namespace import into the current namespace.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeNamespaceImport : CodeObject {
        private string nameSpace;
        private CodeLinePragma linePragma;

        /// <include file='doc\CodeNamespaceImport.uex' path='docs/doc[@for="CodeNamespaceImport.CodeNamespaceImport"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeNamespaceImport'/>.
        ///    </para>
        /// </devdoc>
        public CodeNamespaceImport() {
        }

        /// <include file='doc\CodeNamespaceImport.uex' path='docs/doc[@for="CodeNamespaceImport.CodeNamespaceImport1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeNamespaceImport'/> using the specified namespace
        ///       to import.
        ///    </para>
        /// </devdoc>
        public CodeNamespaceImport(string nameSpace) {
            Namespace = nameSpace;
        }

        /// <include file='doc\CodeNamespaceImport.uex' path='docs/doc[@for="CodeNamespaceImport.LinePragma"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The line the statement occurs on.
        ///    </para>
        /// </devdoc>
        public CodeLinePragma LinePragma {
            get {
                return linePragma;
            }
            set {
                linePragma = value;
            }
        }

        /// <include file='doc\CodeNamespaceImport.uex' path='docs/doc[@for="CodeNamespaceImport.Namespace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the namespace to import.
        ///    </para>
        /// </devdoc>
        public string Namespace {
            get {
                return (nameSpace == null) ? string.Empty : nameSpace;
            }
            set {
                nameSpace = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codenamespaceimportcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeNamespaceImportCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Runtime.InteropServices;
    using System.Globalization;
    
    /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Manages a collection of <see cref='System.CodeDom.CodeNamespaceImport'/> objects.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeNamespaceImportCollection : IList {
        private ArrayList data = new ArrayList();
        private Hashtable keys = new Hashtable(
                new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture),
                new CaseInsensitiveComparer(CultureInfo.InvariantCulture));

        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Indexer method that provides collection access.
        ///    </para>
        /// </devdoc>
        public CodeNamespaceImport this[int index] {
            get {
                return ((CodeNamespaceImport)data[index]);
            }
            set {
                data[index] = value;
                SyncKeys();
            }
        }

        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the number of namespaces in the collection.
        ///    </para>
        /// </devdoc>
        public int Count {
            get {
                return data.Count;
            }
        }

		/// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.IList.IsReadOnly"]/*' />
		/// <internalonly/>
		bool IList.IsReadOnly
		{
			get
			{
				return false;
			}
		}

		/// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.IList.IsFixedSize"]/*' />
		/// <internalonly/>
		bool IList.IsFixedSize
		{
			get
			{
				return false;
			}
		}


        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a namespace import to the collection.
        ///    </para>
        /// </devdoc>
        public void Add(CodeNamespaceImport value) {
            if (!keys.ContainsKey(value.Namespace)) {
                keys[value.Namespace] = value;
                data.Add(value);
            }
        }

        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.AddRange"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds a set of <see cref='System.CodeDom.CodeNamespaceImport'/> objects to the collection.
        ///    </para>
        /// </devdoc>
        public void AddRange(CodeNamespaceImport[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            foreach (CodeNamespaceImport c in value) {
                Add(c);
            }
        }

        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.Clear"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Clears the collection of members.
        ///    </para>
        /// </devdoc>
        public void Clear() {
            data.Clear();
            keys.Clear();
        }

        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.SyncKeys"]/*' />
        /// <devdoc>
        ///    <para>
        ///    Makes the collection of keys synchronised with the data.
        ///    </para>
        /// </devdoc>
        private void SyncKeys() {
            keys = new Hashtable(
                new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture),
                new CaseInsensitiveComparer(CultureInfo.InvariantCulture));
            foreach(CodeNamespaceImport c in this) {
                keys[c.Namespace] = c;
            }
        }

        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an enumerator that enumerates the collection members.
        ///    </para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return data.GetEnumerator();
        }

        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.IList.this"]/*' />
        /// <internalonly/>
        object IList.this[int index] {
            get {
                return this[index];
            }
            set {
                this[index] = (CodeNamespaceImport)value;
                SyncKeys();
            }
        }

        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.ICollection.Count"]/*' />
        /// <internalonly/>
        int ICollection.Count {
            get {
                return Count;
            }
        }

        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.ICollection.IsSynchronized"]/*' />
        /// <internalonly/>
        bool ICollection.IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.ICollection.SyncRoot"]/*' />
        /// <internalonly/>
        object ICollection.SyncRoot {
            get {
                return null;
            }
        }

        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.ICollection.CopyTo"]/*' />
        /// <internalonly/>
        void ICollection.CopyTo(Array array, int index) {
            data.CopyTo(array, index);
        }

        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.IList.Add"]/*' />
        /// <internalonly/>
        int IList.Add(object value) {
            return data.Add((CodeNamespaceImport)value);
        }

        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.IList.Clear"]/*' />
        /// <internalonly/>
        void IList.Clear() {
            Clear();
        }

        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.IList.Contains"]/*' />
        /// <internalonly/>
        bool IList.Contains(object value) {
            return data.Contains(value);
        }

        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.IList.IndexOf"]/*' />
        /// <internalonly/>
        int IList.IndexOf(object value) {
            return data.IndexOf((CodeNamespaceImport)value);
        }

        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.IList.Insert"]/*' />
        /// <internalonly/>
        void IList.Insert(int index, object value) {
            data.Insert(index, (CodeNamespaceImport)value);
            SyncKeys();
        }

        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.IList.Remove"]/*' />
        /// <internalonly/>
        void IList.Remove(object value) {
            data.Remove((CodeNamespaceImport)value);
            SyncKeys();
        }

        /// <include file='doc\CodeNamespaceImportCollection.uex' path='docs/doc[@for="CodeNamespaceImportCollection.IList.RemoveAt"]/*' />
        /// <internalonly/>
        void IList.RemoveAt(int index) {
            data.RemoveAt(index);
            SyncKeys();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeobjectcreateexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeObjectCreateExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeObjectCreateExpression.uex' path='docs/doc[@for="CodeObjectCreateExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents an object create expression.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeObjectCreateExpression : CodeExpression {
        private CodeTypeReference createType;
        private CodeExpressionCollection parameters = new CodeExpressionCollection();

        /// <include file='doc\CodeObjectCreateExpression.uex' path='docs/doc[@for="CodeObjectCreateExpression.CodeObjectCreateExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new <see cref='System.CodeDom.CodeObjectCreateExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeObjectCreateExpression() {
        }

        /// <include file='doc\CodeObjectCreateExpression.uex' path='docs/doc[@for="CodeObjectCreateExpression.CodeObjectCreateExpression1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new <see cref='System.CodeDom.CodeObjectCreateExpression'/> using the specified type and
        ///       parameters.
        ///    </para>
        /// </devdoc>
        public CodeObjectCreateExpression(CodeTypeReference createType, params CodeExpression[] parameters) {
            CreateType = createType;
            Parameters.AddRange(parameters);
        }

        /// <include file='doc\CodeObjectCreateExpression.uex' path='docs/doc[@for="CodeObjectCreateExpression.CodeObjectCreateExpression2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeObjectCreateExpression(string createType, params CodeExpression[] parameters) {
            CreateType = new CodeTypeReference(createType);
            Parameters.AddRange(parameters);
        }

        /// <include file='doc\CodeObjectCreateExpression.uex' path='docs/doc[@for="CodeObjectCreateExpression.CodeObjectCreateExpression3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeObjectCreateExpression(Type createType, params CodeExpression[] parameters) {
            CreateType = new CodeTypeReference(createType);
            Parameters.AddRange(parameters);
        }

        /// <include file='doc\CodeObjectCreateExpression.uex' path='docs/doc[@for="CodeObjectCreateExpression.CreateType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The type of the object to create.
        ///    </para>
        /// </devdoc>
        public CodeTypeReference CreateType {
            get {
                if (createType == null) {
                    createType = new CodeTypeReference("");
                }
                return createType;
            }
            set {
                createType = value;
            }
        }

        /// <include file='doc\CodeObjectCreateExpression.uex' path='docs/doc[@for="CodeObjectCreateExpression.Parameters"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the parameters to use in creating the
        ///       object.
        ///    </para>
        /// </devdoc>
        public CodeExpressionCollection Parameters {
            get {
                return parameters;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeparameterdeclarationexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeParameterDeclarationExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeParameterDeclarationExpression.uex' path='docs/doc[@for="CodeParameterDeclarationExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a parameter declaration for method, constructor, or property arguments.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeParameterDeclarationExpression : CodeExpression {
        private CodeTypeReference type;
        private string name;
        private CodeAttributeDeclarationCollection customAttributes = null;
        private FieldDirection dir = FieldDirection.In;


        /// <include file='doc\CodeParameterDeclarationExpression.uex' path='docs/doc[@for="CodeParameterDeclarationExpression.CodeParameterDeclarationExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeParameterDeclarationExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeParameterDeclarationExpression() {
        }

        /// <include file='doc\CodeParameterDeclarationExpression.uex' path='docs/doc[@for="CodeParameterDeclarationExpression.CodeParameterDeclarationExpression1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeParameterDeclarationExpression'/> using the specified type and name.
        ///    </para>
        /// </devdoc>
        public CodeParameterDeclarationExpression(CodeTypeReference type, string name) {
            Type = type;
            Name = name;
        }

        /// <include file='doc\CodeParameterDeclarationExpression.uex' path='docs/doc[@for="CodeParameterDeclarationExpression.CodeParameterDeclarationExpression2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeParameterDeclarationExpression(string type, string name) {
            Type = new CodeTypeReference(type);
            Name = name;
        }

        /// <include file='doc\CodeParameterDeclarationExpression.uex' path='docs/doc[@for="CodeParameterDeclarationExpression.CodeParameterDeclarationExpression3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeParameterDeclarationExpression(Type type, string name) {
            Type = new CodeTypeReference(type);
            Name = name;
        }

        /// <include file='doc\CodeParameterDeclarationExpression.uex' path='docs/doc[@for="CodeParameterDeclarationExpression.CustomAttributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the custom attributes for the parameter declaration.
        ///    </para>
        /// </devdoc>
        public CodeAttributeDeclarationCollection CustomAttributes {
            get {
                if (customAttributes == null) {
                    customAttributes = new CodeAttributeDeclarationCollection();
                }
                return customAttributes;
            }
            set {
                customAttributes = value;
            }
        }

        /// <include file='doc\CodeParameterDeclarationExpression.uex' path='docs/doc[@for="CodeParameterDeclarationExpression.Direction"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the direction of the field.
        ///    </para>
        /// </devdoc>
        public FieldDirection Direction {
            get {
                return dir;
            }
            set {
                dir = value;
            }
        }

        /// <include file='doc\CodeParameterDeclarationExpression.uex' path='docs/doc[@for="CodeParameterDeclarationExpression.Type"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the type of the parameter.
        ///    </para>
        /// </devdoc>
        public CodeTypeReference Type {
            get {
                if (type == null) {
                    type = new CodeTypeReference("");
                }
                return type;
            }
            set {
                type = value;
            }
        }

        /// <include file='doc\CodeParameterDeclarationExpression.uex' path='docs/doc[@for="CodeParameterDeclarationExpression.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the name of the parameter.
        ///    </para>
        /// </devdoc>
        public string Name {
            get {
                return (name == null) ? string.Empty : name;
            }
            set {
                name = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeparameterdeclarationexpressioncollection.cs ===
// ------------------------------------------------------------------------------
// <copyright file="CodeParameterDeclarationExpressionCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright> 
// ------------------------------------------------------------------------------
// 
namespace System.CodeDom {
    using System;
    using System.Collections;
    using System.Runtime.InteropServices;
    
    
    /// <include file='doc\CodeParameterDeclarationExpressionCollection.uex' path='docs/doc[@for="CodeParameterDeclarationExpressionCollection"]/*' />
    /// <devdoc>
    ///     <para>
    ///       A collection that stores <see cref='System.CodeDom.CodeParameterDeclarationExpression'/> objects.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeParameterDeclarationExpressionCollection : CollectionBase {
        
        /// <include file='doc\CodeParameterDeclarationExpressionCollection.uex' path='docs/doc[@for="CodeParameterDeclarationExpressionCollection.CodeParameterDeclarationExpressionCollection"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeParameterDeclarationExpressionCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeParameterDeclarationExpressionCollection() {
        }
        
        /// <include file='doc\CodeParameterDeclarationExpressionCollection.uex' path='docs/doc[@for="CodeParameterDeclarationExpressionCollection.CodeParameterDeclarationExpressionCollection1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeParameterDeclarationExpressionCollection'/> based on another <see cref='System.CodeDom.CodeParameterDeclarationExpressionCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeParameterDeclarationExpressionCollection(CodeParameterDeclarationExpressionCollection value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeParameterDeclarationExpressionCollection.uex' path='docs/doc[@for="CodeParameterDeclarationExpressionCollection.CodeParameterDeclarationExpressionCollection2"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeParameterDeclarationExpressionCollection'/> containing any array of <see cref='System.CodeDom.CodeParameterDeclarationExpression'/> objects.
        ///    </para>
        /// </devdoc>
        public CodeParameterDeclarationExpressionCollection(CodeParameterDeclarationExpression[] value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeParameterDeclarationExpressionCollection.uex' path='docs/doc[@for="CodeParameterDeclarationExpressionCollection.this"]/*' />
        /// <devdoc>
        /// <para>Represents the entry at the specified index of the <see cref='System.CodeDom.CodeParameterDeclarationExpression'/>.</para>
        /// </devdoc>
        public CodeParameterDeclarationExpression this[int index] {
            get {
                return ((CodeParameterDeclarationExpression)(List[index]));
            }
            set {
                List[index] = value;
            }
        }
        
        /// <include file='doc\CodeParameterDeclarationExpressionCollection.uex' path='docs/doc[@for="CodeParameterDeclarationExpressionCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>Adds a <see cref='System.CodeDom.CodeParameterDeclarationExpression'/> with the specified value to the 
        ///    <see cref='System.CodeDom.CodeParameterDeclarationExpressionCollection'/> .</para>
        /// </devdoc>
        public int Add(CodeParameterDeclarationExpression value) {
            return List.Add(value);
        }
        
        /// <include file='doc\CodeParameterDeclarationExpressionCollection.uex' path='docs/doc[@for="CodeParameterDeclarationExpressionCollection.AddRange"]/*' />
        /// <devdoc>
        /// <para>Copies the elements of an array to the end of the <see cref='System.CodeDom.CodeParameterDeclarationExpressionCollection'/>.</para>
        /// </devdoc>
        public void AddRange(CodeParameterDeclarationExpression[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeParameterDeclarationExpressionCollection.uex' path='docs/doc[@for="CodeParameterDeclarationExpressionCollection.AddRange1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Adds the contents of another <see cref='System.CodeDom.CodeParameterDeclarationExpressionCollection'/> to the end of the collection.
        ///    </para>
        /// </devdoc>
        public void AddRange(CodeParameterDeclarationExpressionCollection value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeParameterDeclarationExpressionCollection.uex' path='docs/doc[@for="CodeParameterDeclarationExpressionCollection.Contains"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the 
        ///    <see cref='System.CodeDom.CodeParameterDeclarationExpressionCollection'/> contains the specified <see cref='System.CodeDom.CodeParameterDeclarationExpression'/>.</para>
        /// </devdoc>
        public bool Contains(CodeParameterDeclarationExpression value) {
            return List.Contains(value);
        }
        
        /// <include file='doc\CodeParameterDeclarationExpressionCollection.uex' path='docs/doc[@for="CodeParameterDeclarationExpressionCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the <see cref='System.CodeDom.CodeParameterDeclarationExpressionCollection'/> values to a one-dimensional <see cref='System.Array'/> instance at the 
        ///    specified index.</para>
        /// </devdoc>
        public void CopyTo(CodeParameterDeclarationExpression[] array, int index) {
            List.CopyTo(array, index);
        }
        
        /// <include file='doc\CodeParameterDeclarationExpressionCollection.uex' path='docs/doc[@for="CodeParameterDeclarationExpressionCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>Returns the index of a <see cref='System.CodeDom.CodeParameterDeclarationExpression'/> in 
        ///       the <see cref='System.CodeDom.CodeParameterDeclarationExpressionCollection'/> .</para>
        /// </devdoc>
        public int IndexOf(CodeParameterDeclarationExpression value) {
            return List.IndexOf(value);
        }
        
        /// <include file='doc\CodeParameterDeclarationExpressionCollection.uex' path='docs/doc[@for="CodeParameterDeclarationExpressionCollection.Insert"]/*' />
        /// <devdoc>
        /// <para>Inserts a <see cref='System.CodeDom.CodeParameterDeclarationExpression'/> into the <see cref='System.CodeDom.CodeParameterDeclarationExpressionCollection'/> at the specified index.</para>
        /// </devdoc>
        public void Insert(int index, CodeParameterDeclarationExpression value) {
            List.Insert(index, value);
        }
        
        /// <include file='doc\CodeParameterDeclarationExpressionCollection.uex' path='docs/doc[@for="CodeParameterDeclarationExpressionCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para> Removes a specific <see cref='System.CodeDom.CodeParameterDeclarationExpression'/> from the 
        ///    <see cref='System.CodeDom.CodeParameterDeclarationExpressionCollection'/> .</para>
        /// </devdoc>
        public void Remove(CodeParameterDeclarationExpression value) {
            List.Remove(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codepropertyreferenceexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodePropertyReferenceExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodePropertyReferenceExpression.uex' path='docs/doc[@for="CodePropertyReferenceExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a reference to a property.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodePropertyReferenceExpression : CodeExpression {
        private CodeExpression targetObject;
        private string propertyName;
        private CodeExpressionCollection parameters = new CodeExpressionCollection();

        /// <include file='doc\CodePropertyReferenceExpression.uex' path='docs/doc[@for="CodePropertyReferenceExpression.CodePropertyReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodePropertyReferenceExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodePropertyReferenceExpression() {
        }

        /// <include file='doc\CodePropertyReferenceExpression.uex' path='docs/doc[@for="CodePropertyReferenceExpression.CodePropertyReferenceExpression1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodePropertyReferenceExpression'/> using the specified target object and property
        ///       name.
        ///    </para>
        /// </devdoc>
        public CodePropertyReferenceExpression(CodeExpression targetObject, string propertyName) {
            TargetObject = targetObject;
            PropertyName = propertyName;
        }

        /// <include file='doc\CodePropertyReferenceExpression.uex' path='docs/doc[@for="CodePropertyReferenceExpression.TargetObject"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The target object containing the property this <see cref='System.CodeDom.CodePropertyReferenceExpression'/> references.
        ///    </para>
        /// </devdoc>
        public CodeExpression TargetObject {
            get {
                return targetObject;
            }
            set {
                targetObject = value;
            }
        }

        /// <include file='doc\CodePropertyReferenceExpression.uex' path='docs/doc[@for="CodePropertyReferenceExpression.PropertyName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The name of the property to reference.
        ///    </para>
        /// </devdoc>
        public string PropertyName {
            get {
                return (propertyName == null) ? string.Empty : propertyName;
            }
            set {
                propertyName = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codepropertysetvaluereferenceexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodePropertySetValueReferenceExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodePropertySetValueReferenceExpression.uex' path='docs/doc[@for="CodePropertySetValueReferenceExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the value paramter of a property set
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodePropertySetValueReferenceExpression : CodeExpression {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\coderemoveeventstatement.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeRemoveEventStatement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeRemoveEventStatement.uex' path='docs/doc[@for="CodeRemoveEventStatement"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a event detach statement.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeRemoveEventStatement : CodeStatement {
        private CodeEventReferenceExpression eventRef;
        private CodeExpression listener;

        /// <include file='doc\CodeRemoveEventStatement.uex' path='docs/doc[@for="CodeRemoveEventStatement.CodeRemoveEventStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeRemoveEventStatement'/>.
        ///    </para>
        /// </devdoc>
        public CodeRemoveEventStatement() {
        }

        /// <include file='doc\CodeRemoveEventStatement.uex' path='docs/doc[@for="CodeRemoveEventStatement.CodeRemoveEventStatement1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.CodeDom.CodeRemoveEventStatement'/> class using the specified arguments.
        ///    </para>
        /// </devdoc>
        public CodeRemoveEventStatement(CodeEventReferenceExpression eventRef, CodeExpression listener) {
            this.eventRef = eventRef;
            this.listener = listener;
        }

        /// <include file='doc\CodeRemoveEventStatement.uex' path='docs/doc[@for="CodeRemoveEventStatement.CodeRemoveEventStatement2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeRemoveEventStatement(CodeExpression targetObject, string eventName, CodeExpression listener) {
            this.eventRef = new CodeEventReferenceExpression(targetObject, eventName);
            this.listener = listener;
        }

        /// <include file='doc\CodeRemoveEventStatement.uex' path='docs/doc[@for="CodeRemoveEventStatement.Event"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeEventReferenceExpression Event{
            get {
                if (eventRef == null) {
                    eventRef = new CodeEventReferenceExpression();
                }
                return eventRef;
            }
            set {
                eventRef = value;
            }
        }

       /// <include file='doc\CodeRemoveEventStatement.uex' path='docs/doc[@for="CodeRemoveEventStatement.Listener"]/*' />
       /// <devdoc>
        ///    <para>
        ///       The listener.
        ///    </para>
        /// </devdoc>
        public CodeExpression Listener {
            get {
                return listener;
            }
            set {
                listener = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codesnippetcompileunit.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeSnippetCompileUnit.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeSnippetCompileUnit.uex' path='docs/doc[@for="CodeSnippetCompileUnit"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a snippet block of code.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeSnippetCompileUnit : CodeCompileUnit {
        private string value;
        private CodeLinePragma linePragma;

        /// <include file='doc\CodeSnippetCompileUnit.uex' path='docs/doc[@for="CodeSnippetCompileUnit.CodeSnippetCompileUnit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeSnippetCompileUnit'/>.
        ///    </para>
        /// </devdoc>
        public CodeSnippetCompileUnit(string value) {
            Value = value;
        }

        /// <include file='doc\CodeSnippetCompileUnit.uex' path='docs/doc[@for="CodeSnippetCompileUnit.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the snippet
        ///       text of the code block to represent.
        ///    </para>
        /// </devdoc>
        public string Value {
            get {
                return (value == null) ? string.Empty : value;
            }
            set {
                this.value = value;
            }
        }

        /// <include file='doc\CodeSnippetCompileUnit.uex' path='docs/doc[@for="CodeSnippetCompileUnit.LinePragma"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The line the code block starts on.
        ///    </para>
        /// </devdoc>
        public CodeLinePragma LinePragma {
            get {
                return linePragma;
            }
            set {
                linePragma = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codesnippetexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeSnippetExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeSnippetExpression.uex' path='docs/doc[@for="CodeSnippetExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a snippet expression.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeSnippetExpression : CodeExpression {
        private string value;

        /// <include file='doc\CodeSnippetExpression.uex' path='docs/doc[@for="CodeSnippetExpression.CodeSnippetExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeSnippetExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeSnippetExpression() {
        }
        
        /// <include file='doc\CodeSnippetExpression.uex' path='docs/doc[@for="CodeSnippetExpression.CodeSnippetExpression1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeSnippetExpression'/> using the specified snippet
        ///       expression.
        ///    </para>
        /// </devdoc>
        public CodeSnippetExpression(string value) {
            Value = value;
        }

        /// <include file='doc\CodeSnippetExpression.uex' path='docs/doc[@for="CodeSnippetExpression.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the snippet expression.
        ///    </para>
        /// </devdoc>
        public string Value {
            get {
                return (value == null) ? string.Empty : value;
            }
            set {
                this.value = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codeprimitiveexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodePrimitiveExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodePrimitiveExpression.uex' path='docs/doc[@for="CodePrimitiveExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a primitive value.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodePrimitiveExpression : CodeExpression {
        private object value;

        /// <include file='doc\CodePrimitiveExpression.uex' path='docs/doc[@for="CodePrimitiveExpression.CodePrimitiveExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodePrimitiveExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodePrimitiveExpression() {
        }

        /// <include file='doc\CodePrimitiveExpression.uex' path='docs/doc[@for="CodePrimitiveExpression.CodePrimitiveExpression1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodePrimitiveExpression'/> using the specified
        ///       object.
        ///    </para>
        /// </devdoc>
        public CodePrimitiveExpression(object value) {
            Value = value;
        }

        /// <include file='doc\CodePrimitiveExpression.uex' path='docs/doc[@for="CodePrimitiveExpression.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the object to represent.
        ///    </para>
        /// </devdoc>
        public object Value {
            get {
                return value;
            }
            set {
                this.value = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codesnippetstatement.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeSnippetStatement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeSnippetStatement.uex' path='docs/doc[@for="CodeSnippetStatement"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a snippet statement.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeSnippetStatement : CodeStatement {
        private string value;

        /// <include file='doc\CodeSnippetStatement.uex' path='docs/doc[@for="CodeSnippetStatement.CodeSnippetStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeSnippetStatement'/>.
        ///    </para>
        /// </devdoc>
        public CodeSnippetStatement() {
        }
        
        /// <include file='doc\CodeSnippetStatement.uex' path='docs/doc[@for="CodeSnippetStatement.CodeSnippetStatement1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeSnippetStatement'/> using the specified snippet
        ///       of code.
        ///    </para>
        /// </devdoc>
        public CodeSnippetStatement(string value) {
            Value = value;
        }

        /// <include file='doc\CodeSnippetStatement.uex' path='docs/doc[@for="CodeSnippetStatement.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the snippet statement.
        ///    </para>
        /// </devdoc>
        public string Value {
            get {
                return (value == null) ? string.Empty : value;
            }
            set {
                this.value = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codestatementcollection.cs ===
// ------------------------------------------------------------------------------
// <copyright file="CodeStatementCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright> 
// ------------------------------------------------------------------------------
// 
namespace System.CodeDom {
    using System;
    using System.Collections;
    using System.Runtime.InteropServices;
    
    
    /// <include file='doc\CodeStatementCollection.uex' path='docs/doc[@for="CodeStatementCollection"]/*' />
    /// <devdoc>
    ///     <para>
    ///       A collection that stores <see cref='System.CodeDom.CodeStatement'/> objects.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeStatementCollection : CollectionBase {
        
        /// <include file='doc\CodeStatementCollection.uex' path='docs/doc[@for="CodeStatementCollection.CodeStatementCollection"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeStatementCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeStatementCollection() {
        }
        
        /// <include file='doc\CodeStatementCollection.uex' path='docs/doc[@for="CodeStatementCollection.CodeStatementCollection1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeStatementCollection'/> based on another <see cref='System.CodeDom.CodeStatementCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeStatementCollection(CodeStatementCollection value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeStatementCollection.uex' path='docs/doc[@for="CodeStatementCollection.CodeStatementCollection2"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeStatementCollection'/> containing any array of <see cref='System.CodeDom.CodeStatement'/> objects.
        ///    </para>
        /// </devdoc>
        public CodeStatementCollection(CodeStatement[] value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeStatementCollection.uex' path='docs/doc[@for="CodeStatementCollection.this"]/*' />
        /// <devdoc>
        /// <para>Represents the entry at the specified index of the <see cref='System.CodeDom.CodeStatement'/>.</para>
        /// </devdoc>
        public CodeStatement this[int index] {
            get {
                return ((CodeStatement)(List[index]));
            }
            set {
                List[index] = value;
            }
        }
        
        /// <include file='doc\CodeStatementCollection.uex' path='docs/doc[@for="CodeStatementCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>Adds a <see cref='System.CodeDom.CodeStatement'/> with the specified value to the 
        ///    <see cref='System.CodeDom.CodeStatementCollection'/> .</para>
        /// </devdoc>
        public int Add(CodeStatement value) {
            return List.Add(value);
        }

        /// <include file='doc\CodeStatementCollection.uex' path='docs/doc[@for="CodeStatementCollection.Add1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(CodeExpression value) {
            return Add(new CodeExpressionStatement(value));
        }

        
        /// <include file='doc\CodeStatementCollection.uex' path='docs/doc[@for="CodeStatementCollection.AddRange"]/*' />
        /// <devdoc>
        /// <para>Copies the elements of an array to the end of the <see cref='System.CodeDom.CodeStatementCollection'/>.</para>
        /// </devdoc>
        public void AddRange(CodeStatement[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeStatementCollection.uex' path='docs/doc[@for="CodeStatementCollection.AddRange1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Adds the contents of another <see cref='System.CodeDom.CodeStatementCollection'/> to the end of the collection.
        ///    </para>
        /// </devdoc>
        public void AddRange(CodeStatementCollection value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeStatementCollection.uex' path='docs/doc[@for="CodeStatementCollection.Contains"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the 
        ///    <see cref='System.CodeDom.CodeStatementCollection'/> contains the specified <see cref='System.CodeDom.CodeStatement'/>.</para>
        /// </devdoc>
        public bool Contains(CodeStatement value) {
            return List.Contains(value);
        }
        
        /// <include file='doc\CodeStatementCollection.uex' path='docs/doc[@for="CodeStatementCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the <see cref='System.CodeDom.CodeStatementCollection'/> values to a one-dimensional <see cref='System.Array'/> instance at the 
        ///    specified index.</para>
        /// </devdoc>
        public void CopyTo(CodeStatement[] array, int index) {
            List.CopyTo(array, index);
        }
        
        /// <include file='doc\CodeStatementCollection.uex' path='docs/doc[@for="CodeStatementCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>Returns the index of a <see cref='System.CodeDom.CodeStatement'/> in 
        ///       the <see cref='System.CodeDom.CodeStatementCollection'/> .</para>
        /// </devdoc>
        public int IndexOf(CodeStatement value) {
            return List.IndexOf(value);
        }
        
        /// <include file='doc\CodeStatementCollection.uex' path='docs/doc[@for="CodeStatementCollection.Insert"]/*' />
        /// <devdoc>
        /// <para>Inserts a <see cref='System.CodeDom.CodeStatement'/> into the <see cref='System.CodeDom.CodeStatementCollection'/> at the specified index.</para>
        /// </devdoc>
        public void Insert(int index, CodeStatement value) {
            List.Insert(index, value);
        }
        
        /// <include file='doc\CodeStatementCollection.uex' path='docs/doc[@for="CodeStatementCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para> Removes a specific <see cref='System.CodeDom.CodeStatement'/> from the 
        ///    <see cref='System.CodeDom.CodeStatementCollection'/> .</para>
        /// </devdoc>
        public void Remove(CodeStatement value) {
            List.Remove(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codethisreferenceexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeThisReferenceExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeThisReferenceExpression.uex' path='docs/doc[@for="CodeThisReferenceExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a current instance reference.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeThisReferenceExpression : CodeExpression {
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codethrowexceptionstatement.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeThrowExceptionStatement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeThrowExceptionStatement.uex' path='docs/doc[@for="CodeThrowExceptionStatement"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents
    ///       a statement that throws an exception.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeThrowExceptionStatement : CodeStatement {
        private CodeExpression toThrow;

        /// <include file='doc\CodeThrowExceptionStatement.uex' path='docs/doc[@for="CodeThrowExceptionStatement.CodeThrowExceptionStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeThrowExceptionStatement'/>.
        ///    </para>
        /// </devdoc>
        public CodeThrowExceptionStatement() {
        }
        
        /// <include file='doc\CodeThrowExceptionStatement.uex' path='docs/doc[@for="CodeThrowExceptionStatement.CodeThrowExceptionStatement1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeThrowExceptionStatement'/> using the specified statement.
        ///    </para>
        /// </devdoc>
        public CodeThrowExceptionStatement(CodeExpression toThrow) {
            ToThrow = toThrow;
        }

        /// <include file='doc\CodeThrowExceptionStatement.uex' path='docs/doc[@for="CodeThrowExceptionStatement.ToThrow"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the expression to throw.
        ///    </para>
        /// </devdoc>
        public CodeExpression ToThrow {
            get {
                return toThrow;
            }
            set {
                toThrow = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codesnippettypemember.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeSnippetTypeMember.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Reflection;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeSnippetTypeMember.uex' path='docs/doc[@for="CodeSnippetTypeMember"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a
    ///       snippet member of a class.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeSnippetTypeMember : CodeTypeMember {
        private string text;

        /// <include file='doc\CodeSnippetTypeMember.uex' path='docs/doc[@for="CodeSnippetTypeMember.CodeSnippetTypeMember"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeSnippetTypeMember'/>.
        ///    </para>
        /// </devdoc>
        public CodeSnippetTypeMember() {
        }

        /// <include file='doc\CodeSnippetTypeMember.uex' path='docs/doc[@for="CodeSnippetTypeMember.CodeSnippetTypeMember1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeSnippetTypeMember'/>.
        ///    </para>
        /// </devdoc>
        public CodeSnippetTypeMember(string text) {
            Text = text;
        }

        /// <include file='doc\CodeSnippetTypeMember.uex' path='docs/doc[@for="CodeSnippetTypeMember.Text"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the code for the class member.
        ///    </para>
        /// </devdoc>
        public string Text {
            get {
                return (text == null) ? string.Empty : text;
            }
            set {
                text = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codetypeconstructor.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeTypeConstructor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeTypeConstructor.uex' path='docs/doc[@for="CodeTypeConstructor"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a static constructor for a class.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeTypeConstructor : CodeMemberMethod {
        /// <include file='doc\CodeTypeConstructor.uex' path='docs/doc[@for="CodeTypeConstructor.CodeTypeConstructor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTypeConstructor'/>.
        ///    </para>
        /// </devdoc>
        public CodeTypeConstructor() {
            Name = ".cctor";
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codestatement.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeStatement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeStatement.uex' path='docs/doc[@for="CodeStatement"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a statement.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeStatement : CodeObject {
        private CodeLinePragma linePragma;

        /// <include file='doc\CodeStatement.uex' path='docs/doc[@for="CodeStatement.LinePragma"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The line the statement occurs on.
        ///    </para>
        /// </devdoc>
        public CodeLinePragma LinePragma {
            get {
                return linePragma;
            }
            set {
                linePragma = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codetypedeclaration.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeTypeDeclaration.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Reflection;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeTypeDeclaration.uex' path='docs/doc[@for="CodeTypeDeclaration"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a
    ///       class or nested class.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeTypeDeclaration : CodeTypeMember {
        private TypeAttributes attributes = Reflection.TypeAttributes.Public | Reflection.TypeAttributes.Class;
        private CodeTypeReferenceCollection baseTypes = new CodeTypeReferenceCollection();
        private CodeTypeMemberCollection members = new CodeTypeMemberCollection();
                
        private bool isEnum;    
        private bool isStruct;
        private int  populated = 0x0;
        private const int BaseTypesCollection = 0x1;
        private const int MembersCollection = 0x2;
        
        /// <include file='doc\CodeTypeDeclaration.uex' path='docs/doc[@for="CodeTypeDeclaration.PopulateBaseTypes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An event that will be fired the first time the BaseTypes Collection is accessed.  
        ///    </para>
        /// </devdoc>
        public event EventHandler PopulateBaseTypes;
        
        /// <include file='doc\CodeTypeDeclaration.uex' path='docs/doc[@for="CodeTypeDeclaration.PopulateMembers"]/*' />
        /// <devdoc>
        ///    <para>
        ///       An event that will be fired the first time the Members Collection is accessed.  
        ///    </para>
        /// </devdoc>
        public event EventHandler PopulateMembers;


        /// <include file='doc\CodeTypeDeclaration.uex' path='docs/doc[@for="CodeTypeDeclaration.CodeTypeDeclaration"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTypeDeclaration'/>.
        ///    </para>
        /// </devdoc>
        public CodeTypeDeclaration() {
        }

        /// <include file='doc\CodeTypeDeclaration.uex' path='docs/doc[@for="CodeTypeDeclaration.CodeTypeDeclaration1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTypeDeclaration'/> with the specified name.
        ///    </para>
        /// </devdoc>
        public CodeTypeDeclaration(string name) {
            Name = name;
        }


        /// <include file='doc\CodeTypeDeclaration.uex' path='docs/doc[@for="CodeTypeDeclaration.TypeAttributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the attributes of the class.
        ///    </para>
        /// </devdoc>
        public TypeAttributes TypeAttributes {
            get {
                return attributes;
            }
            set {
                attributes = value;
            }
        }

        /// <include file='doc\CodeTypeDeclaration.uex' path='docs/doc[@for="CodeTypeDeclaration.BaseTypes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the base types of the class.
        ///    </para>
        /// </devdoc>
        public CodeTypeReferenceCollection BaseTypes {
            get {
                if (0 == (populated & BaseTypesCollection)) {
                    populated |= BaseTypesCollection;
                    if (PopulateBaseTypes != null) PopulateBaseTypes(this, EventArgs.Empty);
                }
                return baseTypes;
            }
        }

        /// <include file='doc\CodeTypeDeclaration.uex' path='docs/doc[@for="CodeTypeDeclaration.IsClass"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value
        ///       indicating whether the class is a class.
        ///    </para>
        /// </devdoc>
        public bool IsClass {
            get {
                return(attributes & TypeAttributes.ClassSemanticsMask) == TypeAttributes.Class && !isEnum && !isStruct;
            }
            set {                  
                if (value) {
                    attributes &= ~TypeAttributes.ClassSemanticsMask;
                    attributes |= TypeAttributes.Class;
                    isStruct = false;
                    isEnum = false;                       
                }
            }
        }

        /// <include file='doc\CodeTypeDeclaration.uex' path='docs/doc[@for="CodeTypeDeclaration.IsStruct"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value
        ///       indicating whether the class is a struct.
        ///    </para>
        /// </devdoc>
        public bool IsStruct {
            get {
                return isStruct;
            }
            set {        
		if (value) {
                    attributes &= ~TypeAttributes.ClassSemanticsMask;
                    isStruct = true;
                    isEnum = false;                       
		}												                          
            }
        }

        /// <include file='doc\CodeTypeDeclaration.uex' path='docs/doc[@for="CodeTypeDeclaration.IsEnum"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value
        ///       indicating whether the class is an enumeration.
        ///    </para>
        /// </devdoc>
        public bool IsEnum {
            get {
                return isEnum;
            }
            set {
		if (value) {
                    attributes &= ~TypeAttributes.ClassSemanticsMask;
                    isStruct = false;
                    isEnum = true;                       
		}                
            }
        }

        /// <include file='doc\CodeTypeDeclaration.uex' path='docs/doc[@for="CodeTypeDeclaration.IsInterface"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value
        ///       indicating whether the class is an interface.
        ///    </para>
        /// </devdoc>
        public bool IsInterface {
            get {
                return(attributes & TypeAttributes.ClassSemanticsMask) == TypeAttributes.Interface;
            }
            set {
                if (value) {
                    attributes &= ~TypeAttributes.ClassSemanticsMask;
                    attributes |= TypeAttributes.Interface;
                    isStruct = false;
                    isEnum = false;                       
                }
            }
        }


        /// <include file='doc\CodeTypeDeclaration.uex' path='docs/doc[@for="CodeTypeDeclaration.Members"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the class member collection members.
        ///    </para>
        /// </devdoc>
        public CodeTypeMemberCollection Members {
            get {
                if (0 == (populated & MembersCollection)) {
                    populated |= MembersCollection;
                    if (PopulateMembers != null) PopulateMembers(this, EventArgs.Empty);
                }
                return members;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codetrycatchfinallystatement.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeTryCatchFinallyStatement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeTryCatchFinallyStatement.uex' path='docs/doc[@for="CodeTryCatchFinallyStatement"]/*' />
    /// <devdoc>
    ///     Represents a try block, with any number of catch clauses and an
    ///     optionally finally block.
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeTryCatchFinallyStatement : CodeStatement {
        private CodeStatementCollection tryStatments = new CodeStatementCollection();
        private CodeStatementCollection finallyStatments = new CodeStatementCollection();
        private CodeCatchClauseCollection catchClauses = new CodeCatchClauseCollection();

        /// <include file='doc\CodeTryCatchFinallyStatement.uex' path='docs/doc[@for="CodeTryCatchFinallyStatement.CodeTryCatchFinallyStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTryCatchFinallyStatement'/>.
        ///    </para>
        /// </devdoc>
        public CodeTryCatchFinallyStatement() {
        }

        /// <include file='doc\CodeTryCatchFinallyStatement.uex' path='docs/doc[@for="CodeTryCatchFinallyStatement.CodeTryCatchFinallyStatement1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTryCatchFinallyStatement'/> using the specified statements to try and catch
        ///       clauses.
        ///    </para>
        /// </devdoc>
        public CodeTryCatchFinallyStatement(CodeStatement[] tryStatements, CodeCatchClause[] catchClauses) {
            TryStatements.AddRange(tryStatements);
            CatchClauses.AddRange(catchClauses);
        }

        /// <include file='doc\CodeTryCatchFinallyStatement.uex' path='docs/doc[@for="CodeTryCatchFinallyStatement.CodeTryCatchFinallyStatement2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTryCatchFinallyStatement'/> using the specified statements to
        ///       try, catch clauses, and finally statements.
        ///    </para>
        /// </devdoc>
        public CodeTryCatchFinallyStatement(CodeStatement[] tryStatements, CodeCatchClause[] catchClauses, CodeStatement[] finallyStatements) {
            TryStatements.AddRange(tryStatements);
            CatchClauses.AddRange(catchClauses);
            FinallyStatements.AddRange(finallyStatements);
        }

        /// <include file='doc\CodeTryCatchFinallyStatement.uex' path='docs/doc[@for="CodeTryCatchFinallyStatement.TryStatements"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the try statements to try.
        ///    </para>
        /// </devdoc>
        public CodeStatementCollection TryStatements {
            get {
                return tryStatments;
            }
        }

        /// <include file='doc\CodeTryCatchFinallyStatement.uex' path='docs/doc[@for="CodeTryCatchFinallyStatement.CatchClauses"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the catch clauses to use.
        ///    </para>
        /// </devdoc>
        public CodeCatchClauseCollection CatchClauses {
            get {
                return catchClauses;
            }
        }

        /// <include file='doc\CodeTryCatchFinallyStatement.uex' path='docs/doc[@for="CodeTryCatchFinallyStatement.FinallyStatements"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the finally statements to use.
        ///    </para>
        /// </devdoc>
        public CodeStatementCollection FinallyStatements {
            get {
                return finallyStatments;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codetypedeclarationcollection.cs ===
// ------------------------------------------------------------------------------
// <copyright file="CodeTypeDeclarationCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright> 
// ------------------------------------------------------------------------------
// 
namespace System.CodeDom {
    using System;
    using System.Collections;
    using System.Runtime.InteropServices;
    
    
    /// <include file='doc\CodeTypeDeclarationCollection.uex' path='docs/doc[@for="CodeTypeDeclarationCollection"]/*' />
    /// <devdoc>
    ///     <para>
    ///       A collection that stores <see cref='System.CodeDom.CodeTypeDeclaration'/> objects.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeTypeDeclarationCollection : CollectionBase {
        
        /// <include file='doc\CodeTypeDeclarationCollection.uex' path='docs/doc[@for="CodeTypeDeclarationCollection.CodeTypeDeclarationCollection"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTypeDeclarationCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeTypeDeclarationCollection() {
        }
        
        /// <include file='doc\CodeTypeDeclarationCollection.uex' path='docs/doc[@for="CodeTypeDeclarationCollection.CodeTypeDeclarationCollection1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTypeDeclarationCollection'/> based on another <see cref='System.CodeDom.CodeTypeDeclarationCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeTypeDeclarationCollection(CodeTypeDeclarationCollection value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeTypeDeclarationCollection.uex' path='docs/doc[@for="CodeTypeDeclarationCollection.CodeTypeDeclarationCollection2"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTypeDeclarationCollection'/> containing any array of <see cref='System.CodeDom.CodeTypeDeclaration'/> objects.
        ///    </para>
        /// </devdoc>
        public CodeTypeDeclarationCollection(CodeTypeDeclaration[] value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeTypeDeclarationCollection.uex' path='docs/doc[@for="CodeTypeDeclarationCollection.this"]/*' />
        /// <devdoc>
        /// <para>Represents the entry at the specified index of the <see cref='System.CodeDom.CodeTypeDeclaration'/>.</para>
        /// </devdoc>
        public CodeTypeDeclaration this[int index] {
            get {
                return ((CodeTypeDeclaration)(List[index]));
            }
            set {
                List[index] = value;
            }
        }
        
        /// <include file='doc\CodeTypeDeclarationCollection.uex' path='docs/doc[@for="CodeTypeDeclarationCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>Adds a <see cref='System.CodeDom.CodeTypeDeclaration'/> with the specified value to the 
        ///    <see cref='System.CodeDom.CodeTypeDeclarationCollection'/> .</para>
        /// </devdoc>
        public int Add(CodeTypeDeclaration value) {
            return List.Add(value);
        }
        
        /// <include file='doc\CodeTypeDeclarationCollection.uex' path='docs/doc[@for="CodeTypeDeclarationCollection.AddRange"]/*' />
        /// <devdoc>
        /// <para>Copies the elements of an array to the end of the <see cref='System.CodeDom.CodeTypeDeclarationCollection'/>.</para>
        /// </devdoc>
        public void AddRange(CodeTypeDeclaration[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeTypeDeclarationCollection.uex' path='docs/doc[@for="CodeTypeDeclarationCollection.AddRange1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Adds the contents of another <see cref='System.CodeDom.CodeTypeDeclarationCollection'/> to the end of the collection.
        ///    </para>
        /// </devdoc>
        public void AddRange(CodeTypeDeclarationCollection value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeTypeDeclarationCollection.uex' path='docs/doc[@for="CodeTypeDeclarationCollection.Contains"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the 
        ///    <see cref='System.CodeDom.CodeTypeDeclarationCollection'/> contains the specified <see cref='System.CodeDom.CodeTypeDeclaration'/>.</para>
        /// </devdoc>
        public bool Contains(CodeTypeDeclaration value) {
            return List.Contains(value);
        }
        
        /// <include file='doc\CodeTypeDeclarationCollection.uex' path='docs/doc[@for="CodeTypeDeclarationCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the <see cref='System.CodeDom.CodeTypeDeclarationCollection'/> values to a one-dimensional <see cref='System.Array'/> instance at the 
        ///    specified index.</para>
        /// </devdoc>
        public void CopyTo(CodeTypeDeclaration[] array, int index) {
            List.CopyTo(array, index);
        }
        
        /// <include file='doc\CodeTypeDeclarationCollection.uex' path='docs/doc[@for="CodeTypeDeclarationCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>Returns the index of a <see cref='System.CodeDom.CodeTypeDeclaration'/> in 
        ///       the <see cref='System.CodeDom.CodeTypeDeclarationCollection'/> .</para>
        /// </devdoc>
        public int IndexOf(CodeTypeDeclaration value) {
            return List.IndexOf(value);
        }
        
        /// <include file='doc\CodeTypeDeclarationCollection.uex' path='docs/doc[@for="CodeTypeDeclarationCollection.Insert"]/*' />
        /// <devdoc>
        /// <para>Inserts a <see cref='System.CodeDom.CodeTypeDeclaration'/> into the <see cref='System.CodeDom.CodeTypeDeclarationCollection'/> at the specified index.</para>
        /// </devdoc>
        public void Insert(int index, CodeTypeDeclaration value) {
            List.Insert(index, value);
        }
        
        /// <include file='doc\CodeTypeDeclarationCollection.uex' path='docs/doc[@for="CodeTypeDeclarationCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para> Removes a specific <see cref='System.CodeDom.CodeTypeDeclaration'/> from the 
        ///    <see cref='System.CodeDom.CodeTypeDeclarationCollection'/> .</para>
        /// </devdoc>
        public void Remove(CodeTypeDeclaration value) {
            List.Remove(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codetypemembercollection.cs ===
// ------------------------------------------------------------------------------
// <copyright file="CodeTypeMemberCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright> 
// ------------------------------------------------------------------------------
// 
namespace System.CodeDom {
    using System;
    using System.Collections;
    using System.Runtime.InteropServices;
    
    
    /// <include file='doc\CodeTypeMemberCollection.uex' path='docs/doc[@for="CodeTypeMemberCollection"]/*' />
    /// <devdoc>
    ///     <para>
    ///       A collection that stores <see cref='System.CodeDom.CodeTypeMember'/> objects.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeTypeMemberCollection : CollectionBase {
        
        /// <include file='doc\CodeTypeMemberCollection.uex' path='docs/doc[@for="CodeTypeMemberCollection.CodeTypeMemberCollection"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTypeMemberCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeTypeMemberCollection() {
        }
        
        /// <include file='doc\CodeTypeMemberCollection.uex' path='docs/doc[@for="CodeTypeMemberCollection.CodeTypeMemberCollection1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTypeMemberCollection'/> based on another <see cref='System.CodeDom.CodeTypeMemberCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeTypeMemberCollection(CodeTypeMemberCollection value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeTypeMemberCollection.uex' path='docs/doc[@for="CodeTypeMemberCollection.CodeTypeMemberCollection2"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTypeMemberCollection'/> containing any array of <see cref='System.CodeDom.CodeTypeMember'/> objects.
        ///    </para>
        /// </devdoc>
        public CodeTypeMemberCollection(CodeTypeMember[] value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeTypeMemberCollection.uex' path='docs/doc[@for="CodeTypeMemberCollection.this"]/*' />
        /// <devdoc>
        /// <para>Represents the entry at the specified index of the <see cref='System.CodeDom.CodeTypeMember'/>.</para>
        /// </devdoc>
        public CodeTypeMember this[int index] {
            get {
                return ((CodeTypeMember)(List[index]));
            }
            set {
                List[index] = value;
            }
        }
        
        /// <include file='doc\CodeTypeMemberCollection.uex' path='docs/doc[@for="CodeTypeMemberCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>Adds a <see cref='System.CodeDom.CodeTypeMember'/> with the specified value to the 
        ///    <see cref='System.CodeDom.CodeTypeMemberCollection'/> .</para>
        /// </devdoc>
        public int Add(CodeTypeMember value) {
            return List.Add(value);
        }
        
        /// <include file='doc\CodeTypeMemberCollection.uex' path='docs/doc[@for="CodeTypeMemberCollection.AddRange"]/*' />
        /// <devdoc>
        /// <para>Copies the elements of an array to the end of the <see cref='System.CodeDom.CodeTypeMemberCollection'/>.</para>
        /// </devdoc>
        public void AddRange(CodeTypeMember[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeTypeMemberCollection.uex' path='docs/doc[@for="CodeTypeMemberCollection.AddRange1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Adds the contents of another <see cref='System.CodeDom.CodeTypeMemberCollection'/> to the end of the collection.
        ///    </para>
        /// </devdoc>
        public void AddRange(CodeTypeMemberCollection value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeTypeMemberCollection.uex' path='docs/doc[@for="CodeTypeMemberCollection.Contains"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the 
        ///    <see cref='System.CodeDom.CodeTypeMemberCollection'/> contains the specified <see cref='System.CodeDom.CodeTypeMember'/>.</para>
        /// </devdoc>
        public bool Contains(CodeTypeMember value) {
            return List.Contains(value);
        }
        
        /// <include file='doc\CodeTypeMemberCollection.uex' path='docs/doc[@for="CodeTypeMemberCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the <see cref='System.CodeDom.CodeTypeMemberCollection'/> values to a one-dimensional <see cref='System.Array'/> instance at the 
        ///    specified index.</para>
        /// </devdoc>
        public void CopyTo(CodeTypeMember[] array, int index) {
            List.CopyTo(array, index);
        }
        
        /// <include file='doc\CodeTypeMemberCollection.uex' path='docs/doc[@for="CodeTypeMemberCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>Returns the index of a <see cref='System.CodeDom.CodeTypeMember'/> in 
        ///       the <see cref='System.CodeDom.CodeTypeMemberCollection'/> .</para>
        /// </devdoc>
        public int IndexOf(CodeTypeMember value) {
            return List.IndexOf(value);
        }
        
        /// <include file='doc\CodeTypeMemberCollection.uex' path='docs/doc[@for="CodeTypeMemberCollection.Insert"]/*' />
        /// <devdoc>
        /// <para>Inserts a <see cref='System.CodeDom.CodeTypeMember'/> into the <see cref='System.CodeDom.CodeTypeMemberCollection'/> at the specified index.</para>
        /// </devdoc>
        public void Insert(int index, CodeTypeMember value) {
            List.Insert(index, value);
        }
        
        /// <include file='doc\CodeTypeMemberCollection.uex' path='docs/doc[@for="CodeTypeMemberCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para> Removes a specific <see cref='System.CodeDom.CodeTypeMember'/> from the 
        ///    <see cref='System.CodeDom.CodeTypeMemberCollection'/> .</para>
        /// </devdoc>
        public void Remove(CodeTypeMember value) {
            List.Remove(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codetypedelegate.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeTypeDelegate.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Reflection;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeTypeDelegate.uex' path='docs/doc[@for="CodeTypeDelegate"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a class or nested class.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeTypeDelegate : CodeTypeDeclaration {
        private CodeParameterDeclarationExpressionCollection parameters = new CodeParameterDeclarationExpressionCollection();
        private CodeTypeReference returnType;

        /// <include file='doc\CodeTypeDelegate.uex' path='docs/doc[@for="CodeTypeDelegate.CodeTypeDelegate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTypeDelegate'/>.
        ///    </para>
        /// </devdoc>
        public CodeTypeDelegate() {
            TypeAttributes &= ~TypeAttributes.ClassSemanticsMask;
            TypeAttributes |= TypeAttributes.Class;
            BaseTypes.Clear();
            BaseTypes.Add(new CodeTypeReference("System.Delegate"));
        }

        /// <include file='doc\CodeTypeDelegate.uex' path='docs/doc[@for="CodeTypeDelegate.CodeTypeDelegate1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTypeDelegate'/>.
        ///    </para>
        /// </devdoc>
        public CodeTypeDelegate(string name) : this() {
            Name = name;
        }

        /// <include file='doc\CodeTypeDelegate.uex' path='docs/doc[@for="CodeTypeDelegate.ReturnType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the return type of the delegate.
        ///    </para>
        /// </devdoc>
        public CodeTypeReference ReturnType {
            get {
                if (returnType == null) {
                    returnType = new CodeTypeReference("");
                }
                return returnType;
            }
            set {
                returnType = value;
            }
        }

        /// <include file='doc\CodeTypeDelegate.uex' path='docs/doc[@for="CodeTypeDelegate.Parameters"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The parameters of the delegate.
        ///    </para>
        /// </devdoc>
        public CodeParameterDeclarationExpressionCollection Parameters {
            get {
                return parameters;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codetypereferencecollection.cs ===
// ------------------------------------------------------------------------------
// <copyright file="CodeTypeReferenceCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright> 
// ------------------------------------------------------------------------------
// 
namespace System.CodeDom {
    using System;
    using System.Collections;
    using System.Runtime.InteropServices;
    
    
    /// <include file='doc\CodeTypeReferenceCollection.uex' path='docs/doc[@for="CodeTypeReferenceCollection"]/*' />
    /// <devdoc>
    ///     <para>
    ///       A collection that stores <see cref='System.CodeDom.CodeTypeReference'/> objects.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeTypeReferenceCollection : CollectionBase {
        
        /// <include file='doc\CodeTypeReferenceCollection.uex' path='docs/doc[@for="CodeTypeReferenceCollection.CodeTypeReferenceCollection"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTypeReferenceCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeTypeReferenceCollection() {
        }
        
        /// <include file='doc\CodeTypeReferenceCollection.uex' path='docs/doc[@for="CodeTypeReferenceCollection.CodeTypeReferenceCollection1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTypeReferenceCollection'/> based on another <see cref='System.CodeDom.CodeTypeReferenceCollection'/>.
        ///    </para>
        /// </devdoc>
        public CodeTypeReferenceCollection(CodeTypeReferenceCollection value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeTypeReferenceCollection.uex' path='docs/doc[@for="CodeTypeReferenceCollection.CodeTypeReferenceCollection2"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTypeReferenceCollection'/> containing any array of <see cref='System.CodeDom.CodeTypeReference'/> objects.
        ///    </para>
        /// </devdoc>
        public CodeTypeReferenceCollection(CodeTypeReference[] value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CodeTypeReferenceCollection.uex' path='docs/doc[@for="CodeTypeReferenceCollection.this"]/*' />
        /// <devdoc>
        /// <para>Represents the entry at the specified index of the <see cref='System.CodeDom.CodeTypeReference'/>.</para>
        /// </devdoc>
        public CodeTypeReference this[int index] {
            get {
                return ((CodeTypeReference)(List[index]));
            }
            set {
                List[index] = value;
            }
        }
        
        /// <include file='doc\CodeTypeReferenceCollection.uex' path='docs/doc[@for="CodeTypeReferenceCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>Adds a <see cref='System.CodeDom.CodeTypeReference'/> with the specified value to the 
        ///    <see cref='System.CodeDom.CodeTypeReferenceCollection'/> .</para>
        /// </devdoc>
        public int Add(CodeTypeReference value) {
            return List.Add(value);
        }

        /// <include file='doc\CodeTypeReferenceCollection.uex' path='docs/doc[@for="CodeTypeReferenceCollection.Add1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(string value) {
            Add(new CodeTypeReference(value));
        }

        /// <include file='doc\CodeTypeReferenceCollection.uex' path='docs/doc[@for="CodeTypeReferenceCollection.Add2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(Type value) {
            Add(new CodeTypeReference(value));
        }
        
        /// <include file='doc\CodeTypeReferenceCollection.uex' path='docs/doc[@for="CodeTypeReferenceCollection.AddRange"]/*' />
        /// <devdoc>
        /// <para>Copies the elements of an array to the end of the <see cref='System.CodeDom.CodeTypeReferenceCollection'/>.</para>
        /// </devdoc>
        public void AddRange(CodeTypeReference[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeTypeReferenceCollection.uex' path='docs/doc[@for="CodeTypeReferenceCollection.AddRange1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Adds the contents of another <see cref='System.CodeDom.CodeTypeReferenceCollection'/> to the end of the collection.
        ///    </para>
        /// </devdoc>
        public void AddRange(CodeTypeReferenceCollection value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CodeTypeReferenceCollection.uex' path='docs/doc[@for="CodeTypeReferenceCollection.Contains"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the 
        ///    <see cref='System.CodeDom.CodeTypeReferenceCollection'/> contains the specified <see cref='System.CodeDom.CodeTypeReference'/>.</para>
        /// </devdoc>
        public bool Contains(CodeTypeReference value) {
            return List.Contains(value);
        }
        
        /// <include file='doc\CodeTypeReferenceCollection.uex' path='docs/doc[@for="CodeTypeReferenceCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the <see cref='System.CodeDom.CodeTypeReferenceCollection'/> values to a one-dimensional <see cref='System.Array'/> instance at the 
        ///    specified index.</para>
        /// </devdoc>
        public void CopyTo(CodeTypeReference[] array, int index) {
            List.CopyTo(array, index);
        }
        
        /// <include file='doc\CodeTypeReferenceCollection.uex' path='docs/doc[@for="CodeTypeReferenceCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>Returns the index of a <see cref='System.CodeDom.CodeTypeReference'/> in 
        ///       the <see cref='System.CodeDom.CodeTypeReferenceCollection'/> .</para>
        /// </devdoc>
        public int IndexOf(CodeTypeReference value) {
            return List.IndexOf(value);
        }
        
        /// <include file='doc\CodeTypeReferenceCollection.uex' path='docs/doc[@for="CodeTypeReferenceCollection.Insert"]/*' />
        /// <devdoc>
        /// <para>Inserts a <see cref='System.CodeDom.CodeTypeReference'/> into the <see cref='System.CodeDom.CodeTypeReferenceCollection'/> at the specified index.</para>
        /// </devdoc>
        public void Insert(int index, CodeTypeReference value) {
            List.Insert(index, value);
        }
        
        /// <include file='doc\CodeTypeReferenceCollection.uex' path='docs/doc[@for="CodeTypeReferenceCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para> Removes a specific <see cref='System.CodeDom.CodeTypeReference'/> from the 
        ///    <see cref='System.CodeDom.CodeTypeReferenceCollection'/> .</para>
        /// </devdoc>
        public void Remove(CodeTypeReference value) {
            List.Remove(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codetypereference.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeTypeReference.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeTypeReference.uex' path='docs/doc[@for="CodeTypeReference"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a Type
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeTypeReference : CodeObject {
        private string baseType;
        private int arrayRank;
        private CodeTypeReference arrayElementType;

        /// <include file='doc\CodeTypeReference.uex' path='docs/doc[@for="CodeTypeReference.CodeTypeReference"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeTypeReference(Type type) {
            if (type.IsArray) {
                this.arrayRank = type.GetArrayRank();
                this.arrayElementType = new CodeTypeReference(type.GetElementType());
                this.baseType = null;
            } else {
                this.arrayRank = 0;
                this.arrayElementType = null;
                this.baseType = type.FullName;
            }
        }

        /// <include file='doc\CodeTypeReference.uex' path='docs/doc[@for="CodeTypeReference.CodeTypeReference1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeTypeReference(string typeName) {
            if (typeName == null || typeName.Length == 0) {
                typeName = typeof(void).FullName;
            }

            // See if this ends with standard array tail. If is is not an exact match, we pass it through verbatim.
            int lastArrayOpen = typeName.LastIndexOf('[');
            int lastArrayClose = typeName.LastIndexOf(']');
            bool isArray = lastArrayOpen >= 0 && lastArrayClose == (typeName.Length - 1) && lastArrayOpen < lastArrayClose;
            if (isArray) {
                for (int index = lastArrayOpen + 1; index < lastArrayClose; index++) {
                    if (typeName[index] != ',') {
                        isArray = false;
                    }
                }
            }

            if (isArray) {
                this.baseType = null;
                this.arrayRank = lastArrayClose - lastArrayOpen;
                this.arrayElementType = new CodeTypeReference(typeName.Substring(0, lastArrayOpen));
            }
            else {
                this.baseType = typeName;
                this.arrayRank = 0;
                this.arrayElementType = null;
            }
        }

        /// <include file='doc\CodeTypeReference.uex' path='docs/doc[@for="CodeTypeReference.CodeTypeReference3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeTypeReference(string baseType, int rank) {
            this.baseType = null;
            this.arrayRank = rank;
            this.arrayElementType = new CodeTypeReference(baseType);
        }

        /// <include file='doc\CodeTypeReference.uex' path='docs/doc[@for="CodeTypeReference.CodeTypeReference4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeTypeReference(CodeTypeReference arrayType, int rank) {
            this.baseType = null;
            this.arrayRank = rank;
            this.arrayElementType = arrayType;
        }
 
        /// <include file='doc\CodeTypeReference.uex' path='docs/doc[@for="CodeTypeReference.ArrayElementType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeTypeReference ArrayElementType {
            get {
                return arrayElementType;
            }
            set {
                arrayElementType = value;
            }
        }

        /// <include file='doc\CodeTypeReference.uex' path='docs/doc[@for="CodeTypeReference.ArrayRank"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int ArrayRank {
            get {
                return arrayRank;
            }
            set {
                arrayRank = value;
            }
        }

        /// <include file='doc\CodeTypeReference.uex' path='docs/doc[@for="CodeTypeReference.BaseType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string BaseType {
            get {
                if (arrayRank > 0 && arrayElementType != null) {
                    return arrayElementType.BaseType;
                }
                return (baseType == null) ? string.Empty : baseType;
            }
            set {
                baseType = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codetypemember.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeTypeMember.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Reflection;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeTypeMember.uex' path='docs/doc[@for="CodeTypeMember"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a class member.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeTypeMember : CodeObject {
        private MemberAttributes attributes = MemberAttributes.Private | MemberAttributes.Final;
        private string name;
        private CodeCommentStatementCollection comments = new CodeCommentStatementCollection();
        private CodeAttributeDeclarationCollection customAttributes = null;
        private CodeLinePragma linePragma;

        /// <include file='doc\CodeTypeMember.uex' path='docs/doc[@for="CodeTypeMember.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       the name of the member.
        ///    </para>
        /// </devdoc>
        public string Name {
            get {
                return (name == null) ? string.Empty : name;
            }
            set {
                name = value;
            }
        }

        /// <include file='doc\CodeTypeMember.uex' path='docs/doc[@for="CodeTypeMember.Attributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a <see cref='System.CodeDom.MemberAttributes'/> indicating
        ///       the attributes of the member.
        ///    </para>
        /// </devdoc>
        public MemberAttributes Attributes {
            get {
                return attributes;
            }
            set {
                attributes = value;
            }
        }

        /// <include file='doc\CodeTypeMember.uex' path='docs/doc[@for="CodeTypeMember.CustomAttributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a <see cref='System.CodeDom.CodeAttributeDeclarationCollection'/> indicating
        ///       the custom attributes of the
        ///       member.
        ///    </para>
        /// </devdoc>
        public CodeAttributeDeclarationCollection CustomAttributes {
            get {
                if (customAttributes == null) {
                    customAttributes = new CodeAttributeDeclarationCollection();
                }
                return customAttributes;
            }
            set {
                customAttributes = value;
            }
        }

        /// <include file='doc\CodeTypeMember.uex' path='docs/doc[@for="CodeTypeMember.LinePragma"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The line the statement occurs on.
        ///    </para>
        /// </devdoc>
        public CodeLinePragma LinePragma {
            get {
                return linePragma;
            }
            set {
                linePragma = value;
            }
        }

        /// <include file='doc\CodeTypeMember.uex' path='docs/doc[@for="CodeTypeMember.Comments"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the member comment collection members.
        ///    </para>
        /// </devdoc>
        public CodeCommentStatementCollection Comments {
            get {
                return comments;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codetypeofexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeTypeOfExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeTypeOfExpression.uex' path='docs/doc[@for="CodeTypeOfExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a TypeOf expression.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeTypeOfExpression : CodeExpression {
        private CodeTypeReference type;

        /// <include file='doc\CodeTypeOfExpression.uex' path='docs/doc[@for="CodeTypeOfExpression.CodeTypeOfExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTypeOfExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeTypeOfExpression() {
        }

        /// <include file='doc\CodeTypeOfExpression.uex' path='docs/doc[@for="CodeTypeOfExpression.CodeTypeOfExpression1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTypeOfExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeTypeOfExpression(CodeTypeReference type) {
            Type = type;
        }

        /// <include file='doc\CodeTypeOfExpression.uex' path='docs/doc[@for="CodeTypeOfExpression.CodeTypeOfExpression2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeTypeOfExpression(string type) {
            Type = new CodeTypeReference(type);
        }

        /// <include file='doc\CodeTypeOfExpression.uex' path='docs/doc[@for="CodeTypeOfExpression.CodeTypeOfExpression3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeTypeOfExpression(Type type) {
            Type = new CodeTypeReference(type);
        }

        /// <include file='doc\CodeTypeOfExpression.uex' path='docs/doc[@for="CodeTypeOfExpression.Type"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the data type.
        ///    </para>
        /// </devdoc>
        public CodeTypeReference Type {
            get {
                if (type == null) {
                    type = new CodeTypeReference("");
                }
                return type;
            }
            set {
                type = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codevariabledeclarationstatement.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeVariableDeclarationStatement.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeVariableDeclarationStatement.uex' path='docs/doc[@for="CodeVariableDeclarationStatement"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a local variable declaration.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeVariableDeclarationStatement : CodeStatement {
        private CodeTypeReference type;
        private string name;
        private CodeExpression initExpression;

        /// <include file='doc\CodeVariableDeclarationStatement.uex' path='docs/doc[@for="CodeVariableDeclarationStatement.CodeVariableDeclarationStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeVariableDeclarationStatement'/>.
        ///    </para>
        /// </devdoc>
        public CodeVariableDeclarationStatement() {
        }

        /// <include file='doc\CodeVariableDeclarationStatement.uex' path='docs/doc[@for="CodeVariableDeclarationStatement.CodeVariableDeclarationStatement1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeVariableDeclarationStatement'/> using the specified type and name.
        ///    </para>
        /// </devdoc>
        public CodeVariableDeclarationStatement(CodeTypeReference type, string name) {
            Type = type;
            Name = name;
        }

        /// <include file='doc\CodeVariableDeclarationStatement.uex' path='docs/doc[@for="CodeVariableDeclarationStatement.CodeVariableDeclarationStatement2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeVariableDeclarationStatement(string type, string name) {
            Type = new CodeTypeReference(type);
            Name = name;
        }

        /// <include file='doc\CodeVariableDeclarationStatement.uex' path='docs/doc[@for="CodeVariableDeclarationStatement.CodeVariableDeclarationStatement3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeVariableDeclarationStatement(Type type, string name) {
            Type = new CodeTypeReference(type);
            Name = name;
        }

        /// <include file='doc\CodeVariableDeclarationStatement.uex' path='docs/doc[@for="CodeVariableDeclarationStatement.CodeVariableDeclarationStatement4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeVariableDeclarationStatement'/> using the specified type, name and
        ///       initialization expression.
        ///    </para>
        /// </devdoc>
        public CodeVariableDeclarationStatement(CodeTypeReference type, string name, CodeExpression initExpression) {
            Type = type;
            Name = name;
            InitExpression = initExpression;
        }

        /// <include file='doc\CodeVariableDeclarationStatement.uex' path='docs/doc[@for="CodeVariableDeclarationStatement.CodeVariableDeclarationStatement5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeVariableDeclarationStatement(string type, string name, CodeExpression initExpression) {
            Type = new CodeTypeReference(type);
            Name = name;
            InitExpression = initExpression;
        }

        /// <include file='doc\CodeVariableDeclarationStatement.uex' path='docs/doc[@for="CodeVariableDeclarationStatement.CodeVariableDeclarationStatement6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeVariableDeclarationStatement(Type type, string name, CodeExpression initExpression) {
            Type = new CodeTypeReference(type);
            Name = name;
            InitExpression = initExpression;
        }

        /// <include file='doc\CodeVariableDeclarationStatement.uex' path='docs/doc[@for="CodeVariableDeclarationStatement.InitExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the initialization expression for the variable.
        ///    </para>
        /// </devdoc>
        public CodeExpression InitExpression {
            get {
                return initExpression;
            }
            set {
                initExpression = value;
            }
        }

        /// <include file='doc\CodeVariableDeclarationStatement.uex' path='docs/doc[@for="CodeVariableDeclarationStatement.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the name of the variable.
        ///    </para>
        /// </devdoc>
        public string Name {
            get {
                return (name == null) ? string.Empty : name;
            }
            set {
                name = value;
            }
        }

        /// <include file='doc\CodeVariableDeclarationStatement.uex' path='docs/doc[@for="CodeVariableDeclarationStatement.Type"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the type of the variable.
        ///    </para>
        /// </devdoc>
        public CodeTypeReference Type {
            get {
                if (type == null) {
                    type = new CodeTypeReference("");
                }
                return type;
            }
            set {
                type = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codetypereferenceexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeTypeReferenceExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeTypeReferenceExpression.uex' path='docs/doc[@for="CodeTypeReferenceExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a reference to a type.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeTypeReferenceExpression : CodeExpression {
        private CodeTypeReference type;

        /// <include file='doc\CodeTypeReferenceExpression.uex' path='docs/doc[@for="CodeTypeReferenceExpression.CodeTypeReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTypeReferenceExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeTypeReferenceExpression() {
        }

        /// <include file='doc\CodeTypeReferenceExpression.uex' path='docs/doc[@for="CodeTypeReferenceExpression.CodeTypeReferenceExpression1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeTypeReferenceExpression'/> using the specified type.
        ///    </para>
        /// </devdoc>
        public CodeTypeReferenceExpression(CodeTypeReference type) {
            Type = type;
        }

        /// <include file='doc\CodeTypeReferenceExpression.uex' path='docs/doc[@for="CodeTypeReferenceExpression.CodeTypeReferenceExpression2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeTypeReferenceExpression(string type) {
            Type = new CodeTypeReference(type);
        }

        /// <include file='doc\CodeTypeReferenceExpression.uex' path='docs/doc[@for="CodeTypeReferenceExpression.CodeTypeReferenceExpression3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeTypeReferenceExpression(Type type) {
            Type = new CodeTypeReference(type);
        }

        /// <include file='doc\CodeTypeReferenceExpression.uex' path='docs/doc[@for="CodeTypeReferenceExpression.Type"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the type to reference.
        ///    </para>
        /// </devdoc>
        public CodeTypeReference Type {
            get {
                if (type == null) {
                    type = new CodeTypeReference("");
                }
                return type;
            }
            set {
                type = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\codevariablereferenceexpression.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeVariableReferenceExpression.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.InteropServices;

    /// <include file='doc\CodeVariableReferenceExpression.uex' path='docs/doc[@for="CodeVariableReferenceExpression"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a reference to a field.
    ///    </para>
    /// </devdoc>
    [
        ClassInterface(ClassInterfaceType.AutoDispatch),
        ComVisible(true),
        Serializable,
    ]
    public class CodeVariableReferenceExpression : CodeExpression {
        private string variableName;

        /// <include file='doc\CodeVariableReferenceExpression.uex' path='docs/doc[@for="CodeVariableReferenceExpression.CodeVariableReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeVariableReferenceExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeVariableReferenceExpression() {
        }

        /// <include file='doc\CodeVariableReferenceExpression.uex' path='docs/doc[@for="CodeVariableReferenceExpression.CodeVariableReferenceExpression1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.CodeArgumentReferenceExpression'/>.
        ///    </para>
        /// </devdoc>
        public CodeVariableReferenceExpression(string variableName) {
            this.variableName = variableName;
        }


        /// <include file='doc\CodeVariableReferenceExpression.uex' path='docs/doc[@for="CodeVariableReferenceExpression.VariableName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string VariableName {
            get {
                return (variableName == null) ? string.Empty : variableName;
            }
            set {
                variableName = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\fielddirection.cs ===
//------------------------------------------------------------------------------
// <copyright file="FieldDirection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System.Runtime.InteropServices;

    /// <include file='doc\FieldDirection.uex' path='docs/doc[@for="FieldDirection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies values used to indicate field and parameter directions.
    ///    </para>
    /// </devdoc>
    [
        ComVisible(true),
        Serializable,
    ]
    public enum FieldDirection {
        /// <include file='doc\FieldDirection.uex' path='docs/doc[@for="FieldDirection.In"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Incoming field.
        ///    </para>
        /// </devdoc>
        In,
        /// <include file='doc\FieldDirection.uex' path='docs/doc[@for="FieldDirection.Out"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Outgoing field.
        ///    </para>
        /// </devdoc>
        Out,
        /// <include file='doc\FieldDirection.uex' path='docs/doc[@for="FieldDirection.Ref"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Field by reference.
        ///    </para>
        /// </devdoc>
        Ref,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\memberattributes.cs ===
//------------------------------------------------------------------------------
// <copyright file="MemberAttributes.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom {

    using System.Diagnostics;
    using System.Runtime.InteropServices;
    
    /// <include file='doc\MemberAttributes.uex' path='docs/doc[@for="MemberAttributes"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Specifies member attributes used for class members.
    ///    </para>
    /// </devdoc>
    [
        ComVisible(true),
        Serializable,
    ]
    public enum MemberAttributes {
        /// <include file='doc\MemberAttributes.uex' path='docs/doc[@for="MemberAttributes.Abstract"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Abstract        = 0x0001,
        /// <include file='doc\MemberAttributes.uex' path='docs/doc[@for="MemberAttributes.Final"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Final           = 0x0002,
        /// <include file='doc\MemberAttributes.uex' path='docs/doc[@for="MemberAttributes.Static"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Static          = 0x0003,
        /// <include file='doc\MemberAttributes.uex' path='docs/doc[@for="MemberAttributes.Override"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Override        = 0x0004,
        /// <include file='doc\MemberAttributes.uex' path='docs/doc[@for="MemberAttributes.Const"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Const           = 0x0005,
        /// <include file='doc\MemberAttributes.uex' path='docs/doc[@for="MemberAttributes.New"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        New             = 0x0010,
        /// <include file='doc\MemberAttributes.uex' path='docs/doc[@for="MemberAttributes.Overloaded"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Overloaded      = 0x0100,
        /// <include file='doc\MemberAttributes.uex' path='docs/doc[@for="MemberAttributes.Assembly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Assembly        = 0x1000,
        /// <include file='doc\MemberAttributes.uex' path='docs/doc[@for="MemberAttributes.FamilyAndAssembly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        FamilyAndAssembly = 0x2000,
        /// <include file='doc\MemberAttributes.uex' path='docs/doc[@for="MemberAttributes.Family"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Family            = 0x3000,
        /// <include file='doc\MemberAttributes.uex' path='docs/doc[@for="MemberAttributes.FamilyOrAssembly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        FamilyOrAssembly  = 0x4000,
        /// <include file='doc\MemberAttributes.uex' path='docs/doc[@for="MemberAttributes.Private"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Private         = 0x5000,
        /// <include file='doc\MemberAttributes.uex' path='docs/doc[@for="MemberAttributes.Public"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Public          = 0x6000,

        /// <include file='doc\MemberAttributes.uex' path='docs/doc[@for="MemberAttributes.AccessMask"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        AccessMask      = 0xF000,
        /// <include file='doc\MemberAttributes.uex' path='docs/doc[@for="MemberAttributes.ScopeMask"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ScopeMask       = 0x000F,
        /// <include file='doc\MemberAttributes.uex' path='docs/doc[@for="MemberAttributes.VTableMask"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        VTableMask      = 0x00F0,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\compiler\codedomprovider.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeDOMProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom.Compiler {
    using System;
    using System.CodeDom;
    using System.ComponentModel;
    using System.IO;
    using System.Security.Permissions;

    /// <include file='doc\CodeDOMProvider.uex' path='docs/doc[@for="CodeDomProvider"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
    ToolboxItem(false)
    ]
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public abstract class CodeDomProvider : Component {
    
        /// <include file='doc\CodeDOMProvider.uex' path='docs/doc[@for="CodeDomProvider.FileExtension"]/*' />
        /// <devdoc>
        ///    <para>Retrieves the default extension to use when saving files using this code dom provider.</para>
        /// </devdoc>
        public virtual string FileExtension {
            get {
                return string.Empty;
            }
        }

        /// <include file='doc\CodeDOMProvider.uex' path='docs/doc[@for="CodeDomProvider.LanguageOptions"]/*' />
        /// <devdoc>
        ///    <para>Returns flags representing language variations.</para>
        /// </devdoc>
        public virtual LanguageOptions LanguageOptions {
            get {
                return LanguageOptions.None;
            }
        }
        
        /// <include file='doc\CodeDOMProvider.uex' path='docs/doc[@for="CodeDomProvider.CreateGenerator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract ICodeGenerator CreateGenerator();

        /// <include file='doc\CodeDOMProvider.uex' path='docs/doc[@for="CodeDomProvider.CreateGenerator1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual ICodeGenerator CreateGenerator(TextWriter output) {
            return CreateGenerator();
        }

        /// <include file='doc\CodeDOMProvider.uex' path='docs/doc[@for="CodeDomProvider.CreateGenerator2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual ICodeGenerator CreateGenerator(string fileName) {
            return CreateGenerator();
        }

        /// <include file='doc\CodeDOMProvider.uex' path='docs/doc[@for="CodeDomProvider.CreateCompiler"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public abstract ICodeCompiler CreateCompiler();
        
        /// <include file='doc\CodeDOMProvider.uex' path='docs/doc[@for="CodeDomProvider.CreateParser"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual ICodeParser CreateParser() {
            return null;
        }
        
        /// <include file='doc\CodeDOMProvider.uex' path='docs/doc[@for="CodeDomProvider.GetConverter"]/*' />
        /// <devdoc>
        ///     This method allows a code dom provider implementation to provide a different type converter
        ///     for a given data type.  At design time, a designer may pass data types through this
        ///     method to see if the code dom provider wants to provide an additional converter.  
        ///     As typical way this would be used is if the language this code dom provider implements
        ///     does not support all of the values of MemberAttributes enumeration, or if the language
        ///     uses different names (Protected instead of Family, for example).  The default 
        ///     implementation just calls TypeDescriptor.GetConverter for the given type.
        /// </devdoc>
        public virtual TypeConverter GetConverter(Type type) {
            return TypeDescriptor.GetConverter(type);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\compiler\codeparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom.Compiler {
    using System.Text;

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.IO;
    using System.Collections;
    using System.Reflection;
    using System.CodeDom;
    using System.Security.Permissions;

    /// <include file='doc\CodeParser.uex' path='docs/doc[@for="CodeParser"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides a code parsing abstract base class.
    ///    </para>
    /// </devdoc>
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public abstract class CodeParser : ICodeParser {
    
        /// <include file='doc\CodeParser.uex' path='docs/doc[@for="CodeParser.Parse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compiles the given text stream into a CodeCompile unit.  
        ///    </para>
        /// </devdoc>
        public abstract CodeCompileUnit Parse(TextReader codeStream);
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\compiler\compilererrorcollection.cs ===
// ------------------------------------------------------------------------------
// <copyright file="CompilerErrorCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright> 
// ------------------------------------------------------------------------------
// 
namespace System.CodeDom.Compiler {
    using System;
    using System.Collections;
    using System.Security.Permissions;
    
    
    /// <include file='doc\CompilerErrorCollection.uex' path='docs/doc[@for="CompilerErrorCollection"]/*' />
    /// <devdoc>
    ///     <para>
    ///       A collection that stores <see cref='System.CodeDom.Compiler.CompilerError'/> objects.
    ///    </para>
    /// </devdoc>
    [Serializable()]
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public class CompilerErrorCollection : CollectionBase {
        
        /// <include file='doc\CompilerErrorCollection.uex' path='docs/doc[@for="CompilerErrorCollection.CompilerErrorCollection"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.Compiler.CompilerErrorCollection'/>.
        ///    </para>
        /// </devdoc>
        public CompilerErrorCollection() {
        }
        
        /// <include file='doc\CompilerErrorCollection.uex' path='docs/doc[@for="CompilerErrorCollection.CompilerErrorCollection1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.Compiler.CompilerErrorCollection'/> based on another <see cref='System.CodeDom.Compiler.CompilerErrorCollection'/>.
        ///    </para>
        /// </devdoc>
        public CompilerErrorCollection(CompilerErrorCollection value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CompilerErrorCollection.uex' path='docs/doc[@for="CompilerErrorCollection.CompilerErrorCollection2"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.Compiler.CompilerErrorCollection'/> containing any array of <see cref='System.CodeDom.Compiler.CompilerError'/> objects.
        ///    </para>
        /// </devdoc>
        public CompilerErrorCollection(CompilerError[] value) {
            this.AddRange(value);
        }
        
        /// <include file='doc\CompilerErrorCollection.uex' path='docs/doc[@for="CompilerErrorCollection.this"]/*' />
        /// <devdoc>
        /// <para>Represents the entry at the specified index of the <see cref='System.CodeDom.Compiler.CompilerError'/>.</para>
        /// </devdoc>
        public CompilerError this[int index] {
            get {
                return ((CompilerError)(List[index]));
            }
            set {
                List[index] = value;
            }
        }
        
        /// <include file='doc\CompilerErrorCollection.uex' path='docs/doc[@for="CompilerErrorCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>Adds a <see cref='System.CodeDom.Compiler.CompilerError'/> with the specified value to the 
        ///    <see cref='System.CodeDom.Compiler.CompilerErrorCollection'/> .</para>
        /// </devdoc>
        public int Add(CompilerError value) {
            return List.Add(value);
        }
        
        /// <include file='doc\CompilerErrorCollection.uex' path='docs/doc[@for="CompilerErrorCollection.AddRange"]/*' />
        /// <devdoc>
        /// <para>Copies the elements of an array to the end of the <see cref='System.CodeDom.Compiler.CompilerErrorCollection'/>.</para>
        /// </devdoc>
        public void AddRange(CompilerError[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            for (int i = 0; ((i) < (value.Length)); i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CompilerErrorCollection.uex' path='docs/doc[@for="CompilerErrorCollection.AddRange1"]/*' />
        /// <devdoc>
        ///     <para>
        ///       Adds the contents of another <see cref='System.CodeDom.Compiler.CompilerErrorCollection'/> to the end of the collection.
        ///    </para>
        /// </devdoc>
        public void AddRange(CompilerErrorCollection value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            int currentCount = value.Count;
            for (int i = 0; i < currentCount; i = ((i) + (1))) {
                this.Add(value[i]);
            }
        }
        
        /// <include file='doc\CompilerErrorCollection.uex' path='docs/doc[@for="CompilerErrorCollection.Contains"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the 
        ///    <see cref='System.CodeDom.Compiler.CompilerErrorCollection'/> contains the specified <see cref='System.CodeDom.Compiler.CompilerError'/>.</para>
        /// </devdoc>
        public bool Contains(CompilerError value) {
            return List.Contains(value);
        }
        
        /// <include file='doc\CompilerErrorCollection.uex' path='docs/doc[@for="CompilerErrorCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the <see cref='System.CodeDom.Compiler.CompilerErrorCollection'/> values to a one-dimensional <see cref='System.Array'/> instance at the 
        ///    specified index.</para>
        /// </devdoc>
        public void CopyTo(CompilerError[] array, int index) {
            List.CopyTo(array, index);
        }

        /// <include file='doc\CompilerErrorCollection.uex' path='docs/doc[@for="CompilerErrorCollection.HasErrors"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       a value indicating whether the collection contains errors.
        ///    </para>
        /// </devdoc>
        public bool HasErrors {
            get {
                if (Count > 0) {
                    foreach (CompilerError e in this) {
                        if (!e.IsWarning) {
                            return true;
                        }
                    }
                }
                return false;
            }
        }

        /// <include file='doc\CompilerErrorCollection.uex' path='docs/doc[@for="CompilerErrorCollection.HasWarnings"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       a value indicating whether the collection contains warnings.
        ///    </para>
        /// </devdoc>
        public bool HasWarnings {
            get {
                if (Count > 0) {
                    foreach (CompilerError e in this) {
                        if (e.IsWarning) {
                            return true;
                        }
                    }
                }
                return false;
            }
        }
        
        /// <include file='doc\CompilerErrorCollection.uex' path='docs/doc[@for="CompilerErrorCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>Returns the index of a <see cref='System.CodeDom.Compiler.CompilerError'/> in 
        ///       the <see cref='System.CodeDom.Compiler.CompilerErrorCollection'/> .</para>
        /// </devdoc>
        public int IndexOf(CompilerError value) {
            return List.IndexOf(value);
        }
        
        /// <include file='doc\CompilerErrorCollection.uex' path='docs/doc[@for="CompilerErrorCollection.Insert"]/*' />
        /// <devdoc>
        /// <para>Inserts a <see cref='System.CodeDom.Compiler.CompilerError'/> into the <see cref='System.CodeDom.Compiler.CompilerErrorCollection'/> at the specified index.</para>
        /// </devdoc>
        public void Insert(int index, CompilerError value) {
            List.Insert(index, value);
        }
        
        /// <include file='doc\CompilerErrorCollection.uex' path='docs/doc[@for="CompilerErrorCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para> Removes a specific <see cref='System.CodeDom.Compiler.CompilerError'/> from the 
        ///    <see cref='System.CodeDom.Compiler.CompilerErrorCollection'/> .</para>
        /// </devdoc>
        public void Remove(CompilerError value) {
            List.Remove(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\compiler\codecompiler.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeCompiler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom.Compiler {
    using System.Text;

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.IO;
    using System.Collections;
    using System.Security;
    using System.Security.Permissions;
    using System.Reflection;
    using System.CodeDom;

    /// <include file='doc\CodeCompiler.uex' path='docs/doc[@for="CodeCompiler"]/*' />
    /// <devdoc>
    ///    <para>Provides a
    ///       base
    ///       class for code compilers.</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public abstract class CodeCompiler : CodeGenerator, ICodeCompiler {

        /// <include file='doc\CodeCompiler.uex' path='docs/doc[@for="CodeCompiler.ICodeCompiler.CompileAssemblyFromDom"]/*' />
        /// <internalonly/>
        CompilerResults ICodeCompiler.CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit e) {
            try {
                return FromDom(options, e);
            }
            finally {
                options.TempFiles.Delete();
            }
        }

        /// <include file='doc\CodeCompiler.uex' path='docs/doc[@for="CodeCompiler.ICodeCompiler.CompileAssemblyFromFile"]/*' />
        /// <internalonly/>
        CompilerResults ICodeCompiler.CompileAssemblyFromFile(CompilerParameters options, string fileName) {
            try {
                return FromFile(options, fileName);
            }
            finally {
                options.TempFiles.Delete();
            }
        }

        /// <include file='doc\CodeCompiler.uex' path='docs/doc[@for="CodeCompiler.ICodeCompiler.CompileAssemblyFromSource"]/*' />
        /// <internalonly/>
        CompilerResults ICodeCompiler.CompileAssemblyFromSource(CompilerParameters options, string source) {
            try {
                return FromSource(options, source);
            }
            finally {
                options.TempFiles.Delete();
            }
        }

        /// <include file='doc\CodeCompiler.uex' path='docs/doc[@for="CodeCompiler.string"]/*' />
        /// <internalonly/>
        CompilerResults ICodeCompiler.CompileAssemblyFromSourceBatch(CompilerParameters options, string[] sources) {
            try {
                return FromSourceBatch(options, sources);
            }
            finally {
                options.TempFiles.Delete();
            }
        }
        
        /// <include file='doc\CodeCompiler.uex' path='docs/doc[@for="CodeCompiler.string1"]/*' />
        /// <internalonly/>
        CompilerResults ICodeCompiler.CompileAssemblyFromFileBatch(CompilerParameters options, string[] fileNames) {
            try {
                // Try opening the files to make sure they exists.  This will throw an exception
                // if it doesn't (bug 30532).
                foreach (string fileName in fileNames) {
                    Stream str = File.OpenRead(fileName);
                    str.Close();
                }

                return FromFileBatch(options, fileNames);
            }
            finally {
                options.TempFiles.Delete();
            }
        }

        /// <include file='doc\CodeCompiler.uex' path='docs/doc[@for="CodeCompiler.CodeCompileUnit"]/*' />
        /// <internalonly/>
        CompilerResults ICodeCompiler.CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] ea) {
            try {
                return FromDomBatch(options, ea);
            }
            finally {
                options.TempFiles.Delete();
            }
        }
        
        /// <include file='doc\CodeCompiler.uex' path='docs/doc[@for="CodeCompiler.FileExtension"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       or sets the file extension to use for source files.
        ///    </para>
        /// </devdoc>
        protected abstract string FileExtension {
            get;
        }

        /// <include file='doc\CodeCompiler.uex' path='docs/doc[@for="CodeCompiler.CompilerName"]/*' />
        /// <devdoc>
        ///    <para>Gets or
        ///       sets the name of the compiler executable.</para>
        /// </devdoc>
        protected abstract string CompilerName {
            get;
        }

        internal void Compile(CompilerParameters options, string compilerDirectory, string compilerExe, string arguments, ref string outputFile, ref int nativeReturnValue, string trueArgs) {
            string errorFile = null;
            outputFile = options.TempFiles.AddExtension("out");
            
            // We try to execute the compiler with a full path name.
            string fullname = compilerDirectory + compilerExe;
            if (File.Exists(fullname)) {
                string trueCmdLine = null;
                if (trueArgs != null)
                    trueCmdLine = "\"" + fullname + "\" " + trueArgs;
                nativeReturnValue = Executor.ExecWaitWithCapture(options.UserToken, "\"" + fullname + "\" " + arguments, options.TempFiles, ref outputFile, ref errorFile, trueCmdLine);
            }
            else {
                throw new InvalidOperationException(SR.GetString(SR.CompilerNotFound, fullname));
            }
        }

        /// <include file='doc\CodeCompiler.uex' path='docs/doc[@for="CodeCompiler.FromDom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compiles the specified compile unit and options, and returns the results
        ///       from the compilation.
        ///    </para>
        /// </devdoc>
        protected virtual CompilerResults FromDom(CompilerParameters options, CodeCompileUnit e) {
            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();
            
            CodeCompileUnit[] units = new CodeCompileUnit[1];
            units[0] = e;
            return FromDomBatch(options, units);
        }

        /// <include file='doc\CodeCompiler.uex' path='docs/doc[@for="CodeCompiler.FromFile"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compiles the specified file using the specified options, and returns the
        ///       results from the compilation.
        ///    </para>
        /// </devdoc>
        protected virtual CompilerResults FromFile(CompilerParameters options, string fileName) {
            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();

            Stream str = null;

            // Try opening the file to make sure it exists.  This will throw an exception
            // if it doesn't (bug 30532).
            str = File.OpenRead(fileName);
            str.Close();

            string[] filenames = new string[1];
            filenames[0] = fileName;
            return FromFileBatch(options, filenames);
        }
        
        /// <include file='doc\CodeCompiler.uex' path='docs/doc[@for="CodeCompiler.FromSource"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compiles the specified source code using the specified options, and
        ///       returns the results from the compilation.
        ///    </para>
        /// </devdoc>
         protected virtual CompilerResults FromSource(CompilerParameters options, string source) {
            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();

            string[] sources = new string[1];
            sources[0] = source;
            return FromSourceBatch(options, sources);
        }
        
        /// <include file='doc\CodeCompiler.uex' path='docs/doc[@for="CodeCompiler.FromDomBatch"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compiles the specified compile units and
        ///       options, and returns the results from the compilation.
        ///    </para>
        /// </devdoc>
        protected virtual CompilerResults FromDomBatch(CompilerParameters options, CodeCompileUnit[] ea) {
            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();

            string[] filenames = new string[ea.Length];

            for (int i = 0; i < ea.Length; i++) {
                ResolveReferencedAssemblies(options, ea[i]);
                filenames[i] = options.TempFiles.AddExtension(i + FileExtension);
                Stream temp = new FileStream(filenames[i], FileMode.Create, FileAccess.Write, FileShare.Read);
                try {
                    StreamWriter sw = new StreamWriter(temp, Encoding.UTF8);
                    ((ICodeGenerator)this).GenerateCodeFromCompileUnit(ea[i], sw, Options);
                    sw.Flush();
                    sw.Close();
                }
                finally {
                    temp.Close();
                }
            }

            return FromFileBatch(options, filenames);
        }

        /// <devdoc>
        ///    <para>
        ///       Because CodeCompileUnit and CompilerParameters both have a referenced assemblies 
        ///       property, they must be reconciled. However, because you can compile multiple
        ///       compile units with one set of options, it will simply merge them.
        ///    </para>
        /// </devdoc>
        private void ResolveReferencedAssemblies(CompilerParameters options, CodeCompileUnit e) {
            if (e.ReferencedAssemblies.Count > 0) {
                foreach(string assemblyName in e.ReferencedAssemblies) {
                    if (!options.ReferencedAssemblies.Contains(assemblyName)) {
                        options.ReferencedAssemblies.Add(assemblyName);
                    }
                }
            }
        }

        /// <include file='doc\CodeCompiler.uex' path='docs/doc[@for="CodeCompiler.FromFileBatch"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compiles the specified files using the specified options, and returns the
        ///       results from the compilation.
        ///    </para>
        /// </devdoc>
        protected virtual CompilerResults FromFileBatch(CompilerParameters options, string[] fileNames) {
            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();

            string outputFile = null;
            int retValue = 0;

            CompilerResults results = new CompilerResults(options.TempFiles);
            SecurityPermission perm1 = new SecurityPermission(SecurityPermissionFlag.ControlEvidence);
            perm1.Assert();
            try {
               results.Evidence = options.Evidence;
            }
            finally {
                 SecurityPermission.RevertAssert();
            }	
            bool createdEmptyAssembly = false;

            if (options.OutputAssembly == null || options.OutputAssembly.Length == 0) {
                string extension = (options.GenerateExecutable) ? "exe" : "dll";
                options.OutputAssembly = results.TempFiles.AddExtension(extension, !options.GenerateInMemory);

                // Create an empty assembly.  This is so that the file will have permissions that
                // we can later access with our current credential.  If we don't do this, the compiler
                // could end up creating an assembly that we cannot open (bug ASURT 83492)
                new FileStream(options.OutputAssembly, FileMode.Create, FileAccess.ReadWrite).Close();
                createdEmptyAssembly = true;
            }

            results.TempFiles.AddExtension("pdb");


            string args = CmdArgsFromParameters(options) + " " + JoinStringArray(fileNames, " ");

            // Use a response file if the compiler supports it
            string responseFileArgs = GetResponseFileCmdArgs(options, args);
            string trueArgs = null;
            if (responseFileArgs != null) {
                trueArgs = args;
                args = responseFileArgs;
            }

            Compile(options, Executor.GetRuntimeInstallDirectory(), CompilerName, args, ref outputFile, ref retValue, trueArgs);

            results.NativeCompilerReturnValue = retValue;

            // only look for errors/warnings if the compile failed or the caller set the warning level
            if (retValue != 0 || options.WarningLevel > 0) {

                FileStream outputStream = new FileStream(outputFile, FileMode.Open,
                    FileAccess.Read, FileShare.ReadWrite);
                try {
                    if (outputStream.Length > 0) {
                        // The output of the compiler is in UTF8 (bug 54925)
                        StreamReader sr = new StreamReader(outputStream, Encoding.UTF8);
                        string line;
                        do {
                            line = sr.ReadLine();
                            if (line != null) { 
                                results.Output.Add(line);

                                ProcessCompilerOutputLine(results, line);
                            }
                        } while (line != null);
                    }
                }
                finally {
                    outputStream.Close();
                }

                // Delete the empty assembly if we created one
                if (retValue != 0 && createdEmptyAssembly)
                    File.Delete(options.OutputAssembly);
            }

            if (!results.Errors.HasErrors && options.GenerateInMemory) {
                FileStream fs = new FileStream(options.OutputAssembly, FileMode.Open, FileAccess.Read, FileShare.Read);
                try {
                    int fileLen = (int)fs.Length;
                    byte[] b = new byte[fileLen];
                    fs.Read(b, 0, fileLen);
                    SecurityPermission perm = new SecurityPermission(SecurityPermissionFlag.ControlEvidence);
                    perm.Assert();
                    try {
                       results.CompiledAssembly = Assembly.Load(b,null,options.Evidence);
                    }
                    finally {
                       SecurityPermission.RevertAssert();
                    }		 
                }
                finally {
                    fs.Close();
                }
            }
            else {

                results.PathToAssembly = options.OutputAssembly;
            }

            return results;
        }

        /// <include file='doc\CodeCompiler.uex' path='docs/doc[@for="CodeCompiler.ProcessCompilerOutputLine"]/*' />
        /// <devdoc>
        /// <para>Processes the specified line from the specified <see cref='System.CodeDom.Compiler.CompilerResults'/> .</para>
        /// </devdoc>
        protected abstract void ProcessCompilerOutputLine(CompilerResults results, string line);

        /// <include file='doc\CodeCompiler.uex' path='docs/doc[@for="CodeCompiler.CmdArgsFromParameters"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the command arguments from the specified <see cref='System.CodeDom.Compiler.CompilerParameters'/>.
        ///    </para>
        /// </devdoc>
        protected abstract string CmdArgsFromParameters(CompilerParameters options);

        /// <include file='doc\CodeCompiler.uex' path='docs/doc[@for="CodeCompiler.GetResponseFileCmdArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual string GetResponseFileCmdArgs(CompilerParameters options, string cmdArgs) {

            string responseFileName = options.TempFiles.AddExtension("cmdline");

            Stream temp = new FileStream(responseFileName, FileMode.Create, FileAccess.Write, FileShare.Read);
            try {
                StreamWriter sw = new StreamWriter(temp, Encoding.UTF8);
                sw.Write(cmdArgs);
                sw.Flush();
                sw.Close();
            }
            finally {
                temp.Close();
            }

            return "@\"" + responseFileName + "\"";
        }

        /// <include file='doc\CodeCompiler.uex' path='docs/doc[@for="CodeCompiler.FromSourceBatch"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compiles the specified source code strings using the specified options, and
        ///       returns the results from the compilation.
        ///    </para>
        /// </devdoc>
        protected virtual CompilerResults FromSourceBatch(CompilerParameters options, string[] sources) {
            new SecurityPermission(SecurityPermissionFlag.UnmanagedCode).Demand();

            string[] filenames = new string[sources.Length];

            IntPtr impersonatedToken = IntPtr.Zero;
            CompilerResults results = null;
            bool needToImpersonate = Executor.RevertImpersonation(options.UserToken,ref impersonatedToken);  
            try {      
                for (int i = 0; i < sources.Length; i++) {
                    string name = options.TempFiles.AddExtension(i + FileExtension);
                    Stream temp = new FileStream(name, FileMode.Create, FileAccess.Write, FileShare.Read);
                    try {
                        StreamWriter sw = new StreamWriter(temp, Encoding.UTF8);
                        sw.Write(sources[i]);
                        sw.Flush();
                        sw.Close();
                    }
                    finally {
                        temp.Close();
                    }
                    filenames[i] = name;
               }
               results = FromFileBatch(options, filenames);
            }
            finally {
               Executor.ReImpersonate(impersonatedToken,needToImpersonate);
            }
            return results;
        }

        /// <include file='doc\CodeCompiler.uex' path='docs/doc[@for="CodeCompiler.JoinStringArray"]/*' />
        /// <devdoc>
        ///    <para>Joins the specified string arrays.</para>
        /// </devdoc>
        protected static string JoinStringArray(string[] sa, string separator) {
            if (sa == null || sa.Length == 0)
                return String.Empty;

            if (sa.Length == 1) {
                return "\"" + sa[0] + "\"";
            }

            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < sa.Length - 1; i++) {
                sb.Append("\"");
                sb.Append(sa[i]);
                sb.Append("\"");
                sb.Append(separator);
            }
            sb.Append("\"");
            sb.Append(sa[sa.Length - 1]);
            sb.Append("\"");

            return sb.ToString();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\compiler\compilererror.cs ===
//------------------------------------------------------------------------------
// <copyright file="CompilerError.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom.Compiler {
    using System;
    using System.CodeDom;
    using System.Security.Permissions;


    /// <include file='doc\CompilerError.uex' path='docs/doc[@for="CompilerError"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a compiler error.
    ///    </para>
    /// </devdoc>
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public class CompilerError {
        private int line;
        private int column;
        private string errorNumber;
        private bool warning = false;
        private string errorText;
        private string fileName;

        /// <include file='doc\CompilerError.uex' path='docs/doc[@for="CompilerError.CompilerError"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.Compiler.CompilerError'/>.
        ///    </para>
        /// </devdoc>
        public CompilerError() {
            this.line = 0;
            this.column = 0;
            this.errorNumber = string.Empty;
            this.errorText = string.Empty;
            this.fileName = string.Empty;
        }
        /// <include file='doc\CompilerError.uex' path='docs/doc[@for="CompilerError.CompilerError1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.Compiler.CompilerError'/> using the specified
        ///       filename, line, column, error number and error text.
        ///    </para>
        /// </devdoc>
        public CompilerError(string fileName, int line, int column, string errorNumber, string errorText) {
            this.line = line;
            this.column = column;
            this.errorNumber = errorNumber;
            this.errorText = errorText;
            this.fileName = fileName;
        }

        /// <include file='doc\CompilerError.uex' path='docs/doc[@for="CompilerError.Line"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the line number where the source of the error occurs.
        ///    </para>
        /// </devdoc>
        public int Line {
            get {
                return line;
            }
            set {
                line = value;
            }
        }

        /// <include file='doc\CompilerError.uex' path='docs/doc[@for="CompilerError.Column"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the column number where the source of the error occurs.
        ///    </para>
        /// </devdoc>
        public int Column {
            get {
                return column;
            }
            set {
                column = value;
            }
        }

        /// <include file='doc\CompilerError.uex' path='docs/doc[@for="CompilerError.ErrorNumber"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the error number.
        ///    </para>
        /// </devdoc>
        public string ErrorNumber {
            get {
                return errorNumber;
            }
            set {
                errorNumber = value;
            }
        }

        /// <include file='doc\CompilerError.uex' path='docs/doc[@for="CompilerError.ErrorText"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the text of the error message.
        ///    </para>
        /// </devdoc>
        public string ErrorText {
            get {
                return errorText;
            }
            set {
                errorText = value;
            }
        }

        /// <include file='doc\CompilerError.uex' path='docs/doc[@for="CompilerError.IsWarning"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets
        ///       a value indicating whether the error is a warning.
        ///    </para>
        /// </devdoc>
        public bool IsWarning {
            get {
                return warning;
            }
            set {
                warning = value;
            }
        }

        /// <include file='doc\CompilerError.uex' path='docs/doc[@for="CompilerError.FileName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the filename of the source that caused the error.
        ///    </para>
        /// </devdoc>
        public string FileName {
            get {
                return fileName;
            }
            set {
                fileName = value;
            }
        }

        /// <include file='doc\CompilerError.uex' path='docs/doc[@for="CompilerError.ToString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Overrides Object's ToString.
        ///    </para>
        /// </devdoc>
        public override string ToString() {
            if (FileName.Length > 0) {
                return string.Format("{0}({1},{2}) : {3} {4}: {5}",
                                     new object[] {
                                        FileName,
                                        Line,
                                        Column,
                                        IsWarning ? "warning" : "error",
                                        ErrorNumber,
                                        ErrorText});
            }
            else
                return string.Format("{0} {1}: {2}",                                         
                                        IsWarning ? "warning" : "error",
                                        ErrorNumber,
                                        ErrorText);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\compiler\codegeneratoroptions.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeGeneratorOptions.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom.Compiler {
    using System;
    using System.CodeDom;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Security.Permissions;


    /// <include file='doc\CodeGeneratorOptions.uex' path='docs/doc[@for="CodeGeneratorOptions"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents options used in code generation
    ///    </para>
    /// </devdoc>
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public class CodeGeneratorOptions {
        private IDictionary options = new ListDictionary();

        /// <include file='doc\CodeGeneratorOptions.uex' path='docs/doc[@for="CodeGeneratorOptions.CodeGeneratorOptions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public CodeGeneratorOptions() {
        }

        /// <include file='doc\CodeGeneratorOptions.uex' path='docs/doc[@for="CodeGeneratorOptions.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object this[string index] {
            get {
                return options[index];
            }
            set {
                options[index] = value;
            }
        }

        /// <include file='doc\CodeGeneratorOptions.uex' path='docs/doc[@for="CodeGeneratorOptions.IndentString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string IndentString {
            get {
                object o = options["IndentString"];
                return ((o == null) ? "    " : (string)o);
            }
            set {
                options["IndentString"] = value;
            }
        }

        /// <include file='doc\CodeGeneratorOptions.uex' path='docs/doc[@for="CodeGeneratorOptions.BracingStyle"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string BracingStyle {
            get {
                object o = options["BracingStyle"];
                return ((o == null) ? "Block" : (string)o);
            }
            set {
                options["BracingStyle"] = value;
            }
        }

        /// <include file='doc\CodeGeneratorOptions.uex' path='docs/doc[@for="CodeGeneratorOptions.ElseOnClosing"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool ElseOnClosing {
            get {
                object o = options["ElseOnClosing"];
                return ((o == null) ? false : (bool)o);
            }
            set {
                options["ElseOnClosing"] = value;
            }
        }

        /// <include file='doc\CodeGeneratorOptions.uex' path='docs/doc[@for="CodeGeneratorOptions.BlankLinesBetweenMembers"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool BlankLinesBetweenMembers {
            get {
                object o = options["BlankLinesBetweenMembers"];
                return ((o == null) ? true : (bool)o);
            }
            set {
                options["BlankLinesBetweenMembers"] = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\compiler\codevalidator.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeGenerator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom.Compiler {
    using System;
    using System.CodeDom;
    using System.Collections;
    using System.Globalization;

    // This is an internal helper class which walks the tree for the ValidateIdentifiers API in the CodeGenerator. For the most part the generator code has been copied and
    // turned into validation code. This code will only validate identifiers and types to check that they are ok in a language
    // independent manner. By default, this will not be turned on. This gives clients of codedom a mechanism to 
    // protect themselves against certain types of code injection attacks (using identifier and type names). 
    // You can pass in any node in the tree that is a subclass of CodeObject.
    internal class CodeValidator
    {
        internal void ValidateIdentifiers(CodeObject e) {
            if (e is CodeCompileUnit) {
                ValidateCodeCompileUnit((CodeCompileUnit)e);
            } 
            else if (e is CodeComment) {
                ValidateComment((CodeComment)e);
            } 
            else if (e is CodeExpression) {
                ValidateExpression((CodeExpression)e);
            }
            else if (e is CodeNamespace) {
                ValidateNamespace((CodeNamespace)e);
            }
            else if (e is CodeNamespaceImport) {
                ValidateNamespaceImport((CodeNamespaceImport)e);
            }
            else if (e is CodeStatement) {
                ValidateStatement((CodeStatement)e);
            }
            else if (e is CodeTypeMember) {
                ValidateTypeMember((CodeTypeMember)e);
            }
            else if (e is CodeTypeReference) {
                ValidateTypeReference((CodeTypeReference)e);
            }
            else {
                throw new ArgumentException(SR.GetString(SR.InvalidElementType, e.GetType().FullName), "e");
            }
        }

        private void ValidateTypeMember(CodeTypeMember e) {
            ValidateCommentStatements(e.Comments);
            if (e.LinePragma != null) ValidateLinePragmaStart(e.LinePragma);

            if (e is CodeMemberEvent) {
                ValidateEvent((CodeMemberEvent)e);
            } 
            else if (e is CodeMemberField) {
                ValidateField((CodeMemberField)e);
            } 
            else if (e is CodeMemberMethod) {
                ValidateMemberMethod((CodeMemberMethod)e);
            } 
            else if (e is CodeMemberProperty) {
                ValidateProperty((CodeMemberProperty)e);
            } 
            else if (e is CodeSnippetTypeMember) {
                ValidateSnippetMember((CodeSnippetTypeMember)e);
            } 
            else if (e is CodeTypeDeclaration) {
                ValidateTypeDeclaration((CodeTypeDeclaration)e);
            } 
            else {
                throw new ArgumentException(SR.GetString(SR.InvalidElementType, e.GetType().FullName), "e");
            }
        }

        private void ValidateCodeCompileUnit(CodeCompileUnit e) {
            if (e is CodeSnippetCompileUnit) {
                ValidateSnippetCompileUnit((CodeSnippetCompileUnit) e);
            } else {
                ValidateCompileUnitStart(e);
                ValidateNamespaces(e);
                ValidateCompileUnitEnd(e);
            }
        }

        private void ValidateSnippetCompileUnit(CodeSnippetCompileUnit e) {
            if (e.LinePragma != null) ValidateLinePragmaStart(e.LinePragma);
        }

        private void ValidateCompileUnitStart(CodeCompileUnit e) {
          if (e.AssemblyCustomAttributes.Count > 0) {
            ValidateAttributes(e.AssemblyCustomAttributes);
          }
        }

        private void ValidateCompileUnitEnd(CodeCompileUnit e) {
        }

        private void ValidateNamespaces(CodeCompileUnit e) {
            foreach (CodeNamespace n in e.Namespaces) {
                ValidateNamespace(n);
            }
        }

        private void ValidateNamespace(CodeNamespace e) {
            ValidateCommentStatements(e.Comments);
            ValidateNamespaceStart(e);
            ValidateNamespaceImports(e);
            ValidateTypes(e);
        }


        private void ValidateNamespaceStart(CodeNamespace e) {
            if (e.Name != null && e.Name.Length > 0) {
                ValidateTypeName(e,"Name",e.Name);
            }
        }

        private void ValidateNamespaceImports(CodeNamespace e) {
            IEnumerator en = e.Imports.GetEnumerator();
            while (en.MoveNext()) {
                CodeNamespaceImport imp = (CodeNamespaceImport)en.Current;
                if (imp.LinePragma != null) ValidateLinePragmaStart(imp.LinePragma);
                ValidateNamespaceImport(imp);
            }
        }

        private void ValidateNamespaceImport(CodeNamespaceImport e) {
            ValidateTypeName(e,"Namespace",e.Namespace);
        }

        private void ValidateAttributes(CodeAttributeDeclarationCollection attributes) {
            if (attributes.Count == 0) return;
            IEnumerator en = attributes.GetEnumerator();
            while (en.MoveNext()) {
                CodeAttributeDeclaration current = (CodeAttributeDeclaration)en.Current;
                ValidateTypeName(current,"Name",current.Name);
                foreach (CodeAttributeArgument arg in current.Arguments) {
                  ValidateAttributeArgument(arg);
                }
            }
        }

        private void ValidateAttributeArgument(CodeAttributeArgument arg) {
            if (arg.Name != null && arg.Name.Length > 0) {
                ValidateIdentifier(arg,"Name",arg.Name);
            }
            ValidateExpression(arg.Value);
        }

        private void ValidateTypes(CodeNamespace e) {
            foreach (CodeTypeDeclaration type in e.Types) {
                ValidateTypeDeclaration(type);
            }
        }

        private void ValidateTypeDeclaration(CodeTypeDeclaration e) { 
            // This function can be called recursively and will modify the global variable currentClass
            // We will save currentClass to a local, modify it to do whatever we want and restore it back when we exit so that it is re-entrant.
            CodeTypeDeclaration savedClass = currentClass;
            currentClass = e;

            ValidateTypeStart(e);
            ValidateTypeMembers(e); // Recursive call can come from here.

            currentClass = savedClass;
        }

        private void ValidateTypeMembers(CodeTypeDeclaration e) {
            foreach (CodeTypeMember currentMember in e.Members) {
		        ValidateTypeMember(currentMember);
	        }
       }


        private void ValidateField(CodeMemberField e) {
            if (IsCurrentDelegate || IsCurrentInterface) return;

            if (e.CustomAttributes.Count > 0) {
                ValidateAttributes(e.CustomAttributes);
            }

            ValidateIdentifier(e,"Name",e.Name);
            if (!IsCurrentEnum) {
                ValidateTypeReference(e.Type);
            }   

            if (e.InitExpression != null) {
                ValidateExpression(e.InitExpression);
            }
        }

        private void ValidateConstructor(CodeConstructor e) {
            if (!(IsCurrentClass || IsCurrentStruct)) return;

            if (e.CustomAttributes.Count > 0) {
                ValidateAttributes(e.CustomAttributes);
            }

            ValidateParameters(e.Parameters);

            CodeExpressionCollection baseArgs = e.BaseConstructorArgs;
            CodeExpressionCollection thisArgs = e.ChainedConstructorArgs;

            if (baseArgs.Count > 0) {
                ValidateExpressionList(baseArgs);
            }

            if (thisArgs.Count > 0) {
                ValidateExpressionList(thisArgs);
            }

            ValidateStatements(e.Statements);
        }

        private void ValidateProperty(CodeMemberProperty e) {
            if (!(IsCurrentClass || IsCurrentStruct || IsCurrentInterface)) return;

            if (e.CustomAttributes.Count > 0) {
                ValidateAttributes(e.CustomAttributes);
            }

            ValidateTypeReference(e.Type);

            if (e.PrivateImplementationType != null && !IsCurrentInterface) {
                ValidateTypeReference(e.PrivateImplementationType);
            }

            if (e.Parameters.Count > 0 && String.Compare(e.Name, "Item", true, CultureInfo.InvariantCulture) == 0) {
                ValidateParameters(e.Parameters);
            }
            else {
                ValidateIdentifier(e,"Name",e.Name);
            }

            if (e.HasGet) {
                if (!(IsCurrentInterface || (e.Attributes & MemberAttributes.ScopeMask) == MemberAttributes.Abstract)) {
                    ValidateStatements(e.GetStatements);
                }
            }

            if (e.HasSet) {
                if (!(IsCurrentInterface || (e.Attributes & MemberAttributes.ScopeMask) == MemberAttributes.Abstract)) {
                    ValidateStatements(e.SetStatements);
                }
            }
        }

        private void ValidateMemberMethod(CodeMemberMethod e) {
           ValidateCommentStatements(e.Comments);
           if (e.LinePragma != null) ValidateLinePragmaStart(e.LinePragma);
           
           if (e is CodeEntryPointMethod) {
               ValidateStatements(((CodeEntryPointMethod)e).Statements);
           } 
           else if (e is CodeConstructor) {
               ValidateConstructor((CodeConstructor)e);
           }
           else if (e is CodeTypeConstructor) {
              ValidateTypeConstructor((CodeTypeConstructor)e);
           }
           else  {
               ValidateMethod(e);
           }
        }

        private void ValidateTypeConstructor(CodeTypeConstructor e) {
            if (!(IsCurrentClass || IsCurrentStruct)) return;
            ValidateStatements(e.Statements);
        }

        private void ValidateMethod(CodeMemberMethod e) {
            if (!(IsCurrentClass || IsCurrentStruct || IsCurrentInterface)) return;

            if (e.CustomAttributes.Count > 0) {
                ValidateAttributes(e.CustomAttributes);
            }
            if (e.ReturnTypeCustomAttributes.Count > 0) {
                ValidateAttributes(e.ReturnTypeCustomAttributes);
            }

            ValidateTypeReference(e.ReturnType);
            if (e.PrivateImplementationType != null) {
                ValidateTypeReference(e.PrivateImplementationType);
            }

            ValidateIdentifier(e,"Name",e.Name);
            ValidateParameters(e.Parameters);
        
            if (!IsCurrentInterface 
                && (e.Attributes & MemberAttributes.ScopeMask) != MemberAttributes.Abstract) {
                ValidateStatements(e.Statements);
            }
        }

        private void ValidateSnippetMember(CodeSnippetTypeMember e) {
        }

        private void ValidateTypeStart(CodeTypeDeclaration e) {
            ValidateCommentStatements(e.Comments);
            if (e.CustomAttributes.Count > 0) {
                ValidateAttributes(e.CustomAttributes);
            }

            ValidateIdentifier(e,"Name",e.Name);
            if (IsCurrentDelegate) {
                CodeTypeDelegate del = (CodeTypeDelegate)e;
                ValidateTypeReference(del.ReturnType);
                ValidateParameters(del.Parameters);
            } else {
                foreach (CodeTypeReference typeRef in e.BaseTypes) {
                    ValidateTypeReference(typeRef);
                }
            }
        }

        private void ValidateCommentStatements(CodeCommentStatementCollection e) {
            foreach (CodeCommentStatement comment in e) {
                 ValidateCommentStatement(comment);
            }
        }

        private void ValidateCommentStatement(CodeCommentStatement e) {
          ValidateComment(e.Comment);
        }

        private void ValidateComment(CodeComment e) {
        }

        private void ValidateStatement(CodeStatement e) {
            if (e is CodeCommentStatement) {
                ValidateCommentStatement((CodeCommentStatement)e);
            }
            else if (e is CodeMethodReturnStatement) {
                ValidateMethodReturnStatement((CodeMethodReturnStatement)e);
            }
            else if (e is CodeConditionStatement) {
                ValidateConditionStatement((CodeConditionStatement)e);
            }
            else if (e is CodeTryCatchFinallyStatement) {
                ValidateTryCatchFinallyStatement((CodeTryCatchFinallyStatement)e);
            }
            else if (e is CodeAssignStatement) {
                ValidateAssignStatement((CodeAssignStatement)e);
            }
            else if (e is CodeExpressionStatement) {
                ValidateExpressionStatement((CodeExpressionStatement)e);
            }
            else if (e is CodeIterationStatement) {
                ValidateIterationStatement((CodeIterationStatement)e);
            }
            else if (e is CodeThrowExceptionStatement) {
                ValidateThrowExceptionStatement((CodeThrowExceptionStatement)e);
            }
            else if (e is CodeSnippetStatement) {
                ValidateSnippetStatement((CodeSnippetStatement)e);
            }
            else if (e is CodeVariableDeclarationStatement) {
                ValidateVariableDeclarationStatement((CodeVariableDeclarationStatement)e);
            }
            else if (e is CodeAttachEventStatement) {
                ValidateAttachEventStatement((CodeAttachEventStatement)e);
            }
            else if (e is CodeRemoveEventStatement) {
                ValidateRemoveEventStatement((CodeRemoveEventStatement)e);
            }
            else if (e is CodeGotoStatement) {
                ValidateGotoStatement((CodeGotoStatement)e);
            }
            else if (e is CodeLabeledStatement) {
                ValidateLabeledStatement((CodeLabeledStatement)e);
            }
            else {
                throw new ArgumentException(SR.GetString(SR.InvalidElementType, e.GetType().FullName), "e");
            }
        }

        private void ValidateStatements(CodeStatementCollection stms) {
            IEnumerator en = stms.GetEnumerator();
            while (en.MoveNext()) {
                ValidateStatement((CodeStatement)en.Current);
            }
        }

        private void ValidateExpressionStatement(CodeExpressionStatement e) {
            ValidateExpression(e.Expression);
        }

        private void ValidateIterationStatement(CodeIterationStatement e) {
            ValidateStatement(e.InitStatement);
            ValidateExpression(e.TestExpression);
            ValidateStatement(e.IncrementStatement);
            ValidateStatements(e.Statements);
        }
        
        private void ValidateThrowExceptionStatement(CodeThrowExceptionStatement e) {
            if (e.ToThrow != null) {
                ValidateExpression(e.ToThrow);
            }
        }

        private void ValidateMethodReturnStatement(CodeMethodReturnStatement e) {
            if (e.Expression != null) {
                ValidateExpression(e.Expression);
            }
        }

        private void ValidateConditionStatement(CodeConditionStatement e) {
            ValidateExpression(e.Condition);
            ValidateStatements(e.TrueStatements);

            CodeStatementCollection falseStatemetns = e.FalseStatements;
            if (falseStatemetns.Count > 0) {
                ValidateStatements(e.FalseStatements);
            }
        }

        private void ValidateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e) {
            ValidateStatements(e.TryStatements);
            CodeCatchClauseCollection catches = e.CatchClauses;
            if (catches.Count > 0) {
                IEnumerator en = catches.GetEnumerator();
                while (en.MoveNext()) {
                    CodeCatchClause current = (CodeCatchClause)en.Current;
                    ValidateTypeReference(current.CatchExceptionType);
                    ValidateIdentifier(current,"LocalName",current.LocalName);
                    ValidateStatements(current.Statements);
                }
            }

            CodeStatementCollection finallyStatements = e.FinallyStatements;
            if (finallyStatements.Count > 0) {
                ValidateStatements(finallyStatements);
            }
        }

        private void ValidateAssignStatement(CodeAssignStatement e) {
            ValidateExpression(e.Left);
            ValidateExpression(e.Right);
        }

        private void ValidateAttachEventStatement(CodeAttachEventStatement e) {
            ValidateEventReferenceExpression(e.Event);
            ValidateExpression(e.Listener);
        }

        private void ValidateRemoveEventStatement(CodeRemoveEventStatement e) {
            ValidateEventReferenceExpression(e.Event);
            ValidateExpression(e.Listener);
        }

        private void ValidateGotoStatement(CodeGotoStatement e) {
            ValidateIdentifier(e,"Label",e.Label);
        }

        private void ValidateLabeledStatement(CodeLabeledStatement e) {
            ValidateIdentifier(e,"Label",e.Label);
            if (e.Statement != null) {
                ValidateStatement(e.Statement);
            }
        }

        private void ValidateVariableDeclarationStatement(CodeVariableDeclarationStatement e) {
            ValidateTypeReference(e.Type);
            ValidateIdentifier(e,"Name",e.Name);
            if (e.InitExpression != null) {
                ValidateExpression(e.InitExpression);
            }
        }

        private void ValidateLinePragmaStart(CodeLinePragma e) {
        }

        private void ValidateEvent(CodeMemberEvent e) {
            if (IsCurrentDelegate || IsCurrentEnum) return;

            if (e.CustomAttributes.Count > 0) {
                ValidateAttributes(e.CustomAttributes);
            }
            if (e.PrivateImplementationType != null) {
                ValidateTypeReference(e.Type);
                ValidateIdentifier(e,"Name",e.Name);
            }
        }

        private void ValidateParameters(CodeParameterDeclarationExpressionCollection parameters) {
            IEnumerator en = parameters.GetEnumerator();
            while (en.MoveNext()) {
                CodeParameterDeclarationExpression current = (CodeParameterDeclarationExpression)en.Current;
                ValidateParameterDeclarationExpression(current);
            }
        }

        private void ValidateSnippetStatement(CodeSnippetStatement e) {
        }

        private void ValidateExpressionList(CodeExpressionCollection expressions) {
            IEnumerator en = expressions.GetEnumerator();
            while (en.MoveNext()) {
                ValidateExpression((CodeExpression)en.Current);
            }
        }

        private void ValidateTypeReference(CodeTypeReference e) {
            String baseType = e.BaseType;
            ValidateTypeName(e,"BaseType",baseType);
        }

        private void ValidateTypeName(Object e, String propertyName, String typeName) {
            if (!CodeGenerator.IsValidLanguageIndependentTypeName(typeName)) {
               String message = SR.GetString(SR.InvalidTypeName, typeName, propertyName, e.GetType().FullName);
               throw new ArgumentException(message, "typeName");
            }
        }

        private void ValidateIdentifier(Object e, String propertyName, String identifier) {
            if (!CodeGenerator.IsValidLanguageIndependentIdentifier(identifier)) {
                String message = SR.GetString(SR.InvalidLanguageIdentifier, identifier, propertyName, e.GetType().FullName);
                throw new ArgumentException(message , "identifier");
            }
        }

        private void ValidateExpression(CodeExpression e) {
            if (e is CodeArrayCreateExpression) {
                ValidateArrayCreateExpression((CodeArrayCreateExpression)e);
            }
            else if (e is CodeBaseReferenceExpression) {
                ValidateBaseReferenceExpression((CodeBaseReferenceExpression)e);
            }
            else if (e is CodeBinaryOperatorExpression) {
                ValidateBinaryOperatorExpression((CodeBinaryOperatorExpression)e);
            }
            else if (e is CodeCastExpression) {
                ValidateCastExpression((CodeCastExpression)e);
            }
            else if (e is CodeDelegateCreateExpression) {
                ValidateDelegateCreateExpression((CodeDelegateCreateExpression)e);
            }
            else if (e is CodeFieldReferenceExpression) {
                ValidateFieldReferenceExpression((CodeFieldReferenceExpression)e);
            }
            else if (e is CodeArgumentReferenceExpression) {
                ValidateArgumentReferenceExpression((CodeArgumentReferenceExpression)e);
            }
            else if (e is CodeVariableReferenceExpression) {
                ValidateVariableReferenceExpression((CodeVariableReferenceExpression)e);
            }
            else if (e is CodeIndexerExpression) {
                ValidateIndexerExpression((CodeIndexerExpression)e);
            }
            else if (e is CodeArrayIndexerExpression) {
                ValidateArrayIndexerExpression((CodeArrayIndexerExpression)e);
            }
            else if (e is CodeSnippetExpression) {
                ValidateSnippetExpression((CodeSnippetExpression)e);
            }
            else if (e is CodeMethodInvokeExpression) {
                ValidateMethodInvokeExpression((CodeMethodInvokeExpression)e);
            }
            else if (e is CodeMethodReferenceExpression) {
                ValidateMethodReferenceExpression((CodeMethodReferenceExpression)e);
            }
            else if (e is CodeEventReferenceExpression) {
                ValidateEventReferenceExpression((CodeEventReferenceExpression)e);
            }
            else if (e is CodeDelegateInvokeExpression) {
                ValidateDelegateInvokeExpression((CodeDelegateInvokeExpression)e);
            }
            else if (e is CodeObjectCreateExpression) {
                ValidateObjectCreateExpression((CodeObjectCreateExpression)e);
            }
            else if (e is CodeParameterDeclarationExpression) {
                ValidateParameterDeclarationExpression((CodeParameterDeclarationExpression)e);
            }
            else if (e is CodeDirectionExpression) {
                ValidateDirectionExpression((CodeDirectionExpression)e);
            }
            else if (e is CodePrimitiveExpression) {
                ValidatePrimitiveExpression((CodePrimitiveExpression)e);
            }
            else if (e is CodePropertyReferenceExpression) {
                ValidatePropertyReferenceExpression((CodePropertyReferenceExpression)e);
            }
            else if (e is CodePropertySetValueReferenceExpression) {
                ValidatePropertySetValueReferenceExpression((CodePropertySetValueReferenceExpression)e);
            }
            else if (e is CodeThisReferenceExpression) {
                ValidateThisReferenceExpression((CodeThisReferenceExpression)e);
            }
            else if (e is CodeTypeReferenceExpression) {
                ValidateTypeReference(((CodeTypeReferenceExpression)e).Type);
            }
            else if (e is CodeTypeOfExpression) {
                ValidateTypeOfExpression((CodeTypeOfExpression)e);
            }
            else {
                if (e == null) {
                    throw new ArgumentNullException("e");
                }
                else {
                    throw new ArgumentException(SR.GetString(SR.InvalidElementType, e.GetType().FullName), "e");
                }
            }
        }

        private void ValidateArrayCreateExpression(CodeArrayCreateExpression e) {
            ValidateTypeReference(e.CreateType);
            CodeExpressionCollection init = e.Initializers;
            if (init.Count > 0) {
                ValidateExpressionList(init);
            }
            else {
                if (e.SizeExpression != null) {
                    ValidateExpression(e.SizeExpression);
                }
            }
        }

        private void ValidateBaseReferenceExpression(CodeBaseReferenceExpression e) { // Nothing to validate
        }

        private void ValidateBinaryOperatorExpression(CodeBinaryOperatorExpression e) {
            ValidateExpression(e.Left);
            ValidateExpression(e.Right);
        }

        private void ValidateCastExpression(CodeCastExpression e) {
            ValidateTypeReference(e.TargetType);
            ValidateExpression(e.Expression);
        }

        private void ValidateDelegateCreateExpression(CodeDelegateCreateExpression e) {
            ValidateTypeReference(e.DelegateType);
            ValidateExpression(e.TargetObject);
            ValidateIdentifier(e,"MethodName",e.MethodName);
        }

        private void ValidateFieldReferenceExpression(CodeFieldReferenceExpression e) {
            if (e.TargetObject != null) {
                ValidateExpression(e.TargetObject);
            }
            ValidateIdentifier(e,"FieldName",e.FieldName);
        }

        private void ValidateArgumentReferenceExpression(CodeArgumentReferenceExpression e) {
            ValidateIdentifier(e,"ParameterName",e.ParameterName);
        }

        private void ValidateVariableReferenceExpression(CodeVariableReferenceExpression e) {
            ValidateIdentifier(e,"VariableName",e.VariableName);
        }

        private void ValidateIndexerExpression(CodeIndexerExpression e) {
            ValidateExpression(e.TargetObject);
            foreach(CodeExpression exp in e.Indices) {            
                ValidateExpression(exp);
            }
        }

        private void ValidateArrayIndexerExpression(CodeArrayIndexerExpression e) {
            ValidateExpression(e.TargetObject);
            foreach(CodeExpression exp in e.Indices) {            
                ValidateExpression(exp);
            }
        }

        private void ValidateSnippetExpression(CodeSnippetExpression e) {
        }

        private void ValidateMethodInvokeExpression(CodeMethodInvokeExpression e) {
            ValidateMethodReferenceExpression(e.Method);
            ValidateExpressionList(e.Parameters);
        }

        private void ValidateMethodReferenceExpression(CodeMethodReferenceExpression e) {
            if (e.TargetObject != null) {
                ValidateExpression(e.TargetObject);
            }
            ValidateIdentifier(e,"MethodName",e.MethodName);
        }

        private void ValidateEventReferenceExpression(CodeEventReferenceExpression e) {
           if (e.TargetObject != null) {
                ValidateExpression(e.TargetObject);
           }
           ValidateIdentifier(e,"EventName",e.EventName);
        }

        private void ValidateDelegateInvokeExpression(CodeDelegateInvokeExpression e) {
           if (e.TargetObject != null) {
                    ValidateExpression(e.TargetObject);
           }
           ValidateExpressionList(e.Parameters);
        }

        private void ValidateObjectCreateExpression(CodeObjectCreateExpression e) {
            ValidateTypeReference(e.CreateType);
            ValidateExpressionList(e.Parameters);
        }

        private void ValidateParameterDeclarationExpression(CodeParameterDeclarationExpression e) {
           if (e.CustomAttributes.Count > 0) {
                ValidateAttributes(e.CustomAttributes);
           }

           ValidateTypeReference(e.Type);
           ValidateIdentifier(e,"Name",e.Name);
        }

        private void ValidateDirectionExpression(CodeDirectionExpression e) {
           ValidateExpression(e.Expression);
        }

        private void ValidatePrimitiveExpression(CodePrimitiveExpression e) {
        }

        private void ValidatePropertyReferenceExpression(CodePropertyReferenceExpression e) {
           if (e.TargetObject != null) {
              ValidateExpression(e.TargetObject);
           }
           ValidateIdentifier(e,"PropertyName",e.PropertyName);
        }

        private void ValidatePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e) { // Do nothing
        }

        private void ValidateThisReferenceExpression(CodeThisReferenceExpression e) {  // Do nothing
        }

        private void ValidateTypeOfExpression(CodeTypeOfExpression e) {
            ValidateTypeReference(e.Type);
        }

        private bool IsCurrentInterface {
            get {
                if (currentClass != null && !(currentClass is CodeTypeDelegate)) {
                    return currentClass.IsInterface;
                }
                return false;
            }
        }

        private bool IsCurrentClass {
            get {
                if (currentClass != null && !(currentClass is CodeTypeDelegate)) {
                    return currentClass.IsClass;
                }
                return false;
            }
        }

        private bool IsCurrentStruct {
            get {
                if (currentClass != null && !(currentClass is CodeTypeDelegate)) {
                    return currentClass.IsStruct;
                }
                return false;
            }
        }

        private bool IsCurrentEnum {
            get {
                if (currentClass != null && !(currentClass is CodeTypeDelegate)) {
                    return currentClass.IsEnum;
                }
                return false;
            }
        }

        private bool IsCurrentDelegate {
            get {
                if (currentClass != null && currentClass is CodeTypeDelegate) {
                    return true;
                }
                return false;
            }
        }

        private CodeTypeDeclaration currentClass;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\compiler\codegenerator.cs ===
//------------------------------------------------------------------------------
// <copyright file="CodeGenerator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom.Compiler {
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.IO;
    using System.Collections;
    using System.Reflection;
    using System.Globalization;
    using System.CodeDom;
    using System.Security.Permissions;

    /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator"]/*' />
    /// <devdoc>
    ///    <para>Provides a base class for code generators.</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public abstract class CodeGenerator : ICodeGenerator {
        private const int ParameterMultilineThreshold = 15;        
        private IndentedTextWriter output;
        private CodeGeneratorOptions options;

        private CodeTypeDeclaration currentClass;
        private CodeTypeMember currentMember;

        private bool inNestedBinary = false;

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.CurrentTypeName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the current class name.
        ///    </para>
        /// </devdoc>
        protected string CurrentTypeName {
            get {
                if (currentClass != null) {
                    return currentClass.Name;
                }
                return "<% unknown %>";
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.CurrentMember"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the current member of the class.
        ///    </para>
        /// </devdoc>
        protected CodeTypeMember CurrentMember {
            get {
                return currentMember;
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.CurrentMemberName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the current member name.
        ///    </para>
        /// </devdoc>
        protected string CurrentMemberName {
            get {
                if (currentMember != null) {
                    return currentMember.Name;
                }
                return "<% unknown %>";
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.IsCurrentInterface"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the current object being
        ///       generated is an interface.
        ///    </para>
        /// </devdoc>
        protected bool IsCurrentInterface {
            get {
                if (currentClass != null && !(currentClass is CodeTypeDelegate)) {
                    return currentClass.IsInterface;
                }
                return false;
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.IsCurrentClass"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the current object being generated
        ///       is a class.
        ///    </para>
        /// </devdoc>
        protected bool IsCurrentClass {
            get {
                if (currentClass != null && !(currentClass is CodeTypeDelegate)) {
                    return currentClass.IsClass;
                }
                return false;
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.IsCurrentStruct"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the current object being generated
        ///       is a struct.
        ///    </para>
        /// </devdoc>
        protected bool IsCurrentStruct {
            get {
                if (currentClass != null && !(currentClass is CodeTypeDelegate)) {
                    return currentClass.IsStruct;
                }
                return false;
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.IsCurrentEnum"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the current object being generated
        ///       is an enumeration.
        ///    </para>
        /// </devdoc>
        protected bool IsCurrentEnum {
            get {
                if (currentClass != null && !(currentClass is CodeTypeDelegate)) {
                    return currentClass.IsEnum;
                }
                return false;
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.IsCurrentDelegate"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value indicating whether the current object being generated
        ///       is a delegate.
        ///    </para>
        /// </devdoc>
        protected bool IsCurrentDelegate {
            get {
                if (currentClass != null && currentClass is CodeTypeDelegate) {
                    return true;
                }
                return false;
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.Indent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the amount of spaces to indent.
        ///    </para>
        /// </devdoc>
        protected int Indent {
            get {
                return output.Indent;
            }
            set {
                output.Indent = value;
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.NullToken"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the token that represents <see langword='null'/>.
        ///    </para>
        /// </devdoc>
        protected abstract string NullToken { get; }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.Output"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the System.IO.TextWriter
        ///       to use for output.
        ///    </para>
        /// </devdoc>
        protected TextWriter Output {
            get {
                return output;
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.Options"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected CodeGeneratorOptions Options {
            get {
                return options;
            }
        }

        private void GenerateType(CodeTypeDeclaration e) {
            currentClass = e;

            GenerateCommentStatements(e.Comments);

            GenerateTypeStart(e);

            GenerateFields(e);

            GenerateSnippetMembers(e);

            GenerateTypeConstructors(e);

            GenerateConstructors(e);

            GenerateProperties(e);

            GenerateEvents(e);

            GenerateMethods(e);

            // Nested types clobber the current class, so reset it.
            GenerateNestedTypes(e);
            currentClass = e;

            GenerateTypeEnd(e);
        }

        private void GenerateTypeConstructors(CodeTypeDeclaration e) {
            IEnumerator en = e.Members.GetEnumerator();
            while (en.MoveNext()) {
                if (en.Current is CodeTypeConstructor) {
                    currentMember = (CodeTypeMember)en.Current;

                    if (options.BlankLinesBetweenMembers) {
                        Output.WriteLine();
                    }
                    GenerateCommentStatements(currentMember.Comments);
                    CodeTypeConstructor imp = (CodeTypeConstructor)en.Current;
                    if (imp.LinePragma != null) GenerateLinePragmaStart(imp.LinePragma);
                    GenerateTypeConstructor(imp);
                    if (imp.LinePragma != null) GenerateLinePragmaEnd(imp.LinePragma);
                }
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateNamespaces"]/*' />
        /// <devdoc>
        ///    <para> Generates code for the namepsaces in the specifield CodeDom compile unit.
        ///     </para>
        /// </devdoc>
        protected void GenerateNamespaces(CodeCompileUnit e) {
            foreach (CodeNamespace n in e.Namespaces) {
                ((ICodeGenerator)this).GenerateCodeFromNamespace(n, output.InnerWriter, options);
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateTypes"]/*' />
        /// <devdoc>
        ///    <para> Generates code for the specified CodeDom namespace representation and the classes it
        ///       contains.</para>
        /// </devdoc>
        protected void GenerateTypes(CodeNamespace e) {
            foreach (CodeTypeDeclaration c in e.Types) {
                if (options.BlankLinesBetweenMembers) {
                            Output.WriteLine();
                }
                ((ICodeGenerator)this).GenerateCodeFromType(c, output.InnerWriter, options);
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.ICodeGenerator.Supports"]/*' />
        /// <internalonly/>
        bool ICodeGenerator.Supports(GeneratorSupport support) {
            return this.Supports(support);
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.ICodeGenerator.GenerateCodeFromType"]/*' />
        /// <internalonly/>
        void ICodeGenerator.GenerateCodeFromType(CodeTypeDeclaration e, TextWriter w, CodeGeneratorOptions o) {
            bool setLocal = false;
            if (output != null && w != output.InnerWriter) {
                throw new InvalidOperationException(SR.GetString(SR.CodeGenOutputWriter));
            }
            if (output == null) {
                setLocal = true;
                options = (o == null) ? new CodeGeneratorOptions() : o;
                output = new IndentedTextWriter(w, options.IndentString);
            }

            try {
                GenerateType(e);
            }
            finally {
                if (setLocal) {
                    output = null;
                    options = null;
                }
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.ICodeGenerator.GenerateCodeFromExpression"]/*' />
        /// <internalonly/>
        void ICodeGenerator.GenerateCodeFromExpression(CodeExpression e, TextWriter w, CodeGeneratorOptions o) {
            bool setLocal = false;
            if (output != null && w != output.InnerWriter) {
                throw new InvalidOperationException(SR.GetString(SR.CodeGenOutputWriter));
            }
            if (output == null) {
                setLocal = true;
                options = (o == null) ? new CodeGeneratorOptions() : o;
                output = new IndentedTextWriter(w, options.IndentString);
            }

            try {
                GenerateExpression(e);
            }
            finally {
                if (setLocal) {
                    output = null;
                    options = null;
                }
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.ICodeGenerator.GenerateCodeFromCompileUnit"]/*' />
        /// <internalonly/>
        void ICodeGenerator.GenerateCodeFromCompileUnit(CodeCompileUnit e, TextWriter w, CodeGeneratorOptions o) {
            bool setLocal = false;
            if (output != null && w != output.InnerWriter) {
                throw new InvalidOperationException(SR.GetString(SR.CodeGenOutputWriter));
            }
            if (output == null) {
                setLocal = true;
                options = (o == null) ? new CodeGeneratorOptions() : o;
                output = new IndentedTextWriter(w, options.IndentString);
            }

            try {
                if (e is CodeSnippetCompileUnit) {
                    GenerateSnippetCompileUnit((CodeSnippetCompileUnit) e);
                }
                else {
                    GenerateCompileUnit(e);
                }
            }
            finally {
                if (setLocal) {
                    output = null;
                    options = null;
                }
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.ICodeGenerator.GenerateCodeFromNamespace"]/*' />
        /// <internalonly/>
        void ICodeGenerator.GenerateCodeFromNamespace(CodeNamespace e, TextWriter w, CodeGeneratorOptions o) {
            bool setLocal = false;
            if (output != null && w != output.InnerWriter) {
                throw new InvalidOperationException(SR.GetString(SR.CodeGenOutputWriter));
            }
            if (output == null) {
                setLocal = true;
                options = (o == null) ? new CodeGeneratorOptions() : o;
                output = new IndentedTextWriter(w, options.IndentString);
            }

            try {
                GenerateNamespace(e);
            }
            finally {
                if (setLocal) {
                    output = null;
                    options = null;
                }
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.ICodeGenerator.GenerateCodeFromStatement"]/*' />
        /// <internalonly/>
        void ICodeGenerator.GenerateCodeFromStatement(CodeStatement e, TextWriter w, CodeGeneratorOptions o) {
            bool setLocal = false;
            if (output != null && w != output.InnerWriter) {
                throw new InvalidOperationException(SR.GetString(SR.CodeGenOutputWriter));
            }
            if (output == null) {
                setLocal = true;
                options = (o == null) ? new CodeGeneratorOptions() : o;
                output = new IndentedTextWriter(w, options.IndentString);
            }

            try {
                GenerateStatement(e);
            }
            finally {
                if (setLocal) {
                    output = null;
                    options = null;
                }
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.ICodeGenerator.IsValidIdentifier"]/*' />
        /// <internalonly/>
        bool ICodeGenerator.IsValidIdentifier(string value) {
            return this.IsValidIdentifier(value);
        }
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.ICodeGenerator.ValidateIdentifier"]/*' />
        /// <internalonly/>
        void ICodeGenerator.ValidateIdentifier(string value) {
            this.ValidateIdentifier(value);
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.ICodeGenerator.CreateEscapedIdentifier"]/*' />
        /// <internalonly/>
        string ICodeGenerator.CreateEscapedIdentifier(string value) {
            return this.CreateEscapedIdentifier(value);
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.ICodeGenerator.CreateValidIdentifier"]/*' />
        /// <internalonly/>
        string ICodeGenerator.CreateValidIdentifier(string value) {
            return this.CreateValidIdentifier(value);
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.ICodeGenerator.GetTypeOutput"]/*' />
        /// <internalonly/>
        string ICodeGenerator.GetTypeOutput(CodeTypeReference type) {
            return this.GetTypeOutput(type);
        }

        private void GenerateConstructors(CodeTypeDeclaration e) {
            IEnumerator en = e.Members.GetEnumerator();
            while (en.MoveNext()) {
                if (en.Current is CodeConstructor) {
                    currentMember = (CodeTypeMember)en.Current;

                    if (options.BlankLinesBetweenMembers) {
                        Output.WriteLine();
                    }
                    GenerateCommentStatements(currentMember.Comments);
                    CodeConstructor imp = (CodeConstructor)en.Current;
                    if (imp.LinePragma != null) GenerateLinePragmaStart(imp.LinePragma);
                    GenerateConstructor(imp, e);
                    if (imp.LinePragma != null) GenerateLinePragmaEnd(imp.LinePragma);
                }
            }
        }

        private void GenerateEvents(CodeTypeDeclaration e) {
            IEnumerator en = e.Members.GetEnumerator();
            while (en.MoveNext()) {
                if (en.Current is CodeMemberEvent) {
                    currentMember = (CodeTypeMember)en.Current;

                    if (options.BlankLinesBetweenMembers) {
                        Output.WriteLine();
                    }
                    GenerateCommentStatements(currentMember.Comments);
                    CodeMemberEvent imp = (CodeMemberEvent)en.Current;
                    if (imp.LinePragma != null) GenerateLinePragmaStart(imp.LinePragma);
                    GenerateEvent(imp, e);
                    if (imp.LinePragma != null) GenerateLinePragmaEnd(imp.LinePragma);
                }
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateExpression"]/*' />
        /// <devdoc>
        ///    <para>Generates code for the specified CodeDom code expression representation.</para>
        /// </devdoc>
        protected void GenerateExpression(CodeExpression e) {
            if (e is CodeArrayCreateExpression) {
                GenerateArrayCreateExpression((CodeArrayCreateExpression)e);
            }
            else if (e is CodeBaseReferenceExpression) {
                GenerateBaseReferenceExpression((CodeBaseReferenceExpression)e);
            }
            else if (e is CodeBinaryOperatorExpression) {
                GenerateBinaryOperatorExpression((CodeBinaryOperatorExpression)e);
            }
            else if (e is CodeCastExpression) {
                GenerateCastExpression((CodeCastExpression)e);
            }
            else if (e is CodeDelegateCreateExpression) {
                GenerateDelegateCreateExpression((CodeDelegateCreateExpression)e);
            }
            else if (e is CodeFieldReferenceExpression) {
                GenerateFieldReferenceExpression((CodeFieldReferenceExpression)e);
            }
            else if (e is CodeArgumentReferenceExpression) {
                GenerateArgumentReferenceExpression((CodeArgumentReferenceExpression)e);
            }
            else if (e is CodeVariableReferenceExpression) {
                GenerateVariableReferenceExpression((CodeVariableReferenceExpression)e);
            }
            else if (e is CodeIndexerExpression) {
                GenerateIndexerExpression((CodeIndexerExpression)e);
            }
            else if (e is CodeArrayIndexerExpression) {
                GenerateArrayIndexerExpression((CodeArrayIndexerExpression)e);
            }
            else if (e is CodeSnippetExpression) {
                GenerateSnippetExpression((CodeSnippetExpression)e);
            }
            else if (e is CodeMethodInvokeExpression) {
                GenerateMethodInvokeExpression((CodeMethodInvokeExpression)e);
            }
            else if (e is CodeMethodReferenceExpression) {
                GenerateMethodReferenceExpression((CodeMethodReferenceExpression)e);
            }
            else if (e is CodeEventReferenceExpression) {
                GenerateEventReferenceExpression((CodeEventReferenceExpression)e);
            }
            else if (e is CodeDelegateInvokeExpression) {
                GenerateDelegateInvokeExpression((CodeDelegateInvokeExpression)e);
            }
            else if (e is CodeObjectCreateExpression) {
                GenerateObjectCreateExpression((CodeObjectCreateExpression)e);
            }
            else if (e is CodeParameterDeclarationExpression) {
                GenerateParameterDeclarationExpression((CodeParameterDeclarationExpression)e);
            }
            else if (e is CodeDirectionExpression) {
                GenerateDirectionExpression((CodeDirectionExpression)e);
            }
            else if (e is CodePrimitiveExpression) {
                GeneratePrimitiveExpression((CodePrimitiveExpression)e);
            }
            else if (e is CodePropertyReferenceExpression) {
                GeneratePropertyReferenceExpression((CodePropertyReferenceExpression)e);
            }
            else if (e is CodePropertySetValueReferenceExpression) {
                GeneratePropertySetValueReferenceExpression((CodePropertySetValueReferenceExpression)e);
            }
            else if (e is CodeThisReferenceExpression) {
                GenerateThisReferenceExpression((CodeThisReferenceExpression)e);
            }
            else if (e is CodeTypeReferenceExpression) {
                GenerateTypeReferenceExpression((CodeTypeReferenceExpression)e);
            }
            else if (e is CodeTypeOfExpression) {
                GenerateTypeOfExpression((CodeTypeOfExpression)e);
            }
            else {
                if (e == null) {
                    throw new ArgumentNullException("e");
                }
                else {
                    throw new ArgumentException(SR.GetString(SR.InvalidElementType, e.GetType().FullName), "e");
                }
            }
        }

        private void GenerateFields(CodeTypeDeclaration e) {
            IEnumerator en = e.Members.GetEnumerator();
            while (en.MoveNext()) {
                if (en.Current is CodeMemberField) {
                    currentMember = (CodeTypeMember)en.Current;

                    if (options.BlankLinesBetweenMembers) {
                        Output.WriteLine();
                    }
                    GenerateCommentStatements(currentMember.Comments);
                    CodeMemberField imp = (CodeMemberField)en.Current;
                    if (imp.LinePragma != null) GenerateLinePragmaStart(imp.LinePragma);
                    GenerateField(imp);
                    if (imp.LinePragma != null) GenerateLinePragmaEnd(imp.LinePragma);
                }
            }
        }

        private void GenerateSnippetMembers(CodeTypeDeclaration e) {
            IEnumerator en = e.Members.GetEnumerator();
            while (en.MoveNext()) {
                if (en.Current is CodeSnippetTypeMember) {
                    currentMember = (CodeTypeMember)en.Current;

                    if (options.BlankLinesBetweenMembers) {
                        Output.WriteLine();
                    }
                    GenerateCommentStatements(currentMember.Comments);
                    CodeSnippetTypeMember imp = (CodeSnippetTypeMember)en.Current;
                    if (imp.LinePragma != null) GenerateLinePragmaStart(imp.LinePragma);
                    GenerateSnippetMember(imp);
                    if (imp.LinePragma != null) GenerateLinePragmaEnd(imp.LinePragma);

                }
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateSnippetCompileUnit"]/*' />
        /// <devdoc>
        ///    <para> Generates code for the specified snippet code block
        ///       </para>
        /// </devdoc>
        protected virtual void GenerateSnippetCompileUnit(CodeSnippetCompileUnit e) {
            if (e.LinePragma != null) GenerateLinePragmaStart(e.LinePragma);
            Output.WriteLine(e.Value);
            if (e.LinePragma != null) GenerateLinePragmaEnd(e.LinePragma);
        }

        private void GenerateMethods(CodeTypeDeclaration e) {
            IEnumerator en = e.Members.GetEnumerator();
            while (en.MoveNext()) {
                if (en.Current is CodeMemberMethod
                    && !(en.Current is CodeTypeConstructor)
                    && !(en.Current is CodeConstructor)) {
                    currentMember = (CodeTypeMember)en.Current;

                    if (options.BlankLinesBetweenMembers) {
                        Output.WriteLine();
                    }
                    GenerateCommentStatements(currentMember.Comments);
                    CodeMemberMethod imp = (CodeMemberMethod)en.Current;
                    if (imp.LinePragma != null) GenerateLinePragmaStart(imp.LinePragma);
                    if (en.Current is CodeEntryPointMethod) {
                        GenerateEntryPointMethod((CodeEntryPointMethod)en.Current, e);
                    } 
                    else {
                        GenerateMethod(imp, e);
                    }
                    if (imp.LinePragma != null) GenerateLinePragmaEnd(imp.LinePragma);
                }
            }
        }

        private void GenerateNestedTypes(CodeTypeDeclaration e) {
            IEnumerator en = e.Members.GetEnumerator();
            while (en.MoveNext()) {
                if (en.Current is CodeTypeDeclaration) {
                    if (options.BlankLinesBetweenMembers) {
                        Output.WriteLine();
                    }
                    CodeTypeDeclaration currentClass = (CodeTypeDeclaration)en.Current;
                    ((ICodeGenerator)this).GenerateCodeFromType(currentClass, output.InnerWriter, options);
                }
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateCompileUnit"]/*' />
        /// <devdoc>
        ///    <para> Generates code for the specified CodeDom
        ///       compile unit representation.</para>
        /// </devdoc>
        protected virtual void GenerateCompileUnit(CodeCompileUnit e) {
            GenerateCompileUnitStart(e);
            GenerateNamespaces(e);
            GenerateCompileUnitEnd(e);
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateNamespace"]/*' />
        /// <devdoc>
        ///    <para> Generates code for the specified CodeDom
        ///       namespace representation.</para>
        /// </devdoc>
        protected virtual void GenerateNamespace(CodeNamespace e) {
            GenerateCommentStatements(e.Comments);
            GenerateNamespaceStart(e);

            GenerateNamespaceImports(e);
            Output.WriteLine("");

            GenerateTypes(e);
            GenerateNamespaceEnd(e);
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateNamespaceImports"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based namespace import
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected void GenerateNamespaceImports(CodeNamespace e) {
            IEnumerator en = e.Imports.GetEnumerator();
            while (en.MoveNext()) {
                CodeNamespaceImport imp = (CodeNamespaceImport)en.Current;
                if (imp.LinePragma != null) GenerateLinePragmaStart(imp.LinePragma);
                GenerateNamespaceImport(imp);
                if (imp.LinePragma != null) GenerateLinePragmaEnd(imp.LinePragma);
            }
        }

        private void GenerateProperties(CodeTypeDeclaration e) {
            IEnumerator en = e.Members.GetEnumerator();
            while (en.MoveNext()) {
                if (en.Current is CodeMemberProperty) {
                    currentMember = (CodeTypeMember)en.Current;

                    if (options.BlankLinesBetweenMembers) {
                        Output.WriteLine();
                    }
                    GenerateCommentStatements(currentMember.Comments);
                    CodeMemberProperty imp = (CodeMemberProperty)en.Current;
                    if (imp.LinePragma != null) GenerateLinePragmaStart(imp.LinePragma);
                    GenerateProperty(imp, e);
                    if (imp.LinePragma != null) GenerateLinePragmaEnd(imp.LinePragma);
                }
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for
        ///       the specified CodeDom based statement representation.
        ///    </para>
        /// </devdoc>
        protected void GenerateStatement(CodeStatement e) {
            if (e.LinePragma != null) {
                GenerateLinePragmaStart(e.LinePragma);
            }

            if (e is CodeCommentStatement) {
                GenerateCommentStatement((CodeCommentStatement)e);
            }
            else if (e is CodeMethodReturnStatement) {
                GenerateMethodReturnStatement((CodeMethodReturnStatement)e);
            }
            else if (e is CodeConditionStatement) {
                GenerateConditionStatement((CodeConditionStatement)e);
            }
            else if (e is CodeTryCatchFinallyStatement) {
                GenerateTryCatchFinallyStatement((CodeTryCatchFinallyStatement)e);
            }
            else if (e is CodeAssignStatement) {
                GenerateAssignStatement((CodeAssignStatement)e);
            }
            else if (e is CodeExpressionStatement) {
                GenerateExpressionStatement((CodeExpressionStatement)e);
            }
            else if (e is CodeIterationStatement) {
                GenerateIterationStatement((CodeIterationStatement)e);
            }
            else if (e is CodeThrowExceptionStatement) {
                GenerateThrowExceptionStatement((CodeThrowExceptionStatement)e);
            }
            else if (e is CodeSnippetStatement) {
                GenerateSnippetStatement((CodeSnippetStatement)e);
            }
            else if (e is CodeVariableDeclarationStatement) {
                GenerateVariableDeclarationStatement((CodeVariableDeclarationStatement)e);
            }
            else if (e is CodeAttachEventStatement) {
                GenerateAttachEventStatement((CodeAttachEventStatement)e);
            }
            else if (e is CodeRemoveEventStatement) {
                GenerateRemoveEventStatement((CodeRemoveEventStatement)e);
            }
            else if (e is CodeGotoStatement) {
                GenerateGotoStatement((CodeGotoStatement)e);
            }
            else if (e is CodeLabeledStatement) {
                GenerateLabeledStatement((CodeLabeledStatement)e);
            }
            else {
                throw new ArgumentException(SR.GetString(SR.InvalidElementType, e.GetType().FullName), "e");
            }

            if (e.LinePragma != null) {
                GenerateLinePragmaEnd(e.LinePragma);
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateStatements"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based statement representations.
        ///    </para>
        /// </devdoc>
        protected void GenerateStatements(CodeStatementCollection stms) {
            IEnumerator en = stms.GetEnumerator();
            while (en.MoveNext()) {
                ((ICodeGenerator)this).GenerateCodeFromStatement((CodeStatement)en.Current, output.InnerWriter, options);
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.OutputAttributeDeclarations"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified System.CodeDom.CodeAttributeBlock.
        ///    </para>
        /// </devdoc>
        protected virtual void OutputAttributeDeclarations(CodeAttributeDeclarationCollection attributes) {
            if (attributes.Count == 0) return;
            GenerateAttributeDeclarationsStart(attributes);
            bool first = true;
            IEnumerator en = attributes.GetEnumerator();
            while (en.MoveNext()) {
                if (first) {
                    first = false;
                }
                else {
                    ContinueOnNewLine(", ");
                }

                CodeAttributeDeclaration current = (CodeAttributeDeclaration)en.Current;
                Output.Write(current.Name);
                Output.Write("(");

                bool firstArg = true;
                foreach (CodeAttributeArgument arg in current.Arguments) {
                    if (firstArg) {
                        firstArg = false;
                    }
                    else {
                        Output.Write(", ");
                    }

                    OutputAttributeArgument(arg);
                }

                Output.Write(")");

            }
            GenerateAttributeDeclarationsEnd(attributes);
        }


        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.OutputAttributeArgument"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Outputs an argument in a attribute block.
        ///    </para>
        /// </devdoc>
        protected virtual void OutputAttributeArgument(CodeAttributeArgument arg) {
            if (arg.Name != null && arg.Name.Length > 0) {
                OutputIdentifier(arg.Name);
                Output.Write("=");
            }
            ((ICodeGenerator)this).GenerateCodeFromExpression(arg.Value, output.InnerWriter, options);
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.OutputDirection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified System.CodeDom.FieldDirection.
        ///    </para>
        /// </devdoc>
        protected virtual void OutputDirection(FieldDirection dir) {
            switch (dir) {
                case FieldDirection.In:
                    break;
                case FieldDirection.Out:
                    Output.Write("out ");
                    break;
                case FieldDirection.Ref:
                    Output.Write("ref ");
                    break;
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.OutputFieldScopeModifier"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OutputFieldScopeModifier(MemberAttributes attributes) {
            switch (attributes & MemberAttributes.VTableMask) {
                case MemberAttributes.New:
                    Output.Write("new ");
                    break;
            }

            switch (attributes & MemberAttributes.ScopeMask) {
                case MemberAttributes.Final:
                    break;
                case MemberAttributes.Static:
                    Output.Write("static ");
                    break;
                case MemberAttributes.Const:
                    Output.Write("const ");
                    break;
                default:
                    break;
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.OutputMemberAccessModifier"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified member access modifier.
        ///    </para>
        /// </devdoc>
        protected virtual void OutputMemberAccessModifier(MemberAttributes attributes) {
            switch (attributes & MemberAttributes.AccessMask) {
                case MemberAttributes.Assembly:
                    Output.Write("internal ");
                    break;
                case MemberAttributes.FamilyAndAssembly:
                    Output.Write("/*FamANDAssem*/ internal ");
                    break;
                case MemberAttributes.Family:
                    Output.Write("protected ");
                    break;
                case MemberAttributes.FamilyOrAssembly:
                    Output.Write("protected internal ");
                    break;
                case MemberAttributes.Private:
                    Output.Write("private ");
                    break;
                case MemberAttributes.Public:
                    Output.Write("public ");
                    break;
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.OutputMemberScopeModifier"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified member scope modifier.
        ///    </para>
        /// </devdoc>
        protected virtual void OutputMemberScopeModifier(MemberAttributes attributes) {
            switch (attributes & MemberAttributes.VTableMask) {
                case MemberAttributes.New:
                    Output.Write("new ");
                    break;
            }

            switch (attributes & MemberAttributes.ScopeMask) {
                case MemberAttributes.Abstract:
                    Output.Write("abstract ");
                    break;
                case MemberAttributes.Final:
                    Output.Write("");
                    break;
                case MemberAttributes.Static:
                    Output.Write("static ");
                    break;
                case MemberAttributes.Override:
                    Output.Write("override ");
                    break;
                default:
                    switch (attributes & MemberAttributes.AccessMask) {
                        case MemberAttributes.Family:
                        case MemberAttributes.Public:
                            Output.Write("virtual ");
                            break;
                        default:
                            // nothing;
                            break;
                    }
                    break;
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.OutputType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified type.
        ///    </para>
        /// </devdoc>
        protected abstract void OutputType(CodeTypeReference typeRef);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.OutputTypeAttributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified type attributes.
        ///    </para>
        /// </devdoc>
        protected virtual void OutputTypeAttributes(TypeAttributes attributes, bool isStruct, bool isEnum) {
            switch(attributes & TypeAttributes.VisibilityMask) {
                case TypeAttributes.Public:                  
                case TypeAttributes.NestedPublic:                    
                    Output.Write("public ");
                    break;
                case TypeAttributes.NestedPrivate:
                    Output.Write("private ");
                    break;
            }
            
            if (isStruct) {
                Output.Write("struct ");
            }
            else if (isEnum) {
                Output.Write("enum ");
            }     
            else {            
                switch (attributes & TypeAttributes.ClassSemanticsMask) {
                    case TypeAttributes.Class:
                        if ((attributes & TypeAttributes.Sealed) == TypeAttributes.Sealed) {
                            Output.Write("sealed ");
                        }
                        if ((attributes & TypeAttributes.Abstract) == TypeAttributes.Abstract) {
                            Output.Write("abstract ");
                        }
                        Output.Write("class ");
                        break;                
                    case TypeAttributes.Interface:
                        Output.Write("interface ");
                        break;
                }     
            }   
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.OutputTypeNamePair"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified object type and name pair.
        ///    </para>
        /// </devdoc>
        protected virtual void OutputTypeNamePair(CodeTypeReference typeRef, string name) {
            OutputType(typeRef);
            Output.Write(" ");
            OutputIdentifier(name);
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.OutputIdentifier"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OutputIdentifier(string ident) {
            Output.Write(ident);
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.OutputExpressionList"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified expression list.
        ///    </para>
        /// </devdoc>
        protected virtual void OutputExpressionList(CodeExpressionCollection expressions) {
            OutputExpressionList(expressions, false /*newlineBetweenItems*/);
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.OutputExpressionList1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified expression list.
        ///    </para>
        /// </devdoc>
        protected virtual void OutputExpressionList(CodeExpressionCollection expressions, bool newlineBetweenItems) {
            bool first = true;
            IEnumerator en = expressions.GetEnumerator();
            Indent++;
            while (en.MoveNext()) {
                if (first) {
                    first = false;
                }
                else {
                    if (newlineBetweenItems)
                        ContinueOnNewLine(",");
                    else
                        Output.Write(", ");
                }
                ((ICodeGenerator)this).GenerateCodeFromExpression((CodeExpression)en.Current, output.InnerWriter, options);
            }
            Indent--;
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.OutputOperator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified operator.
        ///    </para>
        /// </devdoc>
        protected virtual void OutputOperator(CodeBinaryOperatorType op) {
            switch (op) {
                case CodeBinaryOperatorType.Add:
                    Output.Write("+");
                    break;
                case CodeBinaryOperatorType.Subtract:
                    Output.Write("-");
                    break;
                case CodeBinaryOperatorType.Multiply:
                    Output.Write("*");
                    break;
                case CodeBinaryOperatorType.Divide:
                    Output.Write("/");
                    break;
                case CodeBinaryOperatorType.Modulus:
                    Output.Write("%");
                    break;
                case CodeBinaryOperatorType.Assign:
                    Output.Write("=");
                    break;
                case CodeBinaryOperatorType.IdentityInequality:
                    Output.Write("!=");
                    break;
                case CodeBinaryOperatorType.IdentityEquality:
                    Output.Write("==");
                    break;
                case CodeBinaryOperatorType.ValueEquality:
                    Output.Write("==");
                    break;
                case CodeBinaryOperatorType.BitwiseOr:
                    Output.Write("|");
                    break;
                case CodeBinaryOperatorType.BitwiseAnd:
                    Output.Write("&");
                    break;
                case CodeBinaryOperatorType.BooleanOr:
                    Output.Write("||");
                    break;
                case CodeBinaryOperatorType.BooleanAnd:
                    Output.Write("&&");
                    break;
                case CodeBinaryOperatorType.LessThan:
                    Output.Write("<");
                    break;
                case CodeBinaryOperatorType.LessThanOrEqual:
                    Output.Write("<=");
                    break;
                case CodeBinaryOperatorType.GreaterThan:
                    Output.Write(">");
                    break;
                case CodeBinaryOperatorType.GreaterThanOrEqual:
                    Output.Write(">=");
                    break;
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.OutputParameters"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified parameters.
        ///    </para>
        /// </devdoc>
        protected virtual void OutputParameters(CodeParameterDeclarationExpressionCollection parameters) {
            bool first = true;
            bool multiline = parameters.Count > ParameterMultilineThreshold;
            if (multiline) {
                Indent += 3;
            }
            IEnumerator en = parameters.GetEnumerator();
            while (en.MoveNext()) {
                CodeParameterDeclarationExpression current = (CodeParameterDeclarationExpression)en.Current;
                if (first) {
                    first = false;
                }
                else {
                    Output.Write(", ");
                }
                if (multiline) {
                    ContinueOnNewLine("");
                }
                GenerateExpression(current);
            }
            if (multiline) {
                Indent -= 3;
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateArrayCreateExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based array creation expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateArrayCreateExpression(CodeArrayCreateExpression e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateBaseReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based base reference expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateBaseReferenceExpression(CodeBaseReferenceExpression e);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateBinaryOperatorExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based binary operator
        ///       expression representation.
        ///    </para>
        /// </devdoc>
        protected virtual void GenerateBinaryOperatorExpression(CodeBinaryOperatorExpression e) {
            bool indentedExpression = false;
            Output.Write("(");

            GenerateExpression(e.Left);
            Output.Write(" ");

            if (e.Left is CodeBinaryOperatorExpression || e.Right is CodeBinaryOperatorExpression) {
                // In case the line gets too long with nested binary operators, we need to output them on
                // different lines. However we want to indent them to maintain readability, but this needs
                // to be done only once;
                if (!inNestedBinary) {
                    indentedExpression = true;
                    inNestedBinary = true;
                    Indent += 3;
                }
                ContinueOnNewLine("");
            }
 
            OutputOperator(e.Operator);

            Output.Write(" ");
            GenerateExpression(e.Right);

            Output.Write(")");
            if (indentedExpression) {
                Indent -= 3;
                inNestedBinary = false;
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.ContinueOnNewLine"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void ContinueOnNewLine(string st) {
            Output.WriteLine(st);
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateCastExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based cast expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateCastExpression(CodeCastExpression e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateDelegateCreateExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based delegate creation expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateDelegateCreateExpression(CodeDelegateCreateExpression e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateFieldReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based field reference
        ///       expression representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateFieldReferenceExpression(CodeFieldReferenceExpression e);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateArgumentReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract void GenerateArgumentReferenceExpression(CodeArgumentReferenceExpression e);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateVariableReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract void GenerateVariableReferenceExpression(CodeVariableReferenceExpression e);
        
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateIndexerExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based indexer expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateIndexerExpression(CodeIndexerExpression e);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateArrayIndexerExpression"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract void GenerateArrayIndexerExpression(CodeArrayIndexerExpression e);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateSnippetExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based snippet
        ///       expression representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateSnippetExpression(CodeSnippetExpression e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateMethodInvokeExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based method invoke expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateMethodInvokeExpression(CodeMethodInvokeExpression e);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateMethodReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract void GenerateMethodReferenceExpression(CodeMethodReferenceExpression e);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateEventReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract void GenerateEventReferenceExpression(CodeEventReferenceExpression e);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateDelegateInvokeExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based delegate invoke expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateDelegateInvokeExpression(CodeDelegateInvokeExpression e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateObjectCreateExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom
        ///       based object creation expression representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateObjectCreateExpression(CodeObjectCreateExpression e);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateParameterDeclarationExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom
        ///       based parameter declaration expression representation.
        ///    </para>
        /// </devdoc>
        protected virtual void GenerateParameterDeclarationExpression(CodeParameterDeclarationExpression e) {
            if (e.CustomAttributes.Count > 0) {
                OutputAttributeDeclarations(e.CustomAttributes);
                Output.Write(" ");
            }

            OutputDirection(e.Direction);
            OutputTypeNamePair(e.Type, e.Name);
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateDirectionExpression"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void GenerateDirectionExpression(CodeDirectionExpression e) {
            OutputDirection(e.Direction);
            GenerateExpression(e.Expression);
        }


        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GeneratePrimitiveExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based primitive expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected virtual void GeneratePrimitiveExpression(CodePrimitiveExpression e) {
            if (e.Value == null) {
                Output.Write(NullToken);
            }
            else if (e.Value is string) {
                Output.Write(QuoteSnippetString((string)e.Value));
            }
            else if (e.Value is char) {
                Output.Write("'" + e.Value.ToString() + "'");
            }
            else if (e.Value is byte) {
                Output.Write(((byte)e.Value).ToString(CultureInfo.InvariantCulture));
            }
            else if (e.Value is Int16) {
                Output.Write(((Int16)e.Value).ToString(CultureInfo.InvariantCulture));
            }
            else if (e.Value is Int32) {
                Output.Write(((Int32)e.Value).ToString(CultureInfo.InvariantCulture));
            }
            else if (e.Value is Int64) {
                Output.Write(((Int64)e.Value).ToString(CultureInfo.InvariantCulture));
            }
            else if (e.Value is Single) {
                GenerateSingleFloatValue((Single)e.Value);
            }
            else if (e.Value is Double) {
                GenerateDoubleValue((Double)e.Value);
            }
            else if (e.Value is Decimal) {
                GenerateDecimalValue((Decimal)e.Value);
            }
            else if (e.Value is bool) {
                if ((bool)e.Value) {
                    Output.Write("true");
                }
                else {
                    Output.Write("false");
                }
            }
            else {
                throw new ArgumentException(SR.GetString(SR.InvalidPrimitiveType, e.Value.GetType().ToString()));
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateSingleFloatValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void GenerateSingleFloatValue(Single s) {
            Output.Write(s.ToString(CultureInfo.InvariantCulture));
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateDoubleValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void GenerateDoubleValue(Double d) {
            Output.Write(d.ToString("R", CultureInfo.InvariantCulture));
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateDecimalValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void GenerateDecimalValue(Decimal d) {
            Output.Write(d.ToString(CultureInfo.InvariantCulture));
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GeneratePropertyReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based property reference
        ///       expression representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GeneratePropertyReferenceExpression(CodePropertyReferenceExpression e);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GeneratePropertySetValueReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract void GeneratePropertySetValueReferenceExpression(CodePropertySetValueReferenceExpression e);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateThisReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based this reference expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateThisReferenceExpression(CodeThisReferenceExpression e);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateTypeReferenceExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based type reference expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected virtual void GenerateTypeReferenceExpression(CodeTypeReferenceExpression e) {
            OutputType(e.Type);
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateTypeOfExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based type of expression
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected virtual void GenerateTypeOfExpression(CodeTypeOfExpression e) {
            Output.Write("typeof(");
            OutputType(e.Type);
            Output.Write(")");
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateExpressionStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based method
        ///       invoke statement representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateExpressionStatement(CodeExpressionStatement e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateIterationStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based for loop statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateIterationStatement(CodeIterationStatement e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateThrowExceptionStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based throw exception statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateThrowExceptionStatement(CodeThrowExceptionStatement e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateCommentStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based comment statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected virtual void GenerateCommentStatement(CodeCommentStatement e) {
            GenerateComment(e.Comment);
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateCommentStatements"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void GenerateCommentStatements(CodeCommentStatementCollection e) {
            foreach (CodeCommentStatement comment in e) {
                GenerateCommentStatement(comment);
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateComment"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract void GenerateComment(CodeComment e);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateMethodReturnStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based method return statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateMethodReturnStatement(CodeMethodReturnStatement e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateConditionStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based if statement representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateConditionStatement(CodeConditionStatement e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateTryCatchFinallyStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based try catch finally
        ///       statement representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateTryCatchFinallyStatement(CodeTryCatchFinallyStatement e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateAssignStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based assignment statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateAssignStatement(CodeAssignStatement e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateAttachEventStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based attach event statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateAttachEventStatement(CodeAttachEventStatement e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateRemoveEventStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based detach event statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateRemoveEventStatement(CodeRemoveEventStatement e);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateGotoStatement"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract void GenerateGotoStatement(CodeGotoStatement e);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateLabeledStatement"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract void GenerateLabeledStatement(CodeLabeledStatement e);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateSnippetStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based snippet statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected virtual void GenerateSnippetStatement(CodeSnippetStatement e) {
            Output.WriteLine(e.Value);
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateVariableDeclarationStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based variable declaration statement
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateVariableDeclarationStatement(CodeVariableDeclarationStatement e);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateLinePragmaStart"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based line pragma start
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateLinePragmaStart(CodeLinePragma e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateLinePragmaEnd"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based line pragma end
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateLinePragmaEnd(CodeLinePragma e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateEvent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based event
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateEvent(CodeMemberEvent e, CodeTypeDeclaration c);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateField"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based member field
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateField(CodeMemberField e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateSnippetMember"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based snippet class member
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateSnippetMember(CodeSnippetTypeMember e);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateEntryPointMethod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract void GenerateEntryPointMethod(CodeEntryPointMethod e, CodeTypeDeclaration c);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateMethod"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based method
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateMethod(CodeMemberMethod e, CodeTypeDeclaration c);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateProperty"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based property
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateProperty(CodeMemberProperty e, CodeTypeDeclaration c);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateConstructor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based constructor
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateConstructor(CodeConstructor e, CodeTypeDeclaration c);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateTypeConstructor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based class constructor
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateTypeConstructor(CodeTypeConstructor e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateTypeStart"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based start class representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateTypeStart(CodeTypeDeclaration e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateTypeEnd"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based end class representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateTypeEnd(CodeTypeDeclaration e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateCompileUnitStart"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based compile unit start
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected virtual void GenerateCompileUnitStart(CodeCompileUnit e) {
        }
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateCompileUnitEnd"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based compile unit end
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected virtual void GenerateCompileUnitEnd(CodeCompileUnit e) {
        }
         /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateNamespaceStart"]/*' />
         /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based namespace start
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateNamespaceStart(CodeNamespace e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateNamespaceEnd"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based namespace end
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateNamespaceEnd(CodeNamespace e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateNamespaceImport"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based namespace import
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateNamespaceImport(CodeNamespaceImport e);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateAttributeDeclarationsStart"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based attribute block start
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateAttributeDeclarationsStart(CodeAttributeDeclarationCollection attributes);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GenerateAttributeDeclarationsEnd"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code for the specified CodeDom based attribute block end
        ///       representation.
        ///    </para>
        /// </devdoc>
        protected abstract void GenerateAttributeDeclarationsEnd(CodeAttributeDeclarationCollection attributes);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.Supports"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract bool Supports(GeneratorSupport support);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.IsValidIdentifier"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets whether the specified value is a value identifier.
        ///    </para>
        /// </devdoc>
        protected abstract bool IsValidIdentifier(string value);
        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.ValidateIdentifier"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets whether the specified identifier is valid.
        ///    </para>
        /// </devdoc>
        protected virtual void ValidateIdentifier(string value) {
            if (!IsValidIdentifier(value)) {
                throw new ArgumentException(SR.GetString(SR.InvalidIdentifier, value));
            }
        }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.CreateEscapedIdentifier"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract string CreateEscapedIdentifier(string value);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.CreateValidIdentifier"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract string CreateValidIdentifier(string value);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.GetTypeOutput"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected abstract string GetTypeOutput(CodeTypeReference value);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.QuoteSnippetString"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides conversion to formatting with escape codes.
        ///    </para>
        /// </devdoc>
        protected abstract string QuoteSnippetString(string value);

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.IsValidLanguageIndependentIdentifier"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the specified value is a valid language
        ///       independent identifier.
        ///    </para>
        /// </devdoc>
        public static bool IsValidLanguageIndependentIdentifier(string value)
        {
            char[] chars = value.ToCharArray();

            if (chars.Length == 0) 
                return false;

            // First char cannot be a number
            if (Char.GetUnicodeCategory(chars[0]) == UnicodeCategory.DecimalDigitNumber)
                return false;

            // each char must be Lu, Ll, Lt, Lm, Lo, Nd, Mn, Mc, Pc
            // 
            foreach (char ch in chars) {
                UnicodeCategory uc = Char.GetUnicodeCategory(ch);
                switch (uc) {
                    case UnicodeCategory.UppercaseLetter:        // Lu
                    case UnicodeCategory.LowercaseLetter:        // Ll
                    case UnicodeCategory.TitlecaseLetter:        // Lt
                    case UnicodeCategory.ModifierLetter:         // Lm
                    case UnicodeCategory.OtherLetter:            // Lo
                    case UnicodeCategory.DecimalDigitNumber:     // Nd
                    case UnicodeCategory.NonSpacingMark:         // Mn
                    case UnicodeCategory.SpacingCombiningMark:   // Mc
                    case UnicodeCategory.ConnectorPunctuation:   // Pc
                        break;
                    default:
                        return false;
                }
            }

            return true;
        }

        internal static bool IsValidLanguageIndependentTypeName(string value)
        {
            // each char must be Lu, Ll, Lt, Lm, Lo, Nd, Mn, Mc, Pc
            // 
            for(int i = 0; i < value.Length; i++) {
	        	char ch = value[i];
                UnicodeCategory uc = Char.GetUnicodeCategory(ch);
                switch (uc) {
                    case UnicodeCategory.UppercaseLetter:        // Lu
                    case UnicodeCategory.LowercaseLetter:        // Ll
                    case UnicodeCategory.TitlecaseLetter:        // Lt
                    case UnicodeCategory.ModifierLetter:         // Lm
                    case UnicodeCategory.OtherLetter:            // Lo
                    case UnicodeCategory.DecimalDigitNumber:     // Nd
                    case UnicodeCategory.NonSpacingMark:         // Mn
                    case UnicodeCategory.SpacingCombiningMark:   // Mc
                    case UnicodeCategory.ConnectorPunctuation:   // Pc
                        break;
                    default:
			            if (IsSpecialTypeChar(ch))
				            break;
                        return false;
                }
            }

            return true;
        }

	    // This can be a special character like a separator that shows up in a type name
	    private static bool IsSpecialTypeChar(char ch) {
		    switch(ch) {
			    case ':':
			    case '.':
			    case '$':
			    case '+':
			    case '<':
			    case '>':
			    case '-':
				    return true;

		    }
		    return false;
	    }

        /// <include file='doc\CodeGenerator.uex' path='docs/doc[@for="CodeGenerator.ValidateIdentifiers"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Validates a tree to check if all the types and idenfier names follow the rules of an identifier
        ///       in a langauge independent manner.
        ///    </para>
        /// </devdoc>
        public static void ValidateIdentifiers(CodeObject e) {
            CodeValidator codeValidator = new CodeValidator(); // This has internal state and hence is not static
            codeValidator.ValidateIdentifiers(e);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\compiler\compilerparameters.cs ===
//------------------------------------------------------------------------------
// <copyright file="CompilerParameters.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom.Compiler {
    using System;
    using System.CodeDom;
    using System.Collections;
    using System.Collections.Specialized;
    using Microsoft.Win32;
    using System.Runtime.InteropServices;
    using System.Security.Permissions;
    using System.Security.Policy;


    /// <include file='doc\CompilerParameters.uex' path='docs/doc[@for="CompilerParameters"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the parameters used in to invoke the compiler.
    ///    </para>
    /// </devdoc>
#if !CPB50004
    [ComVisible(false)]
#endif
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public class CompilerParameters {
        private StringCollection assemblyNames = new StringCollection();
        private string outputName;
        private string mainClass;
        private bool generateInMemory = false;
        private bool includeDebugInformation = false;
        private int warningLevel = -1;  // -1 means not set (use compiler default)
        private string compilerOptions;
        private string win32Resource;
        private bool treatWarningsAsErrors = false;
        private bool generateExecutable = false;
        private TempFileCollection tempFiles;
        private IntPtr userToken = IntPtr.Zero;
        private Evidence evidence = null;

        /// <include file='doc\CompilerParameters.uex' path='docs/doc[@for="CompilerParameters.CompilerParameters"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.Compiler.CompilerParameters'/>.
        ///    </para>
        /// </devdoc>
        public CompilerParameters() :
            this(null, null) {
        }

        /// <include file='doc\CompilerParameters.uex' path='docs/doc[@for="CompilerParameters.CompilerParameters1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.Compiler.CompilerParameters'/> using the specified
        ///       assembly names.
        ///    </para>
        /// </devdoc>
        public CompilerParameters(string[] assemblyNames) :
            this(assemblyNames, null, false) {
        }

        /// <include file='doc\CompilerParameters.uex' path='docs/doc[@for="CompilerParameters.CompilerParameters2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.Compiler.CompilerParameters'/> using the specified
        ///       assembly names and output name.
        ///    </para>
        /// </devdoc>
        public CompilerParameters(string[] assemblyNames, string outputName) :
            this(assemblyNames, outputName, false) {
        }

        /// <include file='doc\CompilerParameters.uex' path='docs/doc[@for="CompilerParameters.CompilerParameters3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.Compiler.CompilerParameters'/> using the specified
        ///       assembly names, output name and a whether to include debug information flag.
        ///    </para>
        /// </devdoc>
        public CompilerParameters(string[] assemblyNames, string outputName, bool includeDebugInformation) {
            if (assemblyNames != null) {
                ReferencedAssemblies.AddRange(assemblyNames);
            }
            this.outputName = outputName;
            this.includeDebugInformation = includeDebugInformation;
        }

        /// <include file='doc\CompilerParameters.uex' path='docs/doc[@for="CompilerParameters.GenerateExecutable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets whether to generate an executable.
        ///    </para>
        /// </devdoc>
        public bool GenerateExecutable {
            get {
                return generateExecutable;
            }
            set {
                generateExecutable = value;
            }
        }

        /// <include file='doc\CompilerParameters.uex' path='docs/doc[@for="CompilerParameters.GenerateInMemory"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets whether to generate in memory.
        ///    </para>
        /// </devdoc>
        public bool GenerateInMemory {
            get {
                return generateInMemory;
            }
            set {
                generateInMemory = value;
            }
        }

        /// <include file='doc\CompilerParameters.uex' path='docs/doc[@for="CompilerParameters.ReferencedAssemblies"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the assemblies referenced by the source to compile.
        ///    </para>
        /// </devdoc>
        public StringCollection ReferencedAssemblies {
            get {
                return assemblyNames;
            }
        }

        /// <include file='doc\CompilerParameters.uex' path='docs/doc[@for="CompilerParameters.MainClass"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the main class.
        ///    </para>
        /// </devdoc>
        public string MainClass {
            get {
                return mainClass;
            }
            set {
                mainClass = value;
            }
        }

        /// <include file='doc\CompilerParameters.uex' path='docs/doc[@for="CompilerParameters.OutputAssembly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the output assembly.
        ///    </para>
        /// </devdoc>
        public string OutputAssembly {
            get {
                return outputName;
            }
            set {
                outputName = value;
            }
        }

        /// <include file='doc\CompilerParameters.uex' path='docs/doc[@for="CompilerParameters.TempFiles"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the temp files.
        ///    </para>
        /// </devdoc>
        public TempFileCollection TempFiles {
            get {
                if (tempFiles == null)
                    tempFiles = new TempFileCollection();
                return tempFiles;
            }
            set {
                tempFiles = value;
            }
        }

        /// <include file='doc\CompilerParameters.uex' path='docs/doc[@for="CompilerParameters.IncludeDebugInformation"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets whether to include debug information in the compiled
        ///       executable.
        ///    </para>
        /// </devdoc>
        public bool IncludeDebugInformation {
            get {
                return includeDebugInformation;
            }
            set {
                includeDebugInformation = value;
            }
        }

        /// <include file='doc\CompilerParameters.uex' path='docs/doc[@for="CompilerParameters.TreatWarningsAsErrors"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool TreatWarningsAsErrors {
            get {
                return treatWarningsAsErrors;
            }
            set {
                treatWarningsAsErrors = value;
            }
        }

        /// <include file='doc\CompilerParameters.uex' path='docs/doc[@for="CompilerParameters.WarningLevel"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int WarningLevel {
            get {
                return warningLevel;
            }
            set {
                warningLevel = value;
            }
        }

        /// <include file='doc\CompilerParameters.uex' path='docs/doc[@for="CompilerParameters.CompilerOptions"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string CompilerOptions {
            get {
                return compilerOptions;
            }
            set {
                compilerOptions = value;
            }
        }

        /// <include file='doc\CompilerParameters.uex' path='docs/doc[@for="CompilerParameters.Win32Resource"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Win32Resource {
            get {
                return win32Resource;
            }
            set {
                win32Resource = value;
            }
        }

        /// <include file='doc\CompilerParameters.uex' path='docs/doc[@for="CompilerParameters.UserToken"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets user token to be employed when creating the compiler process.
        ///    </para>
        /// </devdoc>
        public IntPtr UserToken {
            get {
                return userToken;
            }
            set {
                userToken = value;
            }
        }

        /// <include file='doc\CompilerParameters.uex' path='docs/doc[@for="CompilerParameters.Evidence"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Set the evidence for partially trusted scenarios.
        ///    </para>
        /// </devdoc>
        public Evidence Evidence {
            get {
                Evidence e = null;
                if (evidence != null)
                    e = CompilerResults.CloneEvidence(evidence);
                return e;
            }
            [SecurityPermissionAttribute( SecurityAction.Demand, ControlEvidence = true )]
            set {
                if (value != null)
                    evidence = CompilerResults.CloneEvidence(value);
                else
                    evidence = null;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\compiler\icodegenerator.cs ===
//------------------------------------------------------------------------------
// <copyright file="ICodeGenerator.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom.Compiler {

    using System.Diagnostics;
    using System.IO;
    using System.Security.Permissions;

    /// <include file='doc\ICodeGenerator.uex' path='docs/doc[@for="ICodeGenerator"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides an
    ///       interface for code generation.
    ///    </para>
    /// </devdoc>
    public interface ICodeGenerator {
        /// <include file='doc\ICodeGenerator.uex' path='docs/doc[@for="ICodeGenerator.IsValidIdentifier"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether
        ///       the specified value is a valid identifier for this language.
        ///    </para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
        bool IsValidIdentifier(string value);

        /// <include file='doc\ICodeGenerator.uex' path='docs/doc[@for="ICodeGenerator.ValidateIdentifier"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Throws an exception if value is not a valid identifier.
        ///    </para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
        void ValidateIdentifier(string value);

        /// <include file='doc\ICodeGenerator.uex' path='docs/doc[@for="ICodeGenerator.CreateEscapedIdentifier"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
        string CreateEscapedIdentifier(string value);
        /// <include file='doc\ICodeGenerator.uex' path='docs/doc[@for="ICodeGenerator.CreateValidIdentifier"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
        string CreateValidIdentifier(string value);
        /// <include file='doc\ICodeGenerator.uex' path='docs/doc[@for="ICodeGenerator.GetTypeOutput"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
        string GetTypeOutput(CodeTypeReference type);
        /// <include file='doc\ICodeGenerator.uex' path='docs/doc[@for="ICodeGenerator.Supports"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
        bool Supports(GeneratorSupport supports);

        /// <include file='doc\ICodeGenerator.uex' path='docs/doc[@for="ICodeGenerator.GenerateCodeFromExpression"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Generates code from the specified expression and
        ///       outputs it to the specified textwriter.
        ///    </para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
        void GenerateCodeFromExpression(CodeExpression e, TextWriter w, CodeGeneratorOptions o);

        /// <include file='doc\ICodeGenerator.uex' path='docs/doc[@for="ICodeGenerator.GenerateCodeFromStatement"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Outputs the language specific representaion of the CodeDom tree
        ///       refered to by e, into w.
        ///    </para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
        void GenerateCodeFromStatement(CodeStatement e, TextWriter w, CodeGeneratorOptions o);

        /// <include file='doc\ICodeGenerator.uex' path='docs/doc[@for="ICodeGenerator.GenerateCodeFromNamespace"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Outputs the language specific representaion of the CodeDom tree
        ///       refered to by e, into w.
        ///    </para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
        void GenerateCodeFromNamespace(CodeNamespace e, TextWriter w, CodeGeneratorOptions o);

        /// <include file='doc\ICodeGenerator.uex' path='docs/doc[@for="ICodeGenerator.GenerateCodeFromCompileUnit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Outputs the language specific representaion of the CodeDom tree
        ///       refered to by e, into w.
        ///    </para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
        void GenerateCodeFromCompileUnit(CodeCompileUnit e, TextWriter w, CodeGeneratorOptions o);

        /// <include file='doc\ICodeGenerator.uex' path='docs/doc[@for="ICodeGenerator.GenerateCodeFromType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Outputs the language specific representaion of the CodeDom tree
        ///       refered to by e, into w.
        ///    </para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
        void GenerateCodeFromType(CodeTypeDeclaration e, TextWriter w, CodeGeneratorOptions o);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\compiler\icodecompiler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ICodeCompiler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom.Compiler {

    using System.Diagnostics;
    using System.IO;
    using System.Security.Permissions;

    /// <include file='doc\ICodeCompiler.uex' path='docs/doc[@for="ICodeCompiler"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides a
    ///       code compilation
    ///       interface.
    ///    </para>
    /// </devdoc>
    public interface ICodeCompiler {

        /// <include file='doc\ICodeCompiler.uex' path='docs/doc[@for="ICodeCompiler.CompileAssemblyFromDom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an assembly based on options, with the information from
        ///       e.
        ///    </para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
        CompilerResults CompileAssemblyFromDom(CompilerParameters options, CodeCompileUnit compilationUnit);

        /// <include file='doc\ICodeCompiler.uex' path='docs/doc[@for="ICodeCompiler.CompileAssemblyFromFile"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an assembly based on options, with the contents of
        ///       fileName.
        ///    </para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
        CompilerResults CompileAssemblyFromFile(CompilerParameters options, string fileName);

        /// <include file='doc\ICodeCompiler.uex' path='docs/doc[@for="ICodeCompiler.CompileAssemblyFromSource"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an assembly based on options, with the information from
        ///       source.
        ///    </para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
        CompilerResults CompileAssemblyFromSource(CompilerParameters options, string source);

        /// <include file='doc\ICodeCompiler.uex' path='docs/doc[@for="ICodeCompiler.CompileAssemblyFromDomBatch"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compiles an assembly based on the specified options and
        ///       information.
        ///    </para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
        CompilerResults CompileAssemblyFromDomBatch(CompilerParameters options, CodeCompileUnit[] compilationUnits);

        /// <include file='doc\ICodeCompiler.uex' path='docs/doc[@for="ICodeCompiler.CompileAssemblyFromFileBatch"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compiles
        ///       an
        ///       assembly based on the specified options and contents of the specified
        ///       filenames.
        ///    </para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
        CompilerResults CompileAssemblyFromFileBatch(CompilerParameters options, string[] fileNames);

        /// <include file='doc\ICodeCompiler.uex' path='docs/doc[@for="ICodeCompiler.CompileAssemblyFromSourceBatch"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compiles an assembly based on the specified options and information from the specified
        ///       sources.
        ///    </para>
        /// </devdoc>
        [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
        [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
        CompilerResults CompileAssemblyFromSourceBatch(CompilerParameters options, string[] sources);

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\compiler\compilerresults.cs ===
//------------------------------------------------------------------------------
// <copyright file="CompilerResults.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom.Compiler {
    using System;
    using System.CodeDom;
    using System.Reflection;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Security;
    using System.Security.Permissions;
    using System.Security.Policy;
    using System.Runtime.Serialization;
    using System.Runtime.Serialization.Formatters.Binary;
    using System.IO;


    /// <include file='doc\CompilerResults.uex' path='docs/doc[@for="CompilerResults"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents the results
    ///       of compilation from the compiler.
    ///    </para>
    /// </devdoc>
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public class CompilerResults {
        private CompilerErrorCollection errors = new CompilerErrorCollection();
        private StringCollection output = new StringCollection();
        private Assembly compiledAssembly;
        private string pathToAssembly;
        private int nativeCompilerReturnValue;
        private TempFileCollection tempFiles;
        private Evidence evidence;

        /// <include file='doc\CompilerResults.uex' path='docs/doc[@for="CompilerResults.CompilerResults"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.Compiler.CompilerResults'/>
        ///       that uses the specified
        ///       temporary files.
        ///    </para>
        /// </devdoc>
        public CompilerResults(TempFileCollection tempFiles) {
            this.tempFiles = tempFiles;
        }

        /// <include file='doc\CompilerResults.uex' path='docs/doc[@for="CompilerResults.TempFiles"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the temporary files to use.
        ///    </para>
        /// </devdoc>
        public TempFileCollection TempFiles {
            get {
                return tempFiles;
            }
            set {
                tempFiles = value;
            }
        }

        /// <include file='doc\CompilerResults.uex' path='docs/doc[@for="CompilerResults.Evidence"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Set the evidence for partially trusted scenarios.
        ///    </para>
        /// </devdoc>
        public Evidence Evidence {
            get {
                Evidence e = null;
                if (evidence != null)
                    e = CloneEvidence(evidence);
                return e;
            }
            [SecurityPermissionAttribute( SecurityAction.Demand, ControlEvidence = true )]
            set {
                if (value != null)
                    evidence = CloneEvidence(value);
                else
                    evidence = null;
            }
        }

        /// <include file='doc\CompilerResults.uex' path='docs/doc[@for="CompilerResults.CompiledAssembly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The compiled assembly.
        ///    </para>
        /// </devdoc>
        public Assembly CompiledAssembly {
           [SecurityPermissionAttribute(SecurityAction.Assert, Flags=SecurityPermissionFlag.ControlEvidence)]
            get {
                if (compiledAssembly == null && pathToAssembly != null) {
                    AssemblyName assemName = new AssemblyName();
                    assemName.CodeBase = pathToAssembly;
                    compiledAssembly = Assembly.Load(assemName,evidence);
                }
                return compiledAssembly;
            }
            set {
                compiledAssembly = value;
            }
        }

        /// <include file='doc\CompilerResults.uex' path='docs/doc[@for="CompilerResults.Errors"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the collection of compiler errors.
        ///    </para>
        /// </devdoc>
        public CompilerErrorCollection Errors {
            get {
                return errors;
            }
        }

        /// <include file='doc\CompilerResults.uex' path='docs/doc[@for="CompilerResults.Output"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the compiler output messages.
        ///    </para>
        /// </devdoc>
        public StringCollection Output {
            get {
                return output;
            }
        }

        /// <include file='doc\CompilerResults.uex' path='docs/doc[@for="CompilerResults.PathToAssembly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the path to the assembly.
        ///    </para>
        /// </devdoc>
        public string PathToAssembly {
            get {
                return pathToAssembly;
            }
            set {
                pathToAssembly = value;
            }
        }

        /// <include file='doc\CompilerResults.uex' path='docs/doc[@for="CompilerResults.NativeCompilerReturnValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the compiler's return value.
        ///    </para>
        /// </devdoc>
        public int NativeCompilerReturnValue {
            get {
                return nativeCompilerReturnValue;
            }
            set {
                nativeCompilerReturnValue = value;
            }
        }

        internal static Evidence CloneEvidence(Evidence ev) {
            new PermissionSet( PermissionState.Unrestricted ).Assert();

            MemoryStream stream = new MemoryStream();

            BinaryFormatter formatter = new BinaryFormatter();

            formatter.Serialize( stream, ev );

            stream.Position = 0;

            return (Evidence)formatter.Deserialize( stream );
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\compiler\executor.cs ===
//------------------------------------------------------------------------------
// <copyright file="Executor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom.Compiler {

    using System.Diagnostics;
    using System;
    using System.ComponentModel;
    using System.Text;
    using System.Threading;
    using System.IO;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.CodeDom;
    using System.Security;
    using System.Security.Permissions;
    using Microsoft.Win32;
    using System.Globalization;
    
    /// <include file='doc\Executor.uex' path='docs/doc[@for="Executor"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides command execution functions for the CodeDom compiler.
    ///    </para>
    /// </devdoc>
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public sealed class Executor {

        // How long (in milliseconds) do we wait for the program to terminate
        private const int ProcessTimeOut = 600000;

        //private static StringBuilder tempfilename = new StringBuilder(1024);

        private Executor() {
        }

        /// <include file='doc\Executor.uex' path='docs/doc[@for="Executor.GetRuntimeInstallDirectory"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the runtime install directory.
        ///    </para>
        /// </devdoc>
        internal static string GetRuntimeInstallDirectory() {

            // Get the path to mscorlib.dll
            string s = typeof(object).Module.FullyQualifiedName;

            // Remove the file part to get the directory
            return Directory.GetParent(s).ToString() + "\\";
        }

        private static IntPtr CreateInheritedFile(string file) {
            NativeMethods.SECURITY_ATTRIBUTES sec_attribs = new NativeMethods.SECURITY_ATTRIBUTES();
            sec_attribs.nLength = Marshal.SizeOf(sec_attribs);
            sec_attribs.bInheritHandle = true;

            IntPtr handle = UnsafeNativeMethods.CreateFile(file,
                                    NativeMethods.GENERIC_WRITE,
                                    NativeMethods.FILE_SHARE_READ,
                                    sec_attribs,
                                    NativeMethods.CREATE_ALWAYS,
                                    NativeMethods.FILE_ATTRIBUTE_NORMAL,
                                    NativeMethods.NullHandleRef);
            if (handle == NativeMethods.InvalidIntPtr) {
                throw new ExternalException(SR.GetString(SR.ExecFailedToCreate, file), Marshal.GetLastWin32Error());
            }

            return handle;
        }

        /// <include file='doc\Executor.uex' path='docs/doc[@for="Executor.ExecWait"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static void ExecWait(string cmd, TempFileCollection tempFiles) {
            string outputName = null;
            string errorName = null;
            ExecWaitWithCapture(IntPtr.Zero, cmd, tempFiles, ref outputName, ref errorName);
        }

        /// <include file='doc\Executor.uex' path='docs/doc[@for="Executor.ExecWaitWithCapture"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static int ExecWaitWithCapture(string cmd, TempFileCollection tempFiles, ref string outputName, ref string errorName) {
            return ExecWaitWithCapture(IntPtr.Zero, cmd, Environment.CurrentDirectory, tempFiles, ref outputName, ref errorName);
        }

        /// <include file='doc\Executor.uex' path='docs/doc[@for="Executor.ExecWaitWithCapture1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static int ExecWaitWithCapture(string cmd, string currentDir, TempFileCollection tempFiles, ref string outputName, ref string errorName) {
            return ExecWaitWithCapture(IntPtr.Zero, cmd, currentDir, tempFiles, ref outputName, ref errorName);
        }

        /// <include file='doc\Executor.uex' path='docs/doc[@for="Executor.ExecWaitWithCapture2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static int ExecWaitWithCapture(IntPtr userToken, string cmd, TempFileCollection tempFiles, ref string outputName, ref string errorName) {
            return ExecWaitWithCapture(userToken, cmd, Environment.CurrentDirectory, tempFiles, ref outputName, ref errorName);
        }

        internal static int ExecWaitWithCapture(IntPtr userToken, string cmd, TempFileCollection tempFiles, ref string outputName, ref string errorName, string trueCmdLine) {
            return ExecWaitWithCapture(userToken, cmd, Environment.CurrentDirectory, tempFiles, ref outputName, ref errorName, trueCmdLine);
        }

        /// <include file='doc\Executor.uex' path='docs/doc[@for="Executor.ExecWaitWithCapture4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static int ExecWaitWithCapture(IntPtr userToken, string cmd, string currentDir, TempFileCollection tempFiles, ref string outputName, ref string errorName) {
            return ExecWaitWithCapture(userToken, cmd, Environment.CurrentDirectory, tempFiles, ref outputName, ref errorName, null);
        }

        /// <include file='doc\Executor.uex' path='docs/doc[@for="Executor.ExecWaitWithCapture3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        internal static int ExecWaitWithCapture(IntPtr userToken, string cmd, string currentDir, TempFileCollection tempFiles, ref string outputName, ref string errorName, string trueCmdLine) {
            int retValue = 0;
            IntPtr impersonatedToken = IntPtr.Zero;
            bool needToReimpersonate = false;

            // Undo any current impersonation, call ExecWaitWithCaptureUnimpersonated, and reimpersonate

            try {
                if (UnsafeNativeMethods.OpenThreadToken(
                            new HandleRef(null, UnsafeNativeMethods.GetCurrentThread()),
                            NativeMethods.TOKEN_READ | NativeMethods.TOKEN_IMPERSONATE,
                            true,
                            ref impersonatedToken)) {

                    // got the currenly impersonated token -- revert and reimpersonate later
                    if (UnsafeNativeMethods.RevertToSelf()) {
                        needToReimpersonate = true;
                    }
                }

                // Execute the process
                retValue = ExecWaitWithCaptureUnimpersonated(userToken, cmd, currentDir, tempFiles, ref outputName, ref errorName, trueCmdLine);

            } finally {
                bool success;

                if (needToReimpersonate)
                    success = UnsafeNativeMethods.SetThreadToken(NativeMethods.NullHandleRef, new HandleRef(null, impersonatedToken));
                else
                    success = true; // no need to reimpersonate - success

                // close the token before error check (and possible exception)
                // could be that there is a token but Revert failed and thus needToReimpersonate is false
                if (impersonatedToken != IntPtr.Zero)
                    UnsafeNativeMethods.CloseHandle(new HandleRef(null, impersonatedToken));

                // reimpersonation failure is rare but bad - the thread is left in wrong state
                if (!success)
                    throw new ExternalException(SR.GetString(SR.ExecCantExec, cmd), Marshal.GetLastWin32Error());
            }

            return retValue;
        }

        private static int ExecWaitWithCaptureUnimpersonated(IntPtr userToken, string cmd, string currentDir, TempFileCollection tempFiles, ref string outputName, ref string errorName, string trueCmdLine) {

            IntSecurity.UnmanagedCode.Demand();

            IntPtr output;
            IntPtr error;

            int retValue = 0;

            if (outputName == null || outputName.Length == 0)
                outputName = tempFiles.AddExtension("out");

            if (errorName == null || errorName.Length == 0)
                errorName = tempFiles.AddExtension("err");

            // Create the files
            output = CreateInheritedFile(outputName);
            error = CreateInheritedFile(errorName);

            bool success = false;
            NativeMethods.PROCESS_INFORMATION pi = new NativeMethods.PROCESS_INFORMATION();
            IntPtr primaryToken = IntPtr.Zero;
            GCHandle environmentHandle = new GCHandle();

            try {
                // Output the command line...
                // Make sure the FileStream doesn't own the handle
                FileStream outputStream = new FileStream(output, FileAccess.ReadWrite, false /*ownsHandle*/);
                StreamWriter sw = new StreamWriter(outputStream, Encoding.UTF8);
                sw.Write(currentDir);
                sw.Write("> ");
                // 'true' command line is used in case the command line points to
                // a response file (bug 60374)
                sw.WriteLine(trueCmdLine != null ? trueCmdLine : cmd);
                sw.WriteLine();
                sw.WriteLine();
                sw.Flush();
                outputStream.Close();

                NativeMethods.STARTUPINFO si = new NativeMethods.STARTUPINFO();

                si.cb = Marshal.SizeOf(si);
                si.dwFlags = NativeMethods.STARTF_USESTDHANDLES | NativeMethods.STARTF_USESHOWWINDOW;
                si.wShowWindow = NativeMethods.SW_HIDE;
                si.hStdOutput = output;
                si.hStdError = error;
                si.hStdInput = UnsafeNativeMethods.GetStdHandle(NativeMethods.STD_INPUT_HANDLE);

                //
                // Prepare the environment
                //
                IDictionary environment = new Hashtable();

                // Add the current environment
                foreach (DictionaryEntry entry in Environment.GetEnvironmentVariables())
                    environment.Add(entry.Key, entry.Value);

                // Add the flag to incdicate restricted security in the process
                environment["_ClrRestrictSecAttributes"] = "1";

                // set up the environment block parameter
                IntPtr environmentPtr = (IntPtr)0;
                byte[] environmentBytes = EnvironmentToByteArray(environment);
                environmentHandle = GCHandle.Alloc(environmentBytes, GCHandleType.Pinned);
                environmentPtr = environmentHandle.AddrOfPinnedObject();

                if (userToken == IntPtr.Zero) {
                    success = UnsafeNativeMethods.CreateProcess(
                                                null,       // String lpApplicationName, 
                                                new StringBuilder(cmd), // String lpCommandLine, 
                                                null,       // SECURITY_ATTRIBUTES lpProcessAttributes, 
                                                null,       // SECURITY_ATTRIBUTES lpThreadAttributes, 
                                                true,       // bool bInheritHandles, 
                                                0,          // int dwCreationFlags, 
                                                new HandleRef(null, environmentPtr), // int lpEnvironment, 
                                                currentDir, // String lpCurrentDirectory, 
                                                si,         // STARTUPINFO lpStartupInfo, 
                                                pi);        // PROCESS_INFORMATION lpProcessInformation);
                }
                else {
                    success = UnsafeNativeMethods.DuplicateTokenEx(
                                                new HandleRef(null, userToken),
                                                NativeMethods.TOKEN_ALL_ACCESS,
                                                null,
                                                NativeMethods.IMPERSONATION_LEVEL_SecurityImpersonation,
                                                NativeMethods.TOKEN_TYPE_TokenPrimary,
                                                ref primaryToken
                                                );


                    if (success) {
                        success = UnsafeNativeMethods.CreateProcessAsUser(
                                                    new HandleRef(null, primaryToken),  // int token,
                                                    null,       // String lpApplicationName, 
                                                    cmd,        // String lpCommandLine, 
                                                    null,       // SECURITY_ATTRIBUTES lpProcessAttributes, 
                                                    null,       // SECURITY_ATTRIBUTES lpThreadAttributes, 
                                                    true,       // bool bInheritHandles, 
                                                    0,          // int dwCreationFlags, 
                                                    new HandleRef(null, environmentPtr), // int lpEnvironment, 
                                                    currentDir, // String lpCurrentDirectory, 
                                                    si,         // STARTUPINFO lpStartupInfo, 
                                                    pi);        // PROCESS_INFORMATION lpProcessInformation);

                        if (!success) {
                            UnsafeNativeMethods.CloseHandle(new HandleRef(null, primaryToken));
                            primaryToken = IntPtr.Zero;
                        }
                    }
                }
            }
            finally {

                // free environment block
                if (environmentHandle.IsAllocated)
                    environmentHandle.Free();   

                // Close the file handles
                UnsafeNativeMethods.CloseHandle(new HandleRef(null, output));
                UnsafeNativeMethods.CloseHandle(new HandleRef(null, error));
            }

            if (success) {

                try {
                    int ret = SafeNativeMethods.WaitForSingleObject(new HandleRef(null, pi.hProcess), ProcessTimeOut);

                    // Check for timeout
                    if (ret == NativeMethods.WAIT_TIMEOUT) {
                        throw new ExternalException(SR.GetString(SR.ExecTimeout, cmd), NativeMethods.WAIT_TIMEOUT);
                    }

                    if (ret != NativeMethods.WAIT_OBJECT_0) {
                        throw new ExternalException(SR.GetString(SR.ExecBadreturn, cmd), Marshal.GetLastWin32Error());
                    }

                    // Check the process's exit code
                    int status = NativeMethods.STILL_ACTIVE;
                    if (!UnsafeNativeMethods.GetExitCodeProcess(new HandleRef(null, pi.hProcess), ref status)) {
                        throw new ExternalException(SR.GetString(SR.ExecCantGetRetCode, cmd), Marshal.GetLastWin32Error());
                    }

                    retValue = status;
                }
                finally {
                    UnsafeNativeMethods.CloseHandle(new HandleRef(null, pi.hThread));
                    UnsafeNativeMethods.CloseHandle(new HandleRef(null, pi.hProcess));

                    if (primaryToken != IntPtr.Zero)
                        UnsafeNativeMethods.CloseHandle(new HandleRef(null, primaryToken));
                }
            }
            else {
                throw new ExternalException(SR.GetString(SR.ExecCantExec, cmd), Marshal.GetLastWin32Error());
            }

            return retValue;
        }

        private static byte[] EnvironmentToByteArray(IDictionary sd) {
            // get the keys
            string[] keys = new string[sd.Count];
            sd.Keys.CopyTo(keys, 0);
            
            // get the values
            string[] values = new string[sd.Count];
            sd.Values.CopyTo(values, 0);
            
            // sort both by the keys
            Array.Sort(keys, values, InvariantComparer.Default);

            // create a list of null terminated "key=val" strings
            StringBuilder stringBuff = new StringBuilder();
            for (int i = 0; i < sd.Count; ++ i) {
                stringBuff.Append(keys[i]);
                stringBuff.Append('=');
                stringBuff.Append(values[i]);
                stringBuff.Append('\0');
            }
            // an extra null at the end indicates end of list.
            stringBuff.Append('\0');
            
            int byteCount = stringBuff.Length;
            byte[] bytes = Encoding.Default.GetBytes(stringBuff.ToString());
                        
            return bytes;
        }

        internal static bool RevertImpersonation(IntPtr userToken,ref IntPtr impersonatedToken) {
            bool needToReimpersonate = false;

            // Undo any current impersonation, and reimpersonate
            if (UnsafeNativeMethods.OpenThreadToken(
                            new HandleRef(null, UnsafeNativeMethods.GetCurrentThread()),
                            NativeMethods.TOKEN_READ | NativeMethods.TOKEN_IMPERSONATE,
                            true,
                            ref impersonatedToken)) {

                    // got the currenly impersonated token -- revert and reimpersonate later
                    if (UnsafeNativeMethods.RevertToSelf()) {
                        needToReimpersonate = true;
                    }
            }

            return needToReimpersonate;	
        }

        internal static void ReImpersonate(IntPtr impersonatedToken, bool needToImpersonate) {
            bool success = false;

            if (needToImpersonate)
                success = UnsafeNativeMethods.SetThreadToken(NativeMethods.NullHandleRef, new HandleRef(null, impersonatedToken));
            else
                success = true;

            // close the token before error check (and possible exception)
            // could be that there is a token but Revert failed and thus needToReimpersonate is false
            if (impersonatedToken != IntPtr.Zero)
                UnsafeNativeMethods.CloseHandle(new HandleRef(null, impersonatedToken));

            // reimpersonation failure is rare but bad - the thread is left in wrong state
            if (!success)
                throw new ExternalException(SR.GetString(SR.ExecCantRevert), Marshal.GetLastWin32Error());
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\compiler\generatorsupport.cs ===
//------------------------------------------------------------------------------
// <copyright file="GeneratorSupport.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom.Compiler {
    
    using System.ComponentModel;

    /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
        Flags,
        Serializable,
    ]
    public enum GeneratorSupport {
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.ArraysOfArrays"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ArraysOfArrays = 0x1,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.EntryPointMethod"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EntryPointMethod = 0x2,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.GotoStatements"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        GotoStatements = 0x4,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.MultidimensionalArrays"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        MultidimensionalArrays = 0x8,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.StaticConstructors"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        StaticConstructors = 0x10,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.TryCatchStatements"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        TryCatchStatements = 0x20,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.ReturnTypeAttributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ReturnTypeAttributes = 0x40,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.DeclareValueTypes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DeclareValueTypes = 0x80,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.DeclareEnums"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DeclareEnums = 0x0100,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.DeclareDelegates"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DeclareDelegates = 0x0200,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.DeclareInterfaces"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DeclareInterfaces = 0x0400,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.DeclareEvents"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        DeclareEvents = 0x0800,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.AssemblyAttributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        AssemblyAttributes = 0x1000,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.ParameterAttributes"]/*' />
        /// <devdoc>
        ///    <para>Supports custom metadata attributes declared on parameters for methods and constructors. Allows
        ///          use of CodeParameterDeclarationExpress.CustomAttributes.</para>
        /// </devdoc>
        ParameterAttributes = 0x2000,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.ReferenceParameters"]/*' />
        /// <devdoc>
        ///    <para>Supports declaring and calling parameters with a FieldDirection of Out or Ref, meaning that
        ///          the value is a type of reference parameter.</para>
        /// </devdoc>
        ReferenceParameters = 0x4000,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.ChainedConstructorArguments"]/*' />
        /// <devdoc>
        ///    <para>Supports contructors that call other constructors within the same class. Allows use of the 
        ///          CodeConstructor.ChainedConstructorArgs collection.</para>
        /// </devdoc>
        ChainedConstructorArguments = 0x8000,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.NestedTypes"]/*' />
        /// <devdoc>
        ///    <para>Supports declaring types that are nested within other types. This allows the insertion of a 
        ///          CodeTypeReference into the Members collection of another CodeTypeReference.</para>
        /// </devdoc>
        NestedTypes = 0x00010000,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.MultipleInterfaceMembers"]/*' />
        /// <devdoc>
        ///    <para>Supports declaring methods, properties or events that simultaneously implement more than one interface of
        ///          a type that have a matching name. This allows insertion of more than one entry into the ImplementationTypes 
        ///          collection or CodeMemberProperty, CodeMemberMethod and CodeMemberEvent.</para>
        /// </devdoc>
        MultipleInterfaceMembers = 0x00020000,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.PublicStaticMembers"]/*' />
        /// <devdoc>
        ///    <para>Supports the declaration of public static fields, properties, methods and events. This allows use of 
        ///          MemberAttributes.Static in combination with access values other than MemberAttributes.Private.</para>
        /// </devdoc>
        PublicStaticMembers = 0x00040000,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.ComplexExpressions"]/*' />
        /// <devdoc>
        ///    <para>Supports the generation arbitarily nested expressions. Not all generators may be able to deal with 
        ///          multiple function calls or binary operations in the same expression. Without this, CodeMethodInvokeExpression and
        ///          CodeBinaryOperatorExpression should only be used (a) as the Right value of a CodeAssignStatement or (b) in a
        ///          CodeExpressionStatement.</para>
        /// </devdoc>
        ComplexExpressions = 0x00080000,
        /// <include file='doc\GeneratorSupport.uex' path='docs/doc[@for="GeneratorSupport.Win32Resources"]/*' />
        /// <devdoc>
        ///    <para>Supports linking with Win32 resources.</para>
        /// </devdoc>
        Win32Resources = 0x00100000,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\compiler\icodeparser.cs ===
//------------------------------------------------------------------------------
// <copyright file="ICodeParser.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom.Compiler {

    using System.Diagnostics;
    using System.IO;

    /// <include file='doc\ICodeParser.uex' path='docs/doc[@for="ICodeParser"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides a code parsing interface.
    ///    </para>
    /// </devdoc>
    public interface ICodeParser {
    
        /// <include file='doc\ICodeParser.uex' path='docs/doc[@for="ICodeParser.Parse"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compiles the given text stream into a CodeCompile unit.  
        ///    </para>
        /// </devdoc>
        CodeCompileUnit Parse(TextReader codeStream);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\compiler\indenttextwriter.cs ===
//------------------------------------------------------------------------------
// <copyright file="IndentTextWriter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom.Compiler {

    using System.Diagnostics;
    using System;
    using System.IO;
    using System.Text;
    using System.Security.Permissions;

    /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter"]/*' />
    /// <devdoc>
    ///    <para>Provides a text writer that can indent new lines by a tabString token.</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public class IndentedTextWriter : TextWriter {
        private TextWriter writer;
        private int indentLevel;
        private bool tabsPending;
        private string tabString;

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.DefaultTabString"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public const string DefaultTabString = "    ";

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.IndentedTextWriter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.Compiler.IndentedTextWriter'/> using the specified
        ///       text writer and default tab string.
        ///    </para>
        /// </devdoc>
        public IndentedTextWriter(TextWriter writer) : this(writer, DefaultTabString) {
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.IndentedTextWriter1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of <see cref='System.CodeDom.Compiler.IndentedTextWriter'/> using the specified
        ///       text writer and tab string.
        ///    </para>
        /// </devdoc>
        public IndentedTextWriter(TextWriter writer, string tabString) {
            this.writer = writer;
            this.tabString = tabString;
            indentLevel = 0;
            tabsPending = false;
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.Encoding"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override Encoding Encoding {
            get {
                return writer.Encoding;
            }
        }
                                                
        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.NewLine"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the new line character to use.
        ///    </para>
        /// </devdoc>
        public override string NewLine {
            get {
                return writer.NewLine;
            }

            set {
                writer.NewLine = value;
            }
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.Indent"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the number of spaces to indent.
        ///    </para>
        /// </devdoc>
        public int Indent {
            get {
                return indentLevel;
            }
            set {
                Debug.Assert(value >= 0, "Bogus Indent... probably caused by mismatched Indent++ and Indent--");
                if (value < 0) {
                    value = 0;
                }
                indentLevel = value;
            }
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.InnerWriter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the TextWriter to use.
        ///    </para>
        /// </devdoc>
        public TextWriter InnerWriter {
            get {
                return writer;
            }
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.Close"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Closes the document being written to.
        ///    </para>
        /// </devdoc>
        public override void Close() {
            writer.Close();
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.Flush"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void Flush() {
            writer.Flush();
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.OutputTabs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual void OutputTabs() {
            if (tabsPending) {
                for (int i=0; i < indentLevel; i++) {
                    writer.Write(tabString);
                }
                tabsPending = false;
            }
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.Write"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes a string
        ///       to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(string s) {
            OutputTabs();
            writer.Write(s);
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.Write1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of a Boolean value to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(bool value) {
            OutputTabs();
            writer.Write(value);
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.Write2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes a character to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(char value) {
            OutputTabs();
            writer.Write(value);
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.Write3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes a
        ///       character array to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(char[] buffer) {
            OutputTabs();
            writer.Write(buffer);
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.Write4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes a subarray
        ///       of characters to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(char[] buffer, int index, int count) {
            OutputTabs();
            writer.Write(buffer, index, count);
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.Write5"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of a Double to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(double value) {
            OutputTabs();
            writer.Write(value);
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.Write6"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of
        ///       a Single to the text
        ///       stream.
        ///    </para>
        /// </devdoc>
        public override void Write(float value) {
            OutputTabs();
            writer.Write(value);
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.Write7"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of an integer to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(int value) {
            OutputTabs();
            writer.Write(value);
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.Write8"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of an 8-byte integer to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(long value) {
            OutputTabs();
            writer.Write(value);
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.Write9"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of an object
        ///       to the text stream.
        ///    </para>
        /// </devdoc>
        public override void Write(object value) {
            OutputTabs();
            writer.Write(value);
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.Write10"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes out a formatted string, using the same semantics as specified.
        ///    </para>
        /// </devdoc>
        public override void Write(string format, object arg0) {
            OutputTabs();
            writer.Write(format, arg0);
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.Write11"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes out a formatted string,
        ///       using the same semantics as specified.
        ///    </para>
        /// </devdoc>
        public override void Write(string format, object arg0, object arg1) {
            OutputTabs();
            writer.Write(format, arg0, arg1);
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.Write12"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes out a formatted string,
        ///       using the same semantics as specified.
        ///    </para>
        /// </devdoc>
        public override void Write(string format, params object[] arg) {
            OutputTabs();
            writer.Write(format, arg);
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.WriteLineNoTabs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the specified
        ///       string to a line without tabs.
        ///    </para>
        /// </devdoc>
        public void WriteLineNoTabs(string s) {
            writer.WriteLine(s);
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.WriteLine"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the specified string followed by
        ///       a line terminator to the text stream.
        ///    </para>
        /// </devdoc>
        public override void WriteLine(string s) {
            OutputTabs();
            writer.WriteLine(s);
            tabsPending = true;
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.WriteLine1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes a line terminator.
        ///    </para>
        /// </devdoc>
        public override void WriteLine() {
            OutputTabs();
            writer.WriteLine();
            tabsPending = true;
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.WriteLine2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Writes the text representation of a Boolean followed by a line terminator to
        ///       the text stream.
        ///    </para>
        /// </devdoc>
        public override void WriteLine(bool value) {
            OutputTabs();
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.WriteLine3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(char value) {
            OutputTabs();
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.WriteLine4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(char[] buffer) {
            OutputTabs();
            writer.WriteLine(buffer);
            tabsPending = true;
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.WriteLine5"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(char[] buffer, int index, int count) {
            OutputTabs();
            writer.WriteLine(buffer, index, count);
            tabsPending = true;
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.WriteLine6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(double value) {
            OutputTabs();
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.WriteLine7"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(float value) {
            OutputTabs();
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.WriteLine8"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(int value) {
            OutputTabs();
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.WriteLine9"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(long value) {
            OutputTabs();
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.WriteLine10"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(object value) {
            OutputTabs();
            writer.WriteLine(value);
            tabsPending = true;
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.WriteLine11"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(string format, object arg0) {
            OutputTabs();
            writer.WriteLine(format, arg0);
            tabsPending = true;
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.WriteLine12"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(string format, object arg0, object arg1) {
            OutputTabs();
            writer.WriteLine(format, arg0, arg1);
            tabsPending = true;
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.WriteLine13"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override void WriteLine(string format, params object[] arg) {
            OutputTabs();
            writer.WriteLine(format, arg);
            tabsPending = true;
        }

        /// <include file='doc\IndentTextWriter.uex' path='docs/doc[@for="IndentedTextWriter.WriteLine14"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        [CLSCompliant(false)]
        public override void WriteLine(UInt32 value) {
            OutputTabs();
            writer.WriteLine(value);
            tabsPending = true;
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\compiler\languageoptions.cs ===
//------------------------------------------------------------------------------
// <copyright file="LanguageOptions.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom.Compiler {
    
    /// <include file='doc\LanguageOptions.uex' path='docs/doc[@for="LanguageOptions"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [
        Flags,
        Serializable,
    ]
    public enum LanguageOptions {
        /// <include file='doc\LanguageOptions.uex' path='docs/doc[@for="LanguageOptions.None"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        None = 0x0,
        /// <include file='doc\LanguageOptions.uex' path='docs/doc[@for="LanguageOptions.CaseInsensitive"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        CaseInsensitive = 0x1,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\collections\specialized\fixedstringlookup.cs ===
//------------------------------------------------------------------------------
// <copyright file="FixedStringLookup.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Collections.Specialized {

    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.Globalization;
    
    // This class provides a very efficient way to lookup an entry in a list of strings,
    // providing that they are declared in a particular way.
    
    // It requires the set of strings to be orderded into an array of arrays of strings.
    // The first indexer must the length of the string, so that each sub-array is of the
    // same length. The contained array must be in alphabetical order. Furthermore, if the 
    // table is to be searched case-insensitively, the strings must all be lower case.
    internal class FixedStringLookup {
        
        // Returns whether the match is found in the lookup table
        internal static bool Contains(string[][] lookupTable, string value, bool ignoreCase) {
            int length = value.Length;
            if (length <= 0 || length - 1 >= lookupTable.Length) {
                return false;
            }

            string[] subArray = lookupTable[length - 1];
            if (subArray == null) {
                return false;
            }
            return Contains(subArray, value, ignoreCase);            
        }

#if DEBUG

        internal static void VerifyLookupTable(string[][] lookupTable, bool ignoreCase) {
            for (int i = 0; i < lookupTable.Length; i++) {
                string[] subArray = lookupTable[i];
                if (subArray != null) {
                    string lastValue = null;
                    for (int j = 0; j < subArray.Length; j++) {
                        string value = subArray[j];
                        // Must all be the length of the hashed position
                        Debug.Assert(value.Length == i + 1);
                        if (lastValue != null) {
                            // Must be sorted within the sub array;
                            Debug.Assert(string.Compare(lastValue, value, ignoreCase, CultureInfo.InvariantCulture) < 0);
                        }
                        lastValue = value;
                    }
                }
            }
        }

#endif

        // This routine finds a hit within a single sorted array, with the assumption that the
        // value and all the strings are of the same length.
        private static bool Contains(string[] array, string value, bool ignoreCase) {
            int min = 0;
            int max = array.Length;
            int pos = 0;
            char searchChar;
            while (pos < value.Length) {            
                if (ignoreCase) {
                    searchChar = char.ToLower(value[pos], CultureInfo.CurrentCulture);
                } else {
                    searchChar = value[pos];
                }
                if ((max - min) <= 1) {
                    // we are down to a single item, so we can stay on this row until the end.
                    if (searchChar != array[min][pos]) {
                        return false;
                    }
                    pos++;
                    continue;
                }

                // There are multiple items to search, use binary search to find one of the hits
                if (!FindCharacter(array, searchChar, pos, ref min, ref max)) {
                    return false;
                }
                // and move to next char
                pos++;
            }
            return true;
        }

        // Do a binary search on the character array at the specific position and constrict the ranges appropriately.
        private static bool FindCharacter(string[] array, char value, int pos, ref int min, ref int max) {
            int index = min;
            while (min < max) {
                index = (min + max) / 2;
                char comp = array[index][pos];
                if (value == comp) {
                    // We have a match. Now adjust to any adjacent matches
                    int newMin = index;
                    while (newMin > min && array[newMin - 1][pos] == value) {
                        newMin--;
                    }
                    min = newMin;

                    int newMax = index + 1;
                    while (newMax < max && array[newMax][pos] == value) {
                        newMax++;
                    }
                    max = newMax;
                    return true;
                }
                if (value < comp) {
                    max = index;
                }
                else {
                    min = index + 1;
                }
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\collections\specialized\bitvector32.cs ===
//------------------------------------------------------------------------------
// <copyright file="BitVector32.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Collections.Specialized {

    using System.Diagnostics;
    using System.Text;
    using System;
    using Microsoft.Win32;

    /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32"]/*' />
    /// <devdoc>
    ///    <para>Provides a simple light bit vector with easy integer or Boolean access to
    ///       a 32 bit storage.</para>
    /// </devdoc>
    public struct BitVector32 {
        private uint data;

        /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32.BitVector32"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the BitVector32 structure with the specified internal data.</para>
        /// </devdoc>
        public BitVector32(int data) {
            this.data = (uint)data;
        }

        /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32.BitVector321"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the BitVector32 structure with the information in the specified 
        ///    value.</para>
        /// </devdoc>
        public BitVector32(BitVector32 value) {
            this.data = value.data;
        }

        /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32.this"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets a value indicating whether all the specified bits are set.</para>
        /// </devdoc>
        public bool this[int bit] {
            get {
                return (data & bit) == bit;
            }
            set {
                if (value) {
                    data |= (uint)bit;
                }
                else {
                    data &= ~(uint)bit;
                }
            }
        }

        /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32.this1"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the value for the specfied section.</para>
        /// </devdoc>
        public int this[Section section] {
            get {
                return (int)((data & (uint)(section.Mask << section.Offset)) >> section.Offset);
            }
            set {
#if DEBUG
                if ((value & section.Mask) != value) {
                    Debug.Fail("Value out of bounds on BitVector32 Section Set!");
                }
#endif
                value <<= section.Offset;
                int offsetMask = (0xFFFF & (int)section.Mask) << section.Offset;
                data = (data & ~(uint)offsetMask) | ((uint)value & (uint)offsetMask);
            }
        }

        /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32.Data"]/*' />
        /// <devdoc>
        ///    returns the raw data stored in this bit vector...
        /// </devdoc>
        public int Data {
            get {
                return (int)data;
            }
        }

        private static short CountBitsSet(short mask) {

            // yes, I know there are better algorythms, however, we know the
            // bits are always right aligned, with no holes (i.e. always 00000111,
            // never 000100011), so this is just fine...
            //
            short value = 0;
            while ((mask & 0x1) != 0) {
                value++;
                mask >>= 1;
            }
            return value;
        }

        /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32.CreateMask"]/*' />
        /// <devdoc>
        ///    <para> Creates the first mask in a series.</para>
        /// </devdoc>
        public static int CreateMask() {
            return CreateMask(0);
        }

        /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32.CreateMask1"]/*' />
        /// <devdoc>
        ///     Creates the next mask in a series.
        /// </devdoc>
        public static int CreateMask(int previous) {
            if (previous == 0) {
                return 1;
            }

            if (previous == unchecked((int)0x80000000)) {
                throw new InvalidOperationException(SR.GetString(SR.BitVectorFull));
            }

            return previous << 1;
        }

        /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32.CreateMaskFromHighValue"]/*' />
        /// <devdoc>
        ///     Given a highValue, creates the mask
        /// </devdoc>
        private static short CreateMaskFromHighValue(short highValue) {
            short required = 16;
            while ((highValue & 0x8000) == 0) {
                required--;
                highValue <<= 1;
            }

            ushort value = 0;
            while (required > 0) {
                required--;
                value <<= 1;
                value |= 0x1;
            }

            return unchecked((short) value);
        }

        /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32.CreateSection"]/*' />
        /// <devdoc>
        ///    <para>Creates the first section in a series, with the specified maximum value.</para>
        /// </devdoc>
        public static Section CreateSection(short maxValue) {
            return CreateSectionHelper(maxValue, 0, 0);
        }

        /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32.CreateSection1"]/*' />
        /// <devdoc>
        ///    <para>Creates the next section in a series, with the specified maximum value.</para>
        /// </devdoc>
        public static Section CreateSection(short maxValue, Section previous) {
            return CreateSectionHelper(maxValue, previous.Mask, previous.Offset);
        }

        private static Section CreateSectionHelper(short maxValue, short priorMask, short priorOffset) {
            if (maxValue < 1) {
                throw new ArgumentException("maxValue");
            }
#if DEBUG
            int maskCheck = CreateMaskFromHighValue(maxValue);
            int offsetCheck = priorOffset + CountBitsSet(priorMask);
            Debug.Assert(maskCheck <= short.MaxValue && offsetCheck < 32, "Overflow on BitVector32");
#endif
            short offset = (short)(priorOffset + CountBitsSet(priorMask));
            if (offset >= 32) {
                throw new InvalidOperationException(SR.GetString(SR.BitVectorFull));
            }
            return new Section(CreateMaskFromHighValue(maxValue), offset);
        }
        
        /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32.Equals"]/*' />
        public override bool Equals(object o) {
            if (!(o is BitVector32)) {
                return false;
            }
            
            return data == ((BitVector32)o).data;
        }

        /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32.GetHashCode"]/*' />
        public override int GetHashCode() {
            return base.GetHashCode();
        }

        /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public static string ToString(BitVector32 value) {
            StringBuilder sb = new StringBuilder(/*"BitVector32{".Length*/12 + /*32 bits*/32 + /*"}".Length"*/1);
            sb.Append("BitVector32{");
            int locdata = (int)value.data;
            for (int i=0; i<32; i++) {
                if ((locdata & 0x80000000) != 0) {
                    sb.Append("1");
                }
                else {
                    sb.Append("0");
                }
                locdata <<= 1;
            }
            sb.Append("}");
            return sb.ToString();
        }

        /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32.ToString1"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override string ToString() {
            return BitVector32.ToString(this);
        }

        /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32.Section"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Represents an section of the vector that can contain a integer number.</para>
        /// </devdoc>
        public struct Section {
            private readonly short mask;
            private readonly short offset;

            internal Section(short mask, short offset) {
                this.mask = mask;
                this.offset = offset;
            }

            /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32.Section.Mask"]/*' />
            /// <internalonly/>
            public short Mask {
                get {
                    return mask;
                }
            }

            /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32.Section.Offset"]/*' />
            /// <internalonly/>
            public short Offset {
                get {
                    return offset;
                }
            }
            
            /// <include file='doc\BitVector32.uex' path='docs/doc[@for="Section.Equals"]/*' />
            /// <internalonly/>
            public override bool Equals(object o) {
                if (!(o is Section)) {
                    return false;
                }
                
                Section s = (Section)o;
                return mask == s.mask && offset == s.offset;
            }
            
            /// <include file='doc\BitVector32.uex' path='docs/doc[@for="Section.GetHashCode"]/*' />
            /// <internalonly/>
            public override int GetHashCode() {
                return base.GetHashCode();
            }

            /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32.Section.ToString"]/*' />
            /// <internalonly/>
            /// <devdoc>
            /// </devdoc>
            public static string ToString(Section value) {
                return "Section{0x" + Convert.ToString(value.Mask, 16) + ", 0x" + Convert.ToString(value.Offset, 16) + "}";
            }

            /// <include file='doc\BitVector32.uex' path='docs/doc[@for="BitVector32.Section.ToString1"]/*' />
            /// <internalonly/>
            /// <devdoc>
            /// </devdoc>
            public override string ToString() {
                return Section.ToString(this);
            }

        }
    }
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\collections\specialized\hybriddictionary.cs ===
//------------------------------------------------------------------------------
// <copyright file="HybridDictionary.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Collections.Specialized {

    using System.Collections;
    using System.Globalization;

    /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary"]/*' />
    /// <devdoc>
    ///  <para> 
    ///    This data structure implements IDictionary first using a linked list
    ///    (ListDictionary) and then switching over to use Hashtable when large. This is recommended
    ///    for cases where the number of elements in a dictionary is unknown and might be small.
    ///
    ///    It also has a single boolean parameter to allow case-sensitivity that is not affected by
    ///    ambient culture and has been optimized for looking up case-insensitive symbols
    ///  </para>
    /// </devdoc>
    [Serializable]
    public class HybridDictionary: IDictionary {

        // These numbers have been carefully tested to be optimal. Please don't change them
        // without doing thorough performance testing.
        private const int CutoverPoint = 9;
        private const int InitialHashtableSize = 13;
        private const int FixedSizeCutoverPoint = 6;


        private static IHashCodeProvider hashCodeProvider;
        private static IComparer comparer;

        private static IHashCodeProvider HashCodeProvider {
            get {
                if (hashCodeProvider == null) {
                    hashCodeProvider = new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture);
                }
                return hashCodeProvider;
            }
        }

        private static IComparer Comparer {
            get {
                if (comparer == null) {
                    comparer = new SymbolEqualComparer();
                }
                return comparer;
            }
        }

        // Instance variables. This keeps the HybridDictionary very light-weight when empty
        private ListDictionary list;
        private Hashtable hashtable;
        private bool caseInsensitive;

        /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary.HybridDictionary1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public HybridDictionary() {
        }

        /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary.HybridDictionary2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public HybridDictionary(int initialSize) : this(initialSize, false) {
        }

        /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary.HybridDictionary3"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public HybridDictionary(bool caseInsensitive) {
            this.caseInsensitive = caseInsensitive;
        }

        /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary.HybridDictionary4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public HybridDictionary(int initialSize, bool caseInsensitive) {
            this.caseInsensitive = caseInsensitive;
            if (initialSize >= FixedSizeCutoverPoint) {
                if (caseInsensitive) {
                    hashtable = new Hashtable(initialSize, HashCodeProvider, Comparer);
                } else {
                    hashtable = new Hashtable(initialSize);
                }
            }
        }

        /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object this[object key] {
            get {
                if (hashtable != null) {
                    return hashtable[key];
                } else if (list != null) {
                    return list[key];
                } else {
                    if (key == null) {
                        throw new ArgumentNullException("key", SR.GetString(SR.ArgumentNull_Key));
                    }
                    return null;
                }
            }
            set {
                if (hashtable != null) {
                    hashtable[key] = value;
                } 
                else if (list != null) {
                    if (list.Count >= CutoverPoint - 1) {
                        ChangeOver();
                        hashtable[key] = value;
                    } else {
                        list[key] = value;
                    }
                }
                else {
                    list = new ListDictionary(caseInsensitive ? Comparer : null);
                    list[key] = value;
                }
            }
        }

        private ListDictionary List {
            get {
                if (list == null) {
                    list = new ListDictionary(caseInsensitive ? Comparer : null);
                }
                return list;
            }
        }

        private void ChangeOver() {
            IDictionaryEnumerator en = list.GetEnumerator();
            if (caseInsensitive) {
                hashtable = new Hashtable(InitialHashtableSize, HashCodeProvider, Comparer);
            } else {
                hashtable = new Hashtable(InitialHashtableSize);
            }
            while (en.MoveNext()) {
                hashtable.Add(en.Key, en.Value);
            }
            list = null;
        }

        /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary.Count"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Count {
            get {
                if (hashtable != null) {
                    return hashtable.Count;
                } else if (list != null) {
                    return list.Count;
                } else {
                    return 0;
                }
            }
        }   

        /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary.Keys"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICollection Keys {
            get {
                if (hashtable != null) {
                    return hashtable.Keys;
                } else {
                    return List.Keys;
                } 
            }
        }

        /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary.IsFixedSize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsFixedSize {
            get {
                return false;
            }
        }

        /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary.IsSynchronized"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object SyncRoot {
            get {
                return this;
            }
        }

        /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary.Values"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICollection Values {
            get {
                if (hashtable != null) {
                    return hashtable.Values;
                } else {
                    return List.Values;
                } 
            }
        }

        /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(object key, object value) {
            if (hashtable != null) {
                hashtable.Add(key, value);
            } else {
                if (list == null) {
                    list = new ListDictionary(caseInsensitive ? Comparer : null);
                    list.Add(key, value); 
                }
                else {
                    if (list.Count + 1 >= CutoverPoint) {
                        ChangeOver();
                        hashtable.Add(key, value);
                    } else {
                        list.Add(key, value); 
                    }
                }
            }
        }

        /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary.Clear"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Clear() {
            hashtable = null;
            list = null;
        }

        /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(object key) {
            if (hashtable != null) {
                return hashtable.Contains(key);
            } else if (list != null) {
                return list.Contains(key);
            } else {
                return false;
            }
        }

        /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Array array, int index)  {
            if (hashtable != null) {
                hashtable.CopyTo(array, index);
            } else {
                List.CopyTo(array, index);
            } 
        }

        /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary.GetEnumerator1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IDictionaryEnumerator GetEnumerator() {
            if (hashtable != null) {
                return hashtable.GetEnumerator();
            } 
            if (list == null) {
                list = new ListDictionary(caseInsensitive ? Comparer : null);
            }
            return list.GetEnumerator();
        }

        /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary.GetEnumerator2"]/*' />
        /// <devdoc>
        /// <para>[To be supplied.]</para>
        /// </devdoc>
        IEnumerator IEnumerable.GetEnumerator() {
            if (hashtable != null) {
                return hashtable.GetEnumerator();
            } 
            if (list == null) {
                list = new ListDictionary(caseInsensitive ? Comparer : null);
            }
            return list.GetEnumerator();
        }

        /// <include file='doc\HybridDictionary.uex' path='docs/doc[@for="HybridDictionary.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(object key) {
            if (hashtable != null) {
                hashtable.Remove(key);
            } else {
                List.Remove(key);
            } 
        }

        /// <devdoc>
        ///  <para> 
        ///    This implements a comparison that only 
        ///    checks for equalilty, so this should only be used in un-sorted data
        ///    structures like Hastable and ListDictionary. This is a little faster
        ///    than using CaseInsensitiveComparer because it does a strict character by 
        ///    character equality chech rather than a sorted comparison. It should also only be
        ///    used for symbols and not regular text.
        ///  </para>
        /// </devdoc>
        private class SymbolEqualComparer: IComparer {

            int IComparer.Compare(object keyLeft, object keyRight) {

                string sLeft = keyLeft as string;
                string sRight = keyRight as string;
                if (sLeft == null) {
                    throw new ArgumentException("keyLeft");
                }
                if (sRight == null) {
                    throw new ArgumentException("keyRight");
                }
                int lLeft = sLeft.Length;
                int lRight = sRight.Length;
                if (lLeft != lRight) {
                    return 1;
                }
                for (int i = 0; i < lLeft; i++) {
                    char charLeft = sLeft[i];
                    char charRight = sRight[i];
                    if (charLeft == charRight) {
                        continue;
                    }
                    UnicodeCategory catLeft = Char.GetUnicodeCategory(charLeft);
                    UnicodeCategory catRight = Char.GetUnicodeCategory(charRight);
                    if (catLeft == UnicodeCategory.UppercaseLetter 
                        && catRight == UnicodeCategory.LowercaseLetter) {
                        if (Char.ToLower(charLeft, CultureInfo.InvariantCulture) == charRight) {
                            continue;
                        }
                    } else if (catRight == UnicodeCategory.UppercaseLetter 
                        && catLeft == UnicodeCategory.LowercaseLetter){
                        if (Char.ToLower(charRight, CultureInfo.InvariantCulture) == charLeft) {
                            continue;
                        }
                    }
                    return 1;
                }
                return 0;        
            }
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\collections\specialized\collectionsutil.cs ===
/*
 * Wrapper for a case insensitive Hashtable.
 * Should live in BCL.
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Collections.Specialized {

    using System.Collections;

    /// <include file='doc\CollectionsUtil.uex' path='docs/doc[@for="CollectionsUtil"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class CollectionsUtil {

        /// <include file='doc\CollectionsUtil.uex' path='docs/doc[@for="CollectionsUtil.CreateCaseInsensitiveHashtable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Hashtable CreateCaseInsensitiveHashtable()  {
            return new Hashtable(CaseInsensitiveHashCodeProvider.Default, CaseInsensitiveComparer.Default);
        }

        /// <include file='doc\CollectionsUtil.uex' path='docs/doc[@for="CollectionsUtil.CreateCaseInsensitiveHashtable1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Hashtable CreateCaseInsensitiveHashtable(int capacity)  {
            return new Hashtable(capacity, CaseInsensitiveHashCodeProvider.Default, CaseInsensitiveComparer.Default);
        }

        /// <include file='doc\CollectionsUtil.uex' path='docs/doc[@for="CollectionsUtil.CreateCaseInsensitiveHashtable2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static Hashtable CreateCaseInsensitiveHashtable(IDictionary d)  {
            return new Hashtable(d, CaseInsensitiveHashCodeProvider.Default, CaseInsensitiveComparer.Default);
        }

        /// <include file='doc\CollectionsUtil.uex' path='docs/doc[@for="CollectionsUtil.CreateCaseInsensitiveSortedList"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static SortedList CreateCaseInsensitiveSortedList() {
            return new SortedList(CaseInsensitiveComparer.Default);
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\codedom\compiler\tempfiles.cs ===
//------------------------------------------------------------------------------
// <copyright file="TempFiles.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.CodeDom.Compiler {
    using System;
    using System.Collections;
    using System.Diagnostics;
    using System.IO;
    using System.Runtime.InteropServices;
    using System.Text;
    using Microsoft.Win32;
    using System.Security;
    using System.Security.Permissions;
    using System.Security.Cryptography;
    using System.Globalization;

    /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection"]/*' />
    /// <devdoc>
    ///    <para>Represents a collection of temporary file names that are all based on a
    ///       single base filename located in a temporary directory.</para>
    /// </devdoc>
    [PermissionSet(SecurityAction.LinkDemand, Name="FullTrust")]
    [PermissionSet(SecurityAction.InheritanceDemand, Name="FullTrust")]
    public class TempFileCollection : ICollection, IDisposable {
        private static RNGCryptoServiceProvider rng;

        string basePath;
        string tempDir;
        bool keepFiles;
        Hashtable files = new Hashtable();

        static TempFileCollection() {
            // Since creating the random generator can be expensive, only do it once
            rng = new RNGCryptoServiceProvider();
        }

        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.TempFileCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TempFileCollection() : this(null, false) { 
        }

        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.TempFileCollection1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TempFileCollection(string tempDir) : this(tempDir, false) { 
        }

        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.TempFileCollection2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public TempFileCollection(string tempDir, bool keepFiles) {
            this.keepFiles = keepFiles;
            this.tempDir = tempDir;
        }

        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.IDisposable.Dispose"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// <para> To allow it's stuff to be cleaned up</para>
        /// </devdoc>
        void IDisposable.Dispose() {
            GC.SuppressFinalize(this);
            Dispose(true);
        }
        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.Dispose"]/*' />
        protected virtual void Dispose(bool disposing) {
            // It is safe to call Delete from here even if Dispose is called from Finalizer
            // because the graph of objects is guaranteed to be there and
            // neither Hashtable nor String have a finalizer of their own that could 
            // be called before TempFileCollection Finalizer
            Delete();
        }

        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.Finalize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ~TempFileCollection() {
            Dispose(false);
        }

        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.AddExtension"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string AddExtension(string fileExtension) {
            return AddExtension(fileExtension, keepFiles);
        }

        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.AddExtension1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string AddExtension(string fileExtension, bool keepFile) {
            if (fileExtension == null || fileExtension.Length == 0)
                throw new ArgumentException(SR.GetString(SR.InvalidNullEmptyArgument, "fileExtension"), "fileExtension");  // fileExtension not specified
            string fileName = BasePath + "." + fileExtension;
            AddFile(fileName, keepFile);
            return fileName;
        }

        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.AddFile"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddFile(string fileName, bool keepFile) {
            if (fileName == null || fileName.Length == 0)
                throw new ArgumentException(SR.GetString(SR.InvalidNullEmptyArgument, "fileName"), "fileName");  // fileName not specified
            fileName = fileName.ToLower(CultureInfo.InvariantCulture);
            if (files[fileName] != null) 
                throw new ArgumentException(SR.GetString(SR.DuplicateFileName, fileName), "fileName");  // duplicate fileName
            files.Add(fileName, (object)keepFile);
        }

        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return files.Keys.GetEnumerator();
        }

        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator() {
            return files.Keys.GetEnumerator();
        }

        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.ICollection.CopyTo"]/*' />
        /// <internalonly/>
        void ICollection.CopyTo(Array array, int start) {
            files.Keys.CopyTo(array, start);
        }

        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(string[] fileNames, int start) {
            files.Keys.CopyTo(fileNames, start);
        }

        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Count {
            get {
                return files.Count;
            }
        }

        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.ICollection.Count"]/*' />
        /// <internalonly/>
        int ICollection.Count {
            get { return files.Count; }
        }

        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.ICollection.SyncRoot"]/*' />
        /// <internalonly/>
        object ICollection.SyncRoot {
            get { return null; }
        }

        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.ICollection.IsSynchronized"]/*' />
        /// <internalonly/>
        bool ICollection.IsSynchronized {
            get { return false; }
        }

        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.TempDir"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string TempDir {
            get { return tempDir == null ? string.Empty : tempDir; }
        }
                                              
        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.BasePath"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string BasePath {
            get {
                EnsureTempNameCreated();
                return basePath;
            }
        }

        void EnsureTempNameCreated() {
            if (basePath == null) {
                basePath = GetTempFileName(TempDir);

                string full = basePath;
                new EnvironmentPermission(PermissionState.Unrestricted).Assert();
                try {
                    full = Path.GetFullPath(basePath);
                }
                finally {
                    CodeAccessPermission.RevertAssert();
                }

                new FileIOPermission(FileIOPermissionAccess.AllAccess, full).Demand();
            }
        }

        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.KeepFiles"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool KeepFiles {
            get { return keepFiles; }
            set { keepFiles = value; }
        }

        bool KeepFile(string fileName) {
            object keep = files[fileName];
            if (keep == null) return false;
            return (bool)keep; 
        }

        /// <include file='doc\TempFiles.uex' path='docs/doc[@for="TempFileCollection.Delete"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Delete() {
            string[] fileNames = new string[files.Count];
            files.Keys.CopyTo(fileNames, 0);
            foreach (string fileName in fileNames) {
                if (!KeepFile(fileName)) {
                    Delete(fileName);
                    files.Remove(fileName);
                }
            }
        }

        void Delete(string fileName) {
            try {
                File.Delete(fileName);
            }
            catch {
                // Ignore all exceptions
            }
        }

        static string GetTempFileName(string tempDir) {
            if (tempDir == null || tempDir.Length == 0) {
                StringBuilder buffer = new StringBuilder(260);
                if (UnsafeNativeMethods.GetTempPath(buffer.Capacity, buffer) == 0)
                    throw new ExternalException(SR.GetString(SR.ErrorGetTempPath), Marshal.GetLastWin32Error());
                tempDir = buffer.ToString();
            }

            string fileName = GenerateRandomFileName();

            if (tempDir.EndsWith("\\"))
                return tempDir + fileName;
            return tempDir + "\\" + fileName;
        }

        // Generate a random file name with 8 characters
        static string GenerateRandomFileName() {
            // Generate random bytes
            byte[] data = new byte[6];
            lock (rng) {
                rng.GetBytes(data);
            }

            // Turn them into a string containing only characters valid in file names/url
            string s = Convert.ToBase64String(data).ToLower(CultureInfo.InvariantCulture);
            s = s.Replace('/', '-');
            s = s.Replace('+', '_');

            return s;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\collections\specialized\namevaluecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="NameValueCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Ordered String/String[] collection of name/value pairs with support for null key
 * Wraps NameObject collection
 *
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Collections.Specialized {

    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.Serialization;
    using System.Text;
    
    /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection"]/*' />
    /// <devdoc>
    /// <para>Represents a sorted collection of associated <see cref='System.String' qualify='true'/> keys and <see cref='System.String' qualify='true'/> values that 
    ///    can be accessed either with the hash code of the key or with the index.</para>
    /// </devdoc>
    [Serializable()]
    public class NameValueCollection : NameObjectCollectionBase {
    
        private String[] _all;                            
        private String[] _allKeys;
    
        //
        // Constructors
        //
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.NameValueCollection"]/*' />
        /// <devdoc>
        /// <para>Creates an empty <see cref='System.Collections.Specialized.NameValueCollection'/> with the default initial capacity
        ///    and using the default case-insensitive hash code provider and the default
        ///    case-insensitive comparer.</para>
        /// </devdoc>
        public NameValueCollection() : base() {
        }
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.NameValueCollection1"]/*' />
        /// <devdoc>
        /// <para>Copies the entries from the specified <see cref='System.Collections.Specialized.NameValueCollection'/> to a new <see cref='System.Collections.Specialized.NameValueCollection'/> with the same initial capacity as 
        ///    the number of entries copied and using the default case-insensitive hash code
        ///    provider and the default case-insensitive comparer.</para>
        /// </devdoc>
        public NameValueCollection(NameValueCollection col) : base(col.HashCodeProvider, col.Comparer) {
            Add(col);
        }
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.NameValueCollection2"]/*' />
        /// <devdoc>
        /// <para>Creates an empty <see cref='System.Collections.Specialized.NameValueCollection'/> with the default initial capacity 
        ///    and using the specified case-insensitive hash code provider and the specified
        ///    case-insensitive comparer.</para>
        /// </devdoc>
        public NameValueCollection(IHashCodeProvider hashProvider, IComparer comparer) 
            : base(hashProvider, comparer) {
        }
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.NameValueCollection3"]/*' />
        /// <devdoc>
        /// <para>Creates an empty <see cref='System.Collections.Specialized.NameValueCollection'/> with 
        ///    the specified initial capacity and using the default case-insensitive hash code
        ///    provider and the default case-insensitive comparer.</para>
        /// </devdoc>
        public NameValueCollection(int capacity) : base(capacity) {
        }
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.NameValueCollection4"]/*' />
        /// <devdoc>
        /// <para>Copies the entries from the specified <see cref='System.Collections.Specialized.NameValueCollection'/> to a new <see cref='System.Collections.Specialized.NameValueCollection'/> with the specified initial capacity or the 
        ///    same initial capacity as the number of entries copied, whichever is greater, and
        ///    using the default case-insensitive hash code provider and the default
        ///    case-insensitive comparer.</para>
        /// </devdoc>
        public NameValueCollection(int capacity, NameValueCollection col) : base(capacity, col.HashCodeProvider, col.Comparer) {
            Add(col);
        }
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.NameValueCollection5"]/*' />
        /// <devdoc>
        /// <para>Creates an empty <see cref='System.Collections.Specialized.NameValueCollection'/> with the specified initial capacity and 
        ///    using the specified case-insensitive hash code provider and the specified
        ///    case-insensitive comparer.</para>
        /// </devdoc>
        public NameValueCollection(int capacity, IHashCodeProvider hashProvider, IComparer comparer) 
            : base(capacity, hashProvider, comparer) {
        }

        //
        // Serialization support
        //

        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.NameValueCollection6"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected NameValueCollection(SerializationInfo info, StreamingContext context) : base(info, context) {
        }
    
        //
        //  Helper methods
        //
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.InvalidateCachedArrays"]/*' />
        /// <devdoc>
        /// <para> Resets the cached arrays of the collection to <see langword='null'/>.</para>
        /// </devdoc>
        protected void InvalidateCachedArrays() {
            _all = null;
            _allKeys = null;
        }
    
        private static String GetAsOneString(ArrayList list) {
            int n = (list != null) ? list.Count : 0;
    
            if (n == 1) {
                return (String)list[0];
            }
            else if (n > 1) {
                StringBuilder s = new StringBuilder((String)list[0]);
    
                for (int i = 1; i < n; i++) {
                    s.Append(',');
                    s.Append((String)list[i]);
                }
    
                return s.ToString();
            }
            else {
                return null;
            }
        }
    
        private static String[] GetAsStringArray(ArrayList list)
        {
            int n = (list != null) ? list.Count : 0;
            if (n == 0)
                return null;
    
            String [] array = new String[n];
            list.CopyTo(0, array, 0, n);
            return array;
        }
    
        //
        // Misc public APIs
        //
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.Add"]/*' />
        /// <devdoc>
        /// <para>Copies the entries in the specified <see cref='System.Collections.Specialized.NameValueCollection'/> to the current <see cref='System.Collections.Specialized.NameValueCollection'/>.</para>
        /// </devdoc>
        public void Add(NameValueCollection c) {
            InvalidateCachedArrays();
    
            int n = c.Count;
    
            for (int i = 0; i < n; i++) {
                String key = c.GetKey(i);
                String[] values = c.GetValues(i);
    
                if (values != null) {
                    for (int j = 0; j < values.Length; j++)
                        Add(key, values[j]);
                }
                else {
                    Add(key, null);
                }
            }
        }
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.Clear"]/*' />
        /// <devdoc>
        ///    <para>Invalidates the cached arrays and removes all entries 
        ///       from the <see cref='System.Collections.Specialized.NameValueCollection'/>.</para>
        /// </devdoc>
        public void Clear() {
            if (IsReadOnly)
                throw new NotSupportedException(SR.GetString(SR.CollectionReadOnly));
    
            InvalidateCachedArrays();
            BaseClear();
        }
        
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.CopyTo"]/*' />
        public void CopyTo(Array dest, int index) {
            if (_all == null) {
                int n = Count;
                _all = new String[n];
                for (int i = 0; i < n; i++)
                    _all[i] = Get(i);
            }
    
            _all.CopyTo(dest, index);
        }
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.HasKeys"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the <see cref='System.Collections.Specialized.NameValueCollection'/> contains entries whose keys are not <see langword='null'/>.</para>
        /// </devdoc>
        public bool HasKeys() {
            return BaseHasKeys();
        }
    
        //
        // Access by name
        //
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.Add1"]/*' />
        /// <devdoc>
        ///    <para>Adds an entry with the specified name and value into the 
        ///    <see cref='System.Collections.Specialized.NameValueCollection'/>.</para>
        /// </devdoc>
        public virtual void Add(String name, String value) {
            if (IsReadOnly)
                throw new NotSupportedException(SR.GetString(SR.CollectionReadOnly));
    
            InvalidateCachedArrays();
    
            ArrayList values = (ArrayList)BaseGet(name);
    
            if (values == null) {
                // new key - add new key with single value
                values = new ArrayList(1);
                if (value != null)
                    values.Add(value);
                BaseAdd(name, values);
            }
            else {
                // old key -- append value to the list of values
                if (value != null)
                    values.Add(value);
            }
        }
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.Get"]/*' />
        /// <devdoc>
        /// <para> Gets the values associated with the specified key from the <see cref='System.Collections.Specialized.NameValueCollection'/> combined into one comma-separated list.</para>
        /// </devdoc>
        public virtual String Get(String name) {
            ArrayList values = (ArrayList)BaseGet(name);
            return GetAsOneString(values);
        }
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.GetValues"]/*' />
        /// <devdoc>
        /// <para>Gets the values associated with the specified key from the <see cref='System.Collections.Specialized.NameValueCollection'/>.</para>
        /// </devdoc>
        public virtual String[] GetValues(String name) {
            ArrayList values = (ArrayList)BaseGet(name);
            return GetAsStringArray(values);
        }
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.Set"]/*' />
        /// <devdoc>
        /// <para>Adds a value to an entry in the <see cref='System.Collections.Specialized.NameValueCollection'/>.</para>
        /// </devdoc>
        public virtual void Set(String name, String value) {
            if (IsReadOnly)
                throw new NotSupportedException(SR.GetString(SR.CollectionReadOnly));
    
            InvalidateCachedArrays();
    
            ArrayList values = new ArrayList(1);
            values.Add(value);
            BaseSet(name, values);
        }
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.Remove"]/*' />
        /// <devdoc>
        /// <para>Removes the entries with the specified key from the <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> instance.</para>
        /// </devdoc>
        public virtual void Remove(String name) {
            InvalidateCachedArrays();
            BaseRemove(name);
        }
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.this"]/*' />
        /// <devdoc>
        ///    <para> Represents the entry with the specified key in the 
        ///    <see cref='System.Collections.Specialized.NameValueCollection'/>.</para>
        /// </devdoc>
        public String this[String name] {
            get {
                return Get(name);
            }
    
            set {
                Set(name, value);
            }
        }
    
        //
        // Indexed access
        //
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.Get1"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Gets the values at the specified index of the <see cref='System.Collections.Specialized.NameValueCollection'/> combined into one
        ///       comma-separated list.</para>
        /// </devdoc>
        public virtual String Get(int index)   {
            ArrayList values = (ArrayList)BaseGet(index);
            return GetAsOneString(values);
        }
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.GetValues1"]/*' />
        /// <devdoc>
        ///    <para> Gets the values at the specified index of the <see cref='System.Collections.Specialized.NameValueCollection'/>.</para>
        /// </devdoc>
        public virtual String[] GetValues(int index) {
            ArrayList values = (ArrayList)BaseGet(index);
            return GetAsStringArray(values);
        }
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.GetKey"]/*' />
        /// <devdoc>
        /// <para>Gets the key at the specified index of the <see cref='System.Collections.Specialized.NameValueCollection'/>.</para>
        /// </devdoc>
        public virtual String GetKey(int index) {
            return BaseGetKey(index);
        }
    
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.this1"]/*' />
        /// <devdoc>
        /// <para>Represents the entry at the specified index of the <see cref='System.Collections.Specialized.NameValueCollection'/>.</para>
        /// </devdoc>
        public String this[int index] {
            get {
                return Get(index);
            }
        }
    
        //
        // Access to keys and values as arrays
        //
        
        /// <include file='doc\NameValueCollection.uex' path='docs/doc[@for="NameValueCollection.AllKeys"]/*' />
        /// <devdoc>
        /// <para>Gets all the keys in the <see cref='System.Collections.Specialized.NameValueCollection'/>. </para>
        /// </devdoc>
        public virtual String[] AllKeys {
            get {
                if (_allKeys == null)
                    _allKeys = BaseGetAllKeys();
                return _allKeys;
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\collections\specialized\listdictionary.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListDictionary.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Collections.Specialized {

    using System.Collections;
    using Microsoft.Win32;

    /// <include file='doc\ListDictionary.uex' path='docs/doc[@for="ListDictionary"]/*' />
    /// <devdoc>
    ///  <para> 
    ///    This is a simple implementation of IDictionary using a singly linked list. This
    ///    will be smaller and faster than a Hashtable if the number of elements is 10 or less.
    ///    This should not be used if performance is important for large numbers of elements.
    ///  </para>
    /// </devdoc>
    [Serializable]
    public class ListDictionary: IDictionary {
        DictionaryNode head;
        int version;
        int count;
        IComparer comparer;

        /// <include file='doc\ListDictionary.uex' path='docs/doc[@for="ListDictionary.ListDictionary"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ListDictionary() {
        }

        /// <include file='doc\ListDictionary.uex' path='docs/doc[@for="ListDictionary.ListDictionary1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ListDictionary(IComparer comparer) {
            this.comparer = comparer;
        }

        /// <include file='doc\ListDictionary.uex' path='docs/doc[@for="ListDictionary.this"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object this[object key] {
            get {
                if (key == null) {
                    throw new ArgumentNullException("key", SR.GetString(SR.ArgumentNull_Key));
                }
                DictionaryNode node = head;
                if (comparer == null) {
                    while (node != null) {
                        if (key.Equals(node.key)) {
                            return node.value;
                        }
                        node = node.next;
                    }
                }
                else {
                    while (node != null) {
                        if (comparer.Compare(key, node.key) == 0) {
                            return node.value;
                        }
                        node = node.next;
                    }
                }
                return null;
            }
            set {
                if (key == null) {
                    throw new ArgumentNullException("key", SR.GetString(SR.ArgumentNull_Key));
                }
                version++;
                DictionaryNode last = null;
                DictionaryNode node;
                for (node = head; node != null; node = node.next) {
                    if ((comparer == null) ? key.Equals(node.key) : comparer.Compare(key, node.key) == 0) {
                        break;
                    } 
                    last = node;
                }
                if (node != null) {
                    // Found it
                    node.value = value;
                    return;
                }
                // Not found, so add a new one
                DictionaryNode newNode = new DictionaryNode();
                newNode.key = key;
                newNode.value = value;
                if (last != null) {
                    last.next = newNode;
                }
                else {
                    head = newNode;
                }
                count++;
            }
        }

        /// <include file='doc\ListDictionary.uex' path='docs/doc[@for="ListDictionary.Count"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Count {
            get {
                return count;
            }
        }   

        /// <include file='doc\ListDictionary.uex' path='docs/doc[@for="ListDictionary.Keys"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICollection Keys {
            get {
                return new NodeKeyValueCollection(this, true);
            }
        }

        /// <include file='doc\ListDictionary.uex' path='docs/doc[@for="ListDictionary.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\ListDictionary.uex' path='docs/doc[@for="ListDictionary.IsFixedSize"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsFixedSize {
            get {
                return false;
            }
        }

        /// <include file='doc\ListDictionary.uex' path='docs/doc[@for="ListDictionary.IsSynchronized"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\ListDictionary.uex' path='docs/doc[@for="ListDictionary.SyncRoot"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public object SyncRoot {
            get {
                return this;
            }
        }

        /// <include file='doc\ListDictionary.uex' path='docs/doc[@for="ListDictionary.Values"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ICollection Values {
            get {
                return new NodeKeyValueCollection(this, false);
            }
        }

        /// <include file='doc\ListDictionary.uex' path='docs/doc[@for="ListDictionary.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Add(object key, object value) {
            if (key == null) {
                throw new ArgumentNullException("key", SR.GetString(SR.ArgumentNull_Key));
            }
            version++;
            DictionaryNode last = null;
            DictionaryNode node;
            for (node = head; node != null; node = node.next) {
                if ((comparer == null) ? key.Equals(node.key) : comparer.Compare(key, node.key) == 0) {
                    throw new ArgumentException(SR.GetString(SR.Argument_AddingDuplicate));
                } 
                last = node;
            }
            if (node != null) {
                // Found it
                node.value = value;
                return;
            }
            // Not found, so add a new one
            DictionaryNode newNode = new DictionaryNode();
            newNode.key = key;
            newNode.value = value;
            if (last != null) {
                last.next = newNode;
            }
            else {
                head = newNode;
            }
            count++;
        }

        /// <include file='doc\ListDictionary.uex' path='docs/doc[@for="ListDictionary.Clear"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Clear() {
            count = 0;
            head = null;
            version++;
        }

        /// <include file='doc\ListDictionary.uex' path='docs/doc[@for="ListDictionary.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(object key) {
            if (key == null) {
                throw new ArgumentNullException("key", SR.GetString(SR.ArgumentNull_Key));
            }
            for (DictionaryNode node = head; node != null; node = node.next) {
                if ((comparer == null) ? key.Equals(node.key) : comparer.Compare(key, node.key) == 0) {
                    return true;
                }
            }
            return false;
        }

        /// <include file='doc\ListDictionary.uex' path='docs/doc[@for="ListDictionary.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Array array, int index)  {
            if (array==null)
                throw new ArgumentNullException("array");
            if (index < 0) 
                throw new ArgumentOutOfRangeException("index", SR.GetString(SR.ArgumentOutOfRange_NeedNonNegNum));
            for (DictionaryNode node = head; node != null; node = node.next) {
                array.SetValue(new DictionaryEntry(node.key, node.value), index);
                index++;
            }
        }

        /// <include file='doc\ListDictionary.uex' path='docs/doc[@for="ListDictionary.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public IDictionaryEnumerator GetEnumerator() {
            return new NodeEnumerator(this);
        }

        /// <include file='doc\ListDictionary.uex' path='docs/doc[@for="ListDictionary.IEnumerable.GetEnumerator"]/*' />
        IEnumerator IEnumerable.GetEnumerator() {
            return new NodeEnumerator(this);
        }

        /// <include file='doc\ListDictionary.uex' path='docs/doc[@for="ListDictionary.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(object key) {
            if (key == null) {
                throw new ArgumentNullException("key", SR.GetString(SR.ArgumentNull_Key));
            }
            version++;
            DictionaryNode last = null;
            DictionaryNode node;
            for (node = head; node != null; node = node.next) {
                if ((comparer == null) ? key.Equals(node.key) : comparer.Compare(key, node.key) == 0) {
                    break;
                } 
                last = node;
            }
            if (node == null) {
                return;
            }          
            if (node == head) {
                head = node.next;
            } else {
                last.next = node.next;
            }
            count--;
        }

        private class NodeEnumerator : IDictionaryEnumerator {
            ListDictionary list;
            DictionaryNode current;
            int version;
            bool start;


            public NodeEnumerator(ListDictionary list) {
                this.list = list;
                version = list.version;
                start = true;
                current = null;
            }

            public object Current {
                get {
                    return Entry;
                }
            }

            public DictionaryEntry Entry {
                get {
                    if (version != list.version) {
                        throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
                    }
                    if (current == null) {
                        throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumOpCantHappen));
                    }
                    return new DictionaryEntry(current.key, current.value);
                }
            }

            public object Key {
                get {
                    if (version != list.version) {
                        throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
                    }
                    if (current == null) {
                        throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumOpCantHappen));
                    }
                    return current.key;
                }
            }

            public object Value {
                get {
                    if (version != list.version) {
                        throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
                    }
                    if (current == null) {
                        throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumOpCantHappen));
                    }
                    return current.value;
                }
            }

            public bool MoveNext() {
                if (version != list.version) {
                    throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
                }
                if (start) {
                    current = list.head;
                    start = false;
                }
                else {
                    current = current.next;
                }
                return (current != null);
            }

            public void Reset() {
                if (version != list.version) {
                    throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
                }
                start = true;
                current = null;
            }
            
        }


        private class NodeKeyValueCollection : ICollection {
            ListDictionary list;
            bool isKeys;

            public NodeKeyValueCollection(ListDictionary list, bool isKeys) {
                this.list = list;
                this.isKeys = isKeys;
            }

            void ICollection.CopyTo(Array array, int index)  {
                if (array==null)
                    throw new ArgumentNullException("array");
                if (index < 0) 
                    throw new ArgumentOutOfRangeException("index", SR.GetString(SR.ArgumentOutOfRange_NeedNonNegNum));
                for (DictionaryNode node = list.head; node != null; node = node.next) {
                    array.SetValue(isKeys ? node.key : node.value, index);
                    index++;
                }
            }

            int ICollection.Count {
                get {
                    int count = 0;
                    for (DictionaryNode node = list.head; node != null; node = node.next) {
                        count++;
                    }
                    return count;
                }
            }   

            bool ICollection.IsSynchronized {
                get {
                    return false;
                }
            }

            object ICollection.SyncRoot {
                get {
                    return this;
                }
            }

            IEnumerator IEnumerable.GetEnumerator() {
                return new NodeKeyValueEnumerator(list, isKeys);
            }


            private class NodeKeyValueEnumerator: IEnumerator {
                ListDictionary list;
                DictionaryNode current;
                int version;
                bool isKeys;
                bool start;

                public NodeKeyValueEnumerator(ListDictionary list, bool isKeys) {
                    this.list = list;
                    this.isKeys = isKeys;
                    this.version = list.version;
                    this.start = true;
                    this.current = null;
                }

                public object Current {
                    get {
                        if (version != list.version) {
                            throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
                        }
                        if (current == null) {
                            throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumOpCantHappen));
                        }
                        return isKeys ? current.key : current.value;
                    }
                }

                public bool MoveNext() {
                    if (version != list.version) {
                        throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
                    }
                    if (start) {
                        current = list.head;
                        start = false;
                    }
                    else {
                        current = current.next;
                    }
                    return (current != null);
                }

                public void Reset() {
                    if (version != list.version) {
                        throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
                    }
                    start = true;
                    current = null;
                }
            }        
        }

        [Serializable]
        private class DictionaryNode {
            public object key;
            public object value;
            public DictionaryNode next;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\collections\specialized\stringcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="StringCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.Collections.Specialized {

    using System.Diagnostics;
    using System.Collections;

    /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection"]/*' />
    /// <devdoc>
    ///    <para>Represents a collection of strings.</para>
    /// </devdoc>
    [
        Serializable,
    ]
    public class StringCollection : IList {
        private ArrayList data = new ArrayList();

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.this"]/*' />
        /// <devdoc>
        /// <para>Represents the entry at the specified index of the <see cref='System.Collections.Specialized.StringCollection'/>.</para>
        /// </devdoc>
        public string this[int index] {
            get {
                return ((string)data[index]);
            }
            set {
                data[index] = value;
            }
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>Gets the number of strings in the 
        ///    <see cref='System.Collections.Specialized.StringCollection'/> .</para>
        /// </devdoc>
        public int Count {
            get {
                return data.Count;
            }
        }

		/// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.IList.IsReadOnly"]/*' />
		bool IList.IsReadOnly
		{
			get
			{
				return false;
			}
		}

		/// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.IList.IsFixedSize"]/*' />
		bool IList.IsFixedSize
		{
			get
			{
				return false;
			}
		}


        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>Adds a string with the specified value to the 
        ///    <see cref='System.Collections.Specialized.StringCollection'/> .</para>
        /// </devdoc>
        public int Add(string value) {
            return data.Add(value);
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.AddRange"]/*' />
        /// <devdoc>
        /// <para>Copies the elements of a string array to the end of the <see cref='System.Collections.Specialized.StringCollection'/>.</para>
        /// </devdoc>
        public void AddRange(string[] value) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            foreach (string s in value) {
                Add(s);
            }
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.Clear"]/*' />
        /// <devdoc>
        ///    <para>Removes all the strings from the 
        ///    <see cref='System.Collections.Specialized.StringCollection'/> .</para>
        /// </devdoc>
        public void Clear() {
            data.Clear();
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the 
        ///    <see cref='System.Collections.Specialized.StringCollection'/> contains a string with the specified 
        ///       value.</para>
        /// </devdoc>
        public bool Contains(string value) {
            return data.Contains(value);
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the <see cref='System.Collections.Specialized.StringCollection'/> values to a one-dimensional <see cref='System.Array'/> instance at the 
        ///    specified index.</para>
        /// </devdoc>
        public void CopyTo(string[] array, int index) {
            data.CopyTo(array, index);
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>Returns an enumerator that can iterate through 
        ///       the <see cref='System.Collections.Specialized.StringCollection'/> .</para>
        /// </devdoc>
        public StringEnumerator GetEnumerator() {
            return new StringEnumerator(this);
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>Returns the index of the first occurrence of a string in 
        ///       the <see cref='System.Collections.Specialized.StringCollection'/> .</para>
        /// </devdoc>
        public int IndexOf(string value) {
            return data.IndexOf(value);
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.Insert"]/*' />
        /// <devdoc>
        /// <para>Inserts a string into the <see cref='System.Collections.Specialized.StringCollection'/> at the specified 
        ///    index.</para>
        /// </devdoc>
        public void Insert(int index, string value) {
            data.Insert(index, value);
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.IsReadOnly"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the <see cref='System.Collections.Specialized.StringCollection'/> is read-only.</para>
        /// </devdoc>
        public bool IsReadOnly {
            get {
                return false;
            }
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.IsSynchronized"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether access to the 
        ///    <see cref='System.Collections.Specialized.StringCollection'/> 
        ///    is synchronized (thread-safe).</para>
        /// </devdoc>
        public bool IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para> Removes a specific string from the 
        ///    <see cref='System.Collections.Specialized.StringCollection'/> .</para>
        /// </devdoc>
        public void Remove(string value) {
            data.Remove(value);
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.RemoveAt"]/*' />
        /// <devdoc>
        /// <para>Removes the string at the specified index of the <see cref='System.Collections.Specialized.StringCollection'/>.</para>
        /// </devdoc>
        public void RemoveAt(int index) {
            data.RemoveAt(index);
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.SyncRoot"]/*' />
        /// <devdoc>
        /// <para>Gets an object that can be used to synchronize access to the <see cref='System.Collections.Specialized.StringCollection'/>.</para>
        /// </devdoc>
        public object SyncRoot {
            get {
                return this;
            }
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.IList.this"]/*' />
        object IList.this[int index] {
            get {
                return this[index];
            }
            set {
                this[index] = (string)value;
            }
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.IList.Add"]/*' />
        int IList.Add(object value) {
            return Add((string)value);
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.IList.Contains"]/*' />
        bool IList.Contains(object value) {
            return Contains((string) value);
        }


        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.IList.IndexOf"]/*' />
        int IList.IndexOf(object value) {
            return IndexOf((string)value);
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.IList.Insert"]/*' />
        void IList.Insert(int index, object value) {
            Insert(index, (string)value);
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.IList.Remove"]/*' />
        void IList.Remove(object value) {
            Remove((string)value);
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.ICollection.CopyTo"]/*' />
        void ICollection.CopyTo(Array array, int index) {
            data.CopyTo(array, index);
        }

        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringCollection.IEnumerable.GetEnumerator"]/*' />
        IEnumerator IEnumerable.GetEnumerator() {
            return data.GetEnumerator();
        }
    }

    /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringEnumerator"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class StringEnumerator {
        private System.Collections.IEnumerator baseEnumerator;
        private System.Collections.IEnumerable temp;
        
        internal StringEnumerator(StringCollection mappings) {
            this.temp = (IEnumerable)(mappings);
            this.baseEnumerator = temp.GetEnumerator();
        }
        
        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringEnumerator.Current"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public string Current {
            get {
                return (string)(baseEnumerator.Current);
            }
        }
        
        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringEnumerator.MoveNext"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool MoveNext() {
            return baseEnumerator.MoveNext();
        }
        /// <include file='doc\StringCollection.uex' path='docs/doc[@for="StringEnumerator.Reset"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Reset() {
            baseEnumerator.Reset();
        }
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\collections\specialized\nameobjectcollectionbase.cs ===
//------------------------------------------------------------------------------
// <copyright file="NameObjectCollectionBase.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * Ordered String/Object collection of name/value pairs with support for null key
 *
 * This class is intended to be used as a base class
 * 
 * Copyright (c) 2000 Microsoft Corporation
 */

namespace System.Collections.Specialized {

    using Microsoft.Win32;
    using System.Collections;
    using System.Runtime.Serialization;
    using System.Globalization;
    
    /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase"]/*' />
    /// <devdoc>
    /// <para>Provides the <see langword='abstract '/>base class for a sorted collection of associated <see cref='System.String' qualify='true'/> keys 
    ///    and <see cref='System.Object' qualify='true'/> values that can be accessed either with the hash code of
    ///    the key or with the index.</para>
    /// </devdoc>
    [Serializable()]
    public abstract class NameObjectCollectionBase : ICollection, ISerializable, IDeserializationCallback {
    
        private bool _readOnly = false;
        private ArrayList _entriesArray;
        private IHashCodeProvider _hashProvider;
        private IComparer _comparer;
        private Hashtable _entriesTable;
        private NameObjectEntry _nullKeyEntry;
        private KeysCollection _keys;
        private SerializationInfo _serializationInfo;
        private int _version;
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.NameObjectCollectionBase"]/*' />
        /// <devdoc>
        /// <para> Creates an empty <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> instance with the default initial capacity and using the default case-insensitive hash
        ///    code provider and the default case-insensitive comparer.</para>
        /// </devdoc>
        protected NameObjectCollectionBase() {
            _hashProvider = new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture);
            _comparer = new CaseInsensitiveComparer(CultureInfo.InvariantCulture);
            Reset();
        }
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.NameObjectCollectionBase1"]/*' />
        /// <devdoc>
        /// <para>Creates an empty <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> instance with 
        ///    the default initial capacity and using the specified case-insensitive hash code provider and the
        ///    specified case-insensitive comparer.</para>
        /// </devdoc>
        protected NameObjectCollectionBase(IHashCodeProvider hashProvider, IComparer comparer) {
            _hashProvider = hashProvider;
            _comparer = comparer;
            Reset();
        }
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.NameObjectCollectionBase2"]/*' />
        /// <devdoc>
        /// <para>Creates an empty <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> instance with the specified 
        ///    initial capacity and using the specified case-insensitive hash code provider
        ///    and the specified case-insensitive comparer.</para>
        /// </devdoc>
        protected NameObjectCollectionBase(int capacity, IHashCodeProvider hashProvider, IComparer comparer) {
            _hashProvider = hashProvider;
            _comparer = comparer;
            Reset(capacity);
        }
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.NameObjectCollectionBase3"]/*' />
        /// <devdoc>
        /// <para>Creates an empty <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> instance with the specified 
        ///    initial capacity and using the default case-insensitive hash code provider
        ///    and the default case-insensitive comparer.</para>
        /// </devdoc>
        protected NameObjectCollectionBase(int capacity) {
            _hashProvider = new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture);
            _comparer = new CaseInsensitiveComparer(CultureInfo.InvariantCulture);
            Reset(capacity);
        }

        //
        // Serialization support
        //

        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.NameObjectCollectionBase4"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected NameObjectCollectionBase(SerializationInfo info, StreamingContext context) {
            _serializationInfo = info; 
        }

        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.GetObjectData"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void GetObjectData(SerializationInfo info, StreamingContext context) {
            if (info == null)
                throw new ArgumentNullException("info");

            info.AddValue("ReadOnly", _readOnly);
            info.AddValue("HashProvider", _hashProvider, typeof(IHashCodeProvider));
            info.AddValue("Comparer", _comparer, typeof(IComparer));

            int count = _entriesArray.Count;
            info.AddValue("Count", count);

            String[] keys = new String[count];
            Object[] values = new Object[count];

            for (int i = 0; i < count; i++) {
                NameObjectEntry entry = (NameObjectEntry)_entriesArray[i];
                keys[i] = entry.Key;
                values[i] = entry.Value;
            }

            info.AddValue("Keys", keys, typeof(String[]));
            info.AddValue("Values", values, typeof(Object[]));
        }

        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.OnDeserialization"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public virtual void OnDeserialization(Object sender) {
            if (_hashProvider!=null) {
                return;//Somebody had a dependency on this hashtable and fixed us up before the ObjectManager got to it.
            }

            if (_serializationInfo == null)
                throw new SerializationException();

            SerializationInfo info = _serializationInfo;
            _serializationInfo = null;
            
            bool readOnly = info.GetBoolean("ReadOnly");
            _hashProvider = (IHashCodeProvider)info.GetValue("HashProvider", typeof(IHashCodeProvider));
            _comparer = (IComparer)info.GetValue("Comparer", typeof(IComparer));
            int count = info.GetInt32("Count");

            String[] keys = (String[])info.GetValue("Keys", typeof(String[]));
            Object[] values = (Object[])info.GetValue("Values", typeof(Object[]));

            if (_hashProvider == null || _comparer == null || keys == null || values == null)
                throw new SerializationException();

            Reset(count);

            for (int i = 0; i < count; i++)
                BaseAdd(keys[i], values[i]);
    
            _readOnly = readOnly;  // after collection populated
            _version++;
        }

        //
        // Private helpers
        //
    
        private void Reset() {
            _entriesArray = new ArrayList();
            _entriesTable = new Hashtable(_hashProvider, _comparer);
            _nullKeyEntry = null;
            _version++;
        }
    
        private void Reset(int capacity) {
            _entriesArray = new ArrayList(capacity);
            _entriesTable = new Hashtable(capacity, _hashProvider, _comparer);
            _nullKeyEntry = null;
            _version++;
        }
    
        private NameObjectEntry FindEntry(String key) {
            if (key != null)
                return (NameObjectEntry)_entriesTable[key];
            else
                return _nullKeyEntry;
        }
    
        //
        // Misc
        //

        internal IHashCodeProvider HashCodeProvider {
            get { return _hashProvider; }
        }

        internal IComparer Comparer {
            get { return _comparer; }
        }
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.IsReadOnly"]/*' />
        /// <devdoc>
        /// <para>Gets or sets a value indicating whether the <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> instance is read-only.</para>
        /// </devdoc>
        protected bool IsReadOnly {
            get { return _readOnly; }
            set { _readOnly = value; }
        }
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.BaseHasKeys"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> instance contains entries whose 
        ///    keys are not <see langword='null'/>.</para>
        /// </devdoc>
        protected bool BaseHasKeys() {
            return (_entriesTable.Count > 0);  // any entries with keys?
        }
    
        //
        // Methods to add / remove entries
        //
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.BaseAdd"]/*' />
        /// <devdoc>
        ///    <para>Adds an entry with the specified key and value into the 
        ///    <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> instance.</para>
        /// </devdoc>
        protected void BaseAdd(String name, Object value) {
            if (_readOnly)
                throw new NotSupportedException(SR.GetString(SR.CollectionReadOnly));
    
            NameObjectEntry entry = new NameObjectEntry(name, value);
    
            // insert entry into hashtable
            if (name != null) {
                if (_entriesTable[name] == null)
                    _entriesTable.Add(name, entry);
            }
            else { // null key -- special case -- hashtable doesn't like null keys
                if (_nullKeyEntry == null)
                    _nullKeyEntry = entry;
            }
    
            // add entry to the list
            _entriesArray.Add(entry);

            _version++;
        }
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.BaseRemove"]/*' />
        /// <devdoc>
        ///    <para>Removes the entries with the specified key from the 
        ///    <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> instance.</para>
        /// </devdoc>
        protected void BaseRemove(String name) {
            if (_readOnly)
                throw new NotSupportedException(SR.GetString(SR.CollectionReadOnly));
    
            if (name != null) {
                // remove from hashtable
                _entriesTable.Remove(name);
    
                // remove from array
                for (int i = _entriesArray.Count-1; i >= 0; i--) {
                    if (_comparer.Compare(name, BaseGetKey(i)) == 0)
                        _entriesArray.RemoveAt(i);
                }
            }
            else { // null key -- special case
                // null out special 'null key' entry
                _nullKeyEntry = null;
    
                // remove from array
                for (int i = _entriesArray.Count-1; i >= 0; i--) {
                    if (BaseGetKey(i) == null)
                        _entriesArray.RemoveAt(i);
                }
            }

            _version++;
        }
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.BaseRemoveAt"]/*' />
        /// <devdoc>
        ///    <para> Removes the entry at the specified index of the 
        ///    <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> instance.</para>
        /// </devdoc>
        protected void BaseRemoveAt(int index) {
            if (_readOnly)
                throw new NotSupportedException(SR.GetString(SR.CollectionReadOnly));
    
            String key = BaseGetKey(index);
    
            if (key != null) {
                // remove from hashtable
                _entriesTable.Remove(key);
            } 
            else { // null key -- special case
                // null out special 'null key' entry
                _nullKeyEntry = null;
            }
    
            // remove from array
            _entriesArray.RemoveAt(index);

            _version++;
        }
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.BaseClear"]/*' />
        /// <devdoc>
        /// <para>Removes all entries from the <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> instance.</para>
        /// </devdoc>
        protected void BaseClear() {
            if (_readOnly)
                throw new NotSupportedException(SR.GetString(SR.CollectionReadOnly));
    
            Reset();
        }
    
        //
        // Access by name
        //
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.BaseGet"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the first entry with the specified key from 
        ///       the <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> instance.</para>
        /// </devdoc>
        protected Object BaseGet(String name) {
            NameObjectEntry e = FindEntry(name);
            return (e != null) ? e.Value : null;
        }
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.BaseSet"]/*' />
        /// <devdoc>
        /// <para>Sets the value of the first entry with the specified key in the <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> 
        /// instance, if found; otherwise, adds an entry with the specified key and value
        /// into the <see cref='System.Collections.Specialized.NameObjectCollectionBase'/>
        /// instance.</para>
        /// </devdoc>
        protected void BaseSet(String name, Object value) {
            if (_readOnly)
                throw new NotSupportedException(SR.GetString(SR.CollectionReadOnly));
    
            NameObjectEntry entry = FindEntry(name);
            if (entry != null) {
                entry.Value = value;
                _version++;
            }
            else {
                BaseAdd(name, value);
            }
        }
    
        //
        // Access by index
        //
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.BaseGet1"]/*' />
        /// <devdoc>
        ///    <para>Gets the value of the entry at the specified index of 
        ///       the <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> instance.</para>
        /// </devdoc>
        protected Object BaseGet(int index) {
            NameObjectEntry entry = (NameObjectEntry)_entriesArray[index];
            return entry.Value;
        }
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.BaseGetKey"]/*' />
        /// <devdoc>
        ///    <para>Gets the key of the entry at the specified index of the 
        ///    <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> 
        ///    instance.</para>
        /// </devdoc>
        protected String BaseGetKey(int index) {
            NameObjectEntry entry = (NameObjectEntry)_entriesArray[index];
            return entry.Key;
        }
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.BaseSet1"]/*' />
        /// <devdoc>
        ///    <para>Sets the value of the entry at the specified index of 
        ///       the <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> instance.</para>
        /// </devdoc>
        protected void BaseSet(int index, Object value) {
            NameObjectEntry entry = (NameObjectEntry)_entriesArray[index];
            entry.Value = value;
            _version++;
        }
    
        //
        // ICollection implementation
        //
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.GetEnumerator"]/*' />
        /// <devdoc>
        /// <para>Returns an enumerator that can iterate through the <see cref='System.Collections.Specialized.NameObjectCollectionBase'/>.</para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return new NameObjectKeysEnumerator(this);
        }
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.Count"]/*' />
        /// <devdoc>
        /// <para>Gets the number of key-and-value pairs in the <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> instance.</para>
        /// </devdoc>
        public virtual int Count {
            get {
                return _entriesArray.Count;
            }
        }
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.ICollection.CopyTo"]/*' />
        void ICollection.CopyTo(Array array, int index) {
            for (IEnumerator e = this.GetEnumerator(); e.MoveNext();)
                array.SetValue(e.Current, index++);
        }
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.ICollection.SyncRoot"]/*' />
        Object ICollection.SyncRoot {
            get { return this; }
        }
        
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.ICollection.IsSynchronized"]/*' />
        bool ICollection.IsSynchronized {
            get { return false; }
        }
    
        //
        //  Helper methods to get arrays of keys and values
        //
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.BaseGetAllKeys"]/*' />
        /// <devdoc>
        /// <para>Returns a <see cref='System.String' qualify='true'/> array containing all the keys in the 
        /// <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> instance.</para>
        /// </devdoc>
        protected String[] BaseGetAllKeys() {
            int n = _entriesArray.Count;
            String[] allKeys = new String[n];
    
            for (int i = 0; i < n; i++)
                allKeys[i] = BaseGetKey(i);
    
            return allKeys;
        }
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.BaseGetAllValues"]/*' />
        /// <devdoc>
        /// <para>Returns an <see cref='System.Object' qualify='true'/> array containing all the values in the 
        /// <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> instance.</para>
        /// </devdoc>
        protected Object[] BaseGetAllValues() {
            int n = _entriesArray.Count;
            Object[] allValues = new Object[n];
    
            for (int i = 0; i < n; i++)
                allValues[i] = BaseGet(i);
    
            return allValues;
        }
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.BaseGetAllValues1"]/*' />
        /// <devdoc>
        ///    <para>Returns an array of the specified type containing 
        ///       all the values in the <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> instance.</para>
        /// </devdoc>
        protected object[] BaseGetAllValues(Type type) {
            int n = _entriesArray.Count;
            object[] allValues = (object[]) Array.CreateInstance(type, n);
    
            for (int i = 0; i < n; i++) {
                allValues[i] = BaseGet(i);
            }
    
            return allValues;
        }
    
        //
        // Keys propetry
        //
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.Keys"]/*' />
        /// <devdoc>
        /// <para>Returns a <see cref='System.Collections.Specialized.NameObjectCollectionBase.KeysCollection'/> instance containing 
        ///    all the keys in the <see cref='System.Collections.Specialized.NameObjectCollectionBase'/> instance.</para>
        /// </devdoc>
        public virtual KeysCollection Keys {
            get {
                if (_keys == null)
                    _keys = new KeysCollection(this);
                return _keys;
            }
        }
    
        //
        // Simple entry class to allow substitution of values and indexed access to keys
        //
    
        internal class NameObjectEntry {
    
            internal NameObjectEntry(String name, Object value) {
                Key = name;
                Value = value;
            }
    
            internal String Key;
            internal Object Value;
        }
    
        //
        // Enumerator over keys of NameObjectCollection
        //
    
        [Serializable()]
        internal class NameObjectKeysEnumerator : IEnumerator {
            private int _pos;
            private NameObjectCollectionBase _coll;
            private int _version;
    
            internal NameObjectKeysEnumerator(NameObjectCollectionBase coll) {
                _coll = coll;
                _version = _coll._version;
                _pos = -1;
            }
    
            // Enumerator
    
            public bool MoveNext() {
                if (!_coll._readOnly && _version != _coll._version)
                    throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
                return (++_pos < _coll.Count);
            }
    
            public void Reset() {
                if (!_coll._readOnly && _version != _coll._version)
                    throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
                _pos = -1;
            }
    
            public Object Current {
                get {
                    if (!_coll._readOnly && _version != _coll._version) {
                        throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumFailedVersion));
                    }
                    else if (_pos >= 0 && _pos < _coll.Count) {
                        return _coll.BaseGetKey(_pos);
                    }
                    else {
                        throw new InvalidOperationException(SR.GetString(SR.InvalidOperation_EnumOpCantHappen));
                    }
                }
            }
        }
    
        //
        // Keys collection
        //
    
        /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.KeysCollection"]/*' />
        /// <devdoc>
        /// <para>Represents a collection of the <see cref='System.String' qualify='true'/> keys of a collection.</para>
        /// </devdoc>
        [Serializable()]
        public class KeysCollection : ICollection {
    
            private NameObjectCollectionBase _coll;
    
            internal KeysCollection(NameObjectCollectionBase coll) {
                _coll = coll;
            }
    
            // Indexed access
    
            /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.KeysCollection.Get"]/*' />
            /// <devdoc>
            ///    <para> Gets the key at the specified index of the collection.</para>
            /// </devdoc>
            public virtual String Get(int index) {
                return _coll.BaseGetKey(index);
            }
    
            /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.KeysCollection.this"]/*' />
            /// <devdoc>
            ///    <para>Represents the entry at the specified index of the collection.</para>
            /// </devdoc>
            public String this[int index] {
                get {
                    return Get(index);
                }
            }
    
            // ICollection implementation
    
            /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.KeysCollection.GetEnumerator"]/*' />
            /// <devdoc>
            ///    <para>Returns an enumerator that can iterate through the 
            ///    <see cref='System.Collections.Specialized.NameObjectCollectionBase.KeysCollection'/>.</para>
            /// </devdoc>
            public IEnumerator GetEnumerator() {
                return new NameObjectKeysEnumerator(_coll);
            }
    
            /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="NameObjectCollectionBase.KeysCollection.Count"]/*' />
            /// <devdoc>
            /// <para>Gets the number of keys in the <see cref='System.Collections.Specialized.NameObjectCollectionBase.KeysCollection'/>.</para>
            /// </devdoc>
            public int Count {
                get {
                    return _coll.Count;
                }
            }
    
            /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="KeysCollection.ICollection.CopyTo"]/*' />
            void ICollection.CopyTo(Array array, int index) {
                for (IEnumerator e = this.GetEnumerator(); e.MoveNext();)
                    array.SetValue(e.Current, index++);
            }
    
            /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="KeysCollection.ICollection.SyncRoot"]/*' />
            Object ICollection.SyncRoot {
                get { return _coll; }
            }
    
             
            /// <include file='doc\NameObjectCollectionBase.uex' path='docs/doc[@for="KeysCollection.ICollection.IsSynchronized"]/*' />
            bool ICollection.IsSynchronized {
                get { return false; }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\arrayconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ArrayConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using Microsoft.Win32;
    using System.Collections;
    using System.Diagnostics;
    using System.Globalization;

    /// <include file='doc\ArrayConverter.uex' path='docs/doc[@for="ArrayConverter"]/*' />
    /// <devdoc>
    /// <para>Provides a type converter to convert <see cref='System.Array'/>
    /// objects to and from various other representations.</para>
    /// </devdoc>
    public class ArrayConverter : CollectionConverter {

        /// <include file='doc\ArrayConverter.uex' path='docs/doc[@for="ArrayConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Converts the given value object to the specified destination type.</para>
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {
                if (value is Array) {
                    return SR.GetString(SR.ArrayConverterText, value.GetType().Name);
                }
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\ArrayConverter.uex' path='docs/doc[@for="ArrayConverter.GetProperties"]/*' />
        /// <devdoc>
        ///    <para>Gets a collection of properties for the type of array
        ///       specified by the value
        ///       parameter.</para>
        /// </devdoc>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {

            PropertyDescriptor[] props = null;

            if (value.GetType().IsArray) {
                Array valueArray = (Array)value;
                int length = valueArray.GetLength(0);
                props = new PropertyDescriptor[length];
                
                Type arrayType = value.GetType();
                Type elementType = arrayType.GetElementType();
                
                for (int i = 0; i < length; i++) {
                    props[i] = new ArrayPropertyDescriptor(arrayType, elementType, i);
                }
            }

            return new PropertyDescriptorCollection(props);
        }

        /// <include file='doc\ArrayConverter.uex' path='docs/doc[@for="ArrayConverter.GetPropertiesSupported"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this object
        ///       supports properties.</para>
        /// </devdoc>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
            return true;
        }

        private class ArrayPropertyDescriptor : SimplePropertyDescriptor {
            private int index;

            public ArrayPropertyDescriptor(Type arrayType, Type elementType, int index) : base(arrayType, "[" + index + "]", elementType, null) {
                this.index = index;
            }
            
            public override object GetValue(object instance) {
                if (instance is Array) {
                    Array array = (Array)instance;
                    if (array.GetLength(0) > index) {
                        return array.GetValue(index);
                    }
                }
                
                return null;
            }
            
            public override void SetValue(object instance, object value) {
                if (instance is Array) {
                    Array array = (Array)instance;
                    if (array.GetLength(0) > index) {
                        array.SetValue(value, index);
                    }
                    
                    OnValueChanged(instance, EventArgs.Empty);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\collections\specialized\stringdictionary.cs ===
//------------------------------------------------------------------------------
// <copyright file="StringDictionary.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.Collections.Specialized {
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.ComponentModel.Design.Serialization;
    using System.Globalization;
    
    /// <include file='doc\StringDictionary.uex' path='docs/doc[@for="StringDictionary"]/*' />
    /// <devdoc>
    ///    <para>Implements a hashtable with the key strongly typed to be
    ///       a string rather than an object. </para>
    /// </devdoc>
    [DesignerSerializer("System.Diagnostics.Design.StringDictionaryCodeDomSerializer, " + AssemblyRef.SystemDesign, "System.ComponentModel.Design.Serialization.CodeDomSerializer, " + AssemblyRef.SystemDesign)]
    public class StringDictionary : IEnumerable {
        
        private Hashtable contents = new Hashtable();
        
        /// <include file='doc\StringDictionary.uex' path='docs/doc[@for="StringDictionary.StringDictionary"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the System.Windows.Forms.StringDictionary class.</para>
        /// </devdoc>
        public StringDictionary() {
        }

        
        /// <include file='doc\StringDictionary.uex' path='docs/doc[@for="StringDictionary.Count"]/*' />
        /// <devdoc>
        /// <para>Gets the number of key-and-value pairs in the System.Windows.Forms.StringDictionary.</para>
        /// </devdoc>
        public virtual int Count {
            get {
                return contents.Count;
            }
        }

        
        /// <include file='doc\StringDictionary.uex' path='docs/doc[@for="StringDictionary.IsSynchronized"]/*' />
        /// <devdoc>
        /// <para>Indicates whether access to the System.Windows.Forms.StringDictionary is synchronized (thread-safe). This property is 
        ///    read-only.</para>
        /// </devdoc>
        public virtual bool IsSynchronized {
            get {
                return contents.IsSynchronized;
            }
        }

        /// <include file='doc\StringDictionary.uex' path='docs/doc[@for="StringDictionary.this"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the value associated with the specified key.</para>
        /// </devdoc>
        public virtual string this[string key] {
            get {
                return (string) contents[key.ToLower(CultureInfo.InvariantCulture)];
            }
            set {
                contents[key.ToLower(CultureInfo.InvariantCulture)] = value;
            }
        }

        /// <include file='doc\StringDictionary.uex' path='docs/doc[@for="StringDictionary.Keys"]/*' />
        /// <devdoc>
        /// <para>Gets a collection of keys in the System.Windows.Forms.StringDictionary.</para>
        /// </devdoc>
        public virtual ICollection Keys {
            get {
                return contents.Keys;
            }
        }

        
        /// <include file='doc\StringDictionary.uex' path='docs/doc[@for="StringDictionary.SyncRoot"]/*' />
        /// <devdoc>
        /// <para>Gets an object that can be used to synchronize access to the System.Windows.Forms.StringDictionary.</para>
        /// </devdoc>
        public virtual object SyncRoot {
            get {
                return contents.SyncRoot;
            }
        }

        /// <include file='doc\StringDictionary.uex' path='docs/doc[@for="StringDictionary.Values"]/*' />
        /// <devdoc>
        /// <para>Gets a collection of values in the System.Windows.Forms.StringDictionary.</para>
        /// </devdoc>
        public virtual ICollection Values {
            get {
                return contents.Values;
            }
        }

        /// <include file='doc\StringDictionary.uex' path='docs/doc[@for="StringDictionary.Add"]/*' />
        /// <devdoc>
        /// <para>Adds an entry with the specified key and value into the System.Windows.Forms.StringDictionary.</para>
        /// </devdoc>
        public virtual void Add(string key, string value) {
            contents.Add(key.ToLower(CultureInfo.InvariantCulture), value);
        }

        /// <include file='doc\StringDictionary.uex' path='docs/doc[@for="StringDictionary.Clear"]/*' />
        /// <devdoc>
        /// <para>Removes all entries from the System.Windows.Forms.StringDictionary.</para>
        /// </devdoc>
        public virtual void Clear() {
            contents.Clear();
        }

        /// <include file='doc\StringDictionary.uex' path='docs/doc[@for="StringDictionary.ContainsKey"]/*' />
        /// <devdoc>
        ///    <para>Determines if the string dictionary contains a specific key</para>
        /// </devdoc>
        public virtual bool ContainsKey(string key) {
            return contents.ContainsKey(key.ToLower(CultureInfo.InvariantCulture));
        }

        /// <include file='doc\StringDictionary.uex' path='docs/doc[@for="StringDictionary.ContainsValue"]/*' />
        /// <devdoc>
        /// <para>Determines if the System.Windows.Forms.StringDictionary contains a specific value.</para>
        /// </devdoc>
        public virtual bool ContainsValue(string value) {
            return contents.ContainsValue(value);
        }

        /// <include file='doc\StringDictionary.uex' path='docs/doc[@for="StringDictionary.CopyTo"]/*' />
        /// <devdoc>
        /// <para>Copies the string dictionary values to a one-dimensional <see cref='System.Array'/> instance at the 
        ///    specified index.</para>
        /// </devdoc>
        public virtual void CopyTo(Array array, int index) {
            contents.CopyTo(array, index);
        }

        /// <include file='doc\StringDictionary.uex' path='docs/doc[@for="StringDictionary.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>Returns an enumerator that can iterate through the string dictionary.</para>
        /// </devdoc>
        public virtual IEnumerator GetEnumerator() {
            return contents.GetEnumerator();
        }

        /// <include file='doc\StringDictionary.uex' path='docs/doc[@for="StringDictionary.Remove"]/*' />
        /// <devdoc>
        ///    <para>Removes the entry with the specified key from the string dictionary.</para>
        /// </devdoc>
        public virtual void Remove(string key) {
            contents.Remove(key.ToLower(CultureInfo.InvariantCulture));
        }

    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\basenumberconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="basenumberconverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    

    using System.Diagnostics;

    using Microsoft.Win32;

    /// <include file='doc\basenumberconverter.uex' path='docs/doc[@for="BaseNumberConverter"]/*' />
    /// <devdoc>
    ///    <para>Provides a base type converter for integral types.</para>
    /// </devdoc>
    public abstract class BaseNumberConverter : TypeConverter {
    
        
        /// <devdoc>
        /// Determines whether this editor will attempt to convert hex (0x or #) strings
        /// </devdoc>
        internal virtual bool AllowHex {
                get {
                     return true;
                }
        }
        
        
        /// <devdoc>
        /// The Type this converter is targeting (e.g. Int16, UInt32, etc.)
        /// </devdoc>
        internal abstract Type TargetType {
                get;
        }
        
        /// <devdoc>
        /// Convert the given value to a string using the given radix
        /// </devdoc>
        internal abstract object FromString(string value, int radix);
        
        /// <devdoc>
        /// Convert the given value to a string using the given formatInfo
        /// </devdoc>
        internal abstract object FromString(string value, NumberFormatInfo formatInfo);
        
        /// <devdoc>
        /// Convert the given value to a string using the given CultureInfo
        /// </devdoc>
        internal abstract object FromString(string value, CultureInfo culture);
        
        /// <devdoc>
        /// Create an error based on the failed text and the exception thrown.
        /// </devdoc>
        internal virtual Exception FromStringError(string failedText, Exception innerException) {
                return new Exception(SR.GetString(SR.ConvertInvalidPrimitive, failedText, TargetType.Name), innerException);
        }
        
        /// <devdoc>
        /// Convert the given value from a string using the given formatInfo
        /// </devdoc>
        internal abstract string ToString(object value, NumberFormatInfo formatInfo);

        /// <include file='doc\basenumberconverter.uex' path='docs/doc[@for="BaseNumberConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can convert an object in the
        ///       given source type to a 64-bit signed integer object using the specified context.</para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\basenumberconverter.uex' path='docs/doc[@for="BaseNumberConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>Converts the given value object to a 64-bit signed integer object.</para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                string text = ((string)value).Trim();

                try {
                    if (AllowHex && text[0] == '#') {
                        return FromString(text.Substring(1), 16);
                    }
                    else if (AllowHex && text.StartsWith("0x") 
                             || text.StartsWith("0X")
                             || text.StartsWith("&h")
                             || text.StartsWith("&H")) {
                        return FromString(text.Substring(2), 16);
                    }
                    else {
                        if (culture == null) {
                            culture = CultureInfo.CurrentCulture;
                        }
                        NumberFormatInfo formatInfo = (NumberFormatInfo)culture.GetFormat(typeof(NumberFormatInfo));
                        return FromString(text, formatInfo);
                    }
                }
                catch (Exception e) {
                    throw FromStringError(text, e);
                }
            }
            return base.ConvertFrom(context, culture, value);
        }
        
        /// <include file='doc\basenumberconverter.uex' path='docs/doc[@for="BaseNumberConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Converts the given value object to a 64-bit signed integer object using the
        ///       arguments.</para>
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string) && value != null && TargetType.IsInstanceOfType(value)) {
                
                if (culture == null) {
                    culture = CultureInfo.CurrentCulture;
                }
                NumberFormatInfo formatInfo = (NumberFormatInfo)culture.GetFormat(typeof(NumberFormatInfo));
                return ToString(value, formatInfo);
            }

            if (destinationType.IsPrimitive) {
                return Convert.ChangeType(value, destinationType);
            }
            return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\basenumberconverter.uex' path='docs/doc[@for="BaseNumberConverter.CanConvertTo"]/*' />
        public override bool CanConvertTo(ITypeDescriptorContext context, Type t) {
            if (base.CanConvertTo(context, t) || t.IsPrimitive) {
                return true;
            }
            return false;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\basecomponenteditor.cs ===
//------------------------------------------------------------------------------
// <copyright file="BaseComponentEditor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Diagnostics;
    using System;

    /// <include file='doc\BaseComponentEditor.uex' path='docs/doc[@for="ComponentEditor"]/*' />
    /// <devdoc>
    ///    <para> Provides the base class for a custom component 
    ///       editor.</para>
    /// </devdoc>
    public abstract class ComponentEditor {
    
        /// <include file='doc\BaseComponentEditor.uex' path='docs/doc[@for="ComponentEditor.EditComponent"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the component was modified.</para>
        /// </devdoc>
        public bool EditComponent(object component) {
            return EditComponent(null, component);
        }
    
        /// <include file='doc\BaseComponentEditor.uex' path='docs/doc[@for="ComponentEditor.EditComponent1"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the component was modified.</para>
        /// </devdoc>
        public abstract bool EditComponent(ITypeDescriptorContext context, object component);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\ambientvalueattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="AmbientValueAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {

    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization.Formatters;

    /// <include file='doc\AmbientValueAttribute.uex' path='docs/doc[@for="AmbientValueAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies the ambient value for a property.  The ambient value is the value you
    ///    can set into a property to make it inherit its ambient.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public sealed class AmbientValueAttribute : Attribute {
    
        private readonly object value;

        /// <include file='doc\AmbientValueAttribute.uex' path='docs/doc[@for="AmbientValueAttribute.AmbientValueAttribute"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.AmbientValueAttribute'/> class, converting the
        ///    specified value to the
        ///    specified type, and using the U.S. English culture as the
        ///    translation
        ///    context.</para>
        /// </devdoc>
        public AmbientValueAttribute(Type type, string value) {
        
            // The try/catch here is because attributes should never throw exceptions.  We would fail to
            // load an otherwise normal class.
            try {
                this.value = TypeDescriptor.GetConverter(type).ConvertFromInvariantString(value);
            }
            catch {
                Debug.Fail("Ambient value attribute of type " + type.FullName + " threw converting from the string '" + value + "'.");
            }
        }

        /// <include file='doc\AmbientValueAttribute.uex' path='docs/doc[@for="AmbientValueAttribute.AmbientValueAttribute1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.AmbientValueAttribute'/> class using a Unicode
        ///    character.</para>
        /// </devdoc>
        public AmbientValueAttribute(char value) {
            this.value = value;
        }
        /// <include file='doc\AmbientValueAttribute.uex' path='docs/doc[@for="AmbientValueAttribute.AmbientValueAttribute2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.AmbientValueAttribute'/> class using an 8-bit unsigned
        ///    integer.</para>
        /// </devdoc>
        public AmbientValueAttribute(byte value) {
            this.value = value;
        }
        /// <include file='doc\AmbientValueAttribute.uex' path='docs/doc[@for="AmbientValueAttribute.AmbientValueAttribute3"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.AmbientValueAttribute'/> class using a 16-bit signed
        ///    integer.</para>
        /// </devdoc>
        public AmbientValueAttribute(short value) {
            this.value = value;
        }
        /// <include file='doc\AmbientValueAttribute.uex' path='docs/doc[@for="AmbientValueAttribute.AmbientValueAttribute4"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.AmbientValueAttribute'/> class using a 32-bit signed
        ///    integer.</para>
        /// </devdoc>
        public AmbientValueAttribute(int value) {
            this.value = value;
        }
        /// <include file='doc\AmbientValueAttribute.uex' path='docs/doc[@for="AmbientValueAttribute.AmbientValueAttribute5"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.AmbientValueAttribute'/> class using a 64-bit signed
        ///    integer.</para>
        /// </devdoc>
        public AmbientValueAttribute(long value) {
            this.value = value;
        }
        /// <include file='doc\AmbientValueAttribute.uex' path='docs/doc[@for="AmbientValueAttribute.AmbientValueAttribute6"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.AmbientValueAttribute'/> class using a
        ///    single-precision floating point
        ///    number.</para>
        /// </devdoc>
        public AmbientValueAttribute(float value) {
            this.value = value;
        }
        /// <include file='doc\AmbientValueAttribute.uex' path='docs/doc[@for="AmbientValueAttribute.AmbientValueAttribute7"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.AmbientValueAttribute'/> class using a
        ///    double-precision floating point
        ///    number.</para>
        /// </devdoc>
        public AmbientValueAttribute(double value) {
            this.value = value;
        }
        /// <include file='doc\AmbientValueAttribute.uex' path='docs/doc[@for="AmbientValueAttribute.AmbientValueAttribute8"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.AmbientValueAttribute'/> class using a <see cref='System.Boolean'/>
        /// value.</para>
        /// </devdoc>
        public AmbientValueAttribute(bool value) {
            this.value = value;
        }
        /// <include file='doc\AmbientValueAttribute.uex' path='docs/doc[@for="AmbientValueAttribute.AmbientValueAttribute9"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.AmbientValueAttribute'/> class using a <see cref='System.String'/>.</para>
        /// </devdoc>
        public AmbientValueAttribute(string value) {
            this.value = value;
        }

        /// <include file='doc\AmbientValueAttribute.uex' path='docs/doc[@for="AmbientValueAttribute.AmbientValueAttribute10"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.AmbientValueAttribute'/>
        /// class.</para>
        /// </devdoc>
        public AmbientValueAttribute(object value) {
            this.value = value;
        }

        /// <include file='doc\AmbientValueAttribute.uex' path='docs/doc[@for="AmbientValueAttribute.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the ambient value of the property this
        ///       attribute is
        ///       bound to.
        ///    </para>
        /// </devdoc>
        public object Value {
            get {
                return value;
            }
        }

        /// <include file='doc\AmbientValueAttribute.uex' path='docs/doc[@for="AmbientValueAttribute.Equals"]/*' />
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            AmbientValueAttribute other = obj as AmbientValueAttribute;

            if (other != null) {
                if (value != null) {
                    return value.Equals(other.Value);
                }
                else {
                    return (other.Value == null);           
                }
            }
            return false;
        }

        /// <include file='doc\AmbientValueAttribute.uex' path='docs/doc[@for="AmbientValueAttribute.GetHashCode"]/*' />
        public override int GetHashCode() {
            return base.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\bindablesupport.cs ===
//------------------------------------------------------------------------------
// <copyright file="BindableSupport.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    

    using System.Diagnostics;
    using System;

    /// <include file='doc\BindableSupport.uex' path='docs/doc[@for="BindableSupport"]/*' />
    /// <devdoc>
    ///    <para>Specifies which values to say if property or event value can be bound to a data
    ///          element or another property or event's value.</para>
    /// </devdoc>
    public enum BindableSupport {
        /// <include file='doc\BindableSupport.uex' path='docs/doc[@for="BindableSupport.No"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The property or event is bindable.
        ///    </para>
        /// </devdoc>
        No        = 0x00,
        /// <include file='doc\BindableSupport.uex' path='docs/doc[@for="BindableSupport.Yes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The property or event is not bindable.
        ///    </para>
        /// </devdoc>
        Yes = 0x01,
        /// <include file='doc\BindableSupport.uex' path='docs/doc[@for="BindableSupport.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       The property or event is the default.
        ///    </para>
        /// </devdoc>
        Default        = 0x02,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\bindableattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="BindableAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\BindableAttribute.uex' path='docs/doc[@for="BindableAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies whether a property is appropriate to bind data
    ///       to.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public sealed class BindableAttribute : Attribute {
        /// <include file='doc\BindableAttribute.uex' path='docs/doc[@for="BindableAttribute.Yes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that a property is appropriate to bind data to. This
        ///    <see langword='static '/>field is read-only. 
        ///    </para>
        /// </devdoc>
        public static readonly BindableAttribute Yes = new BindableAttribute(true);

        /// <include file='doc\BindableAttribute.uex' path='docs/doc[@for="BindableAttribute.No"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that a property is not appropriate to bind
        ///       data to. This <see langword='static '/>field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly BindableAttribute No = new BindableAttribute(false);

        /// <include file='doc\BindableAttribute.uex' path='docs/doc[@for="BindableAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the default value for the <see cref='System.ComponentModel.BindableAttribute'/>,
        ///       which is <see cref='System.ComponentModel.BindableAttribute.No'/>. This <see langword='static '/>field is
        ///       read-only.
        ///    </para>
        /// </devdoc>
        public static readonly BindableAttribute Default = No;

        private bool bindable   = false;
        private bool isDefault  = false;

        /// <include file='doc\BindableAttribute.uex' path='docs/doc[@for="BindableAttribute.BindableAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.BindableAttribute'/> class.
        ///    </para>
        /// </devdoc>
        public BindableAttribute(bool bindable) {
            this.bindable = bindable;
        }

        /// <include file='doc\BindableAttribute.uex' path='docs/doc[@for="BindableAttribute.BindableAttribute1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.BindableAttribute'/> class.
        ///    </para>
        /// </devdoc>
        public BindableAttribute(BindableSupport flags) {
            this.bindable = (flags != BindableSupport.No);
            this.isDefault = (flags == BindableSupport.Default);
        }

        /// <include file='doc\BindableAttribute.uex' path='docs/doc[@for="BindableAttribute.Bindable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating
        ///       whether a property is appropriate to bind data to.
        ///    </para>
        /// </devdoc>
        public bool Bindable {
            get {
                return bindable;
            }
        }

        /// <include file='doc\BindableAttribute.uex' path='docs/doc[@for="BindableAttribute.Equals"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            if (obj != null && obj is BindableAttribute) {
                return ((BindableAttribute)obj).Bindable == bindable;
            }

            return false;
        }

        /// <include file='doc\BindableAttribute.uex' path='docs/doc[@for="BindableAttribute.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return bindable.GetHashCode();
        }

        /// <include file='doc\BindableAttribute.uex' path='docs/doc[@for="BindableAttribute.IsDefaultAttribute"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public override bool IsDefaultAttribute() {
            return (this.Equals(Default) || isDefault);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\browsableattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="BrowsableAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\BrowsableAttribute.uex' path='docs/doc[@for="BrowsableAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies whether a property or event should be displayed in
    ///       a property browsing window.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public sealed class BrowsableAttribute : Attribute {
        /// <include file='doc\BrowsableAttribute.uex' path='docs/doc[@for="BrowsableAttribute.Yes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that a property or event can be modified at
        ///       design time. This <see langword='static '/>
        ///       field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly BrowsableAttribute Yes = new BrowsableAttribute(true);

        /// <include file='doc\BrowsableAttribute.uex' path='docs/doc[@for="BrowsableAttribute.No"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that a property or event cannot be modified at
        ///       design time. This <see langword='static '/>field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly BrowsableAttribute No = new BrowsableAttribute(false);

        /// <include file='doc\BrowsableAttribute.uex' path='docs/doc[@for="BrowsableAttribute.Default"]/*' />
        /// <devdoc>
        /// <para>Specifies the default value for the <see cref='System.ComponentModel.BrowsableAttribute'/>,
        ///    which is <see cref='System.ComponentModel.BrowsableAttribute.Yes'/>. This <see langword='static '/>field is read-only.</para>
        /// </devdoc>
        public static readonly BrowsableAttribute Default = Yes;

        private bool browsable = true;

        /// <include file='doc\BrowsableAttribute.uex' path='docs/doc[@for="BrowsableAttribute.BrowsableAttribute"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.BrowsableAttribute'/> class.</para>
        /// </devdoc>
        public BrowsableAttribute(bool browsable) {
            this.browsable = browsable;
        }

        /// <include file='doc\BrowsableAttribute.uex' path='docs/doc[@for="BrowsableAttribute.Browsable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether an object is browsable.
        ///    </para>
        /// </devdoc>
        public bool Browsable {
            get {
                return browsable;
            }
        }

        /// <include file='doc\BrowsableAttribute.uex' path='docs/doc[@for="BrowsableAttribute.Equals"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            BrowsableAttribute other = obj as BrowsableAttribute;

            return (other != null) && other.Browsable == browsable;
        }

        /// <include file='doc\BrowsableAttribute.uex' path='docs/doc[@for="BrowsableAttribute.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return browsable.GetHashCode();
        }

        /// <include file='doc\BrowsableAttribute.uex' path='docs/doc[@for="BrowsableAttribute.IsDefaultAttribute"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override bool IsDefaultAttribute() {
            return (this.Equals(Default));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\booleanconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="BooleanConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;

    using System.Diagnostics;

    using Microsoft.Win32;
    using System.Collections;
    using System.Globalization;

    /// <include file='doc\BooleanConverter.uex' path='docs/doc[@for="BooleanConverter"]/*' />
    /// <devdoc>
    ///    <para>Provides a type converter to convert
    ///       Boolean objects to and from various other representations.</para>
    /// </devdoc>
    public class BooleanConverter : TypeConverter {
        private static StandardValuesCollection values;


        /// <include file='doc\BooleanConverter.uex' path='docs/doc[@for="BooleanConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object in the given source type to a Boolean object using the
        ///       specified context.</para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\BooleanConverter.uex' path='docs/doc[@for="BooleanConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>Converts the given value
        ///       object to a Boolean object.</para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                string text = ((string)value).Trim();
                try {
                    return Boolean.Parse(text);
                }
                catch (FormatException e) {
                    throw new FormatException(SR.GetString(SR.ConvertInvalidPrimitive, (string)value, "Boolean"), e);
                }
            }
            return base.ConvertFrom(context, culture, value);
        }
    
        /// <include file='doc\BooleanConverter.uex' path='docs/doc[@for="BooleanConverter.GetStandardValues"]/*' />
        /// <devdoc>
        ///    <para>Gets a collection of standard values
        ///       for the Boolean data type.</para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            if (values == null) {
                values = new StandardValuesCollection(new object[] {true, false});
            }
            return values;
        }
    
        /// <include file='doc\BooleanConverter.uex' path='docs/doc[@for="BooleanConverter.GetStandardValuesExclusive"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the list of standard values returned from
        ///    <see cref='System.ComponentModel.BooleanConverter.GetStandardValues'/> is an exclusive list. </para>
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return true;
        }
        
        /// <include file='doc\BooleanConverter.uex' path='docs/doc[@for="BooleanConverter.GetStandardValuesSupported"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this object supports a standard set of values
        ///       that can be picked from a list.</para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\byteconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ByteConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;

    using System.Diagnostics;

    using Microsoft.Win32;

    /// <include file='doc\ByteConverter.uex' path='docs/doc[@for="ByteConverter"]/*' />
    /// <devdoc>
    ///    <para>Provides a
    ///       type converter to convert 8-bit unsigned
    ///       integer objects to and from various other representations.</para>
    /// </devdoc>
    public class ByteConverter : BaseNumberConverter {
    
        /// <include file='doc\ByteConverter.uex' path='docs/doc[@for="ByteConverter.TargetType"]/*' />
        /// <devdoc>
        /// The Type this converter is targeting (e.g. Int16, UInt32, etc.)
        /// </devdoc>
        internal override Type TargetType {
                get {
                    return typeof(Byte);
                }
        }

        /// <include file='doc\ByteConverter.uex' path='docs/doc[@for="ByteConverter.FromString"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given radix
        /// </devdoc>
        internal override object FromString(string value, int radix) {
                return Convert.ToByte(value, radix);
        }
        
        /// <include file='doc\ByteConverter.uex' path='docs/doc[@for="ByteConverter.FromString1"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given formatInfo
        /// </devdoc>
        internal override object FromString(string value, NumberFormatInfo formatInfo) {
                return Byte.Parse(value, NumberStyles.Integer, formatInfo);
        }
        
        
        /// <include file='doc\ByteConverter.uex' path='docs/doc[@for="ByteConverter.FromString2"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given CultureInfo
        /// </devdoc>
        internal override object FromString(string value, CultureInfo culture){
                 return Byte.Parse(value, culture);
        }
        
        /// <include file='doc\ByteConverter.uex' path='docs/doc[@for="ByteConverter.ToString"]/*' />
        /// <devdoc>
        /// Convert the given value from a string using the given formatInfo
        /// </devdoc>
        internal override string ToString(object value, NumberFormatInfo formatInfo) {
                return ((Byte)value).ToString("G", formatInfo);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\canceleventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="CancelEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\CancelEventHandler.uex' path='docs/doc[@for="CancelEventHandler"]/*' />
    /// <devdoc>
    ///    <para>Represents the method that will handle the event raised when canceling an
    ///       event.</para>
    /// </devdoc>
    public delegate void CancelEventHandler(object sender, CancelEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\canceleventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="CancelEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\CancelEventArgs.uex' path='docs/doc[@for="CancelEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.ComponentModel.CancelEventArgs.Cancel'/>
    ///       event.
    ///    </para>
    /// </devdoc>
    public class CancelEventArgs : EventArgs {

        /// <include file='doc\CancelEventArgs.uex' path='docs/doc[@for="CancelEventArgs.cancel"]/*' />
        /// <devdoc>
        ///     Indicates, on return, whether or not the operation should be cancelled
        ///     or not.  'true' means cancel it, 'false' means don't.
        /// </devdoc>
        private bool cancel;
        
        /// <include file='doc\CancelEventArgs.uex' path='docs/doc[@for="CancelEventArgs.CancelEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.CancelEventArgs'/> class with
        ///       cancel set to <see langword='false'/>.
        ///    </para>
        /// </devdoc>
        public CancelEventArgs() : this(false) {
        }

        /// <include file='doc\CancelEventArgs.uex' path='docs/doc[@for="CancelEventArgs.CancelEventArgs1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.CancelEventArgs'/> class with
        ///       cancel set to the given value.
        ///    </para>
        /// </devdoc>
        public CancelEventArgs(bool cancel)
        : base() {
            this.cancel = cancel;
        }

        /// <include file='doc\CancelEventArgs.uex' path='docs/doc[@for="CancelEventArgs.Cancel"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets a value
        ///       indicating whether the operation should be cancelled.
        ///    </para>
        /// </devdoc>
        public bool Cancel {
            get {
                return cancel;
            }
            set {
                this.cancel = value;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\categoryattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="CategoryAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {

    using System;
    using System.ComponentModel;
    using System.Diagnostics;

    /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies the category in which the property or event will be displayed in a
    ///       visual designer.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public class CategoryAttribute : Attribute {
        private static CategoryAttribute appearance;
        private static CategoryAttribute behavior;
        private static CategoryAttribute data;
        private static CategoryAttribute design;
        private static CategoryAttribute action;
        private static CategoryAttribute format;
        private static CategoryAttribute layout;
        private static CategoryAttribute mouse;
        private static CategoryAttribute key;
        private static CategoryAttribute focus;
        private static CategoryAttribute windowStyle;
        private static CategoryAttribute dragDrop;
        private static CategoryAttribute defAttr;
        
        private bool localized;

        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.categoryValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides the actual category name.
        ///    </para>
        /// </devdoc>
        private string categoryValue;

        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.Action"]/*' />
        /// <devdoc>
        ///    <para>Gets the action category attribute.</para>
        /// </devdoc>
        public static CategoryAttribute Action {
            get {
                if (action == null) {
                    action = new CategoryAttribute("Action");
                }
                return action;
            }
        }

        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.Appearance"]/*' />
        /// <devdoc>
        ///    <para>Gets the appearance category attribute.</para>
        /// </devdoc>
        public static CategoryAttribute Appearance {
            get {
                if (appearance == null) {
                    appearance = new CategoryAttribute("Appearance");
                }
                return appearance;
            }
        }

        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.Behavior"]/*' />
        /// <devdoc>
        ///    <para>Gets the behavior category attribute.</para>
        /// </devdoc>
        public static CategoryAttribute Behavior {
            get {
                if (behavior == null) {
                    behavior = new CategoryAttribute("Behavior");
                }
                return behavior;
            }
        }

        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.Data"]/*' />
        /// <devdoc>
        ///    <para>Gets the data category attribute.</para>
        /// </devdoc>
        public static CategoryAttribute Data {
            get {
                if (data == null) {
                    data = new CategoryAttribute("Data");
                }
                return data;
            }
        }

        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>Gets the default category attribute.</para>
        /// </devdoc>
        public static CategoryAttribute Default {
            get {
                if (defAttr == null) {
                    defAttr = new CategoryAttribute();
                }
                return defAttr;
            }
        }
        
        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.Design"]/*' />
        /// <devdoc>
        ///    <para>Gets the design category attribute.</para>
        /// </devdoc>
        public static CategoryAttribute Design {
            get {
                if (design == null) {
                    design = new CategoryAttribute("Design");
                }
                return design;
            }
        }

        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.DragDrop"]/*' />
        /// <devdoc>
        ///    <para>Gets the drag and drop category attribute.</para>
        /// </devdoc>
        public static CategoryAttribute DragDrop {
            get {
                if (dragDrop == null) {
                    dragDrop = new CategoryAttribute("DragDrop");
                }
                return dragDrop;
            }
        }

        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.Focus"]/*' />
        /// <devdoc>
        ///    <para>Gets the focus category attribute.</para>
        /// </devdoc>
        public static CategoryAttribute Focus {
            get {
                if (focus == null) {
                    focus = new CategoryAttribute("Focus");
                }
                return focus;
            }
        }

        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.Format"]/*' />
        /// <devdoc>
        ///    <para>Gets the format category attribute.</para>
        /// </devdoc>
        public static CategoryAttribute Format {
            get {
                if (format == null) {
                    format = new CategoryAttribute("Format");
                }
                return format;
            }
        }

        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.Key"]/*' />
        /// <devdoc>
        ///    <para>Gets the keyboard category attribute.</para>
        /// </devdoc>
        public static CategoryAttribute Key {
            get {
                if (key == null) {
                    key = new CategoryAttribute("Key");
                }
                return key;
            }
        }

        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.Layout"]/*' />
        /// <devdoc>
        ///    <para>Gets the layout category attribute.</para>
        /// </devdoc>
        public static CategoryAttribute Layout {
            get {
                if (layout == null) {
                    layout = new CategoryAttribute("Layout");
                }
                return layout;
            }
        }

        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.Mouse"]/*' />
        /// <devdoc>
        ///    <para>Gets the mouse category attribute.</para>
        /// </devdoc>
        public static CategoryAttribute Mouse {
            get {
                if (mouse == null) {
                    mouse = new CategoryAttribute("Mouse");
                }
                return mouse;
            }
        }

        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.WindowStyle"]/*' />
        /// <devdoc>
        ///    <para> Gets the window style category 
        ///       attribute.</para>
        /// </devdoc>
        public static CategoryAttribute WindowStyle {
            get {
                if (windowStyle == null) {
                    windowStyle = new CategoryAttribute("WindowStyle");
                }
                return windowStyle;
            }
        }

        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.CategoryAttribute"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.CategoryAttribute'/> 
        /// class with the default category.</para>
        /// </devdoc>
        public CategoryAttribute() : this("Default") {
        }

        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.CategoryAttribute1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.CategoryAttribute'/> class with
        ///    the specified category name.</para>
        /// </devdoc>
        public CategoryAttribute(string category) {
            this.categoryValue = category;
            this.localized = false;
        }

        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.Category"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of the category for the property or event 
        ///       that this attribute is bound to.</para>
        /// </devdoc>
        public string Category {
            get {
                if (!localized) {
                    localized = true;
                    string localizedValue = GetLocalizedString(categoryValue);
                    if (localizedValue != null) {
                        categoryValue = localizedValue;
                    }
                }
                return categoryValue;
            }
        }

        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.Equals"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        /// <internalonly/>
        public override bool Equals(object obj){
            if (obj == this) {
                return true;
            }

            if (obj is CategoryAttribute){
                return Category.Equals(((CategoryAttribute)obj).Category);
            }
            return false;
        }

        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return Category.GetHashCode();
        }

        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.GetLocalizedString"]/*' />
        /// <devdoc>
        ///    <para>Looks up the localized name of a given category.</para>
        /// </devdoc>
        protected virtual string GetLocalizedString(string value) {
            return (string)SR.GetObject("PropertyCategory" + value);
        }
        
        /// <include file='doc\CategoryAttribute.uex' path='docs/doc[@for="CategoryAttribute.IsDefaultAttribute"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        /// <internalonly/>
        public override bool IsDefaultAttribute() {
            return Category.Equals(Default.Category);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\cmutils.cs ===
//------------------------------------------------------------------------------
// <copyright file="CMUtils.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Text;
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    using System.Globalization;
    using System.IO;
    using System.ComponentModel;
    using System.Reflection;
    
    internal class CMUtils {

        /// <include file='doc\CMUtils.uex' path='docs/doc[@for="CMUtils.ArraysEqual"]/*' />
        /// <devdoc>
        ///     Compares two arrays for equality. Each element is compared to the
        ///     respective element in the opposite array. All tests are safe will
        ///     null values.
        /// </devdoc>
        public static bool ArraysEqual(Array array1, Array array2) {
            if (array1 == array2) return true;
            if (array1 == null || array2 == null) return false;
            if (array1.Equals(array2))
                return true;
            if (array1.Length != array2.Length)
                return false;
            for (int i = 0; i < array1.Length; i++)
                if (!object.Equals(array1.GetValue(i), array2.GetValue(i)))
                    return false;
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\collectionchangeeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="CollectionChangeEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\CollectionChangeEventHandler.uex' path='docs/doc[@for="CollectionChangeEventHandler"]/*' />
    /// <devdoc>
    ///    <para>Represents the method that will handle the 
    ///    <see langword='CollectionChanged '/>event raised when adding elements to or removing elements from a 
    ///       collection.</para>
    /// </devdoc>
    public delegate void CollectionChangeEventHandler(object sender, CollectionChangeEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\collectionchangeeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="CollectionChangeEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\CollectionChangeEventArgs.uex' path='docs/doc[@for="CollectionChangeEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see langword='CollectionChange '/> event.</para>
    /// </devdoc>
    public class CollectionChangeEventArgs : EventArgs {
        private CollectionChangeAction action;
        private object element;

        /// <include file='doc\CollectionChangeEventArgs.uex' path='docs/doc[@for="CollectionChangeEventArgs.CollectionChangeEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.CollectionChangeEventArgs'/> class.</para>
        /// </devdoc>
        public CollectionChangeEventArgs(CollectionChangeAction action, object element) {
            this.action = action;
            this.element = element;
        }

        /// <include file='doc\CollectionChangeEventArgs.uex' path='docs/doc[@for="CollectionChangeEventArgs.Action"]/*' />
        /// <devdoc>
        ///    <para>Gets an action that specifies how the collection changed.</para>
        /// </devdoc>
        public virtual CollectionChangeAction Action {
            get {
                return action;
            }
        }

        /// <include file='doc\CollectionChangeEventArgs.uex' path='docs/doc[@for="CollectionChangeEventArgs.Element"]/*' />
        /// <devdoc>
        ///    <para>Gets the instance of the collection with the change. </para>
        /// </devdoc>
        public virtual object Element {
            get {
                return element;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\collectionchangeaction.cs ===
//------------------------------------------------------------------------------
// <copyright file="CollectionChangeAction.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\CollectionChangeAction.uex' path='docs/doc[@for="CollectionChangeAction"]/*' />
    /// <devdoc>
    ///    <para>Specifies how the collection is changed.</para>
    /// </devdoc>
    public enum CollectionChangeAction {
        /// <include file='doc\CollectionChangeAction.uex' path='docs/doc[@for="CollectionChangeAction.Add"]/*' />
        /// <devdoc>
        ///    <para> Specifies that an element is added to the collection.</para>
        /// </devdoc>
        Add = 1,

        /// <include file='doc\CollectionChangeAction.uex' path='docs/doc[@for="CollectionChangeAction.Remove"]/*' />
        /// <devdoc>
        ///    <para>Specifies that an element is removed from the collection.</para>
        /// </devdoc>
        Remove = 2,

        /// <include file='doc\CollectionChangeAction.uex' path='docs/doc[@for="CollectionChangeAction.Refresh"]/*' />
        /// <devdoc>
        ///    <para>Specifies that the entire collection has changed.</para>
        /// </devdoc>
        Refresh = 3
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\charconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="CharConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;

    using System.Diagnostics;

    using Microsoft.Win32;
    using System.Globalization;

    /// <include file='doc\CharConverter.uex' path='docs/doc[@for="CharConverter"]/*' />
    /// <devdoc>
    ///    <para>Provides
    ///       a type converter to convert Unicode
    ///       character objects to and from various other representations.</para>
    /// </devdoc>
    public class CharConverter : TypeConverter {

        /// <include file='doc\CharConverter.uex' path='docs/doc[@for="CharConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object in the given source type to a Unicode character object using
        ///       the specified context.</para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

		/// <include file='doc\CharConverter.uex' path='docs/doc[@for="CharConverter.ConvertTo"]/*' />
		/// <devdoc>
		///      Converts the given object to another type.
		/// </devdoc>
		public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) 
		{
			if (destinationType == typeof(string) && value is char)
			{
				if ((char)value == (char)0)
				{
					return "";
				}
			}
            
			return base.ConvertTo(context, culture, value, destinationType);
		}

		/// <include file='doc\CharConverter.uex' path='docs/doc[@for="CharConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>Converts the given object to a Unicode character object.</para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                string text = ((string)value).Trim();

                if (text != null && text.Length > 0) {
                    if (text.Length != 1) {
                        throw new FormatException(SR.GetString(SR.ConvertInvalidPrimitive, text, "Char"));
                    }
                    return text[0];
                }

                return '\0';
            }
            return base.ConvertFrom(context, culture, value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\collectionconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="CollectionConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;

    using System.Diagnostics;

    using Microsoft.Win32;
    using System.Collections;
    using System.Globalization;

    /// <include file='doc\CollectionConverter.uex' path='docs/doc[@for="CollectionConverter"]/*' />
    /// <devdoc>
    ///    <para>Provides a type converter to convert
    ///       collection objects to and from various other representations.</para>
    /// </devdoc>
    public class CollectionConverter : TypeConverter {
    
        /// <include file='doc\CollectionConverter.uex' path='docs/doc[@for="CollectionConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Converts the given
        ///       value object to the
        ///       specified destination type.</para>
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {
                if (value is ICollection) {
                    return SR.GetString(SR.CollectionConverterText);
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
        
        /// <include file='doc\CollectionConverter.uex' path='docs/doc[@for="CollectionConverter.GetProperties"]/*' />
        /// <devdoc>
        ///    <para>Gets a collection of properties for
        ///       the type of array specified by the value parameter using the specified context and
        ///       attributes.</para>
        /// </devdoc>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {
            //return new PropertyDescriptorCollection(null);
            return null;
        }
       
        /// <include file='doc\CollectionConverter.uex' path='docs/doc[@for="CollectionConverter.GetPropertiesSupported"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this object
        ///       supports properties.</para>
        /// </devdoc>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
            return false;
        }
        
        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\componentcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComponentCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ComponentCollection.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
//------------------------------------------------------------------------------
// <autogenerated>
//     This class was generated by a tool.
//     Runtime Version: 1.0.2204.0
//
//     Changes to this file may cause incorrect behavior and will be lost if 
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System;
    using System.Collections;
    using System.ComponentModel;
    using System.Globalization;
    
    /** The component in the container identified by name. */
    /// <include file='doc\ComponentCollection.uex' path='docs/doc[@for="ComponentCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Gets a specific <see cref='System.ComponentModel.Component'/> in the <see cref='System.ComponentModel.Container'/>
    ///       .
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class ComponentCollection : ReadOnlyCollectionBase {
        /// <include file='doc\ComponentCollection.uex' path='docs/doc[@for="ComponentCollection.ComponentCollection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ComponentCollection(IComponent[] components) {
            InnerList.AddRange(components);
        }

        /** The component in the container identified by name. */
        /// <include file='doc\ComponentCollection.uex' path='docs/doc[@for="ComponentCollection.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a specific <see cref='System.ComponentModel.Component'/> in the <see cref='System.ComponentModel.Container'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public virtual IComponent this[string name] {
            get {
                if (name != null) {
                    IList list = InnerList;
                    foreach(IComponent comp in list) {
                        if (comp != null && comp.Site != null && comp.Site.Name != null && string.Compare(comp.Site.Name, name, true, CultureInfo.InvariantCulture) == 0) {
                            return comp;
                        }
                    }
                }
                return null;
            }
        }
        
        /** The component in the container identified by index. */
        /// <include file='doc\ComponentCollection.uex' path='docs/doc[@for="ComponentCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a specific <see cref='System.ComponentModel.Component'/> in the <see cref='System.ComponentModel.Container'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public virtual IComponent this[int index] {
            get {
                return (IComponent)InnerList[index];
            }
        }
        
        /// <include file='doc\ComponentCollection.uex' path='docs/doc[@for="ComponentCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(IComponent[] array, int index) {
            InnerList.CopyTo(array, index);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\component.cs ===
//------------------------------------------------------------------------------
// <copyright file="Component.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {

    using System;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;
    
    /// <include file='doc\Component.uex' path='docs/doc[@for="Component"]/*' />
    /// <devdoc>
    ///    <para>Provides the default implementation for the 
    ///    <see cref='System.ComponentModel.IComponent'/>
    ///    interface and enables object-sharing between applications.</para>
    /// </devdoc>
    [
        DesignerCategory("Component")
    ]
    public class Component : MarshalByRefObject, IComponent {

        /// <devdoc>
        ///    <para>Static hask key for the Disposed event. This field is read-only.</para>
        /// </devdoc>
        private static readonly object EventDisposed = new object(); 

        private ISite site;
        private EventHandlerList events;

        /// <include file='doc\Component.uex' path='docs/doc[@for="Component.Finalize"]/*' />
        ~Component() {
            Dispose(false);
        }

        /// <include file='doc\Component.uex' path='docs/doc[@for="Component.Disposed"]/*' />
        /// <devdoc>
        ///    <para>Adds a event handler to listen to the Disposed event on the component.</para>
        /// </devdoc>
        [
        Browsable(false),
        EditorBrowsable(EditorBrowsableState.Advanced)
        ]
        public event EventHandler Disposed {
            add {
                Events.AddHandler(EventDisposed, value);
            }
            remove {
                Events.RemoveHandler(EventDisposed, value);
            }
        }

        /// <include file='doc\Component.uex' path='docs/doc[@for="Component.Events"]/*' />
        /// <devdoc>
        ///    <para>Gets the list of event handlers that are attached to this component.</para>
        /// </devdoc>
        protected EventHandlerList Events {
            get {
                if (events == null) {
                    events = new EventHandlerList();
                }
                return events;
            }
        }

        /// <include file='doc\Component.uex' path='docs/doc[@for="Component.Site"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the site of the <see cref='System.ComponentModel.Component'/>
        ///       .
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public virtual ISite Site {
            get { return site;}
            set { site = value;}
        }

        /// <include file='doc\Component.uex' path='docs/doc[@for="Component.Dispose"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Disposes of the <see cref='System.ComponentModel.Component'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
    
        /// <include file='doc\Component.uex' path='docs/doc[@for="Component.Dispose2"]/*' />
        /// <devdoc>
        ///    <para>
        ///    Disposes all the resources associated with this component.
        ///    If disposing is false then you must never touch any other
        ///    managed objects, as they may already be finalized. When
        ///    in this state you should dispose any native resources
        ///    that you have a reference to.
        ///    </para>
        ///    <para>
        ///    When disposing is true then you should dispose all data
        ///    and objects you have references to. The normal implementation
        ///    of this method would look something like:
        ///    </para>
        ///    <code>
        ///    public void Dispose() {
        ///        Dispose(true);
        ///        GC.SuppressFinalize(this);
        ///    }
        ///
        ///    protected virtual void Dispose(bool disposing) {
        ///        if (disposing) {
        ///            if (myobject != null) {
        ///                myobject.Dispose();
        ///                myobject = null;
        ///            }
        ///        }
        ///        if (myhandle != IntPtr.Zero) {
        ///            NativeMethods.Release(myhandle);
        ///            myhandle = IntPtr.Zero;
        ///        }
        ///    }
        ///
        ///    ~MyClass() {
        ///        Dispose(false);
        ///    }
        ///    </code>
        ///    <para>
        ///    For base classes, you should never override the Finalier (~Class in C#)
        ///    or the Dispose method that takes no arguments, rather you should
        ///    always override the Dispose method that takes a bool. 
        ///    </para>
        ///    <code>
        ///    protected override void Dispose(bool disposing) {
        ///        if (disposing) {
        ///            if (myobject != null) {
        ///                myobject.Dispose();
        ///                myobject = null;
        ///            }
        ///        }
        ///        if (myhandle != IntPtr.Zero) {
        ///            NativeMethods.Release(myhandle);
        ///            myhandle = IntPtr.Zero;
        ///        }
        ///        base.Dispose(disposing);
        ///    }
        ///    </code>
        /// </devdoc>
        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                lock(this) {
                    if (site != null && site.Container != null) {
                        site.Container.Remove(this);
                    }
                    if (events != null) {
                        EventHandler handler = (EventHandler)events[EventDisposed];
                        if (handler != null) handler(this, EventArgs.Empty);
                    }
                }
            }
        }

        /**
         * Returns the component's container.
         *
         * @return an object implementing the IContainer interface that represents the
         * component's container. If the component does not have a site, null is returned.
         */
        /// <include file='doc\Component.uex' path='docs/doc[@for="Component.Container"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the <see cref='System.ComponentModel.IContainer'/>
        ///       that contains the <see cref='System.ComponentModel.Component'/>
        ///       .
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        public IContainer Container {
            get {
                ISite s = site;
                return s == null? null : s.Container;
            }
        }

        /// <include file='doc\Component.uex' path='docs/doc[@for="Component.GetService"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns an object representing a service provided by
        ///       the <see cref='System.ComponentModel.Component'/>
        ///       .
        ///    </para>
        /// </devdoc>
        protected virtual object GetService(Type service) {
            ISite s = site;
            return((s== null) ? null : s.GetService(service));
        }

        /// <include file='doc\Component.uex' path='docs/doc[@for="Component.DesignMode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the <see cref='System.ComponentModel.Component'/>
        ///       is currently in design mode.
        ///    </para>
        /// </devdoc>
        [
        Browsable(false),
        DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)
        ]
        protected bool DesignMode {
            get {
                ISite s = site;
                return(s == null) ? false : s.DesignMode;
            }
        }

        /// <include file='doc\Component.uex' path='docs/doc[@for="Component.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Returns a <see cref='System.String'/> containing the name of the <see cref='System.ComponentModel.Component'/> , if any. This method should not be
        ///       overridden. For
        ///       internal use only.
        ///    </para>
        /// </devdoc>
        public override String ToString() {
            ISite s = site;

            if (s != null)
                return s.Name + " [" + GetType().FullName + "]";
            else
                return GetType().FullName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\componentconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComponentConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;
    using Microsoft.Win32;
    using System.ComponentModel.Design;
    using System.Collections;
    using System.Diagnostics;

    /// <include file='doc\ComponentConverter.uex' path='docs/doc[@for="ComponentConverter"]/*' />
    /// <devdoc>
    ///    <para>Provides a type converter to convert component objects to and
    ///       from various other representations.</para>
    /// </devdoc>
    public class ComponentConverter : ReferenceConverter {
    
        /// <include file='doc\ComponentConverter.uex' path='docs/doc[@for="ComponentConverter.ComponentConverter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.ComponentConverter'/> class.
        ///    </para>
        /// </devdoc>
        public ComponentConverter(Type type) : base(type) {
        }

        /// <include file='doc\ComponentConverter.uex' path='docs/doc[@for="ComponentConverter.GetProperties"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a collection of properties for the type of component
        ///       specified by the value
        ///       parameter.</para>
        /// </devdoc>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {
            return TypeDescriptor.GetProperties(value, attributes);
        }
        
        /// <include file='doc\ComponentConverter.uex' path='docs/doc[@for="ComponentConverter.GetPropertiesSupported"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating whether this object supports properties using the
        ///       specified context.</para>
        /// </devdoc>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\cultureinfoconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="CultureInfoConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Reflection;
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel.Design.Serialization;
    using System.Diagnostics;
    using Microsoft.Win32;
    using System.Collections;
    using System.Globalization;
    using System.Threading;

    /// <include file='doc\CultureInfoConverter.uex' path='docs/doc[@for="CultureInfoConverter"]/*' />
    /// <devdoc>
    /// <para>Provides a type converter to convert <see cref='System.Globalization.CultureInfo'/>
    /// objects to and from various other representations.</para>
    /// </devdoc>
    public class CultureInfoConverter : TypeConverter {
    
        private StandardValuesCollection values;

        /// <include file='doc\CultureInfoConverter.uex' path='docs/doc[@for="CultureInfoConverter.DefaultCultureString"]/*' />
        /// <devdoc>
        ///      Retrieves the "default" name for our culture.
        /// </devdoc>
        private string DefaultCultureString {
            get {
                return SR.GetString(SR.CultureInfoConverterDefaultCultureString);
            }
        }
        
        /// <include file='doc\CultureInfoConverter.uex' path='docs/doc[@for="CultureInfoConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this converter can
        ///       convert an object in the given source type to a System.Globalization.CultureInfo
        ///       object using
        ///       the specified context.
        ///    </para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\CultureInfoConverter.uex' path='docs/doc[@for="CultureInfoConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\CultureInfoConverter.uex' path='docs/doc[@for="CultureInfoConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the specified value object to a <see cref='System.Globalization.CultureInfo'/>
        ///       object.
        ///    </para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {

            if (value is string) {
                string text = (string)value;
                CultureInfo retVal = null;

                CultureInfo currentUICulture = Thread.CurrentThread.CurrentUICulture;

                if (culture != null && culture.Equals(CultureInfo.InvariantCulture)) {
                    Thread.CurrentThread.CurrentUICulture = culture;
                }

                try {
                    // Look for the default culture info.
                    //
                    if (text == null || text.Length == 0 || string.Compare(text, DefaultCultureString, true, CultureInfo.CurrentCulture) == 0) {
                        retVal = CultureInfo.InvariantCulture;
                    }

                    // Now look in our set of installed cultures.
                    //
                    if (retVal == null) {
                        ICollection values = GetStandardValues(context);
                        IEnumerator e = values.GetEnumerator();
                        while (e.MoveNext()) {
                            CultureInfo info = (CultureInfo)e.Current;
                            if (info != null && string.Compare(info.DisplayName, text, true, CultureInfo.CurrentCulture) == 0) {
                                retVal = info;
                                break;
                            }
                        }
                    }

                    // Now try to create a new culture info from this value
                    //
                    if (retVal == null) {
                        try {
                            retVal = new CultureInfo(text);
                        }
                        catch(Exception) {
                        }
                    }

                    // Finally, try to find a partial match
                    //
                    if (retVal == null) {
                        text = text.ToLower(CultureInfo.CurrentCulture);
                        IEnumerator e = values.GetEnumerator();
                        while (e.MoveNext()) {
                            CultureInfo info = (CultureInfo)e.Current;
                            if (info != null && info.DisplayName.ToLower(CultureInfo.CurrentCulture).StartsWith(text)) {
                                retVal = info;
                                break;
                            }
                        }
                    }
                }
                finally {
                    Thread.CurrentThread.CurrentUICulture = currentUICulture;
                }
                
                // No good.  We can't support it.
                //
                if (retVal == null) {
                    throw new ArgumentException(SR.GetString(SR.CultureInfoConverterInvalidCulture, (string)value));
                }
                return retVal;
            }
            
            return base.ConvertFrom(context, culture, value);
        }
        
        /// <include file='doc\CultureInfoConverter.uex' path='docs/doc[@for="CultureInfoConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Converts the given
        ///       value object to the
        ///       specified destination type.
        ///    </para>
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {

                string retVal;
                CultureInfo currentUICulture = Thread.CurrentThread.CurrentUICulture;

                if (culture != null && culture.Equals(CultureInfo.InvariantCulture)) {
                    Thread.CurrentThread.CurrentUICulture = culture;
                }

                try {
                    if (value == null || value == CultureInfo.InvariantCulture) {
                        retVal = DefaultCultureString;
                    }
                    else {
                        retVal = ((CultureInfo)value).DisplayName;
                    }
                }
                finally {
                    Thread.CurrentThread.CurrentUICulture = currentUICulture;
                }

                return retVal;
            }
            if (destinationType == typeof(InstanceDescriptor) && value is CultureInfo) {
                CultureInfo c = (CultureInfo) value;
                ConstructorInfo ctor = typeof(CultureInfo).GetConstructor(new Type[] {typeof(string)});
                if (ctor != null) {
                    return new InstanceDescriptor(ctor, new object[] {c.Name});
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    
        /// <include file='doc\CultureInfoConverter.uex' path='docs/doc[@for="CultureInfoConverter.GetStandardValues"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a collection of standard values collection for a System.Globalization.CultureInfo
        ///       object using the specified context.
        ///    </para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            if (values == null) {                
                CultureInfo[] installedCultures =  CultureInfo.GetCultures(CultureTypes.AllCultures);                               
                ArrayList cultureList = new ArrayList();
                
                // populate the array with the default culture, which is NULL
                //
                cultureList.Add(null);
                
                // Now populate it with the installed cultures.
                //
                for (int index = 0; index < installedCultures.Length; ++ index)
                    cultureList.Add(installedCultures[index]);                
                
                ArrayList.Adapter(cultureList).Sort(new CultureComparer());
                
                values = new StandardValuesCollection(cultureList.ToArray());
            }
            
            return values;
        }
    
        /// <include file='doc\CultureInfoConverter.uex' path='docs/doc[@for="CultureInfoConverter.GetStandardValuesExclusive"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the list of standard values returned from
        ///       System.ComponentModel.CultureInfoConverter.GetStandardValues is an exclusive list.
        ///    </para>
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return false;
        }
        
        /// <include file='doc\CultureInfoConverter.uex' path='docs/doc[@for="CultureInfoConverter.GetStandardValuesSupported"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this object supports a
        ///       standard set of values that can be picked from a list using the specified
        ///       context.
        ///    </para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
        
        /// <include file='doc\CultureInfoConverter.uex' path='docs/doc[@for="CultureInfoConverter.CultureComparer"]/*' />
        /// <devdoc>
        ///      IComparer object used for sorting CultureInfos
        /// </devdoc>
        private class CultureComparer : IComparer {

            public int Compare(object item1, object item2) {
            
                if (item1 == null) {
                
                    // If both are null, then they are equal
                    //
                    if (item2 == null) {
                        return 0;
                    }

                    // Otherwise, item1 is null, but item2 is valid (greater)
                    //
                    return -1; 
                }
                
                if (item2 == null) {
                
                    // item2 is null, so item 1 is greater
                    //
                    return 1; 
                }

                String itemName1 = ((CultureInfo)item1).DisplayName;
                String itemName2 = ((CultureInfo)item2).DisplayName;

                CompareInfo compInfo = (CultureInfo.CurrentCulture).CompareInfo;
                return compInfo.Compare(itemName1, itemName2, CompareOptions.StringSort);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\datetimeconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DateTimeConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {

    using System.ComponentModel.Design.Serialization;
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.Globalization;
    using System.Reflection;
    using System.Runtime.InteropServices;
    using System.Runtime.Remoting;
    using System.Runtime.Serialization.Formatters;

    /// <include file='doc\DateTimeConverter.uex' path='docs/doc[@for="DateTimeConverter"]/*' />
    /// <devdoc>
    /// <para>Provides a type converter to convert <see cref='System.DateTime'/>
    /// objects to and from various other representations.</para>
    /// </devdoc>
    public class DateTimeConverter : TypeConverter {
    
        /// <include file='doc\DateTimeConverter.uex' path='docs/doc[@for="DateTimeConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object in the given source type to a <see cref='System.DateTime'/>
        ///       object using the
        ///       specified context.</para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\DateTimeConverter.uex' path='docs/doc[@for="DateTimeConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\DateTimeConverter.uex' path='docs/doc[@for="DateTimeConverter.ConvertFrom"]/*' />
        /// <devdoc>
        /// <para>Converts the given value object to a <see cref='System.DateTime'/>
        /// object.</para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                string text = ((string)value).Trim();
                if (text.Length == 0) {
                    return DateTime.MinValue;
                }
                try {
                    // See if we have a culture info to parse with.  If so, then use it.
                    //
                    DateTimeFormatInfo formatInfo = null;
                    
                    if (culture != null ) {
                        formatInfo = (DateTimeFormatInfo)culture.GetFormat(typeof(DateTimeFormatInfo));
                    }
                    
                    if (formatInfo != null) {
                        return DateTime.Parse(text, formatInfo);
                    }
                    else {
                        return DateTime.Parse(text);
                    }
                }
                catch (FormatException e) {
                    throw new FormatException(SR.GetString(SR.ConvertInvalidPrimitive, (string)value, "DateTime"), e);
                }
            }
            
            return base.ConvertFrom(context, culture, value);
        }

        /// <include file='doc\DateTimeConverter.uex' path='docs/doc[@for="DateTimeConverter.ConvertTo"]/*' />
        /// <devdoc>
        /// <para>Converts the given value object to a <see cref='System.DateTime'/>
        /// object
        /// using the arguments.</para>
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == typeof(string) && value is DateTime) {
                DateTime dt = (DateTime) value;
                if (dt == DateTime.MinValue) {
                    return string.Empty;
                }
                
                if (culture == null) {
                    culture = CultureInfo.CurrentCulture;
                }

                DateTimeFormatInfo formatInfo = null;                
                formatInfo = (DateTimeFormatInfo)culture.GetFormat(typeof(DateTimeFormatInfo));
                                
                string format;
                if (culture == CultureInfo.InvariantCulture) {
                    if (dt.TimeOfDay.TotalSeconds == 0) {
                        return dt.ToString("yyyy-MM-dd", culture);
                    }
                    else {
                        return dt.ToString(culture);
                    }                
                }
                if (dt.TimeOfDay.TotalSeconds == 0) {
                    format = formatInfo.ShortDatePattern;
                }
                else {
                    format = formatInfo.ShortDatePattern + " " + formatInfo.ShortTimePattern;
                }
                
                return dt.ToString(format, CultureInfo.CurrentCulture);
            }
            if (destinationType == typeof(InstanceDescriptor) && value is DateTime) {
                DateTime dt = (DateTime)value;
                
                if (dt.Ticks == 0) {
                    // Make a special case for the empty DateTime
                    //
                    ConstructorInfo ctr = typeof(DateTime).GetConstructor(new Type[] {typeof(Int64)});
                        
                    if (ctr != null) {
                        return new InstanceDescriptor(ctr, new object[] {
                            dt.Ticks });
                    }
                }
                
                ConstructorInfo ctor = typeof(DateTime).GetConstructor(new Type[] {
                    typeof(int), typeof(int), typeof(int), typeof(int), 
                    typeof(int), typeof(int), typeof(int)});
                    
                if (ctor != null) {
                    return new InstanceDescriptor(ctor, new object[] {
                        dt.Year, dt.Month, dt.Day, dt.Hour, dt.Minute, dt.Second, dt.Millisecond});
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\container.cs ===
/*
 * Copyright (c) 1999, Microsoft Corporation. All Rights Reserved.
 * Information Contained Herein is Proprietary and Confidential.
 */
namespace System.ComponentModel {

    using System;
    using System.IO;
    using System.ComponentModel;
    using System.Globalization;
    
    /**
     * @security(checkClassLinking=on)
     */
    /// <include file='doc\Container.uex' path='docs/doc[@for="Container"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Encapsulates
    ///       zero or more components.
    ///    </para>
    /// </devdoc>
    public class Container : IContainer {
        private ISite[] sites;
        private int siteCount;

        /// <include file='doc\Container.uex' path='docs/doc[@for="Container.Finalize"]/*' />
        ~Container() {
            Dispose(false);
        }

        /** Adds a component to the container. */
        /// <include file='doc\Container.uex' path='docs/doc[@for="Container.Add"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds the specified component to the <see cref='System.ComponentModel.Container'/>
        ///       . The component is unnamed.
        ///    </para>
        /// </devdoc>
        public virtual void Add(IComponent component) {
            Add(component, null);
        }

        /** Adds a component to the container. */
        /// <include file='doc\Container.uex' path='docs/doc[@for="Container.Add1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Adds the specified component to the <see cref='System.ComponentModel.Container'/> and assigns a name to
        ///       it.
        ///    </para>
        /// </devdoc>
        public virtual void Add(IComponent component, String name) {
            lock(this) {
            
                if (component == null) {
                    return;
                }
                
                ISite site = component.Site;
                
                if (site != null && site.Container == this) {
                    return;
                }
                
                if (sites == null) {
                    sites = new ISite[4];
                }
                else {
                    // Validate that new components
                    // have either a null name or a unique one.
                    //
                    if (name != null) {
                        for (int i = 0; i < Math.Min(siteCount,sites.Length); i++) {
                            ISite s = sites[ i ];
                            
                            if (s != null && s.Name != null && string.Compare(s.Name, name, true, CultureInfo.InvariantCulture) == 0) {
                                throw new ArgumentException(SR.GetString(SR.DuplicateComponentName, name));
                            }
                        }
                    }
                
                    if (sites.Length == siteCount) {
                        ISite[] newSites = new ISite[siteCount * 2];
                        Array.Copy(sites, 0, newSites, 0, siteCount);
                        sites = newSites;
                    }
                }
                
                if (site != null) {
                    site.Container.Remove(component);
                }

                ISite newSite = CreateSite(component, name);
                sites[siteCount++] = newSite;
                component.Site = newSite;
            }
        }

        /** Creates a site for the component within the container. */
        /// <include file='doc\Container.uex' path='docs/doc[@for="Container.CreateSite"]/*' />
        /// <devdoc>
        /// <para>Creates a Site <see cref='System.ComponentModel.ISite'/> for the given <see cref='System.ComponentModel.IComponent'/>
        /// and assigns the given name to the site.</para>
        /// </devdoc>
        protected virtual ISite CreateSite(IComponent component, string name) {
            return new Site(component, this, name);
        }

        /**
         * Disposes of the container.  A call to the Dispose method indicates that
         * the user of the container has no further need for it.
         *
         * The implementation of Dispose must:
         *
         * (1) Remove any references the container is holding to other components.
         *     This is typically accomplished by assigning null to any fields that
         *     contain references to other components.
         *
         * (2) Release any system resources that are associated with the container,
         *     such as file handles, window handles, or database connections.
         *
         * (3) Dispose of child components by calling the Dispose method of each.
         *
         * Ideally, a call to Dispose will revert a container to the state it was
         * in immediately after it was created. However, this is not a requirement.
         * Following a call to its Dispose method, a container is permitted to raise
         * exceptions for operations that cannot meaningfully be performed.
         */
        /// <include file='doc\Container.uex' path='docs/doc[@for="Container.Dispose"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Disposes of the <see cref='System.ComponentModel.Container'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\Container.uex' path='docs/doc[@for="Container.Dispose1"]/*' />
        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                lock(this) {
                    while (siteCount > 0) {
                        ISite site = sites[--siteCount];
                        site.Component.Site = null;
                        site.Component.Dispose();
                    }
                    sites = null;
                }
            }
        }

        /// <include file='doc\Container.uex' path='docs/doc[@for="Container.GetService"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected virtual object GetService(Type service) {
            return((service == typeof(IContainer)) ? this : null);
        }

        /** The components in the container. */
        /// <include file='doc\Container.uex' path='docs/doc[@for="Container.Components"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets all the components in the <see cref='System.ComponentModel.Container'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public virtual ComponentCollection Components {
            get {
                lock(this) {
                    IComponent[] result = new IComponent[siteCount];
                    for (int i = 0; i < siteCount; i++)
                        result[i] = sites[i].Component;
                    return new ComponentCollection(result);
                }
            }
        }

        /** Removes a component from the container. */
        /// <include file='doc\Container.uex' path='docs/doc[@for="Container.Remove"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Removes a component from the <see cref='System.ComponentModel.Container'/>
        ///       .
        ///    </para>
        /// </devdoc>
        public virtual void Remove(IComponent component) {
            lock(this) {
                if (component == null)
                    return;
                ISite site = component.Site;
                if (site == null || site.Container != this)
                    return;
                component.Site = null;
                for (int i = 0; i < siteCount; i++) {
                    if (sites[i] == site) {
                        siteCount--;
                        Array.Copy(sites, i + 1, sites, i, siteCount - i);
                        sites[siteCount] = null;
                        break;
                    }
                }
            }
        }

        /**
         * @security(checkClassLinking=on)
         */
        private class Site : ISite {
            private IComponent component;
            private Container container;
            private String name;

            internal Site(IComponent component, Container container, String name) {
                this.component = component;
                this.container = container;
                this.name = name;
            }

            /** The component sited by this component site. */
            public IComponent Component {
                get {
                    return component;
                }
            }

            /** The container in which the component is sited. */
            public IContainer Container {
                get {
                    return container;
                }
            }

            public Object GetService(Type service) {
                return((service == typeof(ISite)) ? this : container.GetService(service));
            }


            /** Indicates whether the component is in design mode. */
            public bool DesignMode {
                get {
                    return false;
                }
            }

            /** 
             * The name of the component.
             */
            public String Name {
                get { return name;}
                set { 
                    if (value == null || name == null || !value.Equals(name)) {
                        name = value;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\componentresourcemanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="ComponentResourceManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {

    using System;
    using System.Collections;
    using System.Globalization;
    using System.Reflection;
    using System.Resources;

    /// <include file='doc\ComponentResourceManager.uex' path='docs/doc[@for="ComponentResourceManager"]/*' />
    /// <devdoc>
    /// The ComponentResourceManager is a resource manager object that
    /// provides simple functionality for enumerating resources for
    /// a component or object.
    /// </devdoc>
    public class ComponentResourceManager : ResourceManager {

        private Hashtable   resourceSets;

        /// <include file='doc\ComponentResourceManager.uex' path='docs/doc[@for="ComponentResourceManager.ComponentResourceManager"]/*' />
        public ComponentResourceManager() : base() {
        }

        /// <include file='doc\ComponentResourceManager.uex' path='docs/doc[@for="ComponentResourceManager.ComponentResourceManager1"]/*' />
        public ComponentResourceManager(Type t) : base(t) {
        }

        /// <include file='doc\ComponentResourceManager.uex' path='docs/doc[@for="ComponentResourceManager.ApplyResources"]/*' />
        /// <devdoc>
        ///     This method examines all the resources for the current culture.
        ///     When it finds a resource with a key in the format of 
        ///     &quot;[objectName].[property name]&quot; it will apply that resource's value
        ///     to the corresponding property on the object.  If there is no matching
        ///     property the resource will be ignored.
        /// </devdoc>
        public void ApplyResources(object value, string objectName) {
            ApplyResources(value, objectName, null);
        }

        /// <include file='doc\ComponentResourceManager.uex' path='docs/doc[@for="ComponentResourceManager.ApplyResources1"]/*' />
        /// <devdoc>
        ///     This method examines all the resources for the provided culture.
        ///     When it finds a resource with a key in the format of 
        ///     &quot[objectName].[property name]&quot; it will apply that resource's value
        ///     to the corresponding property on the object.  If there is no matching
        ///     property the resource will be ignored.
        /// </devdoc>
        public virtual void ApplyResources(object value, string objectName, CultureInfo culture) {
            if (value == null) {
                throw new ArgumentNullException("value");
            }
            if (objectName == null) {
                throw new ArgumentNullException("objectName");
            }
            if (culture == null) {
                culture = CultureInfo.CurrentUICulture;
            }

            // The general case here will be to always use the same culture, so optimize for
            // that.  The resourceSets hashtable uses culture as a key.  It's value is
            // another hashtable that contains ALL the culture values (so it traverses up
            // the parent culture chain) for that culture.  This means that if ApplyResources
            // is called with different cultures there could be some redundancy in the
            // table, but it allows the normal case of calling with a single culture to 
            // be much faster.
            //
            Hashtable resources;

            if (resourceSets == null) {
                ResourceSet dummy;
                resourceSets = new Hashtable();
                resources = FillResources(culture, out dummy);
                resourceSets[culture] = resources;
            }
            else {
                resources = (Hashtable)resourceSets[culture];
                if (resources == null || ((resources is CaseInsensitiveHashtable) != IgnoreCase)) {
                    ResourceSet dummy;
                    resources = FillResources(culture, out dummy);
                    resourceSets[culture] = resources;
                }
            }

            BindingFlags flags = BindingFlags.Public | BindingFlags.GetProperty | BindingFlags.Instance;
             
            if (IgnoreCase) {
                flags |= BindingFlags.IgnoreCase;
            }

            bool componentReflect = false;
            if (value is IComponent) {
                ISite site = ((IComponent)value).Site;
                if (site != null && site.DesignMode) {
                    componentReflect = true;
                }
            }

            foreach(DictionaryEntry de in resources) {

                // See if this key matches our object.
                //
                string key = de.Key as string;
                if (key == null) {
                    continue;
                }

                if (IgnoreCase) {
                    if (string.Compare(key, 0, objectName, 0, objectName.Length, true, CultureInfo.InvariantCulture) != 0) {
                        continue;
                    }
                }
                else {
                    if (string.CompareOrdinal(key, 0, objectName, 0, objectName.Length) != 0) {
                        continue;
                    }
                }

                // Character after objectName.Length should be a ".", or else we should continue.
                //
                int idx = objectName.Length;
                if (key.Length <= idx || key[idx] != '.' ) {
                    continue;
                }

                // Bypass type descriptor if we are not in design mode.  TypeDescriptor does an attribute
                // scan which is quite expensive.
                //
                string propName = key.Substring(idx + 1);

                if (componentReflect) {
                    PropertyDescriptor prop = TypeDescriptor.GetProperties(value).Find(propName, IgnoreCase);

                    if (prop != null && !prop.IsReadOnly && (de.Value == null || prop.PropertyType.IsInstanceOfType(de.Value))) {
                        prop.SetValue(value, de.Value);
                    }
                }
                else {
                    PropertyInfo prop = value.GetType().GetProperty(propName, flags);

                    if (prop != null && prop.CanWrite && (de.Value == null || prop.PropertyType.IsInstanceOfType(de.Value))) {
                        prop.SetValue(value, de.Value, null);
                    }
                }
            }
        }

        /// <devdoc>
        ///     Recursive routine that creates a resource hashtable
        ///     populated with resources for culture and all parent
        ///     cultures.
        /// </devdoc>
        private Hashtable FillResources(CultureInfo culture, out ResourceSet resourceSet) {

            Hashtable hashtable;
            ResourceSet parentResourceSet = null;

            // Traverse parents first, so we always replace more
            // specific culture values with less specific.
            //
            CultureInfo parent = culture.Parent;
            if (parent != culture) {
                hashtable = FillResources(parent, out parentResourceSet);
            }
            else {

                // We're at the bottom, so create the hashtable
                // 
                if (IgnoreCase) {
                    hashtable = new CaseInsensitiveHashtable();
                }
                else {
                    hashtable = new Hashtable();
                }
            }

            // Now walk culture's resource set.  Another thing we
            // do here is ask ResourceManager to traverse up the 
            // parent chain.  We do NOT want to do this because
            // we are trawling up the parent chain ourselves, but by
            // passing in true for the second parameter the resource
            // manager will cache the culture it did find, so when we 
            // do recurse all missing resources will be filled in
            // so we are very fast.  That's why we remember what our
            // parent resource set's instance was -- if they are the
            // same, we're looking at a cache we've already applied.
            //
            resourceSet = GetResourceSet(culture, true, true);
            if (resourceSet != null && !object.ReferenceEquals(resourceSet, parentResourceSet)) {
                foreach(DictionaryEntry de in resourceSet) {
                    hashtable[de.Key] = de.Value;
                }
            }

            return hashtable;
        }

        private sealed class CaseInsensitiveHashtable : Hashtable {
            internal CaseInsensitiveHashtable() : base(new CaseInsensitiveHashCodeProvider(CultureInfo.InvariantCulture), new CaseInsensitiveComparer(CultureInfo.InvariantCulture)) {
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\defaultpropertyattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DefaultPropertyAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\DefaultPropertyAttribute.uex' path='docs/doc[@for="DefaultPropertyAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies the default property for a component.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    public sealed class DefaultPropertyAttribute : Attribute {
        /// <include file='doc\DefaultPropertyAttribute.uex' path='docs/doc[@for="DefaultPropertyAttribute.name"]/*' />
        /// <devdoc>
        ///     This is the default event name.
        /// </devdoc>
        private readonly string name;

        /// <include file='doc\DefaultPropertyAttribute.uex' path='docs/doc[@for="DefaultPropertyAttribute.DefaultPropertyAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of
        ///       the <see cref='System.ComponentModel.DefaultPropertyAttribute'/> class.
        ///    </para>
        /// </devdoc>
        public DefaultPropertyAttribute(string name) {
            this.name = name;
        }

        /// <include file='doc\DefaultPropertyAttribute.uex' path='docs/doc[@for="DefaultPropertyAttribute.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the default property for the component this attribute is
        ///       bound to.
        ///    </para>
        /// </devdoc>
        public string Name {
            get {
                return name;
            }
        }

        /// <include file='doc\DefaultPropertyAttribute.uex' path='docs/doc[@for="DefaultPropertyAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the default value for the <see cref='System.ComponentModel.DefaultPropertyAttribute'/>, which is <see langword='null'/>. This
        ///    <see langword='static '/>field is read-only. 
        ///    </para>
        /// </devdoc>
        public static readonly DefaultPropertyAttribute Default = new DefaultPropertyAttribute(null);

        /// <include file='doc\DefaultPropertyAttribute.uex' path='docs/doc[@for="DefaultPropertyAttribute.Equals"]/*' />
        public override bool Equals(object obj) {
            DefaultPropertyAttribute other = obj as DefaultPropertyAttribute; 
            return (other != null) && other.Name == name;
        }

        /// <include file='doc\DefaultPropertyAttribute.uex' path='docs/doc[@for="DefaultPropertyAttribute.GetHashCode"]/*' />
        public override int GetHashCode() {
            return base.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\designerattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;
    using System.ComponentModel.Design;
    using System.Globalization;
    
    /// <include file='doc\DesignerAttribute.uex' path='docs/doc[@for="DesignerAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies the class to use to implement design-time services.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface, AllowMultiple=true, Inherited=true)]
    public sealed class DesignerAttribute : Attribute {
        private readonly string designerTypeName;
        private readonly string designerBaseTypeName;
        private string typeId;

        /// <include file='doc\DesignerAttribute.uex' path='docs/doc[@for="DesignerAttribute.DesignerAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.DesignerAttribute'/> class using the name of the type that
        ///       provides design-time services.
        ///    </para>
        /// </devdoc>
        public DesignerAttribute(string designerTypeName) {
            string temp = designerTypeName.ToUpper(CultureInfo.InvariantCulture);
            Debug.Assert(temp.IndexOf(".DLL") == -1, "Came across: " + designerTypeName + " . Please remove the .dll extension");
            this.designerTypeName = designerTypeName;
            this.designerBaseTypeName = typeof(IDesigner).FullName;
        }

        /// <include file='doc\DesignerAttribute.uex' path='docs/doc[@for="DesignerAttribute.DesignerAttribute1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.DesignerAttribute'/> class using the type that provides
        ///       design-time services.
        ///    </para>
        /// </devdoc>
        public DesignerAttribute(Type designerType) {
            this.designerTypeName = designerType.AssemblyQualifiedName;
            this.designerBaseTypeName = typeof(IDesigner).FullName;
        }

        /// <include file='doc\DesignerAttribute.uex' path='docs/doc[@for="DesignerAttribute.DesignerAttribute2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.DesignerAttribute'/> class using the designer type and the
        ///       base class for the designer.
        ///    </para>
        /// </devdoc>
        public DesignerAttribute(string designerTypeName, string designerBaseTypeName) {
            string temp = designerTypeName.ToUpper(CultureInfo.InvariantCulture);
            Debug.Assert(temp.IndexOf(".DLL") == -1, "Came across: " + designerTypeName + " . Please remove the .dll extension");
            this.designerTypeName = designerTypeName;
            this.designerBaseTypeName = designerBaseTypeName;
        }
        
        /// <include file='doc\DesignerAttribute.uex' path='docs/doc[@for="DesignerAttribute.DesignerAttribute3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.DesignerAttribute'/> class, using the name of the designer
        ///       class and the base class for the designer.
        ///    </para>
        /// </devdoc>
        public DesignerAttribute(string designerTypeName, Type designerBaseType) {
            string temp = designerTypeName.ToUpper(CultureInfo.InvariantCulture);
            Debug.Assert(temp.IndexOf(".DLL") == -1, "Came across: " + designerTypeName + " . Please remove the .dll extension");
            this.designerTypeName = designerTypeName;
            this.designerBaseTypeName = designerBaseType.AssemblyQualifiedName;
        }

        /// <include file='doc\DesignerAttribute.uex' path='docs/doc[@for="DesignerAttribute.DesignerAttribute4"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.DesignerAttribute'/> class using the types of the designer and
        ///       designer base class.
        ///    </para>
        /// </devdoc>
        public DesignerAttribute(Type designerType, Type designerBaseType) {
            this.designerTypeName = designerType.AssemblyQualifiedName;
            this.designerBaseTypeName = designerBaseType.AssemblyQualifiedName;
        }

        /// <include file='doc\DesignerAttribute.uex' path='docs/doc[@for="DesignerAttribute.DesignerBaseTypeName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the name of the base type of this designer.
        ///    </para>
        /// </devdoc>
        public string DesignerBaseTypeName {
            get {
                return designerBaseTypeName;
            }
        }
        
        /// <include file='doc\DesignerAttribute.uex' path='docs/doc[@for="DesignerAttribute.DesignerTypeName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the designer type associated with this designer attribute.
        ///    </para>
        /// </devdoc>
        public string DesignerTypeName {
            get {
                return designerTypeName;
            }
        }
        
        /// <include file='doc\DesignerAttribute.uex' path='docs/doc[@for="DesignerAttribute.TypeId"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       This defines a unique ID for this attribute type. It is used
        ///       by filtering algorithms to identify two attributes that are
        ///       the same type. For most attributes, this just returns the
        ///       Type instance for the attribute. DesignerAttribute overrides
        ///       this to include the type of the designer base type.
        ///    </para>
        /// </devdoc>
        public override object TypeId {
            get {
                if (typeId == null) {
                    string baseType = designerBaseTypeName;
                    int comma = baseType.IndexOf(',');
                    if (comma != -1) {
                        baseType = baseType.Substring(0, comma);
                    }
                    typeId = GetType().FullName + baseType;
                }
                return typeId;
            }
        }

        /// <include file='doc\DesignerAttribute.uex' path='docs/doc[@for="DesignerAttribute.Equals"]/*' />
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            DesignerAttribute other = obj as DesignerAttribute;

            return (other != null) && other.designerBaseTypeName == designerBaseTypeName && other.designerTypeName == designerTypeName;
        }

        /// <include file='doc\DesignerAttribute.uex' path='docs/doc[@for="DesignerAttribute.GetHashCode"]/*' />
        public override int GetHashCode() {
            return designerTypeName.GetHashCode() ^ designerBaseTypeName.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\defaulteventattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DefaultEventAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.ComponentModel;
    using System.Diagnostics;
    using System;

    /// <include file='doc\DefaultEventAttribute.uex' path='docs/doc[@for="DefaultEventAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies the default event for a
    ///       component.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    public sealed class DefaultEventAttribute : Attribute {
        /// <include file='doc\DefaultEventAttribute.uex' path='docs/doc[@for="DefaultEventAttribute.name"]/*' />
        /// <devdoc>
        ///     This is the default event name.
        /// </devdoc>
        private readonly string name;

        /// <include file='doc\DefaultEventAttribute.uex' path='docs/doc[@for="DefaultEventAttribute.DefaultEventAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes
        ///       a new instance of the <see cref='System.ComponentModel.DefaultEventAttribute'/> class.
        ///    </para>
        /// </devdoc>
        public DefaultEventAttribute(string name) {
            this.name = name;
        }


        /// <include file='doc\DefaultEventAttribute.uex' path='docs/doc[@for="DefaultEventAttribute.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the default event for
        ///       the component this attribute is bound to.
        ///    </para>
        /// </devdoc>
        public string Name {
            get {
                return name;
            }
        }

        /// <include file='doc\DefaultEventAttribute.uex' path='docs/doc[@for="DefaultEventAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the default value for the <see cref='System.ComponentModel.DefaultEventAttribute'/>, which is
        ///    <see langword='null'/>.
        ///       This <see langword='static '/>field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly DefaultEventAttribute Default = new DefaultEventAttribute(null);

        /// <include file='doc\DefaultEventAttribute.uex' path='docs/doc[@for="DefaultEventAttribute.Equals"]/*' />
        public override bool Equals(object obj) {
            DefaultEventAttribute other = obj as DefaultEventAttribute; 
            return (other != null) && other.Name == name;
        }

        /// <include file='doc\DefaultEventAttribute.uex' path='docs/doc[@for="DefaultEventAttribute.GetHashCode"]/*' />
        public override int GetHashCode() {
            return base.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\defaultvalueattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DefaultValueAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {

    using System;
    using System.ComponentModel;
    using System.Diagnostics;
    using System.Globalization;
    using System.Runtime.InteropServices;
    using System.Runtime.Serialization.Formatters;

    /// <include file='doc\DefaultValueAttribute.uex' path='docs/doc[@for="DefaultValueAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies the default value for a property.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public sealed class DefaultValueAttribute : Attribute {
        /// <include file='doc\DefaultValueAttribute.uex' path='docs/doc[@for="DefaultValueAttribute.value"]/*' />
        /// <devdoc>
        ///     This is the default value.
        /// </devdoc>
        private readonly object value;

        /// <include file='doc\DefaultValueAttribute.uex' path='docs/doc[@for="DefaultValueAttribute.DefaultValueAttribute"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.DefaultValueAttribute'/> class, converting the
        ///    specified value to the
        ///    specified type, and using the U.S. English culture as the
        ///    translation
        ///    context.</para>
        /// </devdoc>
        public DefaultValueAttribute(Type type, string value) {
        
            // The try/catch here is because attributes should never throw exceptions.  We would fail to
            // load an otherwise normal class.
            try {
                this.value = TypeDescriptor.GetConverter(type).ConvertFromInvariantString(value);
            }
            catch {
                Debug.Fail("Default value attribute of type " + type.FullName + " threw converting from the string '" + value + "'.");
            }
        }

        /// <include file='doc\DefaultValueAttribute.uex' path='docs/doc[@for="DefaultValueAttribute.DefaultValueAttribute1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.DefaultValueAttribute'/> class using a Unicode
        ///    character.</para>
        /// </devdoc>
        public DefaultValueAttribute(char value) {
            this.value = value;
        }
        /// <include file='doc\DefaultValueAttribute.uex' path='docs/doc[@for="DefaultValueAttribute.DefaultValueAttribute2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.DefaultValueAttribute'/> class using an 8-bit unsigned
        ///    integer.</para>
        /// </devdoc>
        public DefaultValueAttribute(byte value) {
            this.value = value;
        }
        /// <include file='doc\DefaultValueAttribute.uex' path='docs/doc[@for="DefaultValueAttribute.DefaultValueAttribute3"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.DefaultValueAttribute'/> class using a 16-bit signed
        ///    integer.</para>
        /// </devdoc>
        public DefaultValueAttribute(short value) {
            this.value = value;
        }
        /// <include file='doc\DefaultValueAttribute.uex' path='docs/doc[@for="DefaultValueAttribute.DefaultValueAttribute4"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.DefaultValueAttribute'/> class using a 32-bit signed
        ///    integer.</para>
        /// </devdoc>
        public DefaultValueAttribute(int value) {
            this.value = value;
        }
        /// <include file='doc\DefaultValueAttribute.uex' path='docs/doc[@for="DefaultValueAttribute.DefaultValueAttribute5"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.DefaultValueAttribute'/> class using a 64-bit signed
        ///    integer.</para>
        /// </devdoc>
        public DefaultValueAttribute(long value) {
            this.value = value;
        }
        /// <include file='doc\DefaultValueAttribute.uex' path='docs/doc[@for="DefaultValueAttribute.DefaultValueAttribute6"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.DefaultValueAttribute'/> class using a
        ///    single-precision floating point
        ///    number.</para>
        /// </devdoc>
        public DefaultValueAttribute(float value) {
            this.value = value;
        }
        /// <include file='doc\DefaultValueAttribute.uex' path='docs/doc[@for="DefaultValueAttribute.DefaultValueAttribute7"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.DefaultValueAttribute'/> class using a
        ///    double-precision floating point
        ///    number.</para>
        /// </devdoc>
        public DefaultValueAttribute(double value) {
            this.value = value;
        }
        /// <include file='doc\DefaultValueAttribute.uex' path='docs/doc[@for="DefaultValueAttribute.DefaultValueAttribute8"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.DefaultValueAttribute'/> class using a <see cref='System.Boolean'/>
        /// value.</para>
        /// </devdoc>
        public DefaultValueAttribute(bool value) {
            this.value = value;
        }
        /// <include file='doc\DefaultValueAttribute.uex' path='docs/doc[@for="DefaultValueAttribute.DefaultValueAttribute9"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.DefaultValueAttribute'/> class using a <see cref='System.String'/>.</para>
        /// </devdoc>
        public DefaultValueAttribute(string value) {
            this.value = value;
        }

        /// <include file='doc\DefaultValueAttribute.uex' path='docs/doc[@for="DefaultValueAttribute.DefaultValueAttribute10"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.DefaultValueAttribute'/>
        /// class.</para>
        /// </devdoc>
        public DefaultValueAttribute(object value) {
            this.value = value;
        }

        /// <include file='doc\DefaultValueAttribute.uex' path='docs/doc[@for="DefaultValueAttribute.Value"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the default value of the property this
        ///       attribute is
        ///       bound to.
        ///    </para>
        /// </devdoc>
        public object Value {
            get {
                return value;
            }
        }

        /// <include file='doc\DefaultValueAttribute.uex' path='docs/doc[@for="DefaultValueAttribute.Equals"]/*' />
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            DefaultValueAttribute other = obj as DefaultValueAttribute;

            if (other != null) {
                if (value != null) {
                    return value.Equals(other.Value);
                }
                else {
                    return (other.Value == null);           
                }
            }
            return false;
        }

        /// <include file='doc\DefaultValueAttribute.uex' path='docs/doc[@for="DefaultValueAttribute.GetHashCode"]/*' />
        public override int GetHashCode() {
            return base.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\descriptionattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DescriptionAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\DescriptionAttribute.uex' path='docs/doc[@for="DescriptionAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies a description for a property
    ///       or event.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public class DescriptionAttribute : Attribute {
        /// <include file='doc\DescriptionAttribute.uex' path='docs/doc[@for="DescriptionAttribute.Default"]/*' />
        /// <devdoc>
        /// <para>Specifies the default value for the <see cref='System.ComponentModel.DescriptionAttribute'/> , which is an
        ///    empty string (""). This <see langword='static'/> field is read-only.</para>
        /// </devdoc>
        public static readonly DescriptionAttribute Default = new DescriptionAttribute();
        private string description;

        /// <include file='doc\DescriptionAttribute.uex' path='docs/doc[@for="DescriptionAttribute.DescriptionAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public DescriptionAttribute() : this (string.Empty) {
        }

        /// <include file='doc\DescriptionAttribute.uex' path='docs/doc[@for="DescriptionAttribute.DescriptionAttribute1"]/*' />
        /// <devdoc>
        ///    <para>Initializes a new instance of the <see cref='System.ComponentModel.DescriptionAttribute'/> class.</para>
        /// </devdoc>
        public DescriptionAttribute(string description) {
            this.description = description;
        }

        /// <include file='doc\DescriptionAttribute.uex' path='docs/doc[@for="DescriptionAttribute.Description"]/*' />
        /// <devdoc>
        ///    <para>Gets the description stored in this attribute.</para>
        /// </devdoc>
        public virtual string Description {
            get {
                return DescriptionValue;
            }
        }

        /// <include file='doc\DescriptionAttribute.uex' path='docs/doc[@for="DescriptionAttribute.DescriptionValue"]/*' />
        /// <devdoc>
        ///     Read/Write property that directly modifies the string stored
        ///     in the description attribute. The default implementation
        ///     of the Description property simply returns this value.
        /// </devdoc>
        protected string DescriptionValue {
            get {
                return description;
            }
            set {
                description = value;
            }
        }

        /// <include file='doc\DescriptionAttribute.uex' path='docs/doc[@for="DescriptionAttribute.Equals"]/*' />
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            DescriptionAttribute other = obj as DescriptionAttribute;

            return (other != null) && other.Description == Description;
        }

        /// <include file='doc\DescriptionAttribute.uex' path='docs/doc[@for="DescriptionAttribute.GetHashCode"]/*' />
        public override int GetHashCode() {
            return Description.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\decimalconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DecimalConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;

    using System.Diagnostics;

    using Microsoft.Win32;

    /// <include file='doc\DecimalConverter.uex' path='docs/doc[@for="DecimalConverter"]/*' />
    /// <devdoc>
    /// <para>Provides a type converter to convert <see cref='System.Decimal'/>
    /// objects to and from various
    /// other representations.</para>
    /// </devdoc>
    public class DecimalConverter : BaseNumberConverter {
    
          
        /// <include file='doc\DecimalConverter.uex' path='docs/doc[@for="DecimalConverter.AllowHex"]/*' />
        /// <devdoc>
        /// Determines whether this editor will attempt to convert hex (0x or #) strings
        /// </devdoc>
        internal override bool AllowHex {
                get {
                     return false;
                }
        }
    
         /// <include file='doc\DecimalConverter.uex' path='docs/doc[@for="DecimalConverter.TargetType"]/*' />
         /// <devdoc>
        /// The Type this converter is targeting (e.g. Int16, UInt32, etc.)
        /// </devdoc>
        internal override Type TargetType {
                get {
                    return typeof(Decimal);
                }
        }
        
        /// <include file='doc\DecimalConverter.uex' path='docs/doc[@for="DecimalConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }
        
        /// <include file='doc\DecimalConverter.uex' path='docs/doc[@for="DecimalConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }
            
            if (destinationType == typeof(InstanceDescriptor) && value is Decimal) {
            
                object[] args = new object[] { Decimal.GetBits((Decimal)value) };
                MemberInfo member = typeof(Decimal).GetConstructor(new Type[] {typeof(Int32[])});
                
                Debug.Assert(member != null, "Could not convert decimal to member.  Did someone change method name / signature and not update DecimalConverter?");
                if (member != null) {
                    return new InstanceDescriptor(member, args);
                }
                else {
                    return null;
                }
            }

            return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\DecimalConverter.uex' path='docs/doc[@for="DecimalConverter.FromString"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given radix
        /// </devdoc>
        internal override object FromString(string value, int radix) {
                return Convert.ToDecimal(value);
        }
        
        /// <include file='doc\DecimalConverter.uex' path='docs/doc[@for="DecimalConverter.FromString1"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given formatInfo
        /// </devdoc>
        internal override object FromString(string value, NumberFormatInfo formatInfo) {
                return Decimal.Parse(value, NumberStyles.Float, formatInfo);
        }
        
        
        /// <include file='doc\DecimalConverter.uex' path='docs/doc[@for="DecimalConverter.FromString2"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given CultureInfo
        /// </devdoc>
        internal override object FromString(string value, CultureInfo culture){
                 return Decimal.Parse(value, culture);
        }
        
        /// <include file='doc\DecimalConverter.uex' path='docs/doc[@for="DecimalConverter.ToString"]/*' />
        /// <devdoc>
        /// Convert the given value from a string using the given formatInfo
        /// </devdoc>
        internal override string ToString(object value, NumberFormatInfo formatInfo) {
                return ((Decimal)value).ToString("G", formatInfo);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\designerserializationvisibility.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerSerializationVisibility.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {

    using System;

    /// <include file='doc\DesignerSerializationVisibility.uex' path='docs/doc[@for="DesignerSerializationVisibility"]/*' />
    /// <devdoc>
    ///    <para>Specifies the visibility a property has to the design time
    ///          serializer.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public enum DesignerSerializationVisibility {
    
        /// <include file='doc\DesignerSerializationVisibility.uex' path='docs/doc[@for="DesignerSerializationVisibility.Hidden"]/*' />
        /// <devdoc>
        ///    <para>The code generator will not produce code for the object.</para>
        /// </devdoc>
        Hidden,
        
        /// <include file='doc\DesignerSerializationVisibility.uex' path='docs/doc[@for="DesignerSerializationVisibility.Visible"]/*' />
        /// <devdoc>
        ///    <para>The code generator will produce code for the object.</para>
        /// </devdoc>
        Visible,
        
        /// <include file='doc\DesignerSerializationVisibility.uex' path='docs/doc[@for="DesignerSerializationVisibility.Content"]/*' />
        /// <devdoc>
        ///    <para>The code generator will produce code for the contents of the object, rather than for the object itself.</para>
        /// </devdoc>
        Content
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\designercategoryattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerCategoryAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    
    using System;
    using System.ComponentModel;

    /// <include file='doc\DesignerCategoryAttribute.uex' path='docs/doc[@for="DesignerCategoryAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies that the designer for a class belongs to a certain
    ///       category.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=false, Inherited=true)]
    public sealed class DesignerCategoryAttribute : Attribute {
        private string category;
        private string typeId;
        
        /// <include file='doc\DesignerCategoryAttribute.uex' path='docs/doc[@for="DesignerCategoryAttribute.Component"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that a component marked with this category uses a
        ///       component designer. This <see langword='static '/>field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly DesignerCategoryAttribute Component = new DesignerCategoryAttribute("Component");
        
        /// <include file='doc\DesignerCategoryAttribute.uex' path='docs/doc[@for="DesignerCategoryAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that a component marked with this category cannot use a visual
        ///       designer. This <see langword='static '/>field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly DesignerCategoryAttribute Default = new DesignerCategoryAttribute();
        
        /// <include file='doc\DesignerCategoryAttribute.uex' path='docs/doc[@for="DesignerCategoryAttribute.Form"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that a component marked with this category uses a form designer.
        ///       This <see langword='static '/>field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly DesignerCategoryAttribute Form = new DesignerCategoryAttribute("Form");
        
        /// <include file='doc\DesignerCategoryAttribute.uex' path='docs/doc[@for="DesignerCategoryAttribute.Generic"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that a component marked with this category uses a generic designer.
        ///       This <see langword='static '/>field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly DesignerCategoryAttribute Generic = new DesignerCategoryAttribute("Designer");
        
        /// <include file='doc\DesignerCategoryAttribute.uex' path='docs/doc[@for="DesignerCategoryAttribute.DesignerCategoryAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.DesignerCategoryAttribute'/> class with the
        ///       default category.
        ///    </para>
        /// </devdoc>
        public DesignerCategoryAttribute() {
            category = string.Empty;
        }

        /// <include file='doc\DesignerCategoryAttribute.uex' path='docs/doc[@for="DesignerCategoryAttribute.DesignerCategoryAttribute1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.DesignerCategoryAttribute'/> class with
        ///       the given category name.
        ///    </para>
        /// </devdoc>
        public DesignerCategoryAttribute(string category) {
            this.category = category;
        }

        /// <include file='doc\DesignerCategoryAttribute.uex' path='docs/doc[@for="DesignerCategoryAttribute.Category"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the category.
        ///    </para>
        /// </devdoc>
        public string Category {
            get {
                return category;
            }
        }

        /// <include file='doc\DesignerCategoryAttribute.uex' path='docs/doc[@for="DesignerCategoryAttribute.TypeId"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       This defines a unique ID for this attribute type. It is used
        ///       by filtering algorithms to identify two attributes that are
        ///       the same type. For most attributes, this just returns the
        ///       Type instance for the attribute. DesignerAttribute overrides
        ///       this to include the name of the category
        ///    </para>
        /// </devdoc>
        public override object TypeId {
            get {
                if (typeId == null) {
                    typeId = GetType().FullName + Category;
                }
                return typeId;
            }
        }


        /// <include file='doc\DesignerCategoryAttribute.uex' path='docs/doc[@for="DesignerCategoryAttribute.Equals"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        /// <internalonly/>
        public override bool Equals(object obj){
            if (obj == this) {
                return true;
            }

            DesignerCategoryAttribute other = obj as DesignerCategoryAttribute;
            return (other != null) && other.category == category;
        }
        
        /// <include file='doc\DesignerCategoryAttribute.uex' path='docs/doc[@for="DesignerCategoryAttribute.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return category.GetHashCode();
        }

        /// <include file='doc\DesignerCategoryAttribute.uex' path='docs/doc[@for="DesignerCategoryAttribute.IsDefaultAttribute"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        /// <internalonly/>
        public override bool IsDefaultAttribute() {
            return category.Equals(Default.Category);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\designerserializationvisibilityattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignerSerializationVisibilityAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {   
    using System.Diagnostics;
    using System;

    /// <include file='doc\DesignerSerializationVisibilityAttribute.uex' path='docs/doc[@for="DesignerSerializationVisibilityAttribute"]/*' />
    /// <devdoc>
    ///    <para>
    ///         Specifies the visibility of this property or method as seen
    ///         by the designer serializer.
    ///    </para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Property | AttributeTargets.Method)]
    public sealed class DesignerSerializationVisibilityAttribute : Attribute {
        /// <include file='doc\DesignerSerializationVisibilityAttribute.uex' path='docs/doc[@for="DesignerSerializationVisibilityAttribute.Content"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that a visual designer should serialize the contents of this property,
        ///       rather than the property itself.
        ///       This <see langword='static '/>field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly DesignerSerializationVisibilityAttribute Content = new DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Content);

        /// <include file='doc\DesignerSerializationVisibilityAttribute.uex' path='docs/doc[@for="DesignerSerializationVisibilityAttribute.Hidden"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that a
        ///       visual designer will not serialize the value of this property.
        ///       This <see langword='static '/>field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly DesignerSerializationVisibilityAttribute Hidden = new DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Hidden);

        /// <include file='doc\DesignerSerializationVisibilityAttribute.uex' path='docs/doc[@for="DesignerSerializationVisibilityAttribute.Visible"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that a
        ///       visual designer may use default rules when serializing the value of a property.
        ///       This <see langword='static '/>field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly DesignerSerializationVisibilityAttribute Visible = new DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility.Visible);
        
        /// <include file='doc\DesignerSerializationVisibilityAttribute.uex' path='docs/doc[@for="DesignerSerializationVisibilityAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the default value, which is <see cref='System.ComponentModel.DesignerSerializationVisibilityAttribute.Visible'/>, that is, a visual designer 
        ///       uses default rules to generate the value of a property. This
        ///    <see langword='static '/>field is read-only. 
        ///    </para>
        /// </devdoc>
        public static readonly DesignerSerializationVisibilityAttribute Default = Visible;

        private DesignerSerializationVisibility visibility;

        /// <include file='doc\DesignerSerializationVisibilityAttribute.uex' path='docs/doc[@for="DesignerSerializationVisibilityAttribute.DesignerSerializationVisibilityAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the System.ComponentModel.PersistContentsAttribute class.
        ///    </para>
        /// </devdoc>
        public DesignerSerializationVisibilityAttribute(DesignerSerializationVisibility visibility) {
            this.visibility = visibility;
        }

        /// <include file='doc\DesignerSerializationVisibilityAttribute.uex' path='docs/doc[@for="DesignerSerializationVisibilityAttribute.Visibility"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether a
        ///       visual designer must generate special code to persist the value of a property.
        ///    </para>
        /// </devdoc>
        public DesignerSerializationVisibility Visibility {
            get {
                return visibility;
            }
        }

        /// <include file='doc\DesignerSerializationVisibilityAttribute.uex' path='docs/doc[@for="DesignerSerializationVisibilityAttribute.Equals"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override bool Equals(object obj) {
    
            if (obj == this) {
                return true;
            }

            DesignerSerializationVisibilityAttribute other = obj as DesignerSerializationVisibilityAttribute;
            return other != null && other.Visibility == visibility;
        }

        /// <include file='doc\DesignerSerializationVisibilityAttribute.uex' path='docs/doc[@for="DesignerSerializationVisibilityAttribute.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the hashcode for this object.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

        /// <include file='doc\DesignerSerializationVisibilityAttribute.uex' path='docs/doc[@for="DesignerSerializationVisibilityAttribute.IsDefaultAttribute"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public override bool IsDefaultAttribute() {
            return (this.Equals(Default));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\editorattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="EditorAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    
     using System.Diagnostics;
     using System.Globalization;
                                
    /// <include file='doc\EditorAttribute.uex' path='docs/doc[@for="EditorAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies the editor to use to change a property. This class cannot be inherited.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All, AllowMultiple=true, Inherited=true)]
    public sealed class EditorAttribute : Attribute {

        private string baseTypeName;
        private string typeName;
        private string typeId;
        
        /// <include file='doc\EditorAttribute.uex' path='docs/doc[@for="EditorAttribute.EditorAttribute"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.EditorAttribute'/> class with the default editor, which is
        ///    no editor.</para>
        /// </devdoc>
        public EditorAttribute() {
            this.typeName = string.Empty;
            this.baseTypeName = string.Empty;
        }

        /// <include file='doc\EditorAttribute.uex' path='docs/doc[@for="EditorAttribute.EditorAttribute1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.EditorAttribute'/> class with the type name and base type
        ///    name of the editor.</para>
        /// </devdoc>
        public EditorAttribute(string typeName, string baseTypeName) {
            string temp = typeName.ToUpper(CultureInfo.InvariantCulture);
            Debug.Assert(temp.IndexOf(".DLL") == -1, "Came across: " + typeName + " . Please remove the .dll extension");
            this.typeName = typeName;
            this.baseTypeName = baseTypeName;
        }

        /// <include file='doc\EditorAttribute.uex' path='docs/doc[@for="EditorAttribute.EditorAttribute2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.EditorAttribute'/> class.</para>
        /// </devdoc>
        public EditorAttribute(string typeName, Type baseType) {
            string temp = typeName.ToUpper(CultureInfo.InvariantCulture);
            Debug.Assert(temp.IndexOf(".DLL") == -1, "Came across: " + typeName + " . Please remove the .dll extension");
            this.typeName = typeName;
            this.baseTypeName = baseType.AssemblyQualifiedName;
        }

        /// <include file='doc\EditorAttribute.uex' path='docs/doc[@for="EditorAttribute.EditorAttribute3"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.EditorAttribute'/>
        /// class.</para>
        /// </devdoc>
        public EditorAttribute(Type type, Type baseType) {
            this.typeName = type.AssemblyQualifiedName;
            this.baseTypeName = baseType.AssemblyQualifiedName;
        }

        /// <include file='doc\EditorAttribute.uex' path='docs/doc[@for="EditorAttribute.EditorBaseTypeName"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of the base class or interface serving as a lookup key for this editor.</para>
        /// </devdoc>
        public string EditorBaseTypeName {
            get {
                return baseTypeName;
            }
        }

        /// <include file='doc\EditorAttribute.uex' path='docs/doc[@for="EditorAttribute.EditorTypeName"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of the editor class.</para>
        /// </devdoc>
        public string EditorTypeName {
            get {
                return typeName;
            }
        }
    
        /// <include file='doc\EditorAttribute.uex' path='docs/doc[@for="EditorAttribute.TypeId"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       This defines a unique ID for this attribute type. It is used
        ///       by filtering algorithms to identify two attributes that are
        ///       the same type. For most attributes, this just returns the
        ///       Type instance for the attribute. EditorAttribute overrides
        ///       this to include the type of the editor base type.
        ///    </para>
        /// </devdoc>
        public override object TypeId {
            get {
                if (typeId == null) {
                    string baseType = baseTypeName;
                    int comma = baseType.IndexOf(',');
                    if (comma != -1) {
                        baseType = baseType.Substring(0, comma);
                    }
                    typeId = GetType().FullName + baseType;
                }
                return typeId;
            }
        }

        /// <include file='doc\EditorAttribute.uex' path='docs/doc[@for="EditorAttribute.Equals"]/*' />
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            EditorAttribute other = obj as EditorAttribute;

            return (other != null) && other.typeName == typeName && other.baseTypeName == baseTypeName;
        }

        /// <include file='doc\EditorAttribute.uex' path='docs/doc[@for="EditorAttribute.GetHashCode"]/*' />
        public override int GetHashCode() {
            return base.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\designonlyattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignOnlyAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\DesignOnlyAttribute.uex' path='docs/doc[@for="DesignOnlyAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies whether a property can only be set at
    ///       design time.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public sealed class DesignOnlyAttribute : Attribute {
        private bool isDesignOnly = false;

        /// <include file='doc\DesignOnlyAttribute.uex' path='docs/doc[@for="DesignOnlyAttribute.DesignOnlyAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.DesignOnlyAttribute'/> class.
        ///    </para>
        /// </devdoc>
        public DesignOnlyAttribute(bool isDesignOnly) {
            this.isDesignOnly = isDesignOnly;
        }

        /// <include file='doc\DesignOnlyAttribute.uex' path='docs/doc[@for="DesignOnlyAttribute.IsDesignOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether a property
        ///       can be set only at design time.
        ///    </para>
        /// </devdoc>
        public bool IsDesignOnly {
            get {
                return isDesignOnly;
            }
        }

        /// <include file='doc\DesignOnlyAttribute.uex' path='docs/doc[@for="DesignOnlyAttribute.Yes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that a property can be set only at design time. This
        ///    <see langword='static '/>field is read-only. 
        ///    </para>
        /// </devdoc>
        public static readonly DesignOnlyAttribute Yes = new DesignOnlyAttribute(true);

        /// <include file='doc\DesignOnlyAttribute.uex' path='docs/doc[@for="DesignOnlyAttribute.No"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies
        ///       that a
        ///       property can be set at design time or at run
        ///       time. This <see langword='static '/>field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly DesignOnlyAttribute No = new DesignOnlyAttribute(false);

        /// <include file='doc\DesignOnlyAttribute.uex' path='docs/doc[@for="DesignOnlyAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the default value for the <see cref='System.ComponentModel.DesignOnlyAttribute'/>, which is <see cref='System.ComponentModel.DesignOnlyAttribute.No'/>. This <see langword='static'/> field is
        ///       read-only.
        ///    </para>
        /// </devdoc>
        public static readonly DesignOnlyAttribute Default = No;

        /// <include file='doc\DesignOnlyAttribute.uex' path='docs/doc[@for="DesignOnlyAttribute.IsDefaultAttribute"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public override bool IsDefaultAttribute() {
            return IsDesignOnly == Default.IsDesignOnly;
        }

        /// <include file='doc\DesignOnlyAttribute.uex' path='docs/doc[@for="DesignOnlyAttribute.Equals"]/*' />
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            DesignOnlyAttribute other = obj as DesignOnlyAttribute;

            return (other != null) && other.isDesignOnly == isDesignOnly;
        }

        /// <include file='doc\DesignOnlyAttribute.uex' path='docs/doc[@for="DesignOnlyAttribute.GetHashCode"]/*' />
        public override int GetHashCode() {
            return isDesignOnly.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\designtimevisibleattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="DesignTimeVisibleAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    
    using System;

    /// <include file='doc\DesignTimeVisibleAttribute.uex' path='docs/doc[@for="DesignTimeVisibleAttribute"]/*' />
    /// <devdoc>
    ///    <para>
    ///       DesignTimeVisibileAttribute marks a component's visibility. If
    ///       DesignTimeVisibileAttribute.Yes is present, a visual designer can show
    ///       this component on a designer.
    ///    </para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Interface)]
    public sealed class DesignTimeVisibleAttribute : Attribute {
        private bool visible;

        /// <include file='doc\DesignTimeVisibleAttribute.uex' path='docs/doc[@for="DesignTimeVisibleAttribute.DesignTimeVisibleAttribute"]/*' />
        /// <devdoc>
        ///     Creates a new DesignTimeVisibleAttribute with the visible
        ///     property set to the given value.
        /// </devdoc>
        public DesignTimeVisibleAttribute(bool visible) {
            this.visible = visible;
        }
        
        /// <include file='doc\DesignTimeVisibleAttribute.uex' path='docs/doc[@for="DesignTimeVisibleAttribute.DesignTimeVisibleAttribute1"]/*' />
        /// <devdoc>
        ///     Creates a new DesignTimeVisibleAttribute set to the default
        ///     value of true.
        /// </devdoc>
        public DesignTimeVisibleAttribute() {
        }

        /// <include file='doc\DesignTimeVisibleAttribute.uex' path='docs/doc[@for="DesignTimeVisibleAttribute.Visible"]/*' />
        /// <devdoc>
        ///     True if this component should be shown at design time, or false
        ///     if it shouldn't.
        /// </devdoc>
        public bool Visible {
            get {
                return visible;
            }
        }

        /// <include file='doc\DesignTimeVisibleAttribute.uex' path='docs/doc[@for="DesignTimeVisibleAttribute.Yes"]/*' />
        /// <devdoc>
        ///     Marks a component as visible in a visual designer.
        /// </devdoc>
        public static readonly DesignTimeVisibleAttribute Yes = new DesignTimeVisibleAttribute(true);

        /// <include file='doc\DesignTimeVisibleAttribute.uex' path='docs/doc[@for="DesignTimeVisibleAttribute.No"]/*' />
        /// <devdoc>
        ///     Marks a component as not visible in a visual designer.
        /// </devdoc>
        public static readonly DesignTimeVisibleAttribute No = new DesignTimeVisibleAttribute(false);

        /// <include file='doc\DesignTimeVisibleAttribute.uex' path='docs/doc[@for="DesignTimeVisibleAttribute.Default"]/*' />
        /// <devdoc>
        ///     The default visiblity. (equal to Yes.)
        /// </devdoc>
        public static readonly DesignTimeVisibleAttribute Default = Yes;
        
        /// <include file='doc\DesignTimeVisibleAttribute.uex' path='docs/doc[@for="DesignTimeVisibleAttribute.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            DesignTimeVisibleAttribute other = obj as DesignTimeVisibleAttribute;
            return other != null && other.Visible == visible;
        }

        /// <include file='doc\DesignTimeVisibleAttribute.uex' path='docs/doc[@for="DesignTimeVisibleAttribute.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override int GetHashCode() {
            return typeof(DesignTimeVisibleAttribute).GetHashCode() ^ (visible ? -1 : 0);
        }
        
        /// <include file='doc\DesignTimeVisibleAttribute.uex' path='docs/doc[@for="DesignTimeVisibleAttribute.IsDefaultAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool IsDefaultAttribute() {
            return (this.Visible == Default.Visible);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\editorbrowsableattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="EditorBrowsableAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel
{
    /// <include file='doc\EditorBrowsableAttribute.uex' path='docs/doc[@for="EditorBrowsableAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class | AttributeTargets.Struct | AttributeTargets.Enum | AttributeTargets.Constructor | AttributeTargets.Method | AttributeTargets.Property | AttributeTargets.Field | AttributeTargets.Event | AttributeTargets.Delegate | AttributeTargets.Interface)]
    public sealed class EditorBrowsableAttribute :Attribute
    {
        private EditorBrowsableState browsableState;


        /// <include file='doc\EditorBrowsableAttribute.uex' path='docs/doc[@for="EditorBrowsableAttribute.EditorBrowsableAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public EditorBrowsableAttribute (EditorBrowsableState state) {
            browsableState = state;
        }

        /// <include file='doc\EditorBrowsableAttribute.uex' path='docs/doc[@for="EditorBrowsableAttribute.EditorBrowsableAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public EditorBrowsableAttribute () :this (EditorBrowsableState.Always) {}
        
        /// <include file='doc\EditorBrowsableAttribute.uex' path='docs/doc[@for="EditorBrowsableAttribute.State"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public EditorBrowsableState State {
            get { return browsableState;}
        }

        /// <include file='doc\EditorBrowsableAttribute.uex' path='docs/doc[@for="EditorBrowsableAttribute.Equals"]/*' />
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            EditorBrowsableAttribute other = obj as EditorBrowsableAttribute;

            return (other != null) && other.browsableState == browsableState;
        }

        /// <include file='doc\EditorBrowsableAttribute.uex' path='docs/doc[@for="EditorBrowsableAttribute.GetHashCode"]/*' />
        public override int GetHashCode() {
            return base.GetHashCode();
        }
   }
 
    /// <include file='doc\EditorBrowsableAttribute.uex' path='docs/doc[@for="EditorBrowsableState"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum EditorBrowsableState
    {
        /// <include file='doc\EditorBrowsableAttribute.uex' path='docs/doc[@for="EditorBrowsableState.Always"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Always,
        /// <include file='doc\EditorBrowsableAttribute.uex' path='docs/doc[@for="EditorBrowsableState.Never"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Never,
        /// <include file='doc\EditorBrowsableAttribute.uex' path='docs/doc[@for="EditorBrowsableState.Advanced"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Advanced
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\doubleconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="DoubleConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    

    using System.Diagnostics;

    using Microsoft.Win32;

    /// <include file='doc\DoubleConverter.uex' path='docs/doc[@for="DoubleConverter"]/*' />
    /// <devdoc>
    ///    <para>Provides a type
    ///       converter to convert double-precision, floating point number objects to and from various
    ///       other representations.</para>
    /// </devdoc>
    public class DoubleConverter : BaseNumberConverter {
    
          
        /// <include file='doc\DoubleConverter.uex' path='docs/doc[@for="DoubleConverter.AllowHex"]/*' />
        /// <devdoc>
        /// Determines whether this editor will attempt to convert hex (0x or #) strings
        /// </devdoc>
        internal override bool AllowHex {
                get {
                     return false;
                }
        }
        
         /// <include file='doc\DoubleConverter.uex' path='docs/doc[@for="DoubleConverter.TargetType"]/*' />
         /// <devdoc>
        /// The Type this converter is targeting (e.g. Int16, UInt32, etc.)
        /// </devdoc>
        internal override Type TargetType {
                get {
                    return typeof(Double);
                }
        }

        /// <include file='doc\DoubleConverter.uex' path='docs/doc[@for="DoubleConverter.FromString"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given radix
        /// </devdoc>
        internal override object FromString(string value, int radix) {
                return Convert.ToDouble(value);
        }
        
        /// <include file='doc\DoubleConverter.uex' path='docs/doc[@for="DoubleConverter.FromString1"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given formatInfo
        /// </devdoc>
        internal override object FromString(string value, NumberFormatInfo formatInfo) {
                return Double.Parse(value, NumberStyles.Float, formatInfo);
        }
        
        
        /// <include file='doc\DoubleConverter.uex' path='docs/doc[@for="DoubleConverter.FromString2"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given CultureInfo
        /// </devdoc>
        internal override object FromString(string value, CultureInfo culture){
                 return Double.Parse(value, culture);
        }
        
        /// <include file='doc\DoubleConverter.uex' path='docs/doc[@for="DoubleConverter.ToString"]/*' />
        /// <devdoc>
        /// Convert the given value from a string using the given formatInfo
        /// </devdoc>
        internal override string ToString(object value, NumberFormatInfo formatInfo) {
                return ((Double)value).ToString("R", formatInfo);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\enumconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="EnumConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel.Design.Serialization;
    

    using System.Diagnostics;

    using Microsoft.Win32;
    using System.Collections;
    using System.Reflection;
    using System.Globalization;

    /// <include file='doc\EnumConverter.uex' path='docs/doc[@for="EnumConverter"]/*' />
    /// <devdoc>
    /// <para>Provides a type converter to convert <see cref='System.Enum'/>
    /// objects to and from various
    /// other representations.</para>
    /// </devdoc>
    public class EnumConverter : TypeConverter {
        /// <include file='doc\EnumConverter.uex' path='docs/doc[@for="EnumConverter.values"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Provides a <see cref='System.ComponentModel.TypeConverter.StandardValuesCollection'/> that specifies the
        ///       possible values for the enumeration.
        ///    </para>
        /// </devdoc>
        private StandardValuesCollection values;
        /// <include file='doc\EnumConverter.uex' path='docs/doc[@for="EnumConverter.type"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies
        ///       the
        ///       type of the enumerator this converter is
        ///       associated with.
        ///    </para>
        /// </devdoc>
        private Type type;

        /// <include file='doc\EnumConverter.uex' path='docs/doc[@for="EnumConverter.EnumConverter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.EnumConverter'/> class for the given
        ///       type.
        ///    </para>
        /// </devdoc>
        public EnumConverter(Type type) {
            this.type = type;
        }
        
        /// <include file='doc\EnumConverter.uex' path='docs/doc[@for="EnumConverter.EnumType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected Type EnumType {
            get {
                return type;
            }
        }

        /// <include file='doc\EnumConverter.uex' path='docs/doc[@for="EnumConverter.Values"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        protected StandardValuesCollection Values {
            get {
                return values;
            }
            set {
                values = value;
            }
        }

        /// <include file='doc\EnumConverter.uex' path='docs/doc[@for="EnumConverter.CanConvertFrom"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter
        ///       can convert an object in the given source type to an enumeration object using
        ///       the specified context.</para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }
        
        /// <include file='doc\EnumConverter.uex' path='docs/doc[@for="EnumConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\EnumConverter.uex' path='docs/doc[@for="EnumConverter.Comparer"]/*' />
        /// <devdoc>
        /// <para>Gets an <see cref='System.Collections.IComparer'/>
        /// interface that can
        /// be used to sort the values of the enumerator.</para>
        /// </devdoc>
        protected virtual IComparer Comparer {
            get {
                return InvariantComparer.Default;
            }
        }

        /// <include file='doc\EnumConverter.uex' path='docs/doc[@for="EnumConverter.ConvertFrom"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Converts the specified value object to an enumeration object.</para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                try {
                    string strValue = (string)value;
                    if (strValue.IndexOf(',') != -1) {
                        long convertedValue = 0;
                        string[] values = strValue.Split(new char[] {','});
                        foreach(string v in values) {
                            convertedValue |= Convert.ToInt64((Enum)Enum.Parse(type, v, true));
                        }
                        return Enum.ToObject(type, convertedValue);
                    }
                    else {
                        return Enum.Parse(type, strValue, true);
                    }
                }
                catch (FormatException e) {
                    throw new FormatException(SR.GetString(SR.ConvertInvalidPrimitive, (string)value, type.Name), e);
                }
            }
            return base.ConvertFrom(context, culture, value);
        }
    
        /// <include file='doc\EnumConverter.uex' path='docs/doc[@for="EnumConverter.ConvertTo"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Converts the given
        ///       value object to the
        ///       specified destination type.</para>
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string) && value != null) {
                // Raise an argument exception if the value isn't defined and if
                // the enum isn't a flags style.
                //
                Type underlyingType = Enum.GetUnderlyingType(type);
                if (value is IConvertible && value.GetType() != underlyingType) {
                    value = ((IConvertible)value).ToType(underlyingType, culture);
                }
                if (!type.IsDefined(typeof(FlagsAttribute), false) && !Enum.IsDefined(type, value)) {
                    throw new ArgumentException(SR.GetString(SR.EnumConverterInvalidValue, value.ToString(), type.Name));
                }
                
                return Enum.Format(type, value, "G");
            }
            if (destinationType == typeof(InstanceDescriptor) && value != null) {
                string enumName = ConvertToInvariantString(context, value);
                
                if (type.IsDefined(typeof(FlagsAttribute), false) && enumName.IndexOf(',') != -1) {
                    // This is a flags enum, and there is no one flag
                    // that covers the value.  Instead, convert the
                    // value to the underlying type and invoke
                    // a ToObject call on enum.
                    //
                    Type underlyingType = Enum.GetUnderlyingType(type);
                    if (value is IConvertible) {
                        object convertedValue = ((IConvertible)value).ToType(underlyingType, culture);
                        
                        MethodInfo method = typeof(Enum).GetMethod("ToObject", new Type[] {typeof(Type), underlyingType});
                        if (method != null) {
                            return new InstanceDescriptor(method, new object[] {type, convertedValue});
                        }
                    }
                }
                else {
                    FieldInfo info = type.GetField(enumName);
                    if (info != null) {
                        return new InstanceDescriptor(info, null);
                    }
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\EnumConverter.uex' path='docs/doc[@for="EnumConverter.GetStandardValues"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a collection of standard values for the data type this validator is
        ///       designed for.</para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
            if (values == null) {
                Array objValues = Enum.GetValues(type);
                IComparer comparer = Comparer;
                if (comparer != null) {
                    Array.Sort(objValues, 0, objValues.Length, comparer);
                }
                values = new StandardValuesCollection(objValues);
            }
            return values;
        }
    
        /// <include file='doc\EnumConverter.uex' path='docs/doc[@for="EnumConverter.GetStandardValuesExclusive"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating whether the list of standard values returned from
        ///    <see cref='System.ComponentModel.TypeConverter.GetStandardValues'/> 
        ///    is an exclusive list using the specified context.</para>
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return !type.IsDefined(typeof(FlagsAttribute), false);
        }
        
        /// <include file='doc\EnumConverter.uex' path='docs/doc[@for="EnumConverter.GetStandardValuesSupported"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating
        ///       whether this object
        ///       supports a standard set of values that can be picked
        ///       from a list using the specified context.</para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }
        
        /// <include file='doc\EnumConverter.uex' path='docs/doc[@for="EnumConverter.IsValid"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating whether the given object value is valid for this type.</para>
        /// </devdoc>
        public override bool IsValid(ITypeDescriptorContext context, object value) {
            return Enum.IsDefined(type, value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\eventdescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="EventDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {

    using System;
    using System.Diagnostics;
    using System.Reflection;
    
    /// <include file='doc\EventDescriptor.uex' path='docs/doc[@for="EventDescriptor"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides a description
    ///       of an event.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public abstract class EventDescriptor : MemberDescriptor {
        /// <include file='doc\EventDescriptor.uex' path='docs/doc[@for="EventDescriptor.EventDescriptor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.EventDescriptor'/> class with the
        ///       specified name and attribute
        ///       array.
        ///    </para>
        /// </devdoc>
        protected EventDescriptor(string name, Attribute[] attrs)
            : base(name, attrs) {
        }
        /// <include file='doc\EventDescriptor.uex' path='docs/doc[@for="EventDescriptor.EventDescriptor1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.EventDescriptor'/> class with the name and attributes in
        ///       the specified <see cref='System.ComponentModel.MemberDescriptor'/>
        ///       .
        ///    </para>
        /// </devdoc>
        protected EventDescriptor(MemberDescriptor descr)
            : base(descr) {
        }
        /// <include file='doc\EventDescriptor.uex' path='docs/doc[@for="EventDescriptor.EventDescriptor2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.EventDescriptor'/> class with
        ///       the name in the specified <see cref='System.ComponentModel.MemberDescriptor'/> and the
        ///       attributes in both the <see cref='System.ComponentModel.MemberDescriptor'/> and the <see cref='System.Attribute'/>
        ///       array.
        ///    </para>
        /// </devdoc>
        protected EventDescriptor(MemberDescriptor descr, Attribute[] attrs)
            : base(descr, attrs) {
        }

        /// <include file='doc\EventDescriptor.uex' path='docs/doc[@for="EventDescriptor.ComponentType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived
        ///       class,
        ///       gets the type of the component this event is bound to.
        ///    </para>
        /// </devdoc>
        public abstract Type ComponentType { get; }

        /// <include file='doc\EventDescriptor.uex' path='docs/doc[@for="EventDescriptor.EventType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived
        ///       class, gets the type of delegate for the event.
        ///    </para>
        /// </devdoc>
        public abstract Type EventType { get; }

        /// <include file='doc\EventDescriptor.uex' path='docs/doc[@for="EventDescriptor.IsMulticast"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class, gets a value
        ///       indicating whether the event delegate is a multicast
        ///       delegate.
        ///    </para>
        /// </devdoc>
        public abstract bool IsMulticast { get; }

        /// <include file='doc\EventDescriptor.uex' path='docs/doc[@for="EventDescriptor.AddEventHandler"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in
        ///       a derived class,
        ///       binds the event to the component.
        ///    </para>
        /// </devdoc>
        public abstract void AddEventHandler(object component, Delegate value);

        /// <include file='doc\EventDescriptor.uex' path='docs/doc[@for="EventDescriptor.RemoveEventHandler"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When
        ///       overridden
        ///       in a derived class, unbinds the delegate from the
        ///       component
        ///       so that the delegate will no
        ///       longer receive events from the component.
        ///    </para>
        /// </devdoc>
        public abstract void RemoveEventHandler(object component, Delegate value);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\eventhandlerlist.cs ===
//------------------------------------------------------------------------------
// <copyright file="EventHandlerList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System;

    /// <include file='doc\EventHandlerList.uex' path='docs/doc[@for="EventHandlerList"]/*' />
    /// <devdoc>
    ///    <para>Provides a simple list of delegates. This class cannot be inherited.</para>
    /// </devdoc>
    public sealed class EventHandlerList : IDisposable {
        ListEntry head;

        /// <include file='doc\EventHandlerList.uex' path='docs/doc[@for="EventHandlerList.this"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the delegate for the specified key.</para>
        /// </devdoc>
        public Delegate this[object key] {
            get {
                ListEntry e = Find(key);
                if (e != null) {
                    return e.handler;
                }
                else {
                    return null;
                }
            }
            set {
                ListEntry e = Find(key);
                if (e != null) {
                    e.handler = value;
                }
                else {
                    head = new ListEntry(key, value, head);
                }
            }
        }

        /// <include file='doc\EventHandlerList.uex' path='docs/doc[@for="EventHandlerList.AddHandler"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void AddHandler(object key, Delegate value) {
            ListEntry e = Find(key);
            if (e != null) {
                e.handler = Delegate.Combine(e.handler, value);
            }
            else {
                head = new ListEntry(key, value, head);
            }
        }

        /// <include file='doc\EventHandlerList.uex' path='docs/doc[@for="EventHandlerList.Dispose"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Dispose() {
            head = null;
        }

        private ListEntry Find(object key) {
            ListEntry found = head;
            while (found != null) {
                if (found.key == key) {
                    break;
                }
                found = found.next;
            }
            return found;
        }

        /// <include file='doc\EventHandlerList.uex' path='docs/doc[@for="EventHandlerList.RemoveHandler"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void RemoveHandler(object key, Delegate value) {
            ListEntry e = Find(key);
            if (e != null) {
                e.handler = Delegate.Remove(e.handler, value);
            }
            // else... no error for removal of non-existant delegate
            //
        }

        private sealed class ListEntry {
            internal ListEntry next;
            internal object key;
            internal Delegate handler;

            public ListEntry(object key, Delegate handler, ListEntry next) {
                this.next = next;
                this.key = key;
                this.handler = handler;
            }
        }
    }


}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\eventdescriptorcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="EventDescriptorCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.InteropServices;
    

    using System.Diagnostics;

    using Microsoft.Win32;
    using System.Collections;
    using System.Globalization;
    
    /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a collection of events.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public class EventDescriptorCollection : ICollection, IList {
        private EventDescriptor[] events;
        private string[]          namedSort;
        private IComparer         comparer;
        private bool              eventsOwned = true;
        private bool              needSort = false;
        private int               eventCount;
        private bool              readOnly = false;

        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.Empty"]/*' />
        /// <devdoc>
        /// An empty AttributeCollection that can used instead of creating a new one with no items.
        /// </devdoc>
        public static readonly EventDescriptorCollection Empty = new EventDescriptorCollection(null, true);

        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.EventDescriptorCollection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.EventDescriptorCollection'/> class.
        ///    </para>
        /// </devdoc>
        public EventDescriptorCollection(EventDescriptor[] events) {
            this.events = events;
            if (events == null) {
                this.events = new EventDescriptor[0];
            }
            this.eventCount = this.events.Length;
            this.eventsOwned = true;
        }

        internal EventDescriptorCollection(EventDescriptor[] events, bool readOnly) : this(events) {
            this.readOnly = readOnly;
        }

        private EventDescriptorCollection(EventDescriptor[] events, int eventCount, string[] namedSort, IComparer comparer) {
            this.eventsOwned = false;
            if (namedSort != null) {
               this.namedSort = (string[])namedSort.Clone();
            }
            this.comparer = comparer;
            this.events = events;
            this.eventCount = eventCount;
            this.needSort = true;
        }

        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number
        ///       of event descriptors in the collection.
        ///    </para>
        /// </devdoc>
        public int Count {
            get {
                return eventCount;
            }
        }

        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.this"]/*' />
        /// <devdoc>
        ///    <para>Gets the event with the specified index 
        ///       number.</para>
        /// </devdoc>
        public virtual EventDescriptor this[int index] {
            get {
                if (index >= eventCount) {
                    throw new IndexOutOfRangeException();
                }
                EnsureEventsOwned();
                return events[index];
            }
        }

        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the event with the specified name.
        ///    </para>
        /// </devdoc>
        public virtual EventDescriptor this[string name] {
            get {
                return Find(name, false);
            }
        }
        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(EventDescriptor value) {
            if (readOnly) {
                throw new NotSupportedException();
            }

            EnsureSize(eventCount + 1);
            events[eventCount++] = value;
            return eventCount - 1;
        }
        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.Clear"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Clear() {
            if (readOnly) {
                throw new NotSupportedException();
            }

            eventCount = 0;
        }
        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(EventDescriptor value) {
            return IndexOf(value) >= 0;
        }
        
        private void EnsureEventsOwned() {
            if (!eventsOwned) {
               eventsOwned = true;
               if (events != null) {
                  EventDescriptor[] newEvents = new EventDescriptor[events.Length];
                  Array.Copy(events, 0, newEvents, 0, events.Length);
                  this.events = newEvents;
               }
            }
        
            if (needSort) {
               needSort = false;
               InternalSort(this.namedSort);
            }
        }
        
        private void EnsureSize(int sizeNeeded) {
            
            if (sizeNeeded <= events.Length) {
               return;
            }
            
            if (events == null || events.Length == 0) {
                eventCount = 0;
                events = new EventDescriptor[sizeNeeded];
                return;
            }
            
            EnsureEventsOwned();
            
            int newSize = Math.Max(sizeNeeded, events.Length * 2);
            EventDescriptor[] newEvents = new EventDescriptor[newSize];
            Array.Copy(events, 0, newEvents, 0, eventCount);
            events = newEvents;
        }
        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(EventDescriptor value) {
            return Array.IndexOf(events, value, 0, eventCount);
        }
        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, EventDescriptor value) {
            if (readOnly) {
                throw new NotSupportedException();
            }

            EnsureSize(eventCount + 1);
            if (index < eventCount) {
                Array.Copy(events, index, events, index + 1, eventCount - index);   
            }
            events[index] = value;
            eventCount++;
        }
        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(EventDescriptor value) {
            if (readOnly) {
                throw new NotSupportedException();
            }

            int index = IndexOf(value);
            
            if (index != -1) {
                RemoveAt(index);
            }
        }
        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void RemoveAt(int index) {
            if (readOnly) {
                throw new NotSupportedException();
            }

            if (index < eventCount - 1) {
                  Array.Copy(events, index + 1, events, index, eventCount - index);
            }
            eventCount--;
        }

        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.Find"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the description of the event with the specified
        ///       name
        ///       in the collection.
        ///    </para>
        /// </devdoc>
        public virtual EventDescriptor Find(string name, bool ignoreCase) {
                EventDescriptor p = null;
                
                for(int i = 0; i < events.Length; i++) {
                    if (String.Compare(events[i].Name, name, ignoreCase, CultureInfo.InvariantCulture) == 0) {
                        p = events[i];
                        break;
                    }
                }
                
                return p;
        }
        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an enumerator for this <see cref='System.ComponentModel.EventDescriptorCollection'/>.
        ///    </para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return events.GetEnumerator();
        }

        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.Sort"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sorts the members of this EventDescriptorCollection, using the default sort for this collection, 
        ///       which is usually alphabetical.
        ///    </para>
        /// </devdoc>
        public virtual EventDescriptorCollection Sort() {
            return new EventDescriptorCollection(this.events, this.eventCount, this.namedSort, this.comparer);
        }
        

        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.Sort1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sorts the members of this EventDescriptorCollection.  Any specified NamedSort arguments will 
        ///       be applied first, followed by sort using the specified IComparer.
        ///    </para>
        /// </devdoc>
        public virtual EventDescriptorCollection Sort(string[] names) {
            return new EventDescriptorCollection(this.events, this.eventCount, names, this.comparer);
        }
        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.Sort2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sorts the members of this EventDescriptorCollection.  Any specified NamedSort arguments will 
        ///       be applied first, followed by sort using the specified IComparer.
        ///    </para>
        /// </devdoc>
        public virtual EventDescriptorCollection Sort(string[] names, IComparer comparer) {
            return new EventDescriptorCollection(this.events, this.eventCount, names, comparer);
        }
        
         /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.Sort3"]/*' />
         /// <devdoc>
        ///    <para>
        ///       Sorts the members of this EventDescriptorCollection, using the specified IComparer to compare, 
        ///       the EventDescriptors contained in the collection.
        ///    </para>
        /// </devdoc>
        public virtual EventDescriptorCollection Sort(IComparer comparer) {
            return new EventDescriptorCollection(this.events, this.eventCount, this.namedSort, comparer);
        }
        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.InternalSort"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sorts the members of this EventDescriptorCollection.  Any specified NamedSort arguments will 
        ///       be applied first, followed by sort using the specified IComparer.
        ///    </para>
        /// </devdoc>
        protected void InternalSort(string[] names) {
            if (events == null || events.Length == 0) {
                return;
            }  
            
            this.InternalSort(this.comparer);
            
            if (names != null && names.Length > 0) {
            
               ArrayList eventArrayList = new ArrayList(events);
               int foundCount = 0;
               int eventCount = events.Length;
               
               for (int i = 0; i < names.Length; i++) {
                    for (int j = 0; j < eventCount; j++) {
                        EventDescriptor currentEvent = (EventDescriptor)eventArrayList[j];
                        
                        // Found a matching event.  Here, we add it to our array.  We also
                        // mark it as null in our array list so we don't add it twice later.
                        //
                        if (currentEvent != null && currentEvent.Name.Equals(names[i])) {
                            events[foundCount++] = currentEvent;
                            eventArrayList[j] = null;
                            break;
                        }
                    }
               }
                
               // At this point we have filled in the first "foundCount" number of propeties, one for each
               // name in our name array.  If a name didn't match, then it is ignored.  Next, we must fill
               // in the rest of the properties.  We now have a sparse array containing the remainder, so
               // it's easy.
               //
               for (int i = 0; i < eventCount; i++) {
                   if (eventArrayList[i] != null) {
                       events[foundCount++] = (EventDescriptor)eventArrayList[i];
                   }
               }
               
               Debug.Assert(foundCount == eventCount, "We did not completely fill our event array");
            }
        }
        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.InternalSort1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sorts the members of this EventDescriptorCollection using the specified IComparer.
        ///    </para>
        /// </devdoc>
        protected void InternalSort(IComparer sorter) {
            if (sorter == null) {
                TypeDescriptor.SortDescriptorArray(this);
            }
            else {
                Array.Sort(events, sorter);
            }
        }

        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.ICollection.Count"]/*' />
        /// <internalonly/>
        int ICollection.Count {
            get {
                return Count;
            }
        }

       
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.ICollection.IsSynchronized"]/*' />
        /// <internalonly/>
        bool ICollection.IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.ICollection.SyncRoot"]/*' />
        /// <internalonly/>
        object ICollection.SyncRoot {
            get {
                return null;
            }
        }

        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.ICollection.CopyTo"]/*' />
        /// <internalonly/>
        void ICollection.CopyTo(Array array, int index) {
            Array.Copy(events, 0, array, index, events.Length);
        }

        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }
        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.IList.this"]/*' />
        /// <internalonly/>
        object IList.this[int index] {
            get {
                return this[index];
            }
            set {
                if (readOnly) {
                    throw new NotSupportedException();
                }

                if (index >= eventCount) {
                    throw new IndexOutOfRangeException();
                }
                EnsureEventsOwned();
                events[index] = (EventDescriptor)value;
            }
        }
        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.IList.Add"]/*' />
        /// <internalonly/>
        int IList.Add(object value) {
            return Add((EventDescriptor)value);
        }
        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.IList.Clear"]/*' />
        /// <internalonly/>
        void IList.Clear() {
            Clear();
        }
        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.IList.Contains"]/*' />
        /// <internalonly/>
        bool IList.Contains(object value) {
            return Contains((EventDescriptor)value);
        }
        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.IList.IndexOf"]/*' />
        /// <internalonly/>
        int IList.IndexOf(object value) {
            return IndexOf((EventDescriptor)value);
        }
        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.IList.Insert"]/*' />
        /// <internalonly/>
        void IList.Insert(int index, object value) {
            Insert(index, (EventDescriptor)value);
        }
        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.IList.Remove"]/*' />
        /// <internalonly/>
        void IList.Remove(object value) {
            Remove((EventDescriptor)value);
        }
        
        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.IList.RemoveAt"]/*' />
        /// <internalonly/>
        void IList.RemoveAt(int index) {
            RemoveAt(index);
        }

        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.IList.IsReadOnly"]/*' />
        /// <internalonly/>
        bool IList.IsReadOnly {
            get {
                return readOnly;
            }
        }

        /// <include file='doc\EventDescriptorCollection.uex' path='docs/doc[@for="EventDescriptorCollection.IList.IsFixedSize"]/*' />
        /// <internalonly/>
        bool IList.IsFixedSize {
            get {
                return !readOnly;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\expandableobjectconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ExpandableObjectConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {

    using System.Collections;
    using System.ComponentModel;
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using System.Diagnostics;

    /// <include file='doc\ExpandableObjectConverter.uex' path='docs/doc[@for="ExpandableObjectConverter"]/*' />
    /// <devdoc>
    ///    <para>Provides
    ///       a type converter to convert expandable objects to and from various
    ///       other representations.</para>
    /// </devdoc>
    public class ExpandableObjectConverter : TypeConverter {
    
        /// <include file='doc\ExpandableObjectConverter.uex' path='docs/doc[@for="ExpandableObjectConverter.ExpandableObjectConverter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the System.ComponentModel.ExpandableObjectConverter class.
        ///    </para>
        /// </devdoc>
        public ExpandableObjectConverter() {
        }


        /// <include file='doc\ExpandableObjectConverter.uex' path='docs/doc[@for="ExpandableObjectConverter.GetProperties"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a collection of properties for the type of object
        ///       specified by the value
        ///       parameter.</para>
        /// </devdoc>
        public override PropertyDescriptorCollection GetProperties(ITypeDescriptorContext context, object value, Attribute[] attributes) {
            return TypeDescriptor.GetProperties(value, attributes);
        }
        
        /// <include file='doc\ExpandableObjectConverter.uex' path='docs/doc[@for="ExpandableObjectConverter.GetPropertiesSupported"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating
        ///       whether this object supports properties using the
        ///       specified context.</para>
        /// </devdoc>
        public override bool GetPropertiesSupported(ITypeDescriptorContext context) {
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\extendedpropertydescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ExtendedPropertyDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    

    using System.Diagnostics;

    using System;
    using System.ComponentModel.Design;
    using System.Collections;
    using Microsoft.Win32;

    /// <include file='doc\ExtendedPropertyDescriptor.uex' path='docs/doc[@for="ExtendedPropertyDescriptor"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       This class wraps an PropertyDescriptor with something that looks like a property. It
    ///       allows you to treat extended properties the same as regular properties.
    ///    </para>
    /// </devdoc>
    internal sealed class ExtendedPropertyDescriptor : PropertyDescriptor {

        private readonly ReflectPropertyDescriptor      extenderInfo;       // the extender property
        private readonly IExtenderProvider provider;           // the guy providing it

        /// <include file='doc\ExtendedPropertyDescriptor.uex' path='docs/doc[@for="ExtendedPropertyDescriptor.ExtendedPropertyDescriptor"]/*' />
        /// <devdoc>
        ///     Creates a new extended property info.  Callers can then treat this as
        ///     a standard property.
        /// </devdoc>
        public ExtendedPropertyDescriptor(ReflectPropertyDescriptor extenderInfo, Type receiverType, IExtenderProvider provider) : this(extenderInfo, receiverType, provider, null) {
        }

        /// <include file='doc\ExtendedPropertyDescriptor.uex' path='docs/doc[@for="ExtendedPropertyDescriptor.ExtendedPropertyDescriptor1"]/*' />
        /// <devdoc>
        ///     Creates a new extended property info.  Callers can then treat this as
        ///     a standard property.
        /// </devdoc>
        public ExtendedPropertyDescriptor(ReflectPropertyDescriptor extenderInfo, Type receiverType, IExtenderProvider provider, Attribute[] attributes)
            : base((MemberDescriptor)extenderInfo, attributes) {

            Debug.Assert(extenderInfo != null, "ExtendedPropertyDescriptor must have extenderInfo");
            Debug.Assert(provider != null, "ExtendedPropertyDescriptor must have provider");

            ArrayList attrList = new ArrayList(AttributeArray);
            attrList.Add(ExtenderProvidedPropertyAttribute.Create(extenderInfo, receiverType, provider));
            if (extenderInfo.IsReadOnly) {
                attrList.Add(ReadOnlyAttribute.Yes);
            }
            
            Attribute[] temp = new Attribute[attrList.Count];
            attrList.CopyTo(temp, 0);
            AttributeArray = temp;

            this.extenderInfo = extenderInfo;
            this.provider = provider;
        }

        /// <include file='doc\ExtendedPropertyDescriptor.uex' path='docs/doc[@for="ExtendedPropertyDescriptor.CanResetValue"]/*' />
        /// <devdoc>
        ///     Determines if the the component will allow its value to be reset.
        /// </devdoc>
        public override bool CanResetValue(object comp) {
            return extenderInfo.ExtenderCanResetValue(provider, comp);
        }

        /// <include file='doc\ExtendedPropertyDescriptor.uex' path='docs/doc[@for="ExtendedPropertyDescriptor.ComponentType"]/*' />
        /// <devdoc>
        ///     Retrieves the type of the component this PropertyDescriptor is bound to.
        /// </devdoc>
        public override Type ComponentType {
            get {
                return extenderInfo.ComponentType;
            }
        }
        
        /// <include file='doc\ExtendedPropertyDescriptor.uex' path='docs/doc[@for="ExtendedPropertyDescriptor.IsReadOnly"]/*' />
        /// <devdoc>
        ///     Determines if the property can be written to.
        /// </devdoc>
        public override bool IsReadOnly {
            get {
                return Attributes[typeof(ReadOnlyAttribute)].Equals(ReadOnlyAttribute.Yes);
            }
        }

        /// <include file='doc\ExtendedPropertyDescriptor.uex' path='docs/doc[@for="ExtendedPropertyDescriptor.PropertyType"]/*' />
        /// <devdoc>
        ///     Retrieves the data type of the property.
        /// </devdoc>
        public override Type PropertyType {
            get {
                return extenderInfo.ExtenderGetType(provider);
            }
        }

        /// <include file='doc\ExtendedPropertyDescriptor.uex' path='docs/doc[@for="ExtendedPropertyDescriptor.DisplayName"]/*' />
        /// <devdoc>
        ///     Retrieves the display name of the property.  This is the name that will
        ///     be displayed in a properties window.  This will be the same as the property
        ///     name for most properties.
        /// </devdoc>
        public override string DisplayName {
            get {
                string name = Name;
                ISite site = GetSite(provider);
                if (site != null) {
                    string providerName = site.Name;
                    if (providerName != null && providerName.Length > 0) {
                        name = SR.GetString(SR.MetaExtenderName, name, providerName);
                    }
                }
                return name;
            }
        }

        /// <include file='doc\ExtendedPropertyDescriptor.uex' path='docs/doc[@for="ExtendedPropertyDescriptor.Provider"]/*' />
        /// <devdoc>
        ///     Retrieves the object that is providing this extending property.
        /// </devdoc>
        public IExtenderProvider Provider {
            get {
                return provider;
            }
        }

        /// <include file='doc\ExtendedPropertyDescriptor.uex' path='docs/doc[@for="ExtendedPropertyDescriptor.GetValue"]/*' />
        /// <devdoc>
        ///     Retrieves the value of the property for the given component.  This will
        ///     throw an exception if the component does not have this property.
        /// </devdoc>
        public override object GetValue(object comp) {
            return extenderInfo.ExtenderGetValue(provider, comp);
        }

        /// <include file='doc\ExtendedPropertyDescriptor.uex' path='docs/doc[@for="ExtendedPropertyDescriptor.ResetValue"]/*' />
        /// <devdoc>
        ///     Resets the value of this property on comp to the default value.
        /// </devdoc>
        public override void ResetValue(object comp) {
            extenderInfo.ExtenderResetValue(provider, comp, this);
        }

        /// <include file='doc\ExtendedPropertyDescriptor.uex' path='docs/doc[@for="ExtendedPropertyDescriptor.SetValue"]/*' />
        /// <devdoc>
        ///     Sets the value of this property on the given component.
        /// </devdoc>
        public override void SetValue(object component, object value) {
            extenderInfo.ExtenderSetValue(provider, component, value, this);
        }

        /// <include file='doc\ExtendedPropertyDescriptor.uex' path='docs/doc[@for="ExtendedPropertyDescriptor.ShouldSerializeValue"]/*' />
        /// <devdoc>
        ///     Determines if this property should be persisted.  A property is
        ///     to be persisted if it is marked as persistable through a
        ///     PersistableAttribute, and if the property contains something other
        ///     than the default value.  Note, however, that this method will
        ///     return true for design time properties as well, so callers
        ///     should also check to see if a property is design time only before
        ///     persisting to runtime storage.
        /// </devdoc>
        public override bool ShouldSerializeValue(object comp) {
            return extenderInfo.ExtenderShouldSerializeValue(provider, comp);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\extenderprovidedpropertyattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ExtenderProvidedPropertyAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    

    using System.Diagnostics;

    using System;
    

    /// <include file='doc\ExtenderProvidedPropertyAttribute.uex' path='docs/doc[@for="ExtenderProvidedPropertyAttribute"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       ExtenderProvidedPropertyAttribute is an attribute that marks that a property
    ///       was actually offered up by and extender provider.
    ///    </para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public sealed class ExtenderProvidedPropertyAttribute : Attribute {

        private PropertyDescriptor extenderProperty;
        private IExtenderProvider  provider;
        private Type               receiverType;

        /// <include file='doc\ExtenderProvidedPropertyAttribute.uex' path='docs/doc[@for="ExtenderProvidedPropertyAttribute.Create"]/*' />
        /// <devdoc>
        ///     Creates a new ExtenderProvidedPropertyAttribute.
        /// </devdoc>
        internal static ExtenderProvidedPropertyAttribute Create(PropertyDescriptor extenderProperty, Type receiverType, IExtenderProvider provider) {
            ExtenderProvidedPropertyAttribute e = new ExtenderProvidedPropertyAttribute();
            e.extenderProperty = extenderProperty;
            e.receiverType = receiverType;
            e.provider = provider;
            return e;
        }

        /// <include file='doc\ExtenderProvidedPropertyAttribute.uex' path='docs/doc[@for="ExtenderProvidedPropertyAttribute.ExtenderProvidedPropertyAttribute"]/*' />
        /// <devdoc>
        ///     Creates an empty ExtenderProvidedPropertyAttribute.
        /// </devdoc>
        public ExtenderProvidedPropertyAttribute() {
        }

        /// <include file='doc\ExtenderProvidedPropertyAttribute.uex' path='docs/doc[@for="ExtenderProvidedPropertyAttribute.ExtenderProperty"]/*' />
        /// <devdoc>
        ///     PropertyDescriptor of the property that is being provided.
        /// </devdoc>
        public PropertyDescriptor ExtenderProperty {
            get {
                return extenderProperty;
            }
        }

        /// <include file='doc\ExtenderProvidedPropertyAttribute.uex' path='docs/doc[@for="ExtenderProvidedPropertyAttribute.Provider"]/*' />
        /// <devdoc>
        ///     Extender provider that is providing the property.
        /// </devdoc>
        public IExtenderProvider Provider {
            get {
                return provider;
            }
        }

        /// <include file='doc\ExtenderProvidedPropertyAttribute.uex' path='docs/doc[@for="ExtenderProvidedPropertyAttribute.ReceiverType"]/*' />
        /// <devdoc>
        ///     The type of object that can receive these properties.
        /// </devdoc>
        public Type ReceiverType {
            get {
                return receiverType;
            }
        }

        /// <include file='doc\ExtenderProvidedPropertyAttribute.uex' path='docs/doc[@for="ExtenderProvidedPropertyAttribute.Equals"]/*' />
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            ExtenderProvidedPropertyAttribute other = obj as ExtenderProvidedPropertyAttribute;

            return (other != null) && other.extenderProperty.Equals(extenderProperty) && other.provider.Equals(provider) && other.receiverType.Equals(receiverType);
        }

        /// <include file='doc\ExtenderProvidedPropertyAttribute.uex' path='docs/doc[@for="ExtenderProvidedPropertyAttribute.GetHashCode"]/*' />
        public override int GetHashCode() {
            return base.GetHashCode();
        }
    
        /// <include file='doc\ExtenderProvidedPropertyAttribute.uex' path='docs/doc[@for="ExtenderProvidedPropertyAttribute.IsDefaultAttribute"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override bool IsDefaultAttribute() {
            return receiverType == null;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\ibindinglist.cs ===
//------------------------------------------------------------------------------
// <copyright file="IBindingList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.Collections;

    /// <include file='doc\ITable.uex' path='docs/doc[@for="IBindingList"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface IBindingList : IList {
        /// <include file='doc\ITable.uex' path='docs/doc[@for="IBindingList.AllowNew"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        bool AllowNew { get;}
        /// <include file='doc\ITable.uex' path='docs/doc[@for="IBindingList.AddNew"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        object AddNew();
        /// <include file='doc\ITable.uex' path='docs/doc[@for="IBindingList.AllowEdit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        bool AllowEdit { get; }
        /// <include file='doc\ITable.uex' path='docs/doc[@for="IBindingList.AllowRemove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        bool AllowRemove { get; }
        /// <include file='doc\ITable.uex' path='docs/doc[@for="IBindingList.SupportsChangeNotification"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        bool SupportsChangeNotification { get; }
        /// <include file='doc\ITable.uex' path='docs/doc[@for="IBindingList.SupportsSearching"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        bool SupportsSearching { get; }
        /// <include file='doc\ITable.uex' path='docs/doc[@for="IBindingList.SupportsSorting"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        bool SupportsSorting { get; }
        /// <include file='doc\ITable.uex' path='docs/doc[@for="IBindingList.IsSorted"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        bool IsSorted { get; }
        /// <include file='doc\ITable.uex' path='docs/doc[@for="IBindingList.SortProperty"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PropertyDescriptor SortProperty { get; }
        /// <include file='doc\ITable.uex' path='docs/doc[@for="IBindingList.SortDirection"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ListSortDirection SortDirection { get; }
        /// <include file='doc\ITable.uex' path='docs/doc[@for="IBindingList.ListChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        event ListChangedEventHandler ListChanged;
        /// <include file='doc\ITable.uex' path='docs/doc[@for="IBindingList.AddIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>

        void AddIndex(PropertyDescriptor property);
        /// <include file='doc\ITable.uex' path='docs/doc[@for="IBindingList.ApplySort"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void ApplySort(PropertyDescriptor property, ListSortDirection direction);
        /// <include file='doc\ITable.uex' path='docs/doc[@for="IBindingList.Find"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        int Find(PropertyDescriptor property, object key);
        /// <include file='doc\ITable.uex' path='docs/doc[@for="IBindingList.RemoveIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void RemoveIndex(PropertyDescriptor property);
        /// <include file='doc\ITable.uex' path='docs/doc[@for="IBindingList.RemoveSort"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void RemoveSort();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\icontainer.cs ===
/*
 * Copyright (c) 1999, Microsoft Corporation. All Rights Reserved.
 * Information Contained Herein is Proprietary and Confidential.
 */
namespace System.ComponentModel {

    /*
     * A "container" is an object that logically contains zero or more child
     * components.
     *
     * In this context, "containment" refers to logical containment, not visual
     * containment.  Components and containers can be used in a variety of
     * scenarios, including both visual and non-visual scenarios.
     */
    // Interfaces don't need to be serializable
    /// <include file='doc\IContainer.uex' path='docs/doc[@for="IContainer"]/*' />
    /// <devdoc>
    ///    <para>Provides
    ///       functionality for containers. Containers are objects that logically contain zero or more components.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public interface IContainer : IDisposable {
        /** Adds a component to the container. */
        /// <include file='doc\IContainer.uex' path='docs/doc[@for="IContainer.Add"]/*' />
        /// <devdoc>
        /// <para>Adds the specified <see cref='System.ComponentModel.IComponent'/> to the <see cref='System.ComponentModel.IContainer'/>
        /// at the end of the list.</para>
        /// </devdoc>
        void Add(IComponent component);

        /** Adds a component to the container. */
        /// <include file='doc\IContainer.uex' path='docs/doc[@for="IContainer.Add1"]/*' />
        /// <devdoc>
        /// <para>Adds the specified <see cref='System.ComponentModel.IComponent'/> to the <see cref='System.ComponentModel.IContainer'/>
        /// at the end of the list, and assigns a name to the component.</para>
        /// </devdoc>
        void Add(IComponent component, String name);

        /** The components in the container. */
        /// <include file='doc\IContainer.uex' path='docs/doc[@for="IContainer.Components"]/*' />
        /// <devdoc>
        /// <para>Gets all the components in the <see cref='System.ComponentModel.IContainer'/>.</para>
        /// </devdoc>
        ComponentCollection Components {get;}

        /** Removes a component from the container. */
        /// <include file='doc\IContainer.uex' path='docs/doc[@for="IContainer.Remove"]/*' />
        /// <devdoc>
        /// <para>Removes a component from the <see cref='System.ComponentModel.IContainer'/>.</para>
        /// </devdoc>
        void Remove(IComponent component);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\icomnativedescriptorhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="IComNativeDescriptorHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    

    using System.Diagnostics;
    using System;
    
    using Microsoft.Win32;

    /// <include file='doc\IComNativeDescriptorHandler.uex' path='docs/doc[@for="IComNativeDescriptorHandler"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       Top level mapping layer between a COM object and TypeDescriptor.
    ///    </para>
    /// </devdoc>
    public interface IComNativeDescriptorHandler {
        /// <include file='doc\IComNativeDescriptorHandler.uex' path='docs/doc[@for="IComNativeDescriptorHandler.GetAttributes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        AttributeCollection GetAttributes(object component);
        /// <include file='doc\IComNativeDescriptorHandler.uex' path='docs/doc[@for="IComNativeDescriptorHandler.GetClassName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        string GetClassName(object component);
        /// <include file='doc\IComNativeDescriptorHandler.uex' path='docs/doc[@for="IComNativeDescriptorHandler.GetConverter"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        TypeConverter GetConverter(object component);
        /// <include file='doc\IComNativeDescriptorHandler.uex' path='docs/doc[@for="IComNativeDescriptorHandler.GetDefaultEvent"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EventDescriptor GetDefaultEvent(object component);
        /// <include file='doc\IComNativeDescriptorHandler.uex' path='docs/doc[@for="IComNativeDescriptorHandler.GetDefaultProperty"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PropertyDescriptor GetDefaultProperty(object component);
        /// <include file='doc\IComNativeDescriptorHandler.uex' path='docs/doc[@for="IComNativeDescriptorHandler.GetEditor"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        object GetEditor(object component, Type baseEditorType);
        /// <include file='doc\IComNativeDescriptorHandler.uex' path='docs/doc[@for="IComNativeDescriptorHandler.GetName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        string GetName(object component);
        /// <include file='doc\IComNativeDescriptorHandler.uex' path='docs/doc[@for="IComNativeDescriptorHandler.GetEvents"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EventDescriptorCollection GetEvents(object component);
        /// <include file='doc\IComNativeDescriptorHandler.uex' path='docs/doc[@for="IComNativeDescriptorHandler.GetEvents1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        EventDescriptorCollection GetEvents(object component, Attribute[] attributes);
        /// <include file='doc\IComNativeDescriptorHandler.uex' path='docs/doc[@for="IComNativeDescriptorHandler.GetProperties"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PropertyDescriptorCollection GetProperties(object component, Attribute[] attributes);
        /// <include file='doc\IComNativeDescriptorHandler.uex' path='docs/doc[@for="IComNativeDescriptorHandler.GetPropertyValue"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        object GetPropertyValue(object component, string propertyName, ref bool success);
        /// <include file='doc\IComNativeDescriptorHandler.uex' path='docs/doc[@for="IComNativeDescriptorHandler.GetPropertyValue1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        object GetPropertyValue(object component, int dispid, ref bool success);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\icomponent.cs ===
/*
 * Copyright (c) 1999, Microsoft Corporation. All Rights Reserved.
 * Information Contained Herein is Proprietary and Confidential.
 */
namespace System.ComponentModel {
    using System;
    using System.ComponentModel.Design;
    using System.ComponentModel.Design.Serialization;

    /*
     * A "component" is an object that can be placed in a container.
     *
     * In this context, "containment" refers to logical containment, not visual
     * containment.  Components and containers can be used in a variety of
     * scenarios, including both visual and non-visual scenarios.
     *
     * To be a component, a class implements the IComponent interface, and provides
     * a parameter-less constructor.
     *
     * A component interacts with its container primarily through a container-
     * provided "site".
     */

    // Interfaces don't need to be serializable
    /// <include file='doc\IComponent.uex' path='docs/doc[@for="IComponent"]/*' />
    /// <devdoc>
    ///    <para>Provides functionality required by all components.</para>
    /// </devdoc>
    [
        RootDesignerSerializer("System.ComponentModel.Design.Serialization.RootCodeDomSerializer, " + AssemblyRef.SystemDesign, "System.ComponentModel.Design.Serialization.CodeDomSerializer, " + AssemblyRef.SystemDesign, true),
        Designer("System.ComponentModel.Design.ComponentDesigner, " + AssemblyRef.SystemDesign, typeof(IDesigner)),
        Designer("System.Windows.Forms.Design.ComponentDocumentDesigner, " + AssemblyRef.SystemDesign, typeof(IRootDesigner)),
        TypeConverter(typeof(ComponentConverter)),
        System.Runtime.InteropServices.ComVisible(true)
    ]
    public interface IComponent : IDisposable {
        /**
         * The site of the component.
         */
        /// <include file='doc\IComponent.uex' path='docs/doc[@for="IComponent.Site"]/*' />
        /// <devdoc>
        ///    <para>When implemented by a class, gets or sets
        ///       the <see cref='System.ComponentModel.ISite'/> associated
        ///       with the <see cref='System.ComponentModel.IComponent'/>.</para>
        /// </devdoc>
        ISite Site {
            get;
            set;
        }

        /// <include file='doc\IComponent.uex' path='docs/doc[@for="IComponent.Disposed"]/*' />
        /// <devdoc>
        ///    <para>Adds a event handler to listen to the Disposed event on the component.</para>
        /// </devdoc>
        event EventHandler Disposed;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\idataerrorinfo.cs ===
//------------------------------------------------------------------------------
// <copyright file="IDataErrorInfo.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {

    using System;

    /// <include file='doc\IDataErrorInfo.uex' path='docs/doc[@for="IDataErrorInfo"]/*' />
    /// <devdoc>
    /// </devdoc>
    // suppose that you have some data that can be indexed by use of string:
    // then there are two types of errors:
    // 1. an error for each piece of data that can be indexed
    // 2. an error that is valid on the entire data
    //
    public interface IDataErrorInfo {

        /// <include file='doc\IDataErrorInfo.uex' path='docs/doc[@for="IDataErrorInfo.this"]/*' />
        /// <devdoc>
        /// </devdoc>
        string this[string columnName] {
            get;
        }
        /// <include file='doc\IDataErrorInfo.uex' path='docs/doc[@for="IDataErrorInfo.Error"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        string Error {
            get;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\icustomtypedescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ICustomTypeDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    

    using System.Diagnostics;

    using System;
    using Microsoft.Win32;
    

    /// <include file='doc\ICustomTypeDescriptor.uex' path='docs/doc[@for="ICustomTypeDescriptor"]/*' />
    /// <devdoc>
    ///    <para>Provides an interface that provides custom type information for an 
    ///       object.</para>
    /// </devdoc>
    public interface ICustomTypeDescriptor {

        /// <include file='doc\ICustomTypeDescriptor.uex' path='docs/doc[@for="ICustomTypeDescriptor.GetAttributes"]/*' />
        /// <devdoc>
        /// <para>Gets a collection of type <see cref='System.Attribute'/> with the attributes 
        ///    for this object.</para>
        /// </devdoc>
        AttributeCollection GetAttributes();

        /// <include file='doc\ICustomTypeDescriptor.uex' path='docs/doc[@for="ICustomTypeDescriptor.GetClassName"]/*' />
        /// <devdoc>
        ///    <para>Gets the class name of this object.</para>
        /// </devdoc>
        string GetClassName();

        /// <include file='doc\ICustomTypeDescriptor.uex' path='docs/doc[@for="ICustomTypeDescriptor.GetComponentName"]/*' />
        /// <devdoc>
        ///    <para>Gets the name of this object.</para>
        /// </devdoc>
        string GetComponentName();

        /// <include file='doc\ICustomTypeDescriptor.uex' path='docs/doc[@for="ICustomTypeDescriptor.GetConverter"]/*' />
        /// <devdoc>
        ///    <para>Gets a type converter for this object.</para>
        /// </devdoc>
        TypeConverter GetConverter();

        /// <include file='doc\ICustomTypeDescriptor.uex' path='docs/doc[@for="ICustomTypeDescriptor.GetDefaultEvent"]/*' />
        /// <devdoc>
        ///    <para>Gets the default event for this object.</para>
        /// </devdoc>
        EventDescriptor GetDefaultEvent();


        /// <include file='doc\ICustomTypeDescriptor.uex' path='docs/doc[@for="ICustomTypeDescriptor.GetDefaultProperty"]/*' />
        /// <devdoc>
        ///    <para>Gets the default property for this object.</para>
        /// </devdoc>
        PropertyDescriptor GetDefaultProperty();

        /// <include file='doc\ICustomTypeDescriptor.uex' path='docs/doc[@for="ICustomTypeDescriptor.GetEditor"]/*' />
        /// <devdoc>
        ///    <para>Gets an editor of the specified type for this object.</para>
        /// </devdoc>
        object GetEditor(Type editorBaseType);

        /// <include file='doc\ICustomTypeDescriptor.uex' path='docs/doc[@for="ICustomTypeDescriptor.GetEvents"]/*' />
        /// <devdoc>
        ///    <para>Gets the events for this instance of a component.</para>
        /// </devdoc>
        EventDescriptorCollection GetEvents();

        /// <include file='doc\ICustomTypeDescriptor.uex' path='docs/doc[@for="ICustomTypeDescriptor.GetEvents1"]/*' />
        /// <devdoc>
        ///    <para>Gets the events for this instance of a component using the attribute array as a
        ///       filter.</para>
        /// </devdoc>
        EventDescriptorCollection GetEvents(Attribute[] attributes);

        /// <include file='doc\ICustomTypeDescriptor.uex' path='docs/doc[@for="ICustomTypeDescriptor.GetProperties"]/*' />
        /// <devdoc>
        ///    <para>Gets the properties for this instance of a component.</para>
        /// </devdoc>
        PropertyDescriptorCollection GetProperties();

        /// <include file='doc\ICustomTypeDescriptor.uex' path='docs/doc[@for="ICustomTypeDescriptor.GetProperties1"]/*' />
        /// <devdoc>
        ///    <para>Gets the properties for this instance of a component using the attribute array as a filter.</para>
        /// </devdoc>
        PropertyDescriptorCollection GetProperties(Attribute[] attributes);

        /// <include file='doc\ICustomTypeDescriptor.uex' path='docs/doc[@for="ICustomTypeDescriptor.GetPropertyOwner"]/*' />
        /// <devdoc>
        ///    <para>Gets the object that directly depends on this value being edited.</para>
        /// </devdoc>
        object GetPropertyOwner(PropertyDescriptor pd);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\ieditableobject.cs ===
//------------------------------------------------------------------------------
// <copyright file="IEditableObject.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 * An object that can rollback edits.
 * 
 * Copyright (c) 1999 Microsoft Corporation
 */
namespace System.ComponentModel {

    using System.Diagnostics;

    /// <include file='doc\IEditableObject.uex' path='docs/doc[@for="IEditableObject"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface IEditableObject {
        /// <include file='doc\IEditableObject.uex' path='docs/doc[@for="IEditableObject.BeginEdit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void BeginEdit();
        /// <include file='doc\IEditableObject.uex' path='docs/doc[@for="IEditableObject.EndEdit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void EndEdit();
        /// <include file='doc\IEditableObject.uex' path='docs/doc[@for="IEditableObject.CancelEdit"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        void CancelEdit();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\guidconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="GuidConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;
    

    using System.Diagnostics;

    using Microsoft.Win32;
    using System.Globalization;

    /// <include file='doc\GuidConverter.uex' path='docs/doc[@for="GuidConverter"]/*' />
    /// <devdoc>
    ///    <para>Provides a
    ///       type converter to convert globally unique identifier objects to and from various
    ///       other representations.</para>
    /// </devdoc>
    public class GuidConverter : TypeConverter {

        /// <include file='doc\GuidConverter.uex' path='docs/doc[@for="GuidConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this
        ///       converter can convert an object in the given source type to a globally unique identifier object
        ///       using the context.</para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\GuidConverter.uex' path='docs/doc[@for="GuidConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\GuidConverter.uex' path='docs/doc[@for="GuidConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>Converts
        ///       the given object to a globally unique identifier object.</para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                string text = ((string)value).Trim();
                return new Guid(text);
            }
            return base.ConvertFrom(context, culture, value);
        }
        
        /// <include file='doc\GuidConverter.uex' path='docs/doc[@for="GuidConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(InstanceDescriptor) && value is Guid) {
                ConstructorInfo ctor = typeof(Guid).GetConstructor(new Type[] {typeof(string)});
                if (ctor != null) {
                    return new InstanceDescriptor(ctor, new object[] {value.ToString()});
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\iextenderprovider.cs ===
//------------------------------------------------------------------------------
// <copyright file="IExtenderProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    

    using System.Diagnostics;

    using System;

    /// <include file='doc\IExtenderProvider.uex' path='docs/doc[@for="IExtenderProvider"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Defines the interface
    ///       for extending properties to other components in a container.
    ///    </para>
    /// </devdoc>
    public interface IExtenderProvider {

        /// <include file='doc\IExtenderProvider.uex' path='docs/doc[@for="IExtenderProvider.CanExtend"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies
        ///       whether this object can provide its extender properties to
        ///       the specified object.
        ///    </para>
        /// </devdoc>
        bool CanExtend(object extendee);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\installertypeattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="InstallerTypeAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Diagnostics;

    /// <include file='doc\InstallerTypeAttribute.uex' path='docs/doc[@for="InstallerTypeAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies the installer
    ///       to use for a type to install components.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    public class InstallerTypeAttribute : Attribute {
        string _typeName;

        /// <include file='doc\InstallerTypeAttribute.uex' path='docs/doc[@for="InstallerTypeAttribute.InstallerTypeAttribute"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the System.Windows.Forms.ComponentModel.InstallerTypeAttribute class.</para>
        /// </devdoc>
        public InstallerTypeAttribute(Type installerType) {
            _typeName = installerType.AssemblyQualifiedName;
        }

        /// <include file='doc\InstallerTypeAttribute.uex' path='docs/doc[@for="InstallerTypeAttribute.InstallerTypeAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public InstallerTypeAttribute(string typeName) {
            _typeName = typeName;
        }

        /// <include file='doc\InstallerTypeAttribute.uex' path='docs/doc[@for="InstallerTypeAttribute.InstallerType"]/*' />
        /// <devdoc>
        ///    <para> Gets the
        ///       type of installer associated with this attribute.</para>
        /// </devdoc>
        public virtual Type InstallerType {
            get {
                return Type.GetType(_typeName);
            }
        }

        /// <include file='doc\InstallerTypeAttribute.uex' path='docs/doc[@for="InstallerTypeAttribute.Equals"]/*' />
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            InstallerTypeAttribute other = obj as InstallerTypeAttribute;

            return (other != null) && other._typeName == _typeName;
        }

        /// <include file='doc\InstallerTypeAttribute.uex' path='docs/doc[@for="InstallerTypeAttribute.GetHashCode"]/*' />
        public override int GetHashCode() {
            return base.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\int64converter.cs ===
//------------------------------------------------------------------------------
// <copyright file="Int64Converter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    

    using System.Diagnostics;

    using Microsoft.Win32;

    /// <include file='doc\Int64Converter.uex' path='docs/doc[@for="Int64Converter"]/*' />
    /// <devdoc>
    ///    <para>Provides a type converter to convert 64-bit signed integer objects to and
    ///       from various other representations.</para>
    /// </devdoc>
    public class Int64Converter : BaseNumberConverter {
    
    
           /// <include file='doc\Int64Converter.uex' path='docs/doc[@for="Int64Converter.TargetType"]/*' />
           /// <devdoc>
        /// The Type this converter is targeting (e.g. Int16, UInt32, etc.)
        /// </devdoc>
        internal override Type TargetType {
                get {
                    return typeof(Int64);
                }
        }

        /// <include file='doc\Int64Converter.uex' path='docs/doc[@for="Int64Converter.FromString"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given radix
        /// </devdoc>
        internal override object FromString(string value, int radix) {
                return Convert.ToInt64(value, radix);
        }
        
        /// <include file='doc\Int64Converter.uex' path='docs/doc[@for="Int64Converter.FromString1"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given formatInfo
        /// </devdoc>
        internal override object FromString(string value, NumberFormatInfo formatInfo) {
                return Int64.Parse(value, NumberStyles.Integer, formatInfo);
        }
        
        
        /// <include file='doc\Int64Converter.uex' path='docs/doc[@for="Int64Converter.FromString2"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given CultureInfo
        /// </devdoc>
        internal override object FromString(string value, CultureInfo culture){
                 return Int64.Parse(value, culture);
        }
        
        /// <include file='doc\Int64Converter.uex' path='docs/doc[@for="Int64Converter.ToString"]/*' />
        /// <devdoc>
        /// Convert the given value from a string using the given formatInfo
        /// </devdoc>
        internal override string ToString(object value, NumberFormatInfo formatInfo) {
                return ((Int64)value).ToString("G", formatInfo);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\int32converter.cs ===
//------------------------------------------------------------------------------
// <copyright file="Int32Converter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    

    using System.Diagnostics;

    using Microsoft.Win32;

    /// <include file='doc\Int32Converter.uex' path='docs/doc[@for="Int32Converter"]/*' />
    /// <devdoc>
    ///    <para>Provides a type converter to convert 32-bit signed integer objects to and
    ///       from various other representations.</para>
    /// </devdoc>
    public class Int32Converter : BaseNumberConverter {
    
        /// <include file='doc\Int32Converter.uex' path='docs/doc[@for="Int32Converter.TargetType"]/*' />
        /// <devdoc>
        /// The Type this converter is targeting (e.g. Int16, UInt32, etc.)
        /// </devdoc>
        internal override Type TargetType {
                get {
                    return typeof(Int32);
                }
        }

        /// <include file='doc\Int32Converter.uex' path='docs/doc[@for="Int32Converter.FromString"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given radix
        /// </devdoc>
        internal override object FromString(string value, int radix) {
                return Convert.ToInt32(value, radix);
        }
        
        /// <include file='doc\Int32Converter.uex' path='docs/doc[@for="Int32Converter.FromString1"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given formatInfo
        /// </devdoc>
        internal override object FromString(string value, NumberFormatInfo formatInfo) {
                return Int32.Parse(value, NumberStyles.Integer, formatInfo);
        }
        
        
        /// <include file='doc\Int32Converter.uex' path='docs/doc[@for="Int32Converter.FromString2"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given CultureInfo
        /// </devdoc>
        internal override object FromString(string value, CultureInfo culture){
                 return Int32.Parse(value, culture);
        }
        
        
        
        /// <include file='doc\Int32Converter.uex' path='docs/doc[@for="Int32Converter.ToString"]/*' />
        /// <devdoc>
        /// Convert the given value from a string using the given formatInfo
        /// </devdoc>
        internal override string ToString(object value, NumberFormatInfo formatInfo) {
                return ((Int32)value).ToString("G", formatInfo);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\ilistsource.cs ===
//------------------------------------------------------------------------------
// <copyright file="IListSource.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {

    using System;
    using Microsoft.Win32;
    using System.Collections;

    /// <include file='doc\IListSource.uex' path='docs/doc[@for="IListSource"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface IListSource {

        /// <include file='doc\IListSource.uex' path='docs/doc[@for="IListSource.ContainsListCollection"]/*' />
        bool ContainsListCollection { get; }

        /// <include file='doc\IListSource.uex' path='docs/doc[@for="IListSource.GetList"]/*' />
        IList GetList();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\intsecurity.cs ===
//------------------------------------------------------------------------------
// <copyright file="IntSecurity.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   IntSecurity.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/
namespace System.ComponentModel {
    using System;
    using System.Security.Permissions;
    using System.Security;

    internal class IntSecurity {
        public static readonly CodeAccessPermission UnmanagedCode = new SecurityPermission(SecurityPermissionFlag.UnmanagedCode);
        public static readonly CodeAccessPermission FullReflection = new ReflectionPermission(PermissionState.Unrestricted);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\immutableobjectattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ImmutableObjectAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>
//------------------------------------------------------------------------------


/**************************************************************************\
*
* Copyright (c) 1998-2002, Microsoft Corp.  All Rights Reserved.
*
* Module Name:
*
*   ImmutableObjectAttribute.cs
*
* Abstract:
*
* Revision History:
*
\**************************************************************************/

namespace System.ComponentModel {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    
    /// <include file='doc\ImmutableObjectAttribute.uex' path='docs/doc[@for="ImmutableObjectAttribute"]/*' />
    /// <devdoc>
    ///  Specifies that a object has no sub properties that are editable.
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public sealed class ImmutableObjectAttribute : Attribute {
         
         /// <include file='doc\ImmutableObjectAttribute.uex' path='docs/doc[@for="ImmutableObjectAttribute.Yes"]/*' />
         /// <devdoc>
         ///  Specifies that a object has no sub properties that are editable.
         ///
         ///  This is usually used in the properties window to determine if an expandable object
         ///  should be rendered as read-only.
         /// </devdoc>
         public static readonly ImmutableObjectAttribute Yes = new ImmutableObjectAttribute(true);
         
         /// <include file='doc\ImmutableObjectAttribute.uex' path='docs/doc[@for="ImmutableObjectAttribute.No"]/*' />
         /// <devdoc>
         ///  Specifies that a object has at least one editable sub-property.
         ///
         ///  This is usually used in the properties window to determine if an expandable object
         ///  should be rendered as read-only.
         /// </devdoc>
         public static readonly ImmutableObjectAttribute No = new ImmutableObjectAttribute(false);
         
         
         /// <include file='doc\ImmutableObjectAttribute.uex' path='docs/doc[@for="ImmutableObjectAttribute.Default"]/*' />
         /// <devdoc>
         ///  Defaults to ImmutableObjectAttribute.No
         /// </devdoc>
         public static readonly ImmutableObjectAttribute Default = No;
         
         private bool immutable = true;
         
         /// <include file='doc\ImmutableObjectAttribute.uex' path='docs/doc[@for="ImmutableObjectAttribute.ImmutableObjectAttribute"]/*' />
         /// <devdoc>
         ///  Constructs an ImmutableObjectAttribute object.
         ///
         /// </devdoc>
         public ImmutableObjectAttribute(bool immutable) {
            this.immutable = immutable;
         }
         
         /// <include file='doc\ImmutableObjectAttribute.uex' path='docs/doc[@for="ImmutableObjectAttribute.Immutable"]/*' />
         /// <devdoc>
         ///    <para>[To be supplied.]</para>
         /// </devdoc>
         public bool Immutable {
             get {
               return immutable;
             }
         }
         
         /// <include file='doc\ImmutableObjectAttribute.uex' path='docs/doc[@for="ImmutableObjectAttribute.Equals"]/*' />
         /// <internalonly/>
         /// <devdoc>
         /// </devdoc>
         public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            ImmutableObjectAttribute other = obj as ImmutableObjectAttribute;
            return other != null && other.Immutable == this.immutable;
         }
         
         /// <include file='doc\ImmutableObjectAttribute.uex' path='docs/doc[@for="ImmutableObjectAttribute.GetHashCode"]/*' />
         /// <devdoc>
         ///    <para>
         ///       Returns the hashcode for this object.
         ///    </para>
         /// </devdoc>
         public override int GetHashCode() {
             return base.GetHashCode();
         }

         /// <include file='doc\ImmutableObjectAttribute.uex' path='docs/doc[@for="ImmutableObjectAttribute.IsDefaultAttribute"]/*' />
         /// <internalonly/>
         /// <devdoc>
         /// </devdoc>
         public override bool IsDefaultAttribute() {
            return (this.Equals(Default));
         }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\int16converter.cs ===
//------------------------------------------------------------------------------
// <copyright file="Int16Converter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    

    using System.Diagnostics;

    using Microsoft.Win32;

    /// <include file='doc\Int16Converter.uex' path='docs/doc[@for="Int16Converter"]/*' />
    /// <devdoc>
    ///    <para>Provides a type converter to convert 16-bit signed integer objects to and
    ///       from various other representations.</para>
    /// </devdoc>
    public class Int16Converter : BaseNumberConverter {

        /// <include file='doc\Int16Converter.uex' path='docs/doc[@for="Int16Converter.TargetType"]/*' />
        /// <devdoc>
        /// The Type this converter is targeting (e.g. Int16, UInt32, etc.)
        /// </devdoc>
        internal override Type TargetType {
                get {
                    return typeof(Int16);
                }
        }

        /// <include file='doc\Int16Converter.uex' path='docs/doc[@for="Int16Converter.FromString"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given radix
        /// </devdoc>
        internal override object FromString(string value, int radix) {
                return Convert.ToInt16(value, radix);
        }
        
        /// <include file='doc\Int16Converter.uex' path='docs/doc[@for="Int16Converter.FromString1"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given CultureInfo
        /// </devdoc>
        internal override object FromString(string value, CultureInfo culture){
                 return Int16.Parse(value, culture);
        }
        
        
        /// <include file='doc\Int16Converter.uex' path='docs/doc[@for="Int16Converter.FromString2"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given formatInfo
        /// </devdoc>
        internal override object FromString(string value, NumberFormatInfo formatInfo) {
                return Int16.Parse(value, NumberStyles.Integer, formatInfo);
        }
        
        
        /// <include file='doc\Int16Converter.uex' path='docs/doc[@for="Int16Converter.ToString"]/*' />
        /// <devdoc>
        /// Convert the given value from a string using the given formatInfo
        /// </devdoc>
        internal override string ToString(object value, NumberFormatInfo formatInfo) {
                return ((Int16)value).ToString("G", formatInfo);
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\isupportinitialize.cs ===
//------------------------------------------------------------------------------
// <copyright file="ISupportInitialize.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    

    using System.Diagnostics;

    using System;

    /// <include file='doc\ISupportInitialize.uex' path='docs/doc[@for="ISupportInitialize"]/*' />
    /// <devdoc>
    ///    <para>Specifies that this object supports
    ///       a simple,
    ///       transacted notification for batch initialization.</para>
    /// </devdoc>
    public interface ISupportInitialize {
        /// <include file='doc\ISupportInitialize.uex' path='docs/doc[@for="ISupportInitialize.BeginInit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Signals
        ///       the object that initialization is starting.
        ///    </para>
        /// </devdoc>
        void BeginInit();

        /// <include file='doc\ISupportInitialize.uex' path='docs/doc[@for="ISupportInitialize.EndInit"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Signals the object that initialization is
        ///       complete.
        ///    </para>
        /// </devdoc>
        void EndInit();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\itypedescriptorcontext.cs ===
//------------------------------------------------------------------------------
// <copyright file="ITypeDescriptorContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    

    using System.Diagnostics;

    /// <include file='doc\ITypeDescriptorContext.uex' path='docs/doc[@for="ITypeDescriptorContext"]/*' />
    /// <devdoc>
    ///    <para> 
    ///       Provides information about a context to a type converter or a value editor,
    ///       so that the type converter or editor can perform a conversion.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public interface ITypeDescriptorContext : IServiceProvider {
    
        /// <include file='doc\ITypeDescriptorContext.uex' path='docs/doc[@for="ITypeDescriptorContext.Container"]/*' />
        /// <devdoc>
        ///    <para>Gets the container with the set of objects for this formatter.</para>
        /// </devdoc>
        IContainer Container { get; }
        
        /// <include file='doc\ITypeDescriptorContext.uex' path='docs/doc[@for="ITypeDescriptorContext.Instance"]/*' />
        /// <devdoc>
        ///    <para>Gets the instance that is invoking the method on the formatter object.</para>
        /// </devdoc>
        object Instance { get; }
        
        /// <include file='doc\ITypeDescriptorContext.uex' path='docs/doc[@for="ITypeDescriptorContext.PropertyDescriptor"]/*' />
        /// <devdoc>
        ///      Retrieves the PropertyDescriptor that is surfacing the given context item.
        /// </devdoc>
        PropertyDescriptor PropertyDescriptor { get; }
        
        /// <include file='doc\ITypeDescriptorContext.uex' path='docs/doc[@for="ITypeDescriptorContext.OnComponentChanging"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this object can be changed.</para>
        /// </devdoc>
        bool OnComponentChanging();
        
        /// <include file='doc\ITypeDescriptorContext.uex' path='docs/doc[@for="ITypeDescriptorContext.OnComponentChanged"]/*' />
        /// <devdoc>
        /// <para>Raises the <see cref='System.ComponentModel.Design.IComponentChangeService.ComponentChanged'/>
        /// event.</para>
        /// </devdoc>
        void OnComponentChanged();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\isite.cs ===
/*
 * Copyright (c) 1999, Microsoft Corporation. All Rights Reserved.
 * Information Contained Herein is Proprietary and Confidential.
 */
namespace System.ComponentModel {
    
        using System;
    /*
     * Containers use sites to manage and communicate their child components.
     *
     * A site is a convenient place for a container to store container-specific
     * per-component information.  The canonical example of such a piece of
     * information is the name of the component.
     *
     * To be a site, a class implements the ISite interface.
     *
     * @security(checkClassLinking=on)
     */
         // Interfaces don't need to be serializable
    /// <include file='doc\ISite.uex' path='docs/doc[@for="ISite"]/*' />
    /// <devdoc>
    ///    <para>Provides functionality required by sites. Sites bind
    ///       a <see cref='System.ComponentModel.Component'/> to a <see cref='System.ComponentModel.Container'/>
    ///       and enable communication between them, as well as provide a way
    ///       for the container to manage its components.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public interface ISite : IServiceProvider {
        /** The component sited by this component site. */
        /// <include file='doc\ISite.uex' path='docs/doc[@for="ISite.Component"]/*' />
        /// <devdoc>
        ///    <para>When implemented by a class, gets the component associated with the <see cref='System.ComponentModel.ISite'/>.</para>
        /// </devdoc>
        IComponent Component {get;}
    
        /** The container in which the component is sited. */
        /// <include file='doc\ISite.uex' path='docs/doc[@for="ISite.Container"]/*' />
        /// <devdoc>
        /// <para>When implemented by a class, gets the container associated with the <see cref='System.ComponentModel.ISite'/>.</para>
        /// </devdoc>
        IContainer Container {get;}
    
        /** Indicates whether the component is in design mode. */
        /// <include file='doc\ISite.uex' path='docs/doc[@for="ISite.DesignMode"]/*' />
        /// <devdoc>
        ///    <para>When implemented by a class, determines whether the component is in design mode.</para>
        /// </devdoc>
        bool DesignMode {get;}
    
        /** 
         * The name of the component.
         */
        /// <include file='doc\ISite.uex' path='docs/doc[@for="ISite.Name"]/*' />
        /// <devdoc>
        ///    <para>When implemented by a class, gets or sets the name of
        ///       the component associated with the <see cref='System.ComponentModel.ISite'/>.</para>
        /// </devdoc>
        String Name {
                get;
                set;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\license.cs ===
//------------------------------------------------------------------------------
// <copyright file="License.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;

    /// <include file='doc\License.uex' path='docs/doc[@for="License"]/*' />
    /// <devdoc>
    /// <para>Provides the <see langword='abstract'/> base class for all licenses. A license is
    ///    granted to a specific instance of a component.</para>
    /// </devdoc>
    public abstract class License : IDisposable {

        /// <include file='doc\License.uex' path='docs/doc[@for="License.LicenseKey"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, gets the license key granted to this component.</para>
        /// </devdoc>
        public abstract string LicenseKey { get; }

        /// <include file='doc\License.uex' path='docs/doc[@for="License.Dispose"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, releases the license.</para>
        /// </devdoc>
        public abstract void Dispose();
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\licenseexception.cs ===
//------------------------------------------------------------------------------
// <copyright file="LicenseException.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;

    /// <include file='doc\LicenseException.uex' path='docs/doc[@for="LicenseException"]/*' />
    /// <devdoc>
    ///    <para>Represents the exception thrown when a component cannot be granted a license.</para>
    /// </devdoc>
    public class LicenseException : SystemException {
        private Type type;
        private object instance;

        /// <include file='doc\LicenseException.uex' path='docs/doc[@for="LicenseException.LicenseException"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.LicenseException'/> class for the 
        ///    specified type.</para>
        /// </devdoc>
        public LicenseException(Type type) : this(type, null, SR.GetString(SR.LicExceptionTypeOnly, type.FullName)) {
        }
        /// <include file='doc\LicenseException.uex' path='docs/doc[@for="LicenseException.LicenseException1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.LicenseException'/> class for the 
        ///    specified type and instance.</para>
        /// </devdoc>
        public LicenseException(Type type, object instance) : this(type, null, SR.GetString(SR.LicExceptionTypeAndInstance, type.FullName, instance.GetType().FullName))  {
        }
        /// <include file='doc\LicenseException.uex' path='docs/doc[@for="LicenseException.LicenseException2"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.LicenseException'/> class for the 
        ///    specified type and instance with the specified message.</para>
        /// </devdoc>
        public LicenseException(Type type, object instance, string message) : base(message) {
            this.type = type;
            this.instance = instance;
            HResult = HResults.License;
        }
        /// <include file='doc\LicenseException.uex' path='docs/doc[@for="LicenseException.LicenseException3"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.LicenseException'/> class for the 
        ///    specified innerException, type and instance with the specified message.</para>
        /// </devdoc>
        public LicenseException(Type type, object instance, string message, Exception innerException) : base(message, innerException) {
            this.type = type;
            this.instance = instance;
            HResult = HResults.License;
        }

        /// <include file='doc\LicenseException.uex' path='docs/doc[@for="LicenseException.LicensedType"]/*' />
        /// <devdoc>
        ///    <para>Gets the type of the component that was not granted a license.</para>
        /// </devdoc>
        public Type LicensedType {
            get {
                return type;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\isynchronizeinvoke.cs ===
//------------------------------------------------------------------------------
// <copyright file="ISynchronizeInvoke.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System; 
         
    /// <include file='doc\ISynchronizeInvoke.uex' path='docs/doc[@for="ISynchronizeInvoke"]/*' />
    /// <devdoc>
    ///    <para>Provides a way to synchronously or asynchronously execute a delegate.</para>
    /// </devdoc>
    public interface ISynchronizeInvoke {
    
        /// <include file='doc\ISynchronizeInvoke.uex' path='docs/doc[@for="ISynchronizeInvoke.InvokeRequired"]/*' />
        /// <devdoc>
        /// <para>Gets a value indicating whether the caller must call <see cref='System.ComponentModel.ISynchronizeInvoke.Invoke'/> when calling an object that implements 
        ///    this interface.</para>
        /// </devdoc>
        bool InvokeRequired{get;}
                
        /// <include file='doc\ISynchronizeInvoke.uex' path='docs/doc[@for="ISynchronizeInvoke.BeginInvoke"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Executes the given delegate on the main thread that this object executes on.</para>
        /// </devdoc>
        IAsyncResult BeginInvoke(Delegate method, object[] args);            
        
        /// <include file='doc\ISynchronizeInvoke.uex' path='docs/doc[@for="ISynchronizeInvoke.EndInvoke"]/*' />
        /// <devdoc>
        ///    <para>Waits until the process you started by 
        ///       calling <see cref='System.ComponentModel.ISynchronizeInvoke.BeginInvoke'/> completes, and then returns
        ///       the value generated by the process.</para>
        /// </devdoc>
        object EndInvoke(IAsyncResult result);                      
        
        /// <include file='doc\ISynchronizeInvoke.uex' path='docs/doc[@for="ISynchronizeInvoke.Invoke"]/*' />
        /// <devdoc>
        ///    <para> 
        ///       Executes the given delegate on the main thread that this object
        ///       executes on.</para>
        /// </devdoc>
        object Invoke(Delegate method, object[] args);        
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\itypedlist.cs ===
//------------------------------------------------------------------------------
// <copyright file="ITypedList.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {

    using System;
    using System.ComponentModel;

    /// <include file='doc\ITypedList.uex' path='docs/doc[@for="ITypedList"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public interface ITypedList {
        /// <include file='doc\ITypedList.uex' path='docs/doc[@for="ITypedList.GetListName"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        string GetListName(PropertyDescriptor[] listAccessors);
        /// <include file='doc\ITypedList.uex' path='docs/doc[@for="ITypedList.GetItemProperties"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PropertyDescriptorCollection GetItemProperties(PropertyDescriptor[] listAccessors);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\licensecontext.cs ===
//------------------------------------------------------------------------------
// <copyright file="LicenseContext.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.Runtime.Remoting;
    

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;
    using System.Reflection;    

    /// <include file='doc\LicenseContext.uex' path='docs/doc[@for="LicenseContext"]/*' />
    /// <devdoc>
    ///    <para>Specifies when the licensed object can be used.</para>
    /// </devdoc>
    public class LicenseContext : IServiceProvider {

        /// <include file='doc\LicenseContext.uex' path='docs/doc[@for="LicenseContext.UsageMode"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, gets a value that specifies when a license can be used.</para>
        /// </devdoc>
        public virtual LicenseUsageMode UsageMode { 
            get {
                return LicenseUsageMode.Runtime;
            }
        }

        /// <include file='doc\LicenseContext.uex' path='docs/doc[@for="LicenseContext.GetSavedLicenseKey"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, gets a saved license 
        ///       key for the specified type, from the specified resource assembly.</para>
        /// </devdoc>
        public virtual string GetSavedLicenseKey(Type type, Assembly resourceAssembly) {
            return null;
        }

        /// <include file='doc\LicenseContext.uex' path='docs/doc[@for="LicenseContext.GetService"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, will return an object that implements the asked for service.</para>
        /// </devdoc>
        public virtual object GetService(Type type) {
            return null;
        }

        /// <include file='doc\LicenseContext.uex' path='docs/doc[@for="LicenseContext.SetSavedLicenseKey"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, sets a license key for the specified type.</para>
        /// </devdoc>
        public virtual void SetSavedLicenseKey(Type type, string key) {
            // no-op;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\listchangedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListChangedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {

    /// <include file='doc\TableChangedEventHandler.uex' path='docs/doc[@for="ListChangedEventHandler"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public delegate void ListChangedEventHandler(object sender, ListChangedEventArgs e);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\licenseprovider.cs ===
//------------------------------------------------------------------------------
// <copyright file="LicenseProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.Runtime.Remoting;
    

    using System.Diagnostics;
    using System;
    using Microsoft.Win32;

    /// <include file='doc\LicenseProvider.uex' path='docs/doc[@for="LicenseProvider"]/*' />
    /// <devdoc>
    /// <para>Provides the <see langword='abstract'/> base class for implementing a <see cref='System.ComponentModel.LicenseProvider'/>.</para>
    /// </devdoc>
    public abstract class LicenseProvider {

        /// <include file='doc\LicenseProvider.uex' path='docs/doc[@for="LicenseProvider.GetLicense"]/*' />
        /// <devdoc>
        ///    <para>When overridden in a derived class, gets a license for an <paramref name="instance "/>or <paramref name="type "/>
        ///       of component.</para>
        /// </devdoc>
        public abstract License GetLicense(LicenseContext context, Type type, object instance, bool allowExceptions);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\licenseusagemode.cs ===
//------------------------------------------------------------------------------
// <copyright file="LicenseUsageMode.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    

    using System.Diagnostics;
    using System;

    /// <include file='doc\LicenseUsageMode.uex' path='docs/doc[@for="LicenseUsageMode"]/*' />
    /// <devdoc>
    ///    <para>Specifies when the license can be used.</para>
    /// </devdoc>
    public enum LicenseUsageMode {

        /// <include file='doc\LicenseUsageMode.uex' path='docs/doc[@for="LicenseUsageMode.Runtime"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Used during runtime.
        ///    </para>
        /// </devdoc>
        Runtime,

        /// <include file='doc\LicenseUsageMode.uex' path='docs/doc[@for="LicenseUsageMode.Designtime"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Used during design time by a visual designer or the compiler.
        ///    </para>
        /// </devdoc>
        Designtime,
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\listbindableattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListBindableAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\ListBindableAttribute.uex' path='docs/doc[@for="ListBindableAttribute"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public sealed class ListBindableAttribute : Attribute {
        /// <include file='doc\ListBindableAttribute.uex' path='docs/doc[@for="ListBindableAttribute.Yes"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly ListBindableAttribute Yes = new ListBindableAttribute(true);

        /// <include file='doc\ListBindableAttribute.uex' path='docs/doc[@for="ListBindableAttribute.No"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly ListBindableAttribute No = new ListBindableAttribute(false);

        /// <include file='doc\ListBindableAttribute.uex' path='docs/doc[@for="ListBindableAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public static readonly ListBindableAttribute Default = Yes;

        private bool listBindable   = false;
        private bool isDefault  = false;

        /// <include file='doc\ListBindableAttribute.uex' path='docs/doc[@for="ListBindableAttribute.ListBindableAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ListBindableAttribute(bool listBindable) {
            this.listBindable = listBindable;
        }

        /// <include file='doc\ListBindableAttribute.uex' path='docs/doc[@for="ListBindableAttribute.ListBindableAttribute1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ListBindableAttribute(BindableSupport flags) {
            this.listBindable = (flags != BindableSupport.No);
            this.isDefault = (flags == BindableSupport.Default);
        }

        /// <include file='doc\ListBindableAttribute.uex' path='docs/doc[@for="ListBindableAttribute.ListBindable"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool ListBindable {
            get {
                return listBindable;
            }
        }

        /// <include file='doc\ListBindableAttribute.uex' path='docs/doc[@for="ListBindableAttribute.Equals"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }
            
            ListBindableAttribute other = obj as ListBindableAttribute;
            return other != null && other.ListBindable == listBindable;
        }
        
        /// <include file='doc\ListBindableAttribute.uex' path='docs/doc[@for="ListBindableAttribute.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the hashcode for this object.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }


        /// <include file='doc\ListBindableAttribute.uex' path='docs/doc[@for="ListBindableAttribute.IsDefaultAttribute"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public override bool IsDefaultAttribute() {
            return (this.Equals(Default) || isDefault);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\licensemanager.cs ===
//------------------------------------------------------------------------------
// <copyright file="LicenseManager.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.Runtime.Remoting.Activation;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.Reflection;
    using System.Diagnostics;
    using System;
    using System.Text;
    using System.Collections;
    using System.ComponentModel.Design;
    using Microsoft.Win32;

    /// <include file='doc\LicenseManager.uex' path='docs/doc[@for="LicenseManager"]/*' />
    /// <devdoc>
    ///    <para>Provides properties and methods to add a license
    ///       to a component and to manage a <see cref='System.ComponentModel.LicenseProvider'/>. This class cannot be inherited.</para>
    /// </devdoc>
    public sealed class LicenseManager {
        private static readonly object selfLock = new object();

        private static LicenseContext context = null;
        private static object contextLockHolder = null;
        private static Hashtable providers;
        private static Hashtable providerInstances;

        // not creatable...
        //
        private LicenseManager() {
        }

        /// <include file='doc\LicenseManager.uex' path='docs/doc[@for="LicenseManager.CurrentContext"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets the current <see cref='System.ComponentModel.LicenseContext'/> which specifies when the licensed object can be
        ///       used.
        ///    </para>
        /// </devdoc>
        public static LicenseContext CurrentContext {
            get {
                if (context == null) {
                    lock(typeof(LicenseManager)) {
                        if (context == null) {
                            context = new System.ComponentModel.Design.RuntimeLicenseContext();
                        }
                    }
                }
                return context;
            }
            set {
                lock(typeof(LicenseManager)) {
                    if (contextLockHolder != null) {
                        throw new InvalidOperationException(SR.GetString(SR.LicMgrContextCannotBeChanged));
                    }
                    context = value;
                }
            }
        }

        /// <include file='doc\LicenseManager.uex' path='docs/doc[@for="LicenseManager.UsageMode"]/*' />
        /// <devdoc>
        /// <para>Gets the <see cref='System.ComponentModel.LicenseUsageMode'/> that
        ///    specifies when the licensed object can be used, for the <see cref='System.ComponentModel.LicenseManager.CurrentContext'/>.</para>
        /// </devdoc>
        public static LicenseUsageMode UsageMode {
            get {
                if (context != null) {
                    return context.UsageMode;
                }
                return LicenseUsageMode.Runtime;
            }
        }

        /// <include file='doc\LicenseManager.uex' path='docs/doc[@for="LicenseManager.CacheProvider"]/*' />
        /// <devdoc>
        ///     Caches the provider, both in the instance cache, and the type
        ///     cache.
        /// </devdoc>
        private static void CacheProvider(Type type, LicenseProvider provider) {
            if (providers == null) {
                providers = new Hashtable();
            }
            providers[type] = provider;

            if (provider != null) {
                if (providerInstances == null) {
                    providerInstances = new Hashtable();
                }
                providerInstances[provider.GetType()] = provider;
            }
        }

        /// <include file='doc\LicenseManager.uex' path='docs/doc[@for="LicenseManager.CreateWithContext"]/*' />
        /// <devdoc>
        ///    <para>Creates an instance of the specified type, using 
        ///       creationContext
        ///       as the context in which the licensed instance can be used.</para>
        /// </devdoc>
        public static object CreateWithContext(Type type, LicenseContext creationContext) {
            return CreateWithContext(type, creationContext, new object[0]);
        }

        /// <include file='doc\LicenseManager.uex' path='docs/doc[@for="LicenseManager.CreateWithContext1"]/*' />
        /// <devdoc>
        ///    <para>Creates an instance of the specified type with the 
        ///       specified arguments, using creationContext as the context in which the licensed
        ///       instance can be used.</para>
        /// </devdoc>
        public static object CreateWithContext(Type type, LicenseContext creationContext, object[] args) {
            if ((!(type.IsPublic || type.IsNestedPublic)) && (type.Assembly == typeof(LicenseManager).Assembly)) {
                IntSecurity.FullReflection.Demand();
            }

            object created = null;

            lock(typeof(LicenseManager)) {
                LicenseContext normal = CurrentContext;
                try {
                    CurrentContext = creationContext;
                    LockContext(selfLock);
                    try {
                        created = Activator.CreateInstance(type, BindingFlags.Instance | BindingFlags.Public | BindingFlags.CreateInstance, null, args,null);
                    }
                    catch (TargetInvocationException e) {
                        throw e.InnerException;
                    }
                }
                finally {
                    UnlockContext(selfLock);
                    CurrentContext = normal;
                }
            }

            return created;
        }

        /// <include file='doc\LicenseManager.uex' path='docs/doc[@for="LicenseManager.GetCachedNoLicenseProvider"]/*' />
        /// <devdoc>
        ///     Determines if type was actually cached to have _no_ provider,
        ///     as opposed to not being cached.
        /// </devdoc>
        private static bool GetCachedNoLicenseProvider(Type type) {
            if (providers != null) {
                return providers.ContainsKey(type);
            }
            return false;
        }

        /// <include file='doc\LicenseManager.uex' path='docs/doc[@for="LicenseManager.GetCachedProvider"]/*' />
        /// <devdoc>
        ///     Retrieves a cached instance of the provider associated with the
        ///     specified type.
        /// </devdoc>
        private static LicenseProvider GetCachedProvider(Type type) {
            if (providers != null) {
                return(LicenseProvider)providers[type];
            }
            return null;
        }

        /// <include file='doc\LicenseManager.uex' path='docs/doc[@for="LicenseManager.GetCachedProviderInstance"]/*' />
        /// <devdoc>
        ///     Retrieves a cached instance of the provider of the specified
        ///     type.
        /// </devdoc>
        private static LicenseProvider GetCachedProviderInstance(Type providerType) {
            Debug.Assert(providerType != null, "Type cannot ever be null");
            if (providerInstances != null) {
                return(LicenseProvider)providerInstances[providerType];
            }
            return null;
        }

        /// <include file='doc\LicenseManager.uex' path='docs/doc[@for="LicenseManager.GetLicenseInteropHelperType"]/*' />
        /// <devdoc>
        ///     Retrieves the typehandle of the interop helper
        /// </devdoc>
        private static RuntimeTypeHandle GetLicenseInteropHelperType() {
            return typeof(LicenseInteropHelper).TypeHandle;
        }

        /// <include file='doc\LicenseManager.uex' path='docs/doc[@for="LicenseManager.IsLicensed"]/*' />
        /// <devdoc>
        ///    <para>Determines if the given type has a valid license or not.</para>
        /// </devdoc>
        public static bool IsLicensed(Type type) {
            Debug.Assert(type != null, "IsValid Type cannot ever be null");
            License license;
            bool value = ValidateInternal(type, null, false, out license);
            if (license != null) {
                license.Dispose();
                license = null;
            }
            return value;
        }

        /// <include file='doc\LicenseManager.uex' path='docs/doc[@for="LicenseManager.IsValid"]/*' />
        /// <devdoc>
        ///    <para>Determines if a valid license can be granted for the specified type.</para>
        /// </devdoc>
        public static bool IsValid(Type type) {
            Debug.Assert(type != null, "IsValid Type cannot ever be null");
            License license;
            bool value = ValidateInternal(type, null, false, out license);
            if (license != null) {
                license.Dispose();
                license = null;
            }
            return value;
        }


        /// <include file='doc\LicenseManager.uex' path='docs/doc[@for="LicenseManager.IsValid1"]/*' />
        /// <devdoc>
        ///    <para>Determines if a valid license can be granted for the 
        ///       specified instance of the type. This method creates a valid <see cref='System.ComponentModel.License'/>. </para>
        /// </devdoc>
        public static bool IsValid(Type type, object instance, out License license) {
            return ValidateInternal(type, instance, false, out license);
        }

        /// <include file='doc\LicenseManager.uex' path='docs/doc[@for="LicenseManager.LockContext"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static void LockContext(object contextUser) {
            lock(typeof(LicenseManager)) {
                if (contextLockHolder != null) {
                    throw new InvalidOperationException(SR.GetString(SR.LicMgrAlreadyLocked));
                }
                contextLockHolder = contextUser;
            }
        }

        /// <include file='doc\LicenseManager.uex' path='docs/doc[@for="LicenseManager.UnlockContext"]/*' />
        /// <devdoc>
        /// </devdoc>
        public static void UnlockContext(object contextUser) {
            lock(typeof(LicenseManager)) {
                if (contextLockHolder != contextUser) {
                    throw new ArgumentException(SR.GetString(SR.LicMgrDifferentUser));
                }
                contextLockHolder = null;
            }
        }

        /// <include file='doc\LicenseManager.uex' path='docs/doc[@for="LicenseManager.ValidateInternal"]/*' />
        /// <devdoc>
        ///     Internal validation helper.
        /// </devdoc>
        private static bool ValidateInternal(Type type, object instance, bool allowExceptions, out License license) {
            string licenseKey;
            return ValidateInternalRecursive(CurrentContext, 
                                             type, 
                                             instance, 
                                             allowExceptions, 
                                             out license,
                                             out licenseKey);
        }

        /// <include file='doc\LicenseManager.uex' path='docs/doc[@for="LicenseManager.ValidateInternalRecursive"]/*' />
        /// <devdoc>
        ///     Since we want to walk up the entire inheritance change, when not 
        ///     give an instance, we need another helper method to walk up
        ///     the chain...
        /// </devdoc>
        private static bool ValidateInternalRecursive(LicenseContext context, Type type, object instance, bool allowExceptions, out License license, out string licenseKey) {
            LicenseProvider provider = GetCachedProvider(type);
            if (provider == null && !GetCachedNoLicenseProvider(type)) {
                // NOTE : Must look directly at the class, we want no inheritance.
                //
                LicenseProviderAttribute attr = (LicenseProviderAttribute)Attribute.GetCustomAttribute(type, typeof(LicenseProviderAttribute), false);
                if (attr != null) {
                    Type providerType = attr.LicenseProvider;
                    provider = GetCachedProviderInstance(providerType);

                    if (provider == null) {
                        if ((!(providerType.IsPublic || providerType.IsNestedPublic)) && (providerType.Assembly == typeof(LicenseManager).Assembly)) {
                            IntSecurity.FullReflection.Demand();
                        }

                        provider = (LicenseProvider)Activator.CreateInstance(providerType, BindingFlags.Instance | BindingFlags.Public | BindingFlags.CreateInstance, null, null, null);
                    }
                }

                CacheProvider(type, provider);
            }

            license = null;
            bool isValid = true;

            licenseKey = null;
            if (provider != null) {
                license = provider.GetLicense(context, type, instance, allowExceptions);
                if (license == null) {
                    isValid = false;
                }
                else {
                    // For the case where a COM client is calling "RequestLicKey", 
                    // we try to squirrel away the first found license key
                    //
                    licenseKey = license.LicenseKey;
                }
            }

            // When looking only at a type, we need to recurse up the inheritence
            // chain, however, we can't give out the license, since this may be
            // from more than one provider.
            //
            if (isValid && instance == null) {
                Type baseType = type.BaseType;
                if (baseType != typeof(object) && baseType != null) {
                    if (license != null) {
                        license.Dispose();
                        license = null;
                    }
                    string temp;
                    isValid = ValidateInternalRecursive(context, baseType, null, allowExceptions, out license, out temp);
                    if (license != null) {
                        license.Dispose();
                        license = null;
                    }
                }
            }

            return isValid;
        }

        /// <include file='doc\LicenseManager.uex' path='docs/doc[@for="LicenseManager.Validate"]/*' />
        /// <devdoc>
        ///    <para>Determines if a license can be granted for the specified type.</para>
        /// </devdoc>
        public static void Validate(Type type) {
            License lic;

            if (!ValidateInternal(type, null, true, out lic)) {
                throw new LicenseException(type);
            }

            if (lic != null) {
                lic.Dispose();
                lic = null;
            }
        }

        /// <include file='doc\LicenseManager.uex' path='docs/doc[@for="LicenseManager.Validate1"]/*' />
        /// <devdoc>
        ///    <para>Determines if a license can be granted for the instance of the specified type.</para>
        /// </devdoc>
        public static License Validate(Type type, object instance) {
            License lic;

            if (!ValidateInternal(type, instance, true, out lic)) {
                throw new LicenseException(type, instance);
            }

            return lic;
        }


        // This is a helper class that supports the CLR's IClassFactory2 marshaling
        // support.
        //
        // When a managed object is exposed to COM, the CLR invokes
        // AllocateAndValidateLicense() to set up the appropriate
        // license context and instantiate the object.
        //
        // When the CLR consumes an unmanaged COM object, the CLR invokes
        // GetCurrentContextInfo() to figure out the licensing context
        // and decide whether to call ICF::CreateInstance() (designtime) or
        // ICF::CreateInstanceLic() (runtime). In the former case, it also
        // requests the class factory for a runtime license key and invokes
        // SaveKeyInCurrentContext() to stash a copy in the current licensing
        // context
        class LicenseInteropHelper {

            // Define some common HRESULTs.
            const int S_OK = 0;
            const int E_NOTIMPL = unchecked((int)0x80004001); 
            const int CLASS_E_NOTLICENSED = unchecked((int)0x80040112);
            const int E_FAIL              = unchecked((int)0x80000008);

            DesigntimeLicenseContext helperContext;
            LicenseContext    savedLicenseContext;
            Type              savedType;

            // The CLR invokes this whenever a COM client invokes
            // IClassFactory::CreateInstance() or IClassFactory2::CreateInstanceLic()
            // on a managed managed that has a LicenseProvider custom attribute.
            //
            // If we are being entered because of a call to ICF::CreateInstance(),
            // fDesignTime will be "true".
            //
            // If we are being entered because of a call to ICF::CreateInstanceLic(),
            // fDesignTime will be "false" and bstrKey will point a non-null
            // license key.
            private object AllocateAndValidateLicense(RuntimeTypeHandle rth, IntPtr bstrKey, int fDesignTime) {
                Type type = Type.GetTypeFromHandle(rth);
                CLRLicenseContext licensecontext = new CLRLicenseContext(fDesignTime != 0 ? LicenseUsageMode.Designtime : LicenseUsageMode.Runtime, type);
                if (fDesignTime == 0 && bstrKey != (IntPtr)0) {
                    licensecontext.SetSavedLicenseKey(type, Marshal.PtrToStringBSTR(bstrKey));
                }


                try {
                    return LicenseManager.CreateWithContext(type, licensecontext);
                }
                catch (LicenseException lexp) {
                    throw new COMException(lexp.Message, CLASS_E_NOTLICENSED);
                }
            }

            // The CLR invokes this whenever a COM client invokes
            // IClassFactory2::RequestLicKey on a managed class.
            //
            // This method should return the appropriate HRESULT and set pbstrKey
            // to the licensing key.
            private int RequestLicKey(RuntimeTypeHandle rth, ref IntPtr pbstrKey) {
                Type type = Type.GetTypeFromHandle(rth);
                License license;
                string licenseKey;

                // license will be null, since we passed no instance,
                // however we can still retrieve the "first" license
                // key from the file. This really will only
                // work for simple COM-compatible license providers
                // like LicFileLicenseProvider that don't require the
                // instance to grant a key.
                //
                if (!LicenseManager.ValidateInternalRecursive(LicenseManager.CurrentContext, 
                                                              type, 
                                                              null, 
                                                              false, 
                                                              out license, 
                                                              out licenseKey)) {
                    return E_FAIL;
                }

                if (licenseKey == null) {
                    return E_FAIL;
                }

                pbstrKey = Marshal.StringToBSTR(licenseKey);

                if (license != null) {
                    license.Dispose();
                    license = null;
                }

                return S_OK;

            }


            // The CLR invokes this whenever a COM client invokes
            // IClassFactory2::GetLicInfo on a managed class.
            //
            // COM normally doesn't expect this function to fail so this method
            // should only throw in the case of a catastrophic error (stack, memory, etc.)
            private void GetLicInfo(RuntimeTypeHandle rth, ref int pRuntimeKeyAvail, ref int pLicVerified) {
                pRuntimeKeyAvail = 0;
                pLicVerified = 0;

                Type type = Type.GetTypeFromHandle(rth);
                License license;
                string licenseKey;

                if (helperContext == null) {
                    helperContext = new DesigntimeLicenseContext();
                }
                else {
                    helperContext.savedLicenseKeys.Clear();
                }

                if (LicenseManager.ValidateInternalRecursive(helperContext, type, null, false, out license, out licenseKey)) {

                    if (helperContext.savedLicenseKeys.Contains(type.AssemblyQualifiedName)) {
                        pRuntimeKeyAvail = 1;
                    }

                    if (license != null) {
                        license.Dispose();
                        license = null;

                        pLicVerified = 1;
                    }
                }
            }

            // The CLR invokes this when instantiating an unmanaged COM
            // object. The purpose is to decide which classfactory method to
            // use.
            //
            // If the current context is design time, the CLR will
            // use ICF::CreateInstance().
            //
            // If the current context is runtime and the current context
            // exposes a non-null license key and the COM object supports
            // IClassFactory2, the CLR will use ICF2::CreateInstanceLic().
            // Otherwise, the CLR will use ICF::CreateInstance.
            //
            // Arguments:
            //    ref int fDesignTime:   on exit, this will be set to indicate
            //                           the nature of the current license context.
            //    ref int bstrKey:       on exit, this will point to the
            //                           licensekey saved inside the license context.
            //                           (only if the license context is runtime)
            //    RuntimeTypeHandle rth: the managed type of the wrapper
            private void GetCurrentContextInfo(ref int fDesignTime, ref IntPtr bstrKey, RuntimeTypeHandle rth) {
                this.savedLicenseContext = LicenseManager.CurrentContext;
                this.savedType = Type.GetTypeFromHandle(rth);
                if (this.savedLicenseContext.UsageMode == LicenseUsageMode.Designtime) {
                    fDesignTime = 1;
                    bstrKey = (IntPtr)0;
                }
                else {
                    fDesignTime = 0;
                    String key = this.savedLicenseContext.GetSavedLicenseKey(this.savedType, null);
                    bstrKey = Marshal.StringToBSTR(key);

                }
            }

            // The CLR invokes this when instantiating a licensed COM
            // object inside a designtime license context.
            // It's purpose is to save away the license key that the CLR
            // retrieved using RequestLicKey(). This license key can be NULL.
            private void SaveKeyInCurrentContext(IntPtr bstrKey) {
                if (bstrKey != (IntPtr)0) {
                    this.savedLicenseContext.SetSavedLicenseKey(this.savedType, Marshal.PtrToStringBSTR(bstrKey));
                }
            }

            // A private implementation of a LicenseContext used for instantiating
            // managed objects exposed to COM. It has memory for the license key
            // of a single Type.
            internal class CLRLicenseContext : LicenseContext {
                LicenseUsageMode  usageMode;
                Type              type;
                string            key;

                public CLRLicenseContext(LicenseUsageMode usageMode, Type type) {
                    this.usageMode = usageMode;
                    this.type      = type;
                }

                public override LicenseUsageMode UsageMode
                {
                    get {
                        return this.usageMode;
                    }
                }


                public override string GetSavedLicenseKey(Type type, Assembly resourceAssembly) {
                    return type == this.type ? this.key : null;
                }
                public override void SetSavedLicenseKey(Type type, string key) {
                    if (type == this.type) {
                        this.key = key;
                    }
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\licenseproviderattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="LicenseProviderAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    

    using System;

    /// <include file='doc\LicenseProviderAttribute.uex' path='docs/doc[@for="LicenseProviderAttribute"]/*' />
    /// <devdoc>
    /// <para>Specifies the <see cref='System.ComponentModel.LicenseProvider'/>
    /// to use with a class.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple=false, Inherited=false)]
    public sealed class LicenseProviderAttribute : Attribute {

        /// <include file='doc\LicenseProviderAttribute.uex' path='docs/doc[@for="LicenseProviderAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the default value, which is no provider. This <see langword='static '/>field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly LicenseProviderAttribute Default = new LicenseProviderAttribute();

        private Type licenseProviderType = null;
        private string licenseProviderName = null;

        /// <include file='doc\LicenseProviderAttribute.uex' path='docs/doc[@for="LicenseProviderAttribute.LicenseProviderAttribute"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.LicenseProviderAttribute'/> class without a license
        ///    provider.</para>
        /// </devdoc>
        public LicenseProviderAttribute() : this((string)null) {
        }

        /// <include file='doc\LicenseProviderAttribute.uex' path='docs/doc[@for="LicenseProviderAttribute.LicenseProviderAttribute1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.LicenseProviderAttribute'/> class with
        ///       the specified type.
        ///    </para>
        /// </devdoc>
        public LicenseProviderAttribute(string typeName) {
            licenseProviderName = typeName;
        }

        /// <include file='doc\LicenseProviderAttribute.uex' path='docs/doc[@for="LicenseProviderAttribute.LicenseProviderAttribute2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.LicenseProviderAttribute'/> class with
        ///       the specified type of license provider.
        ///    </para>
        /// </devdoc>
        public LicenseProviderAttribute(Type type) {
            licenseProviderType = type;
        }

        /// <include file='doc\LicenseProviderAttribute.uex' path='docs/doc[@for="LicenseProviderAttribute.LicenseProvider"]/*' />
        /// <devdoc>
        ///    <para>Gets the license provider to use with the associated class.</para>
        /// </devdoc>
        public Type LicenseProvider {
            get {
                if (licenseProviderType == null && licenseProviderName != null) {
                    licenseProviderType = Type.GetType(licenseProviderName);
                }
                return licenseProviderType;
            }
        }

        /// <include file='doc\LicenseProviderAttribute.uex' path='docs/doc[@for="LicenseProviderAttribute.TypeId"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       This defines a unique ID for this attribute type. It is used
        ///       by filtering algorithms to identify two attributes that are
        ///       the same type. For most attributes, this just returns the
        ///       Type instance for the attribute. LicenseProviderAttribute overrides this to include the type name and the
        ///       provider type name.
        ///    </para>
        /// </devdoc>
        public override object TypeId {
            get {
                string typeName = licenseProviderName;

                if (typeName == null && licenseProviderType != null) {
                    typeName = licenseProviderType.FullName;
                }
                return GetType().FullName + typeName;
            }
        }

        /// <include file='doc\LicenseProviderAttribute.uex' path='docs/doc[@for="LicenseProviderAttribute.Equals"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override bool Equals(object value) {
            if (value is LicenseProviderAttribute && value != null) {
                Type type = ((LicenseProviderAttribute)value).LicenseProvider;
                if (type == LicenseProvider) {
                    return true;
                }
                else {
                    if (type != null && type.Equals(LicenseProvider)) {
                        return true;
                    }
                }
            }

            return false;
        }
        
        /// <include file='doc\LicenseProviderAttribute.uex' path='docs/doc[@for="LicenseProviderAttribute.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the hashcode for this object.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\licfilelicenseprovider.cs ===
//------------------------------------------------------------------------------
// <copyright file="LicFileLicenseProvider.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.Runtime.Remoting;
    using System.ComponentModel.Design;
    using System.Diagnostics;
    using System;
    using System.Reflection;
    using System.IO;

    /// <include file='doc\LicFileLicenseProvider.uex' path='docs/doc[@for="LicFileLicenseProvider"]/*' />
    /// <devdoc>
    /// <para>Provides an implementation of a <see cref='System.ComponentModel.LicenseProvider'/>. The provider works in
    ///    a similar fashion to Microsoft .NET Framework standard licensing module.</para>
    /// </devdoc>
    public class LicFileLicenseProvider : LicenseProvider {

        /// <include file='doc\LicFileLicenseProvider.uex' path='docs/doc[@for="LicFileLicenseProvider.IsKeyValid"]/*' />
        /// <devdoc>
        /// <para>Determines if the key retrieved by the <see cref='System.ComponentModel.LicFileLicenseProvider.GetLicense'/> method is valid 
        ///    for the specified type.</para>
        /// </devdoc>
        protected virtual bool IsKeyValid(string key, Type type) {
            if (key != null) {
                return key.StartsWith(GetKey(type));
            }
            return false;
        }

        /// <include file='doc\LicFileLicenseProvider.uex' path='docs/doc[@for="LicFileLicenseProvider.GetKey"]/*' />
        /// <devdoc>
        ///    Creates a key for the specified type.
        /// </devdoc>
        protected virtual string GetKey(Type type) {

            // This string should not be localized.
            //
            return string.Format("{0} is a licensed component.", type.FullName);
        }

        /// <include file='doc\LicFileLicenseProvider.uex' path='docs/doc[@for="LicFileLicenseProvider.GetLicense"]/*' />
        /// <devdoc>
        ///    <para>Gets a license for the instance of the component and determines if it is valid.</para>
        /// </devdoc>
        public override License GetLicense(LicenseContext context, Type type, object instance, bool allowExceptions) {
            LicFileLicense lic = null;
            
            Debug.Assert(context != null, "No context provided!");
            if (context != null) {
                if (context.UsageMode == LicenseUsageMode.Runtime) {
                    string key = context.GetSavedLicenseKey(type, null);
                    if (key != null && IsKeyValid(key, type)) {
                        lic = new LicFileLicense(this, key);
                    }
                }

                if (lic == null) {
                    string modulePath = null;

                    if (context != null) {
                        ITypeResolutionService resolver = (ITypeResolutionService)context.GetService(typeof(ITypeResolutionService));
                        if (resolver != null)
                            modulePath = resolver.GetPathOfAssembly(type.Assembly.GetName());
                    }

                    if (modulePath == null)
                        modulePath = type.Module.FullyQualifiedName;

                    string moduleDir = Path.GetDirectoryName(modulePath);
                    string licenseFile = moduleDir + "\\" + type.FullName + ".lic";

                    if (File.Exists(licenseFile)) {
                        Stream licStream = new FileStream(licenseFile, FileMode.Open, FileAccess.Read, FileShare.Read);
                        StreamReader sr = new StreamReader(licStream);
                        string s = sr.ReadLine();
                        sr.Close();
                        if (IsKeyValid(s, type)) {
                            lic = new LicFileLicense(this, GetKey(type));
                        }
                    }

                    if (lic != null) {
                        context.SetSavedLicenseKey(type, lic.LicenseKey);
                    }
                }

            }
            return lic;
        }

        private class LicFileLicense : License {
            private LicFileLicenseProvider owner;
            private string key;

            public LicFileLicense(LicFileLicenseProvider owner, string key) {
                this.owner = owner;
                this.key = key;
            }
            public override string LicenseKey { 
                get {
                    return key;
                }
            }
            public override void Dispose() {
            }
        }
    }

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\listchangedeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListChangedEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {

    using System;
    using Microsoft.Win32;
    using System.Diagnostics;

    /// <include file='doc\TableChangedEventArgs.uex' path='docs/doc[@for="ListChangedEventArgs"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public class ListChangedEventArgs : EventArgs {

        private ListChangedType listChangedType;
        private int newIndex;
        private int oldIndex;
        private PropertyDescriptor propDesc;

        /// <include file='doc\TableChangedEventArgs.uex' path='docs/doc[@for="ListChangedEventArgs.ListChangedEventArgs"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ListChangedEventArgs(ListChangedType listChangedType, int newIndex) : this(listChangedType, newIndex, -1) {
        }

        /// <include file='doc\TableChangedEventArgs.uex' path='docs/doc[@for="ListChangedEventArgs.ListChangedEventArgs1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ListChangedEventArgs(ListChangedType listChangedType, PropertyDescriptor propDesc) {
            Debug.Assert(listChangedType != ListChangedType.Reset, "this constructor is used only for changes in the list MetaData");
            Debug.Assert(listChangedType != ListChangedType.ItemAdded, "this constructor is used only for changes in the list MetaData");
            Debug.Assert(listChangedType != ListChangedType.ItemDeleted, "this constructor is used only for changes in the list MetaData");
            Debug.Assert(listChangedType != ListChangedType.ItemChanged, "this constructor is used only for changes in the list MetaData");

            this.listChangedType = listChangedType;
            this.propDesc = propDesc;
        }

        /// <include file='doc\TableChangedEventArgs.uex' path='docs/doc[@for="ListChangedEventArgs.ListChangedEventArgs2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ListChangedEventArgs(ListChangedType listChangedType, int newIndex, int oldIndex) {
            Debug.Assert(listChangedType != ListChangedType.PropertyDescriptorAdded, "this constructor is used only for item changed in the list");
            Debug.Assert(listChangedType != ListChangedType.PropertyDescriptorDeleted, "this constructor is used only for item changed in the list");
            Debug.Assert(listChangedType != ListChangedType.PropertyDescriptorChanged, "this constructor is used only for item changed in the list");
            this.listChangedType = listChangedType;
            this.newIndex = newIndex;
            this.oldIndex = oldIndex;
        }

        /// <include file='doc\TableChangedEventArgs.uex' path='docs/doc[@for="ListChangedEventArgs.ListChangedType"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public ListChangedType ListChangedType {
            get {
                return listChangedType;
            }
        }

        /// <include file='doc\TableChangedEventArgs.uex' path='docs/doc[@for="ListChangedEventArgs.NewIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int NewIndex {
            get {
                return newIndex;
            }
        }

        /// <include file='doc\TableChangedEventArgs.uex' path='docs/doc[@for="ListChangedEventArgs.OldIndex"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int OldIndex {
            get {
                return oldIndex;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\localizableattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="LocalizableAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    

    using System.Diagnostics;

    using System;

    /// <include file='doc\LocalizableAttribute.uex' path='docs/doc[@for="LocalizableAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies whether a property should be localized.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public sealed class LocalizableAttribute : Attribute {
        private bool isLocalizable = false;

        /// <include file='doc\LocalizableAttribute.uex' path='docs/doc[@for="LocalizableAttribute.LocalizableAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.LocalizableAttribute'/> class.
        ///    </para>
        /// </devdoc>
        public LocalizableAttribute(bool isLocalizable) {
            this.isLocalizable = isLocalizable;
        }

        /// <include file='doc\LocalizableAttribute.uex' path='docs/doc[@for="LocalizableAttribute.IsLocalizable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether
        ///       a property should be localized.
        ///    </para>
        /// </devdoc>
        public bool IsLocalizable {
            get {
                return isLocalizable;
            }
        }

        /// <include file='doc\LocalizableAttribute.uex' path='docs/doc[@for="LocalizableAttribute.Yes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that a property should be localized. This
        ///    <see langword='static '/>field is read-only. 
        ///    </para>
        /// </devdoc>
        public static readonly LocalizableAttribute Yes = new LocalizableAttribute(true);

        /// <include file='doc\LocalizableAttribute.uex' path='docs/doc[@for="LocalizableAttribute.No"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that a property should not be localized. This
        ///    <see langword='static '/>field is read-only. 
        ///    </para>
        /// </devdoc>
        public static readonly LocalizableAttribute No = new LocalizableAttribute(false);

        /// <include file='doc\LocalizableAttribute.uex' path='docs/doc[@for="LocalizableAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the default value, which is <see cref='System.ComponentModel.LocalizableAttribute.No'/> , that is
        ///       a property should not be localized. This <see langword='static '/>field is
        ///       read-only.
        ///    </para>
        /// </devdoc>
        public static readonly LocalizableAttribute Default = No;

        /// <include file='doc\LocalizableAttribute.uex' path='docs/doc[@for="LocalizableAttribute.IsDefaultAttribute"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override bool IsDefaultAttribute() {
            return (IsLocalizable == Default.IsLocalizable);
        }

        /// <include file='doc\LocalizableAttribute.uex' path='docs/doc[@for="LocalizableAttribute.Equals"]/*' />
        public override bool Equals(object obj) {
            LocalizableAttribute other = obj as LocalizableAttribute; 
            return (other != null) && other.IsLocalizable == this.isLocalizable;
        }

        /// <include file='doc\LocalizableAttribute.uex' path='docs/doc[@for="LocalizableAttribute.GetHashCode"]/*' />
        public override int GetHashCode() {
            return base.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\listsortdirection.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListSortDirection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.Collections;


    /// <include file='doc\TableSortDirection.uex' path='docs/doc[@for="ListSortDirection"]/*' />
    /// <devdoc>
    ///    <para>Specifies the direction of a sort.</para>
    /// </devdoc>
    public enum ListSortDirection {
        /// <include file='doc\TableSortDirection.uex' path='docs/doc[@for="ListSortDirection.Ascending"]/*' />
        /// <devdoc>
        ///    <para>Sort in ascending order.</para>
        /// </devdoc>
        Ascending,
        /// <include file='doc\TableSortDirection.uex' path='docs/doc[@for="ListSortDirection.Descending"]/*' />
        /// <devdoc>
        ///    <para>Sort in descending order.</para>
        /// </devdoc>
        Descending 
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\listchangedtype.cs ===
//------------------------------------------------------------------------------
// <copyright file="ListChangedType.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {

    /// <include file='doc\TableChangedType.uex' path='docs/doc[@for="ListChangedType"]/*' />
    /// <devdoc>
    ///    <para>[To be supplied.]</para>
    /// </devdoc>
    public enum ListChangedType {
        /// <include file='doc\TableChangedType.uex' path='docs/doc[@for="ListChangedType.Reset"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        Reset,
        /// <include file='doc\TableChangedType.uex' path='docs/doc[@for="ListChangedType.ItemAdded"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ItemAdded,
        /// <include file='doc\TableChangedType.uex' path='docs/doc[@for="ListChangedType.ItemDeleted"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ItemDeleted,
        /// <include file='doc\TableChangedType.uex' path='docs/doc[@for="ListChangedType.ItemMoved"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ItemMoved,
        /// <include file='doc\TableChangedType.uex' path='docs/doc[@for="ListChangedType.ItemChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        ItemChanged,
        /// <include file='doc\TableChangedType.uex' path='docs/doc[@for="ListChangedType.PropertyDescriptorAdded"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PropertyDescriptorAdded,
        /// <include file='doc\TableChangedType.uex' path='docs/doc[@for="ListChangedType.PropertyDescriptorDeleted"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PropertyDescriptorDeleted,
        /// <include file='doc\TableChangedType.uex' path='docs/doc[@for="ListChangedType.PropertyDescriptorChanged"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        PropertyDescriptorChanged
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\memberattributecollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="MemberAttributeCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.InteropServices;
    using System.Reflection;
    using System.Diagnostics;
    using Microsoft.Win32;
    using System.Collections;

    /// <include file='doc\MemberAttributeCollection.uex' path='docs/doc[@for="AttributeCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a collection of attributes.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisibleAttribute(true)]
    public class AttributeCollection : ICollection {

        /// <include file='doc\MemberAttributeCollection.uex' path='docs/doc[@for="AttributeCollection.Empty"]/*' />
        /// <devdoc>
        /// An empty AttributeCollection that can used instead of creating a new one.
        /// </devdoc>
        public static readonly AttributeCollection Empty = new AttributeCollection(null);

        private Attribute[] attributes;
        private static Hashtable defaultAttributes;
        private Hashtable foundAttributes;

        /// <include file='doc\MemberAttributeCollection.uex' path='docs/doc[@for="AttributeCollection.AttributeCollection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.AttributeCollection'/> class.
        ///    </para>
        /// </devdoc>
        public AttributeCollection(Attribute[] attributes) {
            if (attributes == null) {
                attributes = new Attribute[0];
            }
            this.attributes = attributes;
        }

        /// <include file='doc\MemberAttributeCollection.uex' path='docs/doc[@for="AttributeCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number of attributes.
        ///    </para>
        /// </devdoc>
        public int Count {
            get {
                return attributes.Length;
            }
        }

        /// <include file='doc\MemberAttributeCollection.uex' path='docs/doc[@for="AttributeCollection.this"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the attribute with the specified index
        ///       number.
        ///    </para>
        /// </devdoc>
        public virtual Attribute this[int index] {
            get {
                return attributes[index];
            }
        }

        /// <include file='doc\MemberAttributeCollection.uex' path='docs/doc[@for="AttributeCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>Gets the attribute
        ///       with the specified type.</para>
        /// </devdoc>
        public virtual Attribute this[Type attributeType] {
            get {

                // create our cache.  we cache these values because
                // IsAssignableFrom (lower) is expensive.  So as soon as we find
                // a match for the type specified here, we squirrel it away
                // this saves a bunch of time when we're hitting attributes hard.
                //
                if (foundAttributes == null) {
                    foundAttributes = new Hashtable();
                }
                else {
                    Attribute found = (Attribute)foundAttributes[attributeType];
                    if (found != null) {
                        return found;
                    }
                }

                // 2 passes here for perf.  Really!  first pass, we just 
                // check equality, and if we don't find it, then we
                // do the IsAssignableFrom dance.   Turns out that's
                // a relatively expensive call and we try to avoid it
                // since we rarely encounter derived attribute types
                // and this list is usually short. 
                //
                int count = attributes.Length;
                for (int i = 0; i < count; i++) {
                    Attribute attribute = attributes[i];
                    Type aType = attribute.GetType();
                    if (aType == attributeType) {
                        foundAttributes[attributeType] = attribute;
                        return attribute;
                    }
                }

                // now check the hierarchies.
                for (int i = 0; i < count; i++) {
                    Attribute attribute = attributes[i];
                    Type aType = attribute.GetType();
                    if (attributeType.IsAssignableFrom(aType)) {
                        foundAttributes[attributeType] = attribute;
                        return attribute;
                    }
                }

                Attribute attr = GetDefaultAttribute(attributeType);

                if (attr != null) {
                    foundAttributes[attributeType] = attr;
                }

                return attr;
            }
        }

        /// <include file='doc\MemberAttributeCollection.uex' path='docs/doc[@for="AttributeCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if this collection of attributes has the
        ///       specified attribute.
        ///    </para>
        /// </devdoc>
        public bool Contains(Attribute attribute) {
            Attribute attr = this[attribute.GetType()];
            if (attr != null && attr.Equals(attribute)) {
                return true;
            }
            return false;
        }

        /// <include file='doc\MemberAttributeCollection.uex' path='docs/doc[@for="AttributeCollection.Contains1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if this attribute collection contains the all
        ///       the specified attributes
        ///       in the attribute array.
        ///    </para>
        /// </devdoc>
        public bool Contains(Attribute[] attributes) {

            if (attributes == null) {
                return true;
            }

            for (int i = 0; i < attributes.Length; i++) {
                if (!Contains(attributes[i])) {
                    return false;
                }
            }

            return true;
        }

        /// <include file='doc\MemberAttributeCollection.uex' path='docs/doc[@for="AttributeCollection.GetDefaultAttribute"]/*' />
        protected Attribute GetDefaultAttribute(Type attributeType) {
            lock (typeof(AttributeCollection)) {
                if (defaultAttributes == null) {
                    defaultAttributes = new Hashtable();
                }

                // If we have already encountered this, use what's in the
                // table.
                if (defaultAttributes.ContainsKey(attributeType)) {
                    return(Attribute)defaultAttributes[attributeType];
                }

                Attribute attr = null;
                
                // Nope, not in the table, so do the legwork to discover the default value.
                System.Reflection.FieldInfo field = attributeType.GetField("Default");
                if (field != null && field.IsStatic) {
                    attr = (Attribute)field.GetValue(null);
                }
                else {
                    ConstructorInfo ci = attributeType.GetConstructor(new Type[0]);
                    if (ci != null) {
                        attr = (Attribute)ci.Invoke(new object[0]);

                        // If we successfully created, verify that it is the
                        // default.  Attributes don't have to abide by this rule.
                        if (!attr.IsDefaultAttribute()) {
                            attr = null;
                        }
                    }
                }

                defaultAttributes[attributeType] = attr;
                return attr;
            }
        }

        /// <include file='doc\MemberAttributeCollection.uex' path='docs/doc[@for="AttributeCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an enumerator for this collection.
        ///    </para>
        /// </devdoc>
        public IEnumerator GetEnumerator() {
            return attributes.GetEnumerator();
        }

        /// <include file='doc\MemberAttributeCollection.uex' path='docs/doc[@for="AttributeCollection.Matches"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if a specified attribute
        ///       is the same as an attribute
        ///       in the collection.
        ///    </para>
        /// </devdoc>
        public bool Matches(Attribute attribute) {
            for (int i = 0; i < attributes.Length; i++) {
                if (attributes[i].Match(attribute)) {
                    return true;
                }
            }
            return false;
        }

        /// <include file='doc\MemberAttributeCollection.uex' path='docs/doc[@for="AttributeCollection.Matches1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines if the attributes
        ///       in the specified array are
        ///       the same as the attributes in the collection.
        ///    </para>
        /// </devdoc>
        public bool Matches(Attribute[] attributes) {
            for (int i = 0; i < attributes.Length; i++) {
                if (!Matches(attributes[i])) {
                    return false;
                }
            }

            return true;
        }

        /// <include file='doc\MemberAttributeCollection.uex' path='docs/doc[@for="AttributeCollection.ICollection.Count"]/*' />
        /// <internalonly/>
        int ICollection.Count {
            get {
                return Count;
            }
        }


        /// <include file='doc\MemberAttributeCollection.uex' path='docs/doc[@for="AttributeCollection.ICollection.IsSynchronized"]/*' />
        /// <internalonly/>
        bool ICollection.IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\MemberAttributeCollection.uex' path='docs/doc[@for="AttributeCollection.ICollection.SyncRoot"]/*' />
        /// <internalonly/>
        object ICollection.SyncRoot {
            get {
                return null;
            }
        }

        /// <include file='doc\MemberAttributeCollection.uex' path='docs/doc[@for="AttributeCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            Array.Copy(attributes, 0, array, index, attributes.Length);
        }

        /// <include file='doc\MemberAttributeCollection.uex' path='docs/doc[@for="AttributeCollection.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\marshalbyvaluecomponent.cs ===
//------------------------------------------------------------------------------
// <copyright file="MarshalByValueComponent.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {

    using System;
    using System.ComponentModel.Design;

    /// <include file='doc\MarshalByValueComponent.uex' path='docs/doc[@for="MarshalByValueComponent"]/*' />
    /// <devdoc>
    /// <para>Provides the base implementation for <see cref='System.ComponentModel.IComponent'/>,
    ///    which is the base class for all components in Win Forms.</para>
    /// </devdoc>
    [
        Designer("System.Windows.Forms.Design.ComponentDocumentDesigner, " + AssemblyRef.SystemDesign, typeof(IRootDesigner)),
        DesignerCategory("Component"),
        TypeConverter(typeof(ComponentConverter))
    ]
    public class MarshalByValueComponent : IComponent, IServiceProvider {

        /// <devdoc>
        ///    <para>Static hask key for the Disposed event. This field is read-only.</para>
        /// </devdoc>
        private static readonly object EventDisposed = new object(); 

        private ISite site;
        private EventHandlerList events;

        /// <include file='doc\MarshalByValueComponent.uex' path='docs/doc[@for="MarshalByValueComponent.MarshalByValueComponent"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.MarshalByValueComponent'/> class.</para>
        /// </devdoc>
        public MarshalByValueComponent() {
        }

        /// <include file='doc\MarshalByValueComponent.uex' path='docs/doc[@for="MarshalByValueComponent.Finalize"]/*' />
        ~MarshalByValueComponent() {
            Dispose(false);
        }

        /// <include file='doc\MarshalByValueComponent.uex' path='docs/doc[@for="MarshalByValueComponent.Disposed"]/*' />
        /// <devdoc>
        ///    <para>Adds a event handler to listen to the Disposed event on the component.</para>
        /// </devdoc>
        public event EventHandler Disposed {
            add {
                Events.AddHandler(EventDisposed, value);
            }
            remove {
                Events.RemoveHandler(EventDisposed, value);
            }
        }

        /// <include file='doc\MarshalByValueComponent.uex' path='docs/doc[@for="MarshalByValueComponent.Events"]/*' />
        /// <devdoc>
        ///    <para>Gets the list of event handlers that are attached to this component.</para>
        /// </devdoc>
        protected EventHandlerList Events {
            get {
                if (events == null) {
                    events = new EventHandlerList();
                }
                return events;
            }
        }

        /// <include file='doc\MarshalByValueComponent.uex' path='docs/doc[@for="MarshalByValueComponent.Site"]/*' />
        /// <devdoc>
        ///    <para>Gets or sets the site of the component.</para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public virtual ISite Site {
            get { return site;}
            set { site = value;}
        }

        /// <include file='doc\MarshalByValueComponent.uex' path='docs/doc[@for="MarshalByValueComponent.Dispose"]/*' />
        /// <devdoc>
        ///    <para>Disposes of the resources (other than memory) used by the component.</para>
        /// </devdoc>
        public void Dispose() {
            Dispose(true);
            GC.SuppressFinalize(this);
        }

        /// <include file='doc\MarshalByValueComponent.uex' path='docs/doc[@for="MarshalByValueComponent.Dispose2"]/*' />
        /// <devdoc>
        ///    <para>
        ///    Disposes all the resources associated with this component.
        ///    If disposing is false then you must never touch any other
        ///    managed objects, as they may already be finalized. When
        ///    in this state you should dispose any native resources
        ///    that you have a reference to.
        ///    </para>
        ///    <para>
        ///    When disposing is true then you should dispose all data
        ///    and objects you have references to. The normal implementation
        ///    of this method would look something like:
        ///    </para>
        ///    <code>
        ///    public void Dispose() {
        ///        Dispose(true);
        ///        GC.SuppressFinalize(this);
        ///    }
        ///
        ///    protected virtual void Dispose(bool disposing) {
        ///        if (disposing) {
        ///            if (myobject != null) {
        ///                myobject.Dispose();
        ///                myobject = null;
        ///            }
        ///        }
        ///        if (myhandle != IntPtr.Zero) {
        ///            NativeMethods.Release(myhandle);
        ///            myhandle = IntPtr.Zero;
        ///        }
        ///    }
        ///
        ///    ~MyClass() {
        ///        Dispose(false);
        ///    }
        ///    </code>
        ///    <para>
        ///    For base classes, you should never override the Finalier (~Class in C#)
        ///    or the Dispose method that takes no arguments, rather you should
        ///    always override the Dispose method that takes a bool. 
        ///    </para>
        ///    <code>
        ///    protected override void Dispose(bool disposing) {
        ///        if (disposing) {
        ///            if (myobject != null) {
        ///                myobject.Dispose();
        ///                myobject = null;
        ///            }
        ///        }
        ///        if (myhandle != IntPtr.Zero) {
        ///            NativeMethods.Release(myhandle);
        ///            myhandle = IntPtr.Zero;
        ///        }
        ///        base.Dispose(disposing);
        ///    }
        ///    </code>
        /// </devdoc>
        protected virtual void Dispose(bool disposing) {
            if (disposing) {
                lock(this) {
                    if (site != null && site.Container != null) {
                        site.Container.Remove(this);
                    }
                    if (events != null) {
                        EventHandler handler = (EventHandler)events[EventDisposed];
                        if (handler != null) handler(this, EventArgs.Empty);
                    }
                }
            }
        }

        /// <include file='doc\MarshalByValueComponent.uex' path='docs/doc[@for="MarshalByValueComponent.Container"]/*' />
        /// <devdoc>
        ///    <para>Gets the container for the component.</para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public virtual IContainer Container {
            get {
                ISite s = site;
                return s == null ? null : s.Container;
            }
        }

        /// <include file='doc\MarshalByValueComponent.uex' path='docs/doc[@for="MarshalByValueComponent.GetService"]/*' />
        /// <devdoc>
        /// <para>Gets the implementer of the <see cref='System.IServiceProvider'/>.</para>
        /// </devdoc>
        public virtual object GetService(Type service) {
            return((site==null)? null : site.GetService(service));
        }


        /// <include file='doc\MarshalByValueComponent.uex' path='docs/doc[@for="MarshalByValueComponent.DesignMode"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the component is currently in design mode.</para>
        /// </devdoc>
        [Browsable(false), DesignerSerializationVisibility(DesignerSerializationVisibility.Hidden)]
        public virtual bool DesignMode {
            get {
                ISite s = site;
                return(s == null) ? false : s.DesignMode;
            }
        }
        /// <include file='doc\Component.uex' path='docs/doc[@for="Component.ToString"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Returns a <see cref='System.String'/> containing the name of the <see cref='System.ComponentModel.Component'/> , if any. This method should not be
        ///       overridden. For
        ///       internal use only.
        ///    </para>
        /// </devdoc>
        public override String ToString() {
            ISite s = site;

            if (s != null)
                return s.Name + " [" + GetType().FullName + "]";
            else
                return GetType().FullName;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\mergablepropertyattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="MergablePropertyAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.ComponentModel;

    using System.Diagnostics;

    using System;

    /// <include file='doc\MergablePropertyAttribute.uex' path='docs/doc[@for="MergablePropertyAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies that
    ///       this property can be combined with properties belonging to
    ///       other objects in a properties window.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public sealed class MergablePropertyAttribute : Attribute {
    
        /// <include file='doc\MergablePropertyAttribute.uex' path='docs/doc[@for="MergablePropertyAttribute.Yes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that a property can be combined with properties belonging to other
        ///       objects in a properties window. This <see langword='static '/>field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly MergablePropertyAttribute Yes = new MergablePropertyAttribute(true);
        
        /// <include file='doc\MergablePropertyAttribute.uex' path='docs/doc[@for="MergablePropertyAttribute.No"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that a property cannot be combined with properties belonging to
        ///       other objects in a properties window. This <see langword='static '/>field is
        ///       read-only.
        ///    </para>
        /// </devdoc>
        public static readonly MergablePropertyAttribute No = new MergablePropertyAttribute(false);
        
        /// <include file='doc\MergablePropertyAttribute.uex' path='docs/doc[@for="MergablePropertyAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the default value, which is <see cref='System.ComponentModel.MergablePropertyAttribute.Yes'/>, that is a property can be combined with
        ///       properties belonging to other objects in a properties window. This <see langword='static '/>field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly MergablePropertyAttribute Default = Yes;
        
        private bool allowMerge;
        
        /// <include file='doc\MergablePropertyAttribute.uex' path='docs/doc[@for="MergablePropertyAttribute.MergablePropertyAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.MergablePropertyAttribute'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public MergablePropertyAttribute(bool allowMerge) {
            this.allowMerge = allowMerge;
        }

        /// <include file='doc\MergablePropertyAttribute.uex' path='docs/doc[@for="MergablePropertyAttribute.AllowMerge"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether this
        ///       property can be combined with properties belonging to other objects in a
        ///       properties window.
        ///    </para>
        /// </devdoc>
        public bool AllowMerge {
            get {
                return allowMerge;
            }
        }
        
        /// <include file='doc\MergablePropertyAttribute.uex' path='docs/doc[@for="MergablePropertyAttribute.Equals"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            MergablePropertyAttribute other = obj as MergablePropertyAttribute;
            return other != null && other.AllowMerge == this.allowMerge;
        }
        
        /// <include file='doc\MergablePropertyAttribute.uex' path='docs/doc[@for="MergablePropertyAttribute.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the hashcode for this object.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

        /// <include file='doc\MergablePropertyAttribute.uex' path='docs/doc[@for="MergablePropertyAttribute.IsDefaultAttribute"]/*' />
        /// <devdoc>
        /// </devdoc>
        /// <internalonly/>
        public override bool IsDefaultAttribute() {
            return (this.Equals(Default));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\propertychangedeventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyChangedEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    

    using System.Diagnostics;
    using System;


    /// <include file='doc\PropertyChangedEventArgs.uex' path='docs/doc[@for="PropertyChangedEventArgs"]/*' />
    /// <devdoc>
    /// <para>Provides data for the <see langword='PropertyChanged'/>
    /// event.</para>
    /// </devdoc>
    public class PropertyChangedEventArgs : EventArgs {
        private readonly string propertyName;

        /// <include file='doc\PropertyChangedEventArgs.uex' path='docs/doc[@for="PropertyChangedEventArgs.PropertyChangedEventArgs"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.PropertyChangedEventArgs'/>
        /// class.</para>
        /// </devdoc>
        public PropertyChangedEventArgs(string propertyName) {
            this.propertyName = propertyName;
        }

        /// <include file='doc\PropertyChangedEventArgs.uex' path='docs/doc[@for="PropertyChangedEventArgs.PropertyName"]/*' />
        /// <devdoc>
        ///    <para>Indicates the name of the property that changed.</para>
        /// </devdoc>
        public virtual string PropertyName {
            get {
                return propertyName;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\memberdescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="MemberDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {


    using System.Diagnostics;

    using System;
    using System.Reflection;
    using System.Collections;
    using Microsoft.Win32;
    using System.ComponentModel.Design;

    /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Declares an array of attributes for a member and defines
    ///       the properties and methods that give you access to the attributes in the array.
    ///       All attributes must derive from <see cref='System.Attribute'/>.
    ///    </para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public abstract class MemberDescriptor {
        private string name;
        private string displayName;
        private int nameHash;
        private AttributeCollection attributeCollection;
        private Attribute[] attributes;
        private bool attributesFiltered = false;
        private bool attributesFilled = false;
        private string category;
        private string description;


        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.MemberDescriptor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.MemberDescriptor'/> class with the specified <paramref name="name
        ///       "/> and no
        ///       attributes.
        ///    </para>
        /// </devdoc>
        protected MemberDescriptor(string name) : this(name, null) {
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.MemberDescriptor1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.MemberDescriptor'/> class with the specified <paramref name="name"/>
        ///       and <paramref name="attributes "/>
        ///       array.
        ///    </para>
        /// </devdoc>
        protected MemberDescriptor(string name, Attribute[] attributes) {
            try {
                if (name == null || name.Length == 0) {
                    throw new ArgumentException(SR.GetString(SR.InvalidMemberName));
                }
                this.name = name;
                this.displayName = name;
                this.nameHash = name.GetHashCode();
                if (attributes != null) {
                    this.attributes = attributes;
                    attributesFiltered = false;
                }

            }
            catch (Exception t) {
                Debug.Fail(t.ToString());
                throw t;
            }
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.MemberDescriptor2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.MemberDescriptor'/> class with the specified <see cref='System.ComponentModel.MemberDescriptor'/>.
        ///    </para>
        /// </devdoc>
        protected MemberDescriptor(MemberDescriptor descr) {
            this.name = descr.Name;
            this.displayName = this.name;
            this.nameHash = name.GetHashCode();
            
            this.attributes = new Attribute[descr.Attributes.Count];
            descr.Attributes.CopyTo(this.attributes, 0);
            
            attributesFiltered = true;
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.MemberDescriptor3"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.MemberDescriptor'/> class with the name in the specified
        ///    <see cref='System.ComponentModel.MemberDescriptor'/> and the attributes 
        ///       in both the old <see cref='System.ComponentModel.MemberDescriptor'/> and the <see cref='System.Attribute'/> array.
        ///    </para>
        /// </devdoc>
        protected MemberDescriptor(MemberDescriptor oldMemberDescriptor, Attribute[] newAttributes) {
            this.name = oldMemberDescriptor.Name;
            this.displayName = oldMemberDescriptor.DisplayName;
            this.nameHash = name.GetHashCode();

            ArrayList newArray = new ArrayList();

            if (oldMemberDescriptor.Attributes.Count != 0) {
                foreach (object o in oldMemberDescriptor.Attributes) {
                    newArray.Add(o);
                }
            }

            if (newAttributes != null) {
                foreach (object o in newAttributes) {
                    newArray.Add(o);
                }
            }

            this.attributes = new Attribute[ newArray.Count ];
            newArray.CopyTo( this.attributes, 0);
            attributesFiltered = false;
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.AttributeArray"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets or sets an array of
        ///       attributes.
        ///    </para>
        /// </devdoc>
        protected virtual Attribute[] AttributeArray {
            get {
                FilterAttributesIfNeeded();
                return attributes;
            }
            set {
                lock(this) {
                    attributes = value;
                    attributesFiltered = false;
                    attributeCollection = null;
                }
            }
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.Attributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the collection of attributes for this member.
        ///    </para>
        /// </devdoc>
        public virtual AttributeCollection Attributes {
            get {
                if (attributeCollection == null) {
                    attributeCollection = CreateAttributeCollection();
                }
                return attributeCollection;
            }
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.Category"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the category that the
        ///       member
        ///       belongs to, as specified in the <see cref='System.ComponentModel.CategoryAttribute'/>.
        ///    </para>
        /// </devdoc>
        public virtual string Category {
            get {
                if (category == null) {
                    category = ((CategoryAttribute)Attributes[typeof(CategoryAttribute)]).Category;
                }
                return category;
            }
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.Description"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the description of
        ///       the member as specified in the <see cref='System.ComponentModel.DescriptionAttribute'/>.
        ///    </para>
        /// </devdoc>
        public virtual string Description {
            get {
                if (description == null) {
                    description = ((DescriptionAttribute) Attributes[typeof(DescriptionAttribute)]).Description;
                }
                return description;
            }
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.IsBrowsable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the member is browsable as specified in the
        ///    <see cref='System.ComponentModel.BrowsableAttribute'/>. 
        ///    </para>
        /// </devdoc>
        public virtual bool IsBrowsable {
            get {
                return((BrowsableAttribute)Attributes[typeof(BrowsableAttribute)]).Browsable;
            }
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.Name"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the
        ///       name of the member.
        ///    </para>
        /// </devdoc>
        public virtual string Name {
            get {
                if (name == null) {
                    return "";
                }
                return name;
            }
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.NameHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the hash
        ///       code for the name of the member as specified in <see cref='System.String.GetHashCode'/>.
        ///    </para>
        /// </devdoc>
        protected virtual int NameHashCode {
            get {
                return nameHash;
            }
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.DesignTimeOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Determines whether this member should be set only at
        ///       design time as specified in the <see cref='System.ComponentModel.DesignOnlyAttribute'/>.
        ///    </para>
        /// </devdoc>
        public virtual bool DesignTimeOnly {
            get {
                return(DesignOnlyAttribute.Yes.Equals(Attributes[typeof(DesignOnlyAttribute)]));
            }
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.DisplayName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name that can be displayed in a window like a
        ///       properties window.
        ///    </para>
        /// </devdoc>
        public virtual string DisplayName {
            get {
                return displayName;
            }
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.CreateAttributeCollection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates a collection of attributes using the
        ///       array of attributes that you passed to the constructor.
        ///    </para>
        /// </devdoc>
        protected virtual AttributeCollection CreateAttributeCollection() {
            return new AttributeCollection(AttributeArray);
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compares this instance to the specified <see cref='System.ComponentModel.MemberDescriptor'/> to see if they are equivalent.
        ///    </para>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null) {
                return false;
            }

            if (obj.GetType() != GetType()) {
                return false;
            }

            MemberDescriptor mdObj = (MemberDescriptor)obj;
            FilterAttributesIfNeeded();
            mdObj.FilterAttributesIfNeeded();

            if (mdObj.nameHash != nameHash) {
                return false;
            }

            if ((mdObj.category == null) != (category == null) ||
                (category != null && !mdObj.category.Equals(category))) {
                return false;
            }

            if ((mdObj.description == null) != (description == null) ||
                (description != null && !mdObj.category.Equals(description))) {
                return false;
            }

            if ((mdObj.attributes == null) != (attributes == null)) {
                return false;
            }
                                                
            bool sameAttrs = true;

            if (attributes != null) {
                if (attributes.Length != mdObj.attributes.Length) {
                    return false;
                }
                for (int i = 0; i < attributes.Length; i++) {
                    if (!attributes[i].Equals(mdObj.attributes[i])) {
                        sameAttrs = false;
                        break;
                    }
                }
            }
            return sameAttrs;
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.FillAttributes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       In an inheriting class, adds the attributes of the inheriting class to the
        ///       specified list of attributes in the parent class.  For duplicate attributes,
        ///       the last one added to the list will be kept.
        ///    </para>
        /// </devdoc>
        protected virtual void FillAttributes(IList attributeList) {
            if (attributes != null) {
                foreach (Attribute attr in attributes) {
                    attributeList.Add(attr);
                }
            }
        }

        private void FilterAttributesIfNeeded() {
            if (!attributesFiltered) {
                IList list;

                if (!attributesFilled) {
                    list = new ArrayList();
                    try {
                        FillAttributes(list);
                    }
                    catch(Exception e) {
                        Debug.Fail(name + ">>" + e.ToString()); 
                    }
                }
                else {
                    list = new ArrayList(attributes);
                }

                Hashtable hash = new Hashtable(list.Count);

                foreach (Attribute attr in list) {
                    hash[attr.TypeId] = attr;
                }

                Attribute[] newAttributes = new Attribute[hash.Values.Count];
                hash.Values.CopyTo(newAttributes, 0);

                lock(this) {
                    attributes = newAttributes;
                    attributesFiltered = true;
                    attributesFilled = true;
                }
            }
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.FindMethod"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Finds the given method through reflection.  This method only looks for public methods.
        ///    </para>
        /// </devdoc>
        protected static MethodInfo FindMethod(Type componentClass, string name, Type[] args, Type returnType) {
            return FindMethod(componentClass, name, args, returnType, true);
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.FindMethod1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Finds the given method through reflection.
        ///    </para>
        /// </devdoc>
        protected static MethodInfo FindMethod(Type componentClass, string name, Type[] args, Type returnType, bool publicOnly) {
            MethodInfo result = null;

            // Guard against the caller fishing around in internal types.  There is only a security issue if the type is in our assembly
            // because if it's not reflection will do a demand for us.
            //
            if ((!(componentClass.IsPublic || componentClass.IsNestedPublic)) && (componentClass.Assembly == typeof(MemberDescriptor).Assembly)) {
                IntSecurity.FullReflection.Demand();
            }

            if (publicOnly) {
                result = componentClass.GetMethod(name, args);
            }
            else {
                result = componentClass.GetMethod(name, BindingFlags.Instance | BindingFlags.Static | BindingFlags.Public | BindingFlags.NonPublic, null, args, null);
            }
            if (result != null && result.ReturnType != returnType) {
                result = null;
            }
            return result;
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the hashcode for this object.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.GetSite"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a component site
        ///       for the given component.
        ///    </para>
        /// </devdoc>
        protected static ISite GetSite(object component) {
            if (!(component is IComponent)) {
                return null;
            }

            return((IComponent)component).Site;
        }

        /// <include file='doc\MemberDescriptor.uex' path='docs/doc[@for="MemberDescriptor.GetInvokee"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets
        ///       the component
        ///       that a method should be invoked on.
        ///    </para>
        /// </devdoc>
        protected static object GetInvokee(Type componentClass, object component) {

            // We delve into the component's designer only if it is a component and if
            // the component we've been handed is not an instance of this property type.
            //
            if (!componentClass.IsInstanceOfType(component) && component is IComponent) {
                ISite site = ((IComponent)component).Site;
                if (site != null && site.DesignMode) {
                    IDesignerHost host = (IDesignerHost)site.GetService(typeof(IDesignerHost));
                    if (host != null) {
                        object designer = host.GetDesigner((IComponent)component);

                        // We only use the designer if it has a compatible class.  If we
                        // got here, we're probably hosed because the user just passed in
                        // an object that this PropertyDescriptor can't munch on, but it's
                        // clearer to use that object instance instead of it's designer.
                        //
                        if (designer != null && componentClass.IsInstanceOfType(designer)) {
                            component = designer;
                        }
                    }
                }
            }

            Debug.Assert(component != null, "Attempt to invoke on null component");
            return component;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\propertydescriptorcollection.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyDescriptorCollection.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.InteropServices;
    

    using System.Diagnostics;

    using Microsoft.Win32;
    using System.Collections.Specialized;
    using System.Collections;
    using System.Globalization;

    /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Represents a collection of properties.
    ///    </para>
    /// </devdoc>
    public class PropertyDescriptorCollection : ICollection, IList, IDictionary {
    
    
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.Empty"]/*' />
        /// <devdoc>
        /// An empty PropertyDescriptorCollection that can used instead of creating a new one with no items.
        /// </devdoc>
        public static readonly PropertyDescriptorCollection Empty = new PropertyDescriptorCollection(null, true);

        private IDictionary          cachedFoundProperties;
        private bool                 cachedIgnoreCase;
        private PropertyDescriptor[] properties;
        private int                  propCount = 0;
        private string[]             namedSort;
        private IComparer            comparer;
        private bool                 propsOwned = true;
        private bool                 needSort = false;
        private bool                 readOnly = false;

        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.PropertyDescriptorCollection"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.PropertyDescriptorCollection'/>
        ///       class.
        ///    </para>
        /// </devdoc>
        public PropertyDescriptorCollection(PropertyDescriptor[] properties) {
            this.properties = properties;
            if (properties == null) {
                this.properties = new PropertyDescriptor[0];
                this.propCount = 0;
            }
            else {
                this.propCount = properties.Length;
            }
            this.propsOwned = true;
        }

        internal PropertyDescriptorCollection(PropertyDescriptor[] properties, bool readOnly) : this(properties) {
            this.readOnly = readOnly;
        }
        
        private PropertyDescriptorCollection(PropertyDescriptor[] properties, int propCount, string[] namedSort, IComparer comparer) {
            this.propsOwned = false;
            if (namedSort != null) {
               this.namedSort = (string[])namedSort.Clone();
            }
            this.comparer = comparer;
            this.properties = properties;
            this.propCount = propCount;
            this.needSort = true;
        }

        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.Count"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the number
        ///       of property descriptors in the
        ///       collection.
        ///    </para>
        /// </devdoc>
        public int Count {
            get {
                return propCount;
            }
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.this"]/*' />
        /// <devdoc>
        ///    <para>Gets the property with the specified index
        ///       number.</para>
        /// </devdoc>
        public virtual PropertyDescriptor this[int index] {
            get {
                if (index >= propCount) {
                    throw new IndexOutOfRangeException();
                }
                EnsurePropsOwned();
                return properties[index];
            }
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IList.this"]/*' />
        /// <internalonly/>
        object IList.this[int index] {
            get {
                return this[index];
            }
            set {
                if (readOnly) {
                    throw new NotSupportedException();
                }

                if (index >= propCount) {
                    throw new IndexOutOfRangeException();
                }


                if (value != null && !(value is PropertyDescriptor)) {
                    throw new ArgumentException("value");
                }

                EnsurePropsOwned();
                properties[index] = (PropertyDescriptor)value;
            }
        }

        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.this1"]/*' />
        /// <devdoc>
        ///    <para>Gets the property with the specified name.</para>
        /// </devdoc>
        public virtual PropertyDescriptor this[string name] {
            get {
                return Find(name, false);
            }
        }
       
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.Add"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int Add(PropertyDescriptor value) {
            if (readOnly) {
                throw new NotSupportedException();
            }

            EnsureSize(propCount + 1);
            properties[propCount++] = value;
            return propCount - 1;
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.Clear"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Clear() {
            if (readOnly) {
                throw new NotSupportedException();
            }

            propCount = 0;
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.Contains"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public bool Contains(PropertyDescriptor value) {
            return IndexOf(value) >= 0;
        }
        
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IndexOf"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public int IndexOf(PropertyDescriptor value) {
            return Array.IndexOf(properties, value, 0, propCount);
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.Insert"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Insert(int index, PropertyDescriptor value) {
            if (readOnly) {
                throw new NotSupportedException();
            }

            EnsureSize(propCount + 1);
            if (index < propCount) {
                Array.Copy(properties, index, properties, index + 1, propCount - index);   
            }
            properties[index] = value;
            propCount++;
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.Remove"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void Remove(PropertyDescriptor value) {
            if (readOnly) {
                throw new NotSupportedException();
            }

            int index = IndexOf(value);
            
            if (index != -1) {
                RemoveAt(index);
            }
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.RemoveAt"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void RemoveAt(int index) {
            if (readOnly) {
                throw new NotSupportedException();
            }

            if (index < propCount - 1) {
                  Array.Copy(properties, index + 1, properties, index, propCount - index);
            }
            propCount--;
        }

        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.Sort"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sorts the members of this PropertyDescriptorCollection, using the default sort for this collection, 
        ///       which is usually alphabetical.
        ///    </para>
        /// </devdoc>
        public virtual PropertyDescriptorCollection Sort() {
            return new PropertyDescriptorCollection(this.properties, this.propCount, this.namedSort, this.comparer);
        }
        

        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.Sort1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sorts the members of this PropertyDescriptorCollection.  Any specified NamedSort arguments will 
        ///       be applied first, followed by sort using the specified IComparer.
        ///    </para>
        /// </devdoc>
        public virtual PropertyDescriptorCollection Sort(string[] names) {
            return new PropertyDescriptorCollection(this.properties, this.propCount, names, this.comparer);
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.Sort2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sorts the members of this PropertyDescriptorCollection.  Any specified NamedSort arguments will 
        ///       be applied first, followed by sort using the specified IComparer.
        ///    </para>
        /// </devdoc>
        public virtual PropertyDescriptorCollection Sort(string[] names, IComparer comparer) {
            return new PropertyDescriptorCollection(this.properties, this.propCount, names, comparer);
        }
        
         /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.Sort3"]/*' />
         /// <devdoc>
        ///    <para>
        ///       Sorts the members of this PropertyDescriptorCollection, using the specified IComparer to compare, 
        ///       the PropertyDescriptors contained in the collection.
        ///    </para>
        /// </devdoc>
        public virtual PropertyDescriptorCollection Sort(IComparer comparer) {
            return new PropertyDescriptorCollection(this.properties, this.propCount, this.namedSort, comparer);
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.InternalSort"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sorts the members of this PropertyDescriptorCollection.  Any specified NamedSort arguments will 
        ///       be applied first, followed by sort using the specified IComparer.
        ///    </para>
        /// </devdoc>
        protected void InternalSort(string[] names) {
            if (properties == null || properties.Length == 0) {
                return;
            }  
            
            this.InternalSort(this.comparer);
            
            if (names != null && names.Length > 0) {
            
               ArrayList propArrayList = new ArrayList(properties);
               int foundCount = 0;
               int propCount = properties.Length;
               
               for (int i = 0; i < names.Length; i++) {
                    for (int j = 0; j < propCount; j++) {
                        PropertyDescriptor currentProp = (PropertyDescriptor)propArrayList[j];
                        
                        // Found a matching property.  Here, we add it to our array.  We also
                        // mark it as null in our array list so we don't add it twice later.
                        //
                        if (currentProp != null && currentProp.Name.Equals(names[i])) {
                            properties[foundCount++] = currentProp;
                            propArrayList[j] = null;
                            break;
                        }
                    }
               }
                
               // At this point we have filled in the first "foundCount" number of propeties, one for each
               // name in our name array.  If a name didn't match, then it is ignored.  Next, we must fill
               // in the rest of the properties.  We now have a sparse array containing the remainder, so
               // it's easy.
               //
               for (int i = 0; i < propCount; i++) {
                   if (propArrayList[i] != null) {
                       properties[foundCount++] = (PropertyDescriptor)propArrayList[i];
                   }
               }
               
               Debug.Assert(foundCount == propCount, "We did not completely fill our property array");
            }
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.InternalSort1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Sorts the members of this PropertyDescriptorCollection using the specified IComparer.
        ///    </para>
        /// </devdoc>
        protected void InternalSort(IComparer sorter) {
            if (sorter == null) {
                TypeDescriptor.SortDescriptorArray(this);
            }
            else {
                Array.Sort(properties, sorter);
            }
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IList.Add"]/*' />
        /// <internalonly/>
        int IList.Add(object value) {
            return Add((PropertyDescriptor)value);
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IList.Clear"]/*' />
        /// <internalonly/>
        void IList.Clear() {
            Clear();
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IList.Contains"]/*' />
        /// <internalonly/>
        bool IList.Contains(object value) {
            return Contains((PropertyDescriptor)value);
        }
        
        private void EnsurePropsOwned() {
            if (!propsOwned) {
               propsOwned = true;
               if (properties != null) {
                  PropertyDescriptor[] newProps = new PropertyDescriptor[propCount];
                  Array.Copy(properties, 0, newProps, 0, propCount);
                  this.properties = newProps;
               }
            }
        
            if (needSort) {
               needSort = false;
               InternalSort(this.namedSort);
            }
        }
        
        private void EnsureSize(int sizeNeeded) {
            
            if (sizeNeeded <= properties.Length) {
               return;
            }
            
            if (properties == null || properties.Length == 0) {
                propCount = 0;
                properties = new PropertyDescriptor[sizeNeeded];
                return;
            }
            
            EnsurePropsOwned();
            
            int newSize = Math.Max(sizeNeeded, properties.Length * 2);
            PropertyDescriptor[] newProps = new PropertyDescriptor[newSize];
            Array.Copy(properties, 0, newProps, 0, propCount);
            properties = newProps;
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.Find"]/*' />
        /// <devdoc>
        ///    <para>Gets the description of the property with the specified
        ///       name.</para>
        /// </devdoc>
        public virtual PropertyDescriptor Find(string name, bool ignoreCase) {
            lock(this) {
                PropertyDescriptor p = null;

                if (cachedFoundProperties == null || cachedIgnoreCase != ignoreCase) {
                    cachedIgnoreCase = ignoreCase;
                    cachedFoundProperties = new HybridDictionary(ignoreCase);
                }
                
                // first try to find it in the cache
                //
                object cached = cachedFoundProperties[name];
                
                if (cached != null) {
                    return (PropertyDescriptor) cached;
                }
                
                // Now start walking from where we last left off, filling
                // the cache as we go.
                //
                for(int i = 0; i < propCount; i++) {
                    
                    if (ignoreCase) {
                        if (String.Compare(properties[i].Name, name, ignoreCase, CultureInfo.InvariantCulture) == 0) {
                            cachedFoundProperties[name] = properties[i];
                            p = properties[i];
                            break;
                        }
                    }
                    else {
                        if (properties[i].Name.Equals(name)) {
                            cachedFoundProperties[name] = properties[i];
                            p = properties[i];
                            break;
                        }
                    }
                }
                
                return p;
            }
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.GetEnumerator"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an enumerator for this <see cref='System.ComponentModel.PropertyDescriptorCollection'/>.
        ///    </para>
        /// </devdoc>
        public virtual IEnumerator GetEnumerator() {
            EnsurePropsOwned();
            // we can only return an enumerator on the props we actually have...
            if (properties.Length != this.propCount) {
                PropertyDescriptor[] enumProps = new PropertyDescriptor[propCount];
                Array.Copy(properties, 0, enumProps, 0, propCount);
                return enumProps.GetEnumerator();
            }
            return properties.GetEnumerator();
        }

        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IDictionary.Add"]/*' />
        /// <internalonly/>
        void IDictionary.Add(object key, object value) {
            PropertyDescriptor newProp = value as PropertyDescriptor;

            if (newProp == null) {
                throw new ArgumentException("value");
            }
            Add(newProp);
        }

        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IDictionary.Clear"]/*' />
        /// <internalonly/>
        void IDictionary.Clear() {
            Clear();
        }

        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IDictionary.Contains"]/*' />
        /// <internalonly/>
        bool IDictionary.Contains(object key) {
            if (key is string) {
                return this[(string)key] != null;
            }
            return false;
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IDictionary.GetEnumerator"]/*' />
        /// <internalonly/>
        IDictionaryEnumerator IDictionary.GetEnumerator() {
            return new PropertyDescriptorEnumerator(this);
        }

         /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IDictionary.IsFixedSize"]/*' />
         /// <internalonly/>
         bool IDictionary.IsFixedSize {
            get {
                return !readOnly;
            }
        }

        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IDictionary.IsReadOnly"]/*' />
        /// <internalonly/>
        bool IDictionary.IsReadOnly {
            get {
                return readOnly;
            }
        }

        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IDictionary.this"]/*' />
        /// <internalonly/>
        object IDictionary.this[object key] {
            get {
                if (key is string) {
                    return this[(string)key];
                }
                return null;
            }

            set {
                if (readOnly) {
                    throw new NotSupportedException();
                }

                if (value != null && !(value is PropertyDescriptor)) {
                    throw new ArgumentException("value");
                }

                int index = -1;

                if (key is int) {
                    index = (int)key;

                    if (index < 0 || index >= propCount) {
                        throw new IndexOutOfRangeException();
                    }
                }
                else if (key is string) {
                    for (int i = 0; i < propCount; i++) {
                        if (properties[i].Name.Equals((string)key)) {
                            index = i;
                            break;
                        }
                    }
                }
                else {
                    throw new ArgumentException("key");
                }

                if (index == -1) {
                    Add((PropertyDescriptor)value);
                }
                else {
                    EnsurePropsOwned();
                    properties[index] = (PropertyDescriptor)value;
                    if (cachedFoundProperties != null && key is string) {
                        cachedFoundProperties[key] = value;
                    }
                }
            }
        }

        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IDictionary.Keys"]/*' />
        /// <internalonly/>
        ICollection IDictionary.Keys {
            get {
                string[] keys = new string[propCount];
                for (int i = 0; i < propCount ;i++) {
                    keys[i] = properties[i].Name;
                }
                return keys;
            }
        }

        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IDictionary.Values"]/*' />
        /// <internalonly/>
        ICollection IDictionary.Values {
            get {
                // we can only return an enumerator on the props we actually have...
                //
                if (properties.Length != this.propCount) {
                    PropertyDescriptor[] newProps = new PropertyDescriptor[propCount];
                    Array.Copy(properties, 0, newProps, 0, propCount);
                    return newProps;
                }
                else {
                    return (ICollection)properties.Clone();
                }
            }
        }

        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IDictionary.Remove"]/*' />
        /// <internalonly/>
        void IDictionary.Remove(object key) {
            if (key is string) {
                PropertyDescriptor pd = this[(string)key];
                if (pd != null) {
                    ((IList)this).Remove(pd);
                }
            }
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IList.IndexOf"]/*' />
        /// <internalonly/>
        int IList.IndexOf(object value) {
            return IndexOf((PropertyDescriptor)value);
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IList.Insert"]/*' />
        /// <internalonly/>
        void IList.Insert(int index, object value) {
            Insert(index, (PropertyDescriptor)value);
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IList.Remove"]/*' />
        /// <internalonly/>
        void IList.Remove(object value) {
            Remove((PropertyDescriptor)value);
        }
        
        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IList.RemoveAt"]/*' />
        /// <internalonly/>
        void IList.RemoveAt(int index) {
            RemoveAt(index);
        }

        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.ICollection.Count"]/*' />
        /// <internalonly/>
        int ICollection.Count {
            get {
                return Count;
            }
        }


        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IList.IsReadOnly"]/*' />
        /// <internalonly/>
        bool IList.IsReadOnly {
            get {
                return readOnly;
            }
        }

        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IList.IsFixedSize"]/*' />
        /// <internalonly/>
        bool IList.IsFixedSize {
            get {
                return !readOnly;
            }
        }

        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.ICollection.IsSynchronized"]/*' />
        /// <internalonly/>
        bool ICollection.IsSynchronized {
            get {
                return false;
            }
        }

        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.ICollection.SyncRoot"]/*' />
        /// <internalonly/>
        object ICollection.SyncRoot {
            get {
                return null;
            }
        }

        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.CopyTo"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public void CopyTo(Array array, int index) {
            EnsurePropsOwned();
            Array.Copy(properties, 0, array, index, Count);
        }

        /// <include file='doc\PropertyDescriptorCollection.uex' path='docs/doc[@for="PropertyDescriptorCollection.IEnumerable.GetEnumerator"]/*' />
        /// <internalonly/>
        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        private class PropertyDescriptorEnumerator : IDictionaryEnumerator {
            private PropertyDescriptorCollection owner;
            private int index;
            
            public PropertyDescriptorEnumerator(PropertyDescriptorCollection owner) {
                this.owner = owner;
            }

            public object Current {
                get{
                    return Entry;
                }
            }

            public DictionaryEntry Entry {
                get {
                    PropertyDescriptor curProp = owner[index];
                    return new DictionaryEntry(curProp.Name, curProp);
                }
            }

            public object Key {
                get {
                    return owner[index].Name;
                }
            }

            public object Value {
                get {
                    return owner[index].Name;
                }
            }

            public bool MoveNext() {
                if (index < (owner.Count - 1)) {
                    index++;
                    return true;
                }
                return false;
            }

            public void Reset() {
                index = 0;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\readonlyattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ReadOnlyAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    

    using System.Diagnostics;

    using System;

    /// <include file='doc\ReadOnlyAttribute.uex' path='docs/doc[@for="ReadOnlyAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies whether the property this attribute is bound to
    ///       is read-only or read/write.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.All)]
    public sealed class ReadOnlyAttribute : Attribute {
        private bool isReadOnly = false;

        /// <include file='doc\ReadOnlyAttribute.uex' path='docs/doc[@for="ReadOnlyAttribute.Yes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the property this attribute is bound to is read-only and
        ///       cannot be modified in the server explorer. This <see langword='static '/>field is
        ///       read-only.
        ///    </para>
        /// </devdoc>
        public static readonly ReadOnlyAttribute Yes = new ReadOnlyAttribute(true);

        /// <include file='doc\ReadOnlyAttribute.uex' path='docs/doc[@for="ReadOnlyAttribute.No"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that the property this attribute is bound to is read/write and can
        ///       be modified at design time. This <see langword='static '/>field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly ReadOnlyAttribute No = new ReadOnlyAttribute(false);

        /// <include file='doc\ReadOnlyAttribute.uex' path='docs/doc[@for="ReadOnlyAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the default value for the <see cref='System.ComponentModel.ReadOnlyAttribute'/> , which is <see cref='System.ComponentModel.ReadOnlyAttribute.No'/>, that is,
        ///       the property this attribute is bound to is read/write. This <see langword='static'/> field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly ReadOnlyAttribute Default = No;

        /// <include file='doc\ReadOnlyAttribute.uex' path='docs/doc[@for="ReadOnlyAttribute.ReadOnlyAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.ReadOnlyAttribute'/> class.
        ///    </para>
        /// </devdoc>
        public ReadOnlyAttribute(bool isReadOnly) {
            this.isReadOnly = isReadOnly;
        }

        /// <include file='doc\ReadOnlyAttribute.uex' path='docs/doc[@for="ReadOnlyAttribute.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether the property this attribute is bound to is
        ///       read-only.
        ///    </para>
        /// </devdoc>
        public bool IsReadOnly {
            get {
                return isReadOnly;
            }
        }

        /// <include file='doc\ReadOnlyAttribute.uex' path='docs/doc[@for="ReadOnlyAttribute.Equals"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override bool Equals(object value) {

            if (this == value) {
                return true;
            }

            ReadOnlyAttribute other = value as ReadOnlyAttribute;

            return other != null && other.IsReadOnly == IsReadOnly;
        }

        /// <include file='doc\ReadOnlyAttribute.uex' path='docs/doc[@for="ReadOnlyAttribute.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the hashcode for this object.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

        /// <include file='doc\ReadOnlyAttribute.uex' path='docs/doc[@for="ReadOnlyAttribute.IsDefaultAttribute"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>
        ///       Determines if this attribute is the default.
        ///    </para>
        /// </devdoc>
        public override bool IsDefaultAttribute() {
            return (this.IsReadOnly == Default.IsReadOnly);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\referenceconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="ReferenceConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;   
    using System.Diagnostics;
    using Microsoft.Win32;
    using System.Collections;
    using System.ComponentModel.Design;    
    using System.Globalization;

    /// <include file='doc\ReferenceConverter.uex' path='docs/doc[@for="ReferenceConverter"]/*' />
    /// <devdoc>
    ///    <para>Provides a type converter to convert object references to and from various
    ///       other representations.</para>
    /// </devdoc>
    public class ReferenceConverter : TypeConverter {
    
        private static readonly string none = SR.GetString(SR.toStringNone);
        private Type type;
        
        /// <include file='doc\ReferenceConverter.uex' path='docs/doc[@for="ReferenceConverter.ReferenceConverter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.ReferenceConverter'/> class.
        ///    </para>
        /// </devdoc>
        public ReferenceConverter(Type type) {
            this.type = type;
        }

        /// <include file='doc\ReferenceConverter.uex' path='docs/doc[@for="ReferenceConverter.CanConvertFrom"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can convert an object in the
        ///       given source type to a reference object using the specified context.</para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\ReferenceConverter.uex' path='docs/doc[@for="ReferenceConverter.ConvertFrom"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Converts the given object to the reference type.</para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
        
            if (value is string) {
                string text = ((string)value).Trim();
                
                if (!String.Equals(text, none) && context != null) {
                
                    // Try the reference service first.
                    //
                    IReferenceService refSvc = (IReferenceService)context.GetService(typeof(IReferenceService));
                    if (refSvc != null) {
                        object obj = refSvc.GetReference(text);
                        if (obj != null) {
                            return obj;
                        }
                    }
                    
                    // Now try IContainer
                    //
                    IContainer cont = context.Container;
                    if (cont != null) {
                        object obj = cont.Components[text];
                        if (obj != null) {
                            return obj;
                        }
                    }
                }
                return null;
                
            }
            return base.ConvertFrom(context, culture, value);
        }

        /// <include file='doc\ReferenceConverter.uex' path='docs/doc[@for="ReferenceConverter.ConvertTo"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Converts the given value object to the reference type
        ///       using the specified context and arguments.</para>
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(string)) {
            
                if (value != null) {
                    // Try the reference service first.
                    //
                    if (context != null) {
                        IReferenceService refSvc = (IReferenceService)context.GetService(typeof(IReferenceService));
                        if (refSvc != null) {
                            string name = refSvc.GetName(value);
                            if (name != null) {
                                return name;
                            }
                        }
                    }
                    
                    // Now see if this is an IComponent.
                    //
                    if (!Marshal.IsComObject(value) && value is IComponent) {
                        IComponent comp = (IComponent)value;
                        ISite site = comp.Site;
                        if (site != null) {
                            string name = site.Name;
                            if (name != null) {
                                return name;
                            }
                        }
                    }

                    // Couldn't find it.
                    return String.Empty;
                }
                return none;
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }

        /// <include file='doc\ReferenceConverter.uex' path='docs/doc[@for="ReferenceConverter.GetStandardValues"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a collection of standard values for the reference data type.</para>
        /// </devdoc>
        public override StandardValuesCollection GetStandardValues(ITypeDescriptorContext context) {
        
            object[] components = null;
            
            if (context != null) {
                ArrayList list = new ArrayList();
                list.Add(null);
            
                // Try the reference service first.
                //
                IReferenceService refSvc = (IReferenceService)context.GetService(typeof(IReferenceService));
                if (refSvc != null) {
                    object[] objs = refSvc.GetReferences(type);
                    int count = objs.Length;
                    
                    for (int i = 0; i < count; i++) {
                        if (IsValueAllowed(context, objs[i]))
                            list.Add(objs[i]);
                    }
                }
                else {
                
                    // Now try IContainer.
                    //
                    IContainer cont = context.Container;
                    if (cont != null) {
                        ComponentCollection objs = cont.Components;
                        
                        foreach(IComponent obj in objs) {
                            if (obj != null && type.IsInstanceOfType(obj) &&
                                IsValueAllowed(context, obj)) {
                                list.Add(obj);
                            }
                        }
                    }
                }

                components = list.ToArray();
                Array.Sort(components, 0, components.Length, new ReferenceComparer(this));
            }
                
            return new StandardValuesCollection(components);
        }
    
        /// <include file='doc\ReferenceConverter.uex' path='docs/doc[@for="ReferenceConverter.GetStandardValuesExclusive"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating whether the list of standard values returned from
        ///    <see cref='System.ComponentModel.ReferenceConverter.GetStandardValues'/> is an exclusive list. </para>
        /// </devdoc>
        public override bool GetStandardValuesExclusive(ITypeDescriptorContext context) {
            return true;
        }
        
        /// <include file='doc\ReferenceConverter.uex' path='docs/doc[@for="ReferenceConverter.GetStandardValuesSupported"]/*' />
        /// <internalonly/>
        /// <devdoc>
        ///    <para>Gets a value indicating whether this object supports a standard set of values
        ///       that can be picked from a list.</para>
        /// </devdoc>
        public override bool GetStandardValuesSupported(ITypeDescriptorContext context) {
            return true;
        }

        /// <include file='doc\ReferenceConverter.uex' path='docs/doc[@for="ReferenceConverter.IsValueAllowed"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether a particular value can be added to
        ///       the standard values collection.</para>
        /// </devdoc>
        protected virtual bool IsValueAllowed(ITypeDescriptorContext context, object value) {
            return true;
        }
        
        /// <include file='doc\ReferenceConverter.uex' path='docs/doc[@for="ReferenceConverter.ReferenceComparer"]/*' />
        /// <devdoc>
        ///      IComparer object used for sorting references
        /// </devdoc>
        private class ReferenceComparer : IComparer {
        
            private ReferenceConverter converter;
            
            public ReferenceComparer(ReferenceConverter converter) {
                this.converter = converter;
            }

            public int Compare(object item1, object item2) {

                String itemName1 = converter.ConvertToString(item1);
                String itemName2 = converter.ConvertToString(item2);

                return string.Compare(itemName1, itemName2, false, CultureInfo.InvariantCulture);
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\propertychangedeventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyChangedEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    

    using System.Diagnostics;

    using System;

    /// <include file='doc\PropertyChangedEventHandler.uex' path='docs/doc[@for="PropertyChangedEventHandler"]/*' />
    /// <devdoc>
    ///    <para>Represents the method that will handle the
    ///    <see langword='PropertyChanged'/> event raised when a
    ///       property is changed on a component.</para>
    /// </devdoc>
    public delegate void PropertyChangedEventHandler(object sender, PropertyChangedEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\providepropertyattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ProvidePropertyAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    

    using System.Diagnostics;

    using System;

    /// <include file='doc\ProvidePropertyAttribute.uex' path='docs/doc[@for="ProvidePropertyAttribute"]/*' />
    /// <devdoc>
    ///    <para> Specifies which methods are extender
    ///       properties.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class, AllowMultiple = true)]
    public sealed class ProvidePropertyAttribute : Attribute {
        private readonly string propertyName;
        private readonly string receiverTypeName;

        /// <include file='doc\ProvidePropertyAttribute.uex' path='docs/doc[@for="ProvidePropertyAttribute.ProvidePropertyAttribute"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.ProvidePropertyAttribute'/> class.</para>
        /// </devdoc>
        public ProvidePropertyAttribute(string propertyName, Type receiverType) {
            this.propertyName = propertyName;
            this.receiverTypeName = receiverType.AssemblyQualifiedName;
        }

        /// <include file='doc\ProvidePropertyAttribute.uex' path='docs/doc[@for="ProvidePropertyAttribute.ProvidePropertyAttribute1"]/*' />
        /// <devdoc>
        /// <para>Initializes a new instance of the <see cref='System.ComponentModel.ProvidePropertyAttribute'/> class.</para>
        /// </devdoc>
        public ProvidePropertyAttribute(string propertyName, string receiverTypeName) {
            this.propertyName = propertyName;
            this.receiverTypeName = receiverTypeName;
        }

        /// <include file='doc\ProvidePropertyAttribute.uex' path='docs/doc[@for="ProvidePropertyAttribute.PropertyName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of a property that this class provides.
        ///    </para>
        /// </devdoc>
        public string PropertyName {
            get {
                return propertyName;
            }
        }
        
        /// <include file='doc\ProvidePropertyAttribute.uex' path='docs/doc[@for="ProvidePropertyAttribute.ReceiverTypeName"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the name of the data type this property can extend
        ///    </para>
        /// </devdoc>
        public string ReceiverTypeName {
            get {
                return receiverTypeName;
            }
        }

        /// <include file='doc\ProvidePropertyAttribute.uex' path='docs/doc[@for="ProvidePropertyAttribute.TypeId"]/*' />
        /// <devdoc>
        ///    <para>ProvidePropertyAttribute overrides this to include the type name and the property name</para>
        /// </devdoc>
        public override object TypeId {
            get {
                return GetType().FullName + propertyName;
            }
        }

        /// <include file='doc\ProvidePropertyAttribute.uex' path='docs/doc[@for="ProvidePropertyAttribute.Equals"]/*' />
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            ProvidePropertyAttribute other = obj as ProvidePropertyAttribute;

            return (other != null) && other.propertyName == propertyName && other.receiverTypeName == receiverTypeName;
        }

        /// <include file='doc\ProvidePropertyAttribute.uex' path='docs/doc[@for="ProvidePropertyAttribute.GetHashCode"]/*' />
        public override int GetHashCode() {
            return propertyName.GetHashCode() ^ receiverTypeName.GetHashCode();
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\recommendedasconfigurableattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RecommendedAsConfigurableAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    

    using System.Diagnostics;

    using System;

    /// <include file='doc\RecommendedAsConfigurableAttribute.uex' path='docs/doc[@for="RecommendedAsConfigurableAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies that the property can be
    ///       used as an application setting.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Property)]
    public class RecommendedAsConfigurableAttribute : Attribute {
        private bool recommendedAsConfigurable = false;

        /// <include file='doc\RecommendedAsConfigurableAttribute.uex' path='docs/doc[@for="RecommendedAsConfigurableAttribute.RecommendedAsConfigurableAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of
        ///       the <see cref='System.ComponentModel.RecommendedAsConfigurableAttribute'/> class.
        ///    </para>
        /// </devdoc>
        public RecommendedAsConfigurableAttribute(bool recommendedAsConfigurable) {
            this.recommendedAsConfigurable = recommendedAsConfigurable;
        }

        /// <include file='doc\RecommendedAsConfigurableAttribute.uex' path='docs/doc[@for="RecommendedAsConfigurableAttribute.RecommendedAsConfigurable"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether the property this
        ///       attribute is bound to can be used as an application setting.</para>
        /// </devdoc>
        public bool RecommendedAsConfigurable {
            get {
                return recommendedAsConfigurable;
            }
        }

        /// <include file='doc\RecommendedAsConfigurableAttribute.uex' path='docs/doc[@for="RecommendedAsConfigurableAttribute.No"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that a property cannot be used as an application setting. This
        ///    <see langword='static '/>field is read-only. 
        ///    </para>
        /// </devdoc>
        public static readonly RecommendedAsConfigurableAttribute No = new RecommendedAsConfigurableAttribute(false);

        /// <include file='doc\RecommendedAsConfigurableAttribute.uex' path='docs/doc[@for="RecommendedAsConfigurableAttribute.Yes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies
        ///       that a property can be used as an application setting. This <see langword='static '/>field is read-only.
        ///    </para>
        /// </devdoc>
        public static readonly RecommendedAsConfigurableAttribute Yes = new RecommendedAsConfigurableAttribute(true);

        /// <include file='doc\RecommendedAsConfigurableAttribute.uex' path='docs/doc[@for="RecommendedAsConfigurableAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the default value for the <see cref='System.ComponentModel.RecommendedAsConfigurableAttribute'/>, which is <see cref='System.ComponentModel.RecommendedAsConfigurableAttribute.No'/>. This <see langword='static '/>field is
        ///       read-only.
        ///    </para>
        /// </devdoc>
        public static readonly RecommendedAsConfigurableAttribute Default = No;
        
        /// <include file='doc\RecommendedAsConfigurableAttribute.uex' path='docs/doc[@for="RecommendedAsConfigurableAttribute.Equals"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            RecommendedAsConfigurableAttribute other = obj as RecommendedAsConfigurableAttribute;

            return other != null && other.RecommendedAsConfigurable == recommendedAsConfigurable;
            
            
        }
        
        /// <include file='doc\RecommendedAsConfigurableAttribute.uex' path='docs/doc[@for="RecommendedAsConfigurableAttribute.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the hashcode for this object.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

        /// <include file='doc\RecommendedAsConfigurableAttribute.uex' path='docs/doc[@for="RecommendedAsConfigurableAttribute.IsDefaultAttribute"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override bool IsDefaultAttribute() {
            return !recommendedAsConfigurable;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\propertydescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="PropertyDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {

    using System;
    using System.Collections;
    using System.ComponentModel.Design;
    using Microsoft.Win32;
    using System.Diagnostics;
    using System.Reflection;
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting.Activation;
    using System.Runtime.InteropServices;

    /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor"]/*' />
    /// <devdoc>
    ///    <para>Provides a description of a property.</para>
    /// </devdoc>
    [System.Runtime.InteropServices.ComVisible(true)]
    public abstract class PropertyDescriptor : MemberDescriptor {
        private TypeConverter converter = null;
        private Hashtable     valueChangedHandlers;
        private object[]      editors;
        private Type[]        editorTypes;
        private int           editorCount;

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.PropertyDescriptor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.PropertyDescriptor'/> class with the specified name and
        ///       attributes.
        ///    </para>
        /// </devdoc>
        protected PropertyDescriptor(string name, Attribute[] attrs)
        : base(name, attrs) {
        }
        
        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.PropertyDescriptor1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.PropertyDescriptor'/> class with
        ///       the name and attributes in the specified <see cref='System.ComponentModel.MemberDescriptor'/>.
        ///    </para>
        /// </devdoc>
        protected PropertyDescriptor(MemberDescriptor descr)
        : base(descr) {
        }
        
        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.PropertyDescriptor2"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.PropertyDescriptor'/> class with
        ///       the name in the specified <see cref='System.ComponentModel.MemberDescriptor'/> and the
        ///       attributes in both the <see cref='System.ComponentModel.MemberDescriptor'/> and the
        ///    <see cref='System.Attribute'/> array. 
        ///    </para>
        /// </devdoc>
        protected PropertyDescriptor(MemberDescriptor descr, Attribute[] attrs)
        : base(descr, attrs) {
        }

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.ComponentType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class, gets the type of the
        ///       component this property
        ///       is bound to.
        ///    </para>
        /// </devdoc>
        public abstract Type ComponentType {get;}

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.Converter"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type converter for this property.
        ///    </para>
        /// </devdoc>
        public virtual TypeConverter Converter {
            get {
                if (converter == null) {
                    TypeConverterAttribute attr = (TypeConverterAttribute)Attributes[typeof(TypeConverterAttribute)];
                    if (attr.ConverterTypeName != null && attr.ConverterTypeName.Length > 0) {
                        Type converterType = GetTypeFromName(attr.ConverterTypeName);
                        if (converterType != null && typeof(TypeConverter).IsAssignableFrom(converterType)) {
                            converter = (TypeConverter)CreateInstance(converterType);
                        }
                    }

                    if (converter == null) {
                        converter = TypeDescriptor.GetConverter(PropertyType);
                    }
                }
                return converter;
            }
        }

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.IsLocalizable"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value
        ///       indicating whether this property should be localized, as
        ///       specified in the <see cref='System.ComponentModel.LocalizableAttribute'/>.
        ///    </para>
        /// </devdoc>
        public virtual bool IsLocalizable {
            get {
                return(LocalizableAttribute.Yes.Equals(Attributes[typeof(LocalizableAttribute)]));
            }
        }

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.IsReadOnly"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in
        ///       a derived class, gets a value
        ///       indicating whether this property is read-only.
        ///    </para>
        /// </devdoc>
        public abstract bool IsReadOnly { get;}

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.SerializationVisibility"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value
        ///       indicating whether this property should be serialized as specified in the <see cref='System.ComponentModel.DesignerSerializationVisibilityAttribute'/>.
        ///    </para>
        /// </devdoc>
        public DesignerSerializationVisibility SerializationVisibility {
            get {
                DesignerSerializationVisibilityAttribute attr = (DesignerSerializationVisibilityAttribute)Attributes[typeof(DesignerSerializationVisibilityAttribute)];
                return attr.Visibility;
            }
        }

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.PropertyType"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class,
        ///       gets the type of the property.
        ///    </para>
        /// </devdoc>
        public abstract Type PropertyType { get;}

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.AddValueChanged"]/*' />
        /// <devdoc>
        ///     Allows interested objects to be notified when this property changes.
        /// </devdoc>
        public virtual void AddValueChanged(object component, EventHandler handler) {
            if (component == null) throw new ArgumentNullException("component");
            if (handler == null) throw new ArgumentNullException("handler");
            
            if (valueChangedHandlers == null) {
                valueChangedHandlers = new Hashtable();
            }
            
            EventHandler h = (EventHandler)valueChangedHandlers[component];
            valueChangedHandlers[component] = Delegate.Combine(h, handler);
        }
        
        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.CanResetValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class, indicates whether
        ///       resetting the <paramref name="component "/>will change the value of the
        ///    <paramref name="component"/>.
        /// </para>
        /// </devdoc>
        public abstract bool CanResetValue(object component);

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.Equals"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Compares this to another <see cref='System.ComponentModel.PropertyDescriptor'/>
        ///       to see if they are equivalent.
        ///    </para>
        /// </devdoc>
        public override bool Equals(object obj) {
            try {
                if (obj == this) {
                    return true;
                }
                
                if (obj == null) {
                    return false;
                }
                
                // Assume that 90% of the time we will only do a .Equals(...) for
                // propertydescriptor vs. propertydescriptor... avoid the overhead
                // of an instanceof call.
                PropertyDescriptor pd = obj as PropertyDescriptor;

                if (pd != null && pd.NameHashCode == this.NameHashCode
                    && pd.PropertyType == this.PropertyType
                    && pd.Name.Equals(this.Name)) {
    
                    return true;
                }
            }
            catch (Exception) {
            }

            return false;
        }

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.CreateInstance"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Creates an instance of the
        ///       specified type.
        ///    </para>
        /// </devdoc>
        protected object CreateInstance(Type type) {
            if ((!(type.IsPublic || type.IsNestedPublic)) && (type.Assembly == typeof(PropertyDescriptor).Assembly)) {
                IntSecurity.FullReflection.Demand();
            }

            ConstructorInfo ctor = type.GetConstructor(new Type[] {typeof(Type)});
            if (ctor != null) {
                return ctor.Invoke(new object[] {PropertyType});
            }
            
            return Activator.CreateInstance(type, BindingFlags.Instance | BindingFlags.Public | BindingFlags.CreateInstance, null, null, null);
        }

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.GetChildProperties"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PropertyDescriptorCollection GetChildProperties() {
            return GetChildProperties(null, null);
        }

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.GetChildProperties1"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PropertyDescriptorCollection GetChildProperties(Attribute[] filter) {
            return GetChildProperties(null, filter);
        }

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.GetChildProperties2"]/*' />
        /// <devdoc>
        ///    <para>[To be supplied.]</para>
        /// </devdoc>
        public PropertyDescriptorCollection GetChildProperties(object instance) {
            return GetChildProperties(instance, null);
        }
        
        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.GetChildProperties3"]/*' />
        /// <devdoc>
        ///    Retrieves the properties 
        /// </devdoc>
        public virtual PropertyDescriptorCollection GetChildProperties(object instance, Attribute[] filter) {
            if (instance == null) {
                return TypeDescriptor.GetProperties(PropertyType, filter);
            }
            else {
                return TypeDescriptor.GetProperties(instance, filter);
            }
        }


        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.GetEditor"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets an editor of the specified type.
        ///    </para>
        /// </devdoc>
        public virtual object GetEditor(Type editorBaseType) {
            object editor = null;

            // Check the editors we've already created for this type.
            //
            if (editorTypes != null) {
                for (int i = 0; i < editorCount; i++) {
                    if (editorTypes[i] == editorBaseType) {
                        return editors[i];
                    }
                }
            }

            // If one wasn't found, then we must go through the attributes.
            //
            if (editor == null) {
                for (int i = 0; i < Attributes.Count; i++) {

                    if (!(Attributes[i] is EditorAttribute)) {
                        continue;
                    }

                    EditorAttribute attr = (EditorAttribute)Attributes[i];
                    Type editorType = GetTypeFromName(attr.EditorBaseTypeName);

                    if (editorBaseType == editorType) {
                        Type type = GetTypeFromName(attr.EditorTypeName);
                        if (type != null) {
                            editor = CreateInstance(type);
                            break;
                        }
                    }
                }
                
                // Now, if we failed to find it in our own attributes, go to the
                // component descriptor.
                //
                if (editor == null) {
                    editor = TypeDescriptor.GetEditor(PropertyType, editorBaseType);
                }
                
                // Now, another slot in our editor cache for next time
                //
                if (editorTypes == null) {
                    editorTypes = new Type[5];
                    editors = new object[5];
                }

                if (editorCount >= editorTypes.Length) {
                    Type[] newTypes = new Type[editorTypes.Length * 2];
                    object[] newEditors = new object[editors.Length * 2];
                    Array.Copy(editorTypes, newTypes, editorTypes.Length);
                    Array.Copy(editors, newEditors, editors.Length);
                    editorTypes = newTypes;
                    editors = newEditors;
                }

                editorTypes[editorCount] = editorBaseType;
                editors[editorCount++] = editor;
            }

            return editor;
        }

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the hashcode for this object.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

       
        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.GetTypeFromName"]/*' />
        /// <devdoc>
        ///    <para>Gets a type using its name.</para>
        /// </devdoc>
        protected Type GetTypeFromName(string typeName) {
                  
            if (typeName == null || typeName.Length == 0) {
                 return null;
            }
        
            int commaIndex = typeName.IndexOf(',');
            Type t = null;
            
            if (commaIndex == -1) {
                t = ComponentType.Module.Assembly.GetType(typeName);
            }
            
            if (t == null) {
                t = Type.GetType(typeName);
            }
            
            return t;
        }

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.GetValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class, gets the current
        ///       value
        ///       of the
        ///       property on a component.
        ///    </para>
        /// </devdoc>
        public abstract object GetValue(object component);

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.OnValueChanged"]/*' />
        /// <devdoc>
        ///     This should be called by your property descriptor implementation
        ///     when the property value has changed.
        /// </devdoc>
        protected virtual void OnValueChanged(object component, EventArgs e) {
            if (component != null && valueChangedHandlers != null) {
                EventHandler handler = (EventHandler)valueChangedHandlers[component];
                if (handler != null) {
                    handler(component, e);
                }
            }
        }

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.RemoveValueChanged"]/*' />
        /// <devdoc>
        ///     Allows interested objects to be notified when this property changes.
        /// </devdoc>
        public virtual void RemoveValueChanged(object component, EventHandler handler) {
            if (component == null) throw new ArgumentNullException("component");
            if (handler == null) throw new ArgumentNullException("handler");
            
            if (valueChangedHandlers != null) {
                EventHandler h = (EventHandler)valueChangedHandlers[component];
                h = (EventHandler)Delegate.Remove(h, handler);
                if (h != null) {
                    valueChangedHandlers[component] = h;
                }
                else {
                    valueChangedHandlers.Remove(component);
                }
            }
        }
        
        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.ResetValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class, resets the
        ///       value
        ///       for this property
        ///       of the component.
        ///    </para>
        /// </devdoc>
        public abstract void ResetValue(object component);

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.SetValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class, sets the value of
        ///       the component to a different value.
        ///    </para>
        /// </devdoc>
        public abstract void SetValue(object component, object value);

        /// <include file='doc\PropertyDescriptor.uex' path='docs/doc[@for="PropertyDescriptor.ShouldSerializeValue"]/*' />
        /// <devdoc>
        ///    <para>
        ///       When overridden in a derived class, indicates whether the
        ///       value of
        ///       this property needs to be persisted.
        ///    </para>
        /// </devdoc>
        public abstract bool ShouldSerializeValue(object component);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\refresheventargs.cs ===
//------------------------------------------------------------------------------
// <copyright file="RefreshEventArgs.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    

    using System.Diagnostics;

    using System;

    /// <include file='doc\RefreshEventArgs.uex' path='docs/doc[@for="RefreshEventArgs"]/*' />
    /// <devdoc>
    ///    <para>
    ///       Provides data for the <see cref='System.ComponentModel.TypeDescriptor.Refresh'/> event.
    ///    </para>
    /// </devdoc>
    public class RefreshEventArgs : EventArgs {

        private object componentChanged;
        private Type   typeChanged;

        /// <include file='doc\RefreshEventArgs.uex' path='docs/doc[@for="RefreshEventArgs.RefreshEventArgs"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.RefreshEventArgs'/> class with
        ///       the component that has
        ///       changed.
        ///    </para>
        /// </devdoc>
        public RefreshEventArgs(object componentChanged) {
            this.componentChanged = componentChanged;
            this.typeChanged = componentChanged.GetType();
        }

        /// <include file='doc\RefreshEventArgs.uex' path='docs/doc[@for="RefreshEventArgs.RefreshEventArgs1"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of the <see cref='System.ComponentModel.RefreshEventArgs'/> class with
        ///       the type
        ///       of component that has changed.
        ///    </para>
        /// </devdoc>
        public RefreshEventArgs(Type typeChanged) {
            this.typeChanged = typeChanged;
        }

        /// <include file='doc\RefreshEventArgs.uex' path='docs/doc[@for="RefreshEventArgs.ComponentChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the component that has changed
        ///       its properties, events, or
        ///       extenders.
        ///    </para>
        /// </devdoc>
        public object ComponentChanged {
            get {
                return componentChanged;
            }
        }

        /// <include file='doc\RefreshEventArgs.uex' path='docs/doc[@for="RefreshEventArgs.TypeChanged"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets the type that has changed its properties, or events.
        ///    </para>
        /// </devdoc>
        public Type TypeChanged {
            get {
                return typeChanged;
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\sbyteconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="SByteConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.ComponentModel;

    using System.Diagnostics;

    using Microsoft.Win32;

    /// <include file='doc\SByteConverter.uex' path='docs/doc[@for="SByteConverter"]/*' />
    /// <devdoc>
    ///    <para>Provides a
    ///       type converter to convert 8-bit unsigned
    ///       integer objects to and from various other representations.</para>
    /// </devdoc>
    public class SByteConverter : BaseNumberConverter {
    
        /// <include file='doc\SByteConverter.uex' path='docs/doc[@for="SByteConverter.TargetType"]/*' />
        /// <devdoc>
        /// The Type this converter is targeting (e.g. Int16, UInt32, etc.)
        /// </devdoc>
        internal override Type TargetType {
                get {
                    return typeof(SByte);
                }
        }

        /// <include file='doc\SByteConverter.uex' path='docs/doc[@for="SByteConverter.FromString"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given radix
        /// </devdoc>
        internal override object FromString(string value, int radix) {
                return Convert.ToSByte(value, radix);
        }
        
        /// <include file='doc\SByteConverter.uex' path='docs/doc[@for="SByteConverter.FromString1"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given formatInfo
        /// </devdoc>
        internal override object FromString(string value, NumberFormatInfo formatInfo) {
                return SByte.Parse(value, NumberStyles.Integer, formatInfo);
        }
        
        
        /// <include file='doc\SByteConverter.uex' path='docs/doc[@for="SByteConverter.FromString2"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given CultureInfo
        /// </devdoc>
        internal override object FromString(string value, CultureInfo culture){
                 return SByte.Parse(value, culture);
        }
        
        /// <include file='doc\SByteConverter.uex' path='docs/doc[@for="SByteConverter.ToString"]/*' />
        /// <devdoc>
        /// Convert the given value from a string using the given formatInfo
        /// </devdoc>
        internal override string ToString(object value, NumberFormatInfo formatInfo) {
                return ((SByte)value).ToString("G", formatInfo);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\refresheventhandler.cs ===
//------------------------------------------------------------------------------
// <copyright file="RefreshEventHandler.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------
namespace System.ComponentModel {
    

    using System.Diagnostics;


    /// <include file='doc\RefreshEventHandler.uex' path='docs/doc[@for="RefreshEventHandler"]/*' />
    /// <devdoc>
    /// <para>Represents the method that will handle the <see cref='System.ComponentModel.TypeDescriptor.Refresh'/> event
    ///    raised when a <see cref='System.Type'/> or component is changed during design time.</para>
    /// </devdoc>
    public delegate void RefreshEventHandler(RefreshEventArgs e);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\runinstallerattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="RunInstallerAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Diagnostics;
    using System;

    /// <include file='doc\RunInstallerAttribute.uex' path='docs/doc[@for="RunInstallerAttribute"]/*' />
    /// <devdoc>
    ///    <para>Specifies whether an installer should be invoked during
    ///       installation of an assembly.</para>
    /// </devdoc>
    [AttributeUsage(AttributeTargets.Class)]
    public class RunInstallerAttribute : Attribute {
        private bool runInstaller;
        
        /// <include file='doc\RunInstallerAttribute.uex' path='docs/doc[@for="RunInstallerAttribute.RunInstallerAttribute"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Initializes a new instance of
        ///       the <see cref='System.ComponentModel.RunInstallerAttribute'/> class.
        ///    </para>
        /// </devdoc>
        public RunInstallerAttribute(bool runInstaller) {
            this.runInstaller = runInstaller;
        }

        /// <include file='doc\RunInstallerAttribute.uex' path='docs/doc[@for="RunInstallerAttribute.RunInstaller"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Gets a value indicating whether an installer should be
        ///       invoked during installation of an assembly.
        ///    </para>
        /// </devdoc>
        public bool RunInstaller {
            get {
                return runInstaller;
            }
        }

        /// <include file='doc\RunInstallerAttribute.uex' path='docs/doc[@for="RunInstallerAttribute.Yes"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that a
        ///       component is visible in a visual designer. This <see langword='static '/>field is
        ///       read-only.
        ///    </para>
        /// </devdoc>
        public static readonly RunInstallerAttribute Yes = new RunInstallerAttribute(true);

        /// <include file='doc\RunInstallerAttribute.uex' path='docs/doc[@for="RunInstallerAttribute.No"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies that a
        ///       component
        ///       is not visible in a visual designer. This <see langword='static '/>field is
        ///       read-only.
        ///    </para>
        /// </devdoc>
        public static readonly RunInstallerAttribute No = new RunInstallerAttribute(false);

        /// <include file='doc\RunInstallerAttribute.uex' path='docs/doc[@for="RunInstallerAttribute.Default"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Specifies the default visiblity, which is <see cref='System.ComponentModel.RunInstallerAttribute.No'/>. This <see langword='static '/>field is
        ///       read-only.
        ///    </para>
        /// </devdoc>
        public static readonly RunInstallerAttribute Default = No;

        /// <include file='doc\RunInstallerAttribute.uex' path='docs/doc[@for="RunInstallerAttribute.Equals"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            RunInstallerAttribute other = obj as RunInstallerAttribute;
            return other != null && other.RunInstaller == runInstaller;
        }

        /// <include file='doc\RunInstallerAttribute.uex' path='docs/doc[@for="RunInstallerAttribute.GetHashCode"]/*' />
        /// <devdoc>
        ///    <para>
        ///       Returns the hashcode for this object.
        ///    </para>
        /// </devdoc>
        public override int GetHashCode() {
            return base.GetHashCode();
        }

        /// <include file='doc\RunInstallerAttribute.uex' path='docs/doc[@for="RunInstallerAttribute.IsDefaultAttribute"]/*' />
        /// <internalonly/>
        /// <devdoc>
        /// </devdoc>
        public override bool IsDefaultAttribute() {
            return (this.Equals(Default));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\reflecteventdescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ReflectEventDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------


/*
 */
namespace System.ComponentModel {
    

    using System.Diagnostics;

    using System;
    using System.Reflection;
    using System.Collections;
    using Microsoft.Win32;
    using System.ComponentModel.Design;

    /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       ReflectEventDescriptor defines an event. Events are the main way that a user can get
    ///       run-time notifications from a component.
    ///       The ReflectEventDescriptor class takes a component class that the event lives on,
    ///       the event name, the type of the event handling delegate, and various
    ///       attributes for the event.
    ///       Every event has a structure through which it passes it's information. The base
    ///       structure, Event, is empty, and there is a default instance, Event.EMPTY, which
    ///       is usually passed. When addOnXXX is invoked, it needs a pointer to a method
    ///       that takes a source object (the object that fired the event) and a structure
    ///       particular to that event. It also needs a pointer to the instance of the
    ///       object the method should be invoked on. These two things are what composes a
    ///       delegate. An event handler is
    ///       a delegate, and the compiler recognizes a special delegate syntax that makes
    ///       using delegates easy.
    ///       For example, to listen to the click event on a button in class Foo, the
    ///       following code will suffice:
    ///    </para>
    ///    <code>
    /// class Foo {
    ///     Button button1 = new Button();
    ///     void button1_click(Object sender, Event e) {
    ///     // do something on button1 click.
    ///     }
    ///     public Foo() {
    ///     button1.addOnClick(this.button1_click);
    ///     }
    ///     }
    ///    </code>
    ///    For an event named XXX, a YYYEvent structure, and a YYYEventHandler delegate,
    ///    a component writer is required to implement two methods of the following
    ///    form:
    ///    <code>
    /// public void addOnXXX(YYYEventHandler handler);
    ///     public void removeOnXXX(YYYEventHandler handler);
    ///    </code>
    ///    YYYEventHandler should be an event handler declared as
    ///    <code>
    /// public multicast delegate void YYYEventHandler(Object sender, YYYEvent e);
    ///    </code>
    ///    Note that this event was declared as a multicast delegate. This allows multiple
    ///    listeners on an event. This is not a requirement.
    ///    Various attributes can be passed to the ReflectEventDescriptor, as are described in
    ///    Attribute.
    ///    ReflectEventDescriptors can be obtained by a user programmatically through the
    ///    ComponentManager.
    /// </devdoc>
    internal sealed class ReflectEventDescriptor : EventDescriptor {

        private static readonly Type[] argsNone = new Type[0];
        private static readonly object  noDefault = new object();

        private Type type;           // the delegate type for the event
        private readonly Type componentClass; // the class of the component this info is for

        private MethodInfo addMethod;     // the method to use when adding an event
        private MethodInfo removeMethod;  // the method to use when removing an event
        private EventInfo realEvent;      // actual event info... may be null
        private bool    filledMethods = false;   // did we already call FillMethods() once?

        /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor.ReflectEventDescriptor"]/*' />
        /// <devdoc>
        ///     This is the main constructor for an ReflectEventDescriptor.
        /// </devdoc>
        public ReflectEventDescriptor(Type componentClass, string name, Type type,
                                      Attribute[] attributes)
        : base(name, attributes) {
            if (componentClass == null) {
                throw new ArgumentException(SR.GetString(SR.InvalidNullArgument, "componentClass"));
            }
            if (type == null || !(typeof(Delegate)).IsAssignableFrom(type)) {
                throw new ArgumentException(SR.GetString(SR.ErrorInvalidEventType, name));
            }
            Debug.Assert(type.IsSubclassOf(typeof(Delegate)), "Not a valid ReflectEvent: " + componentClass.FullName + "." + name + " " + type.FullName);
            this.componentClass = componentClass;
            this.type = type;
        }

        public ReflectEventDescriptor(Type componentClass, EventInfo eventInfo)
        : base(eventInfo.Name, new Attribute[0]) {

            if (componentClass == null) {
                throw new ArgumentException(SR.GetString(SR.InvalidNullArgument, "componentClass"));
            }
            this.componentClass = componentClass;
            this.realEvent = eventInfo;
        }
        /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor.ReflectEventDescriptor1"]/*' />
        /// <devdoc>
        ///     This is a shortcut main constructor for an ReflectEventDescriptor with one attribute.
        /// </devdoc>
        public ReflectEventDescriptor(Type componentClass, string name, Type type, MethodInfo addMethod, MethodInfo removeMethod) : this(componentClass, name, type, (Attribute[]) null) {
            this.addMethod = addMethod;
            this.removeMethod = removeMethod;
            this.filledMethods = true;
        }

        /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor.ReflectEventDescriptor2"]/*' />
        /// <devdoc>
        ///     This is a shortcut main constructor for an ReflectEventDescriptor with one attribute.
        /// </devdoc>
        public ReflectEventDescriptor(Type componentClass, string name, Type type) : this(componentClass, name, type, (Attribute[]) null) {
        }

        /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor.ReflectEventDescriptor3"]/*' />
        /// <devdoc>
        ///     This is a shortcut main constructor for an ReflectEventDescriptor with two attributes.
        /// </devdoc>
        public ReflectEventDescriptor(Type componentClass, string name, Type type,
                                      Attribute a1) : this(componentClass, name, type, new Attribute[] {a1}) {
        }

        /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor.ReflectEventDescriptor4"]/*' />
        /// <devdoc>
        ///     This is a shortcut main constructor for an ReflectEventDescriptor with two attributes.
        /// </devdoc>
        public ReflectEventDescriptor(Type componentClass, string name, Type type,
                                      Attribute a1, Attribute a2) : this(componentClass, name, type, new Attribute[] {a1, a2}) {
        }

        /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor.ReflectEventDescriptor5"]/*' />
        /// <devdoc>
        ///     This is a shortcut main constructor for an ReflectEventDescriptor with three attributes.
        /// </devdoc>
        public ReflectEventDescriptor(Type componentClass, string name, Type type,
                                      Attribute a1, Attribute a2, Attribute a3) : this(componentClass, name, type, new Attribute[] {a1, a2, a3}) {
        }

        /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor.ReflectEventDescriptor6"]/*' />
        /// <devdoc>
        ///     This is a shortcut main constructor for an ReflectEventDescriptor with four attributes.
        /// </devdoc>
        public ReflectEventDescriptor(Type componentClass, string name, Type type,
                                      Attribute a1, Attribute a2,
                                      Attribute a3, Attribute a4) : this(componentClass, name, type, new Attribute[] {a1, a2, a3, a4}) {
        }

        /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor.ReflectEventDescriptor7"]/*' />
        /// <devdoc>
        ///     This constructor takes an existing ReflectEventDescriptor and modifies it by merging in the
        ///     passed-in attributes.
        /// </devdoc>
        public ReflectEventDescriptor(EventDescriptor oldReflectEventDescriptor, Attribute[] attributes)
        : this(oldReflectEventDescriptor.ComponentType, oldReflectEventDescriptor, attributes) {
        }

        /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor.ReflectEventDescriptor8"]/*' />
        /// <devdoc>
        ///     This constructor takes an existing ReflectEventDescriptor and modifies it by merging in the
        ///     passed-in attributes.
        /// </devdoc>
        public ReflectEventDescriptor(Type componentType, EventDescriptor oldReflectEventDescriptor, Attribute[] attributes)
        : base(oldReflectEventDescriptor, attributes) {
            this.componentClass = componentType;
            this.type = oldReflectEventDescriptor.EventType;
            
            if (oldReflectEventDescriptor is ReflectEventDescriptor) {
                this.addMethod = ((ReflectEventDescriptor)oldReflectEventDescriptor).addMethod;
                this.removeMethod = ((ReflectEventDescriptor)oldReflectEventDescriptor).removeMethod;
                this.filledMethods = true;
            }
        }

        /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor.ReflectEventDescriptor9"]/*' />
        /// <devdoc>
        ///     This is a shortcut constructor that takes an existing ReflectEventDescriptor and one attribute to
        ///     merge in.
        /// </devdoc>
        public ReflectEventDescriptor(EventDescriptor oldReflectEventDescriptor, Attribute a1) : this(oldReflectEventDescriptor, new Attribute[] { a1}) {
        }

        /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor.ReflectEventDescriptor10"]/*' />
        /// <devdoc>
        ///     This is a shortcut constructor that takes an existing ReflectEventDescriptor and two attributes to
        ///     merge in.
        /// </devdoc>
        public ReflectEventDescriptor(EventDescriptor oldReflectEventDescriptor, Attribute a1,
                                      Attribute a2) : this(oldReflectEventDescriptor, new Attribute[] { a1,a2}) {
        }

        /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor.ReflectEventDescriptor11"]/*' />
        /// <devdoc>
        ///     This is a shortcut constructor that takes an existing ReflectEventDescriptor and three attributes to
        ///     merge in.
        /// </devdoc>
        public ReflectEventDescriptor(EventDescriptor oldReflectEventDescriptor, Attribute a1,
                                      Attribute a2, Attribute a3) : this(oldReflectEventDescriptor, new Attribute[] { a1,a2,a3}) {
        }

        /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor.ReflectEventDescriptor12"]/*' />
        /// <devdoc>
        ///     This is a shortcut constructor that takes an existing ReflectEventDescriptor and four attributes to
        ///     merge in.
        /// </devdoc>
        public ReflectEventDescriptor(EventDescriptor oldReflectEventDescriptor, Attribute a1,
                                      Attribute a2, Attribute a3, Attribute a4) : this(oldReflectEventDescriptor, new Attribute[] { a1,a2,a3,a4}) {
        }

        /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor.ComponentType"]/*' />
        /// <devdoc>
        ///     Retrieves the type of the component this EventDescriptor is bound to.
        /// </devdoc>
        public override Type ComponentType {
            get {
                return componentClass;
            }
        }

        /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor.EventType"]/*' />
        /// <devdoc>
        ///     Retrieves the type of the delegate for this event.
        /// </devdoc>
        public override Type EventType {
            get {
                FillMethods();
                return type;
            }
        }

        /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor.IsMulticast"]/*' />
        /// <devdoc>
        ///     Indicates whether the delegate type for this event is a multicast
        ///     delegate.
        /// </devdoc>
        public override bool IsMulticast {
            get {
                return(typeof(MulticastDelegate)).IsAssignableFrom(EventType);
            }
        }

        /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor.AddEventHandler"]/*' />
        /// <devdoc>
        ///     This adds the delegate value as a listener to when this event is fired
        ///     by the component, invoking the addOnXXX method.
        /// </devdoc>
        public override void AddEventHandler(object component, Delegate value) {
            FillMethods();

            if (component != null) {
                ISite site = GetSite(component);
                IComponentChangeService changeService = null;

                // Announce that we are about to change this component
                //
                if (site != null) {
                    changeService = (IComponentChangeService)site.GetService(typeof(IComponentChangeService));
                    Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || changeService != null, "IComponentChangeService not found");
                }

                if (changeService != null) {
                    try {
                        changeService.OnComponentChanging(component, this);
                    }
                    catch (CheckoutException coEx) {
                        if (coEx == CheckoutException.Canceled) {
                            return;
                        }
                        throw coEx;
                    }
                }

                bool shadowed = false;

                if (site != null && site.DesignMode) {
                    // Events are final, so just check the class
                    if (EventType != value.GetType()) {
                        throw new ArgumentException(SR.GetString(SR.ErrorInvalidEventHandler, Name));
                    }
                    IDictionaryService dict = (IDictionaryService)site.GetService(typeof(IDictionaryService));
                    Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || dict != null, "IDictionaryService not found");
                    if (dict != null) {
                        Delegate eventdesc = (Delegate)dict.GetValue(this);
                        eventdesc = Delegate.Combine(eventdesc, value);
                        dict.SetValue(this, eventdesc);
                        shadowed = true;
                    }
                }

                if (!shadowed) {
                    addMethod.Invoke(component, new object[] { value});
                }

                // Now notify the change service that the change was successful.
                //
                if (changeService != null) {
                    changeService.OnComponentChanged(component, this, null, value);
                }
            }
        }

        // <doc>
        // <desc>
        //     Adds in custom attributes found on either the AddOn or RemoveOn method...
        // </desc>
        // </doc>
        //
        protected override void FillAttributes(IList attributes) {
        
            //
            // The order that we fill in attributes is critical.  The list of attributes will be
            // filtered so that matching attributes at the end of the list replace earlier matches
            // (last one in wins).  Therefore, the two categories of attributes we add must be
            // added as follows:
            //
            // 1.  Attributes of the event, from base class to most derived.  This way
            //     derived class attributes replace base class attributes.
            //
            // 2.  Attributes from our base MemberDescriptor.  While this seems opposite of what
            //     we want, MemberDescriptor only has attributes if someone passed in a new
            //     set in the constructor.  Therefore, these attributes always
            //     supercede existing values.
            //
        
            FillMethods();
            Debug.Assert(componentClass != null, "Must have a component class for FilterAttributes");
            if (realEvent != null) {
                FillEventInfoAttribute(realEvent, attributes);
            }
            else {
                Debug.Assert(removeMethod != null, "Null remove method for " + Name);
                FillSingleMethodAttribute(removeMethod, attributes);

                Debug.Assert(addMethod != null, "Null remove method for " + Name);
                FillSingleMethodAttribute(addMethod, attributes);
            }
        
            // Include the base attributes.  These override all attributes on the actual
            // property, so we want to add them last.
            //
            base.FillAttributes(attributes);
        }
        
        private void FillEventInfoAttribute(EventInfo realEventInfo, IList attributes) {
            string eventName = realEventInfo.Name;
            BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly;
            Type currentReflectType = realEventInfo.ReflectedType;
            Debug.Assert(currentReflectType != null, "currentReflectType cannot be null");
            int depth = 0;
            
            // First, calculate the depth of the object hierarchy.  We do this so we can do a single
            // object create for an array of attributes.
            //
            while(currentReflectType != typeof(object)) {
                depth++;
                currentReflectType = currentReflectType.BaseType;
            }

            if (depth > 0) {
                // Now build up an array in reverse order
                //
                currentReflectType = realEventInfo.ReflectedType;
                object[][] attributeStack = new object[depth][];
                
                while(currentReflectType != typeof(object)) {

                    // Fill in our member info so we can get at the custom attributes.
                    //
                    MemberInfo memberInfo = currentReflectType.GetEvent(eventName, bindingFlags);
                    
                    // Get custom attributes for the member info.
                    //
                    if (memberInfo != null) {
                        attributeStack[--depth] = TypeDescriptor.GetCustomAttributes(memberInfo);
                    }
                    
                    // Ready for the next loop iteration.
                    //
                    currentReflectType = currentReflectType.BaseType;
                }
                
                // Now trawl the attribute stack so that we add attributes
                // from base class to most derived.
                //
                foreach(object[] attributeArray in attributeStack) {
                    if (attributeArray != null) {
                        foreach(object attr in attributeArray) {
                            if (attr is Attribute) {
                                attributes.Add(attr);
                            }
                        }
                    }
                }
            }
        }
            
        /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor.FillMethods"]/*' />
        /// <devdoc>
        ///     This fills the get and set method fields of the event info.  It is shared
        ///     by the various constructors.
        /// </devdoc>
        private void FillMethods() {
            if (filledMethods) return;

            if (realEvent != null) {
                addMethod = realEvent.GetAddMethod();
                removeMethod = realEvent.GetRemoveMethod();

                EventInfo defined = null;

                if (addMethod == null || removeMethod == null) {
                    Type start = componentClass.BaseType;
                    while (start != null && start != typeof(object)) {
                        BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic;
                        EventInfo test = start.GetEvent(realEvent.Name, bindingFlags);
                        if (test.GetAddMethod() != null) {
                            defined = test;
                            break;
                        }
                    }
                }

                if (defined != null) {
                    addMethod = defined.GetAddMethod();
                    removeMethod = defined.GetRemoveMethod();
                    type = defined.EventHandlerType;
                }
                else {
                    type = realEvent.EventHandlerType;
                }
            }
            else {

                // first, try to get the eventInfo...
                //
                realEvent = this.componentClass.GetEvent(Name);
                if (realEvent != null) {
                    // if we got one, just recurse and return.
                    //
                    FillMethods();
                    return;
                }

                Type[] argsType = new Type[] {type};
                addMethod = FindMethod(componentClass, "AddOn" + Name, argsType, typeof(void));
                removeMethod = FindMethod(componentClass, "RemoveOn" + Name, argsType, typeof(void));
                if (addMethod == null || removeMethod == null) {
                    Debug.Fail("Missing event accessors for " + componentClass.FullName + "." + Name);
                    throw new ArgumentException(SR.GetString(SR.ErrorMissingEventAccessors, Name));
                }
            }

            filledMethods = true;
        }

        private void FillSingleMethodAttribute(MethodInfo realMethodInfo, IList attributes) {

            string methodName = realMethodInfo.Name;
            BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.DeclaredOnly;
            Type currentReflectType = realMethodInfo.ReflectedType;
            Debug.Assert(currentReflectType != null, "currentReflectType cannot be null");

            // First, calculate the depth of the object hierarchy.  We do this so we can do a single
            // object create for an array of attributes.
            //
            int depth = 0;
            while(currentReflectType != null && currentReflectType != typeof(object)) {
                depth++;
                currentReflectType = currentReflectType.BaseType;
            }
            
            if (depth > 0) {
                // Now build up an array in reverse order
                //
                currentReflectType = realMethodInfo.ReflectedType;
                object[][] attributeStack = new object[depth][];
                
                while(currentReflectType != null && currentReflectType != typeof(object)) {
                    // Fill in our member info so we can get at the custom attributes.
                    //
                    MemberInfo memberInfo = currentReflectType.GetMethod(methodName, bindingFlags);
                    
                    // Get custom attributes for the member info.
                    //
                    if (memberInfo != null) {
                        attributeStack[--depth] = TypeDescriptor.GetCustomAttributes(memberInfo);
                    }
                    
                    // Ready for the next loop iteration.
                    //
                    currentReflectType = currentReflectType.BaseType;
                }
                
                // Now trawl the attribute stack so that we add attributes
                // from base class to most derived.
                //
                foreach(object[] attributeArray in attributeStack) {
                    if (attributeArray != null) {
                        foreach(object attr in attributeArray) {
                            if (attr is Attribute) {
                                attributes.Add(attr);
                            }
                        }
                    }
                }
            }
        }

        /// <include file='doc\ReflectEventDescriptor.uex' path='docs/doc[@for="ReflectEventDescriptor.RemoveEventHandler"]/*' />
        /// <devdoc>
        ///     This will remove the delegate value from the event chain so that
        ///     it no longer gets events from this component.
        /// </devdoc>
        public override void RemoveEventHandler(object component, Delegate value) {
            FillMethods();

            if (component != null) {
                ISite site = GetSite(component);
                IComponentChangeService changeService = null;

                // Announce that we are about to change this component
                //
                if (site != null) {
                    changeService = (IComponentChangeService)site.GetService(typeof(IComponentChangeService));
                    Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || changeService != null, "IComponentChangeService not found");
                }

                if (changeService != null) {
                    try {
                        changeService.OnComponentChanging(component, this);
                    }
                    catch (CheckoutException coEx) {
                        if (coEx == CheckoutException.Canceled) {
                            return;
                        }
                        throw coEx;
                    }
                }

                bool shadowed = false;

                if (site != null && site.DesignMode) {
                    IDictionaryService dict = (IDictionaryService)site.GetService(typeof(IDictionaryService));
                    Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || dict != null, "IDictionaryService not found");
                    if (dict != null) {
                        Delegate del = (Delegate)dict.GetValue(this);
                        del = Delegate.Remove(del, value);
                        dict.SetValue(this, del);
                        shadowed = true;
                    }
                }

                if (!shadowed) {
                    removeMethod.Invoke(component, new object[] { value});
                }

                // Now notify the change service that the change was successful.
                //
                if (changeService != null) {
                    changeService.OnComponentChanged(component, this, null, value);
                }
            }
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\stringconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="StringConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    

    using System.Diagnostics;
    using System.Globalization;

    /// <include file='doc\StringConverter.uex' path='docs/doc[@for="StringConverter"]/*' />
    /// <devdoc>
    ///    <para>Provides a type converter to convert string objects to and from various other
    ///       representations.</para>
    /// </devdoc>
    public class StringConverter : TypeConverter {

        /// <include file='doc\StringConverter.uex' path='docs/doc[@for="StringConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can convert an object in the
        ///       given source type to a string using the specified context.</para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\StringConverter.uex' path='docs/doc[@for="StringConverter.ConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>Converts the specified value object to a string object.</para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture, object value) {
            if (value is string) {
                return (string)value;
            }
            if (value == null) {
                return "";
            }
            return base.ConvertFrom(context, culture, value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\timespanconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="TimeSpanConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Threading;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    using System.Globalization;
    using System.ComponentModel.Design.Serialization;
    using System.Reflection;
    

    using System.Diagnostics;

    using Microsoft.Win32;

    /// <include file='doc\TimeSpanConverter.uex' path='docs/doc[@for="TimeSpanConverter"]/*' />
    /// <devdoc>
    /// <para>Provides a type converter to convert <see cref='System.TimeSpan'/>
    /// objects to and from various
    /// other representations.</para>
    /// </devdoc>
    public class TimeSpanConverter : TypeConverter {
    
        /// <include file='doc\TimeSpanConverter.uex' path='docs/doc[@for="TimeSpanConverter.CanConvertFrom"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object in the given source type to a <see cref='System.TimeSpan'/> object using the
        ///       specified context.</para>
        /// </devdoc>
        public override bool CanConvertFrom(ITypeDescriptorContext context, Type sourceType) {
            if (sourceType == typeof(string)) {
                return true;
            }
            return base.CanConvertFrom(context, sourceType);
        }

        /// <include file='doc\TimeSpanConverter.uex' path='docs/doc[@for="TimeSpanConverter.CanConvertTo"]/*' />
        /// <devdoc>
        ///    <para>Gets a value indicating whether this converter can
        ///       convert an object to the given destination type using the context.</para>
        /// </devdoc>
        public override bool CanConvertTo(ITypeDescriptorContext context, Type destinationType) {
            if (destinationType == typeof(InstanceDescriptor)) {
                return true;
            }
            return base.CanConvertTo(context, destinationType);
        }

        /// <include file='doc\TimeSpanConverter.uex' path='docs/doc[@for="TimeSpanConverter.ConvertFrom"]/*' />
        /// <devdoc>
        /// <para>Converts the given object to a <see cref='System.TimeSpan'/>
        /// object.</para>
        /// </devdoc>
        public override object ConvertFrom(ITypeDescriptorContext context, CultureInfo culture,  object value) {
            if (value is string) {
                string text = ((string)value).Trim();
                try {
                    return TimeSpan.Parse(text);
                }
                catch (FormatException e) {
                    throw new FormatException(SR.GetString(SR.ConvertInvalidPrimitive, (string)value, "TimeSpan"), e);
                }
            }
            
            return base.ConvertFrom(context, culture, value);
        }
        
        /// <include file='doc\TimeSpanConverter.uex' path='docs/doc[@for="TimeSpanConverter.ConvertTo"]/*' />
        /// <devdoc>
        ///      Converts the given object to another type.  The most common types to convert
        ///      are to and from a string object.  The default implementation will make a call
        ///      to ToString on the object if the object is valid and if the destination
        ///      type is string.  If this cannot convert to the desitnation type, this will
        ///      throw a NotSupportedException.
        /// </devdoc>
        public override object ConvertTo(ITypeDescriptorContext context, CultureInfo culture, object value, Type destinationType) {
            if (destinationType == null) {
                throw new ArgumentNullException("destinationType");
            }

            if (destinationType == typeof(InstanceDescriptor) && value is TimeSpan) {
                MethodInfo method = typeof(TimeSpan).GetMethod("Parse", new Type[] {typeof(string)});
                if (method != null) {
                    return new InstanceDescriptor(method, new object[] {value.ToString()});
                }
            }
            
            return base.ConvertTo(context, culture, value, destinationType);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\toolboxitemfilterattribute.cs ===
//------------------------------------------------------------------------------
// <copyright file="ToolboxItemFilterAttribute.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    
    using System;
    using System.Diagnostics;
 
    /// <include file='doc\ToolboxItemFilterAttribute.uex' path='docs/doc[@for="ToolboxItemFilterAttribute"]/*' />
    /// <devdoc>
    ///     This attribute allows you to configure a filter that is used enable or disable toolbox items
    ///     from being used on particular designers.  For example, you may have a class of components
    ///     that can only be used on a certain type of designer.  You can configure a toolbox item
    ///     filter to enforce that rule.  For example, take a report designer that uses a component
    ///     base class of ReportElement.  You may want to make ReportElement toolbox items enabled only
    ///     when a ReportDesigner is the active designer.  To do this, you would add the following
    ///     ToolboxItemFilter attributes to each class:
    ///
    ///     [ToolboxItemFilter("MyReportFilterString", ToolboxItemFilterType.Require)]
    ///     public class ReportElement : Component {}
    ///
    ///     [ToolboxItemFilter("MyReportFilterString", ToolboxItemFilterType.Require)]
    ///     public class ReportDesigner : Component {}
    ///     
    ///     These two filters specify that ReportElement toolbox items will only be 
    ///     enabled when a ReportDesigner is visible.  By specifying a filter type of
    ///     Require on the report designer class, this will disable any toolbox items
    ///     that are not report elements.  If the report designer specifed a filter type
    ///     of "Allow" instead of "Require", other components would be enabled when the
    ///     report designer was active.  ReportElements would still be disabled when 
    ///     other designers were active, however, because ReportElement requires designers
    ///     to have the given filter string.
    ///
    ///     Toolbox item filtering is a useful way to restrict toolbox item visibility to
    ///     cases where it is appropriate. This can help to avoid confusion for users, but
    ///     you should use caution not to make items unusually restrictive.  If you have a 
    ///     general purpose component, for example, you should allow the component to appear
    ///     on any designer.
    ///
    ///     The ASP.NET and Windows Forms designers both use filter attributes to prevent
    ///     each other's components from being enabled. This is a useful restriction because,
    ///     since each has several duplicate class names, it may be confusing to users and
    ///     they may not know which controls to choose.
    ///     
    /// </devdoc>
    [
    AttributeUsage(AttributeTargets.Class, AllowMultiple=true, Inherited=true),
    Serializable
    ]
    public sealed class ToolboxItemFilterAttribute : Attribute {
        private string                filterString;
        private ToolboxItemFilterType filterType;
        private string                typeId;

        /// <include file='doc\ToolboxItemFilterAttribute.uex' path='docs/doc[@for="ToolboxItemFilterAttribute.ToolboxItemFilterAttribute"]/*' />
        /// <devdoc>
        ///     Initializes a new ToolboxItemFilterAttribute with the provide filter string and a filter type of
        ///     "Allow".
        /// </devdoc>
        public ToolboxItemFilterAttribute(string filterString) : this(filterString, ToolboxItemFilterType.Allow) {
        }
        
        /// <include file='doc\ToolboxItemFilterAttribute.uex' path='docs/doc[@for="ToolboxItemFilterAttribute.ToolboxItemFilterAttribute2"]/*' />
        /// <devdoc>
        ///     Initializes a new ToolboxItemFilterAttribute with the provide filter string and filter type.
        /// </devdoc>
        public ToolboxItemFilterAttribute(string filterString, ToolboxItemFilterType filterType) {
            if (filterString == null) filterString = String.Empty;
            
            this.filterString = filterString;
            this.filterType = filterType;
        }
        
        /// <include file='doc\ToolboxItemFilterAttribute.uex' path='docs/doc[@for="ToolboxItemFilterAttribute.FilterString"]/*' />
        /// <devdoc>
        ///     Retrieves the filter string for this attribute.  The filter string is a user-defined string that
        ///     is used to identify matching attributes.
        /// </devdoc>
        public string FilterString {
            get {
                return filterString;
            }
        }
        
        /// <include file='doc\ToolboxItemFilterAttribute.uex' path='docs/doc[@for="ToolboxItemFilterAttribute.FilterType"]/*' />
        /// <devdoc>
        ///     Retrieves the filter type for this attribute.  The filter type determines how the filter string should
        ///     be applied.
        /// </devdoc>
        public ToolboxItemFilterType FilterType { 
            get {
                return filterType;
            }
        }

        /// <include file='doc\ToolboxItemFilterAttribute.uex' path='docs/doc[@for="ToolboxItemFilterAttribute.TypeId"]/*' />
        /// <devdoc>
        ///     The unique identifier for this attribute.  All ToolboxItemFilterAttributes with the same filter string
        ///     are considered the same, so they return the same TypeId.
        /// </devdoc>
        public override object TypeId {
            get {
                if (typeId == null) {
                    typeId = GetType().FullName + filterString;
                }
                return typeId;
            }
        }

        /// <include file='doc\ToolboxItemFilterAttribute.uex' path='docs/doc[@for="ToolboxItemFilterAttribute.Equals"]/*' />
        public override bool Equals(object obj) {
            if (obj == this) {
                return true;
            }

            ToolboxItemFilterAttribute other = obj as ToolboxItemFilterAttribute;
            return (other != null && other.FilterType.Equals(FilterType) && other.FilterString.Equals(FilterString));
        }

        /// <include file='doc\ToolboxItemFilterAttribute.uex' path='docs/doc[@for="ToolboxItemFilterAttribute.GetHashCode"]/*' />
        public override int GetHashCode() {
            // No need to hash on filter type as well; there shouldn't be that many duplicates.
            return filterString.GetHashCode();
        }
    
        /// <include file='doc\ToolboxItemFilterAttribute.uex' path='docs/doc[@for="ToolboxItemFilterAttribute.Match"]/*' />
        public override bool Match(object obj) {
        
            ToolboxItemFilterAttribute other = obj as ToolboxItemFilterAttribute;
            if (other == null) {
                return false;
            }
            
            // different filter string kills a match immediately.
            //
            if (!other.FilterString.Equals(FilterString)) {
                return false;
            }
            
            return true;
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\syntaxcheck.cs ===
//------------------------------------------------------------------------------
// <copyright file="SyntaxCheck.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

namespace System.ComponentModel {
    using System.Runtime.InteropServices;
    

    using System.Diagnostics;

    using System;
    using System.IO;

    /// <include file='doc\SyntaxCheck.uex' path='docs/doc[@for="SyntaxCheck"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///     SyntaxCheck
    ///     Helper class to check for path and machine name syntax.
    /// </devdoc>
    public class SyntaxCheck {

        // not creatable...
        //
        private SyntaxCheck() {
        }

        /// <include file='doc\SyntaxCheck.uex' path='docs/doc[@for="SyntaxCheck.CheckMachineName"]/*' />
        /// <devdoc>
        ///     Checks the syntax of the machine name (no "\" anywhere in it).
        /// </devdoc>
        /// <internalonly/>
        public static bool CheckMachineName(string value) {
            if (value == null) 
                return false;
            
            value = value.Trim();                
            if (value.Equals(String.Empty))
                return false;
                
            // Machine names shouldn't contain any "\"
            return (value.IndexOf('\\') == -1);
        }

        /// <include file='doc\SyntaxCheck.uex' path='docs/doc[@for="SyntaxCheck.CheckPath"]/*' />
        /// <devdoc>
        ///     Checks the syntax of the path (must start with "\\").
        /// </devdoc>
        /// <internalonly/>
        public static bool CheckPath(string value) {
            if (value == null) 
                return false;
            
            value = value.Trim();                
            if (value.Equals(String.Empty))
                return false;

            // Path names shouldn't start with "\\"
            return value.StartsWith("\\\\");
        }

        /// <include file='doc\SyntaxCheck.uex' path='docs/doc[@for="SyntaxCheck.CheckRootedPath"]/*' />
        /// <devdoc>
        ///     Checks the syntax of the path (must start with "\" or drive letter "C:").
        ///     NOTE:  These denote a file or directory path!!
        ///     
        /// </devdoc>
        /// <internalonly/>
        public static bool CheckRootedPath(string value) {
            if (value == null) 
                return false;
            
            value = value.Trim();                
            if (value.Equals(String.Empty))
                return false;

            // Is it rooted?
            return Path.IsPathRooted(value);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\reflectpropertydescriptor.cs ===
//------------------------------------------------------------------------------
// <copyright file="ReflectPropertyDescriptor.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Runtime.InteropServices;
    using System.Diagnostics;
    using System;
    using System.Collections;
    using System.Collections.Specialized;
    using System.Reflection;
    using Microsoft.Win32;
    using System.Security;
    using System.Security.Permissions;
    using System.ComponentModel.Design;
    using System.ComponentModel;

    /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor"]/*' />
    /// <internalonly/>
    /// <devdoc>
    ///    <para>
    ///       ReflectPropertyDescriptor defines a property. Properties are the main way that a user can
    ///       set up the state of a component.
    ///       The ReflectPropertyDescriptor class takes a component class that the property lives on,
    ///       a property name, the type of the property, and various attributes for the
    ///       property.
    ///       For a property named XXX of type YYY, the associated component class is
    ///       required to implement two methods of the following
    ///       form:
    ///    </para>
    ///    <code>
    /// public YYY GetXXX();
    ///     public void SetXXX(YYY value);
    ///    </code>
    ///    The component class can optionally implement two additional methods of
    ///    the following form:
    ///    <code>
    /// public boolean ShouldSerializeXXX();
    ///     public void ResetXXX();
    ///    </code>
    ///    These methods deal with a property's default value. The ShouldSerializeXXX()
    ///    method returns true if the current value of the XXX property is different
    ///    than it's default value, so that it should be persisted out. The ResetXXX()
    ///    method resets the XXX property to its default value. If the ReflectPropertyDescriptor
    ///    includes the default value of the property (using the DefaultValueAttribute),
    ///    the ShouldSerializeXXX() and ResetXXX() methods are ignored.
    ///    If the ReflectPropertyDescriptor includes a reference to an editor
    ///    then that value editor will be used to
    ///    edit the property. Otherwise, a system-provided editor will be used.
    ///    Various attributes can be passed to the ReflectPropertyDescriptor, as are described in
    ///    Attribute.
    ///    ReflectPropertyDescriptors can be obtained by a user programmatically through the
    ///    ComponentManager.
    /// </devdoc>
    internal sealed class ReflectPropertyDescriptor : PropertyDescriptor {

        private static readonly Type[] argsNone = new Type[0];
        private static readonly object  noValue = new object();
        
        private static TraceSwitch PropDescCreateSwitch = new TraceSwitch("PropDescCreate", "ReflectPropertyDescriptor: Dump errors when creating property info");
        private static TraceSwitch PropDescUsageSwitch  = new TraceSwitch("PropDescUsage", "ReflectPropertyDescriptor: Debug propertydescriptor usage");
        private static TraceSwitch PropDescSwitch       = new TraceSwitch("PropDesc", "ReflectPropertyDescriptor: Debug property descriptor");
        
        private static readonly int BitDefaultValueQueried      = BitVector32.CreateMask();
        private static readonly int BitGetQueried               = BitVector32.CreateMask(BitDefaultValueQueried);
        private static readonly int BitSetQueried               = BitVector32.CreateMask(BitGetQueried);
        private static readonly int BitShouldSerializeQueried   = BitVector32.CreateMask(BitSetQueried);
        private static readonly int BitResetQueried             = BitVector32.CreateMask(BitShouldSerializeQueried);
        private static readonly int BitChangedQueried           = BitVector32.CreateMask(BitResetQueried);
        private static readonly int BitReadOnlyChecked          = BitVector32.CreateMask(BitChangedQueried);
        private static readonly int BitAmbientValueQueried      = BitVector32.CreateMask(BitReadOnlyChecked);

        BitVector32  state = new BitVector32();  // Contains the state bits for this proeprty descriptor.
        Type         componentClass;             // used to determine if we should all on us or on the designer
        Type         type;                       // the data type of the property
        
        object       defaultValue;               // the default value of the property (or noValue)
        object       ambientValue;               // the ambient value of the property (or noValue)
        
        PropertyInfo propInfo;                   // the property info
        MethodInfo   getMethod;                  // the property get method
        MethodInfo   setMethod;                  // the property set method
        
        MethodInfo   shouldSerializeMethod;      // the should serialize method
        MethodInfo   resetMethod;                // the reset property method
        
        EventInfo    realChangedEventInfo;       // Changed event handler on object
        
        Type         receiverType;               // Only set if we are an extender

        /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor.ReflectPropertyDescriptor"]/*' />
        /// <devdoc>
        ///     The main constructor for ReflectPropertyDescriptors.
        /// </devdoc>
        public ReflectPropertyDescriptor(Type componentClass, string name, Type type,
                                         Attribute[] attributes)
        : base(name, attributes) {
        
            Debug.WriteLineIf(PropDescCreateSwitch.TraceVerbose, "Creating ReflectPropertyDescriptor for " + componentClass.FullName + "." + name);
            
            try {
                if (type == null) {
                    Debug.WriteLineIf(PropDescCreateSwitch.TraceVerbose, "type == null, name == " + name);
                    throw new ArgumentException(SR.GetString(SR.ErrorInvalidPropertyType, name));
                }
                if (componentClass == null) {
                    Debug.WriteLineIf(PropDescCreateSwitch.TraceVerbose, "componentClass == null, name == " + name);
                    throw new ArgumentException(SR.GetString(SR.InvalidNullArgument, "componentClass"));
                }
                this.type = type;
                this.componentClass = componentClass;
            }
            catch (Exception t) {
                Debug.Fail("Property '" + name + "' on component " + componentClass.FullName + " failed to init.");
                Debug.Fail(t.ToString());
                throw t;
            }
        }
        
        /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor.ReflectPropertyDescriptor1"]/*' />
        /// <devdoc>
        ///     A constructor for ReflectPropertyDescriptors that have no attributes.
        /// </devdoc>
        public ReflectPropertyDescriptor(Type componentClass, string name, Type type) : this(componentClass, name, type, (Attribute[])null) {
        }
        
        /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor.ReflectPropertyDescriptor2"]/*' />
        /// <devdoc>
        ///     A constructor for ReflectPropertyDescriptors that have no attributes.
        /// </devdoc>
        public ReflectPropertyDescriptor(Type componentClass, string name, Type type, PropertyInfo propInfo, MethodInfo getMethod, MethodInfo setMethod, Attribute[] attrs) : this(componentClass, name, type, attrs) {
            this.propInfo = propInfo;
            this.getMethod = getMethod;
            this.setMethod = setMethod;
            state[BitGetQueried | BitSetQueried] = true;
        }

        /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor.ReflectPropertyDescriptor3"]/*' />
        /// <devdoc>
        ///     A constructor for ReflectPropertyDescriptors that creates an extender property.
        /// </devdoc>
        public ReflectPropertyDescriptor(Type componentClass, string name, Type type, Type receiverType, MethodInfo getMethod, MethodInfo setMethod, Attribute[] attrs) : this(componentClass, name, type, attrs) {
            this.receiverType = receiverType;
            this.getMethod = getMethod;
            this.setMethod = setMethod;
            state[BitGetQueried | BitSetQueried] = true;
        }

        /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor.ReflectPropertyDescriptor4"]/*' />
        /// <devdoc>
        ///     This constructor takes an existing ReflectPropertyDescriptor and modifies it by merging in the
        ///     passed-in attributes.
        /// </devdoc>
        public ReflectPropertyDescriptor(Type componentClass, PropertyDescriptor oldReflectPropertyDescriptor, Attribute[] attributes)
        : base(oldReflectPropertyDescriptor, attributes) {
        
            this.componentClass = componentClass;
            this.type = oldReflectPropertyDescriptor.PropertyType;

            if (componentClass == null) {
                throw new ArgumentException(SR.GetString(SR.InvalidNullArgument, "componentClass"));
            }

            // If the classes are the same, we can potentially optimize the method fetch because
            // the old property descriptor may already have it.
            //
            if (oldReflectPropertyDescriptor is ReflectPropertyDescriptor) {
                ReflectPropertyDescriptor oldProp = (ReflectPropertyDescriptor)oldReflectPropertyDescriptor;
                
                if (oldProp.ComponentType == componentClass) {
                    propInfo = oldProp.propInfo;
                    getMethod = oldProp.getMethod;
                    setMethod = oldProp.setMethod;
                    shouldSerializeMethod = oldProp.shouldSerializeMethod;
                    resetMethod = oldProp.resetMethod;
                    defaultValue = oldProp.defaultValue;
                    ambientValue = oldProp.ambientValue;
                    state = oldProp.state;
                }
                
                // Now we must figure out what to do with our default value.  First, check to see
                // if the caller has provided an new default value attribute.  If so, use it.  Otherwise,
                // just let it be and it will be picked up on demand.
                //
                if (attributes != null) {
                    foreach(Attribute a in attributes) {
                        if (a is DefaultValueAttribute) {
                            defaultValue = ((DefaultValueAttribute)a).Value;
                            state[BitDefaultValueQueried] = true;
                        }
                        else if (a is AmbientValueAttribute) {
                            ambientValue = ((AmbientValueAttribute)a).Value;
                            state[BitAmbientValueQueried] = true;
                        }
                    }
                }
            }
        }

        /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor.AmbientValue"]/*' />
        /// <devdoc>
        ///      Retrieves the ambient value for this property.
        /// </devdoc>
        private object AmbientValue {
            get {
                if (!state[BitAmbientValueQueried]) {
                    state[BitAmbientValueQueried] = true;
                    Attribute a = Attributes[typeof(AmbientValueAttribute)];
                    if (a != null) {
                        ambientValue = ((AmbientValueAttribute)a).Value;
                    }
                    else {
                        ambientValue = noValue;
                    }
                }
                return ambientValue;
            }
        }

        /// <devdoc>
        ///     The EventInfo for the changed event on the component, or null if there isn't one for this property.
        /// </devdoc>
        private EventInfo ChangedEventValue { 
            get {
                if (!state[BitChangedQueried]) {
                    state[BitChangedQueried] = true;
                    realChangedEventInfo = ComponentType.GetEvent(Name + "Changed", BindingFlags.Public | BindingFlags.Instance);
                }
                return realChangedEventInfo;
            }
            set {
                realChangedEventInfo = value;
                state[BitChangedQueried] = true;
            }
        }

        /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor.ComponentType"]/*' />
        /// <devdoc>
        ///     Retrieves the type of the component this PropertyDescriptor is bound to.
        /// </devdoc>
        public override Type ComponentType {
            get {
                return componentClass;
            }
        }

        /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor.DefaultValue"]/*' />
        /// <devdoc>
        ///      Retrieves the default value for this property.
        /// </devdoc>
        private object DefaultValue {
            get {
                if (!state[BitDefaultValueQueried]) {
                    state[BitDefaultValueQueried] = true;
                    Attribute a = Attributes[typeof(DefaultValueAttribute)];
                    if (a != null) {
                        defaultValue = ((DefaultValueAttribute)a).Value;
                    }
                    else {
                        defaultValue = noValue;
                    }
                }
                return defaultValue;
            }
        }

        /// <devdoc>
        ///     The GetMethod for this property
        /// </devdoc>
        private MethodInfo GetMethodValue {
            get {
                if (!state[BitGetQueried]) {
                    state[BitGetQueried] = true;
                    
                    if (receiverType == null) {
                        if (propInfo == null) {
                            BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.GetProperty;
                            propInfo = componentClass.GetProperty(Name, bindingFlags, null, PropertyType, new Type[0], new ParameterModifier[0]);
                        }
                        if (propInfo != null) {
                            getMethod = propInfo.GetGetMethod(true);
                        }
                        if (getMethod == null) {
                            throw new InvalidOperationException(SR.GetString(SR.ErrorMissingPropertyAccessors, componentClass.FullName + "." + Name));
                        }
                    }
                    else {
                        getMethod = FindMethod(componentClass, "Get" + Name, new Type[] {receiverType}, type);
                        if (getMethod == null) {
                            throw new ArgumentException(SR.GetString(SR.ErrorMissingPropertyAccessors, Name));
                        }
                    }
                }
                return getMethod;
            }
            set {
                state[BitGetQueried] = true;
                getMethod = value; 
            } 
        }
        
        /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor.IsExtender"]/*' />
        /// <devdoc>
        ///     Determines if this property is an extender property.
        /// </devdoc>
        private bool IsExtender {
            get {
                return (receiverType != null);
            }
        }

        /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor.IsReadOnly"]/*' />
        /// <devdoc>
        ///     Indicates whether this property is read only.
        /// </devdoc>
        public override bool IsReadOnly {
            get {
                return SetMethodValue == null || ((ReadOnlyAttribute)Attributes[typeof(ReadOnlyAttribute)]).IsReadOnly;
            }
        }

        /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor.PropertyType"]/*' />
        /// <devdoc>
        ///     Retrieves the type of the property.
        /// </devdoc>
        public override Type PropertyType {
            get {
                return type;
            }
        }

        /// <devdoc>
        ///     Access to the reset method, if one exists for this property.
        /// </devdoc>
        private MethodInfo ResetMethodValue {
            get {
                if (!state[BitResetQueried]) {
                    state[BitResetQueried] = true;
                    
                    Type[] args;
                    
                    if (receiverType == null) {
                        args = argsNone;
                    }
                    else {
                        args = new Type[] {receiverType};
                    }
                    
                    IntSecurity.FullReflection.Assert();
                    try {
                        resetMethod = FindMethod(componentClass, "Reset" + Name, args, typeof(void), /* publicOnly= */ false);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }
                return resetMethod; 
            } 
            set {
                state[BitResetQueried] = true;
                resetMethod = value; 
            } 
        }

        /// <devdoc>
        ///     Accessor for the set method
        /// </devdoc>
        private MethodInfo SetMethodValue {
            get {
                if (!state[BitSetQueried]) {
                    state[BitSetQueried] = true;
                    
                    if (receiverType == null) {
                        if (propInfo == null) {
                            BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.Public | BindingFlags.NonPublic | BindingFlags.GetProperty;
                            propInfo = componentClass.GetProperty(Name, bindingFlags, null, PropertyType, new Type[0], new ParameterModifier[0]);
                        }
                        if (propInfo != null) {
                            setMethod = propInfo.GetSetMethod(true);
                        }
                    }
                    else {
                        setMethod = FindMethod(componentClass, "Set" + Name,
                                               new Type[] { receiverType, type}, typeof(void));
                    }
                }
                return setMethod; 
            }
            set {
                state[BitSetQueried] = true;
                setMethod = value; 
            } 
        }
        
        /// <devdoc>
        ///     Accessor for the ShouldSerialize method.
        /// </devdoc>
        private MethodInfo ShouldSerializeMethodValue {
            get {
                if (!state[BitShouldSerializeQueried]) {
                    state[BitShouldSerializeQueried] = true;
                    
                    Type[] args;
                    
                    if (receiverType == null) {
                        args = argsNone;
                    }
                    else {
                        args = new Type[] {receiverType};
                    }
                    
                    IntSecurity.FullReflection.Assert();
                    try {
                        shouldSerializeMethod = FindMethod(componentClass, "ShouldSerialize" + Name,
                                                         args, typeof(Boolean), /* publicOnly= */ false);
                    }
                    finally {
                        CodeAccessPermission.RevertAssert();
                    }
                }
                return shouldSerializeMethod;
            }
            set {
                state[BitShouldSerializeQueried] = true;
                shouldSerializeMethod = value; 
            }
        }
        
        /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor.AddValueChanged"]/*' />
        /// <devdoc>
        ///     Allows interested objects to be notified when this property changes.
        /// </devdoc>
        public override void AddValueChanged(object component, EventHandler handler) {
            if (component == null) throw new ArgumentNullException("component");
            if (handler == null) throw new ArgumentNullException("handler");
            
            EventInfo changedEvent = ChangedEventValue;
            if (changedEvent != null) {
                changedEvent.AddEventHandler(component, handler);
            }
            else {
                base.AddValueChanged(component, handler);
            }
        }

        internal bool ExtenderCanResetValue(IExtenderProvider provider, object component) {
            if (DefaultValue != noValue) {
                return !object.Equals(ExtenderGetValue(provider, component),defaultValue);
            }
            
            MethodInfo reset = ResetMethodValue;
            if (reset != null) {
                MethodInfo shouldSerialize = ShouldSerializeMethodValue;
                if (shouldSerialize != null) {
                    try {
                        provider = (IExtenderProvider)GetInvokee(componentClass, provider);
                        return (bool)shouldSerialize.Invoke(provider, new object[] { component});
                    }
                    catch (Exception) {
                    }
                }
            }
            else {
                return true;
            }
            return false;
        }

        internal Type ExtenderGetReceiverType() {
            return receiverType;
        }

        internal Type ExtenderGetType(IExtenderProvider provider) {
            return PropertyType;
        }

        internal object ExtenderGetValue(IExtenderProvider provider, object component) {
            if (provider != null) {
                provider = (IExtenderProvider)GetInvokee(componentClass, provider);
                return GetMethodValue.Invoke(provider, new object[] { component});
            }
            return null;
        }

        internal void ExtenderResetValue(IExtenderProvider provider, object component, PropertyDescriptor notifyDesc) {
            if (DefaultValue != noValue) {
                ExtenderSetValue(provider, component, DefaultValue, notifyDesc);
            }
            else if (AmbientValue != noValue) {
                ExtenderSetValue(provider, component, AmbientValue, notifyDesc);
            }
            else if (ResetMethodValue != null) {
                ISite site = GetSite(component);
                IComponentChangeService changeService = null;
                object oldValue = null;
                object newValue;

                // Announce that we are about to change this component
                //
                if (site != null) {
                    changeService = (IComponentChangeService)site.GetService(typeof(IComponentChangeService));
                    Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || changeService != null, "IComponentChangeService not found");
                }

                // Make sure that it is ok to send the onchange events
                //
                if (changeService != null) {
                    oldValue = ExtenderGetValue(provider, component);
                    try {
                        changeService.OnComponentChanging(component, notifyDesc);
                    }
                    catch (CheckoutException coEx) {
                        if (coEx == CheckoutException.Canceled) {
                            return;
                        }
                        throw coEx;
                    }
                }

                provider = (IExtenderProvider)GetInvokee(componentClass, provider);
                if (ResetMethodValue != null) {
                    ResetMethodValue.Invoke(provider, new object[] { component});

                    // Now notify the change service that the change was successful.
                    //
                    if (changeService != null) {
                        newValue = ExtenderGetValue(provider, component);
                        changeService.OnComponentChanged(component, notifyDesc, oldValue, newValue);
                    }
                }
            }
        }

        internal void ExtenderSetValue(IExtenderProvider provider, object component, object value, PropertyDescriptor notifyDesc) {
            if (provider != null) {

                ISite site = GetSite(component);
                IComponentChangeService changeService = null;
                object oldValue = null;

                // Announce that we are about to change this component
                //
                if (site != null) {
                    changeService = (IComponentChangeService)site.GetService(typeof(IComponentChangeService));
                    Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || changeService != null, "IComponentChangeService not found");
                }

                // Make sure that it is ok to send the onchange events
                //
                if (changeService != null) {
                    oldValue = ExtenderGetValue(provider, component);
                    try {
                        changeService.OnComponentChanging(component, notifyDesc);
                    }
                    catch (CheckoutException coEx) {
                        if (coEx == CheckoutException.Canceled) {
                            return;
                        }
                        throw coEx;
                    }
                }

                provider = (IExtenderProvider)GetInvokee(componentClass, provider);

                if (SetMethodValue != null) {
                    SetMethodValue.Invoke(provider, new object[] { component, value});

                    // Now notify the change service that the change was successful.
                    //
                    if (changeService != null) {
                        changeService.OnComponentChanged(component, notifyDesc, oldValue, value);
                    }
                }
            }
        }

        internal bool ExtenderShouldSerializeValue(IExtenderProvider provider, object component) {
        

            provider = (IExtenderProvider)GetInvokee(componentClass, provider);

            if (IsReadOnly) {
                if (ShouldSerializeMethodValue != null) {
                    try {
                        return (bool)ShouldSerializeMethodValue.Invoke(provider, new object[] {component});
                    }
                    catch (Exception) {
                    }
                }
                return Attributes.Contains(DesignerSerializationVisibilityAttribute.Content);
            }
            else if (DefaultValue == noValue) {
                if (ShouldSerializeMethodValue != null) {
                    try {
                        return (bool)ShouldSerializeMethodValue.Invoke(provider, new object[] {component});
                    }
                    catch (Exception) {
                    }
                }
                return true;
            }
            return !object.Equals(DefaultValue, ExtenderGetValue(provider, component));
        }

        /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor.CanResetValue"]/*' />
        /// <devdoc>
        ///     Indicates whether reset will change the value of the component.  If there
        ///     is a DefaultValueAttribute, then this will return true if getValue returns
        ///     something different than the default value.  If there is a reset method and
        ///     a ShouldSerialize method, this will return what ShouldSerialize returns.
        ///     If there is just a reset method, this always returns true.  If none of these
        ///     cases apply, this returns false.
        /// </devdoc>
        public override bool CanResetValue(object component) {
            if (IsExtender) {
                return false;
            }

            if (DefaultValue != noValue) {
                return !object.Equals(GetValue(component),DefaultValue);
            }
            
            if (ResetMethodValue != null) {
                if (ShouldSerializeMethodValue != null) {
                    component = GetInvokee(componentClass, component);
                    try {
                        return (bool)ShouldSerializeMethodValue.Invoke(component, null);
                    }
                    catch (Exception) {
                    }
                }
                return true;
            }
            
            if (AmbientValue != noValue) {
                return ShouldSerializeValue(component);
            }
            
            return false;
        }

        protected override void FillAttributes(IList attributes) {
            Debug.Assert(componentClass != null, "Must have a component class for FillAttributes");

            //
            // The order that we fill in attributes is critical.  The list of attributes will be
            // filtered so that matching attributes at the end of the list replace earlier matches
            // (last one in wins).  Therefore, the three categories of attributes we add must be
            // added as follows:
            //
            // 1.  Attributes of the property type.  These are the lowest level and should be
            //     overwritten by any newer attributes.
            //
            // 2.  Attributes of the property itself, from base class to most derived.  This way
            //     derived class attributes replace base class attributes.
            //
            // 3.  Attributes from our base MemberDescriptor.  While this seems opposite of what
            //     we want, MemberDescriptor only has attributes if someone passed in a new
            //     set in the constructor.  Therefore, these attributes always
            //     supercede existing values.
            //
            
            
            // We need to include attributes from the type of the property.
            //
            foreach (Attribute typeAttr in TypeDescriptor.GetAttributes(PropertyType)) {
                attributes.Add(typeAttr);
            }
        
            // NOTE : Must look at method OR property, to handle the case of Extender properties...
            //
            // Note : Because we are using BindingFlags.DeclaredOnly it is more effcient to re-aquire
            //      : the property info, rather than use the one we have cached.  The one we have cached
            //      : may ave come from a base class, meaning we will request custom metadata for this
            //      : class twice.

            BindingFlags bindingFlags = BindingFlags.Instance | BindingFlags.NonPublic | BindingFlags.Public | BindingFlags.DeclaredOnly;
            Type currentReflectType = componentClass;
            int depth = 0;
            
            // First, calculate the depth of the object hierarchy.  We do this so we can do a single
            // object create for an array of attributes.
            //
            while(currentReflectType != null && currentReflectType != typeof(object)) {
                depth++;
                currentReflectType = currentReflectType.BaseType;
            }
            
            // Now build up an array in reverse order
            //
            if (depth > 0) {
                currentReflectType = componentClass;
                object[][] attributeStack = new object[depth][];
                
                while(currentReflectType != null && currentReflectType != typeof(object)) {
                
                    MemberInfo memberInfo = null;
                    
                    // Fill in our member info so we can get at the custom attributes.
                    //
                    if (IsExtender) {
                        memberInfo = currentReflectType.GetMethod("Get" + Name, bindingFlags);
                    }
                    else {
                        memberInfo = currentReflectType.GetProperty(Name, bindingFlags, null, PropertyType, new Type[0], new ParameterModifier[0]);
                    }
                    
                    // Get custom attributes for the member info.
                    //
                    if (memberInfo != null) {
                        attributeStack[--depth] = TypeDescriptor.GetCustomAttributes(memberInfo);
                    }
                    
                    // Ready for the next loop iteration.
                    //
                    currentReflectType = currentReflectType.BaseType;
                }
                   
                // Now trawl the attribute stack so that we add attributes
                // from base class to most derived.
                //
                foreach(object[] attributeArray in attributeStack) {
                    if (attributeArray != null) {
                        foreach(object attr in attributeArray) {
                            if (attr is Attribute) {
                                attributes.Add(attr);
                            }
                        }
                    }
                }
            }
            
            // Include the base attributes.  These override all attributes on the actual
            // property, so we want to add them last.
            //
            base.FillAttributes(attributes);
            
            // Finally, override any form of ReadOnlyAttribute.  
            //
            if (!state[BitReadOnlyChecked]) {
                state[BitReadOnlyChecked] = true;
                if (SetMethodValue == null) {
                    attributes.Add(ReadOnlyAttribute.Yes);
                }
            }
        }
        
        /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor.GetValue"]/*' />
        /// <devdoc>
        ///     Retrieves the current value of the property on component,
        ///     invoking the getXXX method.  An exception in the getXXX
        ///     method will pass through.
        /// </devdoc>
        public override object GetValue(object component) {
#if DEBUG
            if (PropDescUsageSwitch.TraceVerbose) {
                string compName = "(null)";
                if (component != null)
                    compName = component.ToString();

                Debug.WriteLine("[" + Name + "]: GetValue(" + compName + ")");
            }
#endif

            if (IsExtender) {
                Debug.WriteLineIf(PropDescUsageSwitch.TraceVerbose, "[" + Name + "]:   ---> returning: null");
                return null;
            }

            Debug.Assert(component != null, "GetValue must be given a component");

            if (component != null) {
                component = GetInvokee(componentClass, component);
                

                try {
                    return GetMethodValue.Invoke(component, null);
                }
                catch (Exception t) {
                    
                    string name = null;
                    if (component is IComponent) {

                        ISite site = ((IComponent)component).Site;
                        if (site != null && site.Name != null) {
                            name = site.Name;
                        }
                    }
                    
                    if (name == null) {
                        name = component.GetType().FullName;
                    }
                    
                    if (t is TargetInvocationException) {
                        t = t.InnerException;
                    }
                    
                    string message = t.Message;
                    if (message == null) {
                        message = t.GetType().Name;
                    }
                    
                    throw new TargetInvocationException(SR.GetString(SR.ErrorPropertyAccessorException, Name, name, message), t);
                }
            }
            Debug.WriteLineIf(PropDescUsageSwitch.TraceVerbose, "[" + Name + "]:   ---> returning: null");
            return null;
        }

        /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor.OnValueChanged"]/*' />
        /// <devdoc>
        ///     This should be called by your property descriptor implementation
        ///     when the property value has changed.
        /// </devdoc>
        protected override void OnValueChanged(object component, EventArgs e) {
            if (state[BitChangedQueried] && realChangedEventInfo == null) {
                base.OnValueChanged(component, e);
            }
        }

        /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor.RemoveValueChanged"]/*' />
        /// <devdoc>
        ///     Allows interested objects to be notified when this property changes.
        /// </devdoc>
        public override void RemoveValueChanged(object component, EventHandler handler) {
            if (component == null) throw new ArgumentNullException("component");
            if (handler == null) throw new ArgumentNullException("handler");
            
            EventInfo changedEvent = ChangedEventValue;
            if (changedEvent != null) {
                changedEvent.RemoveEventHandler(component, handler);
            }
            else {
                base.RemoveValueChanged(component, handler);
            }
        }

        /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor.ResetValue"]/*' />
        /// <devdoc>
        ///     Will reset the default value for this property on the component.  If
        ///     there was a default value passed in as a DefaultValueAttribute, that
        ///     value will be set as the value of the property on the component.  If
        ///     there was no default value passed in, a ResetXXX method will be looked
        ///     for.  If one is found, it will be invoked.  If one is not found, this
        ///     is a nop.
        /// </devdoc>
        public override void ResetValue(object component) {
            object invokee = GetInvokee(componentClass, component);

            if (DefaultValue != noValue) {
                SetValue(component, DefaultValue);
            }
            else if (AmbientValue != noValue) {
                SetValue(component, AmbientValue);
            }
            else if (ResetMethodValue != null) {
                ISite site = GetSite(component);
                IComponentChangeService changeService = null;
                object oldValue = null;
                object newValue;

                // Announce that we are about to change this component
                //
                if (site != null) {
                    changeService = (IComponentChangeService)site.GetService(typeof(IComponentChangeService));
                    Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || changeService != null, "IComponentChangeService not found");
                }

                // Make sure that it is ok to send the onchange events
                //
                if (changeService != null) {
                    oldValue = GetMethodValue.Invoke(invokee, (object[])null);
                    try {
                        changeService.OnComponentChanging(component, this);
                    }
                    catch (CheckoutException coEx) {
                        if (coEx == CheckoutException.Canceled) {
                            return;
                        }
                        throw coEx;
                    }

                }

                if (ResetMethodValue != null) {
                    ResetMethodValue.Invoke(invokee, (object[])null);

                    // Now notify the change service that the change was successful.
                    //
                    if (changeService != null) {
                        newValue = GetMethodValue.Invoke(invokee, (object[])null);
                        changeService.OnComponentChanged(component, this, oldValue, newValue);
                    }
                }
            }
        }

        /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor.SetValue"]/*' />
        /// <devdoc>
        ///     This will set value to be the new value of this property on the
        ///     component by invoking the setXXX method on the component.  If the
        ///     value specified is invalid, the component should throw an exception
        ///     which will be passed up.  The component designer should design the
        ///     property so that getXXX following a setXXX should return the value
        ///     passed in if no exception was thrown in the setXXX call.
        /// </devdoc>
        public override void SetValue(object component, object value) {
#if DEBUG
            if (PropDescUsageSwitch.TraceVerbose) {
                string compName = "(null)";
                string valName  = "(null)";

                if (component != null)
                    compName = component.ToString();
                if (value != null)
                    valName = value.ToString();

                Debug.WriteLine("[" + Name + "]: SetValue(" + compName + ", " + valName + ")");
            }
#endif
            if (component != null) {
                ISite site = GetSite(component);
                IComponentChangeService changeService = null;
                object oldValue = null;

                object invokee = GetInvokee(componentClass, component);

                Debug.Assert(!IsReadOnly, "SetValue attempted on read-only property [" + Name + "]");
                if (!IsReadOnly) {

                    // Announce that we are about to change this component
                    //
                    if (site != null) {
                        changeService = (IComponentChangeService)site.GetService(typeof(IComponentChangeService));
                        Debug.Assert(!CompModSwitches.CommonDesignerServices.Enabled || changeService != null, "IComponentChangeService not found");
                    }


                    // Make sure that it is ok to send the onchange events
                    //
                    if (changeService != null) {
                        oldValue = GetMethodValue.Invoke(invokee, null);
                        try {
                            changeService.OnComponentChanging(component, this);
                        }
                        catch (CheckoutException coEx) {
                            if (coEx == CheckoutException.Canceled) {
                                return;
                            }
                            throw coEx;
                        }
                    }

                    try {
                        try {
                            SetMethodValue.Invoke(invokee, new object[]{value});
                            OnValueChanged(invokee, EventArgs.Empty);
                        }
                        catch (Exception t) {
                            // Give ourselves a chance to unwind properly before rethrowing the exception (bug# 20221).
                            //
                            value = oldValue;
                            
                            // If there was a problem setting the controls property then we get:
                            // ArgumentException (from properties set method)
                            // ==> Becomes inner exception of TargetInvocationException
                            // ==> caught here

                            if (t is TargetInvocationException && t.InnerException != null) {
                                // Propagate the original exception up
                                throw t.InnerException;
                            }
                            else {
                                throw t;
                            }
                        }
                    }
                    finally {
                        // Now notify the change service that the change was successful.
                        //
                        if (changeService != null) {
                            changeService.OnComponentChanged(component, this, oldValue, value);
                        }
                    }
                }
            }
        }

        /// <include file='doc\ReflectPropertyDescriptor.uex' path='docs/doc[@for="ReflectPropertyDescriptor.ShouldSerializeValue"]/*' />
        /// <devdoc>
        ///     Indicates whether the value of this property needs to be persisted. In
        ///     other words, it indicates whether the state of the property is distinct
        ///     from when the component is first instantiated. If there is a default
        ///     value specified in this ReflectPropertyDescriptor, it will be compared against the
        ///     property's current value to determine this.  If there is't, the
        ///     ShouldSerializeXXX method is looked for and invoked if found.  If both
        ///     these routes fail, true will be returned.
        ///
        ///     If this returns false, a tool should not persist this property's value.
        /// </devdoc>
        public override bool ShouldSerializeValue(object component) {

            component = GetInvokee(componentClass, component);

            if (IsReadOnly) {
                if (ShouldSerializeMethodValue != null) {
                    try {
                        return (bool)ShouldSerializeMethodValue.Invoke(component, null);
                    }
                    catch (Exception) {
                    }
                }
                return Attributes.Contains(DesignerSerializationVisibilityAttribute.Content);
            }
            else if (DefaultValue == noValue) {
                if (ShouldSerializeMethodValue != null) {
                    try {
                        return (bool)ShouldSerializeMethodValue.Invoke(component, null);
                    }
                    catch (Exception) {
                    }
                }
                return true;
            }
            return !object.Equals(DefaultValue, GetValue(component));
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\Win2K3\NT\com\netfx\src\framework\compmod\system\componentmodel\singleconverter.cs ===
//------------------------------------------------------------------------------
// <copyright file="SingleConverter.cs" company="Microsoft">
//     Copyright (c) Microsoft Corporation.  All rights reserved.
// </copyright>                                                                
//------------------------------------------------------------------------------

/*
 */
namespace System.ComponentModel {
    using System.Runtime.Serialization.Formatters;
    using System.Globalization;
    using System.Runtime.Remoting;
    using System.Runtime.InteropServices;
    

    using System.Diagnostics;

    using Microsoft.Win32;

    /// <include file='doc\SingleConverter.uex' path='docs/doc[@for="SingleConverter"]/*' />
    /// <devdoc>
    ///    <para> Provides a type
    ///       converter to convert single-precision, floating point number objects to and from various other
    ///       representations.</para>
    /// </devdoc>
    public class SingleConverter : BaseNumberConverter {
    
          
        /// <include file='doc\SingleConverter.uex' path='docs/doc[@for="SingleConverter.AllowHex"]/*' />
        /// <devdoc>
        /// Determines whether this editor will attempt to convert hex (0x or #) strings
        /// </devdoc>
        internal override bool AllowHex {
                get {
                     return false;
                }
        }
    
         /// <include file='doc\SingleConverter.uex' path='docs/doc[@for="SingleConverter.TargetType"]/*' />
         /// <devdoc>
        /// The Type this converter is targeting (e.g. Int16, UInt32, etc.)
        /// </devdoc>
        internal override Type TargetType {
                get {
                    return typeof(Single);
                }
        }

        /// <include file='doc\SingleConverter.uex' path='docs/doc[@for="SingleConverter.FromString"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given radix
        /// </devdoc>
        internal override object FromString(string value, int radix) {
                return Convert.ToSingle(value);
        }
        
        /// <include file='doc\SingleConverter.uex' path='docs/doc[@for="SingleConverter.FromString1"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given formatInfo
        /// </devdoc>
        internal override object FromString(string value, NumberFormatInfo formatInfo) {
                return Single.Parse(value, NumberStyles.Float, formatInfo);
        }
        
        
        /// <include file='doc\SingleConverter.uex' path='docs/doc[@for="SingleConverter.FromString2"]/*' />
        /// <devdoc>
        /// Convert the given value to a string using the given CultureInfo
        /// </devdoc>
        int